"use strict";(self.webpackChunk_revideo_docs=self.webpackChunk_revideo_docs||[]).push([[7237],{8621:(e,n,t)=>{t.d(n,{A:()=>u});var o=t(4041),p=t(2663),r=t(7473),s=t(9082);const c={admonition:"admonition_qNG0",admonitionHeading:"admonitionHeading_l909",admonitionIcon:"admonitionIcon_UNbs",admonitionContent:"admonitionContent_oUmQ"};const a={note:{infimaClassName:"secondary",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 14 16"},o.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))},label:o.createElement(s.A,{id:"theme.admonition.note",description:"The default label used for the Note admonition (:::note)"},"note")},tip:{infimaClassName:"success",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 12 16"},o.createElement("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))},label:o.createElement(s.A,{id:"theme.admonition.tip",description:"The default label used for the Tip admonition (:::tip)"},"tip")},danger:{infimaClassName:"danger",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 12 16"},o.createElement("path",{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))},label:o.createElement(s.A,{id:"theme.admonition.danger",description:"The default label used for the Danger admonition (:::danger)"},"danger")},info:{infimaClassName:"info",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 14 16"},o.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))},label:o.createElement(s.A,{id:"theme.admonition.info",description:"The default label used for the Info admonition (:::info)"},"info")},caution:{infimaClassName:"warning",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 16 16"},o.createElement("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))},label:o.createElement(s.A,{id:"theme.admonition.caution",description:"The default label used for the Caution admonition (:::caution)"},"caution")}},i={secondary:"note",important:"info",success:"tip",warning:"danger"};function l(e){const{mdxAdmonitionTitle:n,rest:t}=function(e){const n=o.Children.toArray(e),t=n.find((e=>o.isValidElement(e)&&"mdxAdmonitionTitle"===e.props?.mdxType)),p=o.createElement(o.Fragment,null,n.filter((e=>e!==t)));return{mdxAdmonitionTitle:t,rest:p}}(e.children);return{...e,title:e.title??n,children:t}}function u(e){const{children:n,type:t,title:s,icon:u}=l(e),m=function(e){const n=i[e]??e,t=a[n];return t||(console.warn(`No admonition config found for admonition type "${n}". Using Info as fallback.`),a.info)}(t),y=s??m.label,{iconComponent:d}=m,h=u??o.createElement(d,null);return o.createElement("div",{className:(0,p.A)(r.G.common.admonition,r.G.common.admonitionType(e.type),"alert",`alert--${m.infimaClassName}`,c.admonition)},o.createElement("div",{className:c.admonitionHeading},o.createElement("span",{className:c.admonitionIcon},h),y),o.createElement("div",{className:c.admonitionContent},n))}},4441:(e,n,t)=>{t.d(n,{A:()=>l});var o=t(9575),p=t(4041),r=t(2663),s=t(9082),c=t(2520),a=t(9631);const i={anchorWithStickyNavbar:"anchorWithStickyNavbar_fF9Z",anchorWithHideOnScrollNavbar:"anchorWithHideOnScrollNavbar_Yh18"};function l(e){let{as:n,id:t,...l}=e;const{navbar:{hideOnScroll:u}}=(0,c.p)();if("h1"===n||!t)return p.createElement(n,(0,o.A)({},l,{id:void 0}));const m=(0,s.T)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof l.children?l.children:t});return p.createElement(n,(0,o.A)({},l,{className:(0,r.A)("anchor",u?i.anchorWithHideOnScrollNavbar:i.anchorWithStickyNavbar,l.className),id:t}),l.children,p.createElement(a.A,{className:"hash-link",to:`#${t}`,"aria-label":m,title:m},"\u200b"))}},5906:(e,n,t)=>{t.d(n,{A:()=>u});var o=t(9531),p=t(53),r=t(4041),s=t(9631),c=t(9575);function a(e){let{width:n=24,height:t=24,...o}=e;return r.createElement("svg",(0,c.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0},o),r.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}const i={container:"container_lQCo",small:"small_As57",banner:"banner_A4QS",player:"player_tELG",link:"link_BTzN",icon:"icon_wSGd"};function l(e){let{name:n}=e;const t=`https://github.com/revideo/revideo/blob/main/packages/examples/src/scenes/${n}.tsx`;return r.createElement(s.A,{to:t,className:(0,p.A)("padding--sm",i.link)},r.createElement("span",null,"View source code"),r.createElement(a,{className:i.icon}))}function u(e){let{name:n,banner:t,small:o,link:s}=e;return r.createElement("div",{className:(0,p.A)(i.container,t&&i.banner,o&&i.small)},r.createElement("revideo-player",{class:i.player,src:`/examples/${n}.js`,auto:t}),r.createElement(l,{name:s||n}))}o.A.canUseDOM&&t.e(3980).then(t.bind(t,3980))},9987:(e,n,t)=>{t.d(n,{A:()=>s});var o=t(1125),p=t(8675),r=t(4041);function s(e){let{url:n}=e;const t=(0,p.Fx)()(n);return r.createElement(o.A,{reflection:t,headless:!0})}},6048:(e,n,t)=>{t.d(n,{A:()=>gbr});var o={};t.r(o),t.d(o,{content_0_0:()=>i,content_0_10:()=>C,content_0_100:()=>Jn,content_0_1000:()=>ev,content_0_1002:()=>ov,content_0_1004:()=>sv,content_0_1006:()=>iv,content_0_1008:()=>mv,content_0_1010:()=>hv,content_0_1012:()=>Dv,content_0_1014:()=>_v,content_0_1016:()=>Cv,content_0_1018:()=>vv,content_0_102:()=>nt,content_0_1020:()=>Nv,content_0_1022:()=>Pv,content_0_1024:()=>Wv,content_0_1026:()=>Gv,content_0_1028:()=>Uv,content_0_1030:()=>qv,content_0_1032:()=>Yv,content_0_1034:()=>Kv,content_0_1036:()=>eL,content_0_1038:()=>oL,content_0_104:()=>pt,content_0_1040:()=>sL,content_0_1042:()=>iL,content_0_1044:()=>mL,content_0_1046:()=>hL,content_0_1048:()=>DL,content_0_1050:()=>_L,content_0_1052:()=>CL,content_0_1054:()=>vL,content_0_1056:()=>NL,content_0_1058:()=>PL,content_0_106:()=>ct,content_0_1060:()=>WL,content_0_1062:()=>GL,content_0_1064:()=>UL,content_0_1066:()=>qL,content_0_1068:()=>YL,content_0_1070:()=>KL,content_0_1072:()=>eb,content_0_1074:()=>ob,content_0_1076:()=>sb,content_0_1078:()=>ib,content_0_108:()=>lt,content_0_1080:()=>mb,content_0_1082:()=>hb,content_0_1084:()=>Db,content_0_1086:()=>_b,content_0_1088:()=>Cb,content_0_1090:()=>vb,content_0_1092:()=>Nb,content_0_1094:()=>Pb,content_0_1096:()=>Wb,content_0_1098:()=>Gb,content_0_110:()=>yt,content_0_1100:()=>Ub,content_0_1102:()=>qb,content_0_1104:()=>Yb,content_0_1106:()=>Kb,content_0_1108:()=>eN,content_0_1110:()=>oN,content_0_1112:()=>sN,content_0_1114:()=>iN,content_0_1116:()=>mN,content_0_1118:()=>hN,content_0_112:()=>gt,content_0_1120:()=>DN,content_0_1122:()=>_N,content_0_1124:()=>CN,content_0_1126:()=>vN,content_0_1128:()=>NN,content_0_1130:()=>PN,content_0_1132:()=>WN,content_0_1134:()=>GN,content_0_1136:()=>UN,content_0_1138:()=>qN,content_0_114:()=>Mt,content_0_1140:()=>YN,content_0_1142:()=>KN,content_0_1144:()=>ek,content_0_1146:()=>ok,content_0_1148:()=>sk,content_0_1150:()=>ik,content_0_1152:()=>mk,content_0_1154:()=>hk,content_0_1156:()=>Dk,content_0_1158:()=>_k,content_0_116:()=>wt,content_0_1160:()=>Ck,content_0_1162:()=>vk,content_0_1164:()=>Nk,content_0_1166:()=>Pk,content_0_1168:()=>Wk,content_0_1170:()=>Gk,content_0_1172:()=>Uk,content_0_1174:()=>qk,content_0_1176:()=>Yk,content_0_1178:()=>Kk,content_0_118:()=>xt,content_0_1180:()=>ez,content_0_1182:()=>oz,content_0_1184:()=>sz,content_0_1186:()=>iz,content_0_1188:()=>mz,content_0_1190:()=>hz,content_0_1192:()=>Dz,content_0_1194:()=>_z,content_0_1196:()=>Cz,content_0_1198:()=>vz,content_0_12:()=>v,content_0_120:()=>Lt,content_0_1200:()=>Nz,content_0_1202:()=>Pz,content_0_1204:()=>Wz,content_0_1206:()=>Gz,content_0_1208:()=>Uz,content_0_1210:()=>qz,content_0_1212:()=>Yz,content_0_1214:()=>Kz,content_0_1216:()=>eP,content_0_1218:()=>oP,content_0_122:()=>kt,content_0_1220:()=>sP,content_0_1222:()=>iP,content_0_1224:()=>mP,content_0_1226:()=>hP,content_0_1228:()=>DP,content_0_1230:()=>_P,content_0_1232:()=>CP,content_0_1234:()=>vP,content_0_1236:()=>NP,content_0_1238:()=>PP,content_0_124:()=>It,content_0_1240:()=>WP,content_0_1242:()=>GP,content_0_1244:()=>UP,content_0_1246:()=>qP,content_0_1248:()=>YP,content_0_1250:()=>KP,content_0_1252:()=>eI,content_0_1254:()=>oI,content_0_1256:()=>sI,content_0_1258:()=>iI,content_0_126:()=>St,content_0_1260:()=>mI,content_0_1262:()=>hI,content_0_1264:()=>DI,content_0_1266:()=>_I,content_0_1268:()=>CI,content_0_1270:()=>vI,content_0_1272:()=>NI,content_0_1274:()=>PI,content_0_1276:()=>WI,content_0_1278:()=>GI,content_0_128:()=>Et,content_0_1280:()=>UI,content_0_1282:()=>qI,content_0_1284:()=>YI,content_0_1286:()=>KI,content_0_1288:()=>eR,content_0_1290:()=>oR,content_0_1292:()=>sR,content_0_1294:()=>iR,content_0_1296:()=>mR,content_0_1298:()=>hR,content_0_130:()=>Ft,content_0_1300:()=>DR,content_0_1302:()=>_R,content_0_1304:()=>CR,content_0_1306:()=>vR,content_0_1308:()=>NR,content_0_1310:()=>PR,content_0_1312:()=>WR,content_0_1314:()=>GR,content_0_1316:()=>UR,content_0_1318:()=>qR,content_0_132:()=>jt,content_0_1320:()=>YR,content_0_1322:()=>KR,content_0_1324:()=>eW,content_0_1326:()=>oW,content_0_1328:()=>sW,content_0_1330:()=>iW,content_0_1332:()=>mW,content_0_1334:()=>hW,content_0_1336:()=>DW,content_0_1338:()=>_W,content_0_134:()=>Qt,content_0_1340:()=>CW,content_0_1342:()=>vW,content_0_1344:()=>NW,content_0_1346:()=>PW,content_0_1348:()=>WW,content_0_1350:()=>GW,content_0_1352:()=>UW,content_0_1354:()=>qW,content_0_1356:()=>YW,content_0_1358:()=>KW,content_0_136:()=>Jt,content_0_1360:()=>eS,content_0_1362:()=>oS,content_0_1364:()=>sS,content_0_1366:()=>iS,content_0_1368:()=>mS,content_0_1370:()=>hS,content_0_1372:()=>DS,content_0_1374:()=>_S,content_0_1376:()=>CS,content_0_1378:()=>vS,content_0_138:()=>no,content_0_1380:()=>NS,content_0_1382:()=>PS,content_0_1384:()=>WS,content_0_1386:()=>GS,content_0_1388:()=>US,content_0_1390:()=>qS,content_0_1392:()=>YS,content_0_1394:()=>KS,content_0_1396:()=>eB,content_0_1398:()=>oB,content_0_14:()=>N,content_0_140:()=>po,content_0_1400:()=>sB,content_0_1402:()=>iB,content_0_1404:()=>mB,content_0_1406:()=>hB,content_0_1408:()=>DB,content_0_1410:()=>_B,content_0_1412:()=>CB,content_0_1414:()=>vB,content_0_1416:()=>NB,content_0_1418:()=>PB,content_0_142:()=>co,content_0_1420:()=>WB,content_0_1422:()=>GB,content_0_1424:()=>UB,content_0_1426:()=>qB,content_0_1428:()=>YB,content_0_1430:()=>KB,content_0_1432:()=>eG,content_0_1434:()=>oG,content_0_1436:()=>sG,content_0_1438:()=>iG,content_0_144:()=>lo,content_0_1440:()=>mG,content_0_1442:()=>hG,content_0_1444:()=>DG,content_0_1446:()=>_G,content_0_1448:()=>CG,content_0_1450:()=>vG,content_0_1452:()=>NG,content_0_1454:()=>PG,content_0_1456:()=>WG,content_0_1458:()=>GG,content_0_146:()=>yo,content_0_1460:()=>UG,content_0_1462:()=>qG,content_0_1464:()=>YG,content_0_1466:()=>KG,content_0_1468:()=>eE,content_0_1470:()=>oE,content_0_1472:()=>sE,content_0_1474:()=>iE,content_0_1476:()=>mE,content_0_1478:()=>hE,content_0_148:()=>fo,content_0_1480:()=>DE,content_0_1482:()=>_E,content_0_1484:()=>CE,content_0_1486:()=>vE,content_0_1488:()=>NE,content_0_1490:()=>PE,content_0_1492:()=>WE,content_0_1494:()=>GE,content_0_1496:()=>UE,content_0_1498:()=>qE,content_0_150:()=>Xo,content_0_1500:()=>YE,content_0_1502:()=>KE,content_0_1504:()=>eO,content_0_1506:()=>oO,content_0_1508:()=>sO,content_0_1510:()=>iO,content_0_1512:()=>mO,content_0_1514:()=>hO,content_0_1516:()=>DO,content_0_1518:()=>_O,content_0_152:()=>To,content_0_1520:()=>CO,content_0_1522:()=>vO,content_0_1524:()=>NO,content_0_1526:()=>PO,content_0_1528:()=>WO,content_0_1530:()=>GO,content_0_1532:()=>UO,content_0_1534:()=>qO,content_0_1536:()=>YO,content_0_1538:()=>KO,content_0_154:()=>Ao,content_0_1540:()=>eU,content_0_1542:()=>oU,content_0_1544:()=>sU,content_0_1546:()=>iU,content_0_1548:()=>mU,content_0_1550:()=>hU,content_0_1552:()=>DU,content_0_1554:()=>_U,content_0_1556:()=>CU,content_0_1558:()=>vU,content_0_156:()=>bo,content_0_1560:()=>NU,content_0_1562:()=>PU,content_0_1564:()=>WU,content_0_1566:()=>GU,content_0_1568:()=>UU,content_0_1570:()=>qU,content_0_1572:()=>YU,content_0_1574:()=>KU,content_0_1576:()=>eF,content_0_1578:()=>oF,content_0_158:()=>zo,content_0_1580:()=>sF,content_0_1582:()=>iF,content_0_1584:()=>mF,content_0_1586:()=>hF,content_0_1588:()=>DF,content_0_1590:()=>_F,content_0_1592:()=>CF,content_0_1594:()=>vF,content_0_1596:()=>NF,content_0_1598:()=>PF,content_0_16:()=>P,content_0_160:()=>Ro,content_0_1600:()=>WF,content_0_1602:()=>GF,content_0_1604:()=>UF,content_0_1606:()=>qF,content_0_1608:()=>YF,content_0_1610:()=>KF,content_0_1612:()=>eV,content_0_1614:()=>oV,content_0_1616:()=>sV,content_0_1618:()=>iV,content_0_162:()=>Bo,content_0_1620:()=>mV,content_0_1622:()=>hV,content_0_1624:()=>DV,content_0_1626:()=>_V,content_0_1628:()=>CV,content_0_1630:()=>vV,content_0_1632:()=>NV,content_0_1634:()=>PV,content_0_1636:()=>WV,content_0_1638:()=>GV,content_0_164:()=>Oo,content_0_1640:()=>UV,content_0_1642:()=>qV,content_0_1644:()=>YV,content_0_1646:()=>KV,content_0_1648:()=>eq,content_0_1650:()=>oq,content_0_1652:()=>sq,content_0_1654:()=>iq,content_0_1656:()=>mq,content_0_1658:()=>hq,content_0_166:()=>Vo,content_0_1660:()=>Dq,content_0_1662:()=>_q,content_0_1664:()=>Cq,content_0_1666:()=>vq,content_0_1668:()=>Nq,content_0_1670:()=>Pq,content_0_1672:()=>Wq,content_0_1674:()=>Gq,content_0_1676:()=>Uq,content_0_1678:()=>qq,content_0_168:()=>Ho,content_0_1680:()=>Yq,content_0_1682:()=>Kq,content_0_1684:()=>ej,content_0_1686:()=>oj,content_0_1688:()=>sj,content_0_1690:()=>ij,content_0_1692:()=>mj,content_0_1694:()=>hj,content_0_1696:()=>Dj,content_0_1698:()=>_j,content_0_170:()=>$o,content_0_1700:()=>Cj,content_0_1702:()=>vj,content_0_1704:()=>Nj,content_0_1706:()=>Pj,content_0_1708:()=>Wj,content_0_1710:()=>Gj,content_0_1712:()=>Uj,content_0_1714:()=>qj,content_0_1716:()=>Yj,content_0_1718:()=>Kj,content_0_172:()=>Zo,content_0_1720:()=>eH,content_0_1722:()=>oH,content_0_1724:()=>sH,content_0_1726:()=>iH,content_0_1728:()=>mH,content_0_1730:()=>hH,content_0_1732:()=>DH,content_0_1734:()=>_H,content_0_1736:()=>CH,content_0_1738:()=>vH,content_0_174:()=>tp,content_0_1740:()=>NH,content_0_1742:()=>PH,content_0_1744:()=>WH,content_0_1746:()=>GH,content_0_1748:()=>UH,content_0_1750:()=>qH,content_0_1752:()=>YH,content_0_1754:()=>KH,content_0_1756:()=>eY,content_0_1758:()=>oY,content_0_176:()=>rp,content_0_1760:()=>sY,content_0_1762:()=>iY,content_0_1764:()=>mY,content_0_1766:()=>hY,content_0_1768:()=>DY,content_0_1770:()=>_Y,content_0_1772:()=>CY,content_0_1774:()=>vY,content_0_1776:()=>NY,content_0_1778:()=>PY,content_0_178:()=>ap,content_0_1780:()=>WY,content_0_1782:()=>GY,content_0_1784:()=>UY,content_0_1786:()=>qY,content_0_1788:()=>YY,content_0_1790:()=>KY,content_0_1792:()=>eQ,content_0_1794:()=>oQ,content_0_1796:()=>sQ,content_0_1798:()=>iQ,content_0_18:()=>W,content_0_180:()=>up,content_0_1800:()=>mQ,content_0_1802:()=>hQ,content_0_1804:()=>DQ,content_0_1806:()=>_Q,content_0_1808:()=>CQ,content_0_1810:()=>vQ,content_0_1812:()=>NQ,content_0_1814:()=>PQ,content_0_1816:()=>WQ,content_0_1818:()=>GQ,content_0_182:()=>dp,content_0_1820:()=>UQ,content_0_1822:()=>qQ,content_0_1824:()=>YQ,content_0_1826:()=>KQ,content_0_1828:()=>e$,content_0_1830:()=>o$,content_0_1832:()=>s$,content_0_1834:()=>i$,content_0_1836:()=>m$,content_0_1838:()=>h$,content_0_184:()=>fp,content_0_1840:()=>D$,content_0_1842:()=>_$,content_0_1844:()=>C$,content_0_1846:()=>v$,content_0_1848:()=>N$,content_0_1850:()=>P$,content_0_1852:()=>W$,content_0_1854:()=>G$,content_0_1856:()=>U$,content_0_1858:()=>q$,content_0_186:()=>Xp,content_0_1860:()=>Y$,content_0_1862:()=>K$,content_0_1864:()=>eK,content_0_1866:()=>oK,content_0_1868:()=>sK,content_0_1870:()=>iK,content_0_1872:()=>mK,content_0_1874:()=>hK,content_0_1876:()=>DK,content_0_1878:()=>_K,content_0_188:()=>Tp,content_0_1880:()=>CK,content_0_1882:()=>vK,content_0_1884:()=>NK,content_0_1886:()=>PK,content_0_1888:()=>WK,content_0_190:()=>Ap,content_0_192:()=>bp,content_0_194:()=>zp,content_0_196:()=>Rp,content_0_198:()=>Bp,content_0_2:()=>m,content_0_20:()=>G,content_0_200:()=>Op,content_0_202:()=>Vp,content_0_204:()=>Hp,content_0_206:()=>$p,content_0_208:()=>Zp,content_0_210:()=>tr,content_0_212:()=>rr,content_0_214:()=>ar,content_0_216:()=>ur,content_0_218:()=>dr,content_0_22:()=>U,content_0_220:()=>fr,content_0_222:()=>Xr,content_0_224:()=>Tr,content_0_226:()=>Ar,content_0_228:()=>br,content_0_230:()=>zr,content_0_232:()=>Rr,content_0_234:()=>Br,content_0_236:()=>Or,content_0_238:()=>Vr,content_0_24:()=>q,content_0_240:()=>Hr,content_0_242:()=>$r,content_0_244:()=>Zr,content_0_246:()=>ts,content_0_248:()=>rs,content_0_250:()=>as,content_0_252:()=>us,content_0_254:()=>ds,content_0_256:()=>fs,content_0_258:()=>Xs,content_0_26:()=>Y,content_0_260:()=>Ts,content_0_262:()=>As,content_0_264:()=>bs,content_0_266:()=>zs,content_0_268:()=>Rs,content_0_270:()=>Bs,content_0_272:()=>Os,content_0_274:()=>Vs,content_0_276:()=>Hs,content_0_278:()=>$s,content_0_28:()=>K,content_0_280:()=>Zs,content_0_282:()=>tc,content_0_284:()=>rc,content_0_286:()=>ac,content_0_288:()=>uc,content_0_290:()=>dc,content_0_292:()=>fc,content_0_294:()=>Xc,content_0_296:()=>Tc,content_0_298:()=>Ac,content_0_30:()=>ee,content_0_300:()=>bc,content_0_302:()=>zc,content_0_304:()=>Rc,content_0_306:()=>Bc,content_0_308:()=>Oc,content_0_310:()=>Vc,content_0_312:()=>Hc,content_0_314:()=>$c,content_0_316:()=>Zc,content_0_318:()=>ta,content_0_32:()=>oe,content_0_320:()=>ra,content_0_322:()=>aa,content_0_324:()=>ua,content_0_326:()=>da,content_0_328:()=>fa,content_0_330:()=>Xa,content_0_332:()=>Ta,content_0_334:()=>Aa,content_0_336:()=>ba,content_0_338:()=>za,content_0_34:()=>se,content_0_340:()=>Ra,content_0_342:()=>Ba,content_0_344:()=>Oa,content_0_346:()=>Va,content_0_348:()=>Ha,content_0_350:()=>$a,content_0_352:()=>Za,content_0_354:()=>ti,content_0_356:()=>ri,content_0_358:()=>ai,content_0_36:()=>ie,content_0_360:()=>ui,content_0_362:()=>di,content_0_364:()=>fi,content_0_366:()=>Xi,content_0_368:()=>Ti,content_0_370:()=>Ai,content_0_372:()=>bi,content_0_374:()=>zi,content_0_376:()=>Ri,content_0_378:()=>Bi,content_0_38:()=>me,content_0_380:()=>Oi,content_0_382:()=>Vi,content_0_384:()=>Hi,content_0_386:()=>$i,content_0_388:()=>Zi,content_0_390:()=>tl,content_0_392:()=>rl,content_0_394:()=>al,content_0_396:()=>ul,content_0_398:()=>dl,content_0_4:()=>h,content_0_40:()=>he,content_0_400:()=>fl,content_0_402:()=>Xl,content_0_404:()=>Tl,content_0_406:()=>Al,content_0_408:()=>bl,content_0_410:()=>zl,content_0_412:()=>Rl,content_0_414:()=>Bl,content_0_416:()=>Ol,content_0_418:()=>Vl,content_0_42:()=>De,content_0_420:()=>Hl,content_0_422:()=>$l,content_0_424:()=>Zl,content_0_426:()=>tu,content_0_428:()=>ru,content_0_430:()=>au,content_0_432:()=>uu,content_0_434:()=>du,content_0_436:()=>fu,content_0_438:()=>Xu,content_0_44:()=>_e,content_0_440:()=>Tu,content_0_442:()=>Au,content_0_444:()=>bu,content_0_446:()=>zu,content_0_448:()=>Ru,content_0_450:()=>Bu,content_0_452:()=>Ou,content_0_454:()=>Vu,content_0_456:()=>Hu,content_0_458:()=>$u,content_0_46:()=>Ce,content_0_460:()=>Zu,content_0_462:()=>tm,content_0_464:()=>rm,content_0_466:()=>am,content_0_468:()=>um,content_0_470:()=>dm,content_0_472:()=>fm,content_0_474:()=>Xm,content_0_476:()=>Tm,content_0_478:()=>Am,content_0_48:()=>ve,content_0_480:()=>bm,content_0_482:()=>zm,content_0_484:()=>Rm,content_0_486:()=>Bm,content_0_488:()=>Om,content_0_490:()=>Vm,content_0_492:()=>Hm,content_0_494:()=>$m,content_0_496:()=>Zm,content_0_498:()=>ty,content_0_50:()=>Ne,content_0_500:()=>ry,content_0_502:()=>ay,content_0_504:()=>uy,content_0_506:()=>dy,content_0_508:()=>fy,content_0_510:()=>Xy,content_0_512:()=>Ty,content_0_514:()=>Ay,content_0_516:()=>by,content_0_518:()=>zy,content_0_52:()=>Pe,content_0_520:()=>Ry,content_0_522:()=>By,content_0_524:()=>Oy,content_0_526:()=>Vy,content_0_528:()=>Hy,content_0_530:()=>$y,content_0_532:()=>Zy,content_0_534:()=>td,content_0_536:()=>rd,content_0_538:()=>ad,content_0_54:()=>We,content_0_540:()=>ud,content_0_542:()=>dd,content_0_544:()=>fd,content_0_546:()=>Xd,content_0_548:()=>Td,content_0_550:()=>Ad,content_0_552:()=>bd,content_0_554:()=>zd,content_0_556:()=>Rd,content_0_558:()=>Bd,content_0_56:()=>Ge,content_0_560:()=>Od,content_0_562:()=>Vd,content_0_564:()=>Hd,content_0_566:()=>$d,content_0_568:()=>Zd,content_0_570:()=>th,content_0_572:()=>rh,content_0_574:()=>ah,content_0_576:()=>uh,content_0_578:()=>dh,content_0_58:()=>Ue,content_0_580:()=>fh,content_0_582:()=>Xh,content_0_584:()=>Th,content_0_586:()=>Ah,content_0_588:()=>bh,content_0_590:()=>zh,content_0_592:()=>Rh,content_0_594:()=>Bh,content_0_596:()=>Oh,content_0_598:()=>Vh,content_0_6:()=>D,content_0_60:()=>qe,content_0_600:()=>Hh,content_0_602:()=>$h,content_0_604:()=>Zh,content_0_606:()=>tg,content_0_608:()=>rg,content_0_610:()=>ag,content_0_612:()=>ug,content_0_614:()=>dg,content_0_616:()=>fg,content_0_618:()=>Xg,content_0_62:()=>Ye,content_0_620:()=>Tg,content_0_622:()=>Ag,content_0_624:()=>bg,content_0_626:()=>zg,content_0_628:()=>Rg,content_0_630:()=>Bg,content_0_632:()=>Og,content_0_634:()=>Vg,content_0_636:()=>Hg,content_0_638:()=>$g,content_0_64:()=>Ke,content_0_640:()=>Zg,content_0_642:()=>tf,content_0_644:()=>rf,content_0_646:()=>af,content_0_648:()=>mf,content_0_650:()=>hf,content_0_652:()=>Df,content_0_654:()=>_f,content_0_656:()=>Cf,content_0_658:()=>vf,content_0_66:()=>en,content_0_660:()=>Nf,content_0_662:()=>Pf,content_0_664:()=>Wf,content_0_666:()=>Gf,content_0_668:()=>Uf,content_0_670:()=>qf,content_0_672:()=>Yf,content_0_674:()=>Kf,content_0_676:()=>eD,content_0_678:()=>oD,content_0_68:()=>on,content_0_680:()=>sD,content_0_682:()=>iD,content_0_684:()=>mD,content_0_686:()=>hD,content_0_688:()=>DD,content_0_690:()=>_D,content_0_692:()=>CD,content_0_694:()=>vD,content_0_696:()=>ND,content_0_698:()=>PD,content_0_70:()=>sn,content_0_700:()=>WD,content_0_702:()=>GD,content_0_704:()=>UD,content_0_706:()=>qD,content_0_708:()=>YD,content_0_710:()=>KD,content_0_712:()=>eM,content_0_714:()=>oM,content_0_716:()=>sM,content_0_718:()=>iM,content_0_72:()=>ln,content_0_720:()=>mM,content_0_722:()=>hM,content_0_724:()=>DM,content_0_726:()=>_M,content_0_728:()=>CM,content_0_730:()=>vM,content_0_732:()=>NM,content_0_734:()=>PM,content_0_736:()=>WM,content_0_738:()=>GM,content_0_74:()=>yn,content_0_740:()=>UM,content_0_742:()=>qM,content_0_744:()=>YM,content_0_746:()=>KM,content_0_748:()=>eX,content_0_750:()=>oX,content_0_752:()=>sX,content_0_754:()=>iX,content_0_756:()=>mX,content_0_758:()=>hX,content_0_76:()=>gn,content_0_760:()=>DX,content_0_762:()=>_X,content_0_764:()=>CX,content_0_766:()=>vX,content_0_768:()=>NX,content_0_770:()=>PX,content_0_772:()=>WX,content_0_774:()=>GX,content_0_776:()=>UX,content_0_778:()=>qX,content_0_78:()=>Mn,content_0_780:()=>YX,content_0_782:()=>KX,content_0_784:()=>e_,content_0_786:()=>o_,content_0_788:()=>s_,content_0_790:()=>i_,content_0_792:()=>m_,content_0_794:()=>h_,content_0_796:()=>D_,content_0_798:()=>__,content_0_8:()=>_,content_0_80:()=>wn,content_0_800:()=>C_,content_0_802:()=>v_,content_0_804:()=>N_,content_0_806:()=>P_,content_0_808:()=>W_,content_0_810:()=>G_,content_0_812:()=>U_,content_0_814:()=>q_,content_0_816:()=>Y_,content_0_818:()=>K_,content_0_82:()=>xn,content_0_820:()=>ew,content_0_822:()=>ow,content_0_824:()=>sw,content_0_826:()=>iw,content_0_828:()=>mw,content_0_830:()=>hw,content_0_832:()=>Dw,content_0_834:()=>_w,content_0_836:()=>Cw,content_0_838:()=>vw,content_0_84:()=>Ln,content_0_840:()=>Nw,content_0_842:()=>Pw,content_0_844:()=>Ww,content_0_846:()=>Gw,content_0_848:()=>Uw,content_0_850:()=>qw,content_0_852:()=>Yw,content_0_854:()=>Kw,content_0_856:()=>eT,content_0_858:()=>oT,content_0_86:()=>kn,content_0_860:()=>sT,content_0_862:()=>iT,content_0_864:()=>mT,content_0_866:()=>hT,content_0_868:()=>DT,content_0_870:()=>_T,content_0_872:()=>CT,content_0_874:()=>vT,content_0_876:()=>NT,content_0_878:()=>PT,content_0_88:()=>In,content_0_880:()=>WT,content_0_882:()=>GT,content_0_884:()=>UT,content_0_886:()=>qT,content_0_888:()=>YT,content_0_890:()=>KT,content_0_892:()=>eC,content_0_894:()=>oC,content_0_896:()=>sC,content_0_898:()=>iC,content_0_90:()=>Sn,content_0_900:()=>mC,content_0_902:()=>hC,content_0_904:()=>DC,content_0_906:()=>_C,content_0_908:()=>CC,content_0_910:()=>vC,content_0_912:()=>NC,content_0_914:()=>PC,content_0_916:()=>WC,content_0_918:()=>GC,content_0_92:()=>En,content_0_920:()=>UC,content_0_922:()=>qC,content_0_924:()=>YC,content_0_926:()=>KC,content_0_928:()=>ex,content_0_930:()=>ox,content_0_932:()=>sx,content_0_934:()=>ix,content_0_936:()=>mx,content_0_938:()=>hx,content_0_94:()=>Fn,content_0_940:()=>Dx,content_0_942:()=>_x,content_0_944:()=>Cx,content_0_946:()=>vx,content_0_948:()=>Nx,content_0_950:()=>Px,content_0_952:()=>Wx,content_0_954:()=>Gx,content_0_956:()=>Ux,content_0_958:()=>qx,content_0_96:()=>jn,content_0_960:()=>Yx,content_0_962:()=>Kx,content_0_964:()=>eA,content_0_966:()=>oA,content_0_968:()=>sA,content_0_970:()=>iA,content_0_972:()=>mA,content_0_974:()=>hA,content_0_976:()=>DA,content_0_978:()=>_A,content_0_98:()=>Qn,content_0_980:()=>CA,content_0_982:()=>vA,content_0_984:()=>NA,content_0_986:()=>PA,content_0_988:()=>WA,content_0_990:()=>GA,content_0_992:()=>UA,content_0_994:()=>qA,content_0_996:()=>YA,content_0_998:()=>KA,content_3833_0:()=>GK,content_3833_10:()=>eJ,content_3833_100:()=>v0,content_3833_1000:()=>vhe,content_3833_10000:()=>Lip,content_3833_10002:()=>kip,content_3833_10004:()=>Iip,content_3833_10006:()=>Sip,content_3833_10008:()=>Eip,content_3833_10010:()=>Fip,content_3833_10012:()=>jip,content_3833_10014:()=>Qip,content_3833_10016:()=>Jip,content_3833_10018:()=>nlp,content_3833_1002:()=>Nhe,content_3833_10020:()=>plp,content_3833_10022:()=>clp,content_3833_10024:()=>llp,content_3833_10026:()=>ylp,content_3833_10028:()=>glp,content_3833_10030:()=>Mlp,content_3833_10032:()=>wlp,content_3833_10034:()=>xlp,content_3833_10036:()=>Llp,content_3833_10038:()=>klp,content_3833_1004:()=>Phe,content_3833_10040:()=>Ilp,content_3833_10042:()=>Slp,content_3833_10044:()=>Elp,content_3833_10046:()=>Flp,content_3833_10048:()=>jlp,content_3833_10050:()=>Qlp,content_3833_10052:()=>Jlp,content_3833_10054:()=>nup,content_3833_10056:()=>pup,content_3833_10058:()=>cup,content_3833_1006:()=>Whe,content_3833_10060:()=>lup,content_3833_10062:()=>yup,content_3833_10064:()=>gup,content_3833_10066:()=>Mup,content_3833_10068:()=>wup,content_3833_10070:()=>xup,content_3833_10072:()=>Lup,content_3833_10074:()=>kup,content_3833_10076:()=>Iup,content_3833_10078:()=>Sup,content_3833_1008:()=>Ghe,content_3833_10080:()=>Eup,content_3833_10082:()=>Fup,content_3833_10084:()=>jup,content_3833_10086:()=>Qup,content_3833_10088:()=>Jup,content_3833_10090:()=>nmp,content_3833_10092:()=>pmp,content_3833_10094:()=>cmp,content_3833_10096:()=>lmp,content_3833_10098:()=>ymp,content_3833_1010:()=>Uhe,content_3833_10100:()=>gmp,content_3833_10102:()=>Mmp,content_3833_10104:()=>wmp,content_3833_10106:()=>xmp,content_3833_10108:()=>Lmp,content_3833_10110:()=>kmp,content_3833_10112:()=>Imp,content_3833_10114:()=>Smp,content_3833_10116:()=>Emp,content_3833_10118:()=>Fmp,content_3833_1012:()=>qhe,content_3833_10120:()=>jmp,content_3833_10122:()=>Qmp,content_3833_10124:()=>Jmp,content_3833_10126:()=>nyp,content_3833_10128:()=>pyp,content_3833_10130:()=>cyp,content_3833_10132:()=>lyp,content_3833_10134:()=>yyp,content_3833_10136:()=>gyp,content_3833_10138:()=>Myp,content_3833_1014:()=>Yhe,content_3833_10140:()=>wyp,content_3833_10142:()=>xyp,content_3833_10144:()=>Lyp,content_3833_10146:()=>kyp,content_3833_10148:()=>Iyp,content_3833_10150:()=>Syp,content_3833_10152:()=>Eyp,content_3833_10154:()=>Fyp,content_3833_10156:()=>jyp,content_3833_10158:()=>Qyp,content_3833_1016:()=>Khe,content_3833_10160:()=>Jyp,content_3833_10162:()=>ndp,content_3833_10164:()=>pdp,content_3833_10166:()=>cdp,content_3833_10168:()=>ldp,content_3833_10170:()=>ydp,content_3833_10172:()=>gdp,content_3833_10174:()=>Mdp,content_3833_10176:()=>wdp,content_3833_10178:()=>xdp,content_3833_1018:()=>ege,content_3833_10180:()=>Ldp,content_3833_10182:()=>kdp,content_3833_10184:()=>Idp,content_3833_10186:()=>Sdp,content_3833_10188:()=>Edp,content_3833_10190:()=>Fdp,content_3833_10192:()=>jdp,content_3833_10194:()=>Qdp,content_3833_10196:()=>Jdp,content_3833_10198:()=>nhp,content_3833_102:()=>N0,content_3833_1020:()=>oge,content_3833_10200:()=>php,content_3833_10202:()=>chp,content_3833_10204:()=>lhp,content_3833_10206:()=>yhp,content_3833_10208:()=>ghp,content_3833_10210:()=>Mhp,content_3833_10212:()=>whp,content_3833_10214:()=>xhp,content_3833_10216:()=>Lhp,content_3833_10218:()=>khp,content_3833_1022:()=>sge,content_3833_10220:()=>Ihp,content_3833_10222:()=>Shp,content_3833_10224:()=>Ehp,content_3833_10226:()=>Fhp,content_3833_10228:()=>jhp,content_3833_10230:()=>Qhp,content_3833_10232:()=>Jhp,content_3833_10234:()=>ngp,content_3833_10236:()=>pgp,content_3833_10238:()=>cgp,content_3833_1024:()=>ige,content_3833_10240:()=>lgp,content_3833_10242:()=>ygp,content_3833_10244:()=>ggp,content_3833_10246:()=>Mgp,content_3833_10248:()=>wgp,content_3833_10250:()=>xgp,content_3833_10252:()=>Lgp,content_3833_10254:()=>kgp,content_3833_10256:()=>Igp,content_3833_10258:()=>Sgp,content_3833_1026:()=>mge,content_3833_10260:()=>Egp,content_3833_10262:()=>Fgp,content_3833_10264:()=>jgp,content_3833_10266:()=>Qgp,content_3833_10268:()=>Jgp,content_3833_10270:()=>nfp,content_3833_10272:()=>pfp,content_3833_10274:()=>cfp,content_3833_10276:()=>lfp,content_3833_10278:()=>yfp,content_3833_1028:()=>hge,content_3833_10280:()=>gfp,content_3833_10282:()=>Mfp,content_3833_10284:()=>wfp,content_3833_10286:()=>xfp,content_3833_10288:()=>Lfp,content_3833_10290:()=>kfp,content_3833_10292:()=>Ifp,content_3833_10294:()=>Sfp,content_3833_10296:()=>Efp,content_3833_10298:()=>Ffp,content_3833_1030:()=>Dge,content_3833_10300:()=>jfp,content_3833_10302:()=>Qfp,content_3833_10304:()=>Jfp,content_3833_10306:()=>nDp,content_3833_10308:()=>pDp,content_3833_10310:()=>cDp,content_3833_10312:()=>lDp,content_3833_10314:()=>yDp,content_3833_10316:()=>gDp,content_3833_10318:()=>MDp,content_3833_1032:()=>_ge,content_3833_10320:()=>wDp,content_3833_10322:()=>xDp,content_3833_10324:()=>LDp,content_3833_10326:()=>kDp,content_3833_10328:()=>IDp,content_3833_10330:()=>SDp,content_3833_10332:()=>EDp,content_3833_10334:()=>FDp,content_3833_10336:()=>jDp,content_3833_10338:()=>QDp,content_3833_1034:()=>Cge,content_3833_10340:()=>JDp,content_3833_10342:()=>nMp,content_3833_10344:()=>pMp,content_3833_10346:()=>cMp,content_3833_10348:()=>lMp,content_3833_10350:()=>yMp,content_3833_10352:()=>gMp,content_3833_10354:()=>MMp,content_3833_10356:()=>wMp,content_3833_10358:()=>xMp,content_3833_1036:()=>vge,content_3833_10360:()=>LMp,content_3833_10362:()=>kMp,content_3833_10364:()=>IMp,content_3833_10366:()=>SMp,content_3833_10368:()=>EMp,content_3833_10370:()=>FMp,content_3833_10372:()=>jMp,content_3833_10374:()=>QMp,content_3833_10376:()=>JMp,content_3833_10378:()=>nXp,content_3833_1038:()=>Nge,content_3833_10380:()=>pXp,content_3833_10382:()=>cXp,content_3833_10384:()=>lXp,content_3833_10386:()=>yXp,content_3833_10388:()=>gXp,content_3833_10390:()=>MXp,content_3833_10392:()=>wXp,content_3833_10394:()=>xXp,content_3833_10396:()=>LXp,content_3833_10398:()=>kXp,content_3833_104:()=>P0,content_3833_1040:()=>Pge,content_3833_10400:()=>IXp,content_3833_10402:()=>SXp,content_3833_10404:()=>EXp,content_3833_10406:()=>FXp,content_3833_10408:()=>jXp,content_3833_10410:()=>QXp,content_3833_10412:()=>JXp,content_3833_10414:()=>n_p,content_3833_10416:()=>p_p,content_3833_10418:()=>c_p,content_3833_1042:()=>Wge,content_3833_10420:()=>l_p,content_3833_10422:()=>y_p,content_3833_10424:()=>g_p,content_3833_10426:()=>M_p,content_3833_10428:()=>w_p,content_3833_10430:()=>x_p,content_3833_10432:()=>L_p,content_3833_10434:()=>k_p,content_3833_10436:()=>I_p,content_3833_10438:()=>S_p,content_3833_1044:()=>Gge,content_3833_10440:()=>E_p,content_3833_10442:()=>F_p,content_3833_10444:()=>j_p,content_3833_10446:()=>Q_p,content_3833_10448:()=>J_p,content_3833_10450:()=>nwp,content_3833_10452:()=>pwp,content_3833_10454:()=>cwp,content_3833_10456:()=>lwp,content_3833_10458:()=>ywp,content_3833_1046:()=>Uge,content_3833_10460:()=>gwp,content_3833_10462:()=>Mwp,content_3833_10464:()=>wwp,content_3833_10466:()=>xwp,content_3833_10468:()=>Lwp,content_3833_10470:()=>kwp,content_3833_10472:()=>Iwp,content_3833_10474:()=>Swp,content_3833_10476:()=>Ewp,content_3833_10478:()=>Fwp,content_3833_1048:()=>qge,content_3833_10480:()=>jwp,content_3833_10482:()=>Qwp,content_3833_10484:()=>Jwp,content_3833_10486:()=>nTp,content_3833_10488:()=>pTp,content_3833_10490:()=>cTp,content_3833_10492:()=>lTp,content_3833_10494:()=>yTp,content_3833_10496:()=>gTp,content_3833_10498:()=>MTp,content_3833_1050:()=>Yge,content_3833_10500:()=>wTp,content_3833_10502:()=>xTp,content_3833_10504:()=>LTp,content_3833_10506:()=>kTp,content_3833_10508:()=>ITp,content_3833_10510:()=>STp,content_3833_10512:()=>ETp,content_3833_10514:()=>FTp,content_3833_10516:()=>jTp,content_3833_10518:()=>QTp,content_3833_1052:()=>Kge,content_3833_10520:()=>JTp,content_3833_10522:()=>nCp,content_3833_10524:()=>pCp,content_3833_10526:()=>cCp,content_3833_10528:()=>lCp,content_3833_10530:()=>yCp,content_3833_10532:()=>gCp,content_3833_10534:()=>MCp,content_3833_10536:()=>wCp,content_3833_10538:()=>xCp,content_3833_1054:()=>efe,content_3833_10540:()=>LCp,content_3833_10542:()=>kCp,content_3833_10544:()=>ICp,content_3833_10546:()=>SCp,content_3833_10548:()=>ECp,content_3833_10550:()=>FCp,content_3833_10552:()=>jCp,content_3833_10554:()=>QCp,content_3833_10556:()=>JCp,content_3833_10558:()=>nxp,content_3833_1056:()=>ofe,content_3833_10560:()=>pxp,content_3833_10562:()=>cxp,content_3833_10564:()=>lxp,content_3833_10566:()=>yxp,content_3833_10568:()=>gxp,content_3833_10570:()=>Mxp,content_3833_10572:()=>wxp,content_3833_10574:()=>xxp,content_3833_10576:()=>Lxp,content_3833_10578:()=>kxp,content_3833_1058:()=>sfe,content_3833_10580:()=>Ixp,content_3833_10582:()=>Sxp,content_3833_10584:()=>Exp,content_3833_10586:()=>Fxp,content_3833_10588:()=>jxp,content_3833_10590:()=>Qxp,content_3833_10592:()=>Jxp,content_3833_10594:()=>nAp,content_3833_10596:()=>pAp,content_3833_10598:()=>cAp,content_3833_106:()=>W0,content_3833_1060:()=>ife,content_3833_10600:()=>lAp,content_3833_10602:()=>yAp,content_3833_10604:()=>gAp,content_3833_10606:()=>MAp,content_3833_10608:()=>wAp,content_3833_10610:()=>xAp,content_3833_10612:()=>LAp,content_3833_10614:()=>kAp,content_3833_10616:()=>IAp,content_3833_10618:()=>SAp,content_3833_1062:()=>mfe,content_3833_10620:()=>EAp,content_3833_10622:()=>FAp,content_3833_10624:()=>jAp,content_3833_10626:()=>QAp,content_3833_10628:()=>JAp,content_3833_10630:()=>nvp,content_3833_10632:()=>pvp,content_3833_10634:()=>cvp,content_3833_10636:()=>lvp,content_3833_10638:()=>yvp,content_3833_1064:()=>hfe,content_3833_10640:()=>gvp,content_3833_10642:()=>Mvp,content_3833_10644:()=>wvp,content_3833_10646:()=>xvp,content_3833_10648:()=>Lvp,content_3833_10650:()=>kvp,content_3833_10652:()=>Ivp,content_3833_10654:()=>Svp,content_3833_10656:()=>Evp,content_3833_10658:()=>Fvp,content_3833_1066:()=>Dfe,content_3833_10660:()=>jvp,content_3833_10662:()=>Qvp,content_3833_10664:()=>Jvp,content_3833_10666:()=>nLp,content_3833_10668:()=>pLp,content_3833_10670:()=>cLp,content_3833_10672:()=>lLp,content_3833_10674:()=>yLp,content_3833_10676:()=>gLp,content_3833_10678:()=>MLp,content_3833_1068:()=>_fe,content_3833_10680:()=>wLp,content_3833_10682:()=>xLp,content_3833_10684:()=>LLp,content_3833_10686:()=>kLp,content_3833_10688:()=>ILp,content_3833_10690:()=>SLp,content_3833_10692:()=>ELp,content_3833_10694:()=>FLp,content_3833_10696:()=>jLp,content_3833_10698:()=>QLp,content_3833_1070:()=>Cfe,content_3833_10700:()=>JLp,content_3833_10702:()=>nbp,content_3833_10704:()=>pbp,content_3833_10706:()=>cbp,content_3833_10708:()=>lbp,content_3833_10710:()=>ybp,content_3833_10712:()=>gbp,content_3833_10714:()=>Mbp,content_3833_10716:()=>wbp,content_3833_10718:()=>xbp,content_3833_1072:()=>vfe,content_3833_10720:()=>Lbp,content_3833_10722:()=>kbp,content_3833_10724:()=>Ibp,content_3833_10726:()=>Sbp,content_3833_10728:()=>Ebp,content_3833_10730:()=>Fbp,content_3833_10732:()=>jbp,content_3833_10734:()=>Qbp,content_3833_10736:()=>Jbp,content_3833_10738:()=>nNp,content_3833_1074:()=>Nfe,content_3833_10740:()=>pNp,content_3833_10742:()=>cNp,content_3833_10744:()=>lNp,content_3833_10746:()=>yNp,content_3833_10748:()=>gNp,content_3833_10750:()=>MNp,content_3833_10752:()=>wNp,content_3833_10754:()=>xNp,content_3833_10756:()=>LNp,content_3833_10758:()=>kNp,content_3833_1076:()=>Pfe,content_3833_10760:()=>INp,content_3833_10762:()=>SNp,content_3833_10764:()=>ENp,content_3833_10766:()=>FNp,content_3833_10768:()=>jNp,content_3833_10770:()=>QNp,content_3833_10772:()=>JNp,content_3833_10774:()=>nkp,content_3833_10776:()=>pkp,content_3833_10778:()=>ckp,content_3833_1078:()=>Wfe,content_3833_10780:()=>lkp,content_3833_10782:()=>ykp,content_3833_10784:()=>gkp,content_3833_10786:()=>Mkp,content_3833_10788:()=>wkp,content_3833_10790:()=>xkp,content_3833_10792:()=>Lkp,content_3833_10794:()=>kkp,content_3833_10796:()=>Ikp,content_3833_10798:()=>Skp,content_3833_108:()=>G0,content_3833_1080:()=>Gfe,content_3833_10800:()=>Ekp,content_3833_10802:()=>Fkp,content_3833_10804:()=>jkp,content_3833_10806:()=>Qkp,content_3833_10808:()=>Jkp,content_3833_10810:()=>nzp,content_3833_10812:()=>pzp,content_3833_10814:()=>czp,content_3833_10816:()=>lzp,content_3833_10818:()=>yzp,content_3833_1082:()=>Ufe,content_3833_10820:()=>gzp,content_3833_10822:()=>Mzp,content_3833_10824:()=>wzp,content_3833_10826:()=>xzp,content_3833_10828:()=>Lzp,content_3833_10830:()=>kzp,content_3833_10832:()=>Izp,content_3833_10834:()=>Szp,content_3833_10836:()=>Ezp,content_3833_10838:()=>Fzp,content_3833_1084:()=>qfe,content_3833_10840:()=>jzp,content_3833_10842:()=>Qzp,content_3833_10844:()=>Jzp,content_3833_10846:()=>nPp,content_3833_10848:()=>pPp,content_3833_10850:()=>cPp,content_3833_10852:()=>lPp,content_3833_10854:()=>yPp,content_3833_10856:()=>gPp,content_3833_10858:()=>MPp,content_3833_1086:()=>Yfe,content_3833_10860:()=>wPp,content_3833_10862:()=>xPp,content_3833_10864:()=>LPp,content_3833_10866:()=>kPp,content_3833_10868:()=>IPp,content_3833_10870:()=>SPp,content_3833_10872:()=>EPp,content_3833_10874:()=>FPp,content_3833_10876:()=>jPp,content_3833_10878:()=>QPp,content_3833_1088:()=>Kfe,content_3833_10880:()=>JPp,content_3833_10882:()=>nIp,content_3833_10884:()=>pIp,content_3833_10886:()=>cIp,content_3833_10888:()=>lIp,content_3833_10890:()=>yIp,content_3833_10892:()=>gIp,content_3833_10894:()=>MIp,content_3833_10896:()=>wIp,content_3833_10898:()=>xIp,content_3833_1090:()=>eDe,content_3833_10900:()=>LIp,content_3833_10902:()=>kIp,content_3833_10904:()=>IIp,content_3833_10906:()=>SIp,content_3833_10908:()=>EIp,content_3833_10910:()=>FIp,content_3833_10912:()=>jIp,content_3833_10914:()=>QIp,content_3833_10916:()=>JIp,content_3833_10918:()=>nRp,content_3833_1092:()=>oDe,content_3833_10920:()=>pRp,content_3833_10922:()=>cRp,content_3833_10924:()=>lRp,content_3833_10926:()=>yRp,content_3833_10928:()=>gRp,content_3833_10930:()=>MRp,content_3833_10932:()=>wRp,content_3833_10934:()=>xRp,content_3833_10936:()=>LRp,content_3833_10938:()=>kRp,content_3833_1094:()=>sDe,content_3833_10940:()=>IRp,content_3833_10942:()=>SRp,content_3833_10944:()=>ERp,content_3833_10946:()=>FRp,content_3833_10948:()=>jRp,content_3833_10950:()=>QRp,content_3833_10952:()=>JRp,content_3833_10954:()=>nWp,content_3833_10956:()=>pWp,content_3833_10958:()=>cWp,content_3833_1096:()=>iDe,content_3833_10960:()=>lWp,content_3833_10962:()=>yWp,content_3833_10964:()=>gWp,content_3833_10966:()=>MWp,content_3833_10968:()=>wWp,content_3833_10970:()=>xWp,content_3833_10972:()=>LWp,content_3833_10974:()=>kWp,content_3833_10976:()=>IWp,content_3833_10978:()=>SWp,content_3833_1098:()=>mDe,content_3833_10980:()=>EWp,content_3833_10982:()=>FWp,content_3833_10984:()=>jWp,content_3833_10986:()=>QWp,content_3833_10988:()=>JWp,content_3833_10990:()=>nSp,content_3833_10992:()=>pSp,content_3833_10994:()=>cSp,content_3833_10996:()=>lSp,content_3833_10998:()=>ySp,content_3833_110:()=>U0,content_3833_1100:()=>hDe,content_3833_11000:()=>gSp,content_3833_11002:()=>MSp,content_3833_11004:()=>wSp,content_3833_11006:()=>xSp,content_3833_11008:()=>LSp,content_3833_11010:()=>kSp,content_3833_11012:()=>ISp,content_3833_11014:()=>SSp,content_3833_11016:()=>ESp,content_3833_11018:()=>FSp,content_3833_1102:()=>DDe,content_3833_11020:()=>jSp,content_3833_11022:()=>QSp,content_3833_11024:()=>JSp,content_3833_11026:()=>nBp,content_3833_11028:()=>pBp,content_3833_11030:()=>cBp,content_3833_11032:()=>lBp,content_3833_11034:()=>yBp,content_3833_11036:()=>gBp,content_3833_11038:()=>MBp,content_3833_1104:()=>_De,content_3833_11040:()=>wBp,content_3833_11042:()=>xBp,content_3833_11044:()=>LBp,content_3833_11046:()=>kBp,content_3833_11048:()=>IBp,content_3833_11050:()=>SBp,content_3833_11052:()=>EBp,content_3833_11054:()=>FBp,content_3833_11056:()=>jBp,content_3833_11058:()=>QBp,content_3833_1106:()=>CDe,content_3833_11060:()=>JBp,content_3833_11062:()=>nGp,content_3833_11064:()=>pGp,content_3833_11066:()=>cGp,content_3833_11068:()=>lGp,content_3833_11070:()=>yGp,content_3833_11072:()=>gGp,content_3833_11074:()=>MGp,content_3833_11076:()=>wGp,content_3833_11078:()=>xGp,content_3833_1108:()=>vDe,content_3833_11080:()=>LGp,content_3833_11082:()=>kGp,content_3833_11084:()=>IGp,content_3833_11086:()=>SGp,content_3833_11088:()=>EGp,content_3833_11090:()=>FGp,content_3833_11092:()=>jGp,content_3833_11094:()=>QGp,content_3833_11096:()=>JGp,content_3833_11098:()=>nEp,content_3833_1110:()=>NDe,content_3833_11100:()=>pEp,content_3833_11102:()=>cEp,content_3833_11104:()=>lEp,content_3833_11106:()=>yEp,content_3833_11108:()=>gEp,content_3833_11110:()=>MEp,content_3833_11112:()=>wEp,content_3833_11114:()=>xEp,content_3833_11116:()=>LEp,content_3833_11118:()=>kEp,content_3833_1112:()=>PDe,content_3833_11120:()=>IEp,content_3833_11122:()=>SEp,content_3833_11124:()=>EEp,content_3833_11126:()=>FEp,content_3833_11128:()=>jEp,content_3833_11130:()=>QEp,content_3833_11132:()=>JEp,content_3833_11134:()=>nOp,content_3833_11136:()=>pOp,content_3833_11138:()=>cOp,content_3833_1114:()=>WDe,content_3833_11140:()=>lOp,content_3833_11142:()=>yOp,content_3833_11144:()=>gOp,content_3833_11146:()=>MOp,content_3833_11148:()=>wOp,content_3833_11150:()=>xOp,content_3833_11152:()=>LOp,content_3833_11154:()=>kOp,content_3833_11156:()=>IOp,content_3833_11158:()=>SOp,content_3833_1116:()=>GDe,content_3833_11160:()=>EOp,content_3833_11162:()=>FOp,content_3833_11164:()=>jOp,content_3833_11166:()=>QOp,content_3833_11168:()=>JOp,content_3833_11170:()=>nUp,content_3833_11172:()=>pUp,content_3833_11174:()=>cUp,content_3833_11176:()=>lUp,content_3833_11178:()=>yUp,content_3833_1118:()=>UDe,content_3833_11180:()=>gUp,content_3833_11182:()=>MUp,content_3833_11184:()=>wUp,content_3833_11186:()=>xUp,content_3833_11188:()=>LUp,content_3833_11190:()=>kUp,content_3833_11192:()=>IUp,content_3833_11194:()=>SUp,content_3833_11196:()=>EUp,content_3833_11198:()=>FUp,content_3833_112:()=>q0,content_3833_1120:()=>qDe,content_3833_11200:()=>jUp,content_3833_11202:()=>QUp,content_3833_11204:()=>JUp,content_3833_11206:()=>nFp,content_3833_11208:()=>pFp,content_3833_11210:()=>cFp,content_3833_11212:()=>lFp,content_3833_11214:()=>yFp,content_3833_11216:()=>gFp,content_3833_11218:()=>MFp,content_3833_1122:()=>YDe,content_3833_11220:()=>wFp,content_3833_11222:()=>xFp,content_3833_11224:()=>LFp,content_3833_11226:()=>kFp,content_3833_11228:()=>IFp,content_3833_11230:()=>SFp,content_3833_11232:()=>EFp,content_3833_11234:()=>FFp,content_3833_11236:()=>jFp,content_3833_11238:()=>QFp,content_3833_1124:()=>KDe,content_3833_11240:()=>JFp,content_3833_11242:()=>nVp,content_3833_11244:()=>pVp,content_3833_11246:()=>cVp,content_3833_11248:()=>lVp,content_3833_11250:()=>yVp,content_3833_11252:()=>gVp,content_3833_11254:()=>MVp,content_3833_11256:()=>wVp,content_3833_11258:()=>xVp,content_3833_1126:()=>eMe,content_3833_11260:()=>LVp,content_3833_11262:()=>kVp,content_3833_11264:()=>IVp,content_3833_11266:()=>SVp,content_3833_11268:()=>EVp,content_3833_11270:()=>FVp,content_3833_11272:()=>jVp,content_3833_11274:()=>QVp,content_3833_11276:()=>JVp,content_3833_11278:()=>nqp,content_3833_1128:()=>oMe,content_3833_11280:()=>pqp,content_3833_11282:()=>cqp,content_3833_11284:()=>lqp,content_3833_11286:()=>yqp,content_3833_11288:()=>gqp,content_3833_11290:()=>Mqp,content_3833_11292:()=>wqp,content_3833_11294:()=>xqp,content_3833_11296:()=>Lqp,content_3833_11298:()=>kqp,content_3833_1130:()=>sMe,content_3833_11300:()=>Iqp,content_3833_11302:()=>Sqp,content_3833_11304:()=>Eqp,content_3833_11306:()=>Fqp,content_3833_11308:()=>jqp,content_3833_11310:()=>Qqp,content_3833_11312:()=>Jqp,content_3833_11314:()=>njp,content_3833_11316:()=>pjp,content_3833_11318:()=>cjp,content_3833_1132:()=>iMe,content_3833_11320:()=>ljp,content_3833_11322:()=>yjp,content_3833_11324:()=>gjp,content_3833_11326:()=>Mjp,content_3833_11328:()=>wjp,content_3833_11330:()=>xjp,content_3833_11332:()=>Ljp,content_3833_11334:()=>kjp,content_3833_11336:()=>Ijp,content_3833_11338:()=>Sjp,content_3833_1134:()=>mMe,content_3833_11340:()=>Ejp,content_3833_11342:()=>Fjp,content_3833_11344:()=>jjp,content_3833_11346:()=>Qjp,content_3833_11348:()=>Jjp,content_3833_11350:()=>nHp,content_3833_11352:()=>pHp,content_3833_11354:()=>cHp,content_3833_11356:()=>lHp,content_3833_11358:()=>yHp,content_3833_1136:()=>hMe,content_3833_11360:()=>gHp,content_3833_11362:()=>MHp,content_3833_11364:()=>wHp,content_3833_11366:()=>xHp,content_3833_11368:()=>LHp,content_3833_11370:()=>kHp,content_3833_11372:()=>IHp,content_3833_11374:()=>SHp,content_3833_11376:()=>EHp,content_3833_11378:()=>FHp,content_3833_1138:()=>DMe,content_3833_11380:()=>jHp,content_3833_11382:()=>QHp,content_3833_11384:()=>JHp,content_3833_11386:()=>nYp,content_3833_11388:()=>pYp,content_3833_11390:()=>cYp,content_3833_11392:()=>lYp,content_3833_11394:()=>yYp,content_3833_11396:()=>gYp,content_3833_11398:()=>MYp,content_3833_114:()=>Y0,content_3833_1140:()=>_Me,content_3833_11400:()=>wYp,content_3833_11402:()=>xYp,content_3833_11404:()=>LYp,content_3833_11406:()=>kYp,content_3833_11408:()=>IYp,content_3833_11410:()=>SYp,content_3833_11412:()=>EYp,content_3833_11414:()=>FYp,content_3833_11416:()=>jYp,content_3833_11418:()=>QYp,content_3833_1142:()=>CMe,content_3833_11420:()=>JYp,content_3833_11422:()=>nQp,content_3833_11424:()=>pQp,content_3833_11426:()=>cQp,content_3833_11428:()=>lQp,content_3833_11430:()=>yQp,content_3833_11432:()=>gQp,content_3833_11434:()=>MQp,content_3833_11436:()=>wQp,content_3833_11438:()=>xQp,content_3833_1144:()=>vMe,content_3833_11440:()=>LQp,content_3833_11442:()=>kQp,content_3833_11444:()=>IQp,content_3833_11446:()=>SQp,content_3833_11448:()=>EQp,content_3833_11450:()=>FQp,content_3833_11452:()=>jQp,content_3833_11454:()=>QQp,content_3833_11456:()=>JQp,content_3833_11458:()=>n$p,content_3833_1146:()=>NMe,content_3833_11460:()=>p$p,content_3833_11462:()=>c$p,content_3833_11464:()=>l$p,content_3833_11466:()=>y$p,content_3833_11468:()=>g$p,content_3833_11470:()=>M$p,content_3833_11472:()=>w$p,content_3833_11474:()=>x$p,content_3833_11476:()=>L$p,content_3833_11478:()=>k$p,content_3833_1148:()=>PMe,content_3833_11480:()=>I$p,content_3833_11482:()=>S$p,content_3833_11484:()=>E$p,content_3833_11486:()=>F$p,content_3833_11488:()=>j$p,content_3833_11490:()=>Q$p,content_3833_11492:()=>J$p,content_3833_11494:()=>nKp,content_3833_11496:()=>pKp,content_3833_11498:()=>cKp,content_3833_1150:()=>WMe,content_3833_11500:()=>lKp,content_3833_11502:()=>yKp,content_3833_11504:()=>gKp,content_3833_11506:()=>MKp,content_3833_11508:()=>wKp,content_3833_11510:()=>xKp,content_3833_11512:()=>LKp,content_3833_11514:()=>kKp,content_3833_11516:()=>IKp,content_3833_11518:()=>SKp,content_3833_1152:()=>GMe,content_3833_11520:()=>EKp,content_3833_11522:()=>FKp,content_3833_11524:()=>jKp,content_3833_11526:()=>QKp,content_3833_11528:()=>JKp,content_3833_11530:()=>nJp,content_3833_11532:()=>pJp,content_3833_11534:()=>cJp,content_3833_11536:()=>lJp,content_3833_11538:()=>yJp,content_3833_1154:()=>UMe,content_3833_11540:()=>gJp,content_3833_11542:()=>MJp,content_3833_11544:()=>wJp,content_3833_11546:()=>xJp,content_3833_11548:()=>LJp,content_3833_11550:()=>kJp,content_3833_11552:()=>IJp,content_3833_11554:()=>SJp,content_3833_11556:()=>EJp,content_3833_11558:()=>FJp,content_3833_1156:()=>qMe,content_3833_11560:()=>jJp,content_3833_11562:()=>QJp,content_3833_11564:()=>JJp,content_3833_11566:()=>nZp,content_3833_11568:()=>pZp,content_3833_11570:()=>cZp,content_3833_11572:()=>lZp,content_3833_11574:()=>yZp,content_3833_11576:()=>gZp,content_3833_11578:()=>MZp,content_3833_1158:()=>YMe,content_3833_11580:()=>wZp,content_3833_11582:()=>xZp,content_3833_11584:()=>LZp,content_3833_11586:()=>kZp,content_3833_11588:()=>IZp,content_3833_11590:()=>SZp,content_3833_11592:()=>EZp,content_3833_11594:()=>FZp,content_3833_11596:()=>jZp,content_3833_11598:()=>QZp,content_3833_116:()=>K0,content_3833_1160:()=>KMe,content_3833_11600:()=>JZp,content_3833_11602:()=>n0p,content_3833_11604:()=>p0p,content_3833_11606:()=>c0p,content_3833_11608:()=>l0p,content_3833_11610:()=>y0p,content_3833_11612:()=>g0p,content_3833_11614:()=>M0p,content_3833_11616:()=>w0p,content_3833_11618:()=>x0p,content_3833_1162:()=>eXe,content_3833_11620:()=>L0p,content_3833_11622:()=>k0p,content_3833_11624:()=>I0p,content_3833_11626:()=>S0p,content_3833_11628:()=>E0p,content_3833_11630:()=>F0p,content_3833_11632:()=>j0p,content_3833_11634:()=>Q0p,content_3833_11636:()=>J0p,content_3833_11638:()=>n3p,content_3833_1164:()=>oXe,content_3833_11640:()=>p3p,content_3833_11642:()=>c3p,content_3833_11644:()=>l3p,content_3833_11646:()=>y3p,content_3833_11648:()=>g3p,content_3833_11650:()=>M3p,content_3833_11652:()=>w3p,content_3833_11654:()=>x3p,content_3833_11656:()=>L3p,content_3833_11658:()=>k3p,content_3833_1166:()=>sXe,content_3833_11660:()=>I3p,content_3833_11662:()=>S3p,content_3833_11664:()=>E3p,content_3833_11666:()=>F3p,content_3833_11668:()=>j3p,content_3833_11670:()=>Q3p,content_3833_11672:()=>J3p,content_3833_11674:()=>n8p,content_3833_11676:()=>p8p,content_3833_11678:()=>c8p,content_3833_1168:()=>iXe,content_3833_11680:()=>l8p,content_3833_11682:()=>y8p,content_3833_11684:()=>g8p,content_3833_11686:()=>M8p,content_3833_11688:()=>w8p,content_3833_11690:()=>x8p,content_3833_11692:()=>L8p,content_3833_11694:()=>k8p,content_3833_11696:()=>I8p,content_3833_11698:()=>S8p,content_3833_1170:()=>mXe,content_3833_11700:()=>E8p,content_3833_11702:()=>F8p,content_3833_11704:()=>j8p,content_3833_11706:()=>Q8p,content_3833_11708:()=>J8p,content_3833_11710:()=>n2p,content_3833_11712:()=>p2p,content_3833_11714:()=>c2p,content_3833_11716:()=>l2p,content_3833_11718:()=>y2p,content_3833_1172:()=>hXe,content_3833_11720:()=>g2p,content_3833_11722:()=>M2p,content_3833_11724:()=>w2p,content_3833_11726:()=>x2p,content_3833_11728:()=>L2p,content_3833_11730:()=>k2p,content_3833_11732:()=>I2p,content_3833_11734:()=>S2p,content_3833_11736:()=>E2p,content_3833_11738:()=>F2p,content_3833_1174:()=>DXe,content_3833_11740:()=>j2p,content_3833_11742:()=>Q2p,content_3833_11744:()=>J2p,content_3833_11746:()=>n1p,content_3833_11748:()=>p1p,content_3833_11750:()=>c1p,content_3833_11752:()=>l1p,content_3833_11754:()=>y1p,content_3833_11756:()=>g1p,content_3833_11758:()=>M1p,content_3833_1176:()=>_Xe,content_3833_11760:()=>w1p,content_3833_11762:()=>x1p,content_3833_11764:()=>L1p,content_3833_11766:()=>k1p,content_3833_11768:()=>I1p,content_3833_11770:()=>S1p,content_3833_11772:()=>E1p,content_3833_11774:()=>F1p,content_3833_11776:()=>j1p,content_3833_11778:()=>Q1p,content_3833_1178:()=>CXe,content_3833_11780:()=>J1p,content_3833_11782:()=>n4p,content_3833_11784:()=>p4p,content_3833_11786:()=>c4p,content_3833_11788:()=>l4p,content_3833_11790:()=>y4p,content_3833_11792:()=>g4p,content_3833_11794:()=>M4p,content_3833_11796:()=>w4p,content_3833_11798:()=>x4p,content_3833_118:()=>e3,content_3833_1180:()=>vXe,content_3833_11800:()=>L4p,content_3833_11802:()=>k4p,content_3833_11804:()=>I4p,content_3833_11806:()=>S4p,content_3833_11808:()=>E4p,content_3833_11810:()=>F4p,content_3833_11812:()=>j4p,content_3833_11814:()=>Q4p,content_3833_11816:()=>J4p,content_3833_11818:()=>n6p,content_3833_1182:()=>NXe,content_3833_11820:()=>p6p,content_3833_11822:()=>c6p,content_3833_11824:()=>l6p,content_3833_11826:()=>y6p,content_3833_11828:()=>g6p,content_3833_11830:()=>M6p,content_3833_11832:()=>w6p,content_3833_11834:()=>x6p,content_3833_11836:()=>L6p,content_3833_11838:()=>k6p,content_3833_1184:()=>PXe,content_3833_11840:()=>I6p,content_3833_11842:()=>S6p,content_3833_11844:()=>E6p,content_3833_11846:()=>F6p,content_3833_11848:()=>j6p,content_3833_11850:()=>Q6p,content_3833_11852:()=>J6p,content_3833_11854:()=>n5p,content_3833_11856:()=>p5p,content_3833_11858:()=>c5p,content_3833_1186:()=>WXe,content_3833_11860:()=>l5p,content_3833_11862:()=>y5p,content_3833_11864:()=>g5p,content_3833_11866:()=>M5p,content_3833_11868:()=>w5p,content_3833_11870:()=>x5p,content_3833_11872:()=>L5p,content_3833_11874:()=>k5p,content_3833_11876:()=>I5p,content_3833_11878:()=>S5p,content_3833_1188:()=>GXe,content_3833_11880:()=>E5p,content_3833_11882:()=>F5p,content_3833_11884:()=>j5p,content_3833_11886:()=>Q5p,content_3833_11888:()=>J5p,content_3833_11890:()=>n7p,content_3833_11892:()=>p7p,content_3833_11894:()=>c7p,content_3833_11896:()=>l7p,content_3833_11898:()=>y7p,content_3833_1190:()=>UXe,content_3833_11900:()=>g7p,content_3833_11902:()=>M7p,content_3833_11904:()=>w7p,content_3833_11906:()=>x7p,content_3833_11908:()=>L7p,content_3833_11910:()=>k7p,content_3833_11912:()=>I7p,content_3833_11914:()=>S7p,content_3833_11916:()=>E7p,content_3833_11918:()=>F7p,content_3833_1192:()=>qXe,content_3833_11920:()=>j7p,content_3833_11922:()=>Q7p,content_3833_11924:()=>J7p,content_3833_11926:()=>n9p,content_3833_11928:()=>p9p,content_3833_11930:()=>c9p,content_3833_11932:()=>l9p,content_3833_11934:()=>y9p,content_3833_11936:()=>g9p,content_3833_11938:()=>M9p,content_3833_1194:()=>YXe,content_3833_11940:()=>w9p,content_3833_11942:()=>x9p,content_3833_11944:()=>L9p,content_3833_11946:()=>k9p,content_3833_11948:()=>I9p,content_3833_11950:()=>S9p,content_3833_11952:()=>E9p,content_3833_11954:()=>F9p,content_3833_11956:()=>j9p,content_3833_11958:()=>Q9p,content_3833_1196:()=>KXe,content_3833_11960:()=>J9p,content_3833_11962:()=>ner,content_3833_11964:()=>per,content_3833_11966:()=>cer,content_3833_11968:()=>ler,content_3833_11970:()=>yer,content_3833_11972:()=>ger,content_3833_11974:()=>Mer,content_3833_11976:()=>wer,content_3833_11978:()=>xer,content_3833_1198:()=>e_e,content_3833_11980:()=>Ler,content_3833_11982:()=>ker,content_3833_11984:()=>Ier,content_3833_11986:()=>Ser,content_3833_11988:()=>Eer,content_3833_11990:()=>Fer,content_3833_11992:()=>jer,content_3833_11994:()=>Qer,content_3833_11996:()=>Jer,content_3833_11998:()=>nnr,content_3833_12:()=>oJ,content_3833_120:()=>o3,content_3833_1200:()=>o_e,content_3833_12000:()=>pnr,content_3833_12002:()=>cnr,content_3833_12004:()=>lnr,content_3833_12006:()=>ynr,content_3833_12008:()=>gnr,content_3833_12010:()=>Mnr,content_3833_12012:()=>wnr,content_3833_12014:()=>xnr,content_3833_12016:()=>Lnr,content_3833_12018:()=>knr,content_3833_1202:()=>s_e,content_3833_12020:()=>Inr,content_3833_12022:()=>Snr,content_3833_12024:()=>Enr,content_3833_12026:()=>Fnr,content_3833_12028:()=>jnr,content_3833_12030:()=>Qnr,content_3833_12032:()=>Jnr,content_3833_12034:()=>ntr,content_3833_12036:()=>ptr,content_3833_12038:()=>ctr,content_3833_1204:()=>i_e,content_3833_12040:()=>ltr,content_3833_12042:()=>ytr,content_3833_12044:()=>gtr,content_3833_12046:()=>Mtr,content_3833_12048:()=>wtr,content_3833_12050:()=>xtr,content_3833_12052:()=>Ltr,content_3833_12054:()=>ktr,content_3833_12056:()=>Itr,content_3833_12058:()=>Str,content_3833_1206:()=>m_e,content_3833_12060:()=>Etr,content_3833_12062:()=>Ftr,content_3833_12064:()=>jtr,content_3833_12066:()=>Qtr,content_3833_12068:()=>Jtr,content_3833_12070:()=>nor,content_3833_12072:()=>por,content_3833_12074:()=>cor,content_3833_12076:()=>lor,content_3833_12078:()=>yor,content_3833_1208:()=>h_e,content_3833_12080:()=>gor,content_3833_12082:()=>Xor,content_3833_12084:()=>Tor,content_3833_12086:()=>Aor,content_3833_12088:()=>bor,content_3833_12090:()=>zor,content_3833_12092:()=>Ror,content_3833_12094:()=>Bor,content_3833_12096:()=>Oor,content_3833_12098:()=>Vor,content_3833_1210:()=>D_e,content_3833_12100:()=>Hor,content_3833_12102:()=>$or,content_3833_12104:()=>Zor,content_3833_12106:()=>tpr,content_3833_12108:()=>rpr,content_3833_12110:()=>apr,content_3833_12112:()=>upr,content_3833_12114:()=>dpr,content_3833_12116:()=>fpr,content_3833_12118:()=>Xpr,content_3833_1212:()=>__e,content_3833_12120:()=>Tpr,content_3833_12122:()=>Apr,content_3833_12124:()=>bpr,content_3833_12126:()=>zpr,content_3833_12128:()=>Rpr,content_3833_12130:()=>Bpr,content_3833_12132:()=>Opr,content_3833_12134:()=>Vpr,content_3833_12136:()=>Hpr,content_3833_12138:()=>$pr,content_3833_1214:()=>C_e,content_3833_12140:()=>Zpr,content_3833_12142:()=>trr,content_3833_12144:()=>rrr,content_3833_12146:()=>arr,content_3833_12148:()=>urr,content_3833_12150:()=>drr,content_3833_12152:()=>frr,content_3833_12154:()=>Xrr,content_3833_12156:()=>Trr,content_3833_12158:()=>Arr,content_3833_1216:()=>v_e,content_3833_12160:()=>brr,content_3833_12162:()=>zrr,content_3833_12164:()=>Rrr,content_3833_12166:()=>Brr,content_3833_12168:()=>Orr,content_3833_12170:()=>Vrr,content_3833_12172:()=>Hrr,content_3833_12174:()=>$rr,content_3833_12176:()=>Zrr,content_3833_12178:()=>tsr,content_3833_1218:()=>N_e,content_3833_12180:()=>rsr,content_3833_12182:()=>asr,content_3833_12184:()=>usr,content_3833_12186:()=>dsr,content_3833_12188:()=>fsr,content_3833_12190:()=>Xsr,content_3833_12192:()=>Tsr,content_3833_12194:()=>Asr,content_3833_12196:()=>bsr,content_3833_12198:()=>zsr,content_3833_122:()=>s3,content_3833_1220:()=>P_e,content_3833_12200:()=>Rsr,content_3833_12202:()=>Bsr,content_3833_12204:()=>Osr,content_3833_12206:()=>Vsr,content_3833_12208:()=>Hsr,content_3833_12210:()=>$sr,content_3833_12212:()=>Zsr,content_3833_12214:()=>tcr,content_3833_12216:()=>rcr,content_3833_12218:()=>acr,content_3833_1222:()=>W_e,content_3833_12220:()=>ucr,content_3833_12222:()=>dcr,content_3833_12224:()=>fcr,content_3833_12226:()=>Xcr,content_3833_12228:()=>Tcr,content_3833_12230:()=>Acr,content_3833_12232:()=>bcr,content_3833_12234:()=>zcr,content_3833_12236:()=>Rcr,content_3833_12238:()=>Bcr,content_3833_1224:()=>G_e,content_3833_12240:()=>Ocr,content_3833_12242:()=>Vcr,content_3833_12244:()=>Hcr,content_3833_12246:()=>$cr,content_3833_12248:()=>Zcr,content_3833_12250:()=>tar,content_3833_12252:()=>rar,content_3833_12254:()=>aar,content_3833_12256:()=>uar,content_3833_12258:()=>dar,content_3833_1226:()=>U_e,content_3833_12260:()=>far,content_3833_12262:()=>Xar,content_3833_12264:()=>Tar,content_3833_12266:()=>Aar,content_3833_12268:()=>Nar,content_3833_12270:()=>Par,content_3833_12272:()=>War,content_3833_12274:()=>Gar,content_3833_12276:()=>Uar,content_3833_12278:()=>qar,content_3833_1228:()=>q_e,content_3833_12280:()=>Yar,content_3833_12282:()=>Kar,content_3833_12284:()=>eir,content_3833_12286:()=>oir,content_3833_12288:()=>sir,content_3833_12290:()=>iir,content_3833_12292:()=>mir,content_3833_12294:()=>hir,content_3833_12296:()=>Dir,content_3833_12298:()=>_ir,content_3833_1230:()=>Y_e,content_3833_12300:()=>Cir,content_3833_12302:()=>vir,content_3833_12304:()=>Nir,content_3833_12306:()=>Pir,content_3833_12308:()=>Wir,content_3833_12310:()=>Gir,content_3833_12312:()=>Uir,content_3833_12314:()=>qir,content_3833_12316:()=>Yir,content_3833_12318:()=>Kir,content_3833_1232:()=>K_e,content_3833_12320:()=>elr,content_3833_12322:()=>olr,content_3833_12324:()=>slr,content_3833_12326:()=>ilr,content_3833_12328:()=>mlr,content_3833_12330:()=>hlr,content_3833_12332:()=>Dlr,content_3833_12334:()=>_lr,content_3833_12336:()=>Clr,content_3833_12338:()=>vlr,content_3833_1234:()=>ewe,content_3833_12340:()=>Nlr,content_3833_12342:()=>Plr,content_3833_12344:()=>Wlr,content_3833_12346:()=>Glr,content_3833_12348:()=>Ulr,content_3833_12350:()=>qlr,content_3833_12352:()=>Ylr,content_3833_12354:()=>Klr,content_3833_12356:()=>eur,content_3833_12358:()=>our,content_3833_1236:()=>owe,content_3833_12360:()=>sur,content_3833_12362:()=>iur,content_3833_12364:()=>mur,content_3833_12366:()=>hur,content_3833_12368:()=>Dur,content_3833_12370:()=>_ur,content_3833_12372:()=>Cur,content_3833_12374:()=>vur,content_3833_12376:()=>Nur,content_3833_12378:()=>Pur,content_3833_1238:()=>swe,content_3833_12380:()=>Wur,content_3833_12382:()=>Gur,content_3833_12384:()=>Uur,content_3833_12386:()=>qur,content_3833_12388:()=>Yur,content_3833_12390:()=>Kur,content_3833_12392:()=>emr,content_3833_12394:()=>omr,content_3833_12396:()=>smr,content_3833_12398:()=>imr,content_3833_124:()=>i3,content_3833_1240:()=>iwe,content_3833_12400:()=>mmr,content_3833_12402:()=>hmr,content_3833_12404:()=>Dmr,content_3833_12406:()=>_mr,content_3833_12408:()=>Cmr,content_3833_12410:()=>vmr,content_3833_12412:()=>Nmr,content_3833_12414:()=>Pmr,content_3833_12416:()=>Wmr,content_3833_12418:()=>Gmr,content_3833_1242:()=>mwe,content_3833_12420:()=>Umr,content_3833_12422:()=>qmr,content_3833_12424:()=>Ymr,content_3833_12426:()=>Kmr,content_3833_12428:()=>eyr,content_3833_12430:()=>oyr,content_3833_12432:()=>syr,content_3833_12434:()=>iyr,content_3833_12436:()=>myr,content_3833_12438:()=>hyr,content_3833_1244:()=>hwe,content_3833_12440:()=>Dyr,content_3833_12442:()=>_yr,content_3833_12444:()=>Cyr,content_3833_12446:()=>vyr,content_3833_12448:()=>Nyr,content_3833_12450:()=>Pyr,content_3833_12452:()=>Wyr,content_3833_12454:()=>Gyr,content_3833_12456:()=>Uyr,content_3833_12458:()=>qyr,content_3833_1246:()=>Dwe,content_3833_12460:()=>Yyr,content_3833_12462:()=>Kyr,content_3833_12464:()=>edr,content_3833_12466:()=>odr,content_3833_12468:()=>sdr,content_3833_12470:()=>idr,content_3833_12472:()=>mdr,content_3833_12474:()=>hdr,content_3833_12476:()=>Ddr,content_3833_12478:()=>_dr,content_3833_1248:()=>_we,content_3833_12480:()=>Cdr,content_3833_12482:()=>vdr,content_3833_12484:()=>Ndr,content_3833_12486:()=>Pdr,content_3833_12488:()=>Wdr,content_3833_12490:()=>Gdr,content_3833_12492:()=>Udr,content_3833_12494:()=>qdr,content_3833_12496:()=>Ydr,content_3833_12498:()=>Kdr,content_3833_1250:()=>Cwe,content_3833_12500:()=>ehr,content_3833_12502:()=>ohr,content_3833_12504:()=>shr,content_3833_12506:()=>ihr,content_3833_12508:()=>mhr,content_3833_12510:()=>hhr,content_3833_12512:()=>Dhr,content_3833_12514:()=>_hr,content_3833_12516:()=>Chr,content_3833_12518:()=>vhr,content_3833_1252:()=>vwe,content_3833_12520:()=>Nhr,content_3833_12522:()=>Phr,content_3833_12524:()=>Whr,content_3833_12526:()=>Ghr,content_3833_12528:()=>Uhr,content_3833_12530:()=>qhr,content_3833_12532:()=>Yhr,content_3833_12534:()=>Khr,content_3833_12536:()=>egr,content_3833_12538:()=>ogr,content_3833_1254:()=>Nwe,content_3833_12540:()=>sgr,content_3833_12542:()=>igr,content_3833_12544:()=>mgr,content_3833_12546:()=>hgr,content_3833_12548:()=>Dgr,content_3833_12550:()=>_gr,content_3833_12552:()=>Cgr,content_3833_12554:()=>vgr,content_3833_12556:()=>Ngr,content_3833_12558:()=>Pgr,content_3833_1256:()=>Pwe,content_3833_12560:()=>Wgr,content_3833_12562:()=>Ggr,content_3833_12564:()=>Ugr,content_3833_12566:()=>qgr,content_3833_12568:()=>Ygr,content_3833_12570:()=>Kgr,content_3833_12572:()=>efr,content_3833_12574:()=>ofr,content_3833_12576:()=>sfr,content_3833_12578:()=>ifr,content_3833_1258:()=>Wwe,content_3833_12580:()=>mfr,content_3833_12582:()=>hfr,content_3833_12584:()=>Dfr,content_3833_12586:()=>_fr,content_3833_12588:()=>Cfr,content_3833_12590:()=>vfr,content_3833_12592:()=>Nfr,content_3833_12594:()=>Pfr,content_3833_12596:()=>Wfr,content_3833_12598:()=>Gfr,content_3833_126:()=>m3,content_3833_1260:()=>Gwe,content_3833_12600:()=>Ufr,content_3833_12602:()=>qfr,content_3833_12604:()=>Yfr,content_3833_12606:()=>Kfr,content_3833_12608:()=>eDr,content_3833_12610:()=>oDr,content_3833_12612:()=>sDr,content_3833_12614:()=>iDr,content_3833_12616:()=>mDr,content_3833_12618:()=>hDr,content_3833_1262:()=>Uwe,content_3833_12620:()=>DDr,content_3833_12622:()=>_Dr,content_3833_12624:()=>CDr,content_3833_12626:()=>vDr,content_3833_12628:()=>NDr,content_3833_12630:()=>PDr,content_3833_12632:()=>WDr,content_3833_12634:()=>GDr,content_3833_12636:()=>UDr,content_3833_12638:()=>qDr,content_3833_1264:()=>qwe,content_3833_12640:()=>YDr,content_3833_12642:()=>KDr,content_3833_12644:()=>eMr,content_3833_12646:()=>oMr,content_3833_12648:()=>sMr,content_3833_12650:()=>iMr,content_3833_12652:()=>mMr,content_3833_12654:()=>hMr,content_3833_12656:()=>DMr,content_3833_12658:()=>_Mr,content_3833_1266:()=>Ywe,content_3833_12660:()=>CMr,content_3833_12662:()=>vMr,content_3833_12664:()=>NMr,content_3833_12666:()=>PMr,content_3833_12668:()=>WMr,content_3833_12670:()=>GMr,content_3833_12672:()=>UMr,content_3833_12674:()=>qMr,content_3833_12676:()=>YMr,content_3833_12678:()=>KMr,content_3833_1268:()=>Kwe,content_3833_12680:()=>eXr,content_3833_12682:()=>oXr,content_3833_12684:()=>sXr,content_3833_12686:()=>iXr,content_3833_12688:()=>mXr,content_3833_12690:()=>hXr,content_3833_12692:()=>DXr,content_3833_12694:()=>_Xr,content_3833_12696:()=>CXr,content_3833_12698:()=>vXr,content_3833_1270:()=>eTe,content_3833_12700:()=>NXr,content_3833_12702:()=>PXr,content_3833_12704:()=>WXr,content_3833_12706:()=>GXr,content_3833_12708:()=>UXr,content_3833_12710:()=>qXr,content_3833_12712:()=>YXr,content_3833_12714:()=>KXr,content_3833_12716:()=>e_r,content_3833_12718:()=>o_r,content_3833_1272:()=>oTe,content_3833_12720:()=>s_r,content_3833_12722:()=>i_r,content_3833_12724:()=>m_r,content_3833_12726:()=>h_r,content_3833_12728:()=>D_r,content_3833_12730:()=>__r,content_3833_12732:()=>C_r,content_3833_12734:()=>v_r,content_3833_12736:()=>N_r,content_3833_12738:()=>P_r,content_3833_1274:()=>sTe,content_3833_12740:()=>W_r,content_3833_12742:()=>G_r,content_3833_12744:()=>U_r,content_3833_12746:()=>q_r,content_3833_12748:()=>Y_r,content_3833_12750:()=>K_r,content_3833_12752:()=>ewr,content_3833_12754:()=>owr,content_3833_12756:()=>swr,content_3833_12758:()=>iwr,content_3833_1276:()=>iTe,content_3833_12760:()=>mwr,content_3833_12762:()=>hwr,content_3833_12764:()=>Dwr,content_3833_12766:()=>_wr,content_3833_12768:()=>Cwr,content_3833_12770:()=>vwr,content_3833_12772:()=>Nwr,content_3833_12774:()=>Pwr,content_3833_12776:()=>Wwr,content_3833_12778:()=>Gwr,content_3833_1278:()=>mTe,content_3833_12780:()=>Uwr,content_3833_12782:()=>qwr,content_3833_12784:()=>Ywr,content_3833_12786:()=>Kwr,content_3833_12788:()=>eTr,content_3833_12790:()=>oTr,content_3833_12792:()=>sTr,content_3833_12794:()=>iTr,content_3833_12796:()=>mTr,content_3833_12798:()=>hTr,content_3833_128:()=>h3,content_3833_1280:()=>hTe,content_3833_12800:()=>DTr,content_3833_12802:()=>_Tr,content_3833_12804:()=>CTr,content_3833_12806:()=>vTr,content_3833_12808:()=>NTr,content_3833_12810:()=>PTr,content_3833_12812:()=>WTr,content_3833_12814:()=>GTr,content_3833_12816:()=>UTr,content_3833_12818:()=>qTr,content_3833_1282:()=>DTe,content_3833_12820:()=>YTr,content_3833_12822:()=>KTr,content_3833_12824:()=>eCr,content_3833_12826:()=>oCr,content_3833_12828:()=>sCr,content_3833_12830:()=>iCr,content_3833_12832:()=>mCr,content_3833_12834:()=>hCr,content_3833_12836:()=>DCr,content_3833_12838:()=>_Cr,content_3833_1284:()=>_Te,content_3833_12840:()=>CCr,content_3833_12842:()=>vCr,content_3833_12844:()=>NCr,content_3833_12846:()=>PCr,content_3833_12848:()=>WCr,content_3833_12850:()=>GCr,content_3833_12852:()=>UCr,content_3833_12854:()=>qCr,content_3833_12856:()=>YCr,content_3833_12858:()=>KCr,content_3833_1286:()=>CTe,content_3833_12860:()=>exr,content_3833_12862:()=>oxr,content_3833_12864:()=>sxr,content_3833_12866:()=>ixr,content_3833_12868:()=>mxr,content_3833_12870:()=>hxr,content_3833_12872:()=>Dxr,content_3833_12874:()=>_xr,content_3833_12876:()=>Cxr,content_3833_12878:()=>vxr,content_3833_1288:()=>vTe,content_3833_12880:()=>Nxr,content_3833_12882:()=>Pxr,content_3833_12884:()=>Wxr,content_3833_12886:()=>Gxr,content_3833_12888:()=>Uxr,content_3833_12890:()=>qxr,content_3833_12892:()=>Yxr,content_3833_12894:()=>Kxr,content_3833_12896:()=>eAr,content_3833_12898:()=>oAr,content_3833_1290:()=>NTe,content_3833_12900:()=>sAr,content_3833_12902:()=>iAr,content_3833_12904:()=>mAr,content_3833_12906:()=>hAr,content_3833_12908:()=>DAr,content_3833_12910:()=>_Ar,content_3833_12912:()=>CAr,content_3833_12914:()=>vAr,content_3833_12916:()=>NAr,content_3833_12918:()=>PAr,content_3833_1292:()=>PTe,content_3833_12920:()=>WAr,content_3833_12922:()=>GAr,content_3833_12924:()=>UAr,content_3833_12926:()=>qAr,content_3833_12928:()=>YAr,content_3833_12930:()=>KAr,content_3833_12932:()=>evr,content_3833_12934:()=>ovr,content_3833_12936:()=>svr,content_3833_12938:()=>ivr,content_3833_1294:()=>WTe,content_3833_12940:()=>mvr,content_3833_12942:()=>hvr,content_3833_12944:()=>Dvr,content_3833_12946:()=>_vr,content_3833_12948:()=>Cvr,content_3833_12950:()=>vvr,content_3833_12952:()=>Nvr,content_3833_12954:()=>Pvr,content_3833_12956:()=>Wvr,content_3833_12958:()=>Gvr,content_3833_1296:()=>GTe,content_3833_12960:()=>Uvr,content_3833_12962:()=>qvr,content_3833_12964:()=>Yvr,content_3833_12966:()=>Kvr,content_3833_12968:()=>eLr,content_3833_12970:()=>oLr,content_3833_12972:()=>sLr,content_3833_12974:()=>iLr,content_3833_12976:()=>mLr,content_3833_12978:()=>hLr,content_3833_1298:()=>UTe,content_3833_12980:()=>DLr,content_3833_12982:()=>_Lr,content_3833_12984:()=>CLr,content_3833_12986:()=>vLr,content_3833_12988:()=>NLr,content_3833_12990:()=>PLr,content_3833_12992:()=>WLr,content_3833_12994:()=>GLr,content_3833_12996:()=>ULr,content_3833_12998:()=>qLr,content_3833_130:()=>D3,content_3833_1300:()=>qTe,content_3833_13000:()=>YLr,content_3833_13002:()=>KLr,content_3833_13004:()=>ebr,content_3833_13006:()=>obr,content_3833_13008:()=>sbr,content_3833_13010:()=>ibr,content_3833_13012:()=>mbr,content_3833_13014:()=>hbr,content_3833_1302:()=>YTe,content_3833_1304:()=>KTe,content_3833_1306:()=>eCe,content_3833_1308:()=>oCe,content_3833_1310:()=>sCe,content_3833_1312:()=>iCe,content_3833_1314:()=>mCe,content_3833_1316:()=>hCe,content_3833_1318:()=>DCe,content_3833_132:()=>_3,content_3833_1320:()=>_Ce,content_3833_1322:()=>CCe,content_3833_1324:()=>vCe,content_3833_1326:()=>NCe,content_3833_1328:()=>PCe,content_3833_1330:()=>WCe,content_3833_1332:()=>GCe,content_3833_1334:()=>UCe,content_3833_1336:()=>qCe,content_3833_1338:()=>YCe,content_3833_134:()=>C3,content_3833_1340:()=>KCe,content_3833_1342:()=>exe,content_3833_1344:()=>oxe,content_3833_1346:()=>sxe,content_3833_1348:()=>ixe,content_3833_1350:()=>mxe,content_3833_1352:()=>hxe,content_3833_1354:()=>Dxe,content_3833_1356:()=>_xe,content_3833_1358:()=>Cxe,content_3833_136:()=>v3,content_3833_1360:()=>vxe,content_3833_1362:()=>Nxe,content_3833_1364:()=>Pxe,content_3833_1366:()=>Wxe,content_3833_1368:()=>Gxe,content_3833_1370:()=>Uxe,content_3833_1372:()=>qxe,content_3833_1374:()=>Yxe,content_3833_1376:()=>Kxe,content_3833_1378:()=>eAe,content_3833_138:()=>N3,content_3833_1380:()=>oAe,content_3833_1382:()=>sAe,content_3833_1384:()=>iAe,content_3833_1386:()=>mAe,content_3833_1388:()=>hAe,content_3833_1390:()=>DAe,content_3833_1392:()=>_Ae,content_3833_1394:()=>CAe,content_3833_1396:()=>vAe,content_3833_1398:()=>NAe,content_3833_14:()=>sJ,content_3833_140:()=>P3,content_3833_1400:()=>PAe,content_3833_1402:()=>WAe,content_3833_1404:()=>GAe,content_3833_1406:()=>UAe,content_3833_1408:()=>qAe,content_3833_1410:()=>YAe,content_3833_1412:()=>KAe,content_3833_1414:()=>eve,content_3833_1416:()=>ove,content_3833_1418:()=>sve,content_3833_142:()=>W3,content_3833_1420:()=>ive,content_3833_1422:()=>mve,content_3833_1424:()=>hve,content_3833_1426:()=>Dve,content_3833_1428:()=>_ve,content_3833_1430:()=>Cve,content_3833_1432:()=>vve,content_3833_1434:()=>Nve,content_3833_1436:()=>Pve,content_3833_1438:()=>Wve,content_3833_144:()=>G3,content_3833_1440:()=>Gve,content_3833_1442:()=>Uve,content_3833_1444:()=>qve,content_3833_1446:()=>Yve,content_3833_1448:()=>Kve,content_3833_1450:()=>eLe,content_3833_1452:()=>oLe,content_3833_1454:()=>sLe,content_3833_1456:()=>iLe,content_3833_1458:()=>mLe,content_3833_146:()=>U3,content_3833_1460:()=>hLe,content_3833_1462:()=>DLe,content_3833_1464:()=>_Le,content_3833_1466:()=>CLe,content_3833_1468:()=>vLe,content_3833_1470:()=>NLe,content_3833_1472:()=>PLe,content_3833_1474:()=>WLe,content_3833_1476:()=>GLe,content_3833_1478:()=>ULe,content_3833_148:()=>q3,content_3833_1480:()=>qLe,content_3833_1482:()=>YLe,content_3833_1484:()=>KLe,content_3833_1486:()=>ebe,content_3833_1488:()=>obe,content_3833_1490:()=>sbe,content_3833_1492:()=>ibe,content_3833_1494:()=>mbe,content_3833_1496:()=>hbe,content_3833_1498:()=>Dbe,content_3833_150:()=>Y3,content_3833_1500:()=>_be,content_3833_1502:()=>Cbe,content_3833_1504:()=>vbe,content_3833_1506:()=>Nbe,content_3833_1508:()=>Pbe,content_3833_1510:()=>Wbe,content_3833_1512:()=>Gbe,content_3833_1514:()=>Ube,content_3833_1516:()=>qbe,content_3833_1518:()=>Ybe,content_3833_152:()=>K3,content_3833_1520:()=>Kbe,content_3833_1522:()=>eNe,content_3833_1524:()=>oNe,content_3833_1526:()=>sNe,content_3833_1528:()=>iNe,content_3833_1530:()=>mNe,content_3833_1532:()=>hNe,content_3833_1534:()=>DNe,content_3833_1536:()=>_Ne,content_3833_1538:()=>CNe,content_3833_154:()=>e8,content_3833_1540:()=>vNe,content_3833_1542:()=>NNe,content_3833_1544:()=>PNe,content_3833_1546:()=>WNe,content_3833_1548:()=>GNe,content_3833_1550:()=>UNe,content_3833_1552:()=>qNe,content_3833_1554:()=>YNe,content_3833_1556:()=>KNe,content_3833_1558:()=>eke,content_3833_156:()=>o8,content_3833_1560:()=>oke,content_3833_1562:()=>ske,content_3833_1564:()=>ike,content_3833_1566:()=>mke,content_3833_1568:()=>hke,content_3833_1570:()=>Dke,content_3833_1572:()=>_ke,content_3833_1574:()=>Cke,content_3833_1576:()=>vke,content_3833_1578:()=>Nke,content_3833_158:()=>s8,content_3833_1580:()=>Pke,content_3833_1582:()=>Wke,content_3833_1584:()=>Gke,content_3833_1586:()=>Uke,content_3833_1588:()=>qke,content_3833_1590:()=>Yke,content_3833_1592:()=>Kke,content_3833_1594:()=>eze,content_3833_1596:()=>oze,content_3833_1598:()=>sze,content_3833_16:()=>iJ,content_3833_160:()=>i8,content_3833_1600:()=>ize,content_3833_1602:()=>mze,content_3833_1604:()=>hze,content_3833_1606:()=>Dze,content_3833_1608:()=>_ze,content_3833_1610:()=>Cze,content_3833_1612:()=>vze,content_3833_1614:()=>Nze,content_3833_1616:()=>Pze,content_3833_1618:()=>Wze,content_3833_162:()=>m8,content_3833_1620:()=>Gze,content_3833_1622:()=>Uze,content_3833_1624:()=>qze,content_3833_1626:()=>Yze,content_3833_1628:()=>Kze,content_3833_1630:()=>ePe,content_3833_1632:()=>oPe,content_3833_1634:()=>sPe,content_3833_1636:()=>iPe,content_3833_1638:()=>mPe,content_3833_164:()=>h8,content_3833_1640:()=>hPe,content_3833_1642:()=>DPe,content_3833_1644:()=>_Pe,content_3833_1646:()=>CPe,content_3833_1648:()=>vPe,content_3833_1650:()=>NPe,content_3833_1652:()=>PPe,content_3833_1654:()=>WPe,content_3833_1656:()=>GPe,content_3833_1658:()=>UPe,content_3833_166:()=>D8,content_3833_1660:()=>qPe,content_3833_1662:()=>YPe,content_3833_1664:()=>KPe,content_3833_1666:()=>eIe,content_3833_1668:()=>oIe,content_3833_1670:()=>sIe,content_3833_1672:()=>iIe,content_3833_1674:()=>mIe,content_3833_1676:()=>hIe,content_3833_1678:()=>DIe,content_3833_168:()=>_8,content_3833_1680:()=>_Ie,content_3833_1682:()=>CIe,content_3833_1684:()=>vIe,content_3833_1686:()=>NIe,content_3833_1688:()=>PIe,content_3833_1690:()=>WIe,content_3833_1692:()=>GIe,content_3833_1694:()=>UIe,content_3833_1696:()=>qIe,content_3833_1698:()=>YIe,content_3833_170:()=>C8,content_3833_1700:()=>KIe,content_3833_1702:()=>eRe,content_3833_1704:()=>oRe,content_3833_1706:()=>sRe,content_3833_1708:()=>iRe,content_3833_1710:()=>mRe,content_3833_1712:()=>hRe,content_3833_1714:()=>DRe,content_3833_1716:()=>_Re,content_3833_1718:()=>CRe,content_3833_172:()=>v8,content_3833_1720:()=>vRe,content_3833_1722:()=>NRe,content_3833_1724:()=>PRe,content_3833_1726:()=>WRe,content_3833_1728:()=>GRe,content_3833_1730:()=>URe,content_3833_1732:()=>qRe,content_3833_1734:()=>YRe,content_3833_1736:()=>KRe,content_3833_1738:()=>eWe,content_3833_174:()=>N8,content_3833_1740:()=>oWe,content_3833_1742:()=>sWe,content_3833_1744:()=>iWe,content_3833_1746:()=>mWe,content_3833_1748:()=>hWe,content_3833_1750:()=>DWe,content_3833_1752:()=>_We,content_3833_1754:()=>CWe,content_3833_1756:()=>vWe,content_3833_1758:()=>NWe,content_3833_176:()=>P8,content_3833_1760:()=>PWe,content_3833_1762:()=>WWe,content_3833_1764:()=>GWe,content_3833_1766:()=>UWe,content_3833_1768:()=>qWe,content_3833_1770:()=>YWe,content_3833_1772:()=>KWe,content_3833_1774:()=>eSe,content_3833_1776:()=>oSe,content_3833_1778:()=>sSe,content_3833_178:()=>W8,content_3833_1780:()=>iSe,content_3833_1782:()=>mSe,content_3833_1784:()=>hSe,content_3833_1786:()=>DSe,content_3833_1788:()=>_Se,content_3833_1790:()=>CSe,content_3833_1792:()=>vSe,content_3833_1794:()=>NSe,content_3833_1796:()=>PSe,content_3833_1798:()=>WSe,content_3833_18:()=>mJ,content_3833_180:()=>G8,content_3833_1800:()=>GSe,content_3833_1802:()=>USe,content_3833_1804:()=>qSe,content_3833_1806:()=>YSe,content_3833_1808:()=>KSe,content_3833_1810:()=>eBe,content_3833_1812:()=>oBe,content_3833_1814:()=>sBe,content_3833_1816:()=>iBe,content_3833_1818:()=>mBe,content_3833_182:()=>U8,content_3833_1820:()=>hBe,content_3833_1822:()=>DBe,content_3833_1824:()=>_Be,content_3833_1826:()=>CBe,content_3833_1828:()=>vBe,content_3833_1830:()=>NBe,content_3833_1832:()=>PBe,content_3833_1834:()=>WBe,content_3833_1836:()=>GBe,content_3833_1838:()=>UBe,content_3833_184:()=>q8,content_3833_1840:()=>qBe,content_3833_1842:()=>YBe,content_3833_1844:()=>KBe,content_3833_1846:()=>eGe,content_3833_1848:()=>oGe,content_3833_1850:()=>sGe,content_3833_1852:()=>iGe,content_3833_1854:()=>mGe,content_3833_1856:()=>hGe,content_3833_1858:()=>DGe,content_3833_186:()=>Y8,content_3833_1860:()=>_Ge,content_3833_1862:()=>CGe,content_3833_1864:()=>vGe,content_3833_1866:()=>NGe,content_3833_1868:()=>PGe,content_3833_1870:()=>WGe,content_3833_1872:()=>GGe,content_3833_1874:()=>UGe,content_3833_1876:()=>qGe,content_3833_1878:()=>YGe,content_3833_188:()=>K8,content_3833_1880:()=>KGe,content_3833_1882:()=>eEe,content_3833_1884:()=>oEe,content_3833_1886:()=>sEe,content_3833_1888:()=>iEe,content_3833_1890:()=>mEe,content_3833_1892:()=>hEe,content_3833_1894:()=>DEe,content_3833_1896:()=>_Ee,content_3833_1898:()=>CEe,content_3833_190:()=>e2,content_3833_1900:()=>vEe,content_3833_1902:()=>NEe,content_3833_1904:()=>PEe,content_3833_1906:()=>WEe,content_3833_1908:()=>GEe,content_3833_1910:()=>UEe,content_3833_1912:()=>qEe,content_3833_1914:()=>YEe,content_3833_1916:()=>KEe,content_3833_1918:()=>eOe,content_3833_192:()=>o2,content_3833_1920:()=>oOe,content_3833_1922:()=>sOe,content_3833_1924:()=>iOe,content_3833_1926:()=>mOe,content_3833_1928:()=>hOe,content_3833_1930:()=>DOe,content_3833_1932:()=>_Oe,content_3833_1934:()=>COe,content_3833_1936:()=>vOe,content_3833_1938:()=>NOe,content_3833_194:()=>s2,content_3833_1940:()=>POe,content_3833_1942:()=>WOe,content_3833_1944:()=>GOe,content_3833_1946:()=>UOe,content_3833_1948:()=>qOe,content_3833_1950:()=>YOe,content_3833_1952:()=>KOe,content_3833_1954:()=>eUe,content_3833_1956:()=>oUe,content_3833_1958:()=>sUe,content_3833_196:()=>i2,content_3833_1960:()=>iUe,content_3833_1962:()=>mUe,content_3833_1964:()=>hUe,content_3833_1966:()=>DUe,content_3833_1968:()=>_Ue,content_3833_1970:()=>CUe,content_3833_1972:()=>vUe,content_3833_1974:()=>NUe,content_3833_1976:()=>PUe,content_3833_1978:()=>WUe,content_3833_198:()=>m2,content_3833_1980:()=>GUe,content_3833_1982:()=>UUe,content_3833_1984:()=>qUe,content_3833_1986:()=>YUe,content_3833_1988:()=>KUe,content_3833_1990:()=>eFe,content_3833_1992:()=>oFe,content_3833_1994:()=>sFe,content_3833_1996:()=>iFe,content_3833_1998:()=>mFe,content_3833_2:()=>UK,content_3833_20:()=>hJ,content_3833_200:()=>h2,content_3833_2000:()=>hFe,content_3833_2002:()=>DFe,content_3833_2004:()=>_Fe,content_3833_2006:()=>CFe,content_3833_2008:()=>vFe,content_3833_2010:()=>NFe,content_3833_2012:()=>PFe,content_3833_2014:()=>WFe,content_3833_2016:()=>GFe,content_3833_2018:()=>UFe,content_3833_202:()=>D2,content_3833_2020:()=>qFe,content_3833_2022:()=>YFe,content_3833_2024:()=>KFe,content_3833_2026:()=>eVe,content_3833_2028:()=>oVe,content_3833_2030:()=>sVe,content_3833_2032:()=>iVe,content_3833_2034:()=>mVe,content_3833_2036:()=>hVe,content_3833_2038:()=>DVe,content_3833_204:()=>_2,content_3833_2040:()=>_Ve,content_3833_2042:()=>CVe,content_3833_2044:()=>vVe,content_3833_2046:()=>NVe,content_3833_2048:()=>PVe,content_3833_2050:()=>WVe,content_3833_2052:()=>GVe,content_3833_2054:()=>UVe,content_3833_2056:()=>qVe,content_3833_2058:()=>YVe,content_3833_206:()=>C2,content_3833_2060:()=>KVe,content_3833_2062:()=>eqe,content_3833_2064:()=>oqe,content_3833_2066:()=>sqe,content_3833_2068:()=>iqe,content_3833_2070:()=>mqe,content_3833_2072:()=>hqe,content_3833_2074:()=>Dqe,content_3833_2076:()=>_qe,content_3833_2078:()=>Cqe,content_3833_208:()=>v2,content_3833_2080:()=>vqe,content_3833_2082:()=>Nqe,content_3833_2084:()=>Pqe,content_3833_2086:()=>Wqe,content_3833_2088:()=>Gqe,content_3833_2090:()=>Uqe,content_3833_2092:()=>qqe,content_3833_2094:()=>Yqe,content_3833_2096:()=>Kqe,content_3833_2098:()=>eje,content_3833_210:()=>N2,content_3833_2100:()=>oje,content_3833_2102:()=>sje,content_3833_2104:()=>ije,content_3833_2106:()=>mje,content_3833_2108:()=>hje,content_3833_2110:()=>Dje,content_3833_2112:()=>_je,content_3833_2114:()=>Cje,content_3833_2116:()=>vje,content_3833_2118:()=>Nje,content_3833_212:()=>P2,content_3833_2120:()=>Pje,content_3833_2122:()=>Wje,content_3833_2124:()=>Gje,content_3833_2126:()=>Uje,content_3833_2128:()=>qje,content_3833_2130:()=>Yje,content_3833_2132:()=>Kje,content_3833_2134:()=>eHe,content_3833_2136:()=>oHe,content_3833_2138:()=>sHe,content_3833_214:()=>W2,content_3833_2140:()=>iHe,content_3833_2142:()=>mHe,content_3833_2144:()=>hHe,content_3833_2146:()=>DHe,content_3833_2148:()=>_He,content_3833_2150:()=>CHe,content_3833_2152:()=>vHe,content_3833_2154:()=>NHe,content_3833_2156:()=>PHe,content_3833_2158:()=>WHe,content_3833_216:()=>G2,content_3833_2160:()=>GHe,content_3833_2162:()=>UHe,content_3833_2164:()=>qHe,content_3833_2166:()=>YHe,content_3833_2168:()=>KHe,content_3833_2170:()=>eYe,content_3833_2172:()=>oYe,content_3833_2174:()=>sYe,content_3833_2176:()=>iYe,content_3833_2178:()=>mYe,content_3833_218:()=>U2,content_3833_2180:()=>hYe,content_3833_2182:()=>DYe,content_3833_2184:()=>_Ye,content_3833_2186:()=>CYe,content_3833_2188:()=>vYe,content_3833_2190:()=>NYe,content_3833_2192:()=>PYe,content_3833_2194:()=>WYe,content_3833_2196:()=>GYe,content_3833_2198:()=>UYe,content_3833_22:()=>DJ,content_3833_220:()=>q2,content_3833_2200:()=>qYe,content_3833_2202:()=>YYe,content_3833_2204:()=>KYe,content_3833_2206:()=>eQe,content_3833_2208:()=>oQe,content_3833_2210:()=>sQe,content_3833_2212:()=>iQe,content_3833_2214:()=>mQe,content_3833_2216:()=>hQe,content_3833_2218:()=>DQe,content_3833_222:()=>Y2,content_3833_2220:()=>_Qe,content_3833_2222:()=>CQe,content_3833_2224:()=>vQe,content_3833_2226:()=>NQe,content_3833_2228:()=>PQe,content_3833_2230:()=>WQe,content_3833_2232:()=>GQe,content_3833_2234:()=>UQe,content_3833_2236:()=>qQe,content_3833_2238:()=>YQe,content_3833_224:()=>K2,content_3833_2240:()=>KQe,content_3833_2242:()=>e$e,content_3833_2244:()=>o$e,content_3833_2246:()=>s$e,content_3833_2248:()=>i$e,content_3833_2250:()=>m$e,content_3833_2252:()=>h$e,content_3833_2254:()=>D$e,content_3833_2256:()=>_$e,content_3833_2258:()=>C$e,content_3833_226:()=>e1,content_3833_2260:()=>v$e,content_3833_2262:()=>N$e,content_3833_2264:()=>P$e,content_3833_2266:()=>W$e,content_3833_2268:()=>G$e,content_3833_2270:()=>U$e,content_3833_2272:()=>q$e,content_3833_2274:()=>Y$e,content_3833_2276:()=>K$e,content_3833_2278:()=>eKe,content_3833_228:()=>o1,content_3833_2280:()=>oKe,content_3833_2282:()=>sKe,content_3833_2284:()=>iKe,content_3833_2286:()=>mKe,content_3833_2288:()=>hKe,content_3833_2290:()=>DKe,content_3833_2292:()=>_Ke,content_3833_2294:()=>CKe,content_3833_2296:()=>vKe,content_3833_2298:()=>NKe,content_3833_230:()=>s1,content_3833_2300:()=>PKe,content_3833_2302:()=>WKe,content_3833_2304:()=>GKe,content_3833_2306:()=>UKe,content_3833_2308:()=>qKe,content_3833_2310:()=>YKe,content_3833_2312:()=>KKe,content_3833_2314:()=>eJe,content_3833_2316:()=>oJe,content_3833_2318:()=>sJe,content_3833_232:()=>i1,content_3833_2320:()=>iJe,content_3833_2322:()=>mJe,content_3833_2324:()=>hJe,content_3833_2326:()=>DJe,content_3833_2328:()=>_Je,content_3833_2330:()=>CJe,content_3833_2332:()=>vJe,content_3833_2334:()=>NJe,content_3833_2336:()=>PJe,content_3833_2338:()=>WJe,content_3833_234:()=>m1,content_3833_2340:()=>GJe,content_3833_2342:()=>UJe,content_3833_2344:()=>qJe,content_3833_2346:()=>YJe,content_3833_2348:()=>KJe,content_3833_2350:()=>eZe,content_3833_2352:()=>oZe,content_3833_2354:()=>sZe,content_3833_2356:()=>iZe,content_3833_2358:()=>mZe,content_3833_236:()=>h1,content_3833_2360:()=>hZe,content_3833_2362:()=>DZe,content_3833_2364:()=>_Ze,content_3833_2366:()=>CZe,content_3833_2368:()=>vZe,content_3833_2370:()=>NZe,content_3833_2372:()=>PZe,content_3833_2374:()=>WZe,content_3833_2376:()=>GZe,content_3833_2378:()=>UZe,content_3833_238:()=>D1,content_3833_2380:()=>qZe,content_3833_2382:()=>YZe,content_3833_2384:()=>KZe,content_3833_2386:()=>e0e,content_3833_2388:()=>o0e,content_3833_2390:()=>s0e,content_3833_2392:()=>i0e,content_3833_2394:()=>m0e,content_3833_2396:()=>h0e,content_3833_2398:()=>D0e,content_3833_24:()=>_J,content_3833_240:()=>_1,content_3833_2400:()=>_0e,content_3833_2402:()=>C0e,content_3833_2404:()=>v0e,content_3833_2406:()=>N0e,content_3833_2408:()=>P0e,content_3833_2410:()=>W0e,content_3833_2412:()=>G0e,content_3833_2414:()=>U0e,content_3833_2416:()=>q0e,content_3833_2418:()=>Y0e,content_3833_242:()=>C1,content_3833_2420:()=>K0e,content_3833_2422:()=>e3e,content_3833_2424:()=>o3e,content_3833_2426:()=>s3e,content_3833_2428:()=>i3e,content_3833_2430:()=>m3e,content_3833_2432:()=>h3e,content_3833_2434:()=>D3e,content_3833_2436:()=>_3e,content_3833_2438:()=>C3e,content_3833_244:()=>v1,content_3833_2440:()=>v3e,content_3833_2442:()=>N3e,content_3833_2444:()=>P3e,content_3833_2446:()=>W3e,content_3833_2448:()=>G3e,content_3833_2450:()=>U3e,content_3833_2452:()=>q3e,content_3833_2454:()=>Y3e,content_3833_2456:()=>K3e,content_3833_2458:()=>e8e,content_3833_246:()=>N1,content_3833_2460:()=>o8e,content_3833_2462:()=>s8e,content_3833_2464:()=>i8e,content_3833_2466:()=>m8e,content_3833_2468:()=>h8e,content_3833_2470:()=>D8e,content_3833_2472:()=>_8e,content_3833_2474:()=>C8e,content_3833_2476:()=>v8e,content_3833_2478:()=>N8e,content_3833_248:()=>P1,content_3833_2480:()=>P8e,content_3833_2482:()=>W8e,content_3833_2484:()=>G8e,content_3833_2486:()=>U8e,content_3833_2488:()=>q8e,content_3833_2490:()=>Y8e,content_3833_2492:()=>K8e,content_3833_2494:()=>e2e,content_3833_2496:()=>o2e,content_3833_2498:()=>s2e,content_3833_250:()=>W1,content_3833_2500:()=>i2e,content_3833_2502:()=>m2e,content_3833_2504:()=>h2e,content_3833_2506:()=>D2e,content_3833_2508:()=>_2e,content_3833_2510:()=>C2e,content_3833_2512:()=>v2e,content_3833_2514:()=>N2e,content_3833_2516:()=>P2e,content_3833_2518:()=>W2e,content_3833_252:()=>G1,content_3833_2520:()=>G2e,content_3833_2522:()=>U2e,content_3833_2524:()=>q2e,content_3833_2526:()=>Y2e,content_3833_2528:()=>K2e,content_3833_2530:()=>e1e,content_3833_2532:()=>o1e,content_3833_2534:()=>s1e,content_3833_2536:()=>i1e,content_3833_2538:()=>m1e,content_3833_254:()=>U1,content_3833_2540:()=>h1e,content_3833_2542:()=>D1e,content_3833_2544:()=>_1e,content_3833_2546:()=>C1e,content_3833_2548:()=>v1e,content_3833_2550:()=>N1e,content_3833_2552:()=>P1e,content_3833_2554:()=>W1e,content_3833_2556:()=>G1e,content_3833_2558:()=>U1e,content_3833_256:()=>q1,content_3833_2560:()=>q1e,content_3833_2562:()=>Y1e,content_3833_2564:()=>K1e,content_3833_2566:()=>e4e,content_3833_2568:()=>o4e,content_3833_2570:()=>s4e,content_3833_2572:()=>i4e,content_3833_2574:()=>m4e,content_3833_2576:()=>h4e,content_3833_2578:()=>D4e,content_3833_258:()=>Y1,content_3833_2580:()=>_4e,content_3833_2582:()=>C4e,content_3833_2584:()=>v4e,content_3833_2586:()=>N4e,content_3833_2588:()=>P4e,content_3833_2590:()=>W4e,content_3833_2592:()=>G4e,content_3833_2594:()=>U4e,content_3833_2596:()=>q4e,content_3833_2598:()=>Y4e,content_3833_26:()=>CJ,content_3833_260:()=>K1,content_3833_2600:()=>K4e,content_3833_2602:()=>e6e,content_3833_2604:()=>o6e,content_3833_2606:()=>s6e,content_3833_2608:()=>i6e,content_3833_2610:()=>m6e,content_3833_2612:()=>h6e,content_3833_2614:()=>D6e,content_3833_2616:()=>_6e,content_3833_2618:()=>C6e,content_3833_262:()=>e4,content_3833_2620:()=>v6e,content_3833_2622:()=>N6e,content_3833_2624:()=>P6e,content_3833_2626:()=>W6e,content_3833_2628:()=>G6e,content_3833_2630:()=>U6e,content_3833_2632:()=>q6e,content_3833_2634:()=>Y6e,content_3833_2636:()=>K6e,content_3833_2638:()=>e5e,content_3833_264:()=>o4,content_3833_2640:()=>o5e,content_3833_2642:()=>s5e,content_3833_2644:()=>i5e,content_3833_2646:()=>m5e,content_3833_2648:()=>h5e,content_3833_2650:()=>D5e,content_3833_2652:()=>_5e,content_3833_2654:()=>C5e,content_3833_2656:()=>v5e,content_3833_2658:()=>N5e,content_3833_266:()=>s4,content_3833_2660:()=>P5e,content_3833_2662:()=>W5e,content_3833_2664:()=>G5e,content_3833_2666:()=>U5e,content_3833_2668:()=>q5e,content_3833_2670:()=>Y5e,content_3833_2672:()=>K5e,content_3833_2674:()=>e7e,content_3833_2676:()=>o7e,content_3833_2678:()=>s7e,content_3833_268:()=>i4,content_3833_2680:()=>i7e,content_3833_2682:()=>m7e,content_3833_2684:()=>h7e,content_3833_2686:()=>D7e,content_3833_2688:()=>_7e,content_3833_2690:()=>C7e,content_3833_2692:()=>v7e,content_3833_2694:()=>N7e,content_3833_2696:()=>P7e,content_3833_2698:()=>W7e,content_3833_270:()=>m4,content_3833_2700:()=>G7e,content_3833_2702:()=>U7e,content_3833_2704:()=>q7e,content_3833_2706:()=>Y7e,content_3833_2708:()=>K7e,content_3833_2710:()=>e9e,content_3833_2712:()=>o9e,content_3833_2714:()=>s9e,content_3833_2716:()=>i9e,content_3833_2718:()=>m9e,content_3833_272:()=>h4,content_3833_2720:()=>h9e,content_3833_2722:()=>D9e,content_3833_2724:()=>_9e,content_3833_2726:()=>C9e,content_3833_2728:()=>v9e,content_3833_2730:()=>N9e,content_3833_2732:()=>P9e,content_3833_2734:()=>W9e,content_3833_2736:()=>G9e,content_3833_2738:()=>U9e,content_3833_274:()=>D4,content_3833_2740:()=>q9e,content_3833_2742:()=>Y9e,content_3833_2744:()=>K9e,content_3833_2746:()=>een,content_3833_2748:()=>oen,content_3833_2750:()=>sen,content_3833_2752:()=>ien,content_3833_2754:()=>men,content_3833_2756:()=>hen,content_3833_2758:()=>Den,content_3833_276:()=>_4,content_3833_2760:()=>_en,content_3833_2762:()=>Cen,content_3833_2764:()=>ven,content_3833_2766:()=>Nen,content_3833_2768:()=>Pen,content_3833_2770:()=>Wen,content_3833_2772:()=>Gen,content_3833_2774:()=>Uen,content_3833_2776:()=>qen,content_3833_2778:()=>Yen,content_3833_278:()=>C4,content_3833_2780:()=>Ken,content_3833_2782:()=>enn,content_3833_2784:()=>onn,content_3833_2786:()=>snn,content_3833_2788:()=>inn,content_3833_2790:()=>mnn,content_3833_2792:()=>hnn,content_3833_2794:()=>Dnn,content_3833_2796:()=>_nn,content_3833_2798:()=>Cnn,content_3833_28:()=>vJ,content_3833_280:()=>v4,content_3833_2800:()=>vnn,content_3833_2802:()=>Nnn,content_3833_2804:()=>Pnn,content_3833_2806:()=>Wnn,content_3833_2808:()=>Gnn,content_3833_2810:()=>Unn,content_3833_2812:()=>qnn,content_3833_2814:()=>Ynn,content_3833_2816:()=>Knn,content_3833_2818:()=>etn,content_3833_282:()=>N4,content_3833_2820:()=>otn,content_3833_2822:()=>stn,content_3833_2824:()=>itn,content_3833_2826:()=>mtn,content_3833_2828:()=>htn,content_3833_2830:()=>Dtn,content_3833_2832:()=>_tn,content_3833_2834:()=>Ctn,content_3833_2836:()=>vtn,content_3833_2838:()=>Ntn,content_3833_284:()=>P4,content_3833_2840:()=>Ptn,content_3833_2842:()=>Wtn,content_3833_2844:()=>Gtn,content_3833_2846:()=>Utn,content_3833_2848:()=>qtn,content_3833_2850:()=>Ytn,content_3833_2852:()=>Ktn,content_3833_2854:()=>eon,content_3833_2856:()=>oon,content_3833_2858:()=>son,content_3833_286:()=>W4,content_3833_2860:()=>ion,content_3833_2862:()=>mon,content_3833_2864:()=>hon,content_3833_2866:()=>Don,content_3833_2868:()=>_on,content_3833_2870:()=>Con,content_3833_2872:()=>von,content_3833_2874:()=>Non,content_3833_2876:()=>Pon,content_3833_2878:()=>Won,content_3833_288:()=>G4,content_3833_2880:()=>Gon,content_3833_2882:()=>Uon,content_3833_2884:()=>qon,content_3833_2886:()=>Yon,content_3833_2888:()=>Kon,content_3833_2890:()=>epn,content_3833_2892:()=>opn,content_3833_2894:()=>spn,content_3833_2896:()=>ipn,content_3833_2898:()=>mpn,content_3833_290:()=>U4,content_3833_2900:()=>hpn,content_3833_2902:()=>Dpn,content_3833_2904:()=>_pn,content_3833_2906:()=>Cpn,content_3833_2908:()=>vpn,content_3833_2910:()=>Npn,content_3833_2912:()=>Ppn,content_3833_2914:()=>Wpn,content_3833_2916:()=>Gpn,content_3833_2918:()=>Upn,content_3833_292:()=>q4,content_3833_2920:()=>qpn,content_3833_2922:()=>Ypn,content_3833_2924:()=>Kpn,content_3833_2926:()=>ern,content_3833_2928:()=>orn,content_3833_2930:()=>srn,content_3833_2932:()=>irn,content_3833_2934:()=>mrn,content_3833_2936:()=>hrn,content_3833_2938:()=>Drn,content_3833_294:()=>Y4,content_3833_2940:()=>_rn,content_3833_2942:()=>Crn,content_3833_2944:()=>vrn,content_3833_2946:()=>Nrn,content_3833_2948:()=>Prn,content_3833_2950:()=>Wrn,content_3833_2952:()=>Grn,content_3833_2954:()=>Urn,content_3833_2956:()=>qrn,content_3833_2958:()=>Yrn,content_3833_296:()=>K4,content_3833_2960:()=>Krn,content_3833_2962:()=>esn,content_3833_2964:()=>osn,content_3833_2966:()=>ssn,content_3833_2968:()=>isn,content_3833_2970:()=>msn,content_3833_2972:()=>hsn,content_3833_2974:()=>Dsn,content_3833_2976:()=>_sn,content_3833_2978:()=>Csn,content_3833_298:()=>e6,content_3833_2980:()=>vsn,content_3833_2982:()=>Nsn,content_3833_2984:()=>Psn,content_3833_2986:()=>Wsn,content_3833_2988:()=>Gsn,content_3833_2990:()=>Usn,content_3833_2992:()=>qsn,content_3833_2994:()=>Ysn,content_3833_2996:()=>Ksn,content_3833_2998:()=>ecn,content_3833_30:()=>NJ,content_3833_300:()=>o6,content_3833_3000:()=>ocn,content_3833_3002:()=>scn,content_3833_3004:()=>icn,content_3833_3006:()=>mcn,content_3833_3008:()=>hcn,content_3833_3010:()=>Dcn,content_3833_3012:()=>_cn,content_3833_3014:()=>Ccn,content_3833_3016:()=>vcn,content_3833_3018:()=>Ncn,content_3833_302:()=>s6,content_3833_3020:()=>Pcn,content_3833_3022:()=>Wcn,content_3833_3024:()=>Gcn,content_3833_3026:()=>Ucn,content_3833_3028:()=>qcn,content_3833_3030:()=>Ycn,content_3833_3032:()=>Kcn,content_3833_3034:()=>ean,content_3833_3036:()=>oan,content_3833_3038:()=>san,content_3833_304:()=>i6,content_3833_3040:()=>ian,content_3833_3042:()=>man,content_3833_3044:()=>han,content_3833_3046:()=>Dan,content_3833_3048:()=>_an,content_3833_3050:()=>Can,content_3833_3052:()=>van,content_3833_3054:()=>Nan,content_3833_3056:()=>Pan,content_3833_3058:()=>Wan,content_3833_306:()=>m6,content_3833_3060:()=>Gan,content_3833_3062:()=>Uan,content_3833_3064:()=>qan,content_3833_3066:()=>Yan,content_3833_3068:()=>Kan,content_3833_3070:()=>ein,content_3833_3072:()=>oin,content_3833_3074:()=>sin,content_3833_3076:()=>iin,content_3833_3078:()=>min,content_3833_308:()=>h6,content_3833_3080:()=>hin,content_3833_3082:()=>Din,content_3833_3084:()=>_in,content_3833_3086:()=>Cin,content_3833_3088:()=>vin,content_3833_3090:()=>Nin,content_3833_3092:()=>Pin,content_3833_3094:()=>Win,content_3833_3096:()=>Gin,content_3833_3098:()=>Uin,content_3833_310:()=>D6,content_3833_3100:()=>qin,content_3833_3102:()=>Yin,content_3833_3104:()=>Kin,content_3833_3106:()=>eln,content_3833_3108:()=>oln,content_3833_3110:()=>sln,content_3833_3112:()=>iln,content_3833_3114:()=>mln,content_3833_3116:()=>hln,content_3833_3118:()=>Dln,content_3833_312:()=>_6,content_3833_3120:()=>_ln,content_3833_3122:()=>Cln,content_3833_3124:()=>vln,content_3833_3126:()=>Nln,content_3833_3128:()=>Pln,content_3833_3130:()=>Wln,content_3833_3132:()=>Gln,content_3833_3134:()=>Uln,content_3833_3136:()=>qln,content_3833_3138:()=>Yln,content_3833_314:()=>C6,content_3833_3140:()=>Kln,content_3833_3142:()=>eun,content_3833_3144:()=>oun,content_3833_3146:()=>sun,content_3833_3148:()=>iun,content_3833_3150:()=>mun,content_3833_3152:()=>hun,content_3833_3154:()=>Dun,content_3833_3156:()=>_un,content_3833_3158:()=>Cun,content_3833_316:()=>v6,content_3833_3160:()=>vun,content_3833_3162:()=>Nun,content_3833_3164:()=>Pun,content_3833_3166:()=>Wun,content_3833_3168:()=>Gun,content_3833_3170:()=>Uun,content_3833_3172:()=>qun,content_3833_3174:()=>Yun,content_3833_3176:()=>Kun,content_3833_3178:()=>emn,content_3833_318:()=>N6,content_3833_3180:()=>omn,content_3833_3182:()=>smn,content_3833_3184:()=>imn,content_3833_3186:()=>mmn,content_3833_3188:()=>hmn,content_3833_3190:()=>Dmn,content_3833_3192:()=>_mn,content_3833_3194:()=>Cmn,content_3833_3196:()=>vmn,content_3833_3198:()=>Nmn,content_3833_32:()=>PJ,content_3833_320:()=>P6,content_3833_3200:()=>Pmn,content_3833_3202:()=>Wmn,content_3833_3204:()=>Gmn,content_3833_3206:()=>Umn,content_3833_3208:()=>qmn,content_3833_3210:()=>Ymn,content_3833_3212:()=>Kmn,content_3833_3214:()=>eyn,content_3833_3216:()=>oyn,content_3833_3218:()=>syn,content_3833_322:()=>W6,content_3833_3220:()=>iyn,content_3833_3222:()=>myn,content_3833_3224:()=>hyn,content_3833_3226:()=>Dyn,content_3833_3228:()=>_yn,content_3833_3230:()=>Cyn,content_3833_3232:()=>vyn,content_3833_3234:()=>Nyn,content_3833_3236:()=>Pyn,content_3833_3238:()=>Wyn,content_3833_324:()=>G6,content_3833_3240:()=>Gyn,content_3833_3242:()=>Uyn,content_3833_3244:()=>qyn,content_3833_3246:()=>Yyn,content_3833_3248:()=>Kyn,content_3833_3250:()=>edn,content_3833_3252:()=>odn,content_3833_3254:()=>sdn,content_3833_3256:()=>idn,content_3833_3258:()=>mdn,content_3833_326:()=>U6,content_3833_3260:()=>hdn,content_3833_3262:()=>Ddn,content_3833_3264:()=>_dn,content_3833_3266:()=>Cdn,content_3833_3268:()=>vdn,content_3833_3270:()=>Ndn,content_3833_3272:()=>Pdn,content_3833_3274:()=>Wdn,content_3833_3276:()=>Gdn,content_3833_3278:()=>Udn,content_3833_328:()=>q6,content_3833_3280:()=>qdn,content_3833_3282:()=>Ydn,content_3833_3284:()=>Kdn,content_3833_3286:()=>ehn,content_3833_3288:()=>ohn,content_3833_3290:()=>shn,content_3833_3292:()=>ihn,content_3833_3294:()=>mhn,content_3833_3296:()=>hhn,content_3833_3298:()=>Dhn,content_3833_330:()=>Y6,content_3833_3300:()=>_hn,content_3833_3302:()=>Chn,content_3833_3304:()=>vhn,content_3833_3306:()=>Nhn,content_3833_3308:()=>Phn,content_3833_3310:()=>Whn,content_3833_3312:()=>Ghn,content_3833_3314:()=>Uhn,content_3833_3316:()=>qhn,content_3833_3318:()=>Yhn,content_3833_332:()=>K6,content_3833_3320:()=>Khn,content_3833_3322:()=>egn,content_3833_3324:()=>ogn,content_3833_3326:()=>sgn,content_3833_3328:()=>ign,content_3833_3330:()=>mgn,content_3833_3332:()=>hgn,content_3833_3334:()=>Dgn,content_3833_3336:()=>_gn,content_3833_3338:()=>Cgn,content_3833_334:()=>e5,content_3833_3340:()=>vgn,content_3833_3342:()=>Ngn,content_3833_3344:()=>Pgn,content_3833_3346:()=>Wgn,content_3833_3348:()=>Ggn,content_3833_3350:()=>Ugn,content_3833_3352:()=>qgn,content_3833_3354:()=>Ygn,content_3833_3356:()=>Kgn,content_3833_3358:()=>efn,content_3833_336:()=>o5,content_3833_3360:()=>ofn,content_3833_3362:()=>sfn,content_3833_3364:()=>ifn,content_3833_3366:()=>mfn,content_3833_3368:()=>hfn,content_3833_3370:()=>Dfn,content_3833_3372:()=>_fn,content_3833_3374:()=>Cfn,content_3833_3376:()=>vfn,content_3833_3378:()=>Nfn,content_3833_338:()=>s5,content_3833_3380:()=>Pfn,content_3833_3382:()=>Wfn,content_3833_3384:()=>Gfn,content_3833_3386:()=>Ufn,content_3833_3388:()=>qfn,content_3833_3390:()=>Yfn,content_3833_3392:()=>Kfn,content_3833_3394:()=>eDn,content_3833_3396:()=>oDn,content_3833_3398:()=>sDn,content_3833_34:()=>WJ,content_3833_340:()=>i5,content_3833_3400:()=>iDn,content_3833_3402:()=>mDn,content_3833_3404:()=>hDn,content_3833_3406:()=>DDn,content_3833_3408:()=>_Dn,content_3833_3410:()=>CDn,content_3833_3412:()=>vDn,content_3833_3414:()=>NDn,content_3833_3416:()=>PDn,content_3833_3418:()=>WDn,content_3833_342:()=>m5,content_3833_3420:()=>GDn,content_3833_3422:()=>UDn,content_3833_3424:()=>qDn,content_3833_3426:()=>YDn,content_3833_3428:()=>KDn,content_3833_3430:()=>eMn,content_3833_3432:()=>oMn,content_3833_3434:()=>sMn,content_3833_3436:()=>iMn,content_3833_3438:()=>mMn,content_3833_344:()=>h5,content_3833_3440:()=>hMn,content_3833_3442:()=>DMn,content_3833_3444:()=>_Mn,content_3833_3446:()=>CMn,content_3833_3448:()=>vMn,content_3833_3450:()=>NMn,content_3833_3452:()=>PMn,content_3833_3454:()=>WMn,content_3833_3456:()=>GMn,content_3833_3458:()=>UMn,content_3833_346:()=>D5,content_3833_3460:()=>qMn,content_3833_3462:()=>YMn,content_3833_3464:()=>KMn,content_3833_3466:()=>eXn,content_3833_3468:()=>oXn,content_3833_3470:()=>sXn,content_3833_3472:()=>iXn,content_3833_3474:()=>mXn,content_3833_3476:()=>hXn,content_3833_3478:()=>DXn,content_3833_348:()=>_5,content_3833_3480:()=>_Xn,content_3833_3482:()=>CXn,content_3833_3484:()=>vXn,content_3833_3486:()=>NXn,content_3833_3488:()=>PXn,content_3833_3490:()=>WXn,content_3833_3492:()=>GXn,content_3833_3494:()=>UXn,content_3833_3496:()=>qXn,content_3833_3498:()=>YXn,content_3833_350:()=>C5,content_3833_3500:()=>KXn,content_3833_3502:()=>e_n,content_3833_3504:()=>o_n,content_3833_3506:()=>s_n,content_3833_3508:()=>i_n,content_3833_3510:()=>m_n,content_3833_3512:()=>h_n,content_3833_3514:()=>D_n,content_3833_3516:()=>__n,content_3833_3518:()=>C_n,content_3833_352:()=>v5,content_3833_3520:()=>v_n,content_3833_3522:()=>N_n,content_3833_3524:()=>P_n,content_3833_3526:()=>W_n,content_3833_3528:()=>G_n,content_3833_3530:()=>U_n,content_3833_3532:()=>q_n,content_3833_3534:()=>Y_n,content_3833_3536:()=>K_n,content_3833_3538:()=>ewn,content_3833_354:()=>N5,content_3833_3540:()=>own,content_3833_3542:()=>swn,content_3833_3544:()=>iwn,content_3833_3546:()=>mwn,content_3833_3548:()=>hwn,content_3833_3550:()=>Dwn,content_3833_3552:()=>_wn,content_3833_3554:()=>Cwn,content_3833_3556:()=>vwn,content_3833_3558:()=>Nwn,content_3833_356:()=>P5,content_3833_3560:()=>Pwn,content_3833_3562:()=>Wwn,content_3833_3564:()=>Gwn,content_3833_3566:()=>Uwn,content_3833_3568:()=>qwn,content_3833_3570:()=>Ywn,content_3833_3572:()=>Kwn,content_3833_3574:()=>eTn,content_3833_3576:()=>oTn,content_3833_3578:()=>sTn,content_3833_358:()=>W5,content_3833_3580:()=>iTn,content_3833_3582:()=>mTn,content_3833_3584:()=>hTn,content_3833_3586:()=>DTn,content_3833_3588:()=>_Tn,content_3833_3590:()=>CTn,content_3833_3592:()=>vTn,content_3833_3594:()=>NTn,content_3833_3596:()=>PTn,content_3833_3598:()=>WTn,content_3833_36:()=>GJ,content_3833_360:()=>G5,content_3833_3600:()=>GTn,content_3833_3602:()=>UTn,content_3833_3604:()=>qTn,content_3833_3606:()=>YTn,content_3833_3608:()=>KTn,content_3833_3610:()=>eCn,content_3833_3612:()=>oCn,content_3833_3614:()=>sCn,content_3833_3616:()=>iCn,content_3833_3618:()=>mCn,content_3833_362:()=>U5,content_3833_3620:()=>hCn,content_3833_3622:()=>DCn,content_3833_3624:()=>_Cn,content_3833_3626:()=>CCn,content_3833_3628:()=>vCn,content_3833_3630:()=>NCn,content_3833_3632:()=>PCn,content_3833_3634:()=>WCn,content_3833_3636:()=>GCn,content_3833_3638:()=>UCn,content_3833_364:()=>q5,content_3833_3640:()=>qCn,content_3833_3642:()=>YCn,content_3833_3644:()=>KCn,content_3833_3646:()=>exn,content_3833_3648:()=>oxn,content_3833_3650:()=>sxn,content_3833_3652:()=>ixn,content_3833_3654:()=>mxn,content_3833_3656:()=>hxn,content_3833_3658:()=>Dxn,content_3833_366:()=>Y5,content_3833_3660:()=>_xn,content_3833_3662:()=>Cxn,content_3833_3664:()=>vxn,content_3833_3666:()=>Nxn,content_3833_3668:()=>Pxn,content_3833_3670:()=>Wxn,content_3833_3672:()=>Gxn,content_3833_3674:()=>Uxn,content_3833_3676:()=>qxn,content_3833_3678:()=>Yxn,content_3833_368:()=>K5,content_3833_3680:()=>Kxn,content_3833_3682:()=>eAn,content_3833_3684:()=>oAn,content_3833_3686:()=>sAn,content_3833_3688:()=>iAn,content_3833_3690:()=>mAn,content_3833_3692:()=>hAn,content_3833_3694:()=>DAn,content_3833_3696:()=>_An,content_3833_3698:()=>CAn,content_3833_370:()=>e7,content_3833_3700:()=>vAn,content_3833_3702:()=>NAn,content_3833_3704:()=>PAn,content_3833_3706:()=>WAn,content_3833_3708:()=>GAn,content_3833_3710:()=>UAn,content_3833_3712:()=>qAn,content_3833_3714:()=>YAn,content_3833_3716:()=>KAn,content_3833_3718:()=>evn,content_3833_372:()=>o7,content_3833_3720:()=>ovn,content_3833_3722:()=>svn,content_3833_3724:()=>ivn,content_3833_3726:()=>mvn,content_3833_3728:()=>hvn,content_3833_3730:()=>Dvn,content_3833_3732:()=>_vn,content_3833_3734:()=>Cvn,content_3833_3736:()=>vvn,content_3833_3738:()=>Nvn,content_3833_374:()=>s7,content_3833_3740:()=>Pvn,content_3833_3742:()=>Wvn,content_3833_3744:()=>Gvn,content_3833_3746:()=>Uvn,content_3833_3748:()=>qvn,content_3833_3750:()=>Yvn,content_3833_3752:()=>Kvn,content_3833_3754:()=>eLn,content_3833_3756:()=>oLn,content_3833_3758:()=>sLn,content_3833_376:()=>i7,content_3833_3760:()=>iLn,content_3833_3762:()=>mLn,content_3833_3764:()=>hLn,content_3833_3766:()=>DLn,content_3833_3768:()=>_Ln,content_3833_3770:()=>CLn,content_3833_3772:()=>vLn,content_3833_3774:()=>NLn,content_3833_3776:()=>PLn,content_3833_3778:()=>WLn,content_3833_378:()=>m7,content_3833_3780:()=>GLn,content_3833_3782:()=>ULn,content_3833_3784:()=>qLn,content_3833_3786:()=>YLn,content_3833_3788:()=>KLn,content_3833_3790:()=>ebn,content_3833_3792:()=>obn,content_3833_3794:()=>sbn,content_3833_3796:()=>ibn,content_3833_3798:()=>mbn,content_3833_38:()=>UJ,content_3833_380:()=>h7,content_3833_3800:()=>hbn,content_3833_3802:()=>Dbn,content_3833_3804:()=>_bn,content_3833_3806:()=>Cbn,content_3833_3808:()=>vbn,content_3833_3810:()=>Nbn,content_3833_3812:()=>Pbn,content_3833_3814:()=>Wbn,content_3833_3816:()=>Gbn,content_3833_3818:()=>Ubn,content_3833_382:()=>D7,content_3833_3820:()=>qbn,content_3833_3822:()=>Ybn,content_3833_3824:()=>Kbn,content_3833_3826:()=>eNn,content_3833_3828:()=>oNn,content_3833_3830:()=>sNn,content_3833_3832:()=>iNn,content_3833_3834:()=>mNn,content_3833_3836:()=>hNn,content_3833_3838:()=>DNn,content_3833_384:()=>_7,content_3833_3840:()=>_Nn,content_3833_3842:()=>CNn,content_3833_3844:()=>vNn,content_3833_3846:()=>NNn,content_3833_3848:()=>PNn,content_3833_3850:()=>WNn,content_3833_3852:()=>GNn,content_3833_3854:()=>UNn,content_3833_3856:()=>qNn,content_3833_3858:()=>YNn,content_3833_386:()=>C7,content_3833_3860:()=>KNn,content_3833_3862:()=>ekn,content_3833_3864:()=>okn,content_3833_3866:()=>skn,content_3833_3868:()=>ikn,content_3833_3870:()=>mkn,content_3833_3872:()=>hkn,content_3833_3874:()=>Dkn,content_3833_3876:()=>_kn,content_3833_3878:()=>Ckn,content_3833_388:()=>v7,content_3833_3880:()=>vkn,content_3833_3882:()=>Nkn,content_3833_3884:()=>Pkn,content_3833_3886:()=>Wkn,content_3833_3888:()=>Gkn,content_3833_3890:()=>Ukn,content_3833_3892:()=>qkn,content_3833_3894:()=>Ykn,content_3833_3896:()=>Kkn,content_3833_3898:()=>ezn,content_3833_390:()=>N7,content_3833_3900:()=>ozn,content_3833_3902:()=>szn,content_3833_3904:()=>izn,content_3833_3906:()=>mzn,content_3833_3908:()=>hzn,content_3833_3910:()=>Dzn,content_3833_3912:()=>_zn,content_3833_3914:()=>Czn,content_3833_3916:()=>vzn,content_3833_3918:()=>Nzn,content_3833_392:()=>P7,content_3833_3920:()=>Pzn,content_3833_3922:()=>Wzn,content_3833_3924:()=>Gzn,content_3833_3926:()=>Uzn,content_3833_3928:()=>qzn,content_3833_3930:()=>Yzn,content_3833_3932:()=>Kzn,content_3833_3934:()=>ePn,content_3833_3936:()=>oPn,content_3833_3938:()=>sPn,content_3833_394:()=>W7,content_3833_3940:()=>iPn,content_3833_3942:()=>mPn,content_3833_3944:()=>hPn,content_3833_3946:()=>DPn,content_3833_3948:()=>_Pn,content_3833_3950:()=>CPn,content_3833_3952:()=>vPn,content_3833_3954:()=>NPn,content_3833_3956:()=>PPn,content_3833_3958:()=>WPn,content_3833_396:()=>G7,content_3833_3960:()=>GPn,content_3833_3962:()=>UPn,content_3833_3964:()=>qPn,content_3833_3966:()=>YPn,content_3833_3968:()=>KPn,content_3833_3970:()=>eIn,content_3833_3972:()=>oIn,content_3833_3974:()=>sIn,content_3833_3976:()=>iIn,content_3833_3978:()=>mIn,content_3833_398:()=>U7,content_3833_3980:()=>hIn,content_3833_3982:()=>DIn,content_3833_3984:()=>_In,content_3833_3986:()=>CIn,content_3833_3988:()=>vIn,content_3833_3990:()=>NIn,content_3833_3992:()=>PIn,content_3833_3994:()=>WIn,content_3833_3996:()=>GIn,content_3833_3998:()=>UIn,content_3833_4:()=>qK,content_3833_40:()=>qJ,content_3833_400:()=>q7,content_3833_4000:()=>qIn,content_3833_4002:()=>YIn,content_3833_4004:()=>KIn,content_3833_4006:()=>eRn,content_3833_4008:()=>oRn,content_3833_4010:()=>sRn,content_3833_4012:()=>iRn,content_3833_4014:()=>mRn,content_3833_4016:()=>hRn,content_3833_4018:()=>DRn,content_3833_402:()=>Y7,content_3833_4020:()=>_Rn,content_3833_4022:()=>CRn,content_3833_4024:()=>vRn,content_3833_4026:()=>NRn,content_3833_4028:()=>PRn,content_3833_4030:()=>WRn,content_3833_4032:()=>GRn,content_3833_4034:()=>URn,content_3833_4036:()=>qRn,content_3833_4038:()=>YRn,content_3833_404:()=>K7,content_3833_4040:()=>KRn,content_3833_4042:()=>eWn,content_3833_4044:()=>oWn,content_3833_4046:()=>sWn,content_3833_4048:()=>iWn,content_3833_4050:()=>mWn,content_3833_4052:()=>hWn,content_3833_4054:()=>DWn,content_3833_4056:()=>_Wn,content_3833_4058:()=>CWn,content_3833_406:()=>e9,content_3833_4060:()=>vWn,content_3833_4062:()=>NWn,content_3833_4064:()=>PWn,content_3833_4066:()=>WWn,content_3833_4068:()=>GWn,content_3833_4070:()=>UWn,content_3833_4072:()=>qWn,content_3833_4074:()=>YWn,content_3833_4076:()=>KWn,content_3833_4078:()=>eSn,content_3833_408:()=>o9,content_3833_4080:()=>oSn,content_3833_4082:()=>sSn,content_3833_4084:()=>iSn,content_3833_4086:()=>mSn,content_3833_4088:()=>hSn,content_3833_4090:()=>DSn,content_3833_4092:()=>_Sn,content_3833_4094:()=>CSn,content_3833_4096:()=>vSn,content_3833_4098:()=>NSn,content_3833_410:()=>s9,content_3833_4100:()=>PSn,content_3833_4102:()=>WSn,content_3833_4104:()=>GSn,content_3833_4106:()=>USn,content_3833_4108:()=>qSn,content_3833_4110:()=>YSn,content_3833_4112:()=>KSn,content_3833_4114:()=>eBn,content_3833_4116:()=>oBn,content_3833_4118:()=>sBn,content_3833_412:()=>i9,content_3833_4120:()=>iBn,content_3833_4122:()=>mBn,content_3833_4124:()=>hBn,content_3833_4126:()=>DBn,content_3833_4128:()=>_Bn,content_3833_4130:()=>CBn,content_3833_4132:()=>vBn,content_3833_4134:()=>NBn,content_3833_4136:()=>PBn,content_3833_4138:()=>WBn,content_3833_414:()=>m9,content_3833_4140:()=>GBn,content_3833_4142:()=>UBn,content_3833_4144:()=>qBn,content_3833_4146:()=>YBn,content_3833_4148:()=>KBn,content_3833_4150:()=>eGn,content_3833_4152:()=>oGn,content_3833_4154:()=>sGn,content_3833_4156:()=>iGn,content_3833_4158:()=>mGn,content_3833_416:()=>h9,content_3833_4160:()=>hGn,content_3833_4162:()=>DGn,content_3833_4164:()=>_Gn,content_3833_4166:()=>CGn,content_3833_4168:()=>vGn,content_3833_4170:()=>NGn,content_3833_4172:()=>PGn,content_3833_4174:()=>WGn,content_3833_4176:()=>GGn,content_3833_4178:()=>UGn,content_3833_418:()=>D9,content_3833_4180:()=>qGn,content_3833_4182:()=>YGn,content_3833_4184:()=>KGn,content_3833_4186:()=>eEn,content_3833_4188:()=>oEn,content_3833_4190:()=>sEn,content_3833_4192:()=>iEn,content_3833_4194:()=>mEn,content_3833_4196:()=>hEn,content_3833_4198:()=>DEn,content_3833_42:()=>YJ,content_3833_420:()=>_9,content_3833_4200:()=>_En,content_3833_4202:()=>CEn,content_3833_4204:()=>vEn,content_3833_4206:()=>NEn,content_3833_4208:()=>PEn,content_3833_4210:()=>WEn,content_3833_4212:()=>GEn,content_3833_4214:()=>UEn,content_3833_4216:()=>qEn,content_3833_4218:()=>YEn,content_3833_422:()=>C9,content_3833_4220:()=>KEn,content_3833_4222:()=>eOn,content_3833_4224:()=>oOn,content_3833_4226:()=>sOn,content_3833_4228:()=>iOn,content_3833_4230:()=>mOn,content_3833_4232:()=>hOn,content_3833_4234:()=>DOn,content_3833_4236:()=>_On,content_3833_4238:()=>COn,content_3833_424:()=>v9,content_3833_4240:()=>vOn,content_3833_4242:()=>NOn,content_3833_4244:()=>POn,content_3833_4246:()=>WOn,content_3833_4248:()=>GOn,content_3833_4250:()=>UOn,content_3833_4252:()=>qOn,content_3833_4254:()=>YOn,content_3833_4256:()=>KOn,content_3833_4258:()=>eUn,content_3833_426:()=>N9,content_3833_4260:()=>oUn,content_3833_4262:()=>sUn,content_3833_4264:()=>iUn,content_3833_4266:()=>mUn,content_3833_4268:()=>hUn,content_3833_4270:()=>DUn,content_3833_4272:()=>_Un,content_3833_4274:()=>CUn,content_3833_4276:()=>vUn,content_3833_4278:()=>NUn,content_3833_428:()=>P9,content_3833_4280:()=>PUn,content_3833_4282:()=>WUn,content_3833_4284:()=>GUn,content_3833_4286:()=>UUn,content_3833_4288:()=>qUn,content_3833_4290:()=>YUn,content_3833_4292:()=>KUn,content_3833_4294:()=>eFn,content_3833_4296:()=>oFn,content_3833_4298:()=>sFn,content_3833_430:()=>W9,content_3833_4300:()=>iFn,content_3833_4302:()=>mFn,content_3833_4304:()=>hFn,content_3833_4306:()=>DFn,content_3833_4308:()=>_Fn,content_3833_4310:()=>CFn,content_3833_4312:()=>vFn,content_3833_4314:()=>NFn,content_3833_4316:()=>PFn,content_3833_4318:()=>WFn,content_3833_432:()=>G9,content_3833_4320:()=>GFn,content_3833_4322:()=>UFn,content_3833_4324:()=>qFn,content_3833_4326:()=>YFn,content_3833_4328:()=>KFn,content_3833_4330:()=>eVn,content_3833_4332:()=>oVn,content_3833_4334:()=>sVn,content_3833_4336:()=>iVn,content_3833_4338:()=>mVn,content_3833_434:()=>U9,content_3833_4340:()=>hVn,content_3833_4342:()=>DVn,content_3833_4344:()=>_Vn,content_3833_4346:()=>CVn,content_3833_4348:()=>vVn,content_3833_4350:()=>NVn,content_3833_4352:()=>PVn,content_3833_4354:()=>WVn,content_3833_4356:()=>GVn,content_3833_4358:()=>UVn,content_3833_436:()=>q9,content_3833_4360:()=>qVn,content_3833_4362:()=>YVn,content_3833_4364:()=>KVn,content_3833_4366:()=>eqn,content_3833_4368:()=>oqn,content_3833_4370:()=>sqn,content_3833_4372:()=>iqn,content_3833_4374:()=>mqn,content_3833_4376:()=>hqn,content_3833_4378:()=>Dqn,content_3833_438:()=>Y9,content_3833_4380:()=>_qn,content_3833_4382:()=>Cqn,content_3833_4384:()=>vqn,content_3833_4386:()=>Nqn,content_3833_4388:()=>Pqn,content_3833_4390:()=>Wqn,content_3833_4392:()=>Gqn,content_3833_4394:()=>Uqn,content_3833_4396:()=>qqn,content_3833_4398:()=>Yqn,content_3833_44:()=>KJ,content_3833_440:()=>K9,content_3833_4400:()=>Kqn,content_3833_4402:()=>ejn,content_3833_4404:()=>ojn,content_3833_4406:()=>sjn,content_3833_4408:()=>ijn,content_3833_4410:()=>mjn,content_3833_4412:()=>hjn,content_3833_4414:()=>Djn,content_3833_4416:()=>_jn,content_3833_4418:()=>Cjn,content_3833_442:()=>eee,content_3833_4420:()=>vjn,content_3833_4422:()=>Njn,content_3833_4424:()=>Pjn,content_3833_4426:()=>Wjn,content_3833_4428:()=>Gjn,content_3833_4430:()=>Ujn,content_3833_4432:()=>qjn,content_3833_4434:()=>Yjn,content_3833_4436:()=>Kjn,content_3833_4438:()=>eHn,content_3833_444:()=>oee,content_3833_4440:()=>oHn,content_3833_4442:()=>sHn,content_3833_4444:()=>iHn,content_3833_4446:()=>mHn,content_3833_4448:()=>hHn,content_3833_4450:()=>DHn,content_3833_4452:()=>_Hn,content_3833_4454:()=>CHn,content_3833_4456:()=>vHn,content_3833_4458:()=>NHn,content_3833_446:()=>see,content_3833_4460:()=>PHn,content_3833_4462:()=>WHn,content_3833_4464:()=>GHn,content_3833_4466:()=>UHn,content_3833_4468:()=>qHn,content_3833_4470:()=>YHn,content_3833_4472:()=>KHn,content_3833_4474:()=>eYn,content_3833_4476:()=>oYn,content_3833_4478:()=>sYn,content_3833_448:()=>iee,content_3833_4480:()=>iYn,content_3833_4482:()=>mYn,content_3833_4484:()=>hYn,content_3833_4486:()=>DYn,content_3833_4488:()=>_Yn,content_3833_4490:()=>CYn,content_3833_4492:()=>vYn,content_3833_4494:()=>NYn,content_3833_4496:()=>PYn,content_3833_4498:()=>WYn,content_3833_450:()=>mee,content_3833_4500:()=>GYn,content_3833_4502:()=>UYn,content_3833_4504:()=>qYn,content_3833_4506:()=>YYn,content_3833_4508:()=>KYn,content_3833_4510:()=>eQn,content_3833_4512:()=>oQn,content_3833_4514:()=>sQn,content_3833_4516:()=>iQn,content_3833_4518:()=>mQn,content_3833_452:()=>hee,content_3833_4520:()=>hQn,content_3833_4522:()=>DQn,content_3833_4524:()=>_Qn,content_3833_4526:()=>CQn,content_3833_4528:()=>vQn,content_3833_4530:()=>NQn,content_3833_4532:()=>PQn,content_3833_4534:()=>WQn,content_3833_4536:()=>GQn,content_3833_4538:()=>UQn,content_3833_454:()=>Dee,content_3833_4540:()=>qQn,content_3833_4542:()=>YQn,content_3833_4544:()=>KQn,content_3833_4546:()=>e$n,content_3833_4548:()=>o$n,content_3833_4550:()=>s$n,content_3833_4552:()=>i$n,content_3833_4554:()=>m$n,content_3833_4556:()=>h$n,content_3833_4558:()=>D$n,content_3833_456:()=>_ee,content_3833_4560:()=>_$n,content_3833_4562:()=>C$n,content_3833_4564:()=>v$n,content_3833_4566:()=>N$n,content_3833_4568:()=>P$n,content_3833_4570:()=>W$n,content_3833_4572:()=>G$n,content_3833_4574:()=>U$n,content_3833_4576:()=>q$n,content_3833_4578:()=>Y$n,content_3833_458:()=>Cee,content_3833_4580:()=>K$n,content_3833_4582:()=>eKn,content_3833_4584:()=>oKn,content_3833_4586:()=>sKn,content_3833_4588:()=>iKn,content_3833_4590:()=>mKn,content_3833_4592:()=>hKn,content_3833_4594:()=>DKn,content_3833_4596:()=>_Kn,content_3833_4598:()=>CKn,content_3833_46:()=>eZ,content_3833_460:()=>vee,content_3833_4600:()=>vKn,content_3833_4602:()=>NKn,content_3833_4604:()=>PKn,content_3833_4606:()=>WKn,content_3833_4608:()=>GKn,content_3833_4610:()=>UKn,content_3833_4612:()=>qKn,content_3833_4614:()=>YKn,content_3833_4616:()=>KKn,content_3833_4618:()=>eJn,content_3833_462:()=>Nee,content_3833_4620:()=>oJn,content_3833_4622:()=>sJn,content_3833_4624:()=>iJn,content_3833_4626:()=>mJn,content_3833_4628:()=>hJn,content_3833_4630:()=>DJn,content_3833_4632:()=>_Jn,content_3833_4634:()=>CJn,content_3833_4636:()=>vJn,content_3833_4638:()=>NJn,content_3833_464:()=>Pee,content_3833_4640:()=>PJn,content_3833_4642:()=>WJn,content_3833_4644:()=>GJn,content_3833_4646:()=>UJn,content_3833_4648:()=>qJn,content_3833_4650:()=>YJn,content_3833_4652:()=>KJn,content_3833_4654:()=>eZn,content_3833_4656:()=>oZn,content_3833_4658:()=>sZn,content_3833_466:()=>Wee,content_3833_4660:()=>iZn,content_3833_4662:()=>mZn,content_3833_4664:()=>hZn,content_3833_4666:()=>DZn,content_3833_4668:()=>_Zn,content_3833_4670:()=>CZn,content_3833_4672:()=>vZn,content_3833_4674:()=>NZn,content_3833_4676:()=>PZn,content_3833_4678:()=>WZn,content_3833_468:()=>Gee,content_3833_4680:()=>GZn,content_3833_4682:()=>UZn,content_3833_4684:()=>qZn,content_3833_4686:()=>YZn,content_3833_4688:()=>KZn,content_3833_4690:()=>e0n,content_3833_4692:()=>o0n,content_3833_4694:()=>s0n,content_3833_4696:()=>i0n,content_3833_4698:()=>m0n,content_3833_470:()=>Uee,content_3833_4700:()=>h0n,content_3833_4702:()=>D0n,content_3833_4704:()=>_0n,content_3833_4706:()=>C0n,content_3833_4708:()=>v0n,content_3833_4710:()=>N0n,content_3833_4712:()=>P0n,content_3833_4714:()=>W0n,content_3833_4716:()=>G0n,content_3833_4718:()=>U0n,content_3833_472:()=>qee,content_3833_4720:()=>q0n,content_3833_4722:()=>Y0n,content_3833_4724:()=>K0n,content_3833_4726:()=>e3n,content_3833_4728:()=>o3n,content_3833_4730:()=>s3n,content_3833_4732:()=>i3n,content_3833_4734:()=>m3n,content_3833_4736:()=>h3n,content_3833_4738:()=>D3n,content_3833_474:()=>Yee,content_3833_4740:()=>_3n,content_3833_4742:()=>C3n,content_3833_4744:()=>v3n,content_3833_4746:()=>N3n,content_3833_4748:()=>P3n,content_3833_4750:()=>W3n,content_3833_4752:()=>G3n,content_3833_4754:()=>U3n,content_3833_4756:()=>q3n,content_3833_4758:()=>Y3n,content_3833_476:()=>Kee,content_3833_4760:()=>K3n,content_3833_4762:()=>e8n,content_3833_4764:()=>o8n,content_3833_4766:()=>s8n,content_3833_4768:()=>i8n,content_3833_4770:()=>m8n,content_3833_4772:()=>h8n,content_3833_4774:()=>D8n,content_3833_4776:()=>_8n,content_3833_4778:()=>C8n,content_3833_478:()=>ene,content_3833_4780:()=>v8n,content_3833_4782:()=>N8n,content_3833_4784:()=>P8n,content_3833_4786:()=>W8n,content_3833_4788:()=>G8n,content_3833_4790:()=>U8n,content_3833_4792:()=>q8n,content_3833_4794:()=>Y8n,content_3833_4796:()=>K8n,content_3833_4798:()=>e2n,content_3833_48:()=>oZ,content_3833_480:()=>one,content_3833_4800:()=>o2n,content_3833_4802:()=>s2n,content_3833_4804:()=>i2n,content_3833_4806:()=>m2n,content_3833_4808:()=>h2n,content_3833_4810:()=>D2n,content_3833_4812:()=>_2n,content_3833_4814:()=>C2n,content_3833_4816:()=>v2n,content_3833_4818:()=>N2n,content_3833_482:()=>sne,content_3833_4820:()=>P2n,content_3833_4822:()=>W2n,content_3833_4824:()=>G2n,content_3833_4826:()=>U2n,content_3833_4828:()=>q2n,content_3833_4830:()=>Y2n,content_3833_4832:()=>K2n,content_3833_4834:()=>e1n,content_3833_4836:()=>o1n,content_3833_4838:()=>s1n,content_3833_484:()=>ine,content_3833_4840:()=>i1n,content_3833_4842:()=>m1n,content_3833_4844:()=>h1n,content_3833_4846:()=>D1n,content_3833_4848:()=>_1n,content_3833_4850:()=>C1n,content_3833_4852:()=>v1n,content_3833_4854:()=>N1n,content_3833_4856:()=>P1n,content_3833_4858:()=>W1n,content_3833_486:()=>mne,content_3833_4860:()=>G1n,content_3833_4862:()=>U1n,content_3833_4864:()=>q1n,content_3833_4866:()=>Y1n,content_3833_4868:()=>K1n,content_3833_4870:()=>e4n,content_3833_4872:()=>o4n,content_3833_4874:()=>s4n,content_3833_4876:()=>i4n,content_3833_4878:()=>m4n,content_3833_488:()=>hne,content_3833_4880:()=>h4n,content_3833_4882:()=>D4n,content_3833_4884:()=>_4n,content_3833_4886:()=>C4n,content_3833_4888:()=>v4n,content_3833_4890:()=>N4n,content_3833_4892:()=>P4n,content_3833_4894:()=>W4n,content_3833_4896:()=>G4n,content_3833_4898:()=>U4n,content_3833_490:()=>Dne,content_3833_4900:()=>q4n,content_3833_4902:()=>Y4n,content_3833_4904:()=>K4n,content_3833_4906:()=>e6n,content_3833_4908:()=>o6n,content_3833_4910:()=>s6n,content_3833_4912:()=>i6n,content_3833_4914:()=>m6n,content_3833_4916:()=>h6n,content_3833_4918:()=>D6n,content_3833_492:()=>_ne,content_3833_4920:()=>_6n,content_3833_4922:()=>C6n,content_3833_4924:()=>v6n,content_3833_4926:()=>N6n,content_3833_4928:()=>P6n,content_3833_4930:()=>W6n,content_3833_4932:()=>G6n,content_3833_4934:()=>U6n,content_3833_4936:()=>q6n,content_3833_4938:()=>Y6n,content_3833_494:()=>Cne,content_3833_4940:()=>K6n,content_3833_4942:()=>e5n,content_3833_4944:()=>o5n,content_3833_4946:()=>s5n,content_3833_4948:()=>i5n,content_3833_4950:()=>m5n,content_3833_4952:()=>h5n,content_3833_4954:()=>D5n,content_3833_4956:()=>_5n,content_3833_4958:()=>C5n,content_3833_496:()=>vne,content_3833_4960:()=>v5n,content_3833_4962:()=>N5n,content_3833_4964:()=>P5n,content_3833_4966:()=>W5n,content_3833_4968:()=>G5n,content_3833_4970:()=>U5n,content_3833_4972:()=>q5n,content_3833_4974:()=>Y5n,content_3833_4976:()=>K5n,content_3833_4978:()=>e7n,content_3833_498:()=>Nne,content_3833_4980:()=>o7n,content_3833_4982:()=>s7n,content_3833_4984:()=>i7n,content_3833_4986:()=>m7n,content_3833_4988:()=>h7n,content_3833_4990:()=>D7n,content_3833_4992:()=>_7n,content_3833_4994:()=>C7n,content_3833_4996:()=>v7n,content_3833_4998:()=>N7n,content_3833_50:()=>sZ,content_3833_500:()=>Pne,content_3833_5000:()=>P7n,content_3833_5002:()=>W7n,content_3833_5004:()=>G7n,content_3833_5006:()=>U7n,content_3833_5008:()=>q7n,content_3833_5010:()=>Y7n,content_3833_5012:()=>K7n,content_3833_5014:()=>e9n,content_3833_5016:()=>o9n,content_3833_5018:()=>s9n,content_3833_502:()=>Wne,content_3833_5020:()=>i9n,content_3833_5022:()=>m9n,content_3833_5024:()=>h9n,content_3833_5026:()=>D9n,content_3833_5028:()=>_9n,content_3833_5030:()=>C9n,content_3833_5032:()=>v9n,content_3833_5034:()=>N9n,content_3833_5036:()=>P9n,content_3833_5038:()=>W9n,content_3833_504:()=>Gne,content_3833_5040:()=>G9n,content_3833_5042:()=>U9n,content_3833_5044:()=>q9n,content_3833_5046:()=>Y9n,content_3833_5048:()=>K9n,content_3833_5050:()=>eet,content_3833_5052:()=>oet,content_3833_5054:()=>set,content_3833_5056:()=>iet,content_3833_5058:()=>yet,content_3833_506:()=>Une,content_3833_5060:()=>get,content_3833_5062:()=>Met,content_3833_5064:()=>wet,content_3833_5066:()=>xet,content_3833_5068:()=>Let,content_3833_5070:()=>ket,content_3833_5072:()=>Iet,content_3833_5074:()=>Set,content_3833_5076:()=>Eet,content_3833_5078:()=>Fet,content_3833_508:()=>qne,content_3833_5080:()=>jet,content_3833_5082:()=>Qet,content_3833_5084:()=>Jet,content_3833_5086:()=>nnt,content_3833_5088:()=>pnt,content_3833_5090:()=>cnt,content_3833_5092:()=>lnt,content_3833_5094:()=>ynt,content_3833_5096:()=>gnt,content_3833_5098:()=>Mnt,content_3833_510:()=>Yne,content_3833_5100:()=>wnt,content_3833_5102:()=>xnt,content_3833_5104:()=>Lnt,content_3833_5106:()=>knt,content_3833_5108:()=>Int,content_3833_5110:()=>Snt,content_3833_5112:()=>Ent,content_3833_5114:()=>Fnt,content_3833_5116:()=>jnt,content_3833_5118:()=>Qnt,content_3833_512:()=>Kne,content_3833_5120:()=>Jnt,content_3833_5122:()=>ntt,content_3833_5124:()=>ptt,content_3833_5126:()=>ctt,content_3833_5128:()=>ltt,content_3833_5130:()=>ytt,content_3833_5132:()=>gtt,content_3833_5134:()=>Mtt,content_3833_5136:()=>wtt,content_3833_5138:()=>xtt,content_3833_514:()=>ete,content_3833_5140:()=>Ltt,content_3833_5142:()=>ktt,content_3833_5144:()=>Itt,content_3833_5146:()=>Stt,content_3833_5148:()=>Ett,content_3833_5150:()=>Ftt,content_3833_5152:()=>jtt,content_3833_5154:()=>Qtt,content_3833_5156:()=>Jtt,content_3833_5158:()=>not,content_3833_516:()=>ote,content_3833_5160:()=>pot,content_3833_5162:()=>cot,content_3833_5164:()=>lot,content_3833_5166:()=>yot,content_3833_5168:()=>got,content_3833_5170:()=>Mot,content_3833_5172:()=>wot,content_3833_5174:()=>xot,content_3833_5176:()=>Lot,content_3833_5178:()=>kot,content_3833_518:()=>ste,content_3833_5180:()=>Iot,content_3833_5182:()=>Sot,content_3833_5184:()=>Eot,content_3833_5186:()=>Fot,content_3833_5188:()=>jot,content_3833_5190:()=>Qot,content_3833_5192:()=>Jot,content_3833_5194:()=>npt,content_3833_5196:()=>ppt,content_3833_5198:()=>cpt,content_3833_52:()=>iZ,content_3833_520:()=>ite,content_3833_5200:()=>lpt,content_3833_5202:()=>ypt,content_3833_5204:()=>gpt,content_3833_5206:()=>Mpt,content_3833_5208:()=>wpt,content_3833_5210:()=>xpt,content_3833_5212:()=>Lpt,content_3833_5214:()=>kpt,content_3833_5216:()=>Ipt,content_3833_5218:()=>Spt,content_3833_522:()=>mte,content_3833_5220:()=>Ept,content_3833_5222:()=>Fpt,content_3833_5224:()=>jpt,content_3833_5226:()=>Qpt,content_3833_5228:()=>Jpt,content_3833_5230:()=>nrt,content_3833_5232:()=>prt,content_3833_5234:()=>crt,content_3833_5236:()=>lrt,content_3833_5238:()=>yrt,content_3833_524:()=>hte,content_3833_5240:()=>grt,content_3833_5242:()=>Mrt,content_3833_5244:()=>wrt,content_3833_5246:()=>xrt,content_3833_5248:()=>Lrt,content_3833_5250:()=>krt,content_3833_5252:()=>Irt,content_3833_5254:()=>Srt,content_3833_5256:()=>Ert,content_3833_5258:()=>Frt,content_3833_526:()=>Dte,content_3833_5260:()=>jrt,content_3833_5262:()=>Qrt,content_3833_5264:()=>Jrt,content_3833_5266:()=>nst,content_3833_5268:()=>pst,content_3833_5270:()=>cst,content_3833_5272:()=>lst,content_3833_5274:()=>yst,content_3833_5276:()=>gst,content_3833_5278:()=>Mst,content_3833_528:()=>_te,content_3833_5280:()=>wst,content_3833_5282:()=>xst,content_3833_5284:()=>Lst,content_3833_5286:()=>kst,content_3833_5288:()=>Ist,content_3833_5290:()=>Sst,content_3833_5292:()=>Est,content_3833_5294:()=>Fst,content_3833_5296:()=>jst,content_3833_5298:()=>Qst,content_3833_530:()=>Cte,content_3833_5300:()=>Jst,content_3833_5302:()=>nct,content_3833_5304:()=>pct,content_3833_5306:()=>cct,content_3833_5308:()=>lct,content_3833_5310:()=>yct,content_3833_5312:()=>gct,content_3833_5314:()=>Mct,content_3833_5316:()=>wct,content_3833_5318:()=>xct,content_3833_532:()=>vte,content_3833_5320:()=>Lct,content_3833_5322:()=>kct,content_3833_5324:()=>Ict,content_3833_5326:()=>Sct,content_3833_5328:()=>Ect,content_3833_5330:()=>Fct,content_3833_5332:()=>jct,content_3833_5334:()=>Qct,content_3833_5336:()=>Jct,content_3833_5338:()=>nat,content_3833_534:()=>Nte,content_3833_5340:()=>pat,content_3833_5342:()=>cat,content_3833_5344:()=>lat,content_3833_5346:()=>yat,content_3833_5348:()=>gat,content_3833_5350:()=>Mat,content_3833_5352:()=>wat,content_3833_5354:()=>xat,content_3833_5356:()=>Lat,content_3833_5358:()=>kat,content_3833_536:()=>Pte,content_3833_5360:()=>Iat,content_3833_5362:()=>Sat,content_3833_5364:()=>Eat,content_3833_5366:()=>Fat,content_3833_5368:()=>jat,content_3833_5370:()=>Qat,content_3833_5372:()=>Jat,content_3833_5374:()=>nit,content_3833_5376:()=>pit,content_3833_5378:()=>cit,content_3833_538:()=>Wte,content_3833_5380:()=>lit,content_3833_5382:()=>yit,content_3833_5384:()=>git,content_3833_5386:()=>Mit,content_3833_5388:()=>wit,content_3833_5390:()=>xit,content_3833_5392:()=>Lit,content_3833_5394:()=>kit,content_3833_5396:()=>Iit,content_3833_5398:()=>Sit,content_3833_54:()=>mZ,content_3833_540:()=>Gte,content_3833_5400:()=>Eit,content_3833_5402:()=>Fit,content_3833_5404:()=>jit,content_3833_5406:()=>Qit,content_3833_5408:()=>Jit,content_3833_5410:()=>nlt,content_3833_5412:()=>plt,content_3833_5414:()=>clt,content_3833_5416:()=>llt,content_3833_5418:()=>ylt,content_3833_542:()=>Ute,content_3833_5420:()=>glt,content_3833_5422:()=>Mlt,content_3833_5424:()=>wlt,content_3833_5426:()=>xlt,content_3833_5428:()=>Llt,content_3833_5430:()=>klt,content_3833_5432:()=>Ilt,content_3833_5434:()=>Slt,content_3833_5436:()=>Elt,content_3833_5438:()=>Flt,content_3833_544:()=>qte,content_3833_5440:()=>jlt,content_3833_5442:()=>Qlt,content_3833_5444:()=>Jlt,content_3833_5446:()=>nut,content_3833_5448:()=>put,content_3833_5450:()=>cut,content_3833_5452:()=>lut,content_3833_5454:()=>yut,content_3833_5456:()=>gut,content_3833_5458:()=>Mut,content_3833_546:()=>Yte,content_3833_5460:()=>wut,content_3833_5462:()=>xut,content_3833_5464:()=>Lut,content_3833_5466:()=>kut,content_3833_5468:()=>Iut,content_3833_5470:()=>Sut,content_3833_5472:()=>Eut,content_3833_5474:()=>Fut,content_3833_5476:()=>jut,content_3833_5478:()=>Qut,content_3833_548:()=>Kte,content_3833_5480:()=>Jut,content_3833_5482:()=>nmt,content_3833_5484:()=>pmt,content_3833_5486:()=>cmt,content_3833_5488:()=>lmt,content_3833_5490:()=>ymt,content_3833_5492:()=>gmt,content_3833_5494:()=>Mmt,content_3833_5496:()=>wmt,content_3833_5498:()=>xmt,content_3833_550:()=>eoe,content_3833_5500:()=>Lmt,content_3833_5502:()=>kmt,content_3833_5504:()=>Imt,content_3833_5506:()=>Smt,content_3833_5508:()=>Emt,content_3833_5510:()=>Fmt,content_3833_5512:()=>jmt,content_3833_5514:()=>Qmt,content_3833_5516:()=>Jmt,content_3833_5518:()=>nyt,content_3833_552:()=>ooe,content_3833_5520:()=>pyt,content_3833_5522:()=>cyt,content_3833_5524:()=>lyt,content_3833_5526:()=>yyt,content_3833_5528:()=>gyt,content_3833_5530:()=>Myt,content_3833_5532:()=>wyt,content_3833_5534:()=>xyt,content_3833_5536:()=>Lyt,content_3833_5538:()=>kyt,content_3833_554:()=>soe,content_3833_5540:()=>Iyt,content_3833_5542:()=>Syt,content_3833_5544:()=>Eyt,content_3833_5546:()=>Fyt,content_3833_5548:()=>jyt,content_3833_5550:()=>Qyt,content_3833_5552:()=>Jyt,content_3833_5554:()=>ndt,content_3833_5556:()=>pdt,content_3833_5558:()=>cdt,content_3833_556:()=>ioe,content_3833_5560:()=>ldt,content_3833_5562:()=>ydt,content_3833_5564:()=>gdt,content_3833_5566:()=>Mdt,content_3833_5568:()=>wdt,content_3833_5570:()=>xdt,content_3833_5572:()=>Ldt,content_3833_5574:()=>kdt,content_3833_5576:()=>Idt,content_3833_5578:()=>Sdt,content_3833_558:()=>moe,content_3833_5580:()=>Edt,content_3833_5582:()=>Fdt,content_3833_5584:()=>jdt,content_3833_5586:()=>Qdt,content_3833_5588:()=>Jdt,content_3833_5590:()=>nht,content_3833_5592:()=>pht,content_3833_5594:()=>cht,content_3833_5596:()=>lht,content_3833_5598:()=>yht,content_3833_56:()=>hZ,content_3833_560:()=>hoe,content_3833_5600:()=>ght,content_3833_5602:()=>Mht,content_3833_5604:()=>wht,content_3833_5606:()=>xht,content_3833_5608:()=>Lht,content_3833_5610:()=>kht,content_3833_5612:()=>Iht,content_3833_5614:()=>Sht,content_3833_5616:()=>Eht,content_3833_5618:()=>Fht,content_3833_562:()=>Doe,content_3833_5620:()=>jht,content_3833_5622:()=>Qht,content_3833_5624:()=>Jht,content_3833_5626:()=>ngt,content_3833_5628:()=>pgt,content_3833_5630:()=>cgt,content_3833_5632:()=>lgt,content_3833_5634:()=>ygt,content_3833_5636:()=>ggt,content_3833_5638:()=>Mgt,content_3833_564:()=>_oe,content_3833_5640:()=>wgt,content_3833_5642:()=>xgt,content_3833_5644:()=>Lgt,content_3833_5646:()=>kgt,content_3833_5648:()=>Igt,content_3833_5650:()=>Sgt,content_3833_5652:()=>Egt,content_3833_5654:()=>Fgt,content_3833_5656:()=>jgt,content_3833_5658:()=>Qgt,content_3833_566:()=>Coe,content_3833_5660:()=>Jgt,content_3833_5662:()=>nft,content_3833_5664:()=>pft,content_3833_5666:()=>cft,content_3833_5668:()=>lft,content_3833_5670:()=>yft,content_3833_5672:()=>gft,content_3833_5674:()=>Mft,content_3833_5676:()=>wft,content_3833_5678:()=>xft,content_3833_568:()=>voe,content_3833_5680:()=>Lft,content_3833_5682:()=>kft,content_3833_5684:()=>Ift,content_3833_5686:()=>Sft,content_3833_5688:()=>Eft,content_3833_5690:()=>Fft,content_3833_5692:()=>jft,content_3833_5694:()=>Qft,content_3833_5696:()=>Jft,content_3833_5698:()=>nDt,content_3833_570:()=>Noe,content_3833_5700:()=>pDt,content_3833_5702:()=>cDt,content_3833_5704:()=>lDt,content_3833_5706:()=>yDt,content_3833_5708:()=>gDt,content_3833_5710:()=>MDt,content_3833_5712:()=>wDt,content_3833_5714:()=>xDt,content_3833_5716:()=>LDt,content_3833_5718:()=>kDt,content_3833_572:()=>Poe,content_3833_5720:()=>IDt,content_3833_5722:()=>SDt,content_3833_5724:()=>EDt,content_3833_5726:()=>FDt,content_3833_5728:()=>jDt,content_3833_5730:()=>QDt,content_3833_5732:()=>JDt,content_3833_5734:()=>nMt,content_3833_5736:()=>pMt,content_3833_5738:()=>cMt,content_3833_574:()=>Woe,content_3833_5740:()=>lMt,content_3833_5742:()=>yMt,content_3833_5744:()=>gMt,content_3833_5746:()=>MMt,content_3833_5748:()=>wMt,content_3833_5750:()=>xMt,content_3833_5752:()=>LMt,content_3833_5754:()=>kMt,content_3833_5756:()=>IMt,content_3833_5758:()=>SMt,content_3833_576:()=>Goe,content_3833_5760:()=>EMt,content_3833_5762:()=>FMt,content_3833_5764:()=>jMt,content_3833_5766:()=>QMt,content_3833_5768:()=>JMt,content_3833_5770:()=>nXt,content_3833_5772:()=>pXt,content_3833_5774:()=>cXt,content_3833_5776:()=>lXt,content_3833_5778:()=>yXt,content_3833_578:()=>Uoe,content_3833_5780:()=>gXt,content_3833_5782:()=>MXt,content_3833_5784:()=>wXt,content_3833_5786:()=>xXt,content_3833_5788:()=>LXt,content_3833_5790:()=>kXt,content_3833_5792:()=>IXt,content_3833_5794:()=>SXt,content_3833_5796:()=>EXt,content_3833_5798:()=>FXt,content_3833_58:()=>DZ,content_3833_580:()=>qoe,content_3833_5800:()=>jXt,content_3833_5802:()=>QXt,content_3833_5804:()=>JXt,content_3833_5806:()=>n_t,content_3833_5808:()=>p_t,content_3833_5810:()=>c_t,content_3833_5812:()=>l_t,content_3833_5814:()=>y_t,content_3833_5816:()=>g_t,content_3833_5818:()=>M_t,content_3833_582:()=>Yoe,content_3833_5820:()=>w_t,content_3833_5822:()=>x_t,content_3833_5824:()=>L_t,content_3833_5826:()=>k_t,content_3833_5828:()=>I_t,content_3833_5830:()=>S_t,content_3833_5832:()=>E_t,content_3833_5834:()=>F_t,content_3833_5836:()=>j_t,content_3833_5838:()=>Q_t,content_3833_584:()=>Koe,content_3833_5840:()=>J_t,content_3833_5842:()=>nwt,content_3833_5844:()=>pwt,content_3833_5846:()=>cwt,content_3833_5848:()=>lwt,content_3833_5850:()=>ywt,content_3833_5852:()=>gwt,content_3833_5854:()=>Mwt,content_3833_5856:()=>wwt,content_3833_5858:()=>xwt,content_3833_586:()=>epe,content_3833_5860:()=>Lwt,content_3833_5862:()=>kwt,content_3833_5864:()=>Iwt,content_3833_5866:()=>Swt,content_3833_5868:()=>Ewt,content_3833_5870:()=>Fwt,content_3833_5872:()=>jwt,content_3833_5874:()=>Qwt,content_3833_5876:()=>Jwt,content_3833_5878:()=>nTt,content_3833_588:()=>ope,content_3833_5880:()=>pTt,content_3833_5882:()=>cTt,content_3833_5884:()=>lTt,content_3833_5886:()=>yTt,content_3833_5888:()=>gTt,content_3833_5890:()=>MTt,content_3833_5892:()=>wTt,content_3833_5894:()=>xTt,content_3833_5896:()=>LTt,content_3833_5898:()=>kTt,content_3833_590:()=>spe,content_3833_5900:()=>ITt,content_3833_5902:()=>STt,content_3833_5904:()=>ETt,content_3833_5906:()=>FTt,content_3833_5908:()=>jTt,content_3833_5910:()=>QTt,content_3833_5912:()=>JTt,content_3833_5914:()=>nCt,content_3833_5916:()=>pCt,content_3833_5918:()=>cCt,content_3833_592:()=>ipe,content_3833_5920:()=>lCt,content_3833_5922:()=>yCt,content_3833_5924:()=>gCt,content_3833_5926:()=>MCt,content_3833_5928:()=>wCt,content_3833_5930:()=>xCt,content_3833_5932:()=>LCt,content_3833_5934:()=>kCt,content_3833_5936:()=>ICt,content_3833_5938:()=>SCt,content_3833_594:()=>mpe,content_3833_5940:()=>ECt,content_3833_5942:()=>FCt,content_3833_5944:()=>jCt,content_3833_5946:()=>QCt,content_3833_5948:()=>JCt,content_3833_5950:()=>nxt,content_3833_5952:()=>pxt,content_3833_5954:()=>cxt,content_3833_5956:()=>lxt,content_3833_5958:()=>yxt,content_3833_596:()=>hpe,content_3833_5960:()=>gxt,content_3833_5962:()=>Mxt,content_3833_5964:()=>wxt,content_3833_5966:()=>xxt,content_3833_5968:()=>Lxt,content_3833_5970:()=>kxt,content_3833_5972:()=>Ixt,content_3833_5974:()=>Sxt,content_3833_5976:()=>Ext,content_3833_5978:()=>Fxt,content_3833_598:()=>Dpe,content_3833_5980:()=>jxt,content_3833_5982:()=>Qxt,content_3833_5984:()=>Jxt,content_3833_5986:()=>nAt,content_3833_5988:()=>pAt,content_3833_5990:()=>cAt,content_3833_5992:()=>lAt,content_3833_5994:()=>yAt,content_3833_5996:()=>gAt,content_3833_5998:()=>MAt,content_3833_6:()=>YK,content_3833_60:()=>_Z,content_3833_600:()=>_pe,content_3833_6000:()=>wAt,content_3833_6002:()=>xAt,content_3833_6004:()=>LAt,content_3833_6006:()=>kAt,content_3833_6008:()=>IAt,content_3833_6010:()=>SAt,content_3833_6012:()=>EAt,content_3833_6014:()=>FAt,content_3833_6016:()=>jAt,content_3833_6018:()=>QAt,content_3833_602:()=>Cpe,content_3833_6020:()=>JAt,content_3833_6022:()=>nvt,content_3833_6024:()=>pvt,content_3833_6026:()=>cvt,content_3833_6028:()=>lvt,content_3833_6030:()=>yvt,content_3833_6032:()=>gvt,content_3833_6034:()=>Mvt,content_3833_6036:()=>wvt,content_3833_6038:()=>xvt,content_3833_604:()=>vpe,content_3833_6040:()=>Lvt,content_3833_6042:()=>kvt,content_3833_6044:()=>Ivt,content_3833_6046:()=>Svt,content_3833_6048:()=>Evt,content_3833_6050:()=>Fvt,content_3833_6052:()=>jvt,content_3833_6054:()=>Qvt,content_3833_6056:()=>Jvt,content_3833_6058:()=>nLt,content_3833_606:()=>Npe,content_3833_6060:()=>pLt,content_3833_6062:()=>cLt,content_3833_6064:()=>lLt,content_3833_6066:()=>yLt,content_3833_6068:()=>gLt,content_3833_6070:()=>MLt,content_3833_6072:()=>wLt,content_3833_6074:()=>xLt,content_3833_6076:()=>LLt,content_3833_6078:()=>kLt,content_3833_608:()=>Ppe,content_3833_6080:()=>ILt,content_3833_6082:()=>SLt,content_3833_6084:()=>ELt,content_3833_6086:()=>FLt,content_3833_6088:()=>jLt,content_3833_6090:()=>QLt,content_3833_6092:()=>JLt,content_3833_6094:()=>nbt,content_3833_6096:()=>pbt,content_3833_6098:()=>cbt,content_3833_610:()=>Wpe,content_3833_6100:()=>lbt,content_3833_6102:()=>ybt,content_3833_6104:()=>gbt,content_3833_6106:()=>Mbt,content_3833_6108:()=>wbt,content_3833_6110:()=>xbt,content_3833_6112:()=>Lbt,content_3833_6114:()=>kbt,content_3833_6116:()=>Ibt,content_3833_6118:()=>Sbt,content_3833_612:()=>Gpe,content_3833_6120:()=>Ebt,content_3833_6122:()=>Fbt,content_3833_6124:()=>jbt,content_3833_6126:()=>Qbt,content_3833_6128:()=>Jbt,content_3833_6130:()=>nNt,content_3833_6132:()=>pNt,content_3833_6134:()=>cNt,content_3833_6136:()=>lNt,content_3833_6138:()=>yNt,content_3833_614:()=>Upe,content_3833_6140:()=>gNt,content_3833_6142:()=>MNt,content_3833_6144:()=>wNt,content_3833_6146:()=>xNt,content_3833_6148:()=>LNt,content_3833_6150:()=>kNt,content_3833_6152:()=>INt,content_3833_6154:()=>SNt,content_3833_6156:()=>ENt,content_3833_6158:()=>FNt,content_3833_616:()=>qpe,content_3833_6160:()=>jNt,content_3833_6162:()=>QNt,content_3833_6164:()=>JNt,content_3833_6166:()=>nkt,content_3833_6168:()=>pkt,content_3833_6170:()=>ckt,content_3833_6172:()=>lkt,content_3833_6174:()=>ykt,content_3833_6176:()=>gkt,content_3833_6178:()=>Mkt,content_3833_618:()=>Ype,content_3833_6180:()=>wkt,content_3833_6182:()=>xkt,content_3833_6184:()=>Lkt,content_3833_6186:()=>kkt,content_3833_6188:()=>Ikt,content_3833_6190:()=>Skt,content_3833_6192:()=>Ekt,content_3833_6194:()=>Fkt,content_3833_6196:()=>jkt,content_3833_6198:()=>Qkt,content_3833_62:()=>CZ,content_3833_620:()=>Kpe,content_3833_6200:()=>Jkt,content_3833_6202:()=>nzt,content_3833_6204:()=>pzt,content_3833_6206:()=>czt,content_3833_6208:()=>lzt,content_3833_6210:()=>yzt,content_3833_6212:()=>gzt,content_3833_6214:()=>Mzt,content_3833_6216:()=>wzt,content_3833_6218:()=>xzt,content_3833_622:()=>ere,content_3833_6220:()=>Lzt,content_3833_6222:()=>kzt,content_3833_6224:()=>Izt,content_3833_6226:()=>Szt,content_3833_6228:()=>Ezt,content_3833_6230:()=>Fzt,content_3833_6232:()=>jzt,content_3833_6234:()=>Qzt,content_3833_6236:()=>Jzt,content_3833_6238:()=>nPt,content_3833_624:()=>ore,content_3833_6240:()=>pPt,content_3833_6242:()=>cPt,content_3833_6244:()=>lPt,content_3833_6246:()=>yPt,content_3833_6248:()=>gPt,content_3833_6250:()=>MPt,content_3833_6252:()=>wPt,content_3833_6254:()=>xPt,content_3833_6256:()=>LPt,content_3833_6258:()=>kPt,content_3833_626:()=>sre,content_3833_6260:()=>IPt,content_3833_6262:()=>SPt,content_3833_6264:()=>EPt,content_3833_6266:()=>FPt,content_3833_6268:()=>jPt,content_3833_6270:()=>QPt,content_3833_6272:()=>JPt,content_3833_6274:()=>nIt,content_3833_6276:()=>pIt,content_3833_6278:()=>cIt,content_3833_628:()=>ire,content_3833_6280:()=>lIt,content_3833_6282:()=>yIt,content_3833_6284:()=>gIt,content_3833_6286:()=>MIt,content_3833_6288:()=>wIt,content_3833_6290:()=>xIt,content_3833_6292:()=>LIt,content_3833_6294:()=>kIt,content_3833_6296:()=>IIt,content_3833_6298:()=>SIt,content_3833_630:()=>mre,content_3833_6300:()=>EIt,content_3833_6302:()=>FIt,content_3833_6304:()=>jIt,content_3833_6306:()=>QIt,content_3833_6308:()=>JIt,content_3833_6310:()=>nRt,content_3833_6312:()=>pRt,content_3833_6314:()=>cRt,content_3833_6316:()=>lRt,content_3833_6318:()=>yRt,content_3833_632:()=>hre,content_3833_6320:()=>gRt,content_3833_6322:()=>MRt,content_3833_6324:()=>wRt,content_3833_6326:()=>xRt,content_3833_6328:()=>LRt,content_3833_6330:()=>kRt,content_3833_6332:()=>IRt,content_3833_6334:()=>SRt,content_3833_6336:()=>ERt,content_3833_6338:()=>FRt,content_3833_634:()=>Dre,content_3833_6340:()=>jRt,content_3833_6342:()=>QRt,content_3833_6344:()=>JRt,content_3833_6346:()=>nWt,content_3833_6348:()=>pWt,content_3833_6350:()=>cWt,content_3833_6352:()=>lWt,content_3833_6354:()=>yWt,content_3833_6356:()=>gWt,content_3833_6358:()=>MWt,content_3833_636:()=>_re,content_3833_6360:()=>wWt,content_3833_6362:()=>xWt,content_3833_6364:()=>LWt,content_3833_6366:()=>kWt,content_3833_6368:()=>IWt,content_3833_6370:()=>SWt,content_3833_6372:()=>EWt,content_3833_6374:()=>FWt,content_3833_6376:()=>jWt,content_3833_6378:()=>QWt,content_3833_638:()=>Cre,content_3833_6380:()=>JWt,content_3833_6382:()=>nSt,content_3833_6384:()=>pSt,content_3833_6386:()=>cSt,content_3833_6388:()=>lSt,content_3833_6390:()=>ySt,content_3833_6392:()=>gSt,content_3833_6394:()=>MSt,content_3833_6396:()=>wSt,content_3833_6398:()=>xSt,content_3833_64:()=>vZ,content_3833_640:()=>vre,content_3833_6400:()=>LSt,content_3833_6402:()=>kSt,content_3833_6404:()=>ISt,content_3833_6406:()=>SSt,content_3833_6408:()=>ESt,content_3833_6410:()=>FSt,content_3833_6412:()=>jSt,content_3833_6414:()=>QSt,content_3833_6416:()=>JSt,content_3833_6418:()=>nBt,content_3833_642:()=>Nre,content_3833_6420:()=>pBt,content_3833_6422:()=>cBt,content_3833_6424:()=>lBt,content_3833_6426:()=>yBt,content_3833_6428:()=>gBt,content_3833_6430:()=>MBt,content_3833_6432:()=>wBt,content_3833_6434:()=>xBt,content_3833_6436:()=>LBt,content_3833_6438:()=>kBt,content_3833_644:()=>Pre,content_3833_6440:()=>IBt,content_3833_6442:()=>SBt,content_3833_6444:()=>EBt,content_3833_6446:()=>FBt,content_3833_6448:()=>jBt,content_3833_6450:()=>QBt,content_3833_6452:()=>JBt,content_3833_6454:()=>nGt,content_3833_6456:()=>pGt,content_3833_6458:()=>cGt,content_3833_646:()=>Wre,content_3833_6460:()=>lGt,content_3833_6462:()=>yGt,content_3833_6464:()=>gGt,content_3833_6466:()=>MGt,content_3833_6468:()=>wGt,content_3833_6470:()=>xGt,content_3833_6472:()=>LGt,content_3833_6474:()=>kGt,content_3833_6476:()=>IGt,content_3833_6478:()=>SGt,content_3833_648:()=>Gre,content_3833_6480:()=>EGt,content_3833_6482:()=>FGt,content_3833_6484:()=>jGt,content_3833_6486:()=>QGt,content_3833_6488:()=>JGt,content_3833_6490:()=>nEt,content_3833_6492:()=>pEt,content_3833_6494:()=>cEt,content_3833_6496:()=>lEt,content_3833_6498:()=>yEt,content_3833_650:()=>Ure,content_3833_6500:()=>gEt,content_3833_6502:()=>MEt,content_3833_6504:()=>wEt,content_3833_6506:()=>xEt,content_3833_6508:()=>LEt,content_3833_6510:()=>kEt,content_3833_6512:()=>IEt,content_3833_6514:()=>SEt,content_3833_6516:()=>EEt,content_3833_6518:()=>FEt,content_3833_652:()=>qre,content_3833_6520:()=>jEt,content_3833_6522:()=>QEt,content_3833_6524:()=>JEt,content_3833_6526:()=>nOt,content_3833_6528:()=>pOt,content_3833_6530:()=>cOt,content_3833_6532:()=>lOt,content_3833_6534:()=>yOt,content_3833_6536:()=>gOt,content_3833_6538:()=>MOt,content_3833_654:()=>Yre,content_3833_6540:()=>wOt,content_3833_6542:()=>xOt,content_3833_6544:()=>LOt,content_3833_6546:()=>kOt,content_3833_6548:()=>IOt,content_3833_6550:()=>SOt,content_3833_6552:()=>EOt,content_3833_6554:()=>FOt,content_3833_6556:()=>jOt,content_3833_6558:()=>QOt,content_3833_656:()=>Kre,content_3833_6560:()=>JOt,content_3833_6562:()=>nUt,content_3833_6564:()=>pUt,content_3833_6566:()=>cUt,content_3833_6568:()=>lUt,content_3833_6570:()=>yUt,content_3833_6572:()=>gUt,content_3833_6574:()=>MUt,content_3833_6576:()=>wUt,content_3833_6578:()=>xUt,content_3833_658:()=>ese,content_3833_6580:()=>LUt,content_3833_6582:()=>kUt,content_3833_6584:()=>IUt,content_3833_6586:()=>SUt,content_3833_6588:()=>EUt,content_3833_6590:()=>FUt,content_3833_6592:()=>jUt,content_3833_6594:()=>QUt,content_3833_6596:()=>JUt,content_3833_6598:()=>nFt,content_3833_66:()=>NZ,content_3833_660:()=>ose,content_3833_6600:()=>pFt,content_3833_6602:()=>cFt,content_3833_6604:()=>lFt,content_3833_6606:()=>yFt,content_3833_6608:()=>gFt,content_3833_6610:()=>MFt,content_3833_6612:()=>wFt,content_3833_6614:()=>xFt,content_3833_6616:()=>LFt,content_3833_6618:()=>kFt,content_3833_662:()=>sse,content_3833_6620:()=>IFt,content_3833_6622:()=>SFt,content_3833_6624:()=>EFt,content_3833_6626:()=>FFt,content_3833_6628:()=>jFt,content_3833_6630:()=>QFt,content_3833_6632:()=>JFt,content_3833_6634:()=>nVt,content_3833_6636:()=>pVt,content_3833_6638:()=>cVt,content_3833_664:()=>ise,content_3833_6640:()=>lVt,content_3833_6642:()=>yVt,content_3833_6644:()=>gVt,content_3833_6646:()=>MVt,content_3833_6648:()=>wVt,content_3833_6650:()=>xVt,content_3833_6652:()=>LVt,content_3833_6654:()=>kVt,content_3833_6656:()=>IVt,content_3833_6658:()=>SVt,content_3833_666:()=>mse,content_3833_6660:()=>EVt,content_3833_6662:()=>FVt,content_3833_6664:()=>jVt,content_3833_6666:()=>QVt,content_3833_6668:()=>JVt,content_3833_6670:()=>nqt,content_3833_6672:()=>pqt,content_3833_6674:()=>cqt,content_3833_6676:()=>lqt,content_3833_6678:()=>yqt,content_3833_668:()=>hse,content_3833_6680:()=>gqt,content_3833_6682:()=>Mqt,content_3833_6684:()=>wqt,content_3833_6686:()=>xqt,content_3833_6688:()=>Lqt,content_3833_6690:()=>kqt,content_3833_6692:()=>Iqt,content_3833_6694:()=>Sqt,content_3833_6696:()=>Eqt,content_3833_6698:()=>Fqt,content_3833_670:()=>Dse,content_3833_6700:()=>jqt,content_3833_6702:()=>Qqt,content_3833_6704:()=>Jqt,content_3833_6706:()=>njt,content_3833_6708:()=>pjt,content_3833_6710:()=>cjt,content_3833_6712:()=>ljt,content_3833_6714:()=>yjt,content_3833_6716:()=>gjt,content_3833_6718:()=>Mjt,content_3833_672:()=>_se,content_3833_6720:()=>wjt,content_3833_6722:()=>xjt,content_3833_6724:()=>Ljt,content_3833_6726:()=>kjt,content_3833_6728:()=>Ijt,content_3833_6730:()=>Sjt,content_3833_6732:()=>Ejt,content_3833_6734:()=>Fjt,content_3833_6736:()=>jjt,content_3833_6738:()=>Qjt,content_3833_674:()=>Cse,content_3833_6740:()=>Jjt,content_3833_6742:()=>nHt,content_3833_6744:()=>pHt,content_3833_6746:()=>cHt,content_3833_6748:()=>lHt,content_3833_6750:()=>yHt,content_3833_6752:()=>gHt,content_3833_6754:()=>MHt,content_3833_6756:()=>wHt,content_3833_6758:()=>xHt,content_3833_676:()=>vse,content_3833_6760:()=>LHt,content_3833_6762:()=>kHt,content_3833_6764:()=>IHt,content_3833_6766:()=>SHt,content_3833_6768:()=>EHt,content_3833_6770:()=>FHt,content_3833_6772:()=>jHt,content_3833_6774:()=>QHt,content_3833_6776:()=>JHt,content_3833_6778:()=>nYt,content_3833_678:()=>Nse,content_3833_6780:()=>pYt,content_3833_6782:()=>cYt,content_3833_6784:()=>lYt,content_3833_6786:()=>yYt,content_3833_6788:()=>gYt,content_3833_6790:()=>MYt,content_3833_6792:()=>wYt,content_3833_6794:()=>xYt,content_3833_6796:()=>LYt,content_3833_6798:()=>kYt,content_3833_68:()=>PZ,content_3833_680:()=>Pse,content_3833_6800:()=>IYt,content_3833_6802:()=>SYt,content_3833_6804:()=>EYt,content_3833_6806:()=>FYt,content_3833_6808:()=>jYt,content_3833_6810:()=>QYt,content_3833_6812:()=>JYt,content_3833_6814:()=>nQt,content_3833_6816:()=>pQt,content_3833_6818:()=>cQt,content_3833_682:()=>Wse,content_3833_6820:()=>lQt,content_3833_6822:()=>yQt,content_3833_6824:()=>gQt,content_3833_6826:()=>MQt,content_3833_6828:()=>wQt,content_3833_6830:()=>xQt,content_3833_6832:()=>LQt,content_3833_6834:()=>kQt,content_3833_6836:()=>IQt,content_3833_6838:()=>SQt,content_3833_684:()=>Gse,content_3833_6840:()=>EQt,content_3833_6842:()=>FQt,content_3833_6844:()=>jQt,content_3833_6846:()=>QQt,content_3833_6848:()=>JQt,content_3833_6850:()=>n$t,content_3833_6852:()=>p$t,content_3833_6854:()=>c$t,content_3833_6856:()=>l$t,content_3833_6858:()=>y$t,content_3833_686:()=>Use,content_3833_6860:()=>g$t,content_3833_6862:()=>M$t,content_3833_6864:()=>w$t,content_3833_6866:()=>x$t,content_3833_6868:()=>L$t,content_3833_6870:()=>k$t,content_3833_6872:()=>I$t,content_3833_6874:()=>S$t,content_3833_6876:()=>E$t,content_3833_6878:()=>F$t,content_3833_688:()=>qse,content_3833_6880:()=>j$t,content_3833_6882:()=>Q$t,content_3833_6884:()=>J$t,content_3833_6886:()=>nKt,content_3833_6888:()=>pKt,content_3833_6890:()=>cKt,content_3833_6892:()=>lKt,content_3833_6894:()=>yKt,content_3833_6896:()=>gKt,content_3833_6898:()=>MKt,content_3833_690:()=>Yse,content_3833_6900:()=>wKt,content_3833_6902:()=>xKt,content_3833_6904:()=>LKt,content_3833_6906:()=>kKt,content_3833_6908:()=>IKt,content_3833_6910:()=>SKt,content_3833_6912:()=>EKt,content_3833_6914:()=>FKt,content_3833_6916:()=>jKt,content_3833_6918:()=>QKt,content_3833_692:()=>Kse,content_3833_6920:()=>JKt,content_3833_6922:()=>nJt,content_3833_6924:()=>pJt,content_3833_6926:()=>cJt,content_3833_6928:()=>lJt,content_3833_6930:()=>yJt,content_3833_6932:()=>gJt,content_3833_6934:()=>MJt,content_3833_6936:()=>wJt,content_3833_6938:()=>xJt,content_3833_694:()=>ece,content_3833_6940:()=>LJt,content_3833_6942:()=>kJt,content_3833_6944:()=>IJt,content_3833_6946:()=>SJt,content_3833_6948:()=>EJt,content_3833_6950:()=>FJt,content_3833_6952:()=>jJt,content_3833_6954:()=>QJt,content_3833_6956:()=>JJt,content_3833_6958:()=>nZt,content_3833_696:()=>oce,content_3833_6960:()=>pZt,content_3833_6962:()=>cZt,content_3833_6964:()=>lZt,content_3833_6966:()=>yZt,content_3833_6968:()=>gZt,content_3833_6970:()=>MZt,content_3833_6972:()=>wZt,content_3833_6974:()=>xZt,content_3833_6976:()=>LZt,content_3833_6978:()=>kZt,content_3833_698:()=>sce,content_3833_6980:()=>IZt,content_3833_6982:()=>SZt,content_3833_6984:()=>EZt,content_3833_6986:()=>FZt,content_3833_6988:()=>jZt,content_3833_6990:()=>QZt,content_3833_6992:()=>JZt,content_3833_6994:()=>n0t,content_3833_6996:()=>p0t,content_3833_6998:()=>c0t,content_3833_70:()=>WZ,content_3833_700:()=>ice,content_3833_7000:()=>l0t,content_3833_7002:()=>y0t,content_3833_7004:()=>g0t,content_3833_7006:()=>M0t,content_3833_7008:()=>w0t,content_3833_7010:()=>x0t,content_3833_7012:()=>L0t,content_3833_7014:()=>k0t,content_3833_7016:()=>I0t,content_3833_7018:()=>S0t,content_3833_702:()=>mce,content_3833_7020:()=>E0t,content_3833_7022:()=>F0t,content_3833_7024:()=>j0t,content_3833_7026:()=>Q0t,content_3833_7028:()=>J0t,content_3833_7030:()=>n3t,content_3833_7032:()=>p3t,content_3833_7034:()=>c3t,content_3833_7036:()=>l3t,content_3833_7038:()=>y3t,content_3833_704:()=>hce,content_3833_7040:()=>g3t,content_3833_7042:()=>M3t,content_3833_7044:()=>w3t,content_3833_7046:()=>x3t,content_3833_7048:()=>L3t,content_3833_7050:()=>k3t,content_3833_7052:()=>I3t,content_3833_7054:()=>S3t,content_3833_7056:()=>E3t,content_3833_7058:()=>F3t,content_3833_706:()=>Dce,content_3833_7060:()=>j3t,content_3833_7062:()=>Q3t,content_3833_7064:()=>J3t,content_3833_7066:()=>n8t,content_3833_7068:()=>p8t,content_3833_7070:()=>c8t,content_3833_7072:()=>l8t,content_3833_7074:()=>y8t,content_3833_7076:()=>g8t,content_3833_7078:()=>M8t,content_3833_708:()=>_ce,content_3833_7080:()=>w8t,content_3833_7082:()=>x8t,content_3833_7084:()=>L8t,content_3833_7086:()=>k8t,content_3833_7088:()=>I8t,content_3833_7090:()=>S8t,content_3833_7092:()=>E8t,content_3833_7094:()=>F8t,content_3833_7096:()=>j8t,content_3833_7098:()=>Q8t,content_3833_710:()=>Cce,content_3833_7100:()=>J8t,content_3833_7102:()=>n2t,content_3833_7104:()=>p2t,content_3833_7106:()=>c2t,content_3833_7108:()=>l2t,content_3833_7110:()=>y2t,content_3833_7112:()=>g2t,content_3833_7114:()=>M2t,content_3833_7116:()=>w2t,content_3833_7118:()=>x2t,content_3833_712:()=>vce,content_3833_7120:()=>L2t,content_3833_7122:()=>k2t,content_3833_7124:()=>I2t,content_3833_7126:()=>S2t,content_3833_7128:()=>E2t,content_3833_7130:()=>F2t,content_3833_7132:()=>j2t,content_3833_7134:()=>Q2t,content_3833_7136:()=>J2t,content_3833_7138:()=>n1t,content_3833_714:()=>Nce,content_3833_7140:()=>p1t,content_3833_7142:()=>c1t,content_3833_7144:()=>l1t,content_3833_7146:()=>y1t,content_3833_7148:()=>g1t,content_3833_7150:()=>M1t,content_3833_7152:()=>w1t,content_3833_7154:()=>x1t,content_3833_7156:()=>L1t,content_3833_7158:()=>k1t,content_3833_716:()=>Pce,content_3833_7160:()=>I1t,content_3833_7162:()=>S1t,content_3833_7164:()=>E1t,content_3833_7166:()=>F1t,content_3833_7168:()=>j1t,content_3833_7170:()=>Q1t,content_3833_7172:()=>J1t,content_3833_7174:()=>n4t,content_3833_7176:()=>p4t,content_3833_7178:()=>c4t,content_3833_718:()=>Wce,content_3833_7180:()=>l4t,content_3833_7182:()=>y4t,content_3833_7184:()=>g4t,content_3833_7186:()=>M4t,content_3833_7188:()=>w4t,content_3833_7190:()=>x4t,content_3833_7192:()=>L4t,content_3833_7194:()=>k4t,content_3833_7196:()=>I4t,content_3833_7198:()=>S4t,content_3833_72:()=>GZ,content_3833_720:()=>Gce,content_3833_7200:()=>E4t,content_3833_7202:()=>F4t,content_3833_7204:()=>j4t,content_3833_7206:()=>Q4t,content_3833_7208:()=>J4t,content_3833_7210:()=>n6t,content_3833_7212:()=>p6t,content_3833_7214:()=>c6t,content_3833_7216:()=>l6t,content_3833_7218:()=>y6t,content_3833_722:()=>Uce,content_3833_7220:()=>g6t,content_3833_7222:()=>M6t,content_3833_7224:()=>w6t,content_3833_7226:()=>x6t,content_3833_7228:()=>L6t,content_3833_7230:()=>k6t,content_3833_7232:()=>I6t,content_3833_7234:()=>S6t,content_3833_7236:()=>E6t,content_3833_7238:()=>F6t,content_3833_724:()=>qce,content_3833_7240:()=>j6t,content_3833_7242:()=>Q6t,content_3833_7244:()=>J6t,content_3833_7246:()=>n5t,content_3833_7248:()=>p5t,content_3833_7250:()=>c5t,content_3833_7252:()=>l5t,content_3833_7254:()=>y5t,content_3833_7256:()=>g5t,content_3833_7258:()=>M5t,content_3833_726:()=>Yce,content_3833_7260:()=>w5t,content_3833_7262:()=>x5t,content_3833_7264:()=>L5t,content_3833_7266:()=>k5t,content_3833_7268:()=>I5t,content_3833_7270:()=>S5t,content_3833_7272:()=>E5t,content_3833_7274:()=>F5t,content_3833_7276:()=>j5t,content_3833_7278:()=>Q5t,content_3833_728:()=>Kce,content_3833_7280:()=>J5t,content_3833_7282:()=>n7t,content_3833_7284:()=>p7t,content_3833_7286:()=>c7t,content_3833_7288:()=>l7t,content_3833_7290:()=>y7t,content_3833_7292:()=>g7t,content_3833_7294:()=>M7t,content_3833_7296:()=>w7t,content_3833_7298:()=>x7t,content_3833_730:()=>eae,content_3833_7300:()=>L7t,content_3833_7302:()=>k7t,content_3833_7304:()=>I7t,content_3833_7306:()=>S7t,content_3833_7308:()=>E7t,content_3833_7310:()=>F7t,content_3833_7312:()=>j7t,content_3833_7314:()=>Q7t,content_3833_7316:()=>J7t,content_3833_7318:()=>n9t,content_3833_732:()=>oae,content_3833_7320:()=>p9t,content_3833_7322:()=>c9t,content_3833_7324:()=>l9t,content_3833_7326:()=>y9t,content_3833_7328:()=>g9t,content_3833_7330:()=>M9t,content_3833_7332:()=>w9t,content_3833_7334:()=>x9t,content_3833_7336:()=>L9t,content_3833_7338:()=>k9t,content_3833_734:()=>sae,content_3833_7340:()=>I9t,content_3833_7342:()=>S9t,content_3833_7344:()=>E9t,content_3833_7346:()=>F9t,content_3833_7348:()=>j9t,content_3833_7350:()=>Q9t,content_3833_7352:()=>J9t,content_3833_7354:()=>neo,content_3833_7356:()=>peo,content_3833_7358:()=>ceo,content_3833_736:()=>iae,content_3833_7360:()=>leo,content_3833_7362:()=>yeo,content_3833_7364:()=>geo,content_3833_7366:()=>Meo,content_3833_7368:()=>weo,content_3833_7370:()=>xeo,content_3833_7372:()=>Leo,content_3833_7374:()=>keo,content_3833_7376:()=>Ieo,content_3833_7378:()=>Seo,content_3833_738:()=>mae,content_3833_7380:()=>Eeo,content_3833_7382:()=>Feo,content_3833_7384:()=>jeo,content_3833_7386:()=>Qeo,content_3833_7388:()=>Jeo,content_3833_7390:()=>nno,content_3833_7392:()=>pno,content_3833_7394:()=>cno,content_3833_7396:()=>lno,content_3833_7398:()=>yno,content_3833_74:()=>UZ,content_3833_740:()=>hae,content_3833_7400:()=>gno,content_3833_7402:()=>Mno,content_3833_7404:()=>wno,content_3833_7406:()=>xno,content_3833_7408:()=>Lno,content_3833_7410:()=>kno,content_3833_7412:()=>Ino,content_3833_7414:()=>Sno,content_3833_7416:()=>Eno,content_3833_7418:()=>Fno,content_3833_742:()=>Dae,content_3833_7420:()=>jno,content_3833_7422:()=>Qno,content_3833_7424:()=>Jno,content_3833_7426:()=>nto,content_3833_7428:()=>pto,content_3833_7430:()=>cto,content_3833_7432:()=>lto,content_3833_7434:()=>yto,content_3833_7436:()=>gto,content_3833_7438:()=>Mto,content_3833_744:()=>_ae,content_3833_7440:()=>wto,content_3833_7442:()=>xto,content_3833_7444:()=>Lto,content_3833_7446:()=>kto,content_3833_7448:()=>Ito,content_3833_7450:()=>Sto,content_3833_7452:()=>Eto,content_3833_7454:()=>Fto,content_3833_7456:()=>jto,content_3833_7458:()=>Qto,content_3833_746:()=>Cae,content_3833_7460:()=>Jto,content_3833_7462:()=>noo,content_3833_7464:()=>poo,content_3833_7466:()=>coo,content_3833_7468:()=>loo,content_3833_7470:()=>yoo,content_3833_7472:()=>goo,content_3833_7474:()=>Moo,content_3833_7476:()=>woo,content_3833_7478:()=>xoo,content_3833_748:()=>vae,content_3833_7480:()=>Loo,content_3833_7482:()=>koo,content_3833_7484:()=>Ioo,content_3833_7486:()=>Soo,content_3833_7488:()=>Eoo,content_3833_7490:()=>Foo,content_3833_7492:()=>joo,content_3833_7494:()=>Qoo,content_3833_7496:()=>Joo,content_3833_7498:()=>npo,content_3833_750:()=>Nae,content_3833_7500:()=>ppo,content_3833_7502:()=>cpo,content_3833_7504:()=>lpo,content_3833_7506:()=>ypo,content_3833_7508:()=>gpo,content_3833_7510:()=>Mpo,content_3833_7512:()=>wpo,content_3833_7514:()=>xpo,content_3833_7516:()=>Lpo,content_3833_7518:()=>kpo,content_3833_752:()=>Pae,content_3833_7520:()=>Ipo,content_3833_7522:()=>Spo,content_3833_7524:()=>Epo,content_3833_7526:()=>Fpo,content_3833_7528:()=>jpo,content_3833_7530:()=>Qpo,content_3833_7532:()=>Jpo,content_3833_7534:()=>nro,content_3833_7536:()=>pro,content_3833_7538:()=>cro,content_3833_754:()=>Wae,content_3833_7540:()=>lro,content_3833_7542:()=>yro,content_3833_7544:()=>gro,content_3833_7546:()=>Mro,content_3833_7548:()=>wro,content_3833_7550:()=>xro,content_3833_7552:()=>Lro,content_3833_7554:()=>kro,content_3833_7556:()=>Iro,content_3833_7558:()=>Sro,content_3833_756:()=>Gae,content_3833_7560:()=>Ero,content_3833_7562:()=>Fro,content_3833_7564:()=>jro,content_3833_7566:()=>Qro,content_3833_7568:()=>Jro,content_3833_7570:()=>nso,content_3833_7572:()=>pso,content_3833_7574:()=>cso,content_3833_7576:()=>lso,content_3833_7578:()=>yso,content_3833_758:()=>Uae,content_3833_7580:()=>gso,content_3833_7582:()=>Mso,content_3833_7584:()=>wso,content_3833_7586:()=>xso,content_3833_7588:()=>Lso,content_3833_7590:()=>kso,content_3833_7592:()=>Iso,content_3833_7594:()=>Sso,content_3833_7596:()=>Eso,content_3833_7598:()=>Fso,content_3833_76:()=>qZ,content_3833_760:()=>qae,content_3833_7600:()=>jso,content_3833_7602:()=>Qso,content_3833_7604:()=>Jso,content_3833_7606:()=>nco,content_3833_7608:()=>pco,content_3833_7610:()=>cco,content_3833_7612:()=>lco,content_3833_7614:()=>yco,content_3833_7616:()=>gco,content_3833_7618:()=>Mco,content_3833_762:()=>Yae,content_3833_7620:()=>wco,content_3833_7622:()=>xco,content_3833_7624:()=>Lco,content_3833_7626:()=>kco,content_3833_7628:()=>Ico,content_3833_7630:()=>Sco,content_3833_7632:()=>Eco,content_3833_7634:()=>Fco,content_3833_7636:()=>jco,content_3833_7638:()=>Qco,content_3833_764:()=>Kae,content_3833_7640:()=>Jco,content_3833_7642:()=>nao,content_3833_7644:()=>pao,content_3833_7646:()=>cao,content_3833_7648:()=>lao,content_3833_7650:()=>yao,content_3833_7652:()=>gao,content_3833_7654:()=>Mao,content_3833_7656:()=>wao,content_3833_7658:()=>xao,content_3833_766:()=>eie,content_3833_7660:()=>Lao,content_3833_7662:()=>kao,content_3833_7664:()=>Iao,content_3833_7666:()=>Sao,content_3833_7668:()=>Eao,content_3833_7670:()=>Fao,content_3833_7672:()=>jao,content_3833_7674:()=>Qao,content_3833_7676:()=>Jao,content_3833_7678:()=>nio,content_3833_768:()=>oie,content_3833_7680:()=>pio,content_3833_7682:()=>cio,content_3833_7684:()=>lio,content_3833_7686:()=>yio,content_3833_7688:()=>gio,content_3833_7690:()=>Mio,content_3833_7692:()=>wio,content_3833_7694:()=>xio,content_3833_7696:()=>Lio,content_3833_7698:()=>kio,content_3833_770:()=>sie,content_3833_7700:()=>Iio,content_3833_7702:()=>Sio,content_3833_7704:()=>Eio,content_3833_7706:()=>Fio,content_3833_7708:()=>jio,content_3833_7710:()=>Qio,content_3833_7712:()=>Jio,content_3833_7714:()=>nlo,content_3833_7716:()=>plo,content_3833_7718:()=>clo,content_3833_772:()=>iie,content_3833_7720:()=>llo,content_3833_7722:()=>ylo,content_3833_7724:()=>glo,content_3833_7726:()=>Mlo,content_3833_7728:()=>wlo,content_3833_7730:()=>xlo,content_3833_7732:()=>Llo,content_3833_7734:()=>klo,content_3833_7736:()=>Ilo,content_3833_7738:()=>Slo,content_3833_774:()=>mie,content_3833_7740:()=>Elo,content_3833_7742:()=>Flo,content_3833_7744:()=>jlo,content_3833_7746:()=>Qlo,content_3833_7748:()=>Jlo,content_3833_7750:()=>nuo,content_3833_7752:()=>puo,content_3833_7754:()=>cuo,content_3833_7756:()=>luo,content_3833_7758:()=>yuo,content_3833_776:()=>hie,content_3833_7760:()=>guo,content_3833_7762:()=>Muo,content_3833_7764:()=>wuo,content_3833_7766:()=>xuo,content_3833_7768:()=>Luo,content_3833_7770:()=>kuo,content_3833_7772:()=>Iuo,content_3833_7774:()=>Suo,content_3833_7776:()=>Euo,content_3833_7778:()=>Fuo,content_3833_778:()=>Die,content_3833_7780:()=>juo,content_3833_7782:()=>Quo,content_3833_7784:()=>Juo,content_3833_7786:()=>nmo,content_3833_7788:()=>pmo,content_3833_7790:()=>cmo,content_3833_7792:()=>lmo,content_3833_7794:()=>ymo,content_3833_7796:()=>gmo,content_3833_7798:()=>Mmo,content_3833_78:()=>YZ,content_3833_780:()=>_ie,content_3833_7800:()=>wmo,content_3833_7802:()=>xmo,content_3833_7804:()=>Lmo,content_3833_7806:()=>kmo,content_3833_7808:()=>Imo,content_3833_7810:()=>Smo,content_3833_7812:()=>Emo,content_3833_7814:()=>Fmo,content_3833_7816:()=>jmo,content_3833_7818:()=>Qmo,content_3833_782:()=>Cie,content_3833_7820:()=>Jmo,content_3833_7822:()=>nyo,content_3833_7824:()=>pyo,content_3833_7826:()=>cyo,content_3833_7828:()=>lyo,content_3833_7830:()=>yyo,content_3833_7832:()=>gyo,content_3833_7834:()=>Myo,content_3833_7836:()=>wyo,content_3833_7838:()=>xyo,content_3833_784:()=>vie,content_3833_7840:()=>Lyo,content_3833_7842:()=>kyo,content_3833_7844:()=>Iyo,content_3833_7846:()=>Syo,content_3833_7848:()=>Eyo,content_3833_7850:()=>Fyo,content_3833_7852:()=>jyo,content_3833_7854:()=>Qyo,content_3833_7856:()=>Jyo,content_3833_7858:()=>ndo,content_3833_786:()=>Nie,content_3833_7860:()=>pdo,content_3833_7862:()=>cdo,content_3833_7864:()=>ldo,content_3833_7866:()=>ydo,content_3833_7868:()=>gdo,content_3833_7870:()=>Mdo,content_3833_7872:()=>wdo,content_3833_7874:()=>xdo,content_3833_7876:()=>Ldo,content_3833_7878:()=>kdo,content_3833_788:()=>Pie,content_3833_7880:()=>Ido,content_3833_7882:()=>Sdo,content_3833_7884:()=>Edo,content_3833_7886:()=>Fdo,content_3833_7888:()=>jdo,content_3833_7890:()=>Qdo,content_3833_7892:()=>Jdo,content_3833_7894:()=>nho,content_3833_7896:()=>pho,content_3833_7898:()=>cho,content_3833_790:()=>Wie,content_3833_7900:()=>lho,content_3833_7902:()=>yho,content_3833_7904:()=>gho,content_3833_7906:()=>Mho,content_3833_7908:()=>who,content_3833_7910:()=>xho,content_3833_7912:()=>Lho,content_3833_7914:()=>kho,content_3833_7916:()=>Iho,content_3833_7918:()=>Sho,content_3833_792:()=>Gie,content_3833_7920:()=>Eho,content_3833_7922:()=>Fho,content_3833_7924:()=>jho,content_3833_7926:()=>Qho,content_3833_7928:()=>Jho,content_3833_7930:()=>ngo,content_3833_7932:()=>pgo,content_3833_7934:()=>cgo,content_3833_7936:()=>lgo,content_3833_7938:()=>ygo,content_3833_794:()=>Uie,content_3833_7940:()=>ggo,content_3833_7942:()=>Mgo,content_3833_7944:()=>wgo,content_3833_7946:()=>xgo,content_3833_7948:()=>Lgo,content_3833_7950:()=>kgo,content_3833_7952:()=>Igo,content_3833_7954:()=>Sgo,content_3833_7956:()=>Ego,content_3833_7958:()=>Fgo,content_3833_796:()=>qie,content_3833_7960:()=>jgo,content_3833_7962:()=>Qgo,content_3833_7964:()=>Jgo,content_3833_7966:()=>nfo,content_3833_7968:()=>pfo,content_3833_7970:()=>cfo,content_3833_7972:()=>lfo,content_3833_7974:()=>yfo,content_3833_7976:()=>gfo,content_3833_7978:()=>Mfo,content_3833_798:()=>Yie,content_3833_7980:()=>wfo,content_3833_7982:()=>xfo,content_3833_7984:()=>Lfo,content_3833_7986:()=>kfo,content_3833_7988:()=>Ifo,content_3833_7990:()=>Sfo,content_3833_7992:()=>Efo,content_3833_7994:()=>Ffo,content_3833_7996:()=>jfo,content_3833_7998:()=>Qfo,content_3833_8:()=>KK,content_3833_80:()=>KZ,content_3833_800:()=>Kie,content_3833_8000:()=>Jfo,content_3833_8002:()=>nDo,content_3833_8004:()=>pDo,content_3833_8006:()=>cDo,content_3833_8008:()=>lDo,content_3833_8010:()=>yDo,content_3833_8012:()=>gDo,content_3833_8014:()=>MDo,content_3833_8016:()=>wDo,content_3833_8018:()=>xDo,content_3833_802:()=>ele,content_3833_8020:()=>LDo,content_3833_8022:()=>kDo,content_3833_8024:()=>IDo,content_3833_8026:()=>SDo,content_3833_8028:()=>EDo,content_3833_8030:()=>FDo,content_3833_8032:()=>jDo,content_3833_8034:()=>QDo,content_3833_8036:()=>JDo,content_3833_8038:()=>nMo,content_3833_804:()=>ole,content_3833_8040:()=>pMo,content_3833_8042:()=>cMo,content_3833_8044:()=>lMo,content_3833_8046:()=>yMo,content_3833_8048:()=>gMo,content_3833_8050:()=>MMo,content_3833_8052:()=>wMo,content_3833_8054:()=>xMo,content_3833_8056:()=>LMo,content_3833_8058:()=>kMo,content_3833_806:()=>sle,content_3833_8060:()=>IMo,content_3833_8062:()=>SMo,content_3833_8064:()=>EMo,content_3833_8066:()=>FMo,content_3833_8068:()=>jMo,content_3833_8070:()=>QMo,content_3833_8072:()=>JMo,content_3833_8074:()=>nXo,content_3833_8076:()=>pXo,content_3833_8078:()=>cXo,content_3833_808:()=>ile,content_3833_8080:()=>lXo,content_3833_8082:()=>yXo,content_3833_8084:()=>gXo,content_3833_8086:()=>MXo,content_3833_8088:()=>wXo,content_3833_8090:()=>xXo,content_3833_8092:()=>LXo,content_3833_8094:()=>kXo,content_3833_8096:()=>IXo,content_3833_8098:()=>SXo,content_3833_810:()=>mle,content_3833_8100:()=>EXo,content_3833_8102:()=>FXo,content_3833_8104:()=>jXo,content_3833_8106:()=>QXo,content_3833_8108:()=>JXo,content_3833_8110:()=>n_o,content_3833_8112:()=>p_o,content_3833_8114:()=>c_o,content_3833_8116:()=>l_o,content_3833_8118:()=>y_o,content_3833_812:()=>hle,content_3833_8120:()=>g_o,content_3833_8122:()=>M_o,content_3833_8124:()=>w_o,content_3833_8126:()=>x_o,content_3833_8128:()=>L_o,content_3833_8130:()=>k_o,content_3833_8132:()=>I_o,content_3833_8134:()=>S_o,content_3833_8136:()=>E_o,content_3833_8138:()=>F_o,content_3833_814:()=>Dle,content_3833_8140:()=>j_o,content_3833_8142:()=>Q_o,content_3833_8144:()=>J_o,content_3833_8146:()=>nwo,content_3833_8148:()=>pwo,content_3833_8150:()=>cwo,content_3833_8152:()=>lwo,content_3833_8154:()=>ywo,content_3833_8156:()=>gwo,content_3833_8158:()=>Mwo,content_3833_816:()=>_le,content_3833_8160:()=>wwo,content_3833_8162:()=>xwo,content_3833_8164:()=>Lwo,content_3833_8166:()=>kwo,content_3833_8168:()=>Iwo,content_3833_8170:()=>Swo,content_3833_8172:()=>Ewo,content_3833_8174:()=>Fwo,content_3833_8176:()=>jwo,content_3833_8178:()=>Qwo,content_3833_818:()=>Cle,content_3833_8180:()=>Jwo,content_3833_8182:()=>nTo,content_3833_8184:()=>pTo,content_3833_8186:()=>cTo,content_3833_8188:()=>lTo,content_3833_8190:()=>yTo,content_3833_8192:()=>gTo,content_3833_8194:()=>MTo,content_3833_8196:()=>wTo,content_3833_8198:()=>xTo,content_3833_82:()=>e0,content_3833_820:()=>vle,content_3833_8200:()=>LTo,content_3833_8202:()=>kTo,content_3833_8204:()=>ITo,content_3833_8206:()=>STo,content_3833_8208:()=>ETo,content_3833_8210:()=>FTo,content_3833_8212:()=>jTo,content_3833_8214:()=>QTo,content_3833_8216:()=>JTo,content_3833_8218:()=>nCo,content_3833_822:()=>Nle,content_3833_8220:()=>pCo,content_3833_8222:()=>cCo,content_3833_8224:()=>lCo,content_3833_8226:()=>yCo,content_3833_8228:()=>gCo,content_3833_8230:()=>MCo,content_3833_8232:()=>wCo,content_3833_8234:()=>xCo,content_3833_8236:()=>LCo,content_3833_8238:()=>kCo,content_3833_824:()=>Ple,content_3833_8240:()=>ICo,content_3833_8242:()=>SCo,content_3833_8244:()=>ECo,content_3833_8246:()=>FCo,content_3833_8248:()=>jCo,content_3833_8250:()=>QCo,content_3833_8252:()=>JCo,content_3833_8254:()=>nxo,content_3833_8256:()=>pxo,content_3833_8258:()=>cxo,content_3833_826:()=>Wle,content_3833_8260:()=>lxo,content_3833_8262:()=>yxo,content_3833_8264:()=>gxo,content_3833_8266:()=>Mxo,content_3833_8268:()=>wxo,content_3833_8270:()=>xxo,content_3833_8272:()=>Lxo,content_3833_8274:()=>kxo,content_3833_8276:()=>Ixo,content_3833_8278:()=>Sxo,content_3833_828:()=>Gle,content_3833_8280:()=>Exo,content_3833_8282:()=>Fxo,content_3833_8284:()=>jxo,content_3833_8286:()=>Qxo,content_3833_8288:()=>Jxo,content_3833_8290:()=>nAo,content_3833_8292:()=>pAo,content_3833_8294:()=>cAo,content_3833_8296:()=>lAo,content_3833_8298:()=>yAo,content_3833_830:()=>Ule,content_3833_8300:()=>gAo,content_3833_8302:()=>MAo,content_3833_8304:()=>wAo,content_3833_8306:()=>xAo,content_3833_8308:()=>LAo,content_3833_8310:()=>kAo,content_3833_8312:()=>IAo,content_3833_8314:()=>SAo,content_3833_8316:()=>EAo,content_3833_8318:()=>FAo,content_3833_832:()=>qle,content_3833_8320:()=>jAo,content_3833_8322:()=>QAo,content_3833_8324:()=>JAo,content_3833_8326:()=>nvo,content_3833_8328:()=>pvo,content_3833_8330:()=>cvo,content_3833_8332:()=>lvo,content_3833_8334:()=>yvo,content_3833_8336:()=>gvo,content_3833_8338:()=>Mvo,content_3833_834:()=>Yle,content_3833_8340:()=>wvo,content_3833_8342:()=>xvo,content_3833_8344:()=>Lvo,content_3833_8346:()=>kvo,content_3833_8348:()=>Ivo,content_3833_8350:()=>Svo,content_3833_8352:()=>Evo,content_3833_8354:()=>Fvo,content_3833_8356:()=>jvo,content_3833_8358:()=>Qvo,content_3833_836:()=>Kle,content_3833_8360:()=>Jvo,content_3833_8362:()=>nLo,content_3833_8364:()=>pLo,content_3833_8366:()=>cLo,content_3833_8368:()=>lLo,content_3833_8370:()=>yLo,content_3833_8372:()=>gLo,content_3833_8374:()=>MLo,content_3833_8376:()=>wLo,content_3833_8378:()=>xLo,content_3833_838:()=>eue,content_3833_8380:()=>LLo,content_3833_8382:()=>kLo,content_3833_8384:()=>ILo,content_3833_8386:()=>SLo,content_3833_8388:()=>ELo,content_3833_8390:()=>FLo,content_3833_8392:()=>jLo,content_3833_8394:()=>QLo,content_3833_8396:()=>JLo,content_3833_8398:()=>nbo,content_3833_84:()=>o0,content_3833_840:()=>oue,content_3833_8400:()=>pbo,content_3833_8402:()=>cbo,content_3833_8404:()=>lbo,content_3833_8406:()=>ybo,content_3833_8408:()=>gbo,content_3833_8410:()=>Mbo,content_3833_8412:()=>wbo,content_3833_8414:()=>xbo,content_3833_8416:()=>Lbo,content_3833_8418:()=>kbo,content_3833_842:()=>sue,content_3833_8420:()=>Ibo,content_3833_8422:()=>Sbo,content_3833_8424:()=>Ebo,content_3833_8426:()=>Fbo,content_3833_8428:()=>jbo,content_3833_8430:()=>Qbo,content_3833_8432:()=>Jbo,content_3833_8434:()=>nNo,content_3833_8436:()=>pNo,content_3833_8438:()=>cNo,content_3833_844:()=>iue,content_3833_8440:()=>lNo,content_3833_8442:()=>yNo,content_3833_8444:()=>gNo,content_3833_8446:()=>MNo,content_3833_8448:()=>wNo,content_3833_8450:()=>xNo,content_3833_8452:()=>LNo,content_3833_8454:()=>kNo,content_3833_8456:()=>INo,content_3833_8458:()=>SNo,content_3833_846:()=>mue,content_3833_8460:()=>ENo,content_3833_8462:()=>FNo,content_3833_8464:()=>jNo,content_3833_8466:()=>QNo,content_3833_8468:()=>JNo,content_3833_8470:()=>nko,content_3833_8472:()=>pko,content_3833_8474:()=>cko,content_3833_8476:()=>lko,content_3833_8478:()=>yko,content_3833_848:()=>hue,content_3833_8480:()=>gko,content_3833_8482:()=>Mko,content_3833_8484:()=>wko,content_3833_8486:()=>xko,content_3833_8488:()=>Lko,content_3833_8490:()=>kko,content_3833_8492:()=>Iko,content_3833_8494:()=>Sko,content_3833_8496:()=>Eko,content_3833_8498:()=>Fko,content_3833_850:()=>Due,content_3833_8500:()=>jko,content_3833_8502:()=>Qko,content_3833_8504:()=>Jko,content_3833_8506:()=>nzo,content_3833_8508:()=>pzo,content_3833_8510:()=>czo,content_3833_8512:()=>lzo,content_3833_8514:()=>yzo,content_3833_8516:()=>gzo,content_3833_8518:()=>Mzo,content_3833_852:()=>_ue,content_3833_8520:()=>wzo,content_3833_8522:()=>xzo,content_3833_8524:()=>Lzo,content_3833_8526:()=>kzo,content_3833_8528:()=>Izo,content_3833_8530:()=>Szo,content_3833_8532:()=>Ezo,content_3833_8534:()=>Fzo,content_3833_8536:()=>jzo,content_3833_8538:()=>Qzo,content_3833_854:()=>Cue,content_3833_8540:()=>Jzo,content_3833_8542:()=>nPo,content_3833_8544:()=>pPo,content_3833_8546:()=>cPo,content_3833_8548:()=>lPo,content_3833_8550:()=>yPo,content_3833_8552:()=>gPo,content_3833_8554:()=>MPo,content_3833_8556:()=>wPo,content_3833_8558:()=>xPo,content_3833_856:()=>vue,content_3833_8560:()=>LPo,content_3833_8562:()=>kPo,content_3833_8564:()=>IPo,content_3833_8566:()=>SPo,content_3833_8568:()=>EPo,content_3833_8570:()=>FPo,content_3833_8572:()=>jPo,content_3833_8574:()=>QPo,content_3833_8576:()=>JPo,content_3833_8578:()=>nIo,content_3833_858:()=>Nue,content_3833_8580:()=>pIo,content_3833_8582:()=>cIo,content_3833_8584:()=>lIo,content_3833_8586:()=>yIo,content_3833_8588:()=>gIo,content_3833_8590:()=>MIo,content_3833_8592:()=>wIo,content_3833_8594:()=>xIo,content_3833_8596:()=>LIo,content_3833_8598:()=>kIo,content_3833_86:()=>s0,content_3833_860:()=>Pue,content_3833_8600:()=>IIo,content_3833_8602:()=>SIo,content_3833_8604:()=>EIo,content_3833_8606:()=>FIo,content_3833_8608:()=>jIo,content_3833_8610:()=>QIo,content_3833_8612:()=>JIo,content_3833_8614:()=>nRo,content_3833_8616:()=>pRo,content_3833_8618:()=>cRo,content_3833_862:()=>Wue,content_3833_8620:()=>lRo,content_3833_8622:()=>yRo,content_3833_8624:()=>gRo,content_3833_8626:()=>MRo,content_3833_8628:()=>wRo,content_3833_8630:()=>xRo,content_3833_8632:()=>LRo,content_3833_8634:()=>kRo,content_3833_8636:()=>IRo,content_3833_8638:()=>SRo,content_3833_864:()=>Gue,content_3833_8640:()=>ERo,content_3833_8642:()=>FRo,content_3833_8644:()=>jRo,content_3833_8646:()=>QRo,content_3833_8648:()=>JRo,content_3833_8650:()=>nWo,content_3833_8652:()=>pWo,content_3833_8654:()=>cWo,content_3833_8656:()=>lWo,content_3833_8658:()=>yWo,content_3833_866:()=>Uue,content_3833_8660:()=>gWo,content_3833_8662:()=>MWo,content_3833_8664:()=>wWo,content_3833_8666:()=>xWo,content_3833_8668:()=>LWo,content_3833_8670:()=>kWo,content_3833_8672:()=>IWo,content_3833_8674:()=>SWo,content_3833_8676:()=>EWo,content_3833_8678:()=>FWo,content_3833_868:()=>que,content_3833_8680:()=>jWo,content_3833_8682:()=>QWo,content_3833_8684:()=>JWo,content_3833_8686:()=>nSo,content_3833_8688:()=>pSo,content_3833_8690:()=>cSo,content_3833_8692:()=>lSo,content_3833_8694:()=>ySo,content_3833_8696:()=>gSo,content_3833_8698:()=>MSo,content_3833_870:()=>Yue,content_3833_8700:()=>wSo,content_3833_8702:()=>xSo,content_3833_8704:()=>LSo,content_3833_8706:()=>kSo,content_3833_8708:()=>ISo,content_3833_8710:()=>SSo,content_3833_8712:()=>ESo,content_3833_8714:()=>FSo,content_3833_8716:()=>jSo,content_3833_8718:()=>QSo,content_3833_872:()=>Kue,content_3833_8720:()=>JSo,content_3833_8722:()=>nBo,content_3833_8724:()=>pBo,content_3833_8726:()=>cBo,content_3833_8728:()=>lBo,content_3833_8730:()=>yBo,content_3833_8732:()=>gBo,content_3833_8734:()=>MBo,content_3833_8736:()=>wBo,content_3833_8738:()=>xBo,content_3833_874:()=>eme,content_3833_8740:()=>LBo,content_3833_8742:()=>kBo,content_3833_8744:()=>IBo,content_3833_8746:()=>SBo,content_3833_8748:()=>EBo,content_3833_8750:()=>FBo,content_3833_8752:()=>jBo,content_3833_8754:()=>QBo,content_3833_8756:()=>JBo,content_3833_8758:()=>nGo,content_3833_876:()=>ome,content_3833_8760:()=>pGo,content_3833_8762:()=>cGo,content_3833_8764:()=>lGo,content_3833_8766:()=>yGo,content_3833_8768:()=>gGo,content_3833_8770:()=>MGo,content_3833_8772:()=>wGo,content_3833_8774:()=>xGo,content_3833_8776:()=>LGo,content_3833_8778:()=>kGo,content_3833_878:()=>sme,content_3833_8780:()=>IGo,content_3833_8782:()=>SGo,content_3833_8784:()=>EGo,content_3833_8786:()=>FGo,content_3833_8788:()=>jGo,content_3833_8790:()=>QGo,content_3833_8792:()=>JGo,content_3833_8794:()=>nEo,content_3833_8796:()=>pEo,content_3833_8798:()=>cEo,content_3833_88:()=>i0,content_3833_880:()=>ime,content_3833_8800:()=>lEo,content_3833_8802:()=>yEo,content_3833_8804:()=>gEo,content_3833_8806:()=>MEo,content_3833_8808:()=>wEo,content_3833_8810:()=>xEo,content_3833_8812:()=>LEo,content_3833_8814:()=>kEo,content_3833_8816:()=>IEo,content_3833_8818:()=>SEo,content_3833_882:()=>mme,content_3833_8820:()=>EEo,content_3833_8822:()=>FEo,content_3833_8824:()=>jEo,content_3833_8826:()=>QEo,content_3833_8828:()=>JEo,content_3833_8830:()=>nOo,content_3833_8832:()=>pOo,content_3833_8834:()=>cOo,content_3833_8836:()=>lOo,content_3833_8838:()=>yOo,content_3833_884:()=>hme,content_3833_8840:()=>gOo,content_3833_8842:()=>MOo,content_3833_8844:()=>wOo,content_3833_8846:()=>xOo,content_3833_8848:()=>LOo,content_3833_8850:()=>kOo,content_3833_8852:()=>IOo,content_3833_8854:()=>SOo,content_3833_8856:()=>EOo,content_3833_8858:()=>FOo,content_3833_886:()=>Dme,content_3833_8860:()=>jOo,content_3833_8862:()=>QOo,content_3833_8864:()=>JOo,content_3833_8866:()=>nUo,content_3833_8868:()=>pUo,content_3833_8870:()=>cUo,content_3833_8872:()=>lUo,content_3833_8874:()=>yUo,content_3833_8876:()=>gUo,content_3833_8878:()=>MUo,content_3833_888:()=>_me,content_3833_8880:()=>wUo,content_3833_8882:()=>xUo,content_3833_8884:()=>LUo,content_3833_8886:()=>kUo,content_3833_8888:()=>IUo,content_3833_8890:()=>SUo,content_3833_8892:()=>EUo,content_3833_8894:()=>FUo,content_3833_8896:()=>jUo,content_3833_8898:()=>QUo,content_3833_890:()=>Cme,content_3833_8900:()=>JUo,content_3833_8902:()=>nFo,content_3833_8904:()=>pFo,content_3833_8906:()=>cFo,content_3833_8908:()=>lFo,content_3833_8910:()=>yFo,content_3833_8912:()=>gFo,content_3833_8914:()=>MFo,content_3833_8916:()=>wFo,content_3833_8918:()=>xFo,content_3833_892:()=>vme,content_3833_8920:()=>LFo,content_3833_8922:()=>kFo,content_3833_8924:()=>IFo,content_3833_8926:()=>SFo,content_3833_8928:()=>EFo,content_3833_8930:()=>FFo,content_3833_8932:()=>jFo,content_3833_8934:()=>QFo,content_3833_8936:()=>JFo,content_3833_8938:()=>nVo,content_3833_894:()=>Nme,content_3833_8940:()=>pVo,content_3833_8942:()=>cVo,content_3833_8944:()=>lVo,content_3833_8946:()=>yVo,content_3833_8948:()=>gVo,content_3833_8950:()=>MVo,content_3833_8952:()=>wVo,content_3833_8954:()=>xVo,content_3833_8956:()=>LVo,content_3833_8958:()=>kVo,content_3833_896:()=>Pme,content_3833_8960:()=>IVo,content_3833_8962:()=>SVo,content_3833_8964:()=>EVo,content_3833_8966:()=>FVo,content_3833_8968:()=>jVo,content_3833_8970:()=>QVo,content_3833_8972:()=>JVo,content_3833_8974:()=>nqo,content_3833_8976:()=>pqo,content_3833_8978:()=>cqo,content_3833_898:()=>Wme,content_3833_8980:()=>lqo,content_3833_8982:()=>yqo,content_3833_8984:()=>gqo,content_3833_8986:()=>Mqo,content_3833_8988:()=>wqo,content_3833_8990:()=>xqo,content_3833_8992:()=>Lqo,content_3833_8994:()=>kqo,content_3833_8996:()=>Iqo,content_3833_8998:()=>Sqo,content_3833_90:()=>m0,content_3833_900:()=>Gme,content_3833_9000:()=>Eqo,content_3833_9002:()=>Fqo,content_3833_9004:()=>jqo,content_3833_9006:()=>Qqo,content_3833_9008:()=>Jqo,content_3833_9010:()=>njo,content_3833_9012:()=>pjo,content_3833_9014:()=>cjo,content_3833_9016:()=>ljo,content_3833_9018:()=>yjo,content_3833_902:()=>Ume,content_3833_9020:()=>gjo,content_3833_9022:()=>Mjo,content_3833_9024:()=>wjo,content_3833_9026:()=>xjo,content_3833_9028:()=>Ljo,content_3833_9030:()=>kjo,content_3833_9032:()=>Ijo,content_3833_9034:()=>Sjo,content_3833_9036:()=>Ejo,content_3833_9038:()=>Fjo,content_3833_904:()=>qme,content_3833_9040:()=>jjo,content_3833_9042:()=>Qjo,content_3833_9044:()=>Jjo,content_3833_9046:()=>nHo,content_3833_9048:()=>pHo,content_3833_9050:()=>cHo,content_3833_9052:()=>lHo,content_3833_9054:()=>yHo,content_3833_9056:()=>gHo,content_3833_9058:()=>MHo,content_3833_906:()=>Yme,content_3833_9060:()=>wHo,content_3833_9062:()=>xHo,content_3833_9064:()=>LHo,content_3833_9066:()=>kHo,content_3833_9068:()=>IHo,content_3833_9070:()=>SHo,content_3833_9072:()=>EHo,content_3833_9074:()=>FHo,content_3833_9076:()=>jHo,content_3833_9078:()=>QHo,content_3833_908:()=>Kme,content_3833_9080:()=>JHo,content_3833_9082:()=>nYo,content_3833_9084:()=>pYo,content_3833_9086:()=>cYo,content_3833_9088:()=>lYo,content_3833_9090:()=>yYo,content_3833_9092:()=>gYo,content_3833_9094:()=>MYo,content_3833_9096:()=>wYo,content_3833_9098:()=>xYo,content_3833_910:()=>eye,content_3833_9100:()=>LYo,content_3833_9102:()=>kYo,content_3833_9104:()=>IYo,content_3833_9106:()=>SYo,content_3833_9108:()=>EYo,content_3833_9110:()=>FYo,content_3833_9112:()=>jYo,content_3833_9114:()=>QYo,content_3833_9116:()=>JYo,content_3833_9118:()=>nQo,content_3833_912:()=>oye,content_3833_9120:()=>pQo,content_3833_9122:()=>cQo,content_3833_9124:()=>lQo,content_3833_9126:()=>yQo,content_3833_9128:()=>gQo,content_3833_9130:()=>MQo,content_3833_9132:()=>wQo,content_3833_9134:()=>xQo,content_3833_9136:()=>LQo,content_3833_9138:()=>kQo,content_3833_914:()=>sye,content_3833_9140:()=>IQo,content_3833_9142:()=>SQo,content_3833_9144:()=>EQo,content_3833_9146:()=>FQo,content_3833_9148:()=>jQo,content_3833_9150:()=>QQo,content_3833_9152:()=>JQo,content_3833_9154:()=>n$o,content_3833_9156:()=>p$o,content_3833_9158:()=>c$o,content_3833_916:()=>iye,content_3833_9160:()=>l$o,content_3833_9162:()=>y$o,content_3833_9164:()=>g$o,content_3833_9166:()=>M$o,content_3833_9168:()=>w$o,content_3833_9170:()=>x$o,content_3833_9172:()=>L$o,content_3833_9174:()=>k$o,content_3833_9176:()=>I$o,content_3833_9178:()=>S$o,content_3833_918:()=>mye,content_3833_9180:()=>E$o,content_3833_9182:()=>F$o,content_3833_9184:()=>j$o,content_3833_9186:()=>Q$o,content_3833_9188:()=>J$o,content_3833_9190:()=>nKo,content_3833_9192:()=>pKo,content_3833_9194:()=>cKo,content_3833_9196:()=>lKo,content_3833_9198:()=>yKo,content_3833_92:()=>h0,content_3833_920:()=>hye,content_3833_9200:()=>gKo,content_3833_9202:()=>MKo,content_3833_9204:()=>wKo,content_3833_9206:()=>xKo,content_3833_9208:()=>LKo,content_3833_9210:()=>kKo,content_3833_9212:()=>IKo,content_3833_9214:()=>SKo,content_3833_9216:()=>EKo,content_3833_9218:()=>FKo,content_3833_922:()=>Dye,content_3833_9220:()=>jKo,content_3833_9222:()=>QKo,content_3833_9224:()=>JKo,content_3833_9226:()=>nJo,content_3833_9228:()=>pJo,content_3833_9230:()=>cJo,content_3833_9232:()=>lJo,content_3833_9234:()=>yJo,content_3833_9236:()=>gJo,content_3833_9238:()=>MJo,content_3833_924:()=>_ye,content_3833_9240:()=>wJo,content_3833_9242:()=>xJo,content_3833_9244:()=>LJo,content_3833_9246:()=>kJo,content_3833_9248:()=>IJo,content_3833_9250:()=>SJo,content_3833_9252:()=>EJo,content_3833_9254:()=>FJo,content_3833_9256:()=>jJo,content_3833_9258:()=>QJo,content_3833_926:()=>Cye,content_3833_9260:()=>JJo,content_3833_9262:()=>nZo,content_3833_9264:()=>pZo,content_3833_9266:()=>cZo,content_3833_9268:()=>lZo,content_3833_9270:()=>yZo,content_3833_9272:()=>gZo,content_3833_9274:()=>MZo,content_3833_9276:()=>wZo,content_3833_9278:()=>xZo,content_3833_928:()=>vye,content_3833_9280:()=>LZo,content_3833_9282:()=>kZo,content_3833_9284:()=>IZo,content_3833_9286:()=>SZo,content_3833_9288:()=>EZo,content_3833_9290:()=>FZo,content_3833_9292:()=>jZo,content_3833_9294:()=>QZo,content_3833_9296:()=>JZo,content_3833_9298:()=>n0o,content_3833_930:()=>Nye,content_3833_9300:()=>p0o,content_3833_9302:()=>c0o,content_3833_9304:()=>l0o,content_3833_9306:()=>y0o,content_3833_9308:()=>g0o,content_3833_9310:()=>M0o,content_3833_9312:()=>w0o,content_3833_9314:()=>x0o,content_3833_9316:()=>L0o,content_3833_9318:()=>k0o,content_3833_932:()=>Pye,content_3833_9320:()=>I0o,content_3833_9322:()=>S0o,content_3833_9324:()=>E0o,content_3833_9326:()=>F0o,content_3833_9328:()=>j0o,content_3833_9330:()=>Q0o,content_3833_9332:()=>J0o,content_3833_9334:()=>n3o,content_3833_9336:()=>p3o,content_3833_9338:()=>c3o,content_3833_934:()=>Wye,content_3833_9340:()=>l3o,content_3833_9342:()=>y3o,content_3833_9344:()=>g3o,content_3833_9346:()=>M3o,content_3833_9348:()=>w3o,content_3833_9350:()=>x3o,content_3833_9352:()=>L3o,content_3833_9354:()=>k3o,content_3833_9356:()=>I3o,content_3833_9358:()=>S3o,content_3833_936:()=>Gye,content_3833_9360:()=>E3o,content_3833_9362:()=>F3o,content_3833_9364:()=>j3o,content_3833_9366:()=>Q3o,content_3833_9368:()=>J3o,content_3833_9370:()=>n8o,content_3833_9372:()=>p8o,content_3833_9374:()=>c8o,content_3833_9376:()=>l8o,content_3833_9378:()=>y8o,content_3833_938:()=>Uye,content_3833_9380:()=>g8o,content_3833_9382:()=>M8o,content_3833_9384:()=>w8o,content_3833_9386:()=>x8o,content_3833_9388:()=>L8o,content_3833_9390:()=>k8o,content_3833_9392:()=>I8o,content_3833_9394:()=>S8o,content_3833_9396:()=>E8o,content_3833_9398:()=>F8o,content_3833_94:()=>D0,content_3833_940:()=>qye,content_3833_9400:()=>j8o,content_3833_9402:()=>Q8o,content_3833_9404:()=>J8o,content_3833_9406:()=>n2o,content_3833_9408:()=>p2o,content_3833_9410:()=>c2o,content_3833_9412:()=>l2o,content_3833_9414:()=>y2o,content_3833_9416:()=>g2o,content_3833_9418:()=>M2o,content_3833_942:()=>Yye,content_3833_9420:()=>w2o,content_3833_9422:()=>x2o,content_3833_9424:()=>L2o,content_3833_9426:()=>k2o,content_3833_9428:()=>I2o,content_3833_9430:()=>S2o,content_3833_9432:()=>E2o,content_3833_9434:()=>F2o,content_3833_9436:()=>j2o,content_3833_9438:()=>Q2o,content_3833_944:()=>Kye,content_3833_9440:()=>J2o,content_3833_9442:()=>n1o,content_3833_9444:()=>p1o,content_3833_9446:()=>c1o,content_3833_9448:()=>l1o,content_3833_9450:()=>y1o,content_3833_9452:()=>g1o,content_3833_9454:()=>M1o,content_3833_9456:()=>w1o,content_3833_9458:()=>x1o,content_3833_946:()=>ede,content_3833_9460:()=>L1o,content_3833_9462:()=>k1o,content_3833_9464:()=>I1o,content_3833_9466:()=>S1o,content_3833_9468:()=>E1o,content_3833_9470:()=>F1o,content_3833_9472:()=>j1o,content_3833_9474:()=>Q1o,content_3833_9476:()=>J1o,content_3833_9478:()=>n4o,content_3833_948:()=>ode,content_3833_9480:()=>p4o,content_3833_9482:()=>c4o,content_3833_9484:()=>l4o,content_3833_9486:()=>y4o,content_3833_9488:()=>g4o,content_3833_9490:()=>M4o,content_3833_9492:()=>w4o,content_3833_9494:()=>x4o,content_3833_9496:()=>L4o,content_3833_9498:()=>k4o,content_3833_950:()=>sde,content_3833_9500:()=>I4o,content_3833_9502:()=>S4o,content_3833_9504:()=>E4o,content_3833_9506:()=>F4o,content_3833_9508:()=>j4o,content_3833_9510:()=>Q4o,content_3833_9512:()=>J4o,content_3833_9514:()=>n6o,content_3833_9516:()=>p6o,content_3833_9518:()=>c6o,content_3833_952:()=>ide,content_3833_9520:()=>l6o,content_3833_9522:()=>y6o,content_3833_9524:()=>g6o,content_3833_9526:()=>M6o,content_3833_9528:()=>w6o,content_3833_9530:()=>x6o,content_3833_9532:()=>L6o,content_3833_9534:()=>k6o,content_3833_9536:()=>I6o,content_3833_9538:()=>S6o,content_3833_954:()=>mde,content_3833_9540:()=>E6o,content_3833_9542:()=>F6o,content_3833_9544:()=>j6o,content_3833_9546:()=>Q6o,content_3833_9548:()=>J6o,content_3833_9550:()=>n5o,content_3833_9552:()=>p5o,content_3833_9554:()=>c5o,content_3833_9556:()=>l5o,content_3833_9558:()=>y5o,content_3833_956:()=>hde,content_3833_9560:()=>g5o,content_3833_9562:()=>M5o,content_3833_9564:()=>w5o,content_3833_9566:()=>x5o,content_3833_9568:()=>L5o,content_3833_9570:()=>k5o,content_3833_9572:()=>I5o,content_3833_9574:()=>S5o,content_3833_9576:()=>E5o,content_3833_9578:()=>F5o,content_3833_958:()=>Dde,content_3833_9580:()=>j5o,content_3833_9582:()=>Q5o,content_3833_9584:()=>J5o,content_3833_9586:()=>n7o,content_3833_9588:()=>p7o,content_3833_9590:()=>c7o,content_3833_9592:()=>l7o,content_3833_9594:()=>y7o,content_3833_9596:()=>g7o,content_3833_9598:()=>M7o,content_3833_96:()=>_0,content_3833_960:()=>_de,content_3833_9600:()=>w7o,content_3833_9602:()=>x7o,content_3833_9604:()=>L7o,content_3833_9606:()=>k7o,content_3833_9608:()=>I7o,content_3833_9610:()=>S7o,content_3833_9612:()=>E7o,content_3833_9614:()=>F7o,content_3833_9616:()=>j7o,content_3833_9618:()=>Q7o,content_3833_962:()=>Cde,content_3833_9620:()=>J7o,content_3833_9622:()=>n9o,content_3833_9624:()=>p9o,content_3833_9626:()=>c9o,content_3833_9628:()=>l9o,content_3833_9630:()=>y9o,content_3833_9632:()=>g9o,content_3833_9634:()=>M9o,content_3833_9636:()=>w9o,content_3833_9638:()=>x9o,content_3833_964:()=>vde,content_3833_9640:()=>L9o,content_3833_9642:()=>k9o,content_3833_9644:()=>I9o,content_3833_9646:()=>S9o,content_3833_9648:()=>E9o,content_3833_9650:()=>F9o,content_3833_9652:()=>j9o,content_3833_9654:()=>Q9o,content_3833_9656:()=>J9o,content_3833_9658:()=>nep,content_3833_966:()=>Nde,content_3833_9660:()=>pep,content_3833_9662:()=>cep,content_3833_9664:()=>lep,content_3833_9666:()=>yep,content_3833_9668:()=>gep,content_3833_9670:()=>Mep,content_3833_9672:()=>wep,content_3833_9674:()=>xep,content_3833_9676:()=>Lep,content_3833_9678:()=>kep,content_3833_968:()=>Pde,content_3833_9680:()=>Iep,content_3833_9682:()=>Sep,content_3833_9684:()=>Eep,content_3833_9686:()=>Fep,content_3833_9688:()=>jep,content_3833_9690:()=>Qep,content_3833_9692:()=>Jep,content_3833_9694:()=>nnp,content_3833_9696:()=>pnp,content_3833_9698:()=>cnp,content_3833_970:()=>Wde,content_3833_9700:()=>lnp,content_3833_9702:()=>ynp,content_3833_9704:()=>gnp,content_3833_9706:()=>Mnp,content_3833_9708:()=>wnp,content_3833_9710:()=>xnp,content_3833_9712:()=>Lnp,content_3833_9714:()=>knp,content_3833_9716:()=>Inp,content_3833_9718:()=>Snp,content_3833_972:()=>Gde,content_3833_9720:()=>Enp,content_3833_9722:()=>Fnp,content_3833_9724:()=>jnp,content_3833_9726:()=>Qnp,content_3833_9728:()=>Jnp,content_3833_9730:()=>ntp,content_3833_9732:()=>ptp,content_3833_9734:()=>ctp,content_3833_9736:()=>ltp,content_3833_9738:()=>ytp,content_3833_974:()=>Ude,content_3833_9740:()=>gtp,content_3833_9742:()=>Mtp,content_3833_9744:()=>wtp,content_3833_9746:()=>xtp,content_3833_9748:()=>Ltp,content_3833_9750:()=>ktp,content_3833_9752:()=>Itp,content_3833_9754:()=>Stp,content_3833_9756:()=>Etp,content_3833_9758:()=>Ftp,content_3833_976:()=>qde,content_3833_9760:()=>jtp,content_3833_9762:()=>Qtp,content_3833_9764:()=>Jtp,content_3833_9766:()=>nop,content_3833_9768:()=>pop,content_3833_9770:()=>cop,content_3833_9772:()=>lop,content_3833_9774:()=>yop,content_3833_9776:()=>gop,content_3833_9778:()=>Mop,content_3833_978:()=>Yde,content_3833_9780:()=>wop,content_3833_9782:()=>xop,content_3833_9784:()=>Lop,content_3833_9786:()=>kop,content_3833_9788:()=>Iop,content_3833_9790:()=>Sop,content_3833_9792:()=>Eop,content_3833_9794:()=>Fop,content_3833_9796:()=>jop,content_3833_9798:()=>Qop,content_3833_98:()=>C0,content_3833_980:()=>Kde,content_3833_9800:()=>Jop,content_3833_9802:()=>npp,content_3833_9804:()=>ppp,content_3833_9806:()=>cpp,content_3833_9808:()=>lpp,content_3833_9810:()=>ypp,content_3833_9812:()=>gpp,content_3833_9814:()=>Mpp,content_3833_9816:()=>wpp,content_3833_9818:()=>xpp,content_3833_982:()=>ehe,content_3833_9820:()=>Lpp,content_3833_9822:()=>kpp,content_3833_9824:()=>Ipp,content_3833_9826:()=>Spp,content_3833_9828:()=>Epp,content_3833_9830:()=>Fpp,content_3833_9832:()=>jpp,content_3833_9834:()=>Qpp,content_3833_9836:()=>Jpp,content_3833_9838:()=>nrp,content_3833_984:()=>ohe,content_3833_9840:()=>prp,content_3833_9842:()=>crp,content_3833_9844:()=>lrp,content_3833_9846:()=>yrp,content_3833_9848:()=>grp,content_3833_9850:()=>Mrp,content_3833_9852:()=>wrp,content_3833_9854:()=>xrp,content_3833_9856:()=>Lrp,content_3833_9858:()=>krp,content_3833_986:()=>she,content_3833_9860:()=>Irp,content_3833_9862:()=>Srp,content_3833_9864:()=>Erp,content_3833_9866:()=>Frp,content_3833_9868:()=>jrp,content_3833_9870:()=>Qrp,content_3833_9872:()=>Jrp,content_3833_9874:()=>nsp,content_3833_9876:()=>psp,content_3833_9878:()=>csp,content_3833_988:()=>ihe,content_3833_9880:()=>lsp,content_3833_9882:()=>ysp,content_3833_9884:()=>gsp,content_3833_9886:()=>Msp,content_3833_9888:()=>wsp,content_3833_9890:()=>xsp,content_3833_9892:()=>Lsp,content_3833_9894:()=>ksp,content_3833_9896:()=>Isp,content_3833_9898:()=>Ssp,content_3833_990:()=>mhe,content_3833_9900:()=>Esp,content_3833_9902:()=>Fsp,content_3833_9904:()=>jsp,content_3833_9906:()=>Qsp,content_3833_9908:()=>Jsp,content_3833_9910:()=>ncp,content_3833_9912:()=>pcp,content_3833_9914:()=>ccp,content_3833_9916:()=>lcp,content_3833_9918:()=>ycp,content_3833_992:()=>hhe,content_3833_9920:()=>gcp,content_3833_9922:()=>Mcp,content_3833_9924:()=>wcp,content_3833_9926:()=>xcp,content_3833_9928:()=>Lcp,content_3833_9930:()=>kcp,content_3833_9932:()=>Icp,content_3833_9934:()=>Scp,content_3833_9936:()=>Ecp,content_3833_9938:()=>Fcp,content_3833_994:()=>Dhe,content_3833_9940:()=>jcp,content_3833_9942:()=>Qcp,content_3833_9944:()=>Jcp,content_3833_9946:()=>nap,content_3833_9948:()=>pap,content_3833_9950:()=>cap,content_3833_9952:()=>lap,content_3833_9954:()=>yap,content_3833_9956:()=>gap,content_3833_9958:()=>Map,content_3833_996:()=>_he,content_3833_9960:()=>wap,content_3833_9962:()=>xap,content_3833_9964:()=>Lap,content_3833_9966:()=>kap,content_3833_9968:()=>Iap,content_3833_9970:()=>Sap,content_3833_9972:()=>Eap,content_3833_9974:()=>Fap,content_3833_9976:()=>jap,content_3833_9978:()=>Qap,content_3833_998:()=>Che,content_3833_9980:()=>Jap,content_3833_9982:()=>nip,content_3833_9984:()=>pip,content_3833_9986:()=>cip,content_3833_9988:()=>lip,content_3833_9990:()=>yip,content_3833_9992:()=>gip,content_3833_9994:()=>Mip,content_3833_9996:()=>wip,content_3833_9998:()=>xip});var p=t(9575),r=t(4041),s=t(2247);const c={toc:[]},a="wrapper";function i(e){let{components:n,...t}=e;return(0,s.yg)(a,(0,p.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const l={toc:[]},u="wrapper";function m(e){let{components:n,...t}=e;return(0,s.yg)(u,(0,p.A)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when a new message is logged."))}m.isMDXComponent=!0;const y={toc:[]},d="wrapper";function h(e){let{components:n,...t}=e;return(0,s.yg)(d,(0,p.A)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A read-only representation of the playback."))}h.isMDXComponent=!0;const g={toc:[]},f="wrapper";function D(e){let{components:n,...t}=e;return(0,s.yg)(f,(0,p.A)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The time passed since the last frame in seconds."))}D.isMDXComponent=!0;const M={toc:[]},X="wrapper";function _(e){let{components:n,...t}=e;return(0,s.yg)(X,(0,p.A)({},M,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert frames to seconds using the current framerate."))}_.isMDXComponent=!0;const w={toc:[]},T="wrapper";function C(e){let{components:n,...t}=e;return(0,s.yg)(T,(0,p.A)({},w,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frames to convert."))}C.isMDXComponent=!0;const x={toc:[]},A="wrapper";function v(e){let{components:n,...t}=e;return(0,s.yg)(A,(0,p.A)({},x,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert seconds to frames using the current framerate."))}v.isMDXComponent=!0;const L={toc:[]},b="wrapper";function N(e){let{components:n,...t}=e;return(0,s.yg)(b,(0,p.A)({},L,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The seconds to convert."))}N.isMDXComponent=!0;const k={toc:[]},z="wrapper";function P(e){let{components:n,...t}=e;return(0,s.yg)(z,(0,p.A)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This class builds on top of the ",(0,s.yg)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}P.isMDXComponent=!0;const I={toc:[]},R="wrapper";function W(e){let{components:n,...t}=e;return(0,s.yg)(R,(0,p.A)({},I,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The player logic used by the editor and embeddable player."))}W.isMDXComponent=!0;const S={toc:[]},B="wrapper";function G(e){let{components:n,...t}=e;return(0,s.yg)(B,(0,p.A)({},S,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to provide visual feedback."))}G.isMDXComponent=!0;const E={toc:[]},O="wrapper";function U(e){let{components:n,...t}=e;return(0,s.yg)(O,(0,p.A)({},E,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered right after recalculation finishes."))}U.isMDXComponent=!0;const F={toc:[]},V="wrapper";function q(e){let{components:n,...t}=e;return(0,s.yg)(V,(0,p.A)({},F,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.yg)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.yg)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}q.isMDXComponent=!0;const j={toc:[]},H="wrapper";function Y(e){let{components:n,...t}=e;return(0,s.yg)(H,(0,p.A)({},j,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}Y.isMDXComponent=!0;const Q={toc:[]},$="wrapper";function K(e){let{components:n,...t}=e;return(0,s.yg)($,(0,p.A)({},Q,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}K.isMDXComponent=!0;const J={toc:[]},Z="wrapper";function ee(e){let{components:n,...t}=e;return(0,s.yg)(Z,(0,p.A)({},J,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Activate the player."))}ee.isMDXComponent=!0;const ne={toc:[]},te="wrapper";function oe(e){let{components:n,...t}=e;return(0,s.yg)(te,(0,p.A)({},ne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.yg)("p",null,"Just pausing the player does not stop the loop."))}oe.isMDXComponent=!0;const pe={toc:[]},re="wrapper";function se(e){let{components:n,...t}=e;return(0,s.yg)(re,(0,p.A)({},pe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Deactivate the player."))}se.isMDXComponent=!0;const ce={toc:[]},ae="wrapper";function ie(e){let{components:n,...t}=e;return(0,s.yg)(ae,(0,p.A)({},ce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the given frame is inside the animation range."))}ie.isMDXComponent=!0;const le={toc:[]},ue="wrapper";function me(e){let{components:n,...t}=e;return(0,s.yg)(ue,(0,p.A)({},le,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame to check."))}me.isMDXComponent=!0;const ye={toc:[]},de="wrapper";function he(e){let{components:n,...t}=e;return(0,s.yg)(de,(0,p.A)({},ye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the given frame is inside the user-defined range."))}he.isMDXComponent=!0;const ge={toc:[]},fe="wrapper";function De(e){let{components:n,...t}=e;return(0,s.yg)(fe,(0,p.A)({},ge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame to check."))}De.isMDXComponent=!0;const Me={toc:[]},Xe="wrapper";function _e(e){let{components:n,...t}=e;return(0,s.yg)(Xe,(0,p.A)({},Me,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abort the ongoing presentation process."))}_e.isMDXComponent=!0;const we={toc:[]},Te="wrapper";function Ce(e){let{components:n,...t}=e;return(0,s.yg)(Te,(0,p.A)({},we,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Present the animation."))}Ce.isMDXComponent=!0;const xe={toc:[]},Ae="wrapper";function ve(e){let{components:n,...t}=e;return(0,s.yg)(Ae,(0,p.A)({},xe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The presentation settings."))}ve.isMDXComponent=!0;const Le={toc:[]},be="wrapper";function Ne(e){let{components:n,...t}=e;return(0,s.yg)(be,(0,p.A)({},Le,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Resume the presentation if waiting for the next slide."))}Ne.isMDXComponent=!0;const ke={toc:[]},ze="wrapper";function Pe(e){let{components:n,...t}=e;return(0,s.yg)(ze,(0,p.A)({},ke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Pe.isMDXComponent=!0;const Ie={toc:[]},Re="wrapper";function We(e){let{components:n,...t}=e;return(0,s.yg)(Re,(0,p.A)({},Ie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}We.isMDXComponent=!0;const Se={toc:[]},Be="wrapper";function Ge(e){let{components:n,...t}=e;return(0,s.yg)(Be,(0,p.A)({},Se,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}Ge.isMDXComponent=!0;const Ee={toc:[]},Oe="wrapper";function Ue(e){let{components:n,...t}=e;return(0,s.yg)(Oe,(0,p.A)({},Ee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}Ue.isMDXComponent=!0;const Fe={toc:[]},Ve="wrapper";function qe(e){let{components:n,...t}=e;return(0,s.yg)(Ve,(0,p.A)({},Fe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the nested fields change."))}qe.isMDXComponent=!0;const je={toc:[]},He="wrapper";function Ye(e){let{components:n,...t}=e;return(0,s.yg)(He,(0,p.A)({},je,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}Ye.isMDXComponent=!0;const Qe={toc:[]},$e="wrapper";function Ke(e){let{components:n,...t}=e;return(0,s.yg)($e,(0,p.A)({},Qe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}Ke.isMDXComponent=!0;const Je={toc:[]},Ze="wrapper";function en(e){let{components:n,...t}=e;return(0,s.yg)(Ze,(0,p.A)({},Je,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}en.isMDXComponent=!0;const nn={toc:[]},tn="wrapper";function on(e){let{components:n,...t}=e;return(0,s.yg)(tn,(0,p.A)({},nn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}on.isMDXComponent=!0;const pn={toc:[]},rn="wrapper";function sn(e){let{components:n,...t}=e;return(0,s.yg)(rn,(0,p.A)({},pn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}sn.isMDXComponent=!0;const cn={toc:[]},an="wrapper";function ln(e){let{components:n,...t}=e;return(0,s.yg)(an,(0,p.A)({},cn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}ln.isMDXComponent=!0;const un={toc:[]},mn="wrapper";function yn(e){let{components:n,...t}=e;return(0,s.yg)(mn,(0,p.A)({},un,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}yn.isMDXComponent=!0;const dn={toc:[]},hn="wrapper";function gn(e){let{components:n,...t}=e;return(0,s.yg)(hn,(0,p.A)({},dn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}gn.isMDXComponent=!0;const fn={toc:[]},Dn="wrapper";function Mn(e){let{components:n,...t}=e;return(0,s.yg)(Dn,(0,p.A)({},fn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Mn.isMDXComponent=!0;const Xn={toc:[]},_n="wrapper";function wn(e){let{components:n,...t}=e;return(0,s.yg)(_n,(0,p.A)({},Xn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This class uses the ",(0,s.yg)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.yg)("p",null,"The actual exporting is outsourced to an ",(0,s.yg)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.yg)("inlineCode",{parentName:"a"},"Exporter")),"."))}wn.isMDXComponent=!0;const Tn={toc:[]},Cn="wrapper";function xn(e){let{components:n,...t}=e;return(0,s.yg)(Cn,(0,p.A)({},Tn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering logic used by the editor to export animations."))}xn.isMDXComponent=!0;const An={toc:[]},vn="wrapper";function Ln(e){let{components:n,...t}=e;return(0,s.yg)(vn,(0,p.A)({},An,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abort the ongoing render process."))}Ln.isMDXComponent=!0;const bn={toc:[]},Nn="wrapper";function kn(e){let{components:n,...t}=e;return(0,s.yg)(Nn,(0,p.A)({},bn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns number of frames that a project will have."))}kn.isMDXComponent=!0;const zn={toc:[]},Pn="wrapper";function In(e){let{components:n,...t}=e;return(0,s.yg)(Pn,(0,p.A)({},zn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the animation using the provided settings."))}In.isMDXComponent=!0;const Rn={toc:[]},Wn="wrapper";function Sn(e){let{components:n,...t}=e;return(0,s.yg)(Wn,(0,p.A)({},Rn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}Sn.isMDXComponent=!0;const Bn={toc:[]},Gn="wrapper";function En(e){let{components:n,...t}=e;return(0,s.yg)(Gn,(0,p.A)({},Bn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method always uses the default ",(0,s.yg)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}En.isMDXComponent=!0;const On={toc:[]},Un="wrapper";function Fn(e){let{components:n,...t}=e;return(0,s.yg)(Un,(0,p.A)({},On,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export an individual frame."))}Fn.isMDXComponent=!0;const Vn={toc:[]},qn="wrapper";function jn(e){let{components:n,...t}=e;return(0,s.yg)(qn,(0,p.A)({},Vn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}jn.isMDXComponent=!0;const Hn={toc:[]},Yn="wrapper";function Qn(e){let{components:n,...t}=e;return(0,s.yg)(Yn,(0,p.A)({},Hn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timestamp to export."))}Qn.isMDXComponent=!0;const $n={toc:[]},Kn="wrapper";function Jn(e){let{components:n,...t}=e;return(0,s.yg)(Kn,(0,p.A)({},$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispose the WebGL context to free up resources."))}Jn.isMDXComponent=!0;const Zn={toc:[]},et="wrapper";function nt(e){let{components:n,...t}=e;return(0,s.yg)(et,(0,p.A)({},Zn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Manages canvases on which an animation can be displayed."))}nt.isMDXComponent=!0;const tt={toc:[]},ot="wrapper";function pt(e){let{components:n,...t}=e;return(0,s.yg)(ot,(0,p.A)({},tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main interface for implementing custom exporters."))}pt.isMDXComponent=!0;const rt={toc:[]},st="wrapper";function ct(e){let{components:n,...t}=e;return(0,s.yg)(st,(0,p.A)({},rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}ct.isMDXComponent=!0;const at={toc:[]},it="wrapper";function lt(e){let{components:n,...t}=e;return(0,s.yg)(it,(0,p.A)({},at,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the rendering configuration."))}lt.isMDXComponent=!0;const ut={toc:[]},mt="wrapper";function yt(e){let{components:n,...t}=e;return(0,s.yg)(mt,(0,p.A)({},ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Take in media assets per frame and generate audio track for the video."))}yt.isMDXComponent=!0;const dt={toc:[]},ht="wrapper";function gt(e){let{components:n,...t}=e;return(0,s.yg)(ht,(0,p.A)({},dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called each time after a frame is rendered."))}gt.isMDXComponent=!0;const ft={toc:[]},Dt="wrapper";function Mt(e){let{components:n,...t}=e;return(0,s.yg)(Dt,(0,p.A)({},ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export a frame."))}Mt.isMDXComponent=!0;const Xt={toc:[]},_t="wrapper";function wt(e){let{components:n,...t}=e;return(0,s.yg)(_t,(0,p.A)({},Xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A canvas containing the rendered frame."))}wt.isMDXComponent=!0;const Tt={toc:[]},Ct="wrapper";function xt(e){let{components:n,...t}=e;return(0,s.yg)(Ct,(0,p.A)({},Tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame number."))}xt.isMDXComponent=!0;const At={toc:[]},vt="wrapper";function Lt(e){let{components:n,...t}=e;return(0,s.yg)(vt,(0,p.A)({},At,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame number within the scene."))}Lt.isMDXComponent=!0;const bt={toc:[]},Nt="wrapper";function kt(e){let{components:n,...t}=e;return(0,s.yg)(Nt,(0,p.A)({},bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the scene with which the frame is associated."))}kt.isMDXComponent=!0;const zt={toc:[]},Pt="wrapper";function It(e){let{components:n,...t}=e;return(0,s.yg)(Pt,(0,p.A)({},zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An abort signal triggered if the user aborts the rendering."))}It.isMDXComponent=!0;const Rt={toc:[]},Wt="wrapper";function St(e){let{components:n,...t}=e;return(0,s.yg)(Wt,(0,p.A)({},Rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Performs clean-up."))}St.isMDXComponent=!0;const Bt={toc:[]},Gt="wrapper";function Et(e){let{components:n,...t}=e;return(0,s.yg)(Gt,(0,p.A)({},Bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}Et.isMDXComponent=!0;const Ot={toc:[]},Ut="wrapper";function Ft(e){let{components:n,...t}=e;return(0,s.yg)(Ut,(0,p.A)({},Ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"after processing the image stream and generating an audio file, merge the video and audio stream as the final video"))}Ft.isMDXComponent=!0;const Vt={toc:[]},qt="wrapper";function jt(e){let{components:n,...t}=e;return(0,s.yg)(qt,(0,p.A)({},Vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.yg)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.yg)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}jt.isMDXComponent=!0;const Ht={toc:[]},Yt="wrapper";function Qt(e){let{components:n,...t}=e;return(0,s.yg)(Yt,(0,p.A)({},Ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Begin the rendering process."))}Qt.isMDXComponent=!0;const $t={toc:[]},Kt="wrapper";function Jt(e){let{components:n,...t}=e;return(0,s.yg)(Kt,(0,p.A)({},$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after rendering the visual elements has finished and audio so that audio track can be merged."))}Jt.isMDXComponent=!0;const Zt={toc:[]},eo="wrapper";function no(e){let{components:n,...t}=e;return(0,s.yg)(eo,(0,p.A)({},Zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}no.isMDXComponent=!0;const to={toc:[]},oo="wrapper";function po(e){let{components:n,...t}=e;return(0,s.yg)(oo,(0,p.A)({},to,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of the rendering."))}po.isMDXComponent=!0;const ro={toc:[]},so="wrapper";function co(e){let{components:n,...t}=e;return(0,s.yg)(so,(0,p.A)({},ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The static interface for exporters."))}co.isMDXComponent=!0;const ao={toc:[]},io="wrapper";function lo(e){let{components:n,...t}=e;return(0,s.yg)(io,(0,p.A)({},ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This name will be displayed in the editor."))}lo.isMDXComponent=!0;const uo={toc:[]},mo="wrapper";function yo(e){let{components:n,...t}=e;return(0,s.yg)(mo,(0,p.A)({},uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this exporter."))}yo.isMDXComponent=!0;const ho={toc:[]},go="wrapper";function fo(e){let{components:n,...t}=e;return(0,s.yg)(go,(0,p.A)({},ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}fo.isMDXComponent=!0;const Do={toc:[]},Mo="wrapper";function Xo(e){let{components:n,...t}=e;return(0,s.yg)(Mo,(0,p.A)({},Do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The unique identifier of this exporter."))}Xo.isMDXComponent=!0;const _o={toc:[]},wo="wrapper";function To(e){let{components:n,...t}=e;return(0,s.yg)(wo,(0,p.A)({},_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}To.isMDXComponent=!0;const Co={toc:[]},xo="wrapper";function Ao(e){let{components:n,...t}=e;return(0,s.yg)(xo,(0,p.A)({},Co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this exporter."))}Ao.isMDXComponent=!0;const vo={toc:[]},Lo="wrapper";function bo(e){let{components:n,...t}=e;return(0,s.yg)(Lo,(0,p.A)({},vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current project."))}bo.isMDXComponent=!0;const No={toc:[]},ko="wrapper";function zo(e){let{components:n,...t}=e;return(0,s.yg)(ko,(0,p.A)({},No,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}zo.isMDXComponent=!0;const Po={toc:[]},Io="wrapper";function Ro(e){let{components:n,...t}=e;return(0,s.yg)(Io,(0,p.A)({},Po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a meta field representing the options of this exporter."))}Ro.isMDXComponent=!0;const Wo={toc:[]},So="wrapper";function Bo(e){let{components:n,...t}=e;return(0,s.yg)(So,(0,p.A)({},Wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When displayed in the editor, the log entry will have the following format:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},"                             inspect node \u2510\n  \u250c expand more          duration \u2510       \u2502\n  \u25bc                               \u25bc       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u25b6 message                       300 ms (+) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 remarks                                    \u2502\n\u2502 object                                     \u2502\n\u2502 stacktrace                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))}Bo.isMDXComponent=!0;const Go={toc:[]},Eo="wrapper";function Oo(e){let{components:n,...t}=e;return(0,s.yg)(Eo,(0,p.A)({},Go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an individual log entry."))}Oo.isMDXComponent=!0;const Uo={toc:[]},Fo="wrapper";function Vo(e){let{components:n,...t}=e;return(0,s.yg)(Fo,(0,p.A)({},Uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}Vo.isMDXComponent=!0;const qo={toc:[]},jo="wrapper";function Ho(e){let{components:n,...t}=e;return(0,s.yg)(jo,(0,p.A)({},qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}Ho.isMDXComponent=!0;const Yo={toc:[]},Qo="wrapper";function $o(e){let{components:n,...t}=e;return(0,s.yg)(Qo,(0,p.A)({},Yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}$o.isMDXComponent=!0;const Ko={toc:[]},Jo="wrapper";function Zo(e){let{components:n,...t}=e;return(0,s.yg)(Jo,(0,p.A)({},Ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}Zo.isMDXComponent=!0;const ep={toc:[]},np="wrapper";function tp(e){let{components:n,...t}=e;return(0,s.yg)(np,(0,p.A)({},ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The log level."))}tp.isMDXComponent=!0;const op={toc:[]},pp="wrapper";function rp(e){let{components:n,...t}=e;return(0,s.yg)(pp,(0,p.A)({},op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}rp.isMDXComponent=!0;const sp={toc:[]},cp="wrapper";function ap(e){let{components:n,...t}=e;return(0,s.yg)(cp,(0,p.A)({},sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}ap.isMDXComponent=!0;const ip={toc:[]},lp="wrapper";function up(e){let{components:n,...t}=e;return(0,s.yg)(lp,(0,p.A)({},ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}up.isMDXComponent=!0;const mp={toc:[]},yp="wrapper";function dp(e){let{components:n,...t}=e;return(0,s.yg)(yp,(0,p.A)({},mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}dp.isMDXComponent=!0;const hp={toc:[]},gp="wrapper";function fp(e){let{components:n,...t}=e;return(0,s.yg)(gp,(0,p.A)({},hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}fp.isMDXComponent=!0;const Dp={toc:[]},Mp="wrapper";function Xp(e){let{components:n,...t}=e;return(0,s.yg)(Mp,(0,p.A)({},Dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional information about the log."))}Xp.isMDXComponent=!0;const _p={toc:[]},wp="wrapper";function Tp(e){let{components:n,...t}=e;return(0,s.yg)(wp,(0,p.A)({},_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded.\nThe current stack trace can be obtained using ",(0,s.yg)("inlineCode",{parentName:"p"},"new Error().stack"),".\nBoth Chromium and Firefox stack traces are supported."))}Tp.isMDXComponent=!0;const Cp={toc:[]},xp="wrapper";function Ap(e){let{components:n,...t}=e;return(0,s.yg)(xp,(0,p.A)({},Cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace of the log."))}Ap.isMDXComponent=!0;const vp={toc:[]},Lp="wrapper";function bp(e){let{components:n,...t}=e;return(0,s.yg)(Lp,(0,p.A)({},vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/media#audio"},"https://motioncanvas.io/docs/media#audio")))}bp.isMDXComponent=!0;const Np={toc:[]},kp="wrapper";function zp(e){let{components:n,...t}=e;return(0,s.yg)(kp,(0,p.A)({},Np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An url for the audio track to play alongside the animation."))}zp.isMDXComponent=!0;const Pp={toc:[]},Ip="wrapper";function Rp(e){let{components:n,...t}=e;return(0,s.yg)(Ip,(0,p.A)({},Pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Rp.isMDXComponent=!0;const Wp={toc:[]},Sp="wrapper";function Bp(e){let{components:n,...t}=e;return(0,s.yg)(Sp,(0,p.A)({},Wp,t,{components:n,mdxType:"MDXLayout"}))}Bp.isMDXComponent=!0;const Gp={toc:[]},Ep="wrapper";function Op(e){let{components:n,...t}=e;return(0,s.yg)(Ep,(0,p.A)({},Gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/experimental"},"https://motioncanvas.io/docs/experimental")))}Op.isMDXComponent=!0;const Up={toc:[]},Fp="wrapper";function Vp(e){let{components:n,...t}=e;return(0,s.yg)(Fp,(0,p.A)({},Up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enable experimental features."))}Vp.isMDXComponent=!0;const qp={toc:[]},jp="wrapper";function Hp(e){let{components:n,...t}=e;return(0,s.yg)(jp,(0,p.A)({},qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A custom logger instance to use."))}Hp.isMDXComponent=!0;const Yp={toc:[]},Qp="wrapper";function $p(e){let{components:n,...t}=e;return(0,s.yg)(Qp,(0,p.A)({},Yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the project."))}$p.isMDXComponent=!0;const Kp={toc:[]},Jp="wrapper";function Zp(e){let{components:n,...t}=e;return(0,s.yg)(Jp,(0,p.A)({},Kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When a string is provided, the plugin will be imported dynamically using\nthe string as the module specifier. This is the preferred way to include\neditor plugins because it makes sure that the plugin's source code gets\nexcluded from the production build."))}Zp.isMDXComponent=!0;const er={toc:[]},nr="wrapper";function tr(e){let{components:n,...t}=e;return(0,s.yg)(nr,(0,p.A)({},er,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}tr.isMDXComponent=!0;const or={toc:[]},pr="wrapper";function rr(e){let{components:n,...t}=e;return(0,s.yg)(pr,(0,p.A)({},or,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A full scene description can be obtained by loading a scene module with a\n",(0,s.yg)("inlineCode",{parentName:"p"},"?scene")," query parameter."))}rr.isMDXComponent=!0;const sr={toc:[]},cr="wrapper";function ar(e){let{components:n,...t}=e;return(0,s.yg)(cr,(0,p.A)({},sr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"import exampleScene from './example?scene';\n\nexport default makeProject({\n  scenes: [exampleScene],\n});\n")))}ar.isMDXComponent=!0;const ir={toc:[]},lr="wrapper";function ur(e){let{components:n,...t}=e;return(0,s.yg)(lr,(0,p.A)({},ir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of scene descriptions that make up the project."))}ur.isMDXComponent=!0;const mr={toc:[]},yr="wrapper";function dr(e){let{components:n,...t}=e;return(0,s.yg)(yr,(0,p.A)({},mr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/project-variables"},"https://motioncanvas.io/docs/project-variables")))}dr.isMDXComponent=!0;const hr={toc:[]},gr="wrapper";function fr(e){let{components:n,...t}=e;return(0,s.yg)(gr,(0,p.A)({},hr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default values for project variables."))}fr.isMDXComponent=!0;const Dr={toc:[]},Mr="wrapper";function Xr(e){let{components:n,...t}=e;return(0,s.yg)(Mr,(0,p.A)({},Dr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A runtime representation of the settings metadata."))}Xr.isMDXComponent=!0;const _r={toc:[]},wr="wrapper";function Tr(e){let{components:n,...t}=e;return(0,s.yg)(wr,(0,p.A)({},_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a runtime representation of the settings metadata."))}Tr.isMDXComponent=!0;const Cr={toc:[]},xr="wrapper";function Ar(e){let{components:n,...t}=e;return(0,s.yg)(xr,(0,p.A)({},Cr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Property decorators."))}Ar.isMDXComponent=!0;const vr={toc:[]},Lr="wrapper";function br(e){let{components:n,...t}=e;return(0,s.yg)(Lr,(0,p.A)({},vr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.yg)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}br.isMDXComponent=!0;const Nr={toc:[]},kr="wrapper";function zr(e){let{components:n,...t}=e;return(0,s.yg)(kr,(0,p.A)({},Nr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a lazy decorator."))}zr.isMDXComponent=!0;const Pr={toc:[]},Ir="wrapper";function Rr(e){let{components:n,...t}=e;return(0,s.yg)(Ir,(0,p.A)({},Pr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns the value of this property."))}Rr.isMDXComponent=!0;const Wr={toc:[]},Sr="wrapper";function Br(e){let{components:n,...t}=e;return(0,s.yg)(Sr,(0,p.A)({},Wr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscriptions and triggering of events."))}Br.isMDXComponent=!0;const Gr={toc:[]},Er="wrapper";function Or(e){let{components:n,...t}=e;return(0,s.yg)(Er,(0,p.A)({},Gr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.yg)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}Or.isMDXComponent=!0;const Ur={toc:[]},Fr="wrapper";function Vr(e){let{components:n,...t}=e;return(0,s.yg)(Fr,(0,p.A)({},Ur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}Vr.isMDXComponent=!0;const qr={toc:[]},jr="wrapper";function Hr(e){let{components:n,...t}=e;return(0,s.yg)(jr,(0,p.A)({},qr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches an asynchronous ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Hr.isMDXComponent=!0;const Yr={toc:[]},Qr="wrapper";function $r(e){let{components:n,...t}=e;return(0,s.yg)(Qr,(0,p.A)({},Yr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}$r.isMDXComponent=!0;const Kr={toc:[]},Jr="wrapper";function Zr(e){let{components:n,...t}=e;return(0,s.yg)(Jr,(0,p.A)({},Kr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Zr.isMDXComponent=!0;const es={toc:[]},ns="wrapper";function ts(e){let{components:n,...t}=e;return(0,s.yg)(ns,(0,p.A)({},es,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}ts.isMDXComponent=!0;const os={toc:[]},ps="wrapper";function rs(e){let{components:n,...t}=e;return(0,s.yg)(ps,(0,p.A)({},os,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}rs.isMDXComponent=!0;const ss={toc:[]},cs="wrapper";function as(e){let{components:n,...t}=e;return(0,s.yg)(cs,(0,p.A)({},ss,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}as.isMDXComponent=!0;const is={toc:[]},ls="wrapper";function us(e){let{components:n,...t}=e;return(0,s.yg)(ls,(0,p.A)({},is,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}us.isMDXComponent=!0;const ms={toc:[]},ys="wrapper";function ds(e){let{components:n,...t}=e;return(0,s.yg)(ys,(0,p.A)({},ms,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}ds.isMDXComponent=!0;const hs={toc:[]},gs="wrapper";function fs(e){let{components:n,...t}=e;return(0,s.yg)(gs,(0,p.A)({},hs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}fs.isMDXComponent=!0;const Ds={toc:[]},Ms="wrapper";function Xs(e){let{components:n,...t}=e;return(0,s.yg)(Ms,(0,p.A)({},Ds,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Xs.isMDXComponent=!0;const _s={toc:[]},ws="wrapper";function Ts(e){let{components:n,...t}=e;return(0,s.yg)(ws,(0,p.A)({},_s,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Ts.isMDXComponent=!0;const Cs={toc:[]},xs="wrapper";function As(e){let{components:n,...t}=e;return(0,s.yg)(xs,(0,p.A)({},Cs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}As.isMDXComponent=!0;const vs={toc:[]},Ls="wrapper";function bs(e){let{components:n,...t}=e;return(0,s.yg)(Ls,(0,p.A)({},vs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}bs.isMDXComponent=!0;const Ns={toc:[]},ks="wrapper";function zs(e){let{components:n,...t}=e;return(0,s.yg)(ks,(0,p.A)({},Ns,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}zs.isMDXComponent=!0;const Ps={toc:[]},Is="wrapper";function Rs(e){let{components:n,...t}=e;return(0,s.yg)(Is,(0,p.A)({},Ps,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Rs.isMDXComponent=!0;const Ws={toc:[]},Ss="wrapper";function Bs(e){let{components:n,...t}=e;return(0,s.yg)(Ss,(0,p.A)({},Ws,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Bs.isMDXComponent=!0;const Gs={toc:[]},Es="wrapper";function Os(e){let{components:n,...t}=e;return(0,s.yg)(Es,(0,p.A)({},Gs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value argument to subscribers."))}Os.isMDXComponent=!0;const Us={toc:[]},Fs="wrapper";function Vs(e){let{components:n,...t}=e;return(0,s.yg)(Fs,(0,p.A)({},Us,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A base for dispatching ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.yg)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Vs.isMDXComponent=!0;const qs={toc:[]},js="wrapper";function Hs(e){let{components:n,...t}=e;return(0,s.yg)(js,(0,p.A)({},qs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Hs.isMDXComponent=!0;const Ys={toc:[]},Qs="wrapper";function $s(e){let{components:n,...t}=e;return(0,s.yg)(Qs,(0,p.A)({},Ys,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}$s.isMDXComponent=!0;const Ks={toc:[]},Js="wrapper";function Zs(e){let{components:n,...t}=e;return(0,s.yg)(Js,(0,p.A)({},Ks,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}Zs.isMDXComponent=!0;const ec={toc:[]},nc="wrapper";function tc(e){let{components:n,...t}=e;return(0,s.yg)(nc,(0,p.A)({},ec,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}tc.isMDXComponent=!0;const oc={toc:[]},pc="wrapper";function rc(e){let{components:n,...t}=e;return(0,s.yg)(pc,(0,p.A)({},oc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}rc.isMDXComponent=!0;const sc={toc:[]},cc="wrapper";function ac(e){let{components:n,...t}=e;return(0,s.yg)(cc,(0,p.A)({},sc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}ac.isMDXComponent=!0;const ic={toc:[]},lc="wrapper";function uc(e){let{components:n,...t}=e;return(0,s.yg)(lc,(0,p.A)({},ic,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}uc.isMDXComponent=!0;const mc={toc:[]},yc="wrapper";function dc(e){let{components:n,...t}=e;return(0,s.yg)(yc,(0,p.A)({},mc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the callback function."))}dc.isMDXComponent=!0;const hc={toc:[]},gc="wrapper";function fc(e){let{components:n,...t}=e;return(0,s.yg)(gc,(0,p.A)({},hc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.yg)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.yg)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}fc.isMDXComponent=!0;const Dc={toc:[]},Mc="wrapper";function Xc(e){let{components:n,...t}=e;return(0,s.yg)(Mc,(0,p.A)({},Dc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}Xc.isMDXComponent=!0;const _c={toc:[]},wc="wrapper";function Tc(e){let{components:n,...t}=e;return(0,s.yg)(wc,(0,p.A)({},_c,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}Tc.isMDXComponent=!0;const Cc={toc:[]},xc="wrapper";function Ac(e){let{components:n,...t}=e;return(0,s.yg)(xc,(0,p.A)({},Cc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Ac.isMDXComponent=!0;const vc={toc:[]},Lc="wrapper";function bc(e){let{components:n,...t}=e;return(0,s.yg)(Lc,(0,p.A)({},vc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Are subscribers being notified?"))}bc.isMDXComponent=!0;const Nc={toc:[]},kc="wrapper";function zc(e){let{components:n,...t}=e;return(0,s.yg)(kc,(0,p.A)({},Nc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Notify all current and future subscribers."))}zc.isMDXComponent=!0;const Pc={toc:[]},Ic="wrapper";function Rc(e){let{components:n,...t}=e;return(0,s.yg)(Ic,(0,p.A)({},Pc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Stop notifying future subscribers."))}Rc.isMDXComponent=!0;const Wc={toc:[]},Sc="wrapper";function Bc(e){let{components:n,...t}=e;return(0,s.yg)(Sc,(0,p.A)({},Wc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Bc.isMDXComponent=!0;const Gc={toc:[]},Ec="wrapper";function Oc(e){let{components:n,...t}=e;return(0,s.yg)(Ec,(0,p.A)({},Gc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}Oc.isMDXComponent=!0;const Uc={toc:[]},Fc="wrapper";function Vc(e){let{components:n,...t}=e;return(0,s.yg)(Fc,(0,p.A)({},Uc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Vc.isMDXComponent=!0;const qc={toc:[]},jc="wrapper";function Hc(e){let{components:n,...t}=e;return(0,s.yg)(jc,(0,p.A)({},qc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Hc.isMDXComponent=!0;const Yc={toc:[]},Qc="wrapper";function $c(e){let{components:n,...t}=e;return(0,s.yg)(Qc,(0,p.A)({},Yc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}$c.isMDXComponent=!0;const Kc={toc:[]},Jc="wrapper";function Zc(e){let{components:n,...t}=e;return(0,s.yg)(Jc,(0,p.A)({},Kc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Zc.isMDXComponent=!0;const ea={toc:[]},na="wrapper";function ta(e){let{components:n,...t}=e;return(0,s.yg)(na,(0,p.A)({},ea,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.yg)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}ta.isMDXComponent=!0;const oa={toc:[]},pa="wrapper";function ra(e){let{components:n,...t}=e;return(0,s.yg)(pa,(0,p.A)({},oa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}ra.isMDXComponent=!0;const sa={toc:[]},ca="wrapper";function aa(e){let{components:n,...t}=e;return(0,s.yg)(ca,(0,p.A)({},sa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}aa.isMDXComponent=!0;const ia={toc:[]},la="wrapper";function ua(e){let{components:n,...t}=e;return(0,s.yg)(la,(0,p.A)({},ia,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}ua.isMDXComponent=!0;const ma={toc:[]},ya="wrapper";function da(e){let{components:n,...t}=e;return(0,s.yg)(ya,(0,p.A)({},ma,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}da.isMDXComponent=!0;const ha={toc:[]},ga="wrapper";function fa(e){let{components:n,...t}=e;return(0,s.yg)(ga,(0,p.A)({},ha,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}fa.isMDXComponent=!0;const Da={toc:[]},Ma="wrapper";function Xa(e){let{components:n,...t}=e;return(0,s.yg)(Ma,(0,p.A)({},Da,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}Xa.isMDXComponent=!0;const _a={toc:[]},wa="wrapper";function Ta(e){let{components:n,...t}=e;return(0,s.yg)(wa,(0,p.A)({},_a,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the callback function."))}Ta.isMDXComponent=!0;const Ca={toc:[]},xa="wrapper";function Aa(e){let{components:n,...t}=e;return(0,s.yg)(xa,(0,p.A)({},Ca,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Aa.isMDXComponent=!0;const va={toc:[]},La="wrapper";function ba(e){let{components:n,...t}=e;return(0,s.yg)(La,(0,p.A)({},va,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}ba.isMDXComponent=!0;const Na={toc:[]},ka="wrapper";function za(e){let{components:n,...t}=e;return(0,s.yg)(ka,(0,p.A)({},Na,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the most recent value of this dispatcher."))}za.isMDXComponent=!0;const Pa={toc:[]},Ia="wrapper";function Ra(e){let{components:n,...t}=e;return(0,s.yg)(Ia,(0,p.A)({},Pa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}Ra.isMDXComponent=!0;const Wa={toc:[]},Sa="wrapper";function Ba(e){let{components:n,...t}=e;return(0,s.yg)(Sa,(0,p.A)({},Wa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ba.isMDXComponent=!0;const Ga={toc:[]},Ea="wrapper";function Oa(e){let{components:n,...t}=e;return(0,s.yg)(Ea,(0,p.A)({},Ga,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Oa.isMDXComponent=!0;const Ua={toc:[]},Fa="wrapper";function Va(e){let{components:n,...t}=e;return(0,s.yg)(Fa,(0,p.A)({},Ua,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Va.isMDXComponent=!0;const qa={toc:[]},ja="wrapper";function Ha(e){let{components:n,...t}=e;return(0,s.yg)(ja,(0,p.A)({},qa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}Ha.isMDXComponent=!0;const Ya={toc:[]},Qa="wrapper";function $a(e){let{components:n,...t}=e;return(0,s.yg)(Qa,(0,p.A)({},Ya,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}$a.isMDXComponent=!0;const Ka={toc:[]},Ja="wrapper";function Za(e){let{components:n,...t}=e;return(0,s.yg)(Ja,(0,p.A)({},Ka,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Za.isMDXComponent=!0;const ei={toc:[]},ni="wrapper";function ti(e){let{components:n,...t}=e;return(0,s.yg)(ni,(0,p.A)({},ei,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}ti.isMDXComponent=!0;const oi={toc:[]},pi="wrapper";function ri(e){let{components:n,...t}=e;return(0,s.yg)(pi,(0,p.A)({},oi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value passed to subscribers."))}ri.isMDXComponent=!0;const si={toc:[]},ci="wrapper";function ai(e){let{components:n,...t}=e;return(0,s.yg)(ci,(0,p.A)({},si,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}ai.isMDXComponent=!0;const ii={toc:[]},li="wrapper";function ui(e){let{components:n,...t}=e;return(0,s.yg)(li,(0,p.A)({},ii,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}ui.isMDXComponent=!0;const mi={toc:[]},yi="wrapper";function di(e){let{components:n,...t}=e;return(0,s.yg)(yi,(0,p.A)({},mi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}di.isMDXComponent=!0;const hi={toc:[]},gi="wrapper";function fi(e){let{components:n,...t}=e;return(0,s.yg)(gi,(0,p.A)({},hi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value."))}fi.isMDXComponent=!0;const Di={toc:[]},Mi="wrapper";function Xi(e){let{components:n,...t}=e;return(0,s.yg)(Mi,(0,p.A)({},Di,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the most recent value of this dispatcher."))}Xi.isMDXComponent=!0;const _i={toc:[]},wi="wrapper";function Ti(e){let{components:n,...t}=e;return(0,s.yg)(wi,(0,p.A)({},_i,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Setting the value will immediately notify all subscribers."))}Ti.isMDXComponent=!0;const Ci={toc:[]},xi="wrapper";function Ai(e){let{components:n,...t}=e;return(0,s.yg)(xi,(0,p.A)({},Ci,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value of this dispatcher."))}Ai.isMDXComponent=!0;const vi={toc:[]},Li="wrapper";function bi(e){let{components:n,...t}=e;return(0,s.yg)(Li,(0,p.A)({},vi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}bi.isMDXComponent=!0;const Ni={toc:[]},ki="wrapper";function zi(e){let{components:n,...t}=e;return(0,s.yg)(ki,(0,p.A)({},Ni,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}zi.isMDXComponent=!0;const Pi={toc:[]},Ii="wrapper";function Ri(e){let{components:n,...t}=e;return(0,s.yg)(Ii,(0,p.A)({},Pi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}Ri.isMDXComponent=!0;const Wi={toc:[]},Si="wrapper";function Bi(e){let{components:n,...t}=e;return(0,s.yg)(Si,(0,p.A)({},Wi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Bi.isMDXComponent=!0;const Gi={toc:[]},Ei="wrapper";function Oi(e){let{components:n,...t}=e;return(0,s.yg)(Ei,(0,p.A)({},Gi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Oi.isMDXComponent=!0;const Ui={toc:[]},Fi="wrapper";function Vi(e){let{components:n,...t}=e;return(0,s.yg)(Fi,(0,p.A)({},Ui,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Vi.isMDXComponent=!0;const qi={toc:[]},ji="wrapper";function Hi(e){let{components:n,...t}=e;return(0,s.yg)(ji,(0,p.A)({},qi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Hi.isMDXComponent=!0;const Yi={toc:[]},Qi="wrapper";function $i(e){let{components:n,...t}=e;return(0,s.yg)(Qi,(0,p.A)({},Yi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}$i.isMDXComponent=!0;const Ki={toc:[]},Ji="wrapper";function Zi(e){let{components:n,...t}=e;return(0,s.yg)(Ji,(0,p.A)({},Ki,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value passed to subscribers."))}Zi.isMDXComponent=!0;const el={toc:[]},nl="wrapper";function tl(e){let{components:n,...t}=e;return(0,s.yg)(nl,(0,p.A)({},el,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}tl.isMDXComponent=!0;const ol={toc:[]},pl="wrapper";function rl(e){let{components:n,...t}=e;return(0,s.yg)(pl,(0,p.A)({},ol,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}rl.isMDXComponent=!0;const sl={toc:[]},cl="wrapper";function al(e){let{components:n,...t}=e;return(0,s.yg)(cl,(0,p.A)({},sl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}al.isMDXComponent=!0;const il={toc:[]},ll="wrapper";function ul(e){let{components:n,...t}=e;return(0,s.yg)(ll,(0,p.A)({},il,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ul.isMDXComponent=!0;const ml={toc:[]},yl="wrapper";function dl(e){let{components:n,...t}=e;return(0,s.yg)(yl,(0,p.A)({},ml,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}dl.isMDXComponent=!0;const hl={toc:[]},gl="wrapper";function fl(e){let{components:n,...t}=e;return(0,s.yg)(gl,(0,p.A)({},hl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}fl.isMDXComponent=!0;const Dl={toc:[]},Ml="wrapper";function Xl(e){let{components:n,...t}=e;return(0,s.yg)(Ml,(0,p.A)({},Dl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Xl.isMDXComponent=!0;const _l={toc:[]},wl="wrapper";function Tl(e){let{components:n,...t}=e;return(0,s.yg)(wl,(0,p.A)({},_l,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}Tl.isMDXComponent=!0;const Cl={toc:[]},xl="wrapper";function Al(e){let{components:n,...t}=e;return(0,s.yg)(xl,(0,p.A)({},Cl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Utilities for controlling the flow and timing of an animation."))}Al.isMDXComponent=!0;const vl={toc:[]},Ll="wrapper";function bl(e){let{components:n,...t}=e;return(0,s.yg)(Ll,(0,p.A)({},vl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback called by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow/EveryTimer"},(0,s.yg)("inlineCode",{parentName:"a"},"EveryTimer"))," every N seconds."))}bl.isMDXComponent=!0;const Nl={toc:[]},kl="wrapper";function zl(e){let{components:n,...t}=e;return(0,s.yg)(kl,(0,p.A)({},Nl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The amount of times the timer has ticked."))}zl.isMDXComponent=!0;const Pl={toc:[]},Il="wrapper";function Rl(e){let{components:n,...t}=e;return(0,s.yg)(Il,(0,p.A)({},Pl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator responsible for running this timer."))}Rl.isMDXComponent=!0;const Wl={toc:[]},Sl="wrapper";function Bl(e){let{components:n,...t}=e;return(0,s.yg)(Sl,(0,p.A)({},Wl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait until the timer ticks."))}Bl.isMDXComponent=!0;const Gl={toc:[]},El="wrapper";function Ol(e){let{components:n,...t}=e;return(0,s.yg)(El,(0,p.A)({},Gl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback called by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#loop"},(0,s.yg)("inlineCode",{parentName:"a"},"loop"))," during each iteration."))}Ol.isMDXComponent=!0;const Ul={toc:[]},Fl="wrapper";function Vl(e){let{components:n,...t}=e;return(0,s.yg)(Fl,(0,p.A)({},Ul,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current iteration index."))}Vl.isMDXComponent=!0;const ql={toc:[]},jl="wrapper";function Hl(e){let{components:n,...t}=e;return(0,s.yg)(jl,(0,p.A)({},ql,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Hl.isMDXComponent=!0;const Yl={toc:[]},Ql="wrapper";function $l(e){let{components:n,...t}=e;return(0,s.yg)(Ql,(0,p.A)({},Yl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}$l.isMDXComponent=!0;const Kl={toc:[]},Jl="wrapper";function Zl(e){let{components:n,...t}=e;return(0,s.yg)(Jl,(0,p.A)({},Kl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}Zl.isMDXComponent=!0;const eu={toc:[]},nu="wrapper";function tu(e){let{components:n,...t}=e;return(0,s.yg)(nu,(0,p.A)({},eu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}tu.isMDXComponent=!0;const ou={toc:[]},pu="wrapper";function ru(e){let{components:n,...t}=e;return(0,s.yg)(pu,(0,p.A)({},ou,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}ru.isMDXComponent=!0;const su={toc:[]},cu="wrapper";function au(e){let{components:n,...t}=e;return(0,s.yg)(cu,(0,p.A)({},su,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}au.isMDXComponent=!0;const iu={toc:[]},lu="wrapper";function uu(e){let{components:n,...t}=e;return(0,s.yg)(lu,(0,p.A)({},iu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.yg)("p",null,"Note that the same animation can be written as:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.yg)("p",null,"The reason ",(0,s.yg)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}uu.isMDXComponent=!0;const mu={toc:[]},yu="wrapper";function du(e){let{components:n,...t}=e;return(0,s.yg)(yu,(0,p.A)({},mu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run tasks one after another."))}du.isMDXComponent=!0;const hu={toc:[]},gu="wrapper";function fu(e){let{components:n,...t}=e;return(0,s.yg)(gu,(0,p.A)({},hu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}fu.isMDXComponent=!0;const Du={toc:[]},Mu="wrapper";function Xu(e){let{components:n,...t}=e;return(0,s.yg)(Mu,(0,p.A)({},Du,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.yg)("p",null,"Note that the same animation can be written as:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.yg)("p",null,"The reason ",(0,s.yg)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Xu.isMDXComponent=!0;const _u={toc:[]},wu="wrapper";function Tu(e){let{components:n,...t}=e;return(0,s.yg)(wu,(0,p.A)({},_u,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator or callback after a specific amount of time."))}Tu.isMDXComponent=!0;const Cu={toc:[]},xu="wrapper";function Au(e){let{components:n,...t}=e;return(0,s.yg)(xu,(0,p.A)({},Cu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delay in seconds"))}Au.isMDXComponent=!0;const vu={toc:[]},Lu="wrapper";function bu(e){let{components:n,...t}=e;return(0,s.yg)(Lu,(0,p.A)({},vu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task or callback to run after the delay."))}bu.isMDXComponent=!0;const Nu={toc:[]},ku="wrapper";function zu(e){let{components:n,...t}=e;return(0,s.yg)(ku,(0,p.A)({},Nu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}zu.isMDXComponent=!0;const Pu={toc:[]},Iu="wrapper";function Ru(e){let{components:n,...t}=e;return(0,s.yg)(Iu,(0,p.A)({},Pu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Call the given callback every N seconds."))}Ru.isMDXComponent=!0;const Wu={toc:[]},Su="wrapper";function Bu(e){let{components:n,...t}=e;return(0,s.yg)(Su,(0,p.A)({},Wu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interval between subsequent calls."))}Bu.isMDXComponent=!0;const Gu={toc:[]},Eu="wrapper";function Ou(e){let{components:n,...t}=e;return(0,s.yg)(Eu,(0,p.A)({},Gu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to be called."))}Ou.isMDXComponent=!0;const Uu={toc:[]},Fu="wrapper";function Vu(e){let{components:n,...t}=e;return(0,s.yg)(Fu,(0,p.A)({},Uu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each iteration waits until the previous one is completed.\nBecause this loop never finishes it cannot be used in the main thread.\nInstead, use ",(0,s.yg)("inlineCode",{parentName:"p"},"yield")," or ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," to run the loop concurrently."))}Vu.isMDXComponent=!0;const qu={toc:[]},ju="wrapper";function Hu(e){let{components:n,...t}=e;return(0,s.yg)(ju,(0,p.A)({},qu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotate the ",(0,s.yg)("inlineCode",{parentName:"p"},"rect")," indefinitely:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield loop(\n  () => rect.rotation(0).rotation(360, 2, linear),\n);\n")))}Hu.isMDXComponent=!0;const Yu={toc:[]},Qu="wrapper";function $u(e){let{components:n,...t}=e;return(0,s.yg)(Qu,(0,p.A)({},Yu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator in a loop."))}$u.isMDXComponent=!0;const Ku={toc:[]},Ju="wrapper";function Zu(e){let{components:n,...t}=e;return(0,s.yg)(Ju,(0,p.A)({},Ku,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Zu.isMDXComponent=!0;const em={toc:[]},nm="wrapper";function tm(e){let{components:n,...t}=e;return(0,s.yg)(nm,(0,p.A)({},em,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each iteration waits until the previous one is completed."))}tm.isMDXComponent=!0;const om={toc:[]},pm="wrapper";function rm(e){let{components:n,...t}=e;return(0,s.yg)(pm,(0,p.A)({},om,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}rm.isMDXComponent=!0;const sm={toc:[]},cm="wrapper";function am(e){let{components:n,...t}=e;return(0,s.yg)(cm,(0,p.A)({},sm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator N times."))}am.isMDXComponent=!0;const im={toc:[]},lm="wrapper";function um(e){let{components:n,...t}=e;return(0,s.yg)(lm,(0,p.A)({},im,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of iterations."))}um.isMDXComponent=!0;const mm={toc:[]},ym="wrapper";function dm(e){let{components:n,...t}=e;return(0,s.yg)(ym,(0,p.A)({},mm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}dm.isMDXComponent=!0;const hm={toc:[]},gm="wrapper";function fm(e){let{components:n,...t}=e;return(0,s.yg)(gm,(0,p.A)({},hm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}fm.isMDXComponent=!0;const Dm={toc:[]},Mm="wrapper";function Xm(e){let{components:n,...t}=e;return(0,s.yg)(Mm,(0,p.A)({},Dm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Xm.isMDXComponent=!0;const _m={toc:[]},wm="wrapper";function Tm(e){let{components:n,...t}=e;return(0,s.yg)(wm,(0,p.A)({},_m,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run a generator in a loop for the given amount of time."))}Tm.isMDXComponent=!0;const Cm={toc:[]},xm="wrapper";function Am(e){let{components:n,...t}=e;return(0,s.yg)(xm,(0,p.A)({},Cm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration in seconds."))}Am.isMDXComponent=!0;const vm={toc:[]},Lm="wrapper";function bm(e){let{components:n,...t}=e;return(0,s.yg)(Lm,(0,p.A)({},vm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}bm.isMDXComponent=!0;const Nm={toc:[]},km="wrapper";function zm(e){let{components:n,...t}=e;return(0,s.yg)(km,(0,p.A)({},Nm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}zm.isMDXComponent=!0;const Pm={toc:[]},Im="wrapper";function Rm(e){let{components:n,...t}=e;return(0,s.yg)(Im,(0,p.A)({},Pm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Rm.isMDXComponent=!0;const Wm={toc:[]},Sm="wrapper";function Bm(e){let{components:n,...t}=e;return(0,s.yg)(Sm,(0,p.A)({},Wm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run a generator in a loop until the given time event."))}Bm.isMDXComponent=!0;const Gm={toc:[]},Em="wrapper";function Om(e){let{components:n,...t}=e;return(0,s.yg)(Em,(0,p.A)({},Gm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The event."))}Om.isMDXComponent=!0;const Um={toc:[]},Fm="wrapper";function Vm(e){let{components:n,...t}=e;return(0,s.yg)(Fm,(0,p.A)({},Um,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Vm.isMDXComponent=!0;const qm={toc:[]},jm="wrapper";function Hm(e){let{components:n,...t}=e;return(0,s.yg)(jm,(0,p.A)({},qm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Do nothing."))}Hm.isMDXComponent=!0;const Ym={toc:[]},Qm="wrapper";function $m(e){let{components:n,...t}=e;return(0,s.yg)(Qm,(0,p.A)({},Ym,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}$m.isMDXComponent=!0;const Km={toc:[]},Jm="wrapper";function Zm(e){let{components:n,...t}=e;return(0,s.yg)(Jm,(0,p.A)({},Km,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}Zm.isMDXComponent=!0;const ey={toc:[]},ny="wrapper";function ty(e){let{components:n,...t}=e;return(0,s.yg)(ny,(0,p.A)({},ey,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Turn the given generator function into a task."))}ty.isMDXComponent=!0;const oy={toc:[]},py="wrapper";function ry(e){let{components:n,...t}=e;return(0,s.yg)(py,(0,p.A)({},oy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a factory that creates the generator."))}ry.isMDXComponent=!0;const sy={toc:[]},cy="wrapper";function ay(e){let{components:n,...t}=e;return(0,s.yg)(cy,(0,p.A)({},sy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}ay.isMDXComponent=!0;const iy={toc:[]},ly="wrapper";function uy(e){let{components:n,...t}=e;return(0,s.yg)(ly,(0,p.A)({},iy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}uy.isMDXComponent=!0;const my={toc:[]},yy="wrapper";function dy(e){let{components:n,...t}=e;return(0,s.yg)(yy,(0,p.A)({},my,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Turn the given generator function into a task."))}dy.isMDXComponent=!0;const hy={toc:[]},gy="wrapper";function fy(e){let{components:n,...t}=e;return(0,s.yg)(gy,(0,p.A)({},hy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional name used when displaying this generator in the UI."))}fy.isMDXComponent=!0;const Dy={toc:[]},My="wrapper";function Xy(e){let{components:n,...t}=e;return(0,s.yg)(My,(0,p.A)({},Dy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a factory that creates the generator."))}Xy.isMDXComponent=!0;const _y={toc:[]},wy="wrapper";function Ty(e){let{components:n,...t}=e;return(0,s.yg)(wy,(0,p.A)({},_y,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ty.isMDXComponent=!0;const Cy={toc:[]},xy="wrapper";function Ay(e){let{components:n,...t}=e;return(0,s.yg)(xy,(0,p.A)({},Cy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ay.isMDXComponent=!0;const vy={toc:[]},Ly="wrapper";function by(e){let{components:n,...t}=e;return(0,s.yg)(Ly,(0,p.A)({},vy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Start all tasks one after another with a constant delay between."))}by.isMDXComponent=!0;const Ny={toc:[]},ky="wrapper";function zy(e){let{components:n,...t}=e;return(0,s.yg)(ky,(0,p.A)({},Ny,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delay between each of the tasks."))}zy.isMDXComponent=!0;const Py={toc:[]},Iy="wrapper";function Ry(e){let{components:n,...t}=e;return(0,s.yg)(Iy,(0,p.A)({},Py,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to be run in a sequence."))}Ry.isMDXComponent=!0;const Wy={toc:[]},Sy="wrapper";function By(e){let{components:n,...t}=e;return(0,s.yg)(Sy,(0,p.A)({},Wy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}By.isMDXComponent=!0;const Gy={toc:[]},Ey="wrapper";function Oy(e){let{components:n,...t}=e;return(0,s.yg)(Ey,(0,p.A)({},Gy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for the given amount of time."))}Oy.isMDXComponent=!0;const Uy={toc:[]},Fy="wrapper";function Vy(e){let{components:n,...t}=e;return(0,s.yg)(Fy,(0,p.A)({},Uy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The relative time in seconds."))}Vy.isMDXComponent=!0;const qy={toc:[]},jy="wrapper";function Hy(e){let{components:n,...t}=e;return(0,s.yg)(jy,(0,p.A)({},qy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional task to be run after the function completes."))}Hy.isMDXComponent=!0;const Yy={toc:[]},Qy="wrapper";function $y(e){let{components:n,...t}=e;return(0,s.yg)(Qy,(0,p.A)({},Yy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}$y.isMDXComponent=!0;const Ky={toc:[]},Jy="wrapper";function Zy(e){let{components:n,...t}=e;return(0,s.yg)(Jy,(0,p.A)({},Ky,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}Zy.isMDXComponent=!0;const ed={toc:[]},nd="wrapper";function td(e){let{components:n,...t}=e;return(0,s.yg)(nd,(0,p.A)({},ed,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait until the given time event."))}td.isMDXComponent=!0;const od={toc:[]},pd="wrapper";function rd(e){let{components:n,...t}=e;return(0,s.yg)(pd,(0,p.A)({},od,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the time event."))}rd.isMDXComponent=!0;const sd={toc:[]},cd="wrapper";function ad(e){let{components:n,...t}=e;return(0,s.yg)(cd,(0,p.A)({},sd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional task to be run after the function completes."))}ad.isMDXComponent=!0;const id={toc:[]},ld="wrapper";function ud(e){let{components:n,...t}=e;return(0,s.yg)(ld,(0,p.A)({},id,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Multi-media management."))}ud.isMDXComponent=!0;const md={toc:[]},yd="wrapper";function dd(e){let{components:n,...t}=e;return(0,s.yg)(yd,(0,p.A)({},md,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}dd.isMDXComponent=!0;const hd={toc:[]},gd="wrapper";function fd(e){let{components:n,...t}=e;return(0,s.yg)(gd,(0,p.A)({},hd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause/resume the audio."))}fd.isMDXComponent=!0;const Dd={toc:[]},Md="wrapper";function Xd(e){let{components:n,...t}=e;return(0,s.yg)(Md,(0,p.A)({},Dd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the audio should be paused or resumed."))}Xd.isMDXComponent=!0;const _d={toc:[]},wd="wrapper";function Td(e){let{components:n,...t}=e;return(0,s.yg)(wd,(0,p.A)({},_d,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The absolute biggest value from the peaks array."))}Td.isMDXComponent=!0;const Cd={toc:[]},xd="wrapper";function Ad(e){let{components:n,...t}=e;return(0,s.yg)(xd,(0,p.A)({},Cd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The amount of samples taken."))}Ad.isMDXComponent=!0;const vd={toc:[]},Ld="wrapper";function bd(e){let{components:n,...t}=e;return(0,s.yg)(Ld,(0,p.A)({},vd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}bd.isMDXComponent=!0;const Nd={toc:[]},kd="wrapper";function zd(e){let{components:n,...t}=e;return(0,s.yg)(kd,(0,p.A)({},Nd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Samples per seconds."))}zd.isMDXComponent=!0;const Pd={toc:[]},Id="wrapper";function Rd(e){let{components:n,...t}=e;return(0,s.yg)(Id,(0,p.A)({},Pd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The runtime representation of meta files."))}Rd.isMDXComponent=!0;const Wd={toc:[]},Sd="wrapper";function Bd(e){let{components:n,...t}=e;return(0,s.yg)(Sd,(0,p.A)({},Wd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a boolean value stored in a meta file."))}Bd.isMDXComponent=!0;const Gd={toc:[]},Ed="wrapper";function Od(e){let{components:n,...t}=e;return(0,s.yg)(Ed,(0,p.A)({},Gd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Od.isMDXComponent=!0;const Ud={toc:[]},Fd="wrapper";function Vd(e){let{components:n,...t}=e;return(0,s.yg)(Fd,(0,p.A)({},Ud,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Vd.isMDXComponent=!0;const qd={toc:[]},jd="wrapper";function Hd(e){let{components:n,...t}=e;return(0,s.yg)(jd,(0,p.A)({},qd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Hd.isMDXComponent=!0;const Yd={toc:[]},Qd="wrapper";function $d(e){let{components:n,...t}=e;return(0,s.yg)(Qd,(0,p.A)({},Yd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}$d.isMDXComponent=!0;const Kd={toc:[]},Jd="wrapper";function Zd(e){let{components:n,...t}=e;return(0,s.yg)(Jd,(0,p.A)({},Kd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}Zd.isMDXComponent=!0;const eh={toc:[]},nh="wrapper";function th(e){let{components:n,...t}=e;return(0,s.yg)(nh,(0,p.A)({},eh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}th.isMDXComponent=!0;const oh={toc:[]},ph="wrapper";function rh(e){let{components:n,...t}=e;return(0,s.yg)(ph,(0,p.A)({},oh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}rh.isMDXComponent=!0;const sh={toc:[]},ch="wrapper";function ah(e){let{components:n,...t}=e;return(0,s.yg)(ch,(0,p.A)({},sh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}ah.isMDXComponent=!0;const ih={toc:[]},lh="wrapper";function uh(e){let{components:n,...t}=e;return(0,s.yg)(lh,(0,p.A)({},ih,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}uh.isMDXComponent=!0;const mh={toc:[]},yh="wrapper";function dh(e){let{components:n,...t}=e;return(0,s.yg)(yh,(0,p.A)({},mh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}dh.isMDXComponent=!0;const hh={toc:[]},gh="wrapper";function fh(e){let{components:n,...t}=e;return(0,s.yg)(gh,(0,p.A)({},hh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}fh.isMDXComponent=!0;const Dh={toc:[]},Mh="wrapper";function Xh(e){let{components:n,...t}=e;return(0,s.yg)(Mh,(0,p.A)({},Dh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Xh.isMDXComponent=!0;const _h={toc:[]},wh="wrapper";function Th(e){let{components:n,...t}=e;return(0,s.yg)(wh,(0,p.A)({},_h,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}Th.isMDXComponent=!0;const Ch={toc:[]},xh="wrapper";function Ah(e){let{components:n,...t}=e;return(0,s.yg)(xh,(0,p.A)({},Ch,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Ah.isMDXComponent=!0;const vh={toc:[]},Lh="wrapper";function bh(e){let{components:n,...t}=e;return(0,s.yg)(Lh,(0,p.A)({},vh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}bh.isMDXComponent=!0;const Nh={toc:[]},kh="wrapper";function zh(e){let{components:n,...t}=e;return(0,s.yg)(kh,(0,p.A)({},Nh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}zh.isMDXComponent=!0;const Ph={toc:[]},Ih="wrapper";function Rh(e){let{components:n,...t}=e;return(0,s.yg)(Ih,(0,p.A)({},Ph,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Rh.isMDXComponent=!0;const Wh={toc:[]},Sh="wrapper";function Bh(e){let{components:n,...t}=e;return(0,s.yg)(Sh,(0,p.A)({},Wh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Bh.isMDXComponent=!0;const Gh={toc:[]},Eh="wrapper";function Oh(e){let{components:n,...t}=e;return(0,s.yg)(Eh,(0,p.A)({},Gh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Oh.isMDXComponent=!0;const Uh={toc:[]},Fh="wrapper";function Vh(e){let{components:n,...t}=e;return(0,s.yg)(Fh,(0,p.A)({},Uh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Vh.isMDXComponent=!0;const qh={toc:[]},jh="wrapper";function Hh(e){let{components:n,...t}=e;return(0,s.yg)(jh,(0,p.A)({},qh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a color stored in a meta file."))}Hh.isMDXComponent=!0;const Yh={toc:[]},Qh="wrapper";function $h(e){let{components:n,...t}=e;return(0,s.yg)(Qh,(0,p.A)({},Yh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}$h.isMDXComponent=!0;const Kh={toc:[]},Jh="wrapper";function Zh(e){let{components:n,...t}=e;return(0,s.yg)(Jh,(0,p.A)({},Kh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Zh.isMDXComponent=!0;const eg={toc:[]},ng="wrapper";function tg(e){let{components:n,...t}=e;return(0,s.yg)(ng,(0,p.A)({},eg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}tg.isMDXComponent=!0;const og={toc:[]},pg="wrapper";function rg(e){let{components:n,...t}=e;return(0,s.yg)(pg,(0,p.A)({},og,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}rg.isMDXComponent=!0;const sg={toc:[]},cg="wrapper";function ag(e){let{components:n,...t}=e;return(0,s.yg)(cg,(0,p.A)({},sg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}ag.isMDXComponent=!0;const ig={toc:[]},lg="wrapper";function ug(e){let{components:n,...t}=e;return(0,s.yg)(lg,(0,p.A)({},ig,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}ug.isMDXComponent=!0;const mg={toc:[]},yg="wrapper";function dg(e){let{components:n,...t}=e;return(0,s.yg)(yg,(0,p.A)({},mg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}dg.isMDXComponent=!0;const hg={toc:[]},gg="wrapper";function fg(e){let{components:n,...t}=e;return(0,s.yg)(gg,(0,p.A)({},hg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}fg.isMDXComponent=!0;const Dg={toc:[]},Mg="wrapper";function Xg(e){let{components:n,...t}=e;return(0,s.yg)(Mg,(0,p.A)({},Dg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}Xg.isMDXComponent=!0;const _g={toc:[]},wg="wrapper";function Tg(e){let{components:n,...t}=e;return(0,s.yg)(wg,(0,p.A)({},_g,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}Tg.isMDXComponent=!0;const Cg={toc:[]},xg="wrapper";function Ag(e){let{components:n,...t}=e;return(0,s.yg)(xg,(0,p.A)({},Cg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}Ag.isMDXComponent=!0;const vg={toc:[]},Lg="wrapper";function bg(e){let{components:n,...t}=e;return(0,s.yg)(Lg,(0,p.A)({},vg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}bg.isMDXComponent=!0;const Ng={toc:[]},kg="wrapper";function zg(e){let{components:n,...t}=e;return(0,s.yg)(kg,(0,p.A)({},Ng,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}zg.isMDXComponent=!0;const Pg={toc:[]},Ig="wrapper";function Rg(e){let{components:n,...t}=e;return(0,s.yg)(Ig,(0,p.A)({},Pg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Rg.isMDXComponent=!0;const Wg={toc:[]},Sg="wrapper";function Bg(e){let{components:n,...t}=e;return(0,s.yg)(Sg,(0,p.A)({},Wg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Bg.isMDXComponent=!0;const Gg={toc:[]},Eg="wrapper";function Og(e){let{components:n,...t}=e;return(0,s.yg)(Eg,(0,p.A)({},Gg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}Og.isMDXComponent=!0;const Ug={toc:[]},Fg="wrapper";function Vg(e){let{components:n,...t}=e;return(0,s.yg)(Fg,(0,p.A)({},Ug,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Vg.isMDXComponent=!0;const qg={toc:[]},jg="wrapper";function Hg(e){let{components:n,...t}=e;return(0,s.yg)(jg,(0,p.A)({},qg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Hg.isMDXComponent=!0;const Yg={toc:[]},Qg="wrapper";function $g(e){let{components:n,...t}=e;return(0,s.yg)(Qg,(0,p.A)({},Yg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}$g.isMDXComponent=!0;const Kg={toc:[]},Jg="wrapper";function Zg(e){let{components:n,...t}=e;return(0,s.yg)(Jg,(0,p.A)({},Kg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Zg.isMDXComponent=!0;const ef={toc:[]},nf="wrapper";function tf(e){let{components:n,...t}=e;return(0,s.yg)(nf,(0,p.A)({},ef,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an enum value stored in a meta file."))}tf.isMDXComponent=!0;const of={toc:[]},pf="wrapper";function rf(e){let{components:n,...t}=e;return(0,s.yg)(pf,(0,p.A)({},of,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}rf.isMDXComponent=!0;const sf={toc:[]},cf="wrapper";function af(e){let{components:n,...t}=e;return(0,s.yg)(cf,(0,p.A)({},sf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}af.isMDXComponent=!0;const lf={toc:[]},uf="wrapper";function mf(e){let{components:n,...t}=e;return(0,s.yg)(uf,(0,p.A)({},lf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}mf.isMDXComponent=!0;const yf={toc:[]},df="wrapper";function hf(e){let{components:n,...t}=e;return(0,s.yg)(df,(0,p.A)({},yf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}hf.isMDXComponent=!0;const gf={toc:[]},ff="wrapper";function Df(e){let{components:n,...t}=e;return(0,s.yg)(ff,(0,p.A)({},gf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}Df.isMDXComponent=!0;const Mf={toc:[]},Xf="wrapper";function _f(e){let{components:n,...t}=e;return(0,s.yg)(Xf,(0,p.A)({},Mf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}_f.isMDXComponent=!0;const wf={toc:[]},Tf="wrapper";function Cf(e){let{components:n,...t}=e;return(0,s.yg)(Tf,(0,p.A)({},wf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}Cf.isMDXComponent=!0;const xf={toc:[]},Af="wrapper";function vf(e){let{components:n,...t}=e;return(0,s.yg)(Af,(0,p.A)({},xf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}vf.isMDXComponent=!0;const Lf={toc:[]},bf="wrapper";function Nf(e){let{components:n,...t}=e;return(0,s.yg)(bf,(0,p.A)({},Lf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}Nf.isMDXComponent=!0;const kf={toc:[]},zf="wrapper";function Pf(e){let{components:n,...t}=e;return(0,s.yg)(zf,(0,p.A)({},kf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Pf.isMDXComponent=!0;const If={toc:[]},Rf="wrapper";function Wf(e){let{components:n,...t}=e;return(0,s.yg)(Rf,(0,p.A)({},If,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}Wf.isMDXComponent=!0;const Sf={toc:[]},Bf="wrapper";function Gf(e){let{components:n,...t}=e;return(0,s.yg)(Bf,(0,p.A)({},Sf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Gf.isMDXComponent=!0;const Ef={toc:[]},Of="wrapper";function Uf(e){let{components:n,...t}=e;return(0,s.yg)(Of,(0,p.A)({},Ef,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Uf.isMDXComponent=!0;const Ff={toc:[]},Vf="wrapper";function qf(e){let{components:n,...t}=e;return(0,s.yg)(Vf,(0,p.A)({},Ff,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}qf.isMDXComponent=!0;const jf={toc:[]},Hf="wrapper";function Yf(e){let{components:n,...t}=e;return(0,s.yg)(Hf,(0,p.A)({},jf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Yf.isMDXComponent=!0;const Qf={toc:[]},$f="wrapper";function Kf(e){let{components:n,...t}=e;return(0,s.yg)($f,(0,p.A)({},Qf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Kf.isMDXComponent=!0;const Jf={toc:[]},Zf="wrapper";function eD(e){let{components:n,...t}=e;return(0,s.yg)(Zf,(0,p.A)({},Jf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}eD.isMDXComponent=!0;const nD={toc:[]},tD="wrapper";function oD(e){let{components:n,...t}=e;return(0,s.yg)(tD,(0,p.A)({},nD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}oD.isMDXComponent=!0;const pD={toc:[]},rD="wrapper";function sD(e){let{components:n,...t}=e;return(0,s.yg)(rD,(0,p.A)({},pD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the exporter configuration."))}sD.isMDXComponent=!0;const cD={toc:[]},aD="wrapper";function iD(e){let{components:n,...t}=e;return(0,s.yg)(aD,(0,p.A)({},cD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}iD.isMDXComponent=!0;const lD={toc:[]},uD="wrapper";function mD(e){let{components:n,...t}=e;return(0,s.yg)(uD,(0,p.A)({},lD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}mD.isMDXComponent=!0;const yD={toc:[]},dD="wrapper";function hD(e){let{components:n,...t}=e;return(0,s.yg)(dD,(0,p.A)({},yD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}hD.isMDXComponent=!0;const gD={toc:[]},fD="wrapper";function DD(e){let{components:n,...t}=e;return(0,s.yg)(fD,(0,p.A)({},gD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}DD.isMDXComponent=!0;const MD={toc:[]},XD="wrapper";function _D(e){let{components:n,...t}=e;return(0,s.yg)(XD,(0,p.A)({},MD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}_D.isMDXComponent=!0;const wD={toc:[]},TD="wrapper";function CD(e){let{components:n,...t}=e;return(0,s.yg)(TD,(0,p.A)({},wD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the nested fields change."))}CD.isMDXComponent=!0;const xD={toc:[]},AD="wrapper";function vD(e){let{components:n,...t}=e;return(0,s.yg)(AD,(0,p.A)({},xD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}vD.isMDXComponent=!0;const LD={toc:[]},bD="wrapper";function ND(e){let{components:n,...t}=e;return(0,s.yg)(bD,(0,p.A)({},LD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}ND.isMDXComponent=!0;const kD={toc:[]},zD="wrapper";function PD(e){let{components:n,...t}=e;return(0,s.yg)(zD,(0,p.A)({},kD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}PD.isMDXComponent=!0;const ID={toc:[]},RD="wrapper";function WD(e){let{components:n,...t}=e;return(0,s.yg)(RD,(0,p.A)({},ID,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}WD.isMDXComponent=!0;const SD={toc:[]},BD="wrapper";function GD(e){let{components:n,...t}=e;return(0,s.yg)(BD,(0,p.A)({},SD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}GD.isMDXComponent=!0;const ED={toc:[]},OD="wrapper";function UD(e){let{components:n,...t}=e;return(0,s.yg)(OD,(0,p.A)({},ED,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}UD.isMDXComponent=!0;const FD={toc:[]},VD="wrapper";function qD(e){let{components:n,...t}=e;return(0,s.yg)(VD,(0,p.A)({},FD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}qD.isMDXComponent=!0;const jD={toc:[]},HD="wrapper";function YD(e){let{components:n,...t}=e;return(0,s.yg)(HD,(0,p.A)({},jD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}YD.isMDXComponent=!0;const QD={toc:[]},$D="wrapper";function KD(e){let{components:n,...t}=e;return(0,s.yg)($D,(0,p.A)({},QD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}KD.isMDXComponent=!0;const JD={toc:[]},ZD="wrapper";function eM(e){let{components:n,...t}=e;return(0,s.yg)(ZD,(0,p.A)({},JD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}eM.isMDXComponent=!0;const nM={toc:[]},tM="wrapper";function oM(e){let{components:n,...t}=e;return(0,s.yg)(tM,(0,p.A)({},nM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}oM.isMDXComponent=!0;const pM={toc:[]},rM="wrapper";function sM(e){let{components:n,...t}=e;return(0,s.yg)(rM,(0,p.A)({},pM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}sM.isMDXComponent=!0;const cM={toc:[]},aM="wrapper";function iM(e){let{components:n,...t}=e;return(0,s.yg)(aM,(0,p.A)({},cM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}iM.isMDXComponent=!0;const lM={toc:[]},uM="wrapper";function mM(e){let{components:n,...t}=e;return(0,s.yg)(uM,(0,p.A)({},lM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an entry in the meta file."))}mM.isMDXComponent=!0;const yM={toc:[]},dM="wrapper";function hM(e){let{components:n,...t}=e;return(0,s.yg)(dM,(0,p.A)({},yM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}hM.isMDXComponent=!0;const gM={toc:[]},fM="wrapper";function DM(e){let{components:n,...t}=e;return(0,s.yg)(fM,(0,p.A)({},gM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}DM.isMDXComponent=!0;const MM={toc:[]},XM="wrapper";function _M(e){let{components:n,...t}=e;return(0,s.yg)(XM,(0,p.A)({},MM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}_M.isMDXComponent=!0;const wM={toc:[]},TM="wrapper";function CM(e){let{components:n,...t}=e;return(0,s.yg)(TM,(0,p.A)({},wM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}CM.isMDXComponent=!0;const xM={toc:[]},AM="wrapper";function vM(e){let{components:n,...t}=e;return(0,s.yg)(AM,(0,p.A)({},xM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}vM.isMDXComponent=!0;const LM={toc:[]},bM="wrapper";function NM(e){let{components:n,...t}=e;return(0,s.yg)(bM,(0,p.A)({},LM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}NM.isMDXComponent=!0;const kM={toc:[]},zM="wrapper";function PM(e){let{components:n,...t}=e;return(0,s.yg)(zM,(0,p.A)({},kM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}PM.isMDXComponent=!0;const IM={toc:[]},RM="wrapper";function WM(e){let{components:n,...t}=e;return(0,s.yg)(RM,(0,p.A)({},IM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}WM.isMDXComponent=!0;const SM={toc:[]},BM="wrapper";function GM(e){let{components:n,...t}=e;return(0,s.yg)(BM,(0,p.A)({},SM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}GM.isMDXComponent=!0;const EM={toc:[]},OM="wrapper";function UM(e){let{components:n,...t}=e;return(0,s.yg)(OM,(0,p.A)({},EM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}UM.isMDXComponent=!0;const FM={toc:[]},VM="wrapper";function qM(e){let{components:n,...t}=e;return(0,s.yg)(VM,(0,p.A)({},FM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}qM.isMDXComponent=!0;const jM={toc:[]},HM="wrapper";function YM(e){let{components:n,...t}=e;return(0,s.yg)(HM,(0,p.A)({},jM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}YM.isMDXComponent=!0;const QM={toc:[]},$M="wrapper";function KM(e){let{components:n,...t}=e;return(0,s.yg)($M,(0,p.A)({},QM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}KM.isMDXComponent=!0;const JM={toc:[]},ZM="wrapper";function eX(e){let{components:n,...t}=e;return(0,s.yg)(ZM,(0,p.A)({},JM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}eX.isMDXComponent=!0;const nX={toc:[]},tX="wrapper";function oX(e){let{components:n,...t}=e;return(0,s.yg)(tX,(0,p.A)({},nX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}oX.isMDXComponent=!0;const pX={toc:[]},rX="wrapper";function sX(e){let{components:n,...t}=e;return(0,s.yg)(rX,(0,p.A)({},pX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}sX.isMDXComponent=!0;const cX={toc:[]},aX="wrapper";function iX(e){let{components:n,...t}=e;return(0,s.yg)(aX,(0,p.A)({},cX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}iX.isMDXComponent=!0;const lX={toc:[]},uX="wrapper";function mX(e){let{components:n,...t}=e;return(0,s.yg)(uX,(0,p.A)({},lX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}mX.isMDXComponent=!0;const yX={toc:[]},dX="wrapper";function hX(e){let{components:n,...t}=e;return(0,s.yg)(dX,(0,p.A)({},yX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}hX.isMDXComponent=!0;const gX={toc:[]},fX="wrapper";function DX(e){let{components:n,...t}=e;return(0,s.yg)(fX,(0,p.A)({},gX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}DX.isMDXComponent=!0;const MX={toc:[]},XX="wrapper";function _X(e){let{components:n,...t}=e;return(0,s.yg)(XX,(0,p.A)({},MX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type used to store this field in the meta\nfile."))}_X.isMDXComponent=!0;const wX={toc:[]},TX="wrapper";function CX(e){let{components:n,...t}=e;return(0,s.yg)(TX,(0,p.A)({},wX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The runtime type of this field."))}CX.isMDXComponent=!0;const xX={toc:[]},AX="wrapper";function vX(e){let{components:n,...t}=e;return(0,s.yg)(AX,(0,p.A)({},xX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a number stored in a meta file."))}vX.isMDXComponent=!0;const LX={toc:[]},bX="wrapper";function NX(e){let{components:n,...t}=e;return(0,s.yg)(bX,(0,p.A)({},LX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}NX.isMDXComponent=!0;const kX={toc:[]},zX="wrapper";function PX(e){let{components:n,...t}=e;return(0,s.yg)(zX,(0,p.A)({},kX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}PX.isMDXComponent=!0;const IX={toc:[]},RX="wrapper";function WX(e){let{components:n,...t}=e;return(0,s.yg)(RX,(0,p.A)({},IX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}WX.isMDXComponent=!0;const SX={toc:[]},BX="wrapper";function GX(e){let{components:n,...t}=e;return(0,s.yg)(BX,(0,p.A)({},SX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}GX.isMDXComponent=!0;const EX={toc:[]},OX="wrapper";function UX(e){let{components:n,...t}=e;return(0,s.yg)(OX,(0,p.A)({},EX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}UX.isMDXComponent=!0;const FX={toc:[]},VX="wrapper";function qX(e){let{components:n,...t}=e;return(0,s.yg)(VX,(0,p.A)({},FX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}qX.isMDXComponent=!0;const jX={toc:[]},HX="wrapper";function YX(e){let{components:n,...t}=e;return(0,s.yg)(HX,(0,p.A)({},jX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}YX.isMDXComponent=!0;const QX={toc:[]},$X="wrapper";function KX(e){let{components:n,...t}=e;return(0,s.yg)($X,(0,p.A)({},QX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}KX.isMDXComponent=!0;const JX={toc:[]},ZX="wrapper";function e_(e){let{components:n,...t}=e;return(0,s.yg)(ZX,(0,p.A)({},JX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}e_.isMDXComponent=!0;const n_={toc:[]},t_="wrapper";function o_(e){let{components:n,...t}=e;return(0,s.yg)(t_,(0,p.A)({},n_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}o_.isMDXComponent=!0;const p_={toc:[]},r_="wrapper";function s_(e){let{components:n,...t}=e;return(0,s.yg)(r_,(0,p.A)({},p_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}s_.isMDXComponent=!0;const c_={toc:[]},a_="wrapper";function i_(e){let{components:n,...t}=e;return(0,s.yg)(a_,(0,p.A)({},c_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}i_.isMDXComponent=!0;const l_={toc:[]},u_="wrapper";function m_(e){let{components:n,...t}=e;return(0,s.yg)(u_,(0,p.A)({},l_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}m_.isMDXComponent=!0;const y_={toc:[]},d_="wrapper";function h_(e){let{components:n,...t}=e;return(0,s.yg)(d_,(0,p.A)({},y_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}h_.isMDXComponent=!0;const g_={toc:[]},f_="wrapper";function D_(e){let{components:n,...t}=e;return(0,s.yg)(f_,(0,p.A)({},g_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}D_.isMDXComponent=!0;const M_={toc:[]},X_="wrapper";function __(e){let{components:n,...t}=e;return(0,s.yg)(X_,(0,p.A)({},M_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}__.isMDXComponent=!0;const w_={toc:[]},T_="wrapper";function C_(e){let{components:n,...t}=e;return(0,s.yg)(T_,(0,p.A)({},w_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}C_.isMDXComponent=!0;const x_={toc:[]},A_="wrapper";function v_(e){let{components:n,...t}=e;return(0,s.yg)(A_,(0,p.A)({},x_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}v_.isMDXComponent=!0;const L_={toc:[]},b_="wrapper";function N_(e){let{components:n,...t}=e;return(0,s.yg)(b_,(0,p.A)({},L_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}N_.isMDXComponent=!0;const k_={toc:[]},z_="wrapper";function P_(e){let{components:n,...t}=e;return(0,s.yg)(z_,(0,p.A)({},k_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}P_.isMDXComponent=!0;const I_={toc:[]},R_="wrapper";function W_(e){let{components:n,...t}=e;return(0,s.yg)(R_,(0,p.A)({},I_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}W_.isMDXComponent=!0;const S_={toc:[]},B_="wrapper";function G_(e){let{components:n,...t}=e;return(0,s.yg)(B_,(0,p.A)({},S_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a range stored in a meta file."))}G_.isMDXComponent=!0;const E_={toc:[]},O_="wrapper";function U_(e){let{components:n,...t}=e;return(0,s.yg)(O_,(0,p.A)({},E_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}U_.isMDXComponent=!0;const F_={toc:[]},V_="wrapper";function q_(e){let{components:n,...t}=e;return(0,s.yg)(V_,(0,p.A)({},F_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}q_.isMDXComponent=!0;const j_={toc:[]},H_="wrapper";function Y_(e){let{components:n,...t}=e;return(0,s.yg)(H_,(0,p.A)({},j_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Y_.isMDXComponent=!0;const Q_={toc:[]},$_="wrapper";function K_(e){let{components:n,...t}=e;return(0,s.yg)($_,(0,p.A)({},Q_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}K_.isMDXComponent=!0;const J_={toc:[]},Z_="wrapper";function ew(e){let{components:n,...t}=e;return(0,s.yg)(Z_,(0,p.A)({},J_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}ew.isMDXComponent=!0;const nw={toc:[]},tw="wrapper";function ow(e){let{components:n,...t}=e;return(0,s.yg)(tw,(0,p.A)({},nw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}ow.isMDXComponent=!0;const pw={toc:[]},rw="wrapper";function sw(e){let{components:n,...t}=e;return(0,s.yg)(rw,(0,p.A)({},pw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}sw.isMDXComponent=!0;const cw={toc:[]},aw="wrapper";function iw(e){let{components:n,...t}=e;return(0,s.yg)(aw,(0,p.A)({},cw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}iw.isMDXComponent=!0;const lw={toc:[]},uw="wrapper";function mw(e){let{components:n,...t}=e;return(0,s.yg)(uw,(0,p.A)({},lw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}mw.isMDXComponent=!0;const yw={toc:[]},dw="wrapper";function hw(e){let{components:n,...t}=e;return(0,s.yg)(dw,(0,p.A)({},yw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}hw.isMDXComponent=!0;const gw={toc:[]},fw="wrapper";function Dw(e){let{components:n,...t}=e;return(0,s.yg)(fw,(0,p.A)({},gw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}Dw.isMDXComponent=!0;const Mw={toc:[]},Xw="wrapper";function _w(e){let{components:n,...t}=e;return(0,s.yg)(Xw,(0,p.A)({},Mw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}_w.isMDXComponent=!0;const ww={toc:[]},Tw="wrapper";function Cw(e){let{components:n,...t}=e;return(0,s.yg)(Tw,(0,p.A)({},ww,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}Cw.isMDXComponent=!0;const xw={toc:[]},Aw="wrapper";function vw(e){let{components:n,...t}=e;return(0,s.yg)(Aw,(0,p.A)({},xw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}vw.isMDXComponent=!0;const Lw={toc:[]},bw="wrapper";function Nw(e){let{components:n,...t}=e;return(0,s.yg)(bw,(0,p.A)({},Lw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Nw.isMDXComponent=!0;const kw={toc:[]},zw="wrapper";function Pw(e){let{components:n,...t}=e;return(0,s.yg)(zw,(0,p.A)({},kw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}Pw.isMDXComponent=!0;const Iw={toc:[]},Rw="wrapper";function Ww(e){let{components:n,...t}=e;return(0,s.yg)(Rw,(0,p.A)({},Iw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Ww.isMDXComponent=!0;const Sw={toc:[]},Bw="wrapper";function Gw(e){let{components:n,...t}=e;return(0,s.yg)(Bw,(0,p.A)({},Sw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Gw.isMDXComponent=!0;const Ew={toc:[]},Ow="wrapper";function Uw(e){let{components:n,...t}=e;return(0,s.yg)(Ow,(0,p.A)({},Ew,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Uw.isMDXComponent=!0;const Fw={toc:[]},Vw="wrapper";function qw(e){let{components:n,...t}=e;return(0,s.yg)(Vw,(0,p.A)({},Fw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}qw.isMDXComponent=!0;const jw={toc:[]},Hw="wrapper";function Yw(e){let{components:n,...t}=e;return(0,s.yg)(Hw,(0,p.A)({},jw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}Yw.isMDXComponent=!0;const Qw={toc:[]},$w="wrapper";function Kw(e){let{components:n,...t}=e;return(0,s.yg)($w,(0,p.A)({},Qw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert the given range from frames to seconds and update this field."))}Kw.isMDXComponent=!0;const Jw={toc:[]},Zw="wrapper";function eT(e){let{components:n,...t}=e;return(0,s.yg)(Zw,(0,p.A)({},Jw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The beginning of the range."))}eT.isMDXComponent=!0;const nT={toc:[]},tT="wrapper";function oT(e){let{components:n,...t}=e;return(0,s.yg)(tT,(0,p.A)({},nT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}oT.isMDXComponent=!0;const pT={toc:[]},rT="wrapper";function sT(e){let{components:n,...t}=e;return(0,s.yg)(rT,(0,p.A)({},pT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current duration in frames."))}sT.isMDXComponent=!0;const cT={toc:[]},aT="wrapper";function iT(e){let{components:n,...t}=e;return(0,s.yg)(aT,(0,p.A)({},cT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current framerate."))}iT.isMDXComponent=!0;const lT={toc:[]},uT="wrapper";function mT(e){let{components:n,...t}=e;return(0,s.yg)(uT,(0,p.A)({},lT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a string stored in a meta file."))}mT.isMDXComponent=!0;const yT={toc:[]},dT="wrapper";function hT(e){let{components:n,...t}=e;return(0,s.yg)(dT,(0,p.A)({},yT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}hT.isMDXComponent=!0;const gT={toc:[]},fT="wrapper";function DT(e){let{components:n,...t}=e;return(0,s.yg)(fT,(0,p.A)({},gT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}DT.isMDXComponent=!0;const MT={toc:[]},XT="wrapper";function _T(e){let{components:n,...t}=e;return(0,s.yg)(XT,(0,p.A)({},MT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}_T.isMDXComponent=!0;const wT={toc:[]},TT="wrapper";function CT(e){let{components:n,...t}=e;return(0,s.yg)(TT,(0,p.A)({},wT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}CT.isMDXComponent=!0;const xT={toc:[]},AT="wrapper";function vT(e){let{components:n,...t}=e;return(0,s.yg)(AT,(0,p.A)({},xT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}vT.isMDXComponent=!0;const LT={toc:[]},bT="wrapper";function NT(e){let{components:n,...t}=e;return(0,s.yg)(bT,(0,p.A)({},LT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}NT.isMDXComponent=!0;const kT={toc:[]},zT="wrapper";function PT(e){let{components:n,...t}=e;return(0,s.yg)(zT,(0,p.A)({},kT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}PT.isMDXComponent=!0;const IT={toc:[]},RT="wrapper";function WT(e){let{components:n,...t}=e;return(0,s.yg)(RT,(0,p.A)({},IT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}WT.isMDXComponent=!0;const ST={toc:[]},BT="wrapper";function GT(e){let{components:n,...t}=e;return(0,s.yg)(BT,(0,p.A)({},ST,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}GT.isMDXComponent=!0;const ET={toc:[]},OT="wrapper";function UT(e){let{components:n,...t}=e;return(0,s.yg)(OT,(0,p.A)({},ET,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}UT.isMDXComponent=!0;const FT={toc:[]},VT="wrapper";function qT(e){let{components:n,...t}=e;return(0,s.yg)(VT,(0,p.A)({},FT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}qT.isMDXComponent=!0;const jT={toc:[]},HT="wrapper";function YT(e){let{components:n,...t}=e;return(0,s.yg)(HT,(0,p.A)({},jT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}YT.isMDXComponent=!0;const QT={toc:[]},$T="wrapper";function KT(e){let{components:n,...t}=e;return(0,s.yg)($T,(0,p.A)({},QT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}KT.isMDXComponent=!0;const JT={toc:[]},ZT="wrapper";function eC(e){let{components:n,...t}=e;return(0,s.yg)(ZT,(0,p.A)({},JT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}eC.isMDXComponent=!0;const nC={toc:[]},tC="wrapper";function oC(e){let{components:n,...t}=e;return(0,s.yg)(tC,(0,p.A)({},nC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}oC.isMDXComponent=!0;const pC={toc:[]},rC="wrapper";function sC(e){let{components:n,...t}=e;return(0,s.yg)(rC,(0,p.A)({},pC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}sC.isMDXComponent=!0;const cC={toc:[]},aC="wrapper";function iC(e){let{components:n,...t}=e;return(0,s.yg)(aC,(0,p.A)({},cC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}iC.isMDXComponent=!0;const lC={toc:[]},uC="wrapper";function mC(e){let{components:n,...t}=e;return(0,s.yg)(uC,(0,p.A)({},lC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}mC.isMDXComponent=!0;const yC={toc:[]},dC="wrapper";function hC(e){let{components:n,...t}=e;return(0,s.yg)(dC,(0,p.A)({},yC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}hC.isMDXComponent=!0;const gC={toc:[]},fC="wrapper";function DC(e){let{components:n,...t}=e;return(0,s.yg)(fC,(0,p.A)({},gC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}DC.isMDXComponent=!0;const MC={toc:[]},XC="wrapper";function _C(e){let{components:n,...t}=e;return(0,s.yg)(XC,(0,p.A)({},MC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a two-dimensional vector stored in a meta file."))}_C.isMDXComponent=!0;const wC={toc:[]},TC="wrapper";function CC(e){let{components:n,...t}=e;return(0,s.yg)(TC,(0,p.A)({},wC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}CC.isMDXComponent=!0;const xC={toc:[]},AC="wrapper";function vC(e){let{components:n,...t}=e;return(0,s.yg)(AC,(0,p.A)({},xC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}vC.isMDXComponent=!0;const LC={toc:[]},bC="wrapper";function NC(e){let{components:n,...t}=e;return(0,s.yg)(bC,(0,p.A)({},LC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}NC.isMDXComponent=!0;const kC={toc:[]},zC="wrapper";function PC(e){let{components:n,...t}=e;return(0,s.yg)(zC,(0,p.A)({},kC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}PC.isMDXComponent=!0;const IC={toc:[]},RC="wrapper";function WC(e){let{components:n,...t}=e;return(0,s.yg)(RC,(0,p.A)({},IC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}WC.isMDXComponent=!0;const SC={toc:[]},BC="wrapper";function GC(e){let{components:n,...t}=e;return(0,s.yg)(BC,(0,p.A)({},SC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}GC.isMDXComponent=!0;const EC={toc:[]},OC="wrapper";function UC(e){let{components:n,...t}=e;return(0,s.yg)(OC,(0,p.A)({},EC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}UC.isMDXComponent=!0;const FC={toc:[]},VC="wrapper";function qC(e){let{components:n,...t}=e;return(0,s.yg)(VC,(0,p.A)({},FC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}qC.isMDXComponent=!0;const jC={toc:[]},HC="wrapper";function YC(e){let{components:n,...t}=e;return(0,s.yg)(HC,(0,p.A)({},jC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}YC.isMDXComponent=!0;const QC={toc:[]},$C="wrapper";function KC(e){let{components:n,...t}=e;return(0,s.yg)($C,(0,p.A)({},QC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}KC.isMDXComponent=!0;const JC={toc:[]},ZC="wrapper";function ex(e){let{components:n,...t}=e;return(0,s.yg)(ZC,(0,p.A)({},JC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}ex.isMDXComponent=!0;const nx={toc:[]},tx="wrapper";function ox(e){let{components:n,...t}=e;return(0,s.yg)(tx,(0,p.A)({},nx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}ox.isMDXComponent=!0;const px={toc:[]},rx="wrapper";function sx(e){let{components:n,...t}=e;return(0,s.yg)(rx,(0,p.A)({},px,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}sx.isMDXComponent=!0;const cx={toc:[]},ax="wrapper";function ix(e){let{components:n,...t}=e;return(0,s.yg)(ax,(0,p.A)({},cx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}ix.isMDXComponent=!0;const lx={toc:[]},ux="wrapper";function mx(e){let{components:n,...t}=e;return(0,s.yg)(ux,(0,p.A)({},lx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}mx.isMDXComponent=!0;const yx={toc:[]},dx="wrapper";function hx(e){let{components:n,...t}=e;return(0,s.yg)(dx,(0,p.A)({},yx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}hx.isMDXComponent=!0;const gx={toc:[]},fx="wrapper";function Dx(e){let{components:n,...t}=e;return(0,s.yg)(fx,(0,p.A)({},gx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Dx.isMDXComponent=!0;const Mx={toc:[]},Xx="wrapper";function _x(e){let{components:n,...t}=e;return(0,s.yg)(Xx,(0,p.A)({},Mx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}_x.isMDXComponent=!0;const wx={toc:[]},Tx="wrapper";function Cx(e){let{components:n,...t}=e;return(0,s.yg)(Tx,(0,p.A)({},wx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Cx.isMDXComponent=!0;const xx={toc:[]},Ax="wrapper";function vx(e){let{components:n,...t}=e;return(0,s.yg)(Ax,(0,p.A)({},xx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}vx.isMDXComponent=!0;const Lx={toc:[]},bx="wrapper";function Nx(e){let{components:n,...t}=e;return(0,s.yg)(bx,(0,p.A)({},Lx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an object with nested meta-fields."))}Nx.isMDXComponent=!0;const kx={toc:[]},zx="wrapper";function Px(e){let{components:n,...t}=e;return(0,s.yg)(zx,(0,p.A)({},kx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an object with nested meta-fields."))}Px.isMDXComponent=!0;const Ix={toc:[]},Rx="wrapper";function Wx(e){let{components:n,...t}=e;return(0,s.yg)(Rx,(0,p.A)({},Ix,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a runtime Motion Canvas plugin."))}Wx.isMDXComponent=!0;const Sx={toc:[]},Bx="wrapper";function Gx(e){let{components:n,...t}=e;return(0,s.yg)(Bx,(0,p.A)({},Sx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name should be unique across the entire ecosystem of Motion Canvas.\nIf a plugin with the same name has already been registered, this plugin\nwill be ignored."),(0,s.yg)("p",null,"If you intend to publish your plugin to npm, it is recommended to prefix\nthis name with the name of your npm package."),(0,s.yg)("p",null,"Other identifiers defined by the plugin, such as a tab id, will be\nautomatically prefixed with this name and as such don't have to be unique."))}Gx.isMDXComponent=!0;const Ex={toc:[]},Ox="wrapper";function Ux(e){let{components:n,...t}=e;return(0,s.yg)(Ox,(0,p.A)({},Ex,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A unique name of the plugin."))}Ux.isMDXComponent=!0;const Fx={toc:[]},Vx="wrapper";function qx(e){let{components:n,...t}=e;return(0,s.yg)(Vx,(0,p.A)({},Fx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide custom exporters for the project."))}qx.isMDXComponent=!0;const jx={toc:[]},Hx="wrapper";function Yx(e){let{components:n,...t}=e;return(0,s.yg)(Hx,(0,p.A)({},jx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project instance."))}Yx.isMDXComponent=!0;const Qx={toc:[]},$x="wrapper";function Kx(e){let{components:n,...t}=e;return(0,s.yg)($x,(0,p.A)({},Qx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the player instance right after it is initialized."))}Kx.isMDXComponent=!0;const Jx={toc:[]},Zx="wrapper";function eA(e){let{components:n,...t}=e;return(0,s.yg)(Zx,(0,p.A)({},Jx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The player instance."))}eA.isMDXComponent=!0;const nA={toc:[]},tA="wrapper";function oA(e){let{components:n,...t}=e;return(0,s.yg)(tA,(0,p.A)({},nA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the presenter instance right after it is initialized."))}oA.isMDXComponent=!0;const pA={toc:[]},rA="wrapper";function sA(e){let{components:n,...t}=e;return(0,s.yg)(rA,(0,p.A)({},pA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The presenter instance."))}sA.isMDXComponent=!0;const cA={toc:[]},aA="wrapper";function iA(e){let{components:n,...t}=e;return(0,s.yg)(aA,(0,p.A)({},cA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the project instance right after it is initialized."))}iA.isMDXComponent=!0;const lA={toc:[]},uA="wrapper";function mA(e){let{components:n,...t}=e;return(0,s.yg)(uA,(0,p.A)({},lA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project instance."))}mA.isMDXComponent=!0;const yA={toc:[]},dA="wrapper";function hA(e){let{components:n,...t}=e;return(0,s.yg)(dA,(0,p.A)({},yA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the renderer instance right after it is initialized."))}hA.isMDXComponent=!0;const gA={toc:[]},fA="wrapper";function DA(e){let{components:n,...t}=e;return(0,s.yg)(fA,(0,p.A)({},gA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The renderer instance."))}DA.isMDXComponent=!0;const MA={toc:[]},XA="wrapper";function _A(e){let{components:n,...t}=e;return(0,s.yg)(XA,(0,p.A)({},MA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Modify the project settings before the project is initialized."))}_A.isMDXComponent=!0;const wA={toc:[]},TA="wrapper";function CA(e){let{components:n,...t}=e;return(0,s.yg)(TA,(0,p.A)({},wA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project settings."))}CA.isMDXComponent=!0;const xA={toc:[]},AA="wrapper";function vA(e){let{components:n,...t}=e;return(0,s.yg)(AA,(0,p.A)({},xA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}vA.isMDXComponent=!0;const LA={toc:[]},bA="wrapper";function NA(e){let{components:n,...t}=e;return(0,s.yg)(bA,(0,p.A)({},LA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper function for exporting Motion Canvas plugins."))}NA.isMDXComponent=!0;const kA={toc:[]},zA="wrapper";function PA(e){let{components:n,...t}=e;return(0,s.yg)(zA,(0,p.A)({},kA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The plugin configuration."))}PA.isMDXComponent=!0;const IA={toc:[]},RA="wrapper";function WA(e){let{components:n,...t}=e;return(0,s.yg)(RA,(0,p.A)({},IA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abstract scene representations and related utilities."))}WA.isMDXComponent=!0;const SA={toc:[]},BA="wrapper";function GA(e){let{components:n,...t}=e;return(0,s.yg)(BA,(0,p.A)({},SA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Signifies the various stages of a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}GA.isMDXComponent=!0;const EA={toc:[]},OA="wrapper";function UA(e){let{components:n,...t}=e;return(0,s.yg)(OA,(0,p.A)({},EA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs after a render ends."))}UA.isMDXComponent=!0;const FA={toc:[]},VA="wrapper";function qA(e){let{components:n,...t}=e;return(0,s.yg)(VA,(0,p.A)({},FA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}qA.isMDXComponent=!0;const jA={toc:[]},HA="wrapper";function YA(e){let{components:n,...t}=e;return(0,s.yg)(HA,(0,p.A)({},jA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.yg)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}YA.isMDXComponent=!0;const QA={toc:[]},$A="wrapper";function KA(e){let{components:n,...t}=e;return(0,s.yg)($A,(0,p.A)({},QA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.yg)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}KA.isMDXComponent=!0;const JA={toc:[]},ZA="wrapper";function ev(e){let{components:n,...t}=e;return(0,s.yg)(ZA,(0,p.A)({},JA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes the state of a scene."))}ev.isMDXComponent=!0;const nv={toc:[]},tv="wrapper";function ov(e){let{components:n,...t}=e;return(0,s.yg)(tv,(0,p.A)({},nv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}ov.isMDXComponent=!0;const pv={toc:[]},rv="wrapper";function sv(e){let{components:n,...t}=e;return(0,s.yg)(rv,(0,p.A)({},pv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has finished transitioning in."))}sv.isMDXComponent=!0;const cv={toc:[]},av="wrapper";function iv(e){let{components:n,...t}=e;return(0,s.yg)(av,(0,p.A)({},cv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.yg)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}iv.isMDXComponent=!0;const lv={toc:[]},uv="wrapper";function mv(e){let{components:n,...t}=e;return(0,s.yg)(uv,(0,p.A)({},lv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene is ready to transition out."))}mv.isMDXComponent=!0;const yv={toc:[]},dv="wrapper";function hv(e){let{components:n,...t}=e;return(0,s.yg)(dv,(0,p.A)({},yv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoking ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.yg)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}hv.isMDXComponent=!0;const gv={toc:[]},fv="wrapper";function Dv(e){let{components:n,...t}=e;return(0,s.yg)(fv,(0,p.A)({},gv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has finished."))}Dv.isMDXComponent=!0;const Mv={toc:[]},Xv="wrapper";function _v(e){let{components:n,...t}=e;return(0,s.yg)(Xv,(0,p.A)({},Mv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has just been created/reset."))}_v.isMDXComponent=!0;const wv={toc:[]},Tv="wrapper";function Cv(e){let{components:n,...t}=e;return(0,s.yg)(Tv,(0,p.A)({},wv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The default implementation of the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.yg)("p",null,"Uses generators to control the animation."))}Cv.isMDXComponent=!0;const xv={toc:[]},Av="wrapper";function vv(e){let{components:n,...t}=e;return(0,s.yg)(Av,(0,p.A)({},xv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Will be passed as the second argument to the constructor."))}vv.isMDXComponent=!0;const Lv={toc:[]},bv="wrapper";function Nv(e){let{components:n,...t}=e;return(0,s.yg)(bv,(0,p.A)({},Lv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Name of the scene."))}Nv.isMDXComponent=!0;const kv={toc:[]},zv="wrapper";function Pv(e){let{components:n,...t}=e;return(0,s.yg)(zv,(0,p.A)({},kv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reference to the project."))}Pv.isMDXComponent=!0;const Iv={toc:[]},Rv="wrapper";function Wv(e){let{components:n,...t}=e;return(0,s.yg)(Rv,(0,p.A)({},Iv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}Wv.isMDXComponent=!0;const Sv={toc:[]},Bv="wrapper";function Gv(e){let{components:n,...t}=e;return(0,s.yg)(Bv,(0,p.A)({},Sv,t,{components:n,mdxType:"MDXLayout"}))}Gv.isMDXComponent=!0;const Ev={toc:[]},Ov="wrapper";function Uv(e){let{components:n,...t}=e;return(0,s.yg)(Ov,(0,p.A)({},Ev,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Uv.isMDXComponent=!0;const Fv={toc:[]},Vv="wrapper";function qv(e){let{components:n,...t}=e;return(0,s.yg)(Vv,(0,p.A)({},Fv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}qv.isMDXComponent=!0;const jv={toc:[]},Hv="wrapper";function Yv(e){let{components:n,...t}=e;return(0,s.yg)(Hv,(0,p.A)({},jv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene starts."))}Yv.isMDXComponent=!0;const Qv={toc:[]},$v="wrapper";function Kv(e){let{components:n,...t}=e;return(0,s.yg)($v,(0,p.A)({},Qv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene ends."))}Kv.isMDXComponent=!0;const Jv={toc:[]},Zv="wrapper";function eL(e){let{components:n,...t}=e;return(0,s.yg)(Zv,(0,p.A)({},Jv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the cached data changes."))}eL.isMDXComponent=!0;const nL={toc:[]},tL="wrapper";function oL(e){let{components:n,...t}=e;return(0,s.yg)(tL,(0,p.A)({},nL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered after scene is recalculated."))}oL.isMDXComponent=!0;const pL={toc:[]},rL="wrapper";function sL(e){let{components:n,...t}=e;return(0,s.yg)(rL,(0,p.A)({},pL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reloaded."))}sL.isMDXComponent=!0;const cL={toc:[]},aL="wrapper";function iL(e){let{components:n,...t}=e;return(0,s.yg)(aL,(0,p.A)({},cL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}iL.isMDXComponent=!0;const lL={toc:[]},uL="wrapper";function mL(e){let{components:n,...t}=e;return(0,s.yg)(uL,(0,p.A)({},lL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reset."))}mL.isMDXComponent=!0;const yL={toc:[]},dL="wrapper";function hL(e){let{components:n,...t}=e;return(0,s.yg)(dL,(0,p.A)({},yL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the main thread changes."))}hL.isMDXComponent=!0;const gL={toc:[]},fL="wrapper";function DL(e){let{components:n,...t}=e;return(0,s.yg)(fL,(0,p.A)({},gL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene directly before this scene, or null if omitted for performance."))}DL.isMDXComponent=!0;const ML={toc:[]},XL="wrapper";function _L(e){let{components:n,...t}=e;return(0,s.yg)(XL,(0,p.A)({},ML,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}_L.isMDXComponent=!0;const wL={toc:[]},TL="wrapper";function CL(e){let{components:n,...t}=e;return(0,s.yg)(TL,(0,p.A)({},wL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}CL.isMDXComponent=!0;const xL={toc:[]},AL="wrapper";function vL(e){let{components:n,...t}=e;return(0,s.yg)(AL,(0,p.A)({},xL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}vL.isMDXComponent=!0;const LL={toc:[]},bL="wrapper";function NL(e){let{components:n,...t}=e;return(0,s.yg)(bL,(0,p.A)({},LL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.yg)("inlineCode",{parentName:"a"},"Initial"))," state."))}NL.isMDXComponent=!0;const kL={toc:[]},zL="wrapper";function PL(e){let{components:n,...t}=e;return(0,s.yg)(zL,(0,p.A)({},kL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}PL.isMDXComponent=!0;const IL={toc:[]},RL="wrapper";function WL(e){let{components:n,...t}=e;return(0,s.yg)(RL,(0,p.A)({},IL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback in the context of this scene."))}WL.isMDXComponent=!0;const SL={toc:[]},BL="wrapper";function GL(e){let{components:n,...t}=e;return(0,s.yg)(BL,(0,p.A)({},SL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}GL.isMDXComponent=!0;const EL={toc:[]},OL="wrapper";function UL(e){let{components:n,...t}=e;return(0,s.yg)(OL,(0,p.A)({},EL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all media assets"))}UL.isMDXComponent=!0;const FL={toc:[]},VL="wrapper";function qL(e){let{components:n,...t}=e;return(0,s.yg)(VL,(0,p.A)({},FL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}qL.isMDXComponent=!0;const jL={toc:[]},HL="wrapper";function YL(e){let{components:n,...t}=e;return(0,s.yg)(HL,(0,p.A)({},jL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real size of this scene."))}YL.isMDXComponent=!0;const QL={toc:[]},$L="wrapper";function KL(e){let{components:n,...t}=e;return(0,s.yg)($L,(0,p.A)({},QL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually returns ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}KL.isMDXComponent=!0;const JL={toc:[]},ZL="wrapper";function eb(e){let{components:n,...t}=e;return(0,s.yg)(ZL,(0,p.A)({},JL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the size of this scene."))}eb.isMDXComponent=!0;const nb={toc:[]},tb="wrapper";function ob(e){let{components:n,...t}=e;return(0,s.yg)(tb,(0,p.A)({},nb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ob.isMDXComponent=!0;const pb={toc:[]},rb="wrapper";function sb(e){let{components:n,...t}=e;return(0,s.yg)(rb,(0,p.A)({},pb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used only by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.yg)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.yg)("p",null,"Should always return ",(0,s.yg)("inlineCode",{parentName:"p"},"true"),"."))}sb.isMDXComponent=!0;const cb={toc:[]},ab="wrapper";function ib(e){let{components:n,...t}=e;return(0,s.yg)(ab,(0,p.A)({},cb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene cached?"))}ib.isMDXComponent=!0;const lb={toc:[]},ub="wrapper";function mb(e){let{components:n,...t}=e;return(0,s.yg)(ub,(0,p.A)({},lb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.yg)("inlineCode",{parentName:"a"},"Finished"))," state?"))}mb.isMDXComponent=!0;const yb={toc:[]},db="wrapper";function hb(e){let{components:n,...t}=e;return(0,s.yg)(db,(0,p.A)({},yb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress this scene one frame forward."))}hb.isMDXComponent=!0;const gb={toc:[]},fb="wrapper";function Db(e){let{components:n,...t}=e;return(0,s.yg)(fb,(0,p.A)({},gb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.yg)("p",null,"At the end of execution, this method should set ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.yg)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Db.isMDXComponent=!0;const Mb={toc:[]},Xb="wrapper";function _b(e){let{components:n,...t}=e;return(0,s.yg)(Xb,(0,p.A)({},Mb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Recalculate the scene."))}_b.isMDXComponent=!0;const wb={toc:[]},Tb="wrapper";function Cb(e){let{components:n,...t}=e;return(0,s.yg)(Tb,(0,p.A)({},wb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.yg)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Cb.isMDXComponent=!0;const xb={toc:[]},Ab="wrapper";function vb(e){let{components:n,...t}=e;return(0,s.yg)(Ab,(0,p.A)({},xb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reload the scene."))}vb.isMDXComponent=!0;const Lb={toc:[]},bb="wrapper";function Nb(e){let{components:n,...t}=e;return(0,s.yg)(bb,(0,p.A)({},Lb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, an updated version of the description."))}Nb.isMDXComponent=!0;const kb={toc:[]},zb="wrapper";function Pb(e){let{components:n,...t}=e;return(0,s.yg)(zb,(0,p.A)({},kb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the scene onto a canvas."))}Pb.isMDXComponent=!0;const Ib={toc:[]},Rb="wrapper";function Wb(e){let{components:n,...t}=e;return(0,s.yg)(Rb,(0,p.A)({},Ib,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to used when rendering."))}Wb.isMDXComponent=!0;const Sb={toc:[]},Bb="wrapper";function Gb(e){let{components:n,...t}=e;return(0,s.yg)(Bb,(0,p.A)({},Sb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset this scene to its initial state."))}Gb.isMDXComponent=!0;const Eb={toc:[]},Ob="wrapper";function Ub(e){let{components:n,...t}=e;return(0,s.yg)(Ob,(0,p.A)({},Eb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, the previous scene."))}Ub.isMDXComponent=!0;const Fb={toc:[]},Vb="wrapper";function qb(e){let{components:n,...t}=e;return(0,s.yg)(Vb,(0,p.A)({},Fb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the view."),(0,s.yg)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.yg)("p",null,"Can modify the state of the view."))}qb.isMDXComponent=!0;const jb={toc:[]},Hb="wrapper";function Yb(e){let{components:n,...t}=e;return(0,s.yg)(Hb,(0,p.A)({},jb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Lifecycle events for ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Yb.isMDXComponent=!0;const Qb={toc:[]},$b="wrapper";function Kb(e){let{components:n,...t}=e;return(0,s.yg)($b,(0,p.A)({},Qb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A random number generator based on\n",(0,s.yg)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.yg)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Kb.isMDXComponent=!0;const Jb={toc:[]},Zb="wrapper";function eN(e){let{components:n,...t}=e;return(0,s.yg)(Zb,(0,p.A)({},Jb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get an array filled with random floats in the given range."))}eN.isMDXComponent=!0;const nN={toc:[]},tN="wrapper";function oN(e){let{components:n,...t}=e;return(0,s.yg)(tN,(0,p.A)({},nN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The size of the array."))}oN.isMDXComponent=!0;const pN={toc:[]},rN="wrapper";function sN(e){let{components:n,...t}=e;return(0,s.yg)(rN,(0,p.A)({},pN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}sN.isMDXComponent=!0;const cN={toc:[]},aN="wrapper";function iN(e){let{components:n,...t}=e;return(0,s.yg)(aN,(0,p.A)({},cN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}iN.isMDXComponent=!0;const lN={toc:[]},uN="wrapper";function mN(e){let{components:n,...t}=e;return(0,s.yg)(uN,(0,p.A)({},lN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a random float from a gaussian distribution."))}mN.isMDXComponent=!0;const yN={toc:[]},dN="wrapper";function hN(e){let{components:n,...t}=e;return(0,s.yg)(dN,(0,p.A)({},yN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The mean of the distribution."))}hN.isMDXComponent=!0;const gN={toc:[]},fN="wrapper";function DN(e){let{components:n,...t}=e;return(0,s.yg)(fN,(0,p.A)({},gN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The standard deviation of the distribution."))}DN.isMDXComponent=!0;const MN={toc:[]},XN="wrapper";function _N(e){let{components:n,...t}=e;return(0,s.yg)(XN,(0,p.A)({},MN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get an array filled with random integers in the given range."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"}),(0,s.yg)("li",{parentName:"ul"})))}_N.isMDXComponent=!0;const wN={toc:[]},TN="wrapper";function CN(e){let{components:n,...t}=e;return(0,s.yg)(TN,(0,p.A)({},wN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The size of the array."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}CN.isMDXComponent=!0;const xN={toc:[]},AN="wrapper";function vN(e){let{components:n,...t}=e;return(0,s.yg)(AN,(0,p.A)({},xN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}vN.isMDXComponent=!0;const LN={toc:[]},bN="wrapper";function NN(e){let{components:n,...t}=e;return(0,s.yg)(bN,(0,p.A)({},LN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. Exclusive."))}NN.isMDXComponent=!0;const kN={toc:[]},zN="wrapper";function PN(e){let{components:n,...t}=e;return(0,s.yg)(zN,(0,p.A)({},kN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the next random float in the given range."))}PN.isMDXComponent=!0;const IN={toc:[]},RN="wrapper";function WN(e){let{components:n,...t}=e;return(0,s.yg)(RN,(0,p.A)({},IN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}WN.isMDXComponent=!0;const SN={toc:[]},BN="wrapper";function GN(e){let{components:n,...t}=e;return(0,s.yg)(BN,(0,p.A)({},SN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}GN.isMDXComponent=!0;const EN={toc:[]},ON="wrapper";function UN(e){let{components:n,...t}=e;return(0,s.yg)(ON,(0,p.A)({},EN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the next random integer in the given range."))}UN.isMDXComponent=!0;const FN={toc:[]},VN="wrapper";function qN(e){let{components:n,...t}=e;return(0,s.yg)(VN,(0,p.A)({},FN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}qN.isMDXComponent=!0;const jN={toc:[]},HN="wrapper";function YN(e){let{components:n,...t}=e;return(0,s.yg)(HN,(0,p.A)({},jN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. Exclusive."))}YN.isMDXComponent=!0;const QN={toc:[]},$N="wrapper";function KN(e){let{components:n,...t}=e;return(0,s.yg)($N,(0,p.A)({},QN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a new independent generator."))}KN.isMDXComponent=!0;const JN={toc:[]},ZN="wrapper";function ek(e){let{components:n,...t}=e;return(0,s.yg)(ZN,(0,p.A)({},JN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get variable signal if exists or create signal if not"))}ek.isMDXComponent=!0;const nk={toc:[]},tk="wrapper";function ok(e){let{components:n,...t}=e;return(0,s.yg)(tk,(0,p.A)({},nk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the variable."))}ok.isMDXComponent=!0;const pk={toc:[]},rk="wrapper";function sk(e){let{components:n,...t}=e;return(0,s.yg)(rk,(0,p.A)({},pk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}sk.isMDXComponent=!0;const ck={toc:[]},ak="wrapper";function ik(e){let{components:n,...t}=e;return(0,s.yg)(ak,(0,p.A)({},ck,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get variable signal if exists or create signal if not"))}ik.isMDXComponent=!0;const lk={toc:[]},uk="wrapper";function mk(e){let{components:n,...t}=e;return(0,s.yg)(uk,(0,p.A)({},lk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset all stored signals."))}mk.isMDXComponent=!0;const yk={toc:[]},dk="wrapper";function hk(e){let{components:n,...t}=e;return(0,s.yg)(dk,(0,p.A)({},yk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update all signals with new project variable values."))}hk.isMDXComponent=!0;const gk={toc:[]},fk="wrapper";function Dk(e){let{components:n,...t}=e;return(0,s.yg)(fk,(0,p.A)({},gk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes cached information about the timing of a scene."))}Dk.isMDXComponent=!0;const Mk={toc:[]},Xk="wrapper";function _k(e){let{components:n,...t}=e;return(0,s.yg)(Xk,(0,p.A)({},Mk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes a complete scene together with the meta file."))}_k.isMDXComponent=!0;const wk={toc:[]},Tk="wrapper";function Ck(e){let{components:n,...t}=e;return(0,s.yg)(Tk,(0,p.A)({},wk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configuration object."))}Ck.isMDXComponent=!0;const xk={toc:[]},Ak="wrapper";function vk(e){let{components:n,...t}=e;return(0,s.yg)(Ak,(0,p.A)({},xk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class used to instantiate the scene."))}vk.isMDXComponent=!0;const Lk={toc:[]},bk="wrapper";function Nk(e){let{components:n,...t}=e;return(0,s.yg)(bk,(0,p.A)({},Lk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}Nk.isMDXComponent=!0;const kk={toc:[]},zk="wrapper";function Pk(e){let{components:n,...t}=e;return(0,s.yg)(zk,(0,p.A)({},kk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace at the moment of creation."))}Pk.isMDXComponent=!0;const Ik={toc:[]},Rk="wrapper";function Wk(e){let{components:n,...t}=e;return(0,s.yg)(Rk,(0,p.A)({},Ik,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}Wk.isMDXComponent=!0;const Sk={toc:[]},Bk="wrapper";function Gk(e){let{components:n,...t}=e;return(0,s.yg)(Bk,(0,p.A)({},Sk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Gk.isMDXComponent=!0;const Ek={toc:[]},Ok="wrapper";function Uk(e){let{components:n,...t}=e;return(0,s.yg)(Ok,(0,p.A)({},Ek,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Uk.isMDXComponent=!0;const Fk={toc:[]},Vk="wrapper";function qk(e){let{components:n,...t}=e;return(0,s.yg)(Vk,(0,p.A)({},Fk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for the inspected element."))}qk.isMDXComponent=!0;const jk={toc:[]},Hk="wrapper";function Yk(e){let{components:n,...t}=e;return(0,s.yg)(Hk,(0,p.A)({},jk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element for which to draw an overlay."))}Yk.isMDXComponent=!0;const Qk={toc:[]},$k="wrapper";function Kk(e){let{components:n,...t}=e;return(0,s.yg)($k,(0,p.A)({},Qk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Kk.isMDXComponent=!0;const Jk={toc:[]},Zk="wrapper";function ez(e){let{components:n,...t}=e;return(0,s.yg)(Zk,(0,p.A)({},Jk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}ez.isMDXComponent=!0;const nz={toc:[]},tz="wrapper";function oz(e){let{components:n,...t}=e;return(0,s.yg)(tz,(0,p.A)({},nz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,'This information will be displayed in the "Properties" panel.'))}oz.isMDXComponent=!0;const pz={toc:[]},rz="wrapper";function sz(e){let{components:n,...t}=e;return(0,s.yg)(rz,(0,p.A)({},pz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the attributes of the inspected element."))}sz.isMDXComponent=!0;const cz={toc:[]},az="wrapper";function iz(e){let{components:n,...t}=e;return(0,s.yg)(az,(0,p.A)({},cz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element to inspect."))}iz.isMDXComponent=!0;const lz={toc:[]},uz="wrapper";function mz(e){let{components:n,...t}=e;return(0,s.yg)(uz,(0,p.A)({},lz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a possible element to inspect at a given position."))}mz.isMDXComponent=!0;const yz={toc:[]},dz="wrapper";function hz(e){let{components:n,...t}=e;return(0,s.yg)(dz,(0,p.A)({},yz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x coordinate."))}hz.isMDXComponent=!0;const gz={toc:[]},fz="wrapper";function Dz(e){let{components:n,...t}=e;return(0,s.yg)(fz,(0,p.A)({},gz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y coordinate."))}Dz.isMDXComponent=!0;const Mz={toc:[]},Xz="wrapper";function _z(e){let{components:n,...t}=e;return(0,s.yg)(Xz,(0,p.A)({},Mz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}_z.isMDXComponent=!0;const wz={toc:[]},Tz="wrapper";function Cz(e){let{components:n,...t}=e;return(0,s.yg)(Tz,(0,p.A)({},wz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x coordinate."))}Cz.isMDXComponent=!0;const xz={toc:[]},Az="wrapper";function vz(e){let{components:n,...t}=e;return(0,s.yg)(Az,(0,p.A)({},xz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y coordinate."))}vz.isMDXComponent=!0;const Lz={toc:[]},bz="wrapper";function Nz(e){let{components:n,...t}=e;return(0,s.yg)(bz,(0,p.A)({},Lz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}Nz.isMDXComponent=!0;const kz={toc:[]},zz="wrapper";function Pz(e){let{components:n,...t}=e;return(0,s.yg)(zz,(0,p.A)({},kz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the inspected element is still valid."))}Pz.isMDXComponent=!0;const Iz={toc:[]},Rz="wrapper";function Wz(e){let{components:n,...t}=e;return(0,s.yg)(Rz,(0,p.A)({},Iz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element to validate."))}Wz.isMDXComponent=!0;const Sz={toc:[]},Bz="wrapper";function Gz(e){let{components:n,...t}=e;return(0,s.yg)(Bz,(0,p.A)({},Sz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.yg)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Gz.isMDXComponent=!0;const Ez={toc:[]},Oz="wrapper";function Uz(e){let{components:n,...t}=e;return(0,s.yg)(Oz,(0,p.A)({},Ez,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main interface for scenes."))}Uz.isMDXComponent=!0;const Fz={toc:[]},Vz="wrapper";function qz(e){let{components:n,...t}=e;return(0,s.yg)(Vz,(0,p.A)({},Fz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Will be passed as the second argument to the constructor."))}qz.isMDXComponent=!0;const jz={toc:[]},Hz="wrapper";function Yz(e){let{components:n,...t}=e;return(0,s.yg)(Hz,(0,p.A)({},jz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Name of the scene."))}Yz.isMDXComponent=!0;const Qz={toc:[]},$z="wrapper";function Kz(e){let{components:n,...t}=e;return(0,s.yg)($z,(0,p.A)({},Qz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reference to the project."))}Kz.isMDXComponent=!0;const Jz={toc:[]},Zz="wrapper";function eP(e){let{components:n,...t}=e;return(0,s.yg)(Zz,(0,p.A)({},Jz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}eP.isMDXComponent=!0;const nP={toc:[]},tP="wrapper";function oP(e){let{components:n,...t}=e;return(0,s.yg)(tP,(0,p.A)({},nP,t,{components:n,mdxType:"MDXLayout"}))}oP.isMDXComponent=!0;const pP={toc:[]},rP="wrapper";function sP(e){let{components:n,...t}=e;return(0,s.yg)(rP,(0,p.A)({},pP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}sP.isMDXComponent=!0;const cP={toc:[]},aP="wrapper";function iP(e){let{components:n,...t}=e;return(0,s.yg)(aP,(0,p.A)({},cP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}iP.isMDXComponent=!0;const lP={toc:[]},uP="wrapper";function mP(e){let{components:n,...t}=e;return(0,s.yg)(uP,(0,p.A)({},lP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether experimental features are enabled."))}mP.isMDXComponent=!0;const yP={toc:[]},dP="wrapper";function hP(e){let{components:n,...t}=e;return(0,s.yg)(dP,(0,p.A)({},yP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene starts."))}hP.isMDXComponent=!0;const gP={toc:[]},fP="wrapper";function DP(e){let{components:n,...t}=e;return(0,s.yg)(fP,(0,p.A)({},gP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene ends."))}DP.isMDXComponent=!0;const MP={toc:[]},XP="wrapper";function _P(e){let{components:n,...t}=e;return(0,s.yg)(XP,(0,p.A)({},MP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_P.isMDXComponent=!0;const wP={toc:[]},TP="wrapper";function CP(e){let{components:n,...t}=e;return(0,s.yg)(TP,(0,p.A)({},wP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the cached data changes."))}CP.isMDXComponent=!0;const xP={toc:[]},AP="wrapper";function vP(e){let{components:n,...t}=e;return(0,s.yg)(AP,(0,p.A)({},xP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered after scene is recalculated."))}vP.isMDXComponent=!0;const LP={toc:[]},bP="wrapper";function NP(e){let{components:n,...t}=e;return(0,s.yg)(bP,(0,p.A)({},LP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reloaded."))}NP.isMDXComponent=!0;const kP={toc:[]},zP="wrapper";function PP(e){let{components:n,...t}=e;return(0,s.yg)(zP,(0,p.A)({},kP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}PP.isMDXComponent=!0;const IP={toc:[]},RP="wrapper";function WP(e){let{components:n,...t}=e;return(0,s.yg)(RP,(0,p.A)({},IP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reset."))}WP.isMDXComponent=!0;const SP={toc:[]},BP="wrapper";function GP(e){let{components:n,...t}=e;return(0,s.yg)(BP,(0,p.A)({},SP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene directly before this scene, or null if omitted for performance."))}GP.isMDXComponent=!0;const EP={toc:[]},OP="wrapper";function UP(e){let{components:n,...t}=e;return(0,s.yg)(OP,(0,p.A)({},EP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}UP.isMDXComponent=!0;const FP={toc:[]},VP="wrapper";function qP(e){let{components:n,...t}=e;return(0,s.yg)(VP,(0,p.A)({},FP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}qP.isMDXComponent=!0;const jP={toc:[]},HP="wrapper";function YP(e){let{components:n,...t}=e;return(0,s.yg)(HP,(0,p.A)({},jP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}YP.isMDXComponent=!0;const QP={toc:[]},$P="wrapper";function KP(e){let{components:n,...t}=e;return(0,s.yg)($P,(0,p.A)({},QP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.yg)("inlineCode",{parentName:"a"},"Initial"))," state."))}KP.isMDXComponent=!0;const JP={toc:[]},ZP="wrapper";function eI(e){let{components:n,...t}=e;return(0,s.yg)(ZP,(0,p.A)({},JP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all media assets"))}eI.isMDXComponent=!0;const nI={toc:[]},tI="wrapper";function oI(e){let{components:n,...t}=e;return(0,s.yg)(tI,(0,p.A)({},nI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}oI.isMDXComponent=!0;const pI={toc:[]},rI="wrapper";function sI(e){let{components:n,...t}=e;return(0,s.yg)(rI,(0,p.A)({},pI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real size of this scene."))}sI.isMDXComponent=!0;const cI={toc:[]},aI="wrapper";function iI(e){let{components:n,...t}=e;return(0,s.yg)(aI,(0,p.A)({},cI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually returns ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}iI.isMDXComponent=!0;const lI={toc:[]},uI="wrapper";function mI(e){let{components:n,...t}=e;return(0,s.yg)(uI,(0,p.A)({},lI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the size of this scene."))}mI.isMDXComponent=!0;const yI={toc:[]},dI="wrapper";function hI(e){let{components:n,...t}=e;return(0,s.yg)(dI,(0,p.A)({},yI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}hI.isMDXComponent=!0;const gI={toc:[]},fI="wrapper";function DI(e){let{components:n,...t}=e;return(0,s.yg)(fI,(0,p.A)({},gI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used only by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.yg)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.yg)("p",null,"Should always return ",(0,s.yg)("inlineCode",{parentName:"p"},"true"),"."))}DI.isMDXComponent=!0;const MI={toc:[]},XI="wrapper";function _I(e){let{components:n,...t}=e;return(0,s.yg)(XI,(0,p.A)({},MI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene cached?"))}_I.isMDXComponent=!0;const wI={toc:[]},TI="wrapper";function CI(e){let{components:n,...t}=e;return(0,s.yg)(TI,(0,p.A)({},wI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.yg)("inlineCode",{parentName:"a"},"Finished"))," state?"))}CI.isMDXComponent=!0;const xI={toc:[]},AI="wrapper";function vI(e){let{components:n,...t}=e;return(0,s.yg)(AI,(0,p.A)({},xI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress this scene one frame forward."))}vI.isMDXComponent=!0;const LI={toc:[]},bI="wrapper";function NI(e){let{components:n,...t}=e;return(0,s.yg)(bI,(0,p.A)({},LI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.yg)("p",null,"At the end of execution, this method should set ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.yg)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}NI.isMDXComponent=!0;const kI={toc:[]},zI="wrapper";function PI(e){let{components:n,...t}=e;return(0,s.yg)(zI,(0,p.A)({},kI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Recalculate the scene."))}PI.isMDXComponent=!0;const II={toc:[]},RI="wrapper";function WI(e){let{components:n,...t}=e;return(0,s.yg)(RI,(0,p.A)({},II,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.yg)("inlineCode",{parentName:"a"},"onReloaded")),"."))}WI.isMDXComponent=!0;const SI={toc:[]},BI="wrapper";function GI(e){let{components:n,...t}=e;return(0,s.yg)(BI,(0,p.A)({},SI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reload the scene."))}GI.isMDXComponent=!0;const EI={toc:[]},OI="wrapper";function UI(e){let{components:n,...t}=e;return(0,s.yg)(OI,(0,p.A)({},EI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, an updated version of the description."))}UI.isMDXComponent=!0;const FI={toc:[]},VI="wrapper";function qI(e){let{components:n,...t}=e;return(0,s.yg)(VI,(0,p.A)({},FI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the scene onto a canvas."))}qI.isMDXComponent=!0;const jI={toc:[]},HI="wrapper";function YI(e){let{components:n,...t}=e;return(0,s.yg)(HI,(0,p.A)({},jI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to used when rendering."))}YI.isMDXComponent=!0;const QI={toc:[]},$I="wrapper";function KI(e){let{components:n,...t}=e;return(0,s.yg)($I,(0,p.A)({},QI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset this scene to its initial state."))}KI.isMDXComponent=!0;const JI={toc:[]},ZI="wrapper";function eR(e){let{components:n,...t}=e;return(0,s.yg)(ZI,(0,p.A)({},JI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, the previous scene."))}eR.isMDXComponent=!0;const nR={toc:[]},tR="wrapper";function oR(e){let{components:n,...t}=e;return(0,s.yg)(tR,(0,p.A)({},nR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}oR.isMDXComponent=!0;const pR={toc:[]},rR="wrapper";function sR(e){let{components:n,...t}=e;return(0,s.yg)(rR,(0,p.A)({},pR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each class implementing the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}sR.isMDXComponent=!0;const cR={toc:[]},aR="wrapper";function iR(e){let{components:n,...t}=e;return(0,s.yg)(aR,(0,p.A)({},cR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constructor used when creating new scenes."))}iR.isMDXComponent=!0;const lR={toc:[]},uR="wrapper";function mR(e){let{components:n,...t}=e;return(0,s.yg)(uR,(0,p.A)({},lR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.yg)("inlineCode",{parentName:"a"},"config")),"."))}mR.isMDXComponent=!0;const yR={toc:[]},dR="wrapper";function hR(e){let{components:n,...t}=e;return(0,s.yg)(dR,(0,p.A)({},yR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes a scene exposed by scene files."))}hR.isMDXComponent=!0;const gR={toc:[]},fR="wrapper";function DR(e){let{components:n,...t}=e;return(0,s.yg)(fR,(0,p.A)({},gR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configuration object."))}DR.isMDXComponent=!0;const MR={toc:[]},XR="wrapper";function _R(e){let{components:n,...t}=e;return(0,s.yg)(XR,(0,p.A)({},MR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class used to instantiate the scene."))}_R.isMDXComponent=!0;const wR={toc:[]},TR="wrapper";function CR(e){let{components:n,...t}=e;return(0,s.yg)(TR,(0,p.A)({},wR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}CR.isMDXComponent=!0;const xR={toc:[]},AR="wrapper";function vR(e){let{components:n,...t}=e;return(0,s.yg)(AR,(0,p.A)({},xR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace at the moment of creation."))}vR.isMDXComponent=!0;const LR={toc:[]},bR="wrapper";function NR(e){let{components:n,...t}=e;return(0,s.yg)(bR,(0,p.A)({},LR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}NR.isMDXComponent=!0;const kR={toc:[]},zR="wrapper";function PR(e){let{components:n,...t}=e;return(0,s.yg)(zR,(0,p.A)({},kR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A part of the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.yg)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}PR.isMDXComponent=!0;const IR={toc:[]},RR="wrapper";function WR(e){let{components:n,...t}=e;return(0,s.yg)(RR,(0,p.A)({},IR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}WR.isMDXComponent=!0;const SR={toc:[]},BR="wrapper";function GR(e){let{components:n,...t}=e;return(0,s.yg)(BR,(0,p.A)({},SR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This interface is only useful when a scene uses thread generators to run."))}GR.isMDXComponent=!0;const ER={toc:[]},OR="wrapper";function UR(e){let{components:n,...t}=e;return(0,s.yg)(OR,(0,p.A)({},ER,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}UR.isMDXComponent=!0;const FR={toc:[]},VR="wrapper";function qR(e){let{components:n,...t}=e;return(0,s.yg)(VR,(0,p.A)({},FR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the main thread changes."))}qR.isMDXComponent=!0;const jR={toc:[]},HR="wrapper";function YR(e){let{components:n,...t}=e;return(0,s.yg)(HR,(0,p.A)({},jR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents attributes of an inspected element."))}YR.isMDXComponent=!0;const QR={toc:[]},$R="wrapper";function KR(e){let{components:n,...t}=e;return(0,s.yg)($R,(0,p.A)({},QR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}KR.isMDXComponent=!0;const JR={toc:[]},ZR="wrapper";function eW(e){let{components:n,...t}=e;return(0,s.yg)(ZR,(0,p.A)({},JR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an element to inspect."))}eW.isMDXComponent=!0;const nW={toc:[]},tW="wrapper";function oW(e){let{components:n,...t}=e;return(0,s.yg)(tW,(0,p.A)({},nW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A runtime representation of the scene metadata."))}oW.isMDXComponent=!0;const pW={toc:[]},rW="wrapper";function sW(e){let{components:n,...t}=e;return(0,s.yg)(rW,(0,p.A)({},pW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a runtime representation of the scene metadata."))}sW.isMDXComponent=!0;const cW={toc:[]},aW="wrapper";function iW(e){let{components:n,...t}=e;return(0,s.yg)(aW,(0,p.A)({},cW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}iW.isMDXComponent=!0;const lW={toc:[]},uW="wrapper";function mW(e){let{components:n,...t}=e;return(0,s.yg)(uW,(0,p.A)({},lW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}mW.isMDXComponent=!0;const yW={toc:[]},dW="wrapper";function hW(e){let{components:n,...t}=e;return(0,s.yg)(dW,(0,p.A)({},yW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}hW.isMDXComponent=!0;const gW={toc:[]},fW="wrapper";function DW(e){let{components:n,...t}=e;return(0,s.yg)(fW,(0,p.A)({},gW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}DW.isMDXComponent=!0;const MW={toc:[]},XW="wrapper";function _W(e){let{components:n,...t}=e;return(0,s.yg)(XW,(0,p.A)({},MW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}_W.isMDXComponent=!0;const wW={toc:[]},TW="wrapper";function CW(e){let{components:n,...t}=e;return(0,s.yg)(TW,(0,p.A)({},wW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}CW.isMDXComponent=!0;const xW={toc:[]},AW="wrapper";function vW(e){let{components:n,...t}=e;return(0,s.yg)(AW,(0,p.A)({},xW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}vW.isMDXComponent=!0;const LW={toc:[]},bW="wrapper";function NW(e){let{components:n,...t}=e;return(0,s.yg)(bW,(0,p.A)({},LW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}NW.isMDXComponent=!0;const kW={toc:[]},zW="wrapper";function PW(e){let{components:n,...t}=e;return(0,s.yg)(zW,(0,p.A)({},kW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}PW.isMDXComponent=!0;const IW={toc:[]},RW="wrapper";function WW(e){let{components:n,...t}=e;return(0,s.yg)(RW,(0,p.A)({},IW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}WW.isMDXComponent=!0;const SW={toc:[]},BW="wrapper";function GW(e){let{components:n,...t}=e;return(0,s.yg)(BW,(0,p.A)({},SW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}GW.isMDXComponent=!0;const EW={toc:[]},OW="wrapper";function UW(e){let{components:n,...t}=e;return(0,s.yg)(OW,(0,p.A)({},EW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}UW.isMDXComponent=!0;const FW={toc:[]},VW="wrapper";function qW(e){let{components:n,...t}=e;return(0,s.yg)(VW,(0,p.A)({},FW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}qW.isMDXComponent=!0;const jW={toc:[]},HW="wrapper";function YW(e){let{components:n,...t}=e;return(0,s.yg)(HW,(0,p.A)({},jW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}YW.isMDXComponent=!0;const QW={toc:[]},$W="wrapper";function KW(e){let{components:n,...t}=e;return(0,s.yg)($W,(0,p.A)({},QW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}KW.isMDXComponent=!0;const JW={toc:[]},ZW="wrapper";function eS(e){let{components:n,...t}=e;return(0,s.yg)(ZW,(0,p.A)({},JW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}eS.isMDXComponent=!0;const nS={toc:[]},tS="wrapper";function oS(e){let{components:n,...t}=e;return(0,s.yg)(tS,(0,p.A)({},nS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}oS.isMDXComponent=!0;const pS={toc:[]},rS="wrapper";function sS(e){let{components:n,...t}=e;return(0,s.yg)(rS,(0,p.A)({},pS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}sS.isMDXComponent=!0;const cS={toc:[]},aS="wrapper";function iS(e){let{components:n,...t}=e;return(0,s.yg)(aS,(0,p.A)({},cS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}iS.isMDXComponent=!0;const lS={toc:[]},uS="wrapper";function mS(e){let{components:n,...t}=e;return(0,s.yg)(uS,(0,p.A)({},lS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}mS.isMDXComponent=!0;const yS={toc:[]},dS="wrapper";function hS(e){let{components:n,...t}=e;return(0,s.yg)(dS,(0,p.A)({},yS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}hS.isMDXComponent=!0;const gS={toc:[]},fS="wrapper";function DS(e){let{components:n,...t}=e;return(0,s.yg)(fS,(0,p.A)({},gS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}DS.isMDXComponent=!0;const MS={toc:[]},XS="wrapper";function _S(e){let{components:n,...t}=e;return(0,s.yg)(XS,(0,p.A)({},MS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}_S.isMDXComponent=!0;const wS={toc:[]},TS="wrapper";function CS(e){let{components:n,...t}=e;return(0,s.yg)(TS,(0,p.A)({},wS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}CS.isMDXComponent=!0;const xS={toc:[]},AS="wrapper";function vS(e){let{components:n,...t}=e;return(0,s.yg)(AS,(0,p.A)({},xS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}vS.isMDXComponent=!0;const LS={toc:[]},bS="wrapper";function NS(e){let{components:n,...t}=e;return(0,s.yg)(bS,(0,p.A)({},LS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}NS.isMDXComponent=!0;const kS={toc:[]},zS="wrapper";function PS(e){let{components:n,...t}=e;return(0,s.yg)(zS,(0,p.A)({},kS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}PS.isMDXComponent=!0;const IS={toc:[]},RS="wrapper";function WS(e){let{components:n,...t}=e;return(0,s.yg)(RS,(0,p.A)({},IS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}WS.isMDXComponent=!0;const SS={toc:[]},BS="wrapper";function GS(e){let{components:n,...t}=e;return(0,s.yg)(BS,(0,p.A)({},SS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}GS.isMDXComponent=!0;const ES={toc:[]},OS="wrapper";function US(e){let{components:n,...t}=e;return(0,s.yg)(OS,(0,p.A)({},ES,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween back to the original value."))}US.isMDXComponent=!0;const FS={toc:[]},VS="wrapper";function qS(e){let{components:n,...t}=e;return(0,s.yg)(VS,(0,p.A)({},FS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the tween."))}qS.isMDXComponent=!0;const jS={toc:[]},HS="wrapper";function YS(e){let{components:n,...t}=e;return(0,s.yg)(HS,(0,p.A)({},jS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function of the tween."))}YS.isMDXComponent=!0;const QS={toc:[]},$S="wrapper";function KS(e){let{components:n,...t}=e;return(0,s.yg)($S,(0,p.A)({},QS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interpolation function of the tween."))}KS.isMDXComponent=!0;const JS={toc:[]},ZS="wrapper";function eB(e){let{components:n,...t}=e;return(0,s.yg)(ZS,(0,p.A)({},JS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback."))}eB.isMDXComponent=!0;const nB={toc:[]},tB="wrapper";function oB(e){let{components:n,...t}=e;return(0,s.yg)(tB,(0,p.A)({},nB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}oB.isMDXComponent=!0;const pB={toc:[]},rB="wrapper";function sB(e){let{components:n,...t}=e;return(0,s.yg)(rB,(0,p.A)({},pB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given task."))}sB.isMDXComponent=!0;const cB={toc:[]},aB="wrapper";function iB(e){let{components:n,...t}=e;return(0,s.yg)(aB,(0,p.A)({},cB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator to run."))}iB.isMDXComponent=!0;const lB={toc:[]},uB="wrapper";function mB(e){let{components:n,...t}=e;return(0,s.yg)(uB,(0,p.A)({},lB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween to the specified value."))}mB.isMDXComponent=!0;const yB={toc:[]},dB="wrapper";function hB(e){let{components:n,...t}=e;return(0,s.yg)(dB,(0,p.A)({},yB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for the specified duration."))}hB.isMDXComponent=!0;const gB={toc:[]},fB="wrapper";function DB(e){let{components:n,...t}=e;return(0,s.yg)(fB,(0,p.A)({},gB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration to wait."))}DB.isMDXComponent=!0;const MB={toc:[]},XB="wrapper";function _B(e){let{components:n,...t}=e;return(0,s.yg)(XB,(0,p.A)({},MB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Thread management."))}_B.isMDXComponent=!0;const wB={toc:[]},TB="wrapper";function CB(e){let{components:n,...t}=e;return(0,s.yg)(TB,(0,p.A)({},wB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.yg)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}CB.isMDXComponent=!0;const xB={toc:[]},AB="wrapper";function vB(e){let{components:n,...t}=e;return(0,s.yg)(AB,(0,p.A)({},xB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A class representing an individual thread."))}vB.isMDXComponent=!0;const LB={toc:[]},bB="wrapper";function NB(e){let{components:n,...t}=e;return(0,s.yg)(bB,(0,p.A)({},LB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator wrapped by this thread."))}NB.isMDXComponent=!0;const kB={toc:[]},zB="wrapper";function PB(e){let{components:n,...t}=e;return(0,s.yg)(zB,(0,p.A)({},kB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator wrapped by this thread."))}PB.isMDXComponent=!0;const IB={toc:[]},RB="wrapper";function WB(e){let{components:n,...t}=e;return(0,s.yg)(RB,(0,p.A)({},IB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.yg)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}WB.isMDXComponent=!0;const SB={toc:[]},BB="wrapper";function GB(e){let{components:n,...t}=e;return(0,s.yg)(BB,(0,p.A)({},SB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current time of this thread."))}GB.isMDXComponent=!0;const EB={toc:[]},OB="wrapper";function UB(e){let{components:n,...t}=e;return(0,s.yg)(OB,(0,p.A)({},EB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The next value to be passed to the wrapped generator."))}UB.isMDXComponent=!0;const FB={toc:[]},VB="wrapper";function qB(e){let{components:n,...t}=e;return(0,s.yg)(VB,(0,p.A)({},FB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if this thread or any of its ancestors has been canceled."))}qB.isMDXComponent=!0;const jB={toc:[]},HB="wrapper";function YB(e){let{components:n,...t}=e;return(0,s.yg)(HB,(0,p.A)({},jB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.yg)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}YB.isMDXComponent=!0;const QB={toc:[]},$B="wrapper";function KB(e){let{components:n,...t}=e;return(0,s.yg)($B,(0,p.A)({},QB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The fixed time of this thread."))}KB.isMDXComponent=!0;const JB={toc:[]},ZB="wrapper";function eG(e){let{components:n,...t}=e;return(0,s.yg)(ZB,(0,p.A)({},JB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress the wrapped generator once."))}eG.isMDXComponent=!0;const nG={toc:[]},tG="wrapper";function oG(e){let{components:n,...t}=e;return(0,s.yg)(tG,(0,p.A)({},nG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the thread for the next update cycle."))}oG.isMDXComponent=!0;const pG={toc:[]},rG="wrapper";function sG(e){let{components:n,...t}=e;return(0,s.yg)(rG,(0,p.A)({},pG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delta time of the next cycle."))}sG.isMDXComponent=!0;const cG={toc:[]},aG="wrapper";function iG(e){let{components:n,...t}=e;return(0,s.yg)(aG,(0,p.A)({},cG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a normal function that returns a generator."))}iG.isMDXComponent=!0;const lG={toc:[]},uG="wrapper";function mG(e){let{components:n,...t}=e;return(0,s.yg)(uG,(0,p.A)({},lG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.yg)("p",null,"Progress to the next frame:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.yg)("p",null,"Run another generator synchronously:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.yg)("p",null,"Run another generator concurrently:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.yg)("p",null,"Await a Promise:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}mG.isMDXComponent=!0;const yG={toc:[]},dG="wrapper";function hG(e){let{components:n,...t}=e;return(0,s.yg)(dG,(0,p.A)({},yG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}hG.isMDXComponent=!0;const gG={toc:[]},fG="wrapper";function DG(e){let{components:n,...t}=e;return(0,s.yg)(fG,(0,p.A)({},gG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Cancel all listed tasks."),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}DG.isMDXComponent=!0;const MG={toc:[]},XG="wrapper";function _G(e){let{components:n,...t}=e;return(0,s.yg)(XG,(0,p.A)({},MG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to cancel."))}_G.isMDXComponent=!0;const wG={toc:[]},TG="wrapper";function CG(e){let{components:n,...t}=e;return(0,s.yg)(TG,(0,p.A)({},wG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the given value is a ","[Promise][promise]","."))}CG.isMDXComponent=!0;const xG={toc:[]},AG="wrapper";function vG(e){let{components:n,...t}=e;return(0,s.yg)(AG,(0,p.A)({},xG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A possible ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}vG.isMDXComponent=!0;const LG={toc:[]},bG="wrapper";function NG(e){let{components:n,...t}=e;return(0,s.yg)(bG,(0,p.A)({},LG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the given value is a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.yg)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}NG.isMDXComponent=!0;const kG={toc:[]},zG="wrapper";function PG(e){let{components:n,...t}=e;return(0,s.yg)(zG,(0,p.A)({},kG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A possible thread ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.yg)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}PG.isMDXComponent=!0;const IG={toc:[]},RG="wrapper";function WG(e){let{components:n,...t}=e;return(0,s.yg)(RG,(0,p.A)({},IG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}WG.isMDXComponent=!0;const SG={toc:[]},BG="wrapper";function GG(e){let{components:n,...t}=e;return(0,s.yg)(BG,(0,p.A)({},SG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause the current generator until all listed tasks are finished."))}GG.isMDXComponent=!0;const EG={toc:[]},OG="wrapper";function UG(e){let{components:n,...t}=e;return(0,s.yg)(OG,(0,p.A)({},EG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to join."))}UG.isMDXComponent=!0;const FG={toc:[]},VG="wrapper";function qG(e){let{components:n,...t}=e;return(0,s.yg)(VG,(0,p.A)({},FG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}qG.isMDXComponent=!0;const jG={toc:[]},HG="wrapper";function YG(e){let{components:n,...t}=e;return(0,s.yg)(HG,(0,p.A)({},jG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause the current generator until listed tasks are finished."))}YG.isMDXComponent=!0;const QG={toc:[]},$G="wrapper";function KG(e){let{components:n,...t}=e;return(0,s.yg)($G,(0,p.A)({},QG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether we should wait for all tasks or for at least one."))}KG.isMDXComponent=!0;const JG={toc:[]},ZG="wrapper";function eE(e){let{components:n,...t}=e;return(0,s.yg)(ZG,(0,p.A)({},JG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to join."))}eE.isMDXComponent=!0;const nE={toc:[]},tE="wrapper";function oE(e){let{components:n,...t}=e;return(0,s.yg)(tE,(0,p.A)({},nE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using an existing task:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"spawn(rect().opacity(1, 1));\n")),(0,s.yg)("p",null,"Using a generator function:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"spawn(function* () {\n  yield* rect().opacity(1, 1);\n  yield* waitFor('click');\n  yield* rect().opacity(0, 1);\n});\n")),(0,s.yg)("p",null,"Await the spawned task:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = spawn(rect().opacity(1, 1));\n// do some other things\nyield* join(task); // await the task\n")))}oE.isMDXComponent=!0;const pE={toc:[]},rE="wrapper";function sE(e){let{components:n,...t}=e;return(0,s.yg)(rE,(0,p.A)({},pE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given task concurrently."))}sE.isMDXComponent=!0;const cE={toc:[]},aE="wrapper";function iE(e){let{components:n,...t}=e;return(0,s.yg)(aE,(0,p.A)({},cE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a generator function or a task to run."))}iE.isMDXComponent=!0;const lE={toc:[]},uE="wrapper";function mE(e){let{components:n,...t}=e;return(0,s.yg)(uE,(0,p.A)({},lE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"From the perspective of the external generator, ",(0,s.yg)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.yg)("inlineCode",{parentName:"p"},"threads")," generator."))}mE.isMDXComponent=!0;const yE={toc:[]},dE="wrapper";function hE(e){let{components:n,...t}=e;return(0,s.yg)(dE,(0,p.A)({},yE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}hE.isMDXComponent=!0;const gE={toc:[]},fE="wrapper";function DE(e){let{components:n,...t}=e;return(0,s.yg)(fE,(0,p.A)({},gE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a context in which generators can be run concurrently."))}DE.isMDXComponent=!0;const ME={toc:[]},XE="wrapper";function _E(e){let{components:n,...t}=e;return(0,s.yg)(XE,(0,p.A)({},ME,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns the generator to run."))}_E.isMDXComponent=!0;const wE={toc:[]},TE="wrapper";function CE(e){let{components:n,...t}=e;return(0,s.yg)(TE,(0,p.A)({},wE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}CE.isMDXComponent=!0;const xE={toc:[]},AE="wrapper";function vE(e){let{components:n,...t}=e;return(0,s.yg)(AE,(0,p.A)({},xE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transitions between scenes."))}vE.isMDXComponent=!0;const LE={toc:[]},bE="wrapper";function NE(e){let{components:n,...t}=e;return(0,s.yg)(bE,(0,p.A)({},LE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that fades between the scenes."))}NE.isMDXComponent=!0;const kE={toc:[]},zE="wrapper";function PE(e){let{components:n,...t}=e;return(0,s.yg)(zE,(0,p.A)({},kE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}PE.isMDXComponent=!0;const IE={toc:[]},RE="wrapper";function WE(e){let{components:n,...t}=e;return(0,s.yg)(RE,(0,p.A)({},IE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that slides the scene in the given direction."))}WE.isMDXComponent=!0;const SE={toc:[]},BE="wrapper";function GE(e){let{components:n,...t}=e;return(0,s.yg)(BE,(0,p.A)({},SE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The direction in which to slide."))}GE.isMDXComponent=!0;const EE={toc:[]},OE="wrapper";function UE(e){let{components:n,...t}=e;return(0,s.yg)(OE,(0,p.A)({},EE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}UE.isMDXComponent=!0;const FE={toc:[]},VE="wrapper";function qE(e){let{components:n,...t}=e;return(0,s.yg)(VE,(0,p.A)({},FE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that slides the scene towards the given origin."))}qE.isMDXComponent=!0;const jE={toc:[]},HE="wrapper";function YE(e){let{components:n,...t}=e;return(0,s.yg)(HE,(0,p.A)({},jE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The origin towards which to slide."))}YE.isMDXComponent=!0;const QE={toc:[]},$E="wrapper";function KE(e){let{components:n,...t}=e;return(0,s.yg)($E,(0,p.A)({},QE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}KE.isMDXComponent=!0;const JE={toc:[]},ZE="wrapper";function eO(e){let{components:n,...t}=e;return(0,s.yg)(ZE,(0,p.A)({},JE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}eO.isMDXComponent=!0;const nO={toc:[]},tO="wrapper";function oO(e){let{components:n,...t}=e;return(0,s.yg)(tO,(0,p.A)({},nO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to use before the current scene is rendered."))}oO.isMDXComponent=!0;const pO={toc:[]},rO="wrapper";function sO(e){let{components:n,...t}=e;return(0,s.yg)(rO,(0,p.A)({},pO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to use before the previous scene is rendered."))}sO.isMDXComponent=!0;const cO={toc:[]},aO="wrapper";function iO(e){let{components:n,...t}=e;return(0,s.yg)(aO,(0,p.A)({},cO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the previous scene should be rendered on top."))}iO.isMDXComponent=!0;const lO={toc:[]},uO="wrapper";function mO(e){let{components:n,...t}=e;return(0,s.yg)(uO,(0,p.A)({},lO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that zooms in on a given area of the scene."))}mO.isMDXComponent=!0;const yO={toc:[]},dO="wrapper";function hO(e){let{components:n,...t}=e;return(0,s.yg)(dO,(0,p.A)({},yO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The area on which to zoom in."))}hO.isMDXComponent=!0;const gO={toc:[]},fO="wrapper";function DO(e){let{components:n,...t}=e;return(0,s.yg)(fO,(0,p.A)({},gO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}DO.isMDXComponent=!0;const MO={toc:[]},XO="wrapper";function _O(e){let{components:n,...t}=e;return(0,s.yg)(XO,(0,p.A)({},MO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that zooms out from a given area of the scene."))}_O.isMDXComponent=!0;const wO={toc:[]},TO="wrapper";function CO(e){let{components:n,...t}=e;return(0,s.yg)(TO,(0,p.A)({},wO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The area from which to zoom out."))}CO.isMDXComponent=!0;const xO={toc:[]},AO="wrapper";function vO(e){let{components:n,...t}=e;return(0,s.yg)(AO,(0,p.A)({},xO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vO.isMDXComponent=!0;const LO={toc:[]},bO="wrapper";function NO(e){let{components:n,...t}=e;return(0,s.yg)(bO,(0,p.A)({},LO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolation and timing of tweens."))}NO.isMDXComponent=!0;const kO={toc:[]},zO="wrapper";function PO(e){let{components:n,...t}=e;return(0,s.yg)(zO,(0,p.A)({},kO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Any old key that is missing in ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.yg)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"})))}PO.isMDXComponent=!0;const IO={toc:[]},RO="wrapper";function WO(e){let{components:n,...t}=e;return(0,s.yg)(RO,(0,p.A)({},IO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A value matching the structure of from and to."))}WO.isMDXComponent=!0;const SO={toc:[]},BO="wrapper";function GO(e){let{components:n,...t}=e;return(0,s.yg)(BO,(0,p.A)({},SO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}GO.isMDXComponent=!0;const EO={toc:[]},OO="wrapper";function UO(e){let{components:n,...t}=e;return(0,s.yg)(OO,(0,p.A)({},EO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 0."))}UO.isMDXComponent=!0;const FO={toc:[]},VO="wrapper";function qO(e){let{components:n,...t}=e;return(0,s.yg)(VO,(0,p.A)({},FO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 1."))}qO.isMDXComponent=!0;const jO={toc:[]},HO="wrapper";function YO(e){let{components:n,...t}=e;return(0,s.yg)(HO,(0,p.A)({},jO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}YO.isMDXComponent=!0;const QO={toc:[]},$O="wrapper";function KO(e){let{components:n,...t}=e;return(0,s.yg)($O,(0,p.A)({},QO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A value matching the structure of from and to."))}KO.isMDXComponent=!0;const JO={toc:[]},ZO="wrapper";function eU(e){let{components:n,...t}=e;return(0,s.yg)(ZO,(0,p.A)({},JO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}eU.isMDXComponent=!0;const nU={toc:[]},tU="wrapper";function oU(e){let{components:n,...t}=e;return(0,s.yg)(tU,(0,p.A)({},nU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 0."))}oU.isMDXComponent=!0;const pU={toc:[]},rU="wrapper";function sU(e){let{components:n,...t}=e;return(0,s.yg)(rU,(0,p.A)({},pU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 1."))}sU.isMDXComponent=!0;const cU={toc:[]},aU="wrapper";function iU(e){let{components:n,...t}=e;return(0,s.yg)(aU,(0,p.A)({},cU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}iU.isMDXComponent=!0;const lU={toc:[]},uU="wrapper";function mU(e){let{components:n,...t}=e;return(0,s.yg)(uU,(0,p.A)({},lU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Complex types used in animations."))}mU.isMDXComponent=!0;const yU={toc:[]},dU="wrapper";function hU(e){let{components:n,...t}=e;return(0,s.yg)(dU,(0,p.A)({},yU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/BBox#expand"},(0,s.yg)("inlineCode",{parentName:"a"},"expand"))," instead."))}hU.isMDXComponent=!0;const gU={toc:[]},fU="wrapper";function DU(e){let{components:n,...t}=e;return(0,s.yg)(fU,(0,p.A)({},gU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Expand the bounding box to accommodate the given spacing."))}DU.isMDXComponent=!0;const MU={toc:[]},XU="wrapper";function _U(e){let{components:n,...t}=e;return(0,s.yg)(XU,(0,p.A)({},MU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to expand the bounding box by."))}_U.isMDXComponent=!0;const wU={toc:[]},TU="wrapper";function CU(e){let{components:n,...t}=e;return(0,s.yg)(TU,(0,p.A)({},wU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Expand the bounding box to accommodate the given spacing."))}CU.isMDXComponent=!0;const xU={toc:[]},AU="wrapper";function vU(e){let{components:n,...t}=e;return(0,s.yg)(AU,(0,p.A)({},xU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to expand the bounding box by."))}vU.isMDXComponent=!0;const LU={toc:[]},bU="wrapper";function NU(e){let{components:n,...t}=e;return(0,s.yg)(bU,(0,p.A)({},LU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.yg)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.yg)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.yg)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.yg)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.yg)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.yg)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}NU.isMDXComponent=!0;const kU={toc:[]},zU="wrapper";function PU(e){let{components:n,...t}=e;return(0,s.yg)(zU,(0,p.A)({},kU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the determinant of the matrix."))}PU.isMDXComponent=!0;const IU={toc:[]},RU="wrapper";function WU(e){let{components:n,...t}=e;return(0,s.yg)(RU,(0,p.A)({},IU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.yg)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", instead."))}WU.isMDXComponent=!0;const SU={toc:[]},BU="wrapper";function GU(e){let{components:n,...t}=e;return(0,s.yg)(BU,(0,p.A)({},SU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}GU.isMDXComponent=!0;const EU={toc:[]},OU="wrapper";function UU(e){let{components:n,...t}=e;return(0,s.yg)(OU,(0,p.A)({},EU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the inverse of the matrix."))}UU.isMDXComponent=!0;const FU={toc:[]},VU="wrapper";function qU(e){let{components:n,...t}=e;return(0,s.yg)(VU,(0,p.A)({},FU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}qU.isMDXComponent=!0;const jU={toc:[]},HU="wrapper";function YU(e){let{components:n,...t}=e;return(0,s.yg)(HU,(0,p.A)({},jU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}YU.isMDXComponent=!0;const QU={toc:[]},$U="wrapper";function KU(e){let{components:n,...t}=e;return(0,s.yg)($U,(0,p.A)({},QU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the provided matrix to this matrix."))}KU.isMDXComponent=!0;const JU={toc:[]},ZU="wrapper";function eF(e){let{components:n,...t}=e;return(0,s.yg)(ZU,(0,p.A)({},JU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to add"))}eF.isMDXComponent=!0;const nF={toc:[]},tF="wrapper";function oF(e){let{components:n,...t}=e;return(0,s.yg)(tF,(0,p.A)({},nF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}oF.isMDXComponent=!0;const pF={toc:[]},rF="wrapper";function sF(e){let{components:n,...t}=e;return(0,s.yg)(rF,(0,p.A)({},pF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}sF.isMDXComponent=!0;const cF={toc:[]},aF="wrapper";function iF(e){let{components:n,...t}=e;return(0,s.yg)(aF,(0,p.A)({},cF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the component vector to retrieve."))}iF.isMDXComponent=!0;const lF={toc:[]},uF="wrapper";function mF(e){let{components:n,...t}=e;return(0,s.yg)(uF,(0,p.A)({},lF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}mF.isMDXComponent=!0;const yF={toc:[]},dF="wrapper";function hF(e){let{components:n,...t}=e;return(0,s.yg)(dF,(0,p.A)({},yF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}hF.isMDXComponent=!0;const gF={toc:[]},fF="wrapper";function DF(e){let{components:n,...t}=e;return(0,s.yg)(fF,(0,p.A)({},gF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}DF.isMDXComponent=!0;const MF={toc:[]},XF="wrapper";function _F(e){let{components:n,...t}=e;return(0,s.yg)(XF,(0,p.A)({},MF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to multiply with"))}_F.isMDXComponent=!0;const wF={toc:[]},TF="wrapper";function CF(e){let{components:n,...t}=e;return(0,s.yg)(TF,(0,p.A)({},wF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}CF.isMDXComponent=!0;const xF={toc:[]},AF="wrapper";function vF(e){let{components:n,...t}=e;return(0,s.yg)(AF,(0,p.A)({},xF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}vF.isMDXComponent=!0;const LF={toc:[]},bF="wrapper";function NF(e){let{components:n,...t}=e;return(0,s.yg)(bF,(0,p.A)({},LF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value by which to scale each term"))}NF.isMDXComponent=!0;const kF={toc:[]},zF="wrapper";function PF(e){let{components:n,...t}=e;return(0,s.yg)(zF,(0,p.A)({},kF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}PF.isMDXComponent=!0;const IF={toc:[]},RF="wrapper";function WF(e){let{components:n,...t}=e;return(0,s.yg)(RF,(0,p.A)({},IF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}WF.isMDXComponent=!0;const SF={toc:[]},BF="wrapper";function GF(e){let{components:n,...t}=e;return(0,s.yg)(BF,(0,p.A)({},SF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}GF.isMDXComponent=!0;const EF={toc:[]},OF="wrapper";function UF(e){let{components:n,...t}=e;return(0,s.yg)(OF,(0,p.A)({},EF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The angle by which to rotate the matrix."))}UF.isMDXComponent=!0;const FF={toc:[]},VF="wrapper";function qF(e){let{components:n,...t}=e;return(0,s.yg)(VF,(0,p.A)({},FF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the angle is provided in degrees."))}qF.isMDXComponent=!0;const jF={toc:[]},HF="wrapper";function YF(e){let{components:n,...t}=e;return(0,s.yg)(HF,(0,p.A)({},jF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}YF.isMDXComponent=!0;const QF={toc:[]},$F="wrapper";function KF(e){let{components:n,...t}=e;return(0,s.yg)($F,(0,p.A)({},QF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}KF.isMDXComponent=!0;const JF={toc:[]},ZF="wrapper";function eV(e){let{components:n,...t}=e;return(0,s.yg)(ZF,(0,p.A)({},JF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the row to retrieve."))}eV.isMDXComponent=!0;const nV={toc:[]},tV="wrapper";function oV(e){let{components:n,...t}=e;return(0,s.yg)(tV,(0,p.A)({},nV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}oV.isMDXComponent=!0;const pV={toc:[]},rV="wrapper";function sV(e){let{components:n,...t}=e;return(0,s.yg)(rV,(0,p.A)({},pV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}sV.isMDXComponent=!0;const cV={toc:[]},aV="wrapper";function iV(e){let{components:n,...t}=e;return(0,s.yg)(aV,(0,p.A)({},cV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scale the x and y component vectors of the matrix."))}iV.isMDXComponent=!0;const lV={toc:[]},uV="wrapper";function mV(e){let{components:n,...t}=e;return(0,s.yg)(uV,(0,p.A)({},lV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The factor by which to scale the matrix"))}mV.isMDXComponent=!0;const yV={toc:[]},dV="wrapper";function hV(e){let{components:n,...t}=e;return(0,s.yg)(dV,(0,p.A)({},yV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}hV.isMDXComponent=!0;const gV={toc:[]},fV="wrapper";function DV(e){let{components:n,...t}=e;return(0,s.yg)(fV,(0,p.A)({},gV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}DV.isMDXComponent=!0;const MV={toc:[]},XV="wrapper";function _V(e){let{components:n,...t}=e;return(0,s.yg)(XV,(0,p.A)({},MV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subtract the provided matrix from this matrix."))}_V.isMDXComponent=!0;const wV={toc:[]},TV="wrapper";function CV(e){let{components:n,...t}=e;return(0,s.yg)(TV,(0,p.A)({},wV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to subract"))}CV.isMDXComponent=!0;const xV={toc:[]},AV="wrapper";function vV(e){let{components:n,...t}=e;return(0,s.yg)(AV,(0,p.A)({},xV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}vV.isMDXComponent=!0;const LV={toc:[]},bV="wrapper";function NV(e){let{components:n,...t}=e;return(0,s.yg)(bV,(0,p.A)({},LV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}NV.isMDXComponent=!0;const kV={toc:[]},zV="wrapper";function PV(e){let{components:n,...t}=e;return(0,s.yg)(zV,(0,p.A)({},kV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Translate the matrix by the dimensions of the provided vector."))}PV.isMDXComponent=!0;const IV={toc:[]},RV="wrapper";function WV(e){let{components:n,...t}=e;return(0,s.yg)(RV,(0,p.A)({},IV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector by which to translate the matrix"))}WV.isMDXComponent=!0;const SV={toc:[]},BV="wrapper";function GV(e){let{components:n,...t}=e;return(0,s.yg)(BV,(0,p.A)({},SV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a two-dimensional vector."))}GV.isMDXComponent=!0;const EV={toc:[]},OV="wrapper";function UV(e){let{components:n,...t}=e;return(0,s.yg)(OV,(0,p.A)({},EV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(0, 1)")))}UV.isMDXComponent=!0;const FV={toc:[]},VV="wrapper";function qV(e){let{components:n,...t}=e;return(0,s.yg)(VV,(0,p.A)({},FV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(-1, 1)")))}qV.isMDXComponent=!0;const jV={toc:[]},HV="wrapper";function YV(e){let{components:n,...t}=e;return(0,s.yg)(HV,(0,p.A)({},jV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(1, 1)")))}YV.isMDXComponent=!0;const QV={toc:[]},$V="wrapper";function KV(e){let{components:n,...t}=e;return(0,s.yg)($V,(0,p.A)({},QV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(0, -1)")))}KV.isMDXComponent=!0;const JV={toc:[]},ZV="wrapper";function eq(e){let{components:n,...t}=e;return(0,s.yg)(ZV,(0,p.A)({},JV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(-1, -1)")))}eq.isMDXComponent=!0;const nq={toc:[]},tq="wrapper";function oq(e){let{components:n,...t}=e;return(0,s.yg)(tq,(0,p.A)({},nq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(1, -1)")))}oq.isMDXComponent=!0;const pq={toc:[]},rq="wrapper";function sq(e){let{components:n,...t}=e;return(0,s.yg)(rq,(0,p.A)({},pq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned angle will be between -180 and 180 degrees."))}sq.isMDXComponent=!0;const cq={toc:[]},aq="wrapper";function iq(e){let{components:n,...t}=e;return(0,s.yg)(aq,(0,p.A)({},cq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}iq.isMDXComponent=!0;const lq={toc:[]},uq="wrapper";function mq(e){let{components:n,...t}=e;return(0,s.yg)(uq,(0,p.A)({},lq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}mq.isMDXComponent=!0;const yq={toc:[]},dq="wrapper";function hq(e){let{components:n,...t}=e;return(0,s.yg)(dq,(0,p.A)({},yq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.yg)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}hq.isMDXComponent=!0;const gq={toc:[]},fq="wrapper";function Dq(e){let{components:n,...t}=e;return(0,s.yg)(fq,(0,p.A)({},gq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if two vectors are equal to each other."))}Dq.isMDXComponent=!0;const Mq={toc:[]},Xq="wrapper";function _q(e){let{components:n,...t}=e;return(0,s.yg)(Xq,(0,p.A)({},Mq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector to compare."))}_q.isMDXComponent=!0;const wq={toc:[]},Tq="wrapper";function Cq(e){let{components:n,...t}=e;return(0,s.yg)(Tq,(0,p.A)({},wq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The allowed error threshold when comparing the vectors."))}Cq.isMDXComponent=!0;const xq={toc:[]},Aq="wrapper";function vq(e){let{components:n,...t}=e;return(0,s.yg)(Aq,(0,p.A)({},xq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.yg)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}vq.isMDXComponent=!0;const Lq={toc:[]},bq="wrapper";function Nq(e){let{components:n,...t}=e;return(0,s.yg)(bq,(0,p.A)({},Lq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if two vectors are exactly equal to each other."))}Nq.isMDXComponent=!0;const kq={toc:[]},zq="wrapper";function Pq(e){let{components:n,...t}=e;return(0,s.yg)(zq,(0,p.A)({},kq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector to compare."))}Pq.isMDXComponent=!0;const Iq={toc:[]},Rq="wrapper";function Wq(e){let{components:n,...t}=e;return(0,s.yg)(Rq,(0,p.A)({},Iq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotates the vector around a point by the provided angle."))}Wq.isMDXComponent=!0;const Sq={toc:[]},Bq="wrapper";function Gq(e){let{components:n,...t}=e;return(0,s.yg)(Bq,(0,p.A)({},Sq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The angle by which to rotate in degrees."))}Gq.isMDXComponent=!0;const Eq={toc:[]},Oq="wrapper";function Uq(e){let{components:n,...t}=e;return(0,s.yg)(Oq,(0,p.A)({},Eq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}Uq.isMDXComponent=!0;const Fq={toc:[]},Vq="wrapper";function qq(e){let{components:n,...t}=e;return(0,s.yg)(Vq,(0,p.A)({},Fq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Helper function to create a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.yg)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}qq.isMDXComponent=!0;const jq={toc:[]},Hq="wrapper";function Yq(e){let{components:n,...t}=e;return(0,s.yg)(Hq,(0,p.A)({},jq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the point should get rotated\ncounterclockwise."))}Yq.isMDXComponent=!0;const Qq={toc:[]},$q="wrapper";function Kq(e){let{components:n,...t}=e;return(0,s.yg)($q,(0,p.A)({},Qq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}Kq.isMDXComponent=!0;const Jq={toc:[]},Zq="wrapper";function ej(e){let{components:n,...t}=e;return(0,s.yg)(Zq,(0,p.A)({},Jq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned angle will be between -180 and 180 degrees."))}ej.isMDXComponent=!0;const nj={toc:[]},tj="wrapper";function oj(e){let{components:n,...t}=e;return(0,s.yg)(tj,(0,p.A)({},nj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}oj.isMDXComponent=!0;const pj={toc:[]},rj="wrapper";function sj(e){let{components:n,...t}=e;return(0,s.yg)(rj,(0,p.A)({},pj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x component of the vector."))}sj.isMDXComponent=!0;const cj={toc:[]},aj="wrapper";function ij(e){let{components:n,...t}=e;return(0,s.yg)(aj,(0,p.A)({},cj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y component of the vector."))}ij.isMDXComponent=!0;const lj={toc:[]},uj="wrapper";function mj(e){let{components:n,...t}=e;return(0,s.yg)(uj,(0,p.A)({},lj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This function is useful when used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.yg)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}mj.isMDXComponent=!0;const yj={toc:[]},dj="wrapper";function hj(e){let{components:n,...t}=e;return(0,s.yg)(dj,(0,p.A)({},yj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Animating an object in a circle around the origin"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}hj.isMDXComponent=!0;const gj={toc:[]},fj="wrapper";function Dj(e){let{components:n,...t}=e;return(0,s.yg)(fj,(0,p.A)({},gj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotating an object around the point ",(0,s.yg)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}Dj.isMDXComponent=!0;const Mj={toc:[]},Xj="wrapper";function _j(e){let{components:n,...t}=e;return(0,s.yg)(Xj,(0,p.A)({},Mj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}_j.isMDXComponent=!0;const wj={toc:[]},Tj="wrapper";function Cj(e){let{components:n,...t}=e;return(0,s.yg)(Tj,(0,p.A)({},wj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}Cj.isMDXComponent=!0;const xj={toc:[]},Aj="wrapper";function vj(e){let{components:n,...t}=e;return(0,s.yg)(Aj,(0,p.A)({},xj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting vector."))}vj.isMDXComponent=!0;const Lj={toc:[]},bj="wrapper";function Nj(e){let{components:n,...t}=e;return(0,s.yg)(bj,(0,p.A)({},Lj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The target vector."))}Nj.isMDXComponent=!0;const kj={toc:[]},zj="wrapper";function Pj(e){let{components:n,...t}=e;return(0,s.yg)(zj,(0,p.A)({},kj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t-value of the interpolation."))}Pj.isMDXComponent=!0;const Ij={toc:[]},Rj="wrapper";function Wj(e){let{components:n,...t}=e;return(0,s.yg)(Rj,(0,p.A)({},Ij,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.yg)("inlineCode",{parentName:"p"},"false"),"."))}Wj.isMDXComponent=!0;const Sj={toc:[]},Bj="wrapper";function Gj(e){let{components:n,...t}=e;return(0,s.yg)(Bj,(0,p.A)({},Sj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}Gj.isMDXComponent=!0;const Ej={toc:[]},Oj="wrapper";function Uj(e){let{components:n,...t}=e;return(0,s.yg)(Oj,(0,p.A)({},Ej,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}Uj.isMDXComponent=!0;const Fj={toc:[]},Vj="wrapper";function qj(e){let{components:n,...t}=e;return(0,s.yg)(Vj,(0,p.A)({},Fj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x component of the vector."))}qj.isMDXComponent=!0;const jj={toc:[]},Hj="wrapper";function Yj(e){let{components:n,...t}=e;return(0,s.yg)(Hj,(0,p.A)({},jj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y component of the vector."))}Yj.isMDXComponent=!0;const Qj={toc:[]},$j="wrapper";function Kj(e){let{components:n,...t}=e;return(0,s.yg)($j,(0,p.A)({},Qj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same class as the one created by\n",(0,s.yg)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.yg)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}Kj.isMDXComponent=!0;const Jj={toc:[]},Zj="wrapper";function eH(e){let{components:n,...t}=e;return(0,s.yg)(Zj,(0,p.A)({},Jj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a color."))}eH.isMDXComponent=!0;const nH={toc:[]},tH="wrapper";function oH(e){let{components:n,...t}=e;return(0,s.yg)(tH,(0,p.A)({},nH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}oH.isMDXComponent=!0;const pH={toc:[]},rH="wrapper";function sH(e){let{components:n,...t}=e;return(0,s.yg)(rH,(0,p.A)({},pH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert the given origin to a vector representing its offset."))}sH.isMDXComponent=!0;const cH={toc:[]},aH="wrapper";function iH(e){let{components:n,...t}=e;return(0,s.yg)(aH,(0,p.A)({},cH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The origin to convert."))}iH.isMDXComponent=!0;const lH={toc:[]},uH="wrapper";function mH(e){let{components:n,...t}=e;return(0,s.yg)(uH,(0,p.A)({},lH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"General utilities and helper functions."))}mH.isMDXComponent=!0;const yH={toc:[]},dH="wrapper";function hH(e){let{components:n,...t}=e;return(0,s.yg)(dH,(0,p.A)({},yH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}hH.isMDXComponent=!0;const gH={toc:[]},fH="wrapper";function DH(e){let{components:n,...t}=e;return(0,s.yg)(fH,(0,p.A)({},gH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}DH.isMDXComponent=!0;const MH={toc:[]},XH="wrapper";function _H(e){let{components:n,...t}=e;return(0,s.yg)(XH,(0,p.A)({},MH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}_H.isMDXComponent=!0;const wH={toc:[]},TH="wrapper";function CH(e){let{components:n,...t}=e;return(0,s.yg)(TH,(0,p.A)({},wH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}CH.isMDXComponent=!0;const xH={toc:[]},AH="wrapper";function vH(e){let{components:n,...t}=e;return(0,s.yg)(AH,(0,p.A)({},xH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}vH.isMDXComponent=!0;const LH={toc:[]},bH="wrapper";function NH(e){let{components:n,...t}=e;return(0,s.yg)(bH,(0,p.A)({},LH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}NH.isMDXComponent=!0;const kH={toc:[]},zH="wrapper";function PH(e){let{components:n,...t}=e;return(0,s.yg)(zH,(0,p.A)({},kH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}PH.isMDXComponent=!0;const IH={toc:[]},RH="wrapper";function WH(e){let{components:n,...t}=e;return(0,s.yg)(RH,(0,p.A)({},IH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}WH.isMDXComponent=!0;const SH={toc:[]},BH="wrapper";function GH(e){let{components:n,...t}=e;return(0,s.yg)(BH,(0,p.A)({},SH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}GH.isMDXComponent=!0;const EH={toc:[]},OH="wrapper";function UH(e){let{components:n,...t}=e;return(0,s.yg)(OH,(0,p.A)({},EH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Optional override for formatting stack traces"))}UH.isMDXComponent=!0;const FH={toc:[]},VH="wrapper";function qH(e){let{components:n,...t}=e;return(0,s.yg)(VH,(0,p.A)({},FH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create .stack property on a target object"))}qH.isMDXComponent=!0;const jH={toc:[]},HH="wrapper";function YH(e){let{components:n,...t}=e;return(0,s.yg)(HH,(0,p.A)({},jH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}YH.isMDXComponent=!0;const QH={toc:[]},$H="wrapper";function KH(e){let{components:n,...t}=e;return(0,s.yg)($H,(0,p.A)({},QH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}KH.isMDXComponent=!0;const JH={toc:[]},ZH="wrapper";function eY(e){let{components:n,...t}=e;return(0,s.yg)(ZH,(0,p.A)({},JH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}eY.isMDXComponent=!0;const nY={toc:[]},tY="wrapper";function oY(e){let{components:n,...t}=e;return(0,s.yg)(tY,(0,p.A)({},nY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}oY.isMDXComponent=!0;const pY={toc:[]},rY="wrapper";function sY(e){let{components:n,...t}=e;return(0,s.yg)(rY,(0,p.A)({},pY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}sY.isMDXComponent=!0;const cY={toc:[]},aY="wrapper";function iY(e){let{components:n,...t}=e;return(0,s.yg)(aY,(0,p.A)({},cY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}iY.isMDXComponent=!0;const lY={toc:[]},uY="wrapper";function mY(e){let{components:n,...t}=e;return(0,s.yg)(uY,(0,p.A)({},lY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}mY.isMDXComponent=!0;const yY={toc:[]},dY="wrapper";function hY(e){let{components:n,...t}=e;return(0,s.yg)(dY,(0,p.A)({},yY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}hY.isMDXComponent=!0;const gY={toc:[]},fY="wrapper";function DY(e){let{components:n,...t}=e;return(0,s.yg)(fY,(0,p.A)({},gY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}DY.isMDXComponent=!0;const MY={toc:[]},XY="wrapper";function _Y(e){let{components:n,...t}=e;return(0,s.yg)(XY,(0,p.A)({},MY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Optional override for formatting stack traces"))}_Y.isMDXComponent=!0;const wY={toc:[]},TY="wrapper";function CY(e){let{components:n,...t}=e;return(0,s.yg)(TY,(0,p.A)({},wY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create .stack property on a target object"))}CY.isMDXComponent=!0;const xY={toc:[]},AY="wrapper";function vY(e){let{components:n,...t}=e;return(0,s.yg)(AY,(0,p.A)({},xY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An array of the transformed references."))}vY.isMDXComponent=!0;const LY={toc:[]},bY="wrapper";function NY(e){let{components:n,...t}=e;return(0,s.yg)(bY,(0,p.A)({},LY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Maps the references in this group to a new array."))}NY.isMDXComponent=!0;const kY={toc:[]},zY="wrapper";function PY(e){let{components:n,...t}=e;return(0,s.yg)(zY,(0,p.A)({},kY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function to transform each reference."))}PY.isMDXComponent=!0;const IY={toc:[]},RY="wrapper";function WY(e){let{components:n,...t}=e;return(0,s.yg)(RY,(0,p.A)({},IY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}WY.isMDXComponent=!0;const SY={toc:[]},BY="wrapper";function GY(e){let{components:n,...t}=e;return(0,s.yg)(BY,(0,p.A)({},SY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant for converting degrees to radians"))}GY.isMDXComponent=!0;const EY={toc:[]},OY="wrapper";function UY(e){let{components:n,...t}=e;return(0,s.yg)(OY,(0,p.A)({},EY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}UY.isMDXComponent=!0;const FY={toc:[]},VY="wrapper";function qY(e){let{components:n,...t}=e;return(0,s.yg)(VY,(0,p.A)({},FY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant for converting radians to degrees"))}qY.isMDXComponent=!0;const jY={toc:[]},HY="wrapper";function YY(e){let{components:n,...t}=e;return(0,s.yg)(HY,(0,p.A)({},jY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.yg)("inlineCode",{parentName:"p"},"ref")," property of a node."))}YY.isMDXComponent=!0;const QY={toc:[]},$Y="wrapper";function KY(e){let{components:n,...t}=e;return(0,s.yg)($Y,(0,p.A)({},QY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}KY.isMDXComponent=!0;const JY={toc:[]},ZY="wrapper";function eQ(e){let{components:n,...t}=e;return(0,s.yg)(ZY,(0,p.A)({},JY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array of references."))}eQ.isMDXComponent=!0;const nQ={toc:[]},tQ="wrapper";function oQ(e){let{components:n,...t}=e;return(0,s.yg)(tQ,(0,p.A)({},nQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.yg)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}oQ.isMDXComponent=!0;const pQ={toc:[]},rQ="wrapper";function sQ(e){let{components:n,...t}=e;return(0,s.yg)(rQ,(0,p.A)({},pQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}sQ.isMDXComponent=!0;const cQ={toc:[]},aQ="wrapper";function iQ(e){let{components:n,...t}=e;return(0,s.yg)(aQ,(0,p.A)({},cQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a group of references."))}iQ.isMDXComponent=!0;const lQ={toc:[]},uQ="wrapper";function mQ(e){let{components:n,...t}=e;return(0,s.yg)(uQ,(0,p.A)({},lQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is a shortcut for calling ",(0,s.yg)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}mQ.isMDXComponent=!0;const yQ={toc:[]},dQ="wrapper";function hQ(e){let{components:n,...t}=e;return(0,s.yg)(dQ,(0,p.A)({},yQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}hQ.isMDXComponent=!0;const gQ={toc:[]},fQ="wrapper";function DQ(e){let{components:n,...t}=e;return(0,s.yg)(fQ,(0,p.A)({},gQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Logs a debug message with an arbitrary payload."))}DQ.isMDXComponent=!0;const MQ={toc:[]},XQ="wrapper";function _Q(e){let{components:n,...t}=e;return(0,s.yg)(XQ,(0,p.A)({},MQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The payload to log"))}_Q.isMDXComponent=!0;const wQ={toc:[]},TQ="wrapper";function CQ(e){let{components:n,...t}=e;return(0,s.yg)(TQ,(0,p.A)({},wQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mark the given function as deprecated."))}CQ.isMDXComponent=!0;const xQ={toc:[]},AQ="wrapper";function vQ(e){let{components:n,...t}=e;return(0,s.yg)(AQ,(0,p.A)({},xQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function to deprecate."))}vQ.isMDXComponent=!0;const LQ={toc:[]},bQ="wrapper";function NQ(e){let{components:n,...t}=e;return(0,s.yg)(bQ,(0,p.A)({},LQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The log message."))}NQ.isMDXComponent=!0;const kQ={toc:[]},zQ="wrapper";function PQ(e){let{components:n,...t}=e;return(0,s.yg)(zQ,(0,p.A)({},kQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The optional log remarks."))}PQ.isMDXComponent=!0;const IQ={toc:[]},RQ="wrapper";function WQ(e){let{components:n,...t}=e;return(0,s.yg)(RQ,(0,p.A)({},IQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}WQ.isMDXComponent=!0;const SQ={toc:[]},BQ="wrapper";function GQ(e){let{components:n,...t}=e;return(0,s.yg)(BQ,(0,p.A)({},SQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mark the current scene as ready to transition out."))}GQ.isMDXComponent=!0;const EQ={toc:[]},OQ="wrapper";function UQ(e){let{components:n,...t}=e;return(0,s.yg)(OQ,(0,p.A)({},EQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}UQ.isMDXComponent=!0;const FQ={toc:[]},VQ="wrapper";function qQ(e){let{components:n,...t}=e;return(0,s.yg)(VQ,(0,p.A)({},FQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.yg)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}qQ.isMDXComponent=!0;const jQ={toc:[]},HQ="wrapper";function YQ(e){let{components:n,...t}=e;return(0,s.yg)(HQ,(0,p.A)({},jQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}YQ.isMDXComponent=!0;const QQ={toc:[]},$Q="wrapper";function KQ(e){let{components:n,...t}=e;return(0,s.yg)($Q,(0,p.A)({},QQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}KQ.isMDXComponent=!0;const JQ={toc:[]},ZQ="wrapper";function e$(e){let{components:n,...t}=e;return(0,s.yg)(ZQ,(0,p.A)({},JQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The length of the array."))}e$.isMDXComponent=!0;const n$={toc:[]},t$="wrapper";function o$(e){let{components:n,...t}=e;return(0,s.yg)(t$,(0,p.A)({},n$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}o$.isMDXComponent=!0;const p$={toc:[]},r$="wrapper";function s$(e){let{components:n,...t}=e;return(0,s.yg)(r$,(0,p.A)({},p$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}s$.isMDXComponent=!0;const c$={toc:[]},a$="wrapper";function i$(e){let{components:n,...t}=e;return(0,s.yg)(a$,(0,p.A)({},c$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}i$.isMDXComponent=!0;const l$={toc:[]},u$="wrapper";function m$(e){let{components:n,...t}=e;return(0,s.yg)(u$,(0,p.A)({},l$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}m$.isMDXComponent=!0;const y$={toc:[]},d$="wrapper";function h$(e){let{components:n,...t}=e;return(0,s.yg)(d$,(0,p.A)({},y$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}h$.isMDXComponent=!0;const g$={toc:[]},f$="wrapper";function D$(e){let{components:n,...t}=e;return(0,s.yg)(f$,(0,p.A)({},g$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}D$.isMDXComponent=!0;const M$={toc:[]},X$="wrapper";function _$(e){let{components:n,...t}=e;return(0,s.yg)(X$,(0,p.A)({},M$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}_$.isMDXComponent=!0;const w$={toc:[]},T$="wrapper";function C$(e){let{components:n,...t}=e;return(0,s.yg)(T$,(0,p.A)({},w$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}C$.isMDXComponent=!0;const x$={toc:[]},A$="wrapper";function v$(e){let{components:n,...t}=e;return(0,s.yg)(A$,(0,p.A)({},x$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value by which to increment or decrement."))}v$.isMDXComponent=!0;const L$={toc:[]},b$="wrapper";function N$(e){let{components:n,...t}=e;return(0,s.yg)(b$,(0,p.A)({},L$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}N$.isMDXComponent=!0;const k$={toc:[]},z$="wrapper";function P$(e){let{components:n,...t}=e;return(0,s.yg)(z$,(0,p.A)({},k$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function that will be provided the context before render."))}P$.isMDXComponent=!0;const I$={toc:[]},R$="wrapper";function W$(e){let{components:n,...t}=e;return(0,s.yg)(R$,(0,p.A)({},I$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}W$.isMDXComponent=!0;const S$={toc:[]},B$="wrapper";function G$(e){let{components:n,...t}=e;return(0,s.yg)(B$,(0,p.A)({},S$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function that will be provided the context after render."))}G$.isMDXComponent=!0;const E$={toc:[]},O$="wrapper";function U$(e){let{components:n,...t}=e;return(0,s.yg)(O$,(0,p.A)({},E$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}U$.isMDXComponent=!0;const F$={toc:[]},V$="wrapper";function q$(e){let{components:n,...t}=e;return(0,s.yg)(V$,(0,p.A)({},F$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}q$.isMDXComponent=!0;const j$={toc:[]},H$="wrapper";function Y$(e){let{components:n,...t}=e;return(0,s.yg)(H$,(0,p.A)({},j$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the event in seconds."))}Y$.isMDXComponent=!0;const Q$={toc:[]},$$="wrapper";function K$(e){let{components:n,...t}=e;return(0,s.yg)($$,(0,p.A)({},Q$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Register a time event and get its duration in seconds."))}K$.isMDXComponent=!0;const J$={toc:[]},Z$="wrapper";function eK(e){let{components:n,...t}=e;return(0,s.yg)(Z$,(0,p.A)({},J$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the event."))}eK.isMDXComponent=!0;const nK={toc:[]},tK="wrapper";function oK(e){let{components:n,...t}=e;return(0,s.yg)(tK,(0,p.A)({},nK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the playback status."))}oK.isMDXComponent=!0;const pK={toc:[]},rK="wrapper";function sK(e){let{components:n,...t}=e;return(0,s.yg)(rK,(0,p.A)({},pK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the random number generator for the current scene."))}sK.isMDXComponent=!0;const cK={toc:[]},aK="wrapper";function iK(e){let{components:n,...t}=e;return(0,s.yg)(aK,(0,p.A)({},cK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the random number generator for the given seed."))}iK.isMDXComponent=!0;const lK={toc:[]},uK="wrapper";function mK(e){let{components:n,...t}=e;return(0,s.yg)(uK,(0,p.A)({},lK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The seed for the generator."))}mK.isMDXComponent=!0;const yK={toc:[]},dK="wrapper";function hK(e){let{components:n,...t}=e;return(0,s.yg)(dK,(0,p.A)({},yK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}hK.isMDXComponent=!0;const gK={toc:[]},fK="wrapper";function DK(e){let{components:n,...t}=e;return(0,s.yg)(fK,(0,p.A)({},gK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the current scene."))}DK.isMDXComponent=!0;const MK={toc:[]},XK="wrapper";function _K(e){let{components:n,...t}=e;return(0,s.yg)(XK,(0,p.A)({},MK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the current thread."))}_K.isMDXComponent=!0;const wK={toc:[]},TK="wrapper";function CK(e){let{components:n,...t}=e;return(0,s.yg)(TK,(0,p.A)({},wK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.yg)("inlineCode",{parentName:"a"},"waitFor")),"."))}CK.isMDXComponent=!0;const xK={toc:[]},AK="wrapper";function vK(e){let{components:n,...t}=e;return(0,s.yg)(AK,(0,p.A)({},xK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}vK.isMDXComponent=!0;const LK={toc:[]},bK="wrapper";function NK(e){let{components:n,...t}=e;return(0,s.yg)(bK,(0,p.A)({},LK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real time since the start of the animation."))}NK.isMDXComponent=!0;const kK={toc:[]},zK="wrapper";function PK(e){let{components:n,...t}=e;return(0,s.yg)(zK,(0,p.A)({},kK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This rewrites a remote url like ",(0,s.yg)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.yg)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}PK.isMDXComponent=!0;const IK={toc:[]},RK="wrapper";function WK(e){let{components:n,...t}=e;return(0,s.yg)(RK,(0,p.A)({},IK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Route the given url through a local proxy."))}WK.isMDXComponent=!0;const SK={toc:[]},BK="wrapper";function GK(e){let{components:n,...t}=e;return(0,s.yg)(BK,(0,p.A)({},SK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}GK.isMDXComponent=!0;const EK={toc:[]},OK="wrapper";function UK(e){let{components:n,...t}=e;return(0,s.yg)(OK,(0,p.A)({},EK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}UK.isMDXComponent=!0;const FK={toc:[]},VK="wrapper";function qK(e){let{components:n,...t}=e;return(0,s.yg)(VK,(0,p.A)({},FK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}qK.isMDXComponent=!0;const jK={toc:[]},HK="wrapper";function YK(e){let{components:n,...t}=e;return(0,s.yg)(HK,(0,p.A)({},jK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}YK.isMDXComponent=!0;const QK={toc:[]},$K="wrapper";function KK(e){let{components:n,...t}=e;return(0,s.yg)($K,(0,p.A)({},QK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}KK.isMDXComponent=!0;const JK={toc:[]},ZK="wrapper";function eJ(e){let{components:n,...t}=e;return(0,s.yg)(ZK,(0,p.A)({},JK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}eJ.isMDXComponent=!0;const nJ={toc:[]},tJ="wrapper";function oJ(e){let{components:n,...t}=e;return(0,s.yg)(tJ,(0,p.A)({},nJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}oJ.isMDXComponent=!0;const pJ={toc:[]},rJ="wrapper";function sJ(e){let{components:n,...t}=e;return(0,s.yg)(rJ,(0,p.A)({},pJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}sJ.isMDXComponent=!0;const cJ={toc:[]},aJ="wrapper";function iJ(e){let{components:n,...t}=e;return(0,s.yg)(aJ,(0,p.A)({},cJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}iJ.isMDXComponent=!0;const lJ={toc:[]},uJ="wrapper";function mJ(e){let{components:n,...t}=e;return(0,s.yg)(uJ,(0,p.A)({},lJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}mJ.isMDXComponent=!0;const yJ={toc:[]},dJ="wrapper";function hJ(e){let{components:n,...t}=e;return(0,s.yg)(dJ,(0,p.A)({},yJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}hJ.isMDXComponent=!0;const gJ={toc:[]},fJ="wrapper";function DJ(e){let{components:n,...t}=e;return(0,s.yg)(fJ,(0,p.A)({},gJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}DJ.isMDXComponent=!0;const MJ={toc:[]},XJ="wrapper";function _J(e){let{components:n,...t}=e;return(0,s.yg)(XJ,(0,p.A)({},MJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom highlighters used by the Code node."))}_J.isMDXComponent=!0;const wJ={toc:[]},TJ="wrapper";function CJ(e){let{components:n,...t}=e;return(0,s.yg)(TJ,(0,p.A)({},wJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Highlights the code at the given index."))}CJ.isMDXComponent=!0;const xJ={toc:[]},AJ="wrapper";function vJ(e){let{components:n,...t}=e;return(0,s.yg)(AJ,(0,p.A)({},xJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the code to highlight."))}vJ.isMDXComponent=!0;const LJ={toc:[]},bJ="wrapper";function NJ(e){let{components:n,...t}=e;return(0,s.yg)(bJ,(0,p.A)({},LJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#prepare"},(0,s.yg)("inlineCode",{parentName:"a"},"prepare")),"."))}NJ.isMDXComponent=!0;const kJ={toc:[]},zJ="wrapper";function PJ(e){let{components:n,...t}=e;return(0,s.yg)(zJ,(0,p.A)({},kJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.yg)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.yg)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}PJ.isMDXComponent=!0;const IJ={toc:[]},RJ="wrapper";function WJ(e){let{components:n,...t}=e;return(0,s.yg)(RJ,(0,p.A)({},IJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializes the highlighter."))}WJ.isMDXComponent=!0;const SJ={toc:[]},BJ="wrapper";function GJ(e){let{components:n,...t}=e;return(0,s.yg)(BJ,(0,p.A)({},SJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#highlight"},(0,s.yg)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}GJ.isMDXComponent=!0;const EJ={toc:[]},OJ="wrapper";function UJ(e){let{components:n,...t}=e;return(0,s.yg)(OJ,(0,p.A)({},EJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepares the code for highlighting."))}UJ.isMDXComponent=!0;const FJ={toc:[]},VJ="wrapper";function qJ(e){let{components:n,...t}=e;return(0,s.yg)(VJ,(0,p.A)({},FJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to prepare."))}qJ.isMDXComponent=!0;const jJ={toc:[]},HJ="wrapper";function YJ(e){let{components:n,...t}=e;return(0,s.yg)(HJ,(0,p.A)({},jJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}YJ.isMDXComponent=!0;const QJ={toc:[]},$J="wrapper";function KJ(e){let{components:n,...t}=e;return(0,s.yg)($J,(0,p.A)({},QJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tokenize the code."))}KJ.isMDXComponent=!0;const JJ={toc:[]},ZJ="wrapper";function eZ(e){let{components:n,...t}=e;return(0,s.yg)(ZJ,(0,p.A)({},JJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}eZ.isMDXComponent=!0;const nZ={toc:[]},tZ="wrapper";function oZ(e){let{components:n,...t}=e;return(0,s.yg)(tZ,(0,p.A)({},nZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}oZ.isMDXComponent=!0;const pZ={toc:[]},rZ="wrapper";function sZ(e){let{components:n,...t}=e;return(0,s.yg)(rZ,(0,p.A)({},pZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom highlighters used by the Code node."))}sZ.isMDXComponent=!0;const cZ={toc:[]},aZ="wrapper";function iZ(e){let{components:n,...t}=e;return(0,s.yg)(aZ,(0,p.A)({},cZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Highlights the code at the given index."))}iZ.isMDXComponent=!0;const lZ={toc:[]},uZ="wrapper";function mZ(e){let{components:n,...t}=e;return(0,s.yg)(uZ,(0,p.A)({},lZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the code to highlight."))}mZ.isMDXComponent=!0;const yZ={toc:[]},dZ="wrapper";function hZ(e){let{components:n,...t}=e;return(0,s.yg)(dZ,(0,p.A)({},yZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#prepare"},(0,s.yg)("inlineCode",{parentName:"a"},"prepare")),"."))}hZ.isMDXComponent=!0;const gZ={toc:[]},fZ="wrapper";function DZ(e){let{components:n,...t}=e;return(0,s.yg)(fZ,(0,p.A)({},gZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.yg)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.yg)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}DZ.isMDXComponent=!0;const MZ={toc:[]},XZ="wrapper";function _Z(e){let{components:n,...t}=e;return(0,s.yg)(XZ,(0,p.A)({},MZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializes the highlighter."))}_Z.isMDXComponent=!0;const wZ={toc:[]},TZ="wrapper";function CZ(e){let{components:n,...t}=e;return(0,s.yg)(TZ,(0,p.A)({},wZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#highlight"},(0,s.yg)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}CZ.isMDXComponent=!0;const xZ={toc:[]},AZ="wrapper";function vZ(e){let{components:n,...t}=e;return(0,s.yg)(AZ,(0,p.A)({},xZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepares the code for highlighting."))}vZ.isMDXComponent=!0;const LZ={toc:[]},bZ="wrapper";function NZ(e){let{components:n,...t}=e;return(0,s.yg)(bZ,(0,p.A)({},LZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to prepare."))}NZ.isMDXComponent=!0;const kZ={toc:[]},zZ="wrapper";function PZ(e){let{components:n,...t}=e;return(0,s.yg)(zZ,(0,p.A)({},kZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}PZ.isMDXComponent=!0;const IZ={toc:[]},RZ="wrapper";function WZ(e){let{components:n,...t}=e;return(0,s.yg)(RZ,(0,p.A)({},IZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tokenize the code."))}WZ.isMDXComponent=!0;const SZ={toc:[]},BZ="wrapper";function GZ(e){let{components:n,...t}=e;return(0,s.yg)(BZ,(0,p.A)({},SZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}GZ.isMDXComponent=!0;const EZ={toc:[]},OZ="wrapper";function UZ(e){let{components:n,...t}=e;return(0,s.yg)(OZ,(0,p.A)({},EZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}UZ.isMDXComponent=!0;const FZ={toc:[]},VZ="wrapper";function qZ(e){let{components:n,...t}=e;return(0,s.yg)(VZ,(0,p.A)({},FZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the cache used by the highlighter."))}qZ.isMDXComponent=!0;const jZ={toc:[]},HZ="wrapper";function YZ(e){let{components:n,...t}=e;return(0,s.yg)(HZ,(0,p.A)({},jZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes the result of a highlight operation."))}YZ.isMDXComponent=!0;const QZ={toc:[]},$Z="wrapper";function KZ(e){let{components:n,...t}=e;return(0,s.yg)($Z,(0,p.A)({},QZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the code at the given index."))}KZ.isMDXComponent=!0;const JZ={toc:[]},ZZ="wrapper";function e0(e){let{components:n,...t}=e;return(0,s.yg)(ZZ,(0,p.A)({},JZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This should be used to skip to the end of the currently highlighted token.\nThe returned style will be used for the skipped characters, and they will\nbe drawn as one continuous string keeping emojis and ligatures intact."),(0,s.yg)("p",null,"The returned value is the number of characters to skip ahead, not the\nindex of the end of the token."))}e0.isMDXComponent=!0;const n0={toc:[]},t0="wrapper";function o0(e){let{components:n,...t}=e;return(0,s.yg)(t0,(0,p.A)({},n0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of characters to skip ahead."))}o0.isMDXComponent=!0;const p0={toc:[]},r0="wrapper";function s0(e){let{components:n,...t}=e;return(0,s.yg)(r0,(0,p.A)({},p0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that compares two code snippets and returns a list of\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeTag"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeTag")),"s describing a transition between them."))}s0.isMDXComponent=!0;const c0={toc:[]},a0="wrapper";function i0(e){let{components:n,...t}=e;return(0,s.yg)(a0,(0,p.A)({},c0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default diffing function utilizing ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#patienceDiff"},(0,s.yg)("inlineCode",{parentName:"a"},"patienceDiff")),"."))}i0.isMDXComponent=!0;const l0={toc:[]},u0="wrapper";function m0(e){let{components:n,...t}=e;return(0,s.yg)(u0,(0,p.A)({},l0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The original code scope."))}m0.isMDXComponent=!0;const y0={toc:[]},d0="wrapper";function h0(e){let{components:n,...t}=e;return(0,s.yg)(d0,(0,p.A)({},y0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new code scope."))}h0.isMDXComponent=!0;const g0={toc:[]},f0="wrapper";function D0(e){let{components:n,...t}=e;return(0,s.yg)(f0,(0,p.A)({},g0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The inherited tokenizer to use."))}D0.isMDXComponent=!0;const M0={toc:[]},X0="wrapper";function _0(e){let{components:n,...t}=e;return(0,s.yg)(X0,(0,p.A)({},M0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default tokenizer function used by ownerless code signals."))}_0.isMDXComponent=!0;const w0={toc:[]},T0="wrapper";function C0(e){let{components:n,...t}=e;return(0,s.yg)(T0,(0,p.A)({},w0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}C0.isMDXComponent=!0;const x0={toc:[]},A0="wrapper";function v0(e){let{components:n,...t}=e;return(0,s.yg)(A0,(0,p.A)({},x0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This function will try to preserve the original fragments, resolving them\nonly if they overlap with the range."))}v0.isMDXComponent=!0;const L0={toc:[]},b0="wrapper";function N0(e){let{components:n,...t}=e;return(0,s.yg)(b0,(0,p.A)({},L0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A tuple containing the transformed fragments and the index of the\nisolated fragment within."))}N0.isMDXComponent=!0;const k0={toc:[]},z0="wrapper";function P0(e){let{components:n,...t}=e;return(0,s.yg)(z0,(0,p.A)({},k0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transform the fragments to isolate the given range into its own fragment."))}P0.isMDXComponent=!0;const I0={toc:[]},R0="wrapper";function W0(e){let{components:n,...t}=e;return(0,s.yg)(R0,(0,p.A)({},I0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The range to extract."))}W0.isMDXComponent=!0;const S0={toc:[]},B0="wrapper";function G0(e){let{components:n,...t}=e;return(0,s.yg)(B0,(0,p.A)({},S0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The fragments to transform."))}G0.isMDXComponent=!0;const E0={toc:[]},O0="wrapper";function U0(e){let{components:n,...t}=e;return(0,s.yg)(O0,(0,p.A)({},E0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all code ranges that match the given pattern."))}U0.isMDXComponent=!0;const F0={toc:[]},V0="wrapper";function q0(e){let{components:n,...t}=e;return(0,s.yg)(V0,(0,p.A)({},F0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to search in."))}q0.isMDXComponent=!0;const j0={toc:[]},H0="wrapper";function Y0(e){let{components:n,...t}=e;return(0,s.yg)(H0,(0,p.A)({},j0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to search for."))}Y0.isMDXComponent=!0;const Q0={toc:[]},$0="wrapper";function K0(e){let{components:n,...t}=e;return(0,s.yg)($0,(0,p.A)({},Q0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional limit on the number of ranges to find."))}K0.isMDXComponent=!0;const J0={toc:[]},Z0="wrapper";function e3(e){let{components:n,...t}=e;return(0,s.yg)(Z0,(0,p.A)({},J0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}e3.isMDXComponent=!0;const n3={toc:[]},t3="wrapper";function o3(e){let{components:n,...t}=e;return(0,s.yg)(t3,(0,p.A)({},n3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents an insertion of code."))}o3.isMDXComponent=!0;const p3={toc:[]},r3="wrapper";function s3(e){let{components:n,...t}=e;return(0,s.yg)(r3,(0,p.A)({},p3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to insert."))}s3.isMDXComponent=!0;const c3={toc:[]},a3="wrapper";function i3(e){let{components:n,...t}=e;return(0,s.yg)(a3,(0,p.A)({},c3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code range that spans the given lines."))}i3.isMDXComponent=!0;const l3={toc:[]},u3="wrapper";function m3(e){let{components:n,...t}=e;return(0,s.yg)(u3,(0,p.A)({},l3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line from which the range starts."))}m3.isMDXComponent=!0;const y3={toc:[]},d3="wrapper";function h3(e){let{components:n,...t}=e;return(0,s.yg)(d3,(0,p.A)({},y3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the range ends. If omitted, the range will\ncover only one line."))}h3.isMDXComponent=!0;const g3={toc:[]},f3="wrapper";function D3(e){let{components:n,...t}=e;return(0,s.yg)(f3,(0,p.A)({},g3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Performs a patience diff on two arrays of strings, returning an object\ncontaining the lines that were deleted, inserted, and potentially moved\nlines. The plus parameter can result in a significant performance hit due\nto additional Longest Common Substring searches."))}D3.isMDXComponent=!0;const M3={toc:[]},X3="wrapper";function _3(e){let{components:n,...t}=e;return(0,s.yg)(X3,(0,p.A)({},M3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The original array of strings"))}_3.isMDXComponent=!0;const w3={toc:[]},T3="wrapper";function C3(e){let{components:n,...t}=e;return(0,s.yg)(T3,(0,p.A)({},w3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new array of strings"))}C3.isMDXComponent=!0;const x3={toc:[]},A3="wrapper";function v3(e){let{components:n,...t}=e;return(0,s.yg)(A3,(0,p.A)({},x3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a custom selection range."))}v3.isMDXComponent=!0;const L3={toc:[]},b3="wrapper";function N3(e){let{components:n,...t}=e;return(0,s.yg)(b3,(0,p.A)({},L3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the selection starts."))}N3.isMDXComponent=!0;const k3={toc:[]},z3="wrapper";function P3(e){let{components:n,...t}=e;return(0,s.yg)(z3,(0,p.A)({},k3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the selection starts."))}P3.isMDXComponent=!0;const I3={toc:[]},R3="wrapper";function W3(e){let{components:n,...t}=e;return(0,s.yg)(R3,(0,p.A)({},I3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the selection ends."))}W3.isMDXComponent=!0;const S3={toc:[]},B3="wrapper";function G3(e){let{components:n,...t}=e;return(0,s.yg)(B3,(0,p.A)({},S3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the selection ends."))}G3.isMDXComponent=!0;const E3={toc:[]},O3="wrapper";function U3(e){let{components:n,...t}=e;return(0,s.yg)(O3,(0,p.A)({},E3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}U3.isMDXComponent=!0;const F3={toc:[]},V3="wrapper";function q3(e){let{components:n,...t}=e;return(0,s.yg)(V3,(0,p.A)({},F3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents a removal of code."))}q3.isMDXComponent=!0;const j3={toc:[]},H3="wrapper";function Y3(e){let{components:n,...t}=e;return(0,s.yg)(H3,(0,p.A)({},j3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to remove."))}Y3.isMDXComponent=!0;const Q3={toc:[]},$3="wrapper";function K3(e){let{components:n,...t}=e;return(0,s.yg)($3,(0,p.A)({},Q3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}K3.isMDXComponent=!0;const J3={toc:[]},Z3="wrapper";function e8(e){let{components:n,...t}=e;return(0,s.yg)(Z3,(0,p.A)({},J3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents a change from one piece of code to\nanother."))}e8.isMDXComponent=!0;const n8={toc:[]},t8="wrapper";function o8(e){let{components:n,...t}=e;return(0,s.yg)(t8,(0,p.A)({},n8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to change from."))}o8.isMDXComponent=!0;const p8={toc:[]},r8="wrapper";function s8(e){let{components:n,...t}=e;return(0,s.yg)(r8,(0,p.A)({},p8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to change to."))}s8.isMDXComponent=!0;const c8={toc:[]},a8="wrapper";function i8(e){let{components:n,...t}=e;return(0,s.yg)(a8,(0,p.A)({},c8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code range that highlights the given word."))}i8.isMDXComponent=!0;const l8={toc:[]},u8="wrapper";function m8(e){let{components:n,...t}=e;return(0,s.yg)(u8,(0,p.A)({},l8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the word appears."))}m8.isMDXComponent=!0;const y8={toc:[]},d8="wrapper";function h8(e){let{components:n,...t}=e;return(0,s.yg)(d8,(0,p.A)({},y8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the word starts."))}h8.isMDXComponent=!0;const g8={toc:[]},f8="wrapper";function D8(e){let{components:n,...t}=e;return(0,s.yg)(f8,(0,p.A)({},g8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The length of the word. If omitted, the range will cover the\nrest of the line."))}D8.isMDXComponent=!0;const M8={toc:[]},X8="wrapper";function _8(e){let{components:n,...t}=e;return(0,s.yg)(X8,(0,p.A)({},M8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}_8.isMDXComponent=!0;const w8={toc:[]},T8="wrapper";function C8(e){let{components:n,...t}=e;return(0,s.yg)(T8,(0,p.A)({},w8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}C8.isMDXComponent=!0;const x8={toc:[]},A8="wrapper";function v8(e){let{components:n,...t}=e;return(0,s.yg)(A8,(0,p.A)({},x8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}v8.isMDXComponent=!0;const L8={toc:[]},b8="wrapper";function N8(e){let{components:n,...t}=e;return(0,s.yg)(b8,(0,p.A)({},L8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}N8.isMDXComponent=!0;const k8={toc:[]},z8="wrapper";function P8(e){let{components:n,...t}=e;return(0,s.yg)(z8,(0,p.A)({},k8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}P8.isMDXComponent=!0;const I8={toc:[]},R8="wrapper";function W8(e){let{components:n,...t}=e;return(0,s.yg)(R8,(0,p.A)({},I8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}W8.isMDXComponent=!0;const S8={toc:[]},B8="wrapper";function G8(e){let{components:n,...t}=e;return(0,s.yg)(B8,(0,p.A)({},S8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}G8.isMDXComponent=!0;const E8={toc:[]},O8="wrapper";function U8(e){let{components:n,...t}=e;return(0,s.yg)(O8,(0,p.A)({},E8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}U8.isMDXComponent=!0;const F8={toc:[]},V8="wrapper";function q8(e){let{components:n,...t}=e;return(0,s.yg)(V8,(0,p.A)({},F8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}q8.isMDXComponent=!0;const j8={toc:[]},H8="wrapper";function Y8(e){let{components:n,...t}=e;return(0,s.yg)(H8,(0,p.A)({},j8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Y8.isMDXComponent=!0;const Q8={toc:[]},$8="wrapper";function K8(e){let{components:n,...t}=e;return(0,s.yg)($8,(0,p.A)({},Q8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}K8.isMDXComponent=!0;const J8={toc:[]},Z8="wrapper";function e2(e){let{components:n,...t}=e;return(0,s.yg)(Z8,(0,p.A)({},J8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}e2.isMDXComponent=!0;const n2={toc:[]},t2="wrapper";function o2(e){let{components:n,...t}=e;return(0,s.yg)(t2,(0,p.A)({},n2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}o2.isMDXComponent=!0;const p2={toc:[]},r2="wrapper";function s2(e){let{components:n,...t}=e;return(0,s.yg)(r2,(0,p.A)({},p2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}s2.isMDXComponent=!0;const c2={toc:[]},a2="wrapper";function i2(e){let{components:n,...t}=e;return(0,s.yg)(a2,(0,p.A)({},c2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}i2.isMDXComponent=!0;const l2={toc:[]},u2="wrapper";function m2(e){let{components:n,...t}=e;return(0,s.yg)(u2,(0,p.A)({},l2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}m2.isMDXComponent=!0;const y2={toc:[]},d2="wrapper";function h2(e){let{components:n,...t}=e;return(0,s.yg)(d2,(0,p.A)({},y2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}h2.isMDXComponent=!0;const g2={toc:[]},f2="wrapper";function D2(e){let{components:n,...t}=e;return(0,s.yg)(f2,(0,p.A)({},g2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}D2.isMDXComponent=!0;const M2={toc:[]},X2="wrapper";function _2(e){let{components:n,...t}=e;return(0,s.yg)(X2,(0,p.A)({},M2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}_2.isMDXComponent=!0;const w2={toc:[]},T2="wrapper";function C2(e){let{components:n,...t}=e;return(0,s.yg)(T2,(0,p.A)({},w2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}C2.isMDXComponent=!0;const x2={toc:[]},A2="wrapper";function v2(e){let{components:n,...t}=e;return(0,s.yg)(A2,(0,p.A)({},x2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}v2.isMDXComponent=!0;const L2={toc:[]},b2="wrapper";function N2(e){let{components:n,...t}=e;return(0,s.yg)(b2,(0,p.A)({},L2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}N2.isMDXComponent=!0;const k2={toc:[]},z2="wrapper";function P2(e){let{components:n,...t}=e;return(0,s.yg)(z2,(0,p.A)({},k2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}P2.isMDXComponent=!0;const I2={toc:[]},R2="wrapper";function W2(e){let{components:n,...t}=e;return(0,s.yg)(R2,(0,p.A)({},I2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W2.isMDXComponent=!0;const S2={toc:[]},B2="wrapper";function G2(e){let{components:n,...t}=e;return(0,s.yg)(B2,(0,p.A)({},S2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}G2.isMDXComponent=!0;const E2={toc:[]},O2="wrapper";function U2(e){let{components:n,...t}=e;return(0,s.yg)(O2,(0,p.A)({},E2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}U2.isMDXComponent=!0;const F2={toc:[]},V2="wrapper";function q2(e){let{components:n,...t}=e;return(0,s.yg)(V2,(0,p.A)({},F2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}q2.isMDXComponent=!0;const j2={toc:[]},H2="wrapper";function Y2(e){let{components:n,...t}=e;return(0,s.yg)(H2,(0,p.A)({},j2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Y2.isMDXComponent=!0;const Q2={toc:[]},$2="wrapper";function K2(e){let{components:n,...t}=e;return(0,s.yg)($2,(0,p.A)({},Q2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}K2.isMDXComponent=!0;const J2={toc:[]},Z2="wrapper";function e1(e){let{components:n,...t}=e;return(0,s.yg)(Z2,(0,p.A)({},J2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}e1.isMDXComponent=!0;const n1={toc:[]},t1="wrapper";function o1(e){let{components:n,...t}=e;return(0,s.yg)(t1,(0,p.A)({},n1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}o1.isMDXComponent=!0;const p1={toc:[]},r1="wrapper";function s1(e){let{components:n,...t}=e;return(0,s.yg)(r1,(0,p.A)({},p1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}s1.isMDXComponent=!0;const c1={toc:[]},a1="wrapper";function i1(e){let{components:n,...t}=e;return(0,s.yg)(a1,(0,p.A)({},c1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}i1.isMDXComponent=!0;const l1={toc:[]},u1="wrapper";function m1(e){let{components:n,...t}=e;return(0,s.yg)(u1,(0,p.A)({},l1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}m1.isMDXComponent=!0;const y1={toc:[]},d1="wrapper";function h1(e){let{components:n,...t}=e;return(0,s.yg)(d1,(0,p.A)({},y1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}h1.isMDXComponent=!0;const g1={toc:[]},f1="wrapper";function D1(e){let{components:n,...t}=e;return(0,s.yg)(f1,(0,p.A)({},g1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}D1.isMDXComponent=!0;const M1={toc:[]},X1="wrapper";function _1(e){let{components:n,...t}=e;return(0,s.yg)(X1,(0,p.A)({},M1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}_1.isMDXComponent=!0;const w1={toc:[]},T1="wrapper";function C1(e){let{components:n,...t}=e;return(0,s.yg)(T1,(0,p.A)({},w1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}C1.isMDXComponent=!0;const x1={toc:[]},A1="wrapper";function v1(e){let{components:n,...t}=e;return(0,s.yg)(A1,(0,p.A)({},x1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}v1.isMDXComponent=!0;const L1={toc:[]},b1="wrapper";function N1(e){let{components:n,...t}=e;return(0,s.yg)(b1,(0,p.A)({},L1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}N1.isMDXComponent=!0;const k1={toc:[]},z1="wrapper";function P1(e){let{components:n,...t}=e;return(0,s.yg)(z1,(0,p.A)({},k1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}P1.isMDXComponent=!0;const I1={toc:[]},R1="wrapper";function W1(e){let{components:n,...t}=e;return(0,s.yg)(R1,(0,p.A)({},I1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}W1.isMDXComponent=!0;const S1={toc:[]},B1="wrapper";function G1(e){let{components:n,...t}=e;return(0,s.yg)(B1,(0,p.A)({},S1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}G1.isMDXComponent=!0;const E1={toc:[]},O1="wrapper";function U1(e){let{components:n,...t}=e;return(0,s.yg)(O1,(0,p.A)({},E1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}U1.isMDXComponent=!0;const F1={toc:[]},V1="wrapper";function q1(e){let{components:n,...t}=e;return(0,s.yg)(V1,(0,p.A)({},F1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}q1.isMDXComponent=!0;const j1={toc:[]},H1="wrapper";function Y1(e){let{components:n,...t}=e;return(0,s.yg)(H1,(0,p.A)({},j1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Y1.isMDXComponent=!0;const Q1={toc:[]},$1="wrapper";function K1(e){let{components:n,...t}=e;return(0,s.yg)($1,(0,p.A)({},Q1,t,{components:n,mdxType:"MDXLayout"}))}K1.isMDXComponent=!0;const J1={toc:[]},Z1="wrapper";function e4(e){let{components:n,...t}=e;return(0,s.yg)(Z1,(0,p.A)({},J1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}e4.isMDXComponent=!0;const n4={toc:[]},t4="wrapper";function o4(e){let{components:n,...t}=e;return(0,s.yg)(t4,(0,p.A)({},n4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}o4.isMDXComponent=!0;const p4={toc:[]},r4="wrapper";function s4(e){let{components:n,...t}=e;return(0,s.yg)(r4,(0,p.A)({},p4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}s4.isMDXComponent=!0;const c4={toc:[]},a4="wrapper";function i4(e){let{components:n,...t}=e;return(0,s.yg)(a4,(0,p.A)({},c4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}i4.isMDXComponent=!0;const l4={toc:[]},u4="wrapper";function m4(e){let{components:n,...t}=e;return(0,s.yg)(u4,(0,p.A)({},l4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}m4.isMDXComponent=!0;const y4={toc:[]},d4="wrapper";function h4(e){let{components:n,...t}=e;return(0,s.yg)(d4,(0,p.A)({},y4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}h4.isMDXComponent=!0;const g4={toc:[]},f4="wrapper";function D4(e){let{components:n,...t}=e;return(0,s.yg)(f4,(0,p.A)({},g4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}D4.isMDXComponent=!0;const M4={toc:[]},X4="wrapper";function _4(e){let{components:n,...t}=e;return(0,s.yg)(X4,(0,p.A)({},M4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}_4.isMDXComponent=!0;const w4={toc:[]},T4="wrapper";function C4(e){let{components:n,...t}=e;return(0,s.yg)(T4,(0,p.A)({},w4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}C4.isMDXComponent=!0;const x4={toc:[]},A4="wrapper";function v4(e){let{components:n,...t}=e;return(0,s.yg)(A4,(0,p.A)({},x4,t,{components:n,mdxType:"MDXLayout"}))}v4.isMDXComponent=!0;const L4={toc:[]},b4="wrapper";function N4(e){let{components:n,...t}=e;return(0,s.yg)(b4,(0,p.A)({},L4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}N4.isMDXComponent=!0;const k4={toc:[]},z4="wrapper";function P4(e){let{components:n,...t}=e;return(0,s.yg)(z4,(0,p.A)({},k4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}P4.isMDXComponent=!0;const I4={toc:[]},R4="wrapper";function W4(e){let{components:n,...t}=e;return(0,s.yg)(R4,(0,p.A)({},I4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W4.isMDXComponent=!0;const S4={toc:[]},B4="wrapper";function G4(e){let{components:n,...t}=e;return(0,s.yg)(B4,(0,p.A)({},S4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}G4.isMDXComponent=!0;const E4={toc:[]},O4="wrapper";function U4(e){let{components:n,...t}=e;return(0,s.yg)(O4,(0,p.A)({},E4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}U4.isMDXComponent=!0;const F4={toc:[]},V4="wrapper";function q4(e){let{components:n,...t}=e;return(0,s.yg)(V4,(0,p.A)({},F4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}q4.isMDXComponent=!0;const j4={toc:[]},H4="wrapper";function Y4(e){let{components:n,...t}=e;return(0,s.yg)(H4,(0,p.A)({},j4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Y4.isMDXComponent=!0;const Q4={toc:[]},$4="wrapper";function K4(e){let{components:n,...t}=e;return(0,s.yg)($4,(0,p.A)({},Q4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}K4.isMDXComponent=!0;const J4={toc:[]},Z4="wrapper";function e6(e){let{components:n,...t}=e;return(0,s.yg)(Z4,(0,p.A)({},J4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}e6.isMDXComponent=!0;const n6={toc:[]},t6="wrapper";function o6(e){let{components:n,...t}=e;return(0,s.yg)(t6,(0,p.A)({},n6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}o6.isMDXComponent=!0;const p6={toc:[]},r6="wrapper";function s6(e){let{components:n,...t}=e;return(0,s.yg)(r6,(0,p.A)({},p6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}s6.isMDXComponent=!0;const c6={toc:[]},a6="wrapper";function i6(e){let{components:n,...t}=e;return(0,s.yg)(a6,(0,p.A)({},c6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}i6.isMDXComponent=!0;const l6={toc:[]},u6="wrapper";function m6(e){let{components:n,...t}=e;return(0,s.yg)(u6,(0,p.A)({},l6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}m6.isMDXComponent=!0;const y6={toc:[]},d6="wrapper";function h6(e){let{components:n,...t}=e;return(0,s.yg)(d6,(0,p.A)({},y6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}h6.isMDXComponent=!0;const g6={toc:[]},f6="wrapper";function D6(e){let{components:n,...t}=e;return(0,s.yg)(f6,(0,p.A)({},g6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}D6.isMDXComponent=!0;const M6={toc:[]},X6="wrapper";function _6(e){let{components:n,...t}=e;return(0,s.yg)(X6,(0,p.A)({},M6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}_6.isMDXComponent=!0;const w6={toc:[]},T6="wrapper";function C6(e){let{components:n,...t}=e;return(0,s.yg)(T6,(0,p.A)({},w6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}C6.isMDXComponent=!0;const x6={toc:[]},A6="wrapper";function v6(e){let{components:n,...t}=e;return(0,s.yg)(A6,(0,p.A)({},x6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}v6.isMDXComponent=!0;const L6={toc:[]},b6="wrapper";function N6(e){let{components:n,...t}=e;return(0,s.yg)(b6,(0,p.A)({},L6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}N6.isMDXComponent=!0;const k6={toc:[]},z6="wrapper";function P6(e){let{components:n,...t}=e;return(0,s.yg)(z6,(0,p.A)({},k6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}P6.isMDXComponent=!0;const I6={toc:[]},R6="wrapper";function W6(e){let{components:n,...t}=e;return(0,s.yg)(R6,(0,p.A)({},I6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}W6.isMDXComponent=!0;const S6={toc:[]},B6="wrapper";function G6(e){let{components:n,...t}=e;return(0,s.yg)(B6,(0,p.A)({},S6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}G6.isMDXComponent=!0;const E6={toc:[]},O6="wrapper";function U6(e){let{components:n,...t}=e;return(0,s.yg)(O6,(0,p.A)({},E6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}U6.isMDXComponent=!0;const F6={toc:[]},V6="wrapper";function q6(e){let{components:n,...t}=e;return(0,s.yg)(V6,(0,p.A)({},F6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}q6.isMDXComponent=!0;const j6={toc:[]},H6="wrapper";function Y6(e){let{components:n,...t}=e;return(0,s.yg)(H6,(0,p.A)({},j6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Y6.isMDXComponent=!0;const Q6={toc:[]},$6="wrapper";function K6(e){let{components:n,...t}=e;return(0,s.yg)($6,(0,p.A)({},Q6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}K6.isMDXComponent=!0;const J6={toc:[]},Z6="wrapper";function e5(e){let{components:n,...t}=e;return(0,s.yg)(Z6,(0,p.A)({},J6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}e5.isMDXComponent=!0;const n5={toc:[]},t5="wrapper";function o5(e){let{components:n,...t}=e;return(0,s.yg)(t5,(0,p.A)({},n5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}o5.isMDXComponent=!0;const p5={toc:[]},r5="wrapper";function s5(e){let{components:n,...t}=e;return(0,s.yg)(r5,(0,p.A)({},p5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}s5.isMDXComponent=!0;const c5={toc:[]},a5="wrapper";function i5(e){let{components:n,...t}=e;return(0,s.yg)(a5,(0,p.A)({},c5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}i5.isMDXComponent=!0;const l5={toc:[]},u5="wrapper";function m5(e){let{components:n,...t}=e;return(0,s.yg)(u5,(0,p.A)({},l5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}m5.isMDXComponent=!0;const y5={toc:[]},d5="wrapper";function h5(e){let{components:n,...t}=e;return(0,s.yg)(d5,(0,p.A)({},y5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}h5.isMDXComponent=!0;const g5={toc:[]},f5="wrapper";function D5(e){let{components:n,...t}=e;return(0,s.yg)(f5,(0,p.A)({},g5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}D5.isMDXComponent=!0;const M5={toc:[]},X5="wrapper";function _5(e){let{components:n,...t}=e;return(0,s.yg)(X5,(0,p.A)({},M5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}_5.isMDXComponent=!0;const w5={toc:[]},T5="wrapper";function C5(e){let{components:n,...t}=e;return(0,s.yg)(T5,(0,p.A)({},w5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}C5.isMDXComponent=!0;const x5={toc:[]},A5="wrapper";function v5(e){let{components:n,...t}=e;return(0,s.yg)(A5,(0,p.A)({},x5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}v5.isMDXComponent=!0;const L5={toc:[]},b5="wrapper";function N5(e){let{components:n,...t}=e;return(0,s.yg)(b5,(0,p.A)({},L5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}N5.isMDXComponent=!0;const k5={toc:[]},z5="wrapper";function P5(e){let{components:n,...t}=e;return(0,s.yg)(z5,(0,p.A)({},k5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}P5.isMDXComponent=!0;const I5={toc:[]},R5="wrapper";function W5(e){let{components:n,...t}=e;return(0,s.yg)(R5,(0,p.A)({},I5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}W5.isMDXComponent=!0;const S5={toc:[]},B5="wrapper";function G5(e){let{components:n,...t}=e;return(0,s.yg)(B5,(0,p.A)({},S5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}G5.isMDXComponent=!0;const E5={toc:[]},O5="wrapper";function U5(e){let{components:n,...t}=e;return(0,s.yg)(O5,(0,p.A)({},E5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}U5.isMDXComponent=!0;const F5={toc:[]},V5="wrapper";function q5(e){let{components:n,...t}=e;return(0,s.yg)(V5,(0,p.A)({},F5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}q5.isMDXComponent=!0;const j5={toc:[]},H5="wrapper";function Y5(e){let{components:n,...t}=e;return(0,s.yg)(H5,(0,p.A)({},j5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Y5.isMDXComponent=!0;const Q5={toc:[]},$5="wrapper";function K5(e){let{components:n,...t}=e;return(0,s.yg)($5,(0,p.A)({},Q5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}K5.isMDXComponent=!0;const J5={toc:[]},Z5="wrapper";function e7(e){let{components:n,...t}=e;return(0,s.yg)(Z5,(0,p.A)({},J5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}e7.isMDXComponent=!0;const n7={toc:[]},t7="wrapper";function o7(e){let{components:n,...t}=e;return(0,s.yg)(t7,(0,p.A)({},n7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}o7.isMDXComponent=!0;const p7={toc:[]},r7="wrapper";function s7(e){let{components:n,...t}=e;return(0,s.yg)(r7,(0,p.A)({},p7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}s7.isMDXComponent=!0;const c7={toc:[]},a7="wrapper";function i7(e){let{components:n,...t}=e;return(0,s.yg)(a7,(0,p.A)({},c7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}i7.isMDXComponent=!0;const l7={toc:[]},u7="wrapper";function m7(e){let{components:n,...t}=e;return(0,s.yg)(u7,(0,p.A)({},l7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}m7.isMDXComponent=!0;const y7={toc:[]},d7="wrapper";function h7(e){let{components:n,...t}=e;return(0,s.yg)(d7,(0,p.A)({},y7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}h7.isMDXComponent=!0;const g7={toc:[]},f7="wrapper";function D7(e){let{components:n,...t}=e;return(0,s.yg)(f7,(0,p.A)({},g7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}D7.isMDXComponent=!0;const M7={toc:[]},X7="wrapper";function _7(e){let{components:n,...t}=e;return(0,s.yg)(X7,(0,p.A)({},M7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_7.isMDXComponent=!0;const w7={toc:[]},T7="wrapper";function C7(e){let{components:n,...t}=e;return(0,s.yg)(T7,(0,p.A)({},w7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}C7.isMDXComponent=!0;const x7={toc:[]},A7="wrapper";function v7(e){let{components:n,...t}=e;return(0,s.yg)(A7,(0,p.A)({},x7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}v7.isMDXComponent=!0;const L7={toc:[]},b7="wrapper";function N7(e){let{components:n,...t}=e;return(0,s.yg)(b7,(0,p.A)({},L7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}N7.isMDXComponent=!0;const k7={toc:[]},z7="wrapper";function P7(e){let{components:n,...t}=e;return(0,s.yg)(z7,(0,p.A)({},k7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}P7.isMDXComponent=!0;const I7={toc:[]},R7="wrapper";function W7(e){let{components:n,...t}=e;return(0,s.yg)(R7,(0,p.A)({},I7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}W7.isMDXComponent=!0;const S7={toc:[]},B7="wrapper";function G7(e){let{components:n,...t}=e;return(0,s.yg)(B7,(0,p.A)({},S7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}G7.isMDXComponent=!0;const E7={toc:[]},O7="wrapper";function U7(e){let{components:n,...t}=e;return(0,s.yg)(O7,(0,p.A)({},E7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}U7.isMDXComponent=!0;const F7={toc:[]},V7="wrapper";function q7(e){let{components:n,...t}=e;return(0,s.yg)(V7,(0,p.A)({},F7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}q7.isMDXComponent=!0;const j7={toc:[]},H7="wrapper";function Y7(e){let{components:n,...t}=e;return(0,s.yg)(H7,(0,p.A)({},j7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Y7.isMDXComponent=!0;const Q7={toc:[]},$7="wrapper";function K7(e){let{components:n,...t}=e;return(0,s.yg)($7,(0,p.A)({},Q7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}K7.isMDXComponent=!0;const J7={toc:[]},Z7="wrapper";function e9(e){let{components:n,...t}=e;return(0,s.yg)(Z7,(0,p.A)({},J7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}e9.isMDXComponent=!0;const n9={toc:[]},t9="wrapper";function o9(e){let{components:n,...t}=e;return(0,s.yg)(t9,(0,p.A)({},n9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}o9.isMDXComponent=!0;const p9={toc:[]},r9="wrapper";function s9(e){let{components:n,...t}=e;return(0,s.yg)(r9,(0,p.A)({},p9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}s9.isMDXComponent=!0;const c9={toc:[]},a9="wrapper";function i9(e){let{components:n,...t}=e;return(0,s.yg)(a9,(0,p.A)({},c9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}i9.isMDXComponent=!0;const l9={toc:[]},u9="wrapper";function m9(e){let{components:n,...t}=e;return(0,s.yg)(u9,(0,p.A)({},l9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}m9.isMDXComponent=!0;const y9={toc:[]},d9="wrapper";function h9(e){let{components:n,...t}=e;return(0,s.yg)(d9,(0,p.A)({},y9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}h9.isMDXComponent=!0;const g9={toc:[]},f9="wrapper";function D9(e){let{components:n,...t}=e;return(0,s.yg)(f9,(0,p.A)({},g9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}D9.isMDXComponent=!0;const M9={toc:[]},X9="wrapper";function _9(e){let{components:n,...t}=e;return(0,s.yg)(X9,(0,p.A)({},M9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_9.isMDXComponent=!0;const w9={toc:[]},T9="wrapper";function C9(e){let{components:n,...t}=e;return(0,s.yg)(T9,(0,p.A)({},w9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}C9.isMDXComponent=!0;const x9={toc:[]},A9="wrapper";function v9(e){let{components:n,...t}=e;return(0,s.yg)(A9,(0,p.A)({},x9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}v9.isMDXComponent=!0;const L9={toc:[]},b9="wrapper";function N9(e){let{components:n,...t}=e;return(0,s.yg)(b9,(0,p.A)({},L9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}N9.isMDXComponent=!0;const k9={toc:[]},z9="wrapper";function P9(e){let{components:n,...t}=e;return(0,s.yg)(z9,(0,p.A)({},k9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}P9.isMDXComponent=!0;const I9={toc:[]},R9="wrapper";function W9(e){let{components:n,...t}=e;return(0,s.yg)(R9,(0,p.A)({},I9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}W9.isMDXComponent=!0;const S9={toc:[]},B9="wrapper";function G9(e){let{components:n,...t}=e;return(0,s.yg)(B9,(0,p.A)({},S9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}G9.isMDXComponent=!0;const E9={toc:[]},O9="wrapper";function U9(e){let{components:n,...t}=e;return(0,s.yg)(O9,(0,p.A)({},E9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}U9.isMDXComponent=!0;const F9={toc:[]},V9="wrapper";function q9(e){let{components:n,...t}=e;return(0,s.yg)(V9,(0,p.A)({},F9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}q9.isMDXComponent=!0;const j9={toc:[]},H9="wrapper";function Y9(e){let{components:n,...t}=e;return(0,s.yg)(H9,(0,p.A)({},j9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Y9.isMDXComponent=!0;const Q9={toc:[]},$9="wrapper";function K9(e){let{components:n,...t}=e;return(0,s.yg)($9,(0,p.A)({},Q9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}K9.isMDXComponent=!0;const J9={toc:[]},Z9="wrapper";function eee(e){let{components:n,...t}=e;return(0,s.yg)(Z9,(0,p.A)({},J9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eee.isMDXComponent=!0;const nee={toc:[]},tee="wrapper";function oee(e){let{components:n,...t}=e;return(0,s.yg)(tee,(0,p.A)({},nee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}oee.isMDXComponent=!0;const pee={toc:[]},ree="wrapper";function see(e){let{components:n,...t}=e;return(0,s.yg)(ree,(0,p.A)({},pee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}see.isMDXComponent=!0;const cee={toc:[]},aee="wrapper";function iee(e){let{components:n,...t}=e;return(0,s.yg)(aee,(0,p.A)({},cee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}iee.isMDXComponent=!0;const lee={toc:[]},uee="wrapper";function mee(e){let{components:n,...t}=e;return(0,s.yg)(uee,(0,p.A)({},lee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}mee.isMDXComponent=!0;const yee={toc:[]},dee="wrapper";function hee(e){let{components:n,...t}=e;return(0,s.yg)(dee,(0,p.A)({},yee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}hee.isMDXComponent=!0;const gee={toc:[]},fee="wrapper";function Dee(e){let{components:n,...t}=e;return(0,s.yg)(fee,(0,p.A)({},gee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Dee.isMDXComponent=!0;const Mee={toc:[]},Xee="wrapper";function _ee(e){let{components:n,...t}=e;return(0,s.yg)(Xee,(0,p.A)({},Mee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}_ee.isMDXComponent=!0;const wee={toc:[]},Tee="wrapper";function Cee(e){let{components:n,...t}=e;return(0,s.yg)(Tee,(0,p.A)({},wee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Cee.isMDXComponent=!0;const xee={toc:[]},Aee="wrapper";function vee(e){let{components:n,...t}=e;return(0,s.yg)(Aee,(0,p.A)({},xee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vee.isMDXComponent=!0;const Lee={toc:[]},bee="wrapper";function Nee(e){let{components:n,...t}=e;return(0,s.yg)(bee,(0,p.A)({},Lee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Nee.isMDXComponent=!0;const kee={toc:[]},zee="wrapper";function Pee(e){let{components:n,...t}=e;return(0,s.yg)(zee,(0,p.A)({},kee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Pee.isMDXComponent=!0;const Iee={toc:[]},Ree="wrapper";function Wee(e){let{components:n,...t}=e;return(0,s.yg)(Ree,(0,p.A)({},Iee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Wee.isMDXComponent=!0;const See={toc:[]},Bee="wrapper";function Gee(e){let{components:n,...t}=e;return(0,s.yg)(Bee,(0,p.A)({},See,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Gee.isMDXComponent=!0;const Eee={toc:[]},Oee="wrapper";function Uee(e){let{components:n,...t}=e;return(0,s.yg)(Oee,(0,p.A)({},Eee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Uee.isMDXComponent=!0;const Fee={toc:[]},Vee="wrapper";function qee(e){let{components:n,...t}=e;return(0,s.yg)(Vee,(0,p.A)({},Fee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}qee.isMDXComponent=!0;const jee={toc:[]},Hee="wrapper";function Yee(e){let{components:n,...t}=e;return(0,s.yg)(Hee,(0,p.A)({},jee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Yee.isMDXComponent=!0;const Qee={toc:[]},$ee="wrapper";function Kee(e){let{components:n,...t}=e;return(0,s.yg)($ee,(0,p.A)({},Qee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Kee.isMDXComponent=!0;const Jee={toc:[]},Zee="wrapper";function ene(e){let{components:n,...t}=e;return(0,s.yg)(Zee,(0,p.A)({},Jee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}ene.isMDXComponent=!0;const nne={toc:[]},tne="wrapper";function one(e){let{components:n,...t}=e;return(0,s.yg)(tne,(0,p.A)({},nne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}one.isMDXComponent=!0;const pne={toc:[]},rne="wrapper";function sne(e){let{components:n,...t}=e;return(0,s.yg)(rne,(0,p.A)({},pne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}sne.isMDXComponent=!0;const cne={toc:[]},ane="wrapper";function ine(e){let{components:n,...t}=e;return(0,s.yg)(ane,(0,p.A)({},cne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}ine.isMDXComponent=!0;const lne={toc:[]},une="wrapper";function mne(e){let{components:n,...t}=e;return(0,s.yg)(une,(0,p.A)({},lne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}mne.isMDXComponent=!0;const yne={toc:[]},dne="wrapper";function hne(e){let{components:n,...t}=e;return(0,s.yg)(dne,(0,p.A)({},yne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hne.isMDXComponent=!0;const gne={toc:[]},fne="wrapper";function Dne(e){let{components:n,...t}=e;return(0,s.yg)(fne,(0,p.A)({},gne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Dne.isMDXComponent=!0;const Mne={toc:[]},Xne="wrapper";function _ne(e){let{components:n,...t}=e;return(0,s.yg)(Xne,(0,p.A)({},Mne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}_ne.isMDXComponent=!0;const wne={toc:[]},Tne="wrapper";function Cne(e){let{components:n,...t}=e;return(0,s.yg)(Tne,(0,p.A)({},wne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Cne.isMDXComponent=!0;const xne={toc:[]},Ane="wrapper";function vne(e){let{components:n,...t}=e;return(0,s.yg)(Ane,(0,p.A)({},xne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}vne.isMDXComponent=!0;const Lne={toc:[]},bne="wrapper";function Nne(e){let{components:n,...t}=e;return(0,s.yg)(bne,(0,p.A)({},Lne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Nne.isMDXComponent=!0;const kne={toc:[]},zne="wrapper";function Pne(e){let{components:n,...t}=e;return(0,s.yg)(zne,(0,p.A)({},kne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Pne.isMDXComponent=!0;const Ine={toc:[]},Rne="wrapper";function Wne(e){let{components:n,...t}=e;return(0,s.yg)(Rne,(0,p.A)({},Ine,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Wne.isMDXComponent=!0;const Sne={toc:[]},Bne="wrapper";function Gne(e){let{components:n,...t}=e;return(0,s.yg)(Bne,(0,p.A)({},Sne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Gne.isMDXComponent=!0;const Ene={toc:[]},One="wrapper";function Une(e){let{components:n,...t}=e;return(0,s.yg)(One,(0,p.A)({},Ene,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Une.isMDXComponent=!0;const Fne={toc:[]},Vne="wrapper";function qne(e){let{components:n,...t}=e;return(0,s.yg)(Vne,(0,p.A)({},Fne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}qne.isMDXComponent=!0;const jne={toc:[]},Hne="wrapper";function Yne(e){let{components:n,...t}=e;return(0,s.yg)(Hne,(0,p.A)({},jne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Yne.isMDXComponent=!0;const Qne={toc:[]},$ne="wrapper";function Kne(e){let{components:n,...t}=e;return(0,s.yg)($ne,(0,p.A)({},Qne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Kne.isMDXComponent=!0;const Jne={toc:[]},Zne="wrapper";function ete(e){let{components:n,...t}=e;return(0,s.yg)(Zne,(0,p.A)({},Jne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}ete.isMDXComponent=!0;const nte={toc:[]},tte="wrapper";function ote(e){let{components:n,...t}=e;return(0,s.yg)(tte,(0,p.A)({},nte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}ote.isMDXComponent=!0;const pte={toc:[]},rte="wrapper";function ste(e){let{components:n,...t}=e;return(0,s.yg)(rte,(0,p.A)({},pte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}ste.isMDXComponent=!0;const cte={toc:[]},ate="wrapper";function ite(e){let{components:n,...t}=e;return(0,s.yg)(ate,(0,p.A)({},cte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ite.isMDXComponent=!0;const lte={toc:[]},ute="wrapper";function mte(e){let{components:n,...t}=e;return(0,s.yg)(ute,(0,p.A)({},lte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}mte.isMDXComponent=!0;const yte={toc:[]},dte="wrapper";function hte(e){let{components:n,...t}=e;return(0,s.yg)(dte,(0,p.A)({},yte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}hte.isMDXComponent=!0;const gte={toc:[]},fte="wrapper";function Dte(e){let{components:n,...t}=e;return(0,s.yg)(fte,(0,p.A)({},gte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Dte.isMDXComponent=!0;const Mte={toc:[]},Xte="wrapper";function _te(e){let{components:n,...t}=e;return(0,s.yg)(Xte,(0,p.A)({},Mte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}_te.isMDXComponent=!0;const wte={toc:[]},Tte="wrapper";function Cte(e){let{components:n,...t}=e;return(0,s.yg)(Tte,(0,p.A)({},wte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Cte.isMDXComponent=!0;const xte={toc:[]},Ate="wrapper";function vte(e){let{components:n,...t}=e;return(0,s.yg)(Ate,(0,p.A)({},xte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vte.isMDXComponent=!0;const Lte={toc:[]},bte="wrapper";function Nte(e){let{components:n,...t}=e;return(0,s.yg)(bte,(0,p.A)({},Lte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Nte.isMDXComponent=!0;const kte={toc:[]},zte="wrapper";function Pte(e){let{components:n,...t}=e;return(0,s.yg)(zte,(0,p.A)({},kte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Pte.isMDXComponent=!0;const Ite={toc:[]},Rte="wrapper";function Wte(e){let{components:n,...t}=e;return(0,s.yg)(Rte,(0,p.A)({},Ite,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Wte.isMDXComponent=!0;const Ste={toc:[]},Bte="wrapper";function Gte(e){let{components:n,...t}=e;return(0,s.yg)(Bte,(0,p.A)({},Ste,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Gte.isMDXComponent=!0;const Ete={toc:[]},Ote="wrapper";function Ute(e){let{components:n,...t}=e;return(0,s.yg)(Ote,(0,p.A)({},Ete,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Ute.isMDXComponent=!0;const Fte={toc:[]},Vte="wrapper";function qte(e){let{components:n,...t}=e;return(0,s.yg)(Vte,(0,p.A)({},Fte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}qte.isMDXComponent=!0;const jte={toc:[]},Hte="wrapper";function Yte(e){let{components:n,...t}=e;return(0,s.yg)(Hte,(0,p.A)({},jte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Yte.isMDXComponent=!0;const Qte={toc:[]},$te="wrapper";function Kte(e){let{components:n,...t}=e;return(0,s.yg)($te,(0,p.A)({},Qte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Kte.isMDXComponent=!0;const Jte={toc:[]},Zte="wrapper";function eoe(e){let{components:n,...t}=e;return(0,s.yg)(Zte,(0,p.A)({},Jte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}eoe.isMDXComponent=!0;const noe={toc:[]},toe="wrapper";function ooe(e){let{components:n,...t}=e;return(0,s.yg)(toe,(0,p.A)({},noe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ooe.isMDXComponent=!0;const poe={toc:[]},roe="wrapper";function soe(e){let{components:n,...t}=e;return(0,s.yg)(roe,(0,p.A)({},poe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}soe.isMDXComponent=!0;const coe={toc:[]},aoe="wrapper";function ioe(e){let{components:n,...t}=e;return(0,s.yg)(aoe,(0,p.A)({},coe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ioe.isMDXComponent=!0;const loe={toc:[]},uoe="wrapper";function moe(e){let{components:n,...t}=e;return(0,s.yg)(uoe,(0,p.A)({},loe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}moe.isMDXComponent=!0;const yoe={toc:[]},doe="wrapper";function hoe(e){let{components:n,...t}=e;return(0,s.yg)(doe,(0,p.A)({},yoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hoe.isMDXComponent=!0;const goe={toc:[]},foe="wrapper";function Doe(e){let{components:n,...t}=e;return(0,s.yg)(foe,(0,p.A)({},goe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Doe.isMDXComponent=!0;const Moe={toc:[]},Xoe="wrapper";function _oe(e){let{components:n,...t}=e;return(0,s.yg)(Xoe,(0,p.A)({},Moe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_oe.isMDXComponent=!0;const woe={toc:[]},Toe="wrapper";function Coe(e){let{components:n,...t}=e;return(0,s.yg)(Toe,(0,p.A)({},woe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Coe.isMDXComponent=!0;const xoe={toc:[]},Aoe="wrapper";function voe(e){let{components:n,...t}=e;return(0,s.yg)(Aoe,(0,p.A)({},xoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}voe.isMDXComponent=!0;const Loe={toc:[]},boe="wrapper";function Noe(e){let{components:n,...t}=e;return(0,s.yg)(boe,(0,p.A)({},Loe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Noe.isMDXComponent=!0;const koe={toc:[]},zoe="wrapper";function Poe(e){let{components:n,...t}=e;return(0,s.yg)(zoe,(0,p.A)({},koe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Poe.isMDXComponent=!0;const Ioe={toc:[]},Roe="wrapper";function Woe(e){let{components:n,...t}=e;return(0,s.yg)(Roe,(0,p.A)({},Ioe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Woe.isMDXComponent=!0;const Soe={toc:[]},Boe="wrapper";function Goe(e){let{components:n,...t}=e;return(0,s.yg)(Boe,(0,p.A)({},Soe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Goe.isMDXComponent=!0;const Eoe={toc:[]},Ooe="wrapper";function Uoe(e){let{components:n,...t}=e;return(0,s.yg)(Ooe,(0,p.A)({},Eoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Uoe.isMDXComponent=!0;const Foe={toc:[]},Voe="wrapper";function qoe(e){let{components:n,...t}=e;return(0,s.yg)(Voe,(0,p.A)({},Foe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}qoe.isMDXComponent=!0;const joe={toc:[]},Hoe="wrapper";function Yoe(e){let{components:n,...t}=e;return(0,s.yg)(Hoe,(0,p.A)({},joe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Yoe.isMDXComponent=!0;const Qoe={toc:[]},$oe="wrapper";function Koe(e){let{components:n,...t}=e;return(0,s.yg)($oe,(0,p.A)({},Qoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Koe.isMDXComponent=!0;const Joe={toc:[]},Zoe="wrapper";function epe(e){let{components:n,...t}=e;return(0,s.yg)(Zoe,(0,p.A)({},Joe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}epe.isMDXComponent=!0;const npe={toc:[]},tpe="wrapper";function ope(e){let{components:n,...t}=e;return(0,s.yg)(tpe,(0,p.A)({},npe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}ope.isMDXComponent=!0;const ppe={toc:[]},rpe="wrapper";function spe(e){let{components:n,...t}=e;return(0,s.yg)(rpe,(0,p.A)({},ppe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}spe.isMDXComponent=!0;const cpe={toc:[]},ape="wrapper";function ipe(e){let{components:n,...t}=e;return(0,s.yg)(ape,(0,p.A)({},cpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ipe.isMDXComponent=!0;const lpe={toc:[]},upe="wrapper";function mpe(e){let{components:n,...t}=e;return(0,s.yg)(upe,(0,p.A)({},lpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}mpe.isMDXComponent=!0;const ype={toc:[]},dpe="wrapper";function hpe(e){let{components:n,...t}=e;return(0,s.yg)(dpe,(0,p.A)({},ype,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}hpe.isMDXComponent=!0;const gpe={toc:[]},fpe="wrapper";function Dpe(e){let{components:n,...t}=e;return(0,s.yg)(fpe,(0,p.A)({},gpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Dpe.isMDXComponent=!0;const Mpe={toc:[]},Xpe="wrapper";function _pe(e){let{components:n,...t}=e;return(0,s.yg)(Xpe,(0,p.A)({},Mpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}_pe.isMDXComponent=!0;const wpe={toc:[]},Tpe="wrapper";function Cpe(e){let{components:n,...t}=e;return(0,s.yg)(Tpe,(0,p.A)({},wpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Cpe.isMDXComponent=!0;const xpe={toc:[]},Ape="wrapper";function vpe(e){let{components:n,...t}=e;return(0,s.yg)(Ape,(0,p.A)({},xpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}vpe.isMDXComponent=!0;const Lpe={toc:[]},bpe="wrapper";function Npe(e){let{components:n,...t}=e;return(0,s.yg)(bpe,(0,p.A)({},Lpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Npe.isMDXComponent=!0;const kpe={toc:[]},zpe="wrapper";function Ppe(e){let{components:n,...t}=e;return(0,s.yg)(zpe,(0,p.A)({},kpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ppe.isMDXComponent=!0;const Ipe={toc:[]},Rpe="wrapper";function Wpe(e){let{components:n,...t}=e;return(0,s.yg)(Rpe,(0,p.A)({},Ipe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Wpe.isMDXComponent=!0;const Spe={toc:[]},Bpe="wrapper";function Gpe(e){let{components:n,...t}=e;return(0,s.yg)(Bpe,(0,p.A)({},Spe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Gpe.isMDXComponent=!0;const Epe={toc:[]},Ope="wrapper";function Upe(e){let{components:n,...t}=e;return(0,s.yg)(Ope,(0,p.A)({},Epe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Upe.isMDXComponent=!0;const Fpe={toc:[]},Vpe="wrapper";function qpe(e){let{components:n,...t}=e;return(0,s.yg)(Vpe,(0,p.A)({},Fpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}qpe.isMDXComponent=!0;const jpe={toc:[]},Hpe="wrapper";function Ype(e){let{components:n,...t}=e;return(0,s.yg)(Hpe,(0,p.A)({},jpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ype.isMDXComponent=!0;const Qpe={toc:[]},$pe="wrapper";function Kpe(e){let{components:n,...t}=e;return(0,s.yg)($pe,(0,p.A)({},Qpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]},Zpe="wrapper";function ere(e){let{components:n,...t}=e;return(0,s.yg)(Zpe,(0,p.A)({},Jpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ere.isMDXComponent=!0;const nre={toc:[]},tre="wrapper";function ore(e){let{components:n,...t}=e;return(0,s.yg)(tre,(0,p.A)({},nre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}ore.isMDXComponent=!0;const pre={toc:[]},rre="wrapper";function sre(e){let{components:n,...t}=e;return(0,s.yg)(rre,(0,p.A)({},pre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}sre.isMDXComponent=!0;const cre={toc:[]},are="wrapper";function ire(e){let{components:n,...t}=e;return(0,s.yg)(are,(0,p.A)({},cre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}ire.isMDXComponent=!0;const lre={toc:[]},ure="wrapper";function mre(e){let{components:n,...t}=e;return(0,s.yg)(ure,(0,p.A)({},lre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}mre.isMDXComponent=!0;const yre={toc:[]},dre="wrapper";function hre(e){let{components:n,...t}=e;return(0,s.yg)(dre,(0,p.A)({},yre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}hre.isMDXComponent=!0;const gre={toc:[]},fre="wrapper";function Dre(e){let{components:n,...t}=e;return(0,s.yg)(fre,(0,p.A)({},gre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Dre.isMDXComponent=!0;const Mre={toc:[]},Xre="wrapper";function _re(e){let{components:n,...t}=e;return(0,s.yg)(Xre,(0,p.A)({},Mre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}_re.isMDXComponent=!0;const wre={toc:[]},Tre="wrapper";function Cre(e){let{components:n,...t}=e;return(0,s.yg)(Tre,(0,p.A)({},wre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Cre.isMDXComponent=!0;const xre={toc:[]},Are="wrapper";function vre(e){let{components:n,...t}=e;return(0,s.yg)(Are,(0,p.A)({},xre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}vre.isMDXComponent=!0;const Lre={toc:[]},bre="wrapper";function Nre(e){let{components:n,...t}=e;return(0,s.yg)(bre,(0,p.A)({},Lre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Nre.isMDXComponent=!0;const kre={toc:[]},zre="wrapper";function Pre(e){let{components:n,...t}=e;return(0,s.yg)(zre,(0,p.A)({},kre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Pre.isMDXComponent=!0;const Ire={toc:[]},Rre="wrapper";function Wre(e){let{components:n,...t}=e;return(0,s.yg)(Rre,(0,p.A)({},Ire,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Wre.isMDXComponent=!0;const Sre={toc:[]},Bre="wrapper";function Gre(e){let{components:n,...t}=e;return(0,s.yg)(Bre,(0,p.A)({},Sre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Gre.isMDXComponent=!0;const Ere={toc:[]},Ore="wrapper";function Ure(e){let{components:n,...t}=e;return(0,s.yg)(Ore,(0,p.A)({},Ere,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Ure.isMDXComponent=!0;const Fre={toc:[]},Vre="wrapper";function qre(e){let{components:n,...t}=e;return(0,s.yg)(Vre,(0,p.A)({},Fre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qre.isMDXComponent=!0;const jre={toc:[]},Hre="wrapper";function Yre(e){let{components:n,...t}=e;return(0,s.yg)(Hre,(0,p.A)({},jre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Yre.isMDXComponent=!0;const Qre={toc:[]},$re="wrapper";function Kre(e){let{components:n,...t}=e;return(0,s.yg)($re,(0,p.A)({},Qre,t,{components:n,mdxType:"MDXLayout"}))}Kre.isMDXComponent=!0;const Jre={toc:[]},Zre="wrapper";function ese(e){let{components:n,...t}=e;return(0,s.yg)(Zre,(0,p.A)({},Jre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ese.isMDXComponent=!0;const nse={toc:[]},tse="wrapper";function ose(e){let{components:n,...t}=e;return(0,s.yg)(tse,(0,p.A)({},nse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ose.isMDXComponent=!0;const pse={toc:[]},rse="wrapper";function sse(e){let{components:n,...t}=e;return(0,s.yg)(rse,(0,p.A)({},pse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}sse.isMDXComponent=!0;const cse={toc:[]},ase="wrapper";function ise(e){let{components:n,...t}=e;return(0,s.yg)(ase,(0,p.A)({},cse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}ise.isMDXComponent=!0;const lse={toc:[]},use="wrapper";function mse(e){let{components:n,...t}=e;return(0,s.yg)(use,(0,p.A)({},lse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}mse.isMDXComponent=!0;const yse={toc:[]},dse="wrapper";function hse(e){let{components:n,...t}=e;return(0,s.yg)(dse,(0,p.A)({},yse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}hse.isMDXComponent=!0;const gse={toc:[]},fse="wrapper";function Dse(e){let{components:n,...t}=e;return(0,s.yg)(fse,(0,p.A)({},gse,t,{components:n,mdxType:"MDXLayout"}))}Dse.isMDXComponent=!0;const Mse={toc:[]},Xse="wrapper";function _se(e){let{components:n,...t}=e;return(0,s.yg)(Xse,(0,p.A)({},Mse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}_se.isMDXComponent=!0;const wse={toc:[]},Tse="wrapper";function Cse(e){let{components:n,...t}=e;return(0,s.yg)(Tse,(0,p.A)({},wse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Cse.isMDXComponent=!0;const xse={toc:[]},Ase="wrapper";function vse(e){let{components:n,...t}=e;return(0,s.yg)(Ase,(0,p.A)({},xse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}vse.isMDXComponent=!0;const Lse={toc:[]},bse="wrapper";function Nse(e){let{components:n,...t}=e;return(0,s.yg)(bse,(0,p.A)({},Lse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Nse.isMDXComponent=!0;const kse={toc:[]},zse="wrapper";function Pse(e){let{components:n,...t}=e;return(0,s.yg)(zse,(0,p.A)({},kse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Pse.isMDXComponent=!0;const Ise={toc:[]},Rse="wrapper";function Wse(e){let{components:n,...t}=e;return(0,s.yg)(Rse,(0,p.A)({},Ise,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Wse.isMDXComponent=!0;const Sse={toc:[]},Bse="wrapper";function Gse(e){let{components:n,...t}=e;return(0,s.yg)(Bse,(0,p.A)({},Sse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Gse.isMDXComponent=!0;const Ese={toc:[]},Ose="wrapper";function Use(e){let{components:n,...t}=e;return(0,s.yg)(Ose,(0,p.A)({},Ese,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Use.isMDXComponent=!0;const Fse={toc:[]},Vse="wrapper";function qse(e){let{components:n,...t}=e;return(0,s.yg)(Vse,(0,p.A)({},Fse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}qse.isMDXComponent=!0;const jse={toc:[]},Hse="wrapper";function Yse(e){let{components:n,...t}=e;return(0,s.yg)(Hse,(0,p.A)({},jse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Yse.isMDXComponent=!0;const Qse={toc:[]},$se="wrapper";function Kse(e){let{components:n,...t}=e;return(0,s.yg)($se,(0,p.A)({},Qse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Kse.isMDXComponent=!0;const Jse={toc:[]},Zse="wrapper";function ece(e){let{components:n,...t}=e;return(0,s.yg)(Zse,(0,p.A)({},Jse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ece.isMDXComponent=!0;const nce={toc:[]},tce="wrapper";function oce(e){let{components:n,...t}=e;return(0,s.yg)(tce,(0,p.A)({},nce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}oce.isMDXComponent=!0;const pce={toc:[]},rce="wrapper";function sce(e){let{components:n,...t}=e;return(0,s.yg)(rce,(0,p.A)({},pce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sce.isMDXComponent=!0;const cce={toc:[]},ace="wrapper";function ice(e){let{components:n,...t}=e;return(0,s.yg)(ace,(0,p.A)({},cce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}ice.isMDXComponent=!0;const lce={toc:[]},uce="wrapper";function mce(e){let{components:n,...t}=e;return(0,s.yg)(uce,(0,p.A)({},lce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}mce.isMDXComponent=!0;const yce={toc:[]},dce="wrapper";function hce(e){let{components:n,...t}=e;return(0,s.yg)(dce,(0,p.A)({},yce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hce.isMDXComponent=!0;const gce={toc:[]},fce="wrapper";function Dce(e){let{components:n,...t}=e;return(0,s.yg)(fce,(0,p.A)({},gce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Dce.isMDXComponent=!0;const Mce={toc:[]},Xce="wrapper";function _ce(e){let{components:n,...t}=e;return(0,s.yg)(Xce,(0,p.A)({},Mce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}_ce.isMDXComponent=!0;const wce={toc:[]},Tce="wrapper";function Cce(e){let{components:n,...t}=e;return(0,s.yg)(Tce,(0,p.A)({},wce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Cce.isMDXComponent=!0;const xce={toc:[]},Ace="wrapper";function vce(e){let{components:n,...t}=e;return(0,s.yg)(Ace,(0,p.A)({},xce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vce.isMDXComponent=!0;const Lce={toc:[]},bce="wrapper";function Nce(e){let{components:n,...t}=e;return(0,s.yg)(bce,(0,p.A)({},Lce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Nce.isMDXComponent=!0;const kce={toc:[]},zce="wrapper";function Pce(e){let{components:n,...t}=e;return(0,s.yg)(zce,(0,p.A)({},kce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Pce.isMDXComponent=!0;const Ice={toc:[]},Rce="wrapper";function Wce(e){let{components:n,...t}=e;return(0,s.yg)(Rce,(0,p.A)({},Ice,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Wce.isMDXComponent=!0;const Sce={toc:[]},Bce="wrapper";function Gce(e){let{components:n,...t}=e;return(0,s.yg)(Bce,(0,p.A)({},Sce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Gce.isMDXComponent=!0;const Ece={toc:[]},Oce="wrapper";function Uce(e){let{components:n,...t}=e;return(0,s.yg)(Oce,(0,p.A)({},Ece,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Uce.isMDXComponent=!0;const Fce={toc:[]},Vce="wrapper";function qce(e){let{components:n,...t}=e;return(0,s.yg)(Vce,(0,p.A)({},Fce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qce.isMDXComponent=!0;const jce={toc:[]},Hce="wrapper";function Yce(e){let{components:n,...t}=e;return(0,s.yg)(Hce,(0,p.A)({},jce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Yce.isMDXComponent=!0;const Qce={toc:[]},$ce="wrapper";function Kce(e){let{components:n,...t}=e;return(0,s.yg)($ce,(0,p.A)({},Qce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Kce.isMDXComponent=!0;const Jce={toc:[]},Zce="wrapper";function eae(e){let{components:n,...t}=e;return(0,s.yg)(Zce,(0,p.A)({},Jce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}eae.isMDXComponent=!0;const nae={toc:[]},tae="wrapper";function oae(e){let{components:n,...t}=e;return(0,s.yg)(tae,(0,p.A)({},nae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}oae.isMDXComponent=!0;const pae={toc:[]},rae="wrapper";function sae(e){let{components:n,...t}=e;return(0,s.yg)(rae,(0,p.A)({},pae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}sae.isMDXComponent=!0;const cae={toc:[]},aae="wrapper";function iae(e){let{components:n,...t}=e;return(0,s.yg)(aae,(0,p.A)({},cae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}iae.isMDXComponent=!0;const lae={toc:[]},uae="wrapper";function mae(e){let{components:n,...t}=e;return(0,s.yg)(uae,(0,p.A)({},lae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}mae.isMDXComponent=!0;const yae={toc:[]},dae="wrapper";function hae(e){let{components:n,...t}=e;return(0,s.yg)(dae,(0,p.A)({},yae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}hae.isMDXComponent=!0;const gae={toc:[]},fae="wrapper";function Dae(e){let{components:n,...t}=e;return(0,s.yg)(fae,(0,p.A)({},gae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Dae.isMDXComponent=!0;const Mae={toc:[]},Xae="wrapper";function _ae(e){let{components:n,...t}=e;return(0,s.yg)(Xae,(0,p.A)({},Mae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}_ae.isMDXComponent=!0;const wae={toc:[]},Tae="wrapper";function Cae(e){let{components:n,...t}=e;return(0,s.yg)(Tae,(0,p.A)({},wae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Cae.isMDXComponent=!0;const xae={toc:[]},Aae="wrapper";function vae(e){let{components:n,...t}=e;return(0,s.yg)(Aae,(0,p.A)({},xae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}vae.isMDXComponent=!0;const Lae={toc:[]},bae="wrapper";function Nae(e){let{components:n,...t}=e;return(0,s.yg)(bae,(0,p.A)({},Lae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Nae.isMDXComponent=!0;const kae={toc:[]},zae="wrapper";function Pae(e){let{components:n,...t}=e;return(0,s.yg)(zae,(0,p.A)({},kae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Pae.isMDXComponent=!0;const Iae={toc:[]},Rae="wrapper";function Wae(e){let{components:n,...t}=e;return(0,s.yg)(Rae,(0,p.A)({},Iae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Wae.isMDXComponent=!0;const Sae={toc:[]},Bae="wrapper";function Gae(e){let{components:n,...t}=e;return(0,s.yg)(Bae,(0,p.A)({},Sae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Gae.isMDXComponent=!0;const Eae={toc:[]},Oae="wrapper";function Uae(e){let{components:n,...t}=e;return(0,s.yg)(Oae,(0,p.A)({},Eae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Uae.isMDXComponent=!0;const Fae={toc:[]},Vae="wrapper";function qae(e){let{components:n,...t}=e;return(0,s.yg)(Vae,(0,p.A)({},Fae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}qae.isMDXComponent=!0;const jae={toc:[]},Hae="wrapper";function Yae(e){let{components:n,...t}=e;return(0,s.yg)(Hae,(0,p.A)({},jae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Yae.isMDXComponent=!0;const Qae={toc:[]},$ae="wrapper";function Kae(e){let{components:n,...t}=e;return(0,s.yg)($ae,(0,p.A)({},Qae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Kae.isMDXComponent=!0;const Jae={toc:[]},Zae="wrapper";function eie(e){let{components:n,...t}=e;return(0,s.yg)(Zae,(0,p.A)({},Jae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}eie.isMDXComponent=!0;const nie={toc:[]},tie="wrapper";function oie(e){let{components:n,...t}=e;return(0,s.yg)(tie,(0,p.A)({},nie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}oie.isMDXComponent=!0;const pie={toc:[]},rie="wrapper";function sie(e){let{components:n,...t}=e;return(0,s.yg)(rie,(0,p.A)({},pie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}sie.isMDXComponent=!0;const cie={toc:[]},aie="wrapper";function iie(e){let{components:n,...t}=e;return(0,s.yg)(aie,(0,p.A)({},cie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}iie.isMDXComponent=!0;const lie={toc:[]},uie="wrapper";function mie(e){let{components:n,...t}=e;return(0,s.yg)(uie,(0,p.A)({},lie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}mie.isMDXComponent=!0;const yie={toc:[]},die="wrapper";function hie(e){let{components:n,...t}=e;return(0,s.yg)(die,(0,p.A)({},yie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}hie.isMDXComponent=!0;const gie={toc:[]},fie="wrapper";function Die(e){let{components:n,...t}=e;return(0,s.yg)(fie,(0,p.A)({},gie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Die.isMDXComponent=!0;const Mie={toc:[]},Xie="wrapper";function _ie(e){let{components:n,...t}=e;return(0,s.yg)(Xie,(0,p.A)({},Mie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}_ie.isMDXComponent=!0;const wie={toc:[]},Tie="wrapper";function Cie(e){let{components:n,...t}=e;return(0,s.yg)(Tie,(0,p.A)({},wie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Cie.isMDXComponent=!0;const xie={toc:[]},Aie="wrapper";function vie(e){let{components:n,...t}=e;return(0,s.yg)(Aie,(0,p.A)({},xie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}vie.isMDXComponent=!0;const Lie={toc:[]},bie="wrapper";function Nie(e){let{components:n,...t}=e;return(0,s.yg)(bie,(0,p.A)({},Lie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Nie.isMDXComponent=!0;const kie={toc:[]},zie="wrapper";function Pie(e){let{components:n,...t}=e;return(0,s.yg)(zie,(0,p.A)({},kie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Pie.isMDXComponent=!0;const Iie={toc:[]},Rie="wrapper";function Wie(e){let{components:n,...t}=e;return(0,s.yg)(Rie,(0,p.A)({},Iie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Wie.isMDXComponent=!0;const Sie={toc:[]},Bie="wrapper";function Gie(e){let{components:n,...t}=e;return(0,s.yg)(Bie,(0,p.A)({},Sie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Gie.isMDXComponent=!0;const Eie={toc:[]},Oie="wrapper";function Uie(e){let{components:n,...t}=e;return(0,s.yg)(Oie,(0,p.A)({},Eie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Uie.isMDXComponent=!0;const Fie={toc:[]},Vie="wrapper";function qie(e){let{components:n,...t}=e;return(0,s.yg)(Vie,(0,p.A)({},Fie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}qie.isMDXComponent=!0;const jie={toc:[]},Hie="wrapper";function Yie(e){let{components:n,...t}=e;return(0,s.yg)(Hie,(0,p.A)({},jie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Yie.isMDXComponent=!0;const Qie={toc:[]},$ie="wrapper";function Kie(e){let{components:n,...t}=e;return(0,s.yg)($ie,(0,p.A)({},Qie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Kie.isMDXComponent=!0;const Jie={toc:[]},Zie="wrapper";function ele(e){let{components:n,...t}=e;return(0,s.yg)(Zie,(0,p.A)({},Jie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ele.isMDXComponent=!0;const nle={toc:[]},tle="wrapper";function ole(e){let{components:n,...t}=e;return(0,s.yg)(tle,(0,p.A)({},nle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}ole.isMDXComponent=!0;const ple={toc:[]},rle="wrapper";function sle(e){let{components:n,...t}=e;return(0,s.yg)(rle,(0,p.A)({},ple,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sle.isMDXComponent=!0;const cle={toc:[]},ale="wrapper";function ile(e){let{components:n,...t}=e;return(0,s.yg)(ale,(0,p.A)({},cle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}ile.isMDXComponent=!0;const lle={toc:[]},ule="wrapper";function mle(e){let{components:n,...t}=e;return(0,s.yg)(ule,(0,p.A)({},lle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}mle.isMDXComponent=!0;const yle={toc:[]},dle="wrapper";function hle(e){let{components:n,...t}=e;return(0,s.yg)(dle,(0,p.A)({},yle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}hle.isMDXComponent=!0;const gle={toc:[]},fle="wrapper";function Dle(e){let{components:n,...t}=e;return(0,s.yg)(fle,(0,p.A)({},gle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Dle.isMDXComponent=!0;const Mle={toc:[]},Xle="wrapper";function _le(e){let{components:n,...t}=e;return(0,s.yg)(Xle,(0,p.A)({},Mle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}_le.isMDXComponent=!0;const wle={toc:[]},Tle="wrapper";function Cle(e){let{components:n,...t}=e;return(0,s.yg)(Tle,(0,p.A)({},wle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Cle.isMDXComponent=!0;const xle={toc:[]},Ale="wrapper";function vle(e){let{components:n,...t}=e;return(0,s.yg)(Ale,(0,p.A)({},xle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}vle.isMDXComponent=!0;const Lle={toc:[]},ble="wrapper";function Nle(e){let{components:n,...t}=e;return(0,s.yg)(ble,(0,p.A)({},Lle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Nle.isMDXComponent=!0;const kle={toc:[]},zle="wrapper";function Ple(e){let{components:n,...t}=e;return(0,s.yg)(zle,(0,p.A)({},kle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Ple.isMDXComponent=!0;const Ile={toc:[]},Rle="wrapper";function Wle(e){let{components:n,...t}=e;return(0,s.yg)(Rle,(0,p.A)({},Ile,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Wle.isMDXComponent=!0;const Sle={toc:[]},Ble="wrapper";function Gle(e){let{components:n,...t}=e;return(0,s.yg)(Ble,(0,p.A)({},Sle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Gle.isMDXComponent=!0;const Ele={toc:[]},Ole="wrapper";function Ule(e){let{components:n,...t}=e;return(0,s.yg)(Ole,(0,p.A)({},Ele,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Ule.isMDXComponent=!0;const Fle={toc:[]},Vle="wrapper";function qle(e){let{components:n,...t}=e;return(0,s.yg)(Vle,(0,p.A)({},Fle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}qle.isMDXComponent=!0;const jle={toc:[]},Hle="wrapper";function Yle(e){let{components:n,...t}=e;return(0,s.yg)(Hle,(0,p.A)({},jle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Yle.isMDXComponent=!0;const Qle={toc:[]},$le="wrapper";function Kle(e){let{components:n,...t}=e;return(0,s.yg)($le,(0,p.A)({},Qle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Kle.isMDXComponent=!0;const Jle={toc:[]},Zle="wrapper";function eue(e){let{components:n,...t}=e;return(0,s.yg)(Zle,(0,p.A)({},Jle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}eue.isMDXComponent=!0;const nue={toc:[]},tue="wrapper";function oue(e){let{components:n,...t}=e;return(0,s.yg)(tue,(0,p.A)({},nue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oue.isMDXComponent=!0;const pue={toc:[]},rue="wrapper";function sue(e){let{components:n,...t}=e;return(0,s.yg)(rue,(0,p.A)({},pue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}sue.isMDXComponent=!0;const cue={toc:[]},aue="wrapper";function iue(e){let{components:n,...t}=e;return(0,s.yg)(aue,(0,p.A)({},cue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}iue.isMDXComponent=!0;const lue={toc:[]},uue="wrapper";function mue(e){let{components:n,...t}=e;return(0,s.yg)(uue,(0,p.A)({},lue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}mue.isMDXComponent=!0;const yue={toc:[]},due="wrapper";function hue(e){let{components:n,...t}=e;return(0,s.yg)(due,(0,p.A)({},yue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}hue.isMDXComponent=!0;const gue={toc:[]},fue="wrapper";function Due(e){let{components:n,...t}=e;return(0,s.yg)(fue,(0,p.A)({},gue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Due.isMDXComponent=!0;const Mue={toc:[]},Xue="wrapper";function _ue(e){let{components:n,...t}=e;return(0,s.yg)(Xue,(0,p.A)({},Mue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}_ue.isMDXComponent=!0;const wue={toc:[]},Tue="wrapper";function Cue(e){let{components:n,...t}=e;return(0,s.yg)(Tue,(0,p.A)({},wue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Cue.isMDXComponent=!0;const xue={toc:[]},Aue="wrapper";function vue(e){let{components:n,...t}=e;return(0,s.yg)(Aue,(0,p.A)({},xue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}vue.isMDXComponent=!0;const Lue={toc:[]},bue="wrapper";function Nue(e){let{components:n,...t}=e;return(0,s.yg)(bue,(0,p.A)({},Lue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Nue.isMDXComponent=!0;const kue={toc:[]},zue="wrapper";function Pue(e){let{components:n,...t}=e;return(0,s.yg)(zue,(0,p.A)({},kue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Pue.isMDXComponent=!0;const Iue={toc:[]},Rue="wrapper";function Wue(e){let{components:n,...t}=e;return(0,s.yg)(Rue,(0,p.A)({},Iue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Wue.isMDXComponent=!0;const Sue={toc:[]},Bue="wrapper";function Gue(e){let{components:n,...t}=e;return(0,s.yg)(Bue,(0,p.A)({},Sue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Gue.isMDXComponent=!0;const Eue={toc:[]},Oue="wrapper";function Uue(e){let{components:n,...t}=e;return(0,s.yg)(Oue,(0,p.A)({},Eue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Uue.isMDXComponent=!0;const Fue={toc:[]},Vue="wrapper";function que(e){let{components:n,...t}=e;return(0,s.yg)(Vue,(0,p.A)({},Fue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}que.isMDXComponent=!0;const jue={toc:[]},Hue="wrapper";function Yue(e){let{components:n,...t}=e;return(0,s.yg)(Hue,(0,p.A)({},jue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Yue.isMDXComponent=!0;const Que={toc:[]},$ue="wrapper";function Kue(e){let{components:n,...t}=e;return(0,s.yg)($ue,(0,p.A)({},Que,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Kue.isMDXComponent=!0;const Jue={toc:[]},Zue="wrapper";function eme(e){let{components:n,...t}=e;return(0,s.yg)(Zue,(0,p.A)({},Jue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}eme.isMDXComponent=!0;const nme={toc:[]},tme="wrapper";function ome(e){let{components:n,...t}=e;return(0,s.yg)(tme,(0,p.A)({},nme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ome.isMDXComponent=!0;const pme={toc:[]},rme="wrapper";function sme(e){let{components:n,...t}=e;return(0,s.yg)(rme,(0,p.A)({},pme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}sme.isMDXComponent=!0;const cme={toc:[]},ame="wrapper";function ime(e){let{components:n,...t}=e;return(0,s.yg)(ame,(0,p.A)({},cme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ime.isMDXComponent=!0;const lme={toc:[]},ume="wrapper";function mme(e){let{components:n,...t}=e;return(0,s.yg)(ume,(0,p.A)({},lme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}mme.isMDXComponent=!0;const yme={toc:[]},dme="wrapper";function hme(e){let{components:n,...t}=e;return(0,s.yg)(dme,(0,p.A)({},yme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}hme.isMDXComponent=!0;const gme={toc:[]},fme="wrapper";function Dme(e){let{components:n,...t}=e;return(0,s.yg)(fme,(0,p.A)({},gme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Dme.isMDXComponent=!0;const Mme={toc:[]},Xme="wrapper";function _me(e){let{components:n,...t}=e;return(0,s.yg)(Xme,(0,p.A)({},Mme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}_me.isMDXComponent=!0;const wme={toc:[]},Tme="wrapper";function Cme(e){let{components:n,...t}=e;return(0,s.yg)(Tme,(0,p.A)({},wme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Cme.isMDXComponent=!0;const xme={toc:[]},Ame="wrapper";function vme(e){let{components:n,...t}=e;return(0,s.yg)(Ame,(0,p.A)({},xme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}vme.isMDXComponent=!0;const Lme={toc:[]},bme="wrapper";function Nme(e){let{components:n,...t}=e;return(0,s.yg)(bme,(0,p.A)({},Lme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Nme.isMDXComponent=!0;const kme={toc:[]},zme="wrapper";function Pme(e){let{components:n,...t}=e;return(0,s.yg)(zme,(0,p.A)({},kme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Pme.isMDXComponent=!0;const Ime={toc:[]},Rme="wrapper";function Wme(e){let{components:n,...t}=e;return(0,s.yg)(Rme,(0,p.A)({},Ime,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wme.isMDXComponent=!0;const Sme={toc:[]},Bme="wrapper";function Gme(e){let{components:n,...t}=e;return(0,s.yg)(Bme,(0,p.A)({},Sme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Gme.isMDXComponent=!0;const Eme={toc:[]},Ome="wrapper";function Ume(e){let{components:n,...t}=e;return(0,s.yg)(Ome,(0,p.A)({},Eme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Ume.isMDXComponent=!0;const Fme={toc:[]},Vme="wrapper";function qme(e){let{components:n,...t}=e;return(0,s.yg)(Vme,(0,p.A)({},Fme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}qme.isMDXComponent=!0;const jme={toc:[]},Hme="wrapper";function Yme(e){let{components:n,...t}=e;return(0,s.yg)(Hme,(0,p.A)({},jme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Yme.isMDXComponent=!0;const Qme={toc:[]},$me="wrapper";function Kme(e){let{components:n,...t}=e;return(0,s.yg)($me,(0,p.A)({},Qme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Kme.isMDXComponent=!0;const Jme={toc:[]},Zme="wrapper";function eye(e){let{components:n,...t}=e;return(0,s.yg)(Zme,(0,p.A)({},Jme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}eye.isMDXComponent=!0;const nye={toc:[]},tye="wrapper";function oye(e){let{components:n,...t}=e;return(0,s.yg)(tye,(0,p.A)({},nye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}oye.isMDXComponent=!0;const pye={toc:[]},rye="wrapper";function sye(e){let{components:n,...t}=e;return(0,s.yg)(rye,(0,p.A)({},pye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}sye.isMDXComponent=!0;const cye={toc:[]},aye="wrapper";function iye(e){let{components:n,...t}=e;return(0,s.yg)(aye,(0,p.A)({},cye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}iye.isMDXComponent=!0;const lye={toc:[]},uye="wrapper";function mye(e){let{components:n,...t}=e;return(0,s.yg)(uye,(0,p.A)({},lye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}mye.isMDXComponent=!0;const yye={toc:[]},dye="wrapper";function hye(e){let{components:n,...t}=e;return(0,s.yg)(dye,(0,p.A)({},yye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}hye.isMDXComponent=!0;const gye={toc:[]},fye="wrapper";function Dye(e){let{components:n,...t}=e;return(0,s.yg)(fye,(0,p.A)({},gye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Dye.isMDXComponent=!0;const Mye={toc:[]},Xye="wrapper";function _ye(e){let{components:n,...t}=e;return(0,s.yg)(Xye,(0,p.A)({},Mye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}_ye.isMDXComponent=!0;const wye={toc:[]},Tye="wrapper";function Cye(e){let{components:n,...t}=e;return(0,s.yg)(Tye,(0,p.A)({},wye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Cye.isMDXComponent=!0;const xye={toc:[]},Aye="wrapper";function vye(e){let{components:n,...t}=e;return(0,s.yg)(Aye,(0,p.A)({},xye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}vye.isMDXComponent=!0;const Lye={toc:[]},bye="wrapper";function Nye(e){let{components:n,...t}=e;return(0,s.yg)(bye,(0,p.A)({},Lye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Nye.isMDXComponent=!0;const kye={toc:[]},zye="wrapper";function Pye(e){let{components:n,...t}=e;return(0,s.yg)(zye,(0,p.A)({},kye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Pye.isMDXComponent=!0;const Iye={toc:[]},Rye="wrapper";function Wye(e){let{components:n,...t}=e;return(0,s.yg)(Rye,(0,p.A)({},Iye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Wye.isMDXComponent=!0;const Sye={toc:[]},Bye="wrapper";function Gye(e){let{components:n,...t}=e;return(0,s.yg)(Bye,(0,p.A)({},Sye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Gye.isMDXComponent=!0;const Eye={toc:[]},Oye="wrapper";function Uye(e){let{components:n,...t}=e;return(0,s.yg)(Oye,(0,p.A)({},Eye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Uye.isMDXComponent=!0;const Fye={toc:[]},Vye="wrapper";function qye(e){let{components:n,...t}=e;return(0,s.yg)(Vye,(0,p.A)({},Fye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qye.isMDXComponent=!0;const jye={toc:[]},Hye="wrapper";function Yye(e){let{components:n,...t}=e;return(0,s.yg)(Hye,(0,p.A)({},jye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Yye.isMDXComponent=!0;const Qye={toc:[]},$ye="wrapper";function Kye(e){let{components:n,...t}=e;return(0,s.yg)($ye,(0,p.A)({},Qye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Kye.isMDXComponent=!0;const Jye={toc:[]},Zye="wrapper";function ede(e){let{components:n,...t}=e;return(0,s.yg)(Zye,(0,p.A)({},Jye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}ede.isMDXComponent=!0;const nde={toc:[]},tde="wrapper";function ode(e){let{components:n,...t}=e;return(0,s.yg)(tde,(0,p.A)({},nde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}ode.isMDXComponent=!0;const pde={toc:[]},rde="wrapper";function sde(e){let{components:n,...t}=e;return(0,s.yg)(rde,(0,p.A)({},pde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sde.isMDXComponent=!0;const cde={toc:[]},ade="wrapper";function ide(e){let{components:n,...t}=e;return(0,s.yg)(ade,(0,p.A)({},cde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}ide.isMDXComponent=!0;const lde={toc:[]},ude="wrapper";function mde(e){let{components:n,...t}=e;return(0,s.yg)(ude,(0,p.A)({},lde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}mde.isMDXComponent=!0;const yde={toc:[]},dde="wrapper";function hde(e){let{components:n,...t}=e;return(0,s.yg)(dde,(0,p.A)({},yde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}hde.isMDXComponent=!0;const gde={toc:[]},fde="wrapper";function Dde(e){let{components:n,...t}=e;return(0,s.yg)(fde,(0,p.A)({},gde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Dde.isMDXComponent=!0;const Mde={toc:[]},Xde="wrapper";function _de(e){let{components:n,...t}=e;return(0,s.yg)(Xde,(0,p.A)({},Mde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}_de.isMDXComponent=!0;const wde={toc:[]},Tde="wrapper";function Cde(e){let{components:n,...t}=e;return(0,s.yg)(Tde,(0,p.A)({},wde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Cde.isMDXComponent=!0;const xde={toc:[]},Ade="wrapper";function vde(e){let{components:n,...t}=e;return(0,s.yg)(Ade,(0,p.A)({},xde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}vde.isMDXComponent=!0;const Lde={toc:[]},bde="wrapper";function Nde(e){let{components:n,...t}=e;return(0,s.yg)(bde,(0,p.A)({},Lde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Nde.isMDXComponent=!0;const kde={toc:[]},zde="wrapper";function Pde(e){let{components:n,...t}=e;return(0,s.yg)(zde,(0,p.A)({},kde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Pde.isMDXComponent=!0;const Ide={toc:[]},Rde="wrapper";function Wde(e){let{components:n,...t}=e;return(0,s.yg)(Rde,(0,p.A)({},Ide,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Wde.isMDXComponent=!0;const Sde={toc:[]},Bde="wrapper";function Gde(e){let{components:n,...t}=e;return(0,s.yg)(Bde,(0,p.A)({},Sde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Gde.isMDXComponent=!0;const Ede={toc:[]},Ode="wrapper";function Ude(e){let{components:n,...t}=e;return(0,s.yg)(Ode,(0,p.A)({},Ede,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Ude.isMDXComponent=!0;const Fde={toc:[]},Vde="wrapper";function qde(e){let{components:n,...t}=e;return(0,s.yg)(Vde,(0,p.A)({},Fde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qde.isMDXComponent=!0;const jde={toc:[]},Hde="wrapper";function Yde(e){let{components:n,...t}=e;return(0,s.yg)(Hde,(0,p.A)({},jde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Yde.isMDXComponent=!0;const Qde={toc:[]},$de="wrapper";function Kde(e){let{components:n,...t}=e;return(0,s.yg)($de,(0,p.A)({},Qde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Kde.isMDXComponent=!0;const Jde={toc:[]},Zde="wrapper";function ehe(e){let{components:n,...t}=e;return(0,s.yg)(Zde,(0,p.A)({},Jde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ehe.isMDXComponent=!0;const nhe={toc:[]},the="wrapper";function ohe(e){let{components:n,...t}=e;return(0,s.yg)(the,(0,p.A)({},nhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}ohe.isMDXComponent=!0;const phe={toc:[]},rhe="wrapper";function she(e){let{components:n,...t}=e;return(0,s.yg)(rhe,(0,p.A)({},phe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}she.isMDXComponent=!0;const che={toc:[]},ahe="wrapper";function ihe(e){let{components:n,...t}=e;return(0,s.yg)(ahe,(0,p.A)({},che,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ihe.isMDXComponent=!0;const lhe={toc:[]},uhe="wrapper";function mhe(e){let{components:n,...t}=e;return(0,s.yg)(uhe,(0,p.A)({},lhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}mhe.isMDXComponent=!0;const yhe={toc:[]},dhe="wrapper";function hhe(e){let{components:n,...t}=e;return(0,s.yg)(dhe,(0,p.A)({},yhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}hhe.isMDXComponent=!0;const ghe={toc:[]},fhe="wrapper";function Dhe(e){let{components:n,...t}=e;return(0,s.yg)(fhe,(0,p.A)({},ghe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Dhe.isMDXComponent=!0;const Mhe={toc:[]},Xhe="wrapper";function _he(e){let{components:n,...t}=e;return(0,s.yg)(Xhe,(0,p.A)({},Mhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}_he.isMDXComponent=!0;const whe={toc:[]},The="wrapper";function Che(e){let{components:n,...t}=e;return(0,s.yg)(The,(0,p.A)({},whe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Che.isMDXComponent=!0;const xhe={toc:[]},Ahe="wrapper";function vhe(e){let{components:n,...t}=e;return(0,s.yg)(Ahe,(0,p.A)({},xhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vhe.isMDXComponent=!0;const Lhe={toc:[]},bhe="wrapper";function Nhe(e){let{components:n,...t}=e;return(0,s.yg)(bhe,(0,p.A)({},Lhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Nhe.isMDXComponent=!0;const khe={toc:[]},zhe="wrapper";function Phe(e){let{components:n,...t}=e;return(0,s.yg)(zhe,(0,p.A)({},khe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Phe.isMDXComponent=!0;const Ihe={toc:[]},Rhe="wrapper";function Whe(e){let{components:n,...t}=e;return(0,s.yg)(Rhe,(0,p.A)({},Ihe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Whe.isMDXComponent=!0;const She={toc:[]},Bhe="wrapper";function Ghe(e){let{components:n,...t}=e;return(0,s.yg)(Bhe,(0,p.A)({},She,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}Ghe.isMDXComponent=!0;const Ehe={toc:[]},Ohe="wrapper";function Uhe(e){let{components:n,...t}=e;return(0,s.yg)(Ohe,(0,p.A)({},Ehe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}Uhe.isMDXComponent=!0;const Fhe={toc:[]},Vhe="wrapper";function qhe(e){let{components:n,...t}=e;return(0,s.yg)(Vhe,(0,p.A)({},Fhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing circular shapes."))}qhe.isMDXComponent=!0;const jhe={toc:[]},Hhe="wrapper";function Yhe(e){let{components:n,...t}=e;return(0,s.yg)(Hhe,(0,p.A)({},jhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Yhe.isMDXComponent=!0;const Qhe={toc:[]},$he="wrapper";function Khe(e){let{components:n,...t}=e;return(0,s.yg)($he,(0,p.A)({},Qhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Khe.isMDXComponent=!0;const Jhe={toc:[]},Zhe="wrapper";function ege(e){let{components:n,...t}=e;return(0,s.yg)(Zhe,(0,p.A)({},Jhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ege.isMDXComponent=!0;const nge={toc:[]},tge="wrapper";function oge(e){let{components:n,...t}=e;return(0,s.yg)(tge,(0,p.A)({},nge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}oge.isMDXComponent=!0;const pge={toc:[]},rge="wrapper";function sge(e){let{components:n,...t}=e;return(0,s.yg)(rge,(0,p.A)({},pge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}sge.isMDXComponent=!0;const cge={toc:[]},age="wrapper";function ige(e){let{components:n,...t}=e;return(0,s.yg)(age,(0,p.A)({},cge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}ige.isMDXComponent=!0;const lge={toc:[]},uge="wrapper";function mge(e){let{components:n,...t}=e;return(0,s.yg)(uge,(0,p.A)({},lge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}mge.isMDXComponent=!0;const yge={toc:[]},dge="wrapper";function hge(e){let{components:n,...t}=e;return(0,s.yg)(dge,(0,p.A)({},yge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}hge.isMDXComponent=!0;const gge={toc:[]},fge="wrapper";function Dge(e){let{components:n,...t}=e;return(0,s.yg)(fge,(0,p.A)({},gge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Dge.isMDXComponent=!0;const Mge={toc:[]},Xge="wrapper";function _ge(e){let{components:n,...t}=e;return(0,s.yg)(Xge,(0,p.A)({},Mge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}_ge.isMDXComponent=!0;const wge={toc:[]},Tge="wrapper";function Cge(e){let{components:n,...t}=e;return(0,s.yg)(Tge,(0,p.A)({},wge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Cge.isMDXComponent=!0;const xge={toc:[]},Age="wrapper";function vge(e){let{components:n,...t}=e;return(0,s.yg)(Age,(0,p.A)({},xge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}vge.isMDXComponent=!0;const Lge={toc:[]},bge="wrapper";function Nge(e){let{components:n,...t}=e;return(0,s.yg)(bge,(0,p.A)({},Lge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Nge.isMDXComponent=!0;const kge={toc:[]},zge="wrapper";function Pge(e){let{components:n,...t}=e;return(0,s.yg)(zge,(0,p.A)({},kge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Pge.isMDXComponent=!0;const Ige={toc:[]},Rge="wrapper";function Wge(e){let{components:n,...t}=e;return(0,s.yg)(Rge,(0,p.A)({},Ige,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Wge.isMDXComponent=!0;const Sge={toc:[]},Bge="wrapper";function Gge(e){let{components:n,...t}=e;return(0,s.yg)(Bge,(0,p.A)({},Sge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Gge.isMDXComponent=!0;const Ege={toc:[]},Oge="wrapper";function Uge(e){let{components:n,...t}=e;return(0,s.yg)(Oge,(0,p.A)({},Ege,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}Uge.isMDXComponent=!0;const Fge={toc:[]},Vge="wrapper";function qge(e){let{components:n,...t}=e;return(0,s.yg)(Vge,(0,p.A)({},Fge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A closed circle will look like a pie chart:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.yg)("p",null,"An open one will look like an arc:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}qge.isMDXComponent=!0;const jge={toc:[]},Hge="wrapper";function Yge(e){let{components:n,...t}=e;return(0,s.yg)(Hge,(0,p.A)({},jge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"false"))}Yge.isMDXComponent=!0;const Qge={toc:[]},$ge="wrapper";function Kge(e){let{components:n,...t}=e;return(0,s.yg)($ge,(0,p.A)({},Qge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the path of this circle should be closed."))}Kge.isMDXComponent=!0;const Jge={toc:[]},Zge="wrapper";function efe(e){let{components:n,...t}=e;return(0,s.yg)(Zge,(0,p.A)({},Jge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the circle begins at ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}efe.isMDXComponent=!0;const nfe={toc:[]},tfe="wrapper";function ofe(e){let{components:n,...t}=e;return(0,s.yg)(tfe,(0,p.A)({},nfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the circle sector should be drawn counterclockwise."))}ofe.isMDXComponent=!0;const pfe={toc:[]},rfe="wrapper";function sfe(e){let{components:n,...t}=e;return(0,s.yg)(rfe,(0,p.A)({},pfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}sfe.isMDXComponent=!0;const cfe={toc:[]},afe="wrapper";function ife(e){let{components:n,...t}=e;return(0,s.yg)(afe,(0,p.A)({},cfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}ife.isMDXComponent=!0;const lfe={toc:[]},ufe="wrapper";function mfe(e){let{components:n,...t}=e;return(0,s.yg)(ufe,(0,p.A)({},lfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}mfe.isMDXComponent=!0;const yfe={toc:[]},dfe="wrapper";function hfe(e){let{components:n,...t}=e;return(0,s.yg)(dfe,(0,p.A)({},yfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"360"))}hfe.isMDXComponent=!0;const gfe={toc:[]},ffe="wrapper";function Dfe(e){let{components:n,...t}=e;return(0,s.yg)(ffe,(0,p.A)({},gfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending angle in degrees for the circle sector."))}Dfe.isMDXComponent=!0;const Mfe={toc:[]},Xfe="wrapper";function _fe(e){let{components:n,...t}=e;return(0,s.yg)(Xfe,(0,p.A)({},Mfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_fe.isMDXComponent=!0;const wfe={toc:[]},Tfe="wrapper";function Cfe(e){let{components:n,...t}=e;return(0,s.yg)(Tfe,(0,p.A)({},wfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Cfe.isMDXComponent=!0;const xfe={toc:[]},Afe="wrapper";function vfe(e){let{components:n,...t}=e;return(0,s.yg)(Afe,(0,p.A)({},xfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}vfe.isMDXComponent=!0;const Lfe={toc:[]},bfe="wrapper";function Nfe(e){let{components:n,...t}=e;return(0,s.yg)(bfe,(0,p.A)({},Lfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Nfe.isMDXComponent=!0;const kfe={toc:[]},zfe="wrapper";function Pfe(e){let{components:n,...t}=e;return(0,s.yg)(zfe,(0,p.A)({},kfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Pfe.isMDXComponent=!0;const Ife={toc:[]},Rfe="wrapper";function Wfe(e){let{components:n,...t}=e;return(0,s.yg)(Rfe,(0,p.A)({},Ife,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Wfe.isMDXComponent=!0;const Sfe={toc:[]},Bfe="wrapper";function Gfe(e){let{components:n,...t}=e;return(0,s.yg)(Bfe,(0,p.A)({},Sfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Gfe.isMDXComponent=!0;const Efe={toc:[]},Ofe="wrapper";function Ufe(e){let{components:n,...t}=e;return(0,s.yg)(Ofe,(0,p.A)({},Efe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Ufe.isMDXComponent=!0;const Ffe={toc:[]},Vfe="wrapper";function qfe(e){let{components:n,...t}=e;return(0,s.yg)(Vfe,(0,p.A)({},Ffe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qfe.isMDXComponent=!0;const jfe={toc:[]},Hfe="wrapper";function Yfe(e){let{components:n,...t}=e;return(0,s.yg)(Hfe,(0,p.A)({},jfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Yfe.isMDXComponent=!0;const Qfe={toc:[]},$fe="wrapper";function Kfe(e){let{components:n,...t}=e;return(0,s.yg)($fe,(0,p.A)({},Qfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]},Zfe="wrapper";function eDe(e){let{components:n,...t}=e;return(0,s.yg)(Zfe,(0,p.A)({},Jfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}eDe.isMDXComponent=!0;const nDe={toc:[]},tDe="wrapper";function oDe(e){let{components:n,...t}=e;return(0,s.yg)(tDe,(0,p.A)({},nDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}oDe.isMDXComponent=!0;const pDe={toc:[]},rDe="wrapper";function sDe(e){let{components:n,...t}=e;return(0,s.yg)(rDe,(0,p.A)({},pDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}sDe.isMDXComponent=!0;const cDe={toc:[]},aDe="wrapper";function iDe(e){let{components:n,...t}=e;return(0,s.yg)(aDe,(0,p.A)({},cDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}iDe.isMDXComponent=!0;const lDe={toc:[]},uDe="wrapper";function mDe(e){let{components:n,...t}=e;return(0,s.yg)(uDe,(0,p.A)({},lDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}mDe.isMDXComponent=!0;const yDe={toc:[]},dDe="wrapper";function hDe(e){let{components:n,...t}=e;return(0,s.yg)(dDe,(0,p.A)({},yDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hDe.isMDXComponent=!0;const gDe={toc:[]},fDe="wrapper";function DDe(e){let{components:n,...t}=e;return(0,s.yg)(fDe,(0,p.A)({},gDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DDe.isMDXComponent=!0;const MDe={toc:[]},XDe="wrapper";function _De(e){let{components:n,...t}=e;return(0,s.yg)(XDe,(0,p.A)({},MDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}_De.isMDXComponent=!0;const wDe={toc:[]},TDe="wrapper";function CDe(e){let{components:n,...t}=e;return(0,s.yg)(TDe,(0,p.A)({},wDe,t,{components:n,mdxType:"MDXLayout"}))}CDe.isMDXComponent=!0;const xDe={toc:[]},ADe="wrapper";function vDe(e){let{components:n,...t}=e;return(0,s.yg)(ADe,(0,p.A)({},xDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}vDe.isMDXComponent=!0;const LDe={toc:[]},bDe="wrapper";function NDe(e){let{components:n,...t}=e;return(0,s.yg)(bDe,(0,p.A)({},LDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}NDe.isMDXComponent=!0;const kDe={toc:[]},zDe="wrapper";function PDe(e){let{components:n,...t}=e;return(0,s.yg)(zDe,(0,p.A)({},kDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}PDe.isMDXComponent=!0;const IDe={toc:[]},RDe="wrapper";function WDe(e){let{components:n,...t}=e;return(0,s.yg)(RDe,(0,p.A)({},IDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}WDe.isMDXComponent=!0;const SDe={toc:[]},BDe="wrapper";function GDe(e){let{components:n,...t}=e;return(0,s.yg)(BDe,(0,p.A)({},SDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}GDe.isMDXComponent=!0;const EDe={toc:[]},ODe="wrapper";function UDe(e){let{components:n,...t}=e;return(0,s.yg)(ODe,(0,p.A)({},EDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}UDe.isMDXComponent=!0;const FDe={toc:[]},VDe="wrapper";function qDe(e){let{components:n,...t}=e;return(0,s.yg)(VDe,(0,p.A)({},FDe,t,{components:n,mdxType:"MDXLayout"}))}qDe.isMDXComponent=!0;const jDe={toc:[]},HDe="wrapper";function YDe(e){let{components:n,...t}=e;return(0,s.yg)(HDe,(0,p.A)({},jDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}YDe.isMDXComponent=!0;const QDe={toc:[]},$De="wrapper";function KDe(e){let{components:n,...t}=e;return(0,s.yg)($De,(0,p.A)({},QDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}KDe.isMDXComponent=!0;const JDe={toc:[]},ZDe="wrapper";function eMe(e){let{components:n,...t}=e;return(0,s.yg)(ZDe,(0,p.A)({},JDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}eMe.isMDXComponent=!0;const nMe={toc:[]},tMe="wrapper";function oMe(e){let{components:n,...t}=e;return(0,s.yg)(tMe,(0,p.A)({},nMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0"))}oMe.isMDXComponent=!0;const pMe={toc:[]},rMe="wrapper";function sMe(e){let{components:n,...t}=e;return(0,s.yg)(rMe,(0,p.A)({},pMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting angle in degrees for the circle sector."))}sMe.isMDXComponent=!0;const cMe={toc:[]},aMe="wrapper";function iMe(e){let{components:n,...t}=e;return(0,s.yg)(aMe,(0,p.A)({},cMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}iMe.isMDXComponent=!0;const lMe={toc:[]},uMe="wrapper";function mMe(e){let{components:n,...t}=e;return(0,s.yg)(uMe,(0,p.A)({},lMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}mMe.isMDXComponent=!0;const yMe={toc:[]},dMe="wrapper";function hMe(e){let{components:n,...t}=e;return(0,s.yg)(dMe,(0,p.A)({},yMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}hMe.isMDXComponent=!0;const gMe={toc:[]},fMe="wrapper";function DMe(e){let{components:n,...t}=e;return(0,s.yg)(fMe,(0,p.A)({},gMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}DMe.isMDXComponent=!0;const MMe={toc:[]},XMe="wrapper";function _Me(e){let{components:n,...t}=e;return(0,s.yg)(XMe,(0,p.A)({},MMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}_Me.isMDXComponent=!0;const wMe={toc:[]},TMe="wrapper";function CMe(e){let{components:n,...t}=e;return(0,s.yg)(TMe,(0,p.A)({},wMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}CMe.isMDXComponent=!0;const xMe={toc:[]},AMe="wrapper";function vMe(e){let{components:n,...t}=e;return(0,s.yg)(AMe,(0,p.A)({},xMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}vMe.isMDXComponent=!0;const LMe={toc:[]},bMe="wrapper";function NMe(e){let{components:n,...t}=e;return(0,s.yg)(bMe,(0,p.A)({},LMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}NMe.isMDXComponent=!0;const kMe={toc:[]},zMe="wrapper";function PMe(e){let{components:n,...t}=e;return(0,s.yg)(zMe,(0,p.A)({},kMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}PMe.isMDXComponent=!0;const IMe={toc:[]},RMe="wrapper";function WMe(e){let{components:n,...t}=e;return(0,s.yg)(RMe,(0,p.A)({},IMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}WMe.isMDXComponent=!0;const SMe={toc:[]},BMe="wrapper";function GMe(e){let{components:n,...t}=e;return(0,s.yg)(BMe,(0,p.A)({},SMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}GMe.isMDXComponent=!0;const EMe={toc:[]},OMe="wrapper";function UMe(e){let{components:n,...t}=e;return(0,s.yg)(OMe,(0,p.A)({},EMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}UMe.isMDXComponent=!0;const FMe={toc:[]},VMe="wrapper";function qMe(e){let{components:n,...t}=e;return(0,s.yg)(VMe,(0,p.A)({},FMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}qMe.isMDXComponent=!0;const jMe={toc:[]},HMe="wrapper";function YMe(e){let{components:n,...t}=e;return(0,s.yg)(HMe,(0,p.A)({},jMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}YMe.isMDXComponent=!0;const QMe={toc:[]},$Me="wrapper";function KMe(e){let{components:n,...t}=e;return(0,s.yg)($Me,(0,p.A)({},QMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}KMe.isMDXComponent=!0;const JMe={toc:[]},ZMe="wrapper";function eXe(e){let{components:n,...t}=e;return(0,s.yg)(ZMe,(0,p.A)({},JMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}eXe.isMDXComponent=!0;const nXe={toc:[]},tXe="wrapper";function oXe(e){let{components:n,...t}=e;return(0,s.yg)(tXe,(0,p.A)({},nXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}oXe.isMDXComponent=!0;const pXe={toc:[]},rXe="wrapper";function sXe(e){let{components:n,...t}=e;return(0,s.yg)(rXe,(0,p.A)({},pXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}sXe.isMDXComponent=!0;const cXe={toc:[]},aXe="wrapper";function iXe(e){let{components:n,...t}=e;return(0,s.yg)(aXe,(0,p.A)({},cXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}iXe.isMDXComponent=!0;const lXe={toc:[]},uXe="wrapper";function mXe(e){let{components:n,...t}=e;return(0,s.yg)(uXe,(0,p.A)({},lXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}mXe.isMDXComponent=!0;const yXe={toc:[]},dXe="wrapper";function hXe(e){let{components:n,...t}=e;return(0,s.yg)(dXe,(0,p.A)({},yXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}hXe.isMDXComponent=!0;const gXe={toc:[]},fXe="wrapper";function DXe(e){let{components:n,...t}=e;return(0,s.yg)(fXe,(0,p.A)({},gXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}DXe.isMDXComponent=!0;const MXe={toc:[]},XXe="wrapper";function _Xe(e){let{components:n,...t}=e;return(0,s.yg)(XXe,(0,p.A)({},MXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}_Xe.isMDXComponent=!0;const wXe={toc:[]},TXe="wrapper";function CXe(e){let{components:n,...t}=e;return(0,s.yg)(TXe,(0,p.A)({},wXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}CXe.isMDXComponent=!0;const xXe={toc:[]},AXe="wrapper";function vXe(e){let{components:n,...t}=e;return(0,s.yg)(AXe,(0,p.A)({},xXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}vXe.isMDXComponent=!0;const LXe={toc:[]},bXe="wrapper";function NXe(e){let{components:n,...t}=e;return(0,s.yg)(bXe,(0,p.A)({},LXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}NXe.isMDXComponent=!0;const kXe={toc:[]},zXe="wrapper";function PXe(e){let{components:n,...t}=e;return(0,s.yg)(zXe,(0,p.A)({},kXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}PXe.isMDXComponent=!0;const IXe={toc:[]},RXe="wrapper";function WXe(e){let{components:n,...t}=e;return(0,s.yg)(RXe,(0,p.A)({},IXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}WXe.isMDXComponent=!0;const SXe={toc:[]},BXe="wrapper";function GXe(e){let{components:n,...t}=e;return(0,s.yg)(BXe,(0,p.A)({},SXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}GXe.isMDXComponent=!0;const EXe={toc:[]},OXe="wrapper";function UXe(e){let{components:n,...t}=e;return(0,s.yg)(OXe,(0,p.A)({},EXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}UXe.isMDXComponent=!0;const FXe={toc:[]},VXe="wrapper";function qXe(e){let{components:n,...t}=e;return(0,s.yg)(VXe,(0,p.A)({},FXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}qXe.isMDXComponent=!0;const jXe={toc:[]},HXe="wrapper";function YXe(e){let{components:n,...t}=e;return(0,s.yg)(HXe,(0,p.A)({},jXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}YXe.isMDXComponent=!0;const QXe={toc:[]},$Xe="wrapper";function KXe(e){let{components:n,...t}=e;return(0,s.yg)($Xe,(0,p.A)({},QXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}KXe.isMDXComponent=!0;const JXe={toc:[]},ZXe="wrapper";function e_e(e){let{components:n,...t}=e;return(0,s.yg)(ZXe,(0,p.A)({},JXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}e_e.isMDXComponent=!0;const n_e={toc:[]},t_e="wrapper";function o_e(e){let{components:n,...t}=e;return(0,s.yg)(t_e,(0,p.A)({},n_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}o_e.isMDXComponent=!0;const p_e={toc:[]},r_e="wrapper";function s_e(e){let{components:n,...t}=e;return(0,s.yg)(r_e,(0,p.A)({},p_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}s_e.isMDXComponent=!0;const c_e={toc:[]},a_e="wrapper";function i_e(e){let{components:n,...t}=e;return(0,s.yg)(a_e,(0,p.A)({},c_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}i_e.isMDXComponent=!0;const l_e={toc:[]},u_e="wrapper";function m_e(e){let{components:n,...t}=e;return(0,s.yg)(u_e,(0,p.A)({},l_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}m_e.isMDXComponent=!0;const y_e={toc:[]},d_e="wrapper";function h_e(e){let{components:n,...t}=e;return(0,s.yg)(d_e,(0,p.A)({},y_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}h_e.isMDXComponent=!0;const g_e={toc:[]},f_e="wrapper";function D_e(e){let{components:n,...t}=e;return(0,s.yg)(f_e,(0,p.A)({},g_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}D_e.isMDXComponent=!0;const M_e={toc:[]},X_e="wrapper";function __e(e){let{components:n,...t}=e;return(0,s.yg)(X_e,(0,p.A)({},M_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}__e.isMDXComponent=!0;const w_e={toc:[]},T_e="wrapper";function C_e(e){let{components:n,...t}=e;return(0,s.yg)(T_e,(0,p.A)({},w_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}C_e.isMDXComponent=!0;const x_e={toc:[]},A_e="wrapper";function v_e(e){let{components:n,...t}=e;return(0,s.yg)(A_e,(0,p.A)({},x_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}v_e.isMDXComponent=!0;const L_e={toc:[]},b_e="wrapper";function N_e(e){let{components:n,...t}=e;return(0,s.yg)(b_e,(0,p.A)({},L_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}N_e.isMDXComponent=!0;const k_e={toc:[]},z_e="wrapper";function P_e(e){let{components:n,...t}=e;return(0,s.yg)(z_e,(0,p.A)({},k_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}P_e.isMDXComponent=!0;const I_e={toc:[]},R_e="wrapper";function W_e(e){let{components:n,...t}=e;return(0,s.yg)(R_e,(0,p.A)({},I_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}W_e.isMDXComponent=!0;const S_e={toc:[]},B_e="wrapper";function G_e(e){let{components:n,...t}=e;return(0,s.yg)(B_e,(0,p.A)({},S_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}G_e.isMDXComponent=!0;const E_e={toc:[]},O_e="wrapper";function U_e(e){let{components:n,...t}=e;return(0,s.yg)(O_e,(0,p.A)({},E_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}U_e.isMDXComponent=!0;const F_e={toc:[]},V_e="wrapper";function q_e(e){let{components:n,...t}=e;return(0,s.yg)(V_e,(0,p.A)({},F_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}q_e.isMDXComponent=!0;const j_e={toc:[]},H_e="wrapper";function Y_e(e){let{components:n,...t}=e;return(0,s.yg)(H_e,(0,p.A)({},j_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Y_e.isMDXComponent=!0;const Q_e={toc:[]},$_e="wrapper";function K_e(e){let{components:n,...t}=e;return(0,s.yg)($_e,(0,p.A)({},Q_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}K_e.isMDXComponent=!0;const J_e={toc:[]},Z_e="wrapper";function ewe(e){let{components:n,...t}=e;return(0,s.yg)(Z_e,(0,p.A)({},J_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ewe.isMDXComponent=!0;const nwe={toc:[]},twe="wrapper";function owe(e){let{components:n,...t}=e;return(0,s.yg)(twe,(0,p.A)({},nwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}owe.isMDXComponent=!0;const pwe={toc:[]},rwe="wrapper";function swe(e){let{components:n,...t}=e;return(0,s.yg)(rwe,(0,p.A)({},pwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}swe.isMDXComponent=!0;const cwe={toc:[]},awe="wrapper";function iwe(e){let{components:n,...t}=e;return(0,s.yg)(awe,(0,p.A)({},cwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}iwe.isMDXComponent=!0;const lwe={toc:[]},uwe="wrapper";function mwe(e){let{components:n,...t}=e;return(0,s.yg)(uwe,(0,p.A)({},lwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mwe.isMDXComponent=!0;const ywe={toc:[]},dwe="wrapper";function hwe(e){let{components:n,...t}=e;return(0,s.yg)(dwe,(0,p.A)({},ywe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}hwe.isMDXComponent=!0;const gwe={toc:[]},fwe="wrapper";function Dwe(e){let{components:n,...t}=e;return(0,s.yg)(fwe,(0,p.A)({},gwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Dwe.isMDXComponent=!0;const Mwe={toc:[]},Xwe="wrapper";function _we(e){let{components:n,...t}=e;return(0,s.yg)(Xwe,(0,p.A)({},Mwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}_we.isMDXComponent=!0;const wwe={toc:[]},Twe="wrapper";function Cwe(e){let{components:n,...t}=e;return(0,s.yg)(Twe,(0,p.A)({},wwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Cwe.isMDXComponent=!0;const xwe={toc:[]},Awe="wrapper";function vwe(e){let{components:n,...t}=e;return(0,s.yg)(Awe,(0,p.A)({},xwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}vwe.isMDXComponent=!0;const Lwe={toc:[]},bwe="wrapper";function Nwe(e){let{components:n,...t}=e;return(0,s.yg)(bwe,(0,p.A)({},Lwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Nwe.isMDXComponent=!0;const kwe={toc:[]},zwe="wrapper";function Pwe(e){let{components:n,...t}=e;return(0,s.yg)(zwe,(0,p.A)({},kwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Pwe.isMDXComponent=!0;const Iwe={toc:[]},Rwe="wrapper";function Wwe(e){let{components:n,...t}=e;return(0,s.yg)(Rwe,(0,p.A)({},Iwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Wwe.isMDXComponent=!0;const Swe={toc:[]},Bwe="wrapper";function Gwe(e){let{components:n,...t}=e;return(0,s.yg)(Bwe,(0,p.A)({},Swe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Gwe.isMDXComponent=!0;const Ewe={toc:[]},Owe="wrapper";function Uwe(e){let{components:n,...t}=e;return(0,s.yg)(Owe,(0,p.A)({},Ewe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Uwe.isMDXComponent=!0;const Fwe={toc:[]},Vwe="wrapper";function qwe(e){let{components:n,...t}=e;return(0,s.yg)(Vwe,(0,p.A)({},Fwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}qwe.isMDXComponent=!0;const jwe={toc:[]},Hwe="wrapper";function Ywe(e){let{components:n,...t}=e;return(0,s.yg)(Hwe,(0,p.A)({},jwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Ywe.isMDXComponent=!0;const Qwe={toc:[]},$we="wrapper";function Kwe(e){let{components:n,...t}=e;return(0,s.yg)($we,(0,p.A)({},Qwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]},Zwe="wrapper";function eTe(e){let{components:n,...t}=e;return(0,s.yg)(Zwe,(0,p.A)({},Jwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}eTe.isMDXComponent=!0;const nTe={toc:[]},tTe="wrapper";function oTe(e){let{components:n,...t}=e;return(0,s.yg)(tTe,(0,p.A)({},nTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}oTe.isMDXComponent=!0;const pTe={toc:[]},rTe="wrapper";function sTe(e){let{components:n,...t}=e;return(0,s.yg)(rTe,(0,p.A)({},pTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}sTe.isMDXComponent=!0;const cTe={toc:[]},aTe="wrapper";function iTe(e){let{components:n,...t}=e;return(0,s.yg)(aTe,(0,p.A)({},cTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}iTe.isMDXComponent=!0;const lTe={toc:[]},uTe="wrapper";function mTe(e){let{components:n,...t}=e;return(0,s.yg)(uTe,(0,p.A)({},lTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}mTe.isMDXComponent=!0;const yTe={toc:[]},dTe="wrapper";function hTe(e){let{components:n,...t}=e;return(0,s.yg)(dTe,(0,p.A)({},yTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}hTe.isMDXComponent=!0;const gTe={toc:[]},fTe="wrapper";function DTe(e){let{components:n,...t}=e;return(0,s.yg)(fTe,(0,p.A)({},gTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}DTe.isMDXComponent=!0;const MTe={toc:[]},XTe="wrapper";function _Te(e){let{components:n,...t}=e;return(0,s.yg)(XTe,(0,p.A)({},MTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}_Te.isMDXComponent=!0;const wTe={toc:[]},TTe="wrapper";function CTe(e){let{components:n,...t}=e;return(0,s.yg)(TTe,(0,p.A)({},wTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}CTe.isMDXComponent=!0;const xTe={toc:[]},ATe="wrapper";function vTe(e){let{components:n,...t}=e;return(0,s.yg)(ATe,(0,p.A)({},xTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}vTe.isMDXComponent=!0;const LTe={toc:[]},bTe="wrapper";function NTe(e){let{components:n,...t}=e;return(0,s.yg)(bTe,(0,p.A)({},LTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}NTe.isMDXComponent=!0;const kTe={toc:[]},zTe="wrapper";function PTe(e){let{components:n,...t}=e;return(0,s.yg)(zTe,(0,p.A)({},kTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}PTe.isMDXComponent=!0;const ITe={toc:[]},RTe="wrapper";function WTe(e){let{components:n,...t}=e;return(0,s.yg)(RTe,(0,p.A)({},ITe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}WTe.isMDXComponent=!0;const STe={toc:[]},BTe="wrapper";function GTe(e){let{components:n,...t}=e;return(0,s.yg)(BTe,(0,p.A)({},STe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}GTe.isMDXComponent=!0;const ETe={toc:[]},OTe="wrapper";function UTe(e){let{components:n,...t}=e;return(0,s.yg)(OTe,(0,p.A)({},ETe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}UTe.isMDXComponent=!0;const FTe={toc:[]},VTe="wrapper";function qTe(e){let{components:n,...t}=e;return(0,s.yg)(VTe,(0,p.A)({},FTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qTe.isMDXComponent=!0;const jTe={toc:[]},HTe="wrapper";function YTe(e){let{components:n,...t}=e;return(0,s.yg)(HTe,(0,p.A)({},jTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}YTe.isMDXComponent=!0;const QTe={toc:[]},$Te="wrapper";function KTe(e){let{components:n,...t}=e;return(0,s.yg)($Te,(0,p.A)({},QTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}KTe.isMDXComponent=!0;const JTe={toc:[]},ZTe="wrapper";function eCe(e){let{components:n,...t}=e;return(0,s.yg)(ZTe,(0,p.A)({},JTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}eCe.isMDXComponent=!0;const nCe={toc:[]},tCe="wrapper";function oCe(e){let{components:n,...t}=e;return(0,s.yg)(tCe,(0,p.A)({},nCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}oCe.isMDXComponent=!0;const pCe={toc:[]},rCe="wrapper";function sCe(e){let{components:n,...t}=e;return(0,s.yg)(rCe,(0,p.A)({},pCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}sCe.isMDXComponent=!0;const cCe={toc:[]},aCe="wrapper";function iCe(e){let{components:n,...t}=e;return(0,s.yg)(aCe,(0,p.A)({},cCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}iCe.isMDXComponent=!0;const lCe={toc:[]},uCe="wrapper";function mCe(e){let{components:n,...t}=e;return(0,s.yg)(uCe,(0,p.A)({},lCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}mCe.isMDXComponent=!0;const yCe={toc:[]},dCe="wrapper";function hCe(e){let{components:n,...t}=e;return(0,s.yg)(dCe,(0,p.A)({},yCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}hCe.isMDXComponent=!0;const gCe={toc:[]},fCe="wrapper";function DCe(e){let{components:n,...t}=e;return(0,s.yg)(fCe,(0,p.A)({},gCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}DCe.isMDXComponent=!0;const MCe={toc:[]},XCe="wrapper";function _Ce(e){let{components:n,...t}=e;return(0,s.yg)(XCe,(0,p.A)({},MCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_Ce.isMDXComponent=!0;const wCe={toc:[]},TCe="wrapper";function CCe(e){let{components:n,...t}=e;return(0,s.yg)(TCe,(0,p.A)({},wCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}CCe.isMDXComponent=!0;const xCe={toc:[]},ACe="wrapper";function vCe(e){let{components:n,...t}=e;return(0,s.yg)(ACe,(0,p.A)({},xCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}vCe.isMDXComponent=!0;const LCe={toc:[]},bCe="wrapper";function NCe(e){let{components:n,...t}=e;return(0,s.yg)(bCe,(0,p.A)({},LCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}NCe.isMDXComponent=!0;const kCe={toc:[]},zCe="wrapper";function PCe(e){let{components:n,...t}=e;return(0,s.yg)(zCe,(0,p.A)({},kCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}PCe.isMDXComponent=!0;const ICe={toc:[]},RCe="wrapper";function WCe(e){let{components:n,...t}=e;return(0,s.yg)(RCe,(0,p.A)({},ICe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}WCe.isMDXComponent=!0;const SCe={toc:[]},BCe="wrapper";function GCe(e){let{components:n,...t}=e;return(0,s.yg)(BCe,(0,p.A)({},SCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}GCe.isMDXComponent=!0;const ECe={toc:[]},OCe="wrapper";function UCe(e){let{components:n,...t}=e;return(0,s.yg)(OCe,(0,p.A)({},ECe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}UCe.isMDXComponent=!0;const FCe={toc:[]},VCe="wrapper";function qCe(e){let{components:n,...t}=e;return(0,s.yg)(VCe,(0,p.A)({},FCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qCe.isMDXComponent=!0;const jCe={toc:[]},HCe="wrapper";function YCe(e){let{components:n,...t}=e;return(0,s.yg)(HCe,(0,p.A)({},jCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}YCe.isMDXComponent=!0;const QCe={toc:[]},$Ce="wrapper";function KCe(e){let{components:n,...t}=e;return(0,s.yg)($Ce,(0,p.A)({},QCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}KCe.isMDXComponent=!0;const JCe={toc:[]},ZCe="wrapper";function exe(e){let{components:n,...t}=e;return(0,s.yg)(ZCe,(0,p.A)({},JCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}exe.isMDXComponent=!0;const nxe={toc:[]},txe="wrapper";function oxe(e){let{components:n,...t}=e;return(0,s.yg)(txe,(0,p.A)({},nxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}oxe.isMDXComponent=!0;const pxe={toc:[]},rxe="wrapper";function sxe(e){let{components:n,...t}=e;return(0,s.yg)(rxe,(0,p.A)({},pxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sxe.isMDXComponent=!0;const cxe={toc:[]},axe="wrapper";function ixe(e){let{components:n,...t}=e;return(0,s.yg)(axe,(0,p.A)({},cxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}ixe.isMDXComponent=!0;const lxe={toc:[]},uxe="wrapper";function mxe(e){let{components:n,...t}=e;return(0,s.yg)(uxe,(0,p.A)({},lxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}mxe.isMDXComponent=!0;const yxe={toc:[]},dxe="wrapper";function hxe(e){let{components:n,...t}=e;return(0,s.yg)(dxe,(0,p.A)({},yxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}hxe.isMDXComponent=!0;const gxe={toc:[]},fxe="wrapper";function Dxe(e){let{components:n,...t}=e;return(0,s.yg)(fxe,(0,p.A)({},gxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Dxe.isMDXComponent=!0;const Mxe={toc:[]},Xxe="wrapper";function _xe(e){let{components:n,...t}=e;return(0,s.yg)(Xxe,(0,p.A)({},Mxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}_xe.isMDXComponent=!0;const wxe={toc:[]},Txe="wrapper";function Cxe(e){let{components:n,...t}=e;return(0,s.yg)(Txe,(0,p.A)({},wxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Cxe.isMDXComponent=!0;const xxe={toc:[]},Axe="wrapper";function vxe(e){let{components:n,...t}=e;return(0,s.yg)(Axe,(0,p.A)({},xxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}vxe.isMDXComponent=!0;const Lxe={toc:[]},bxe="wrapper";function Nxe(e){let{components:n,...t}=e;return(0,s.yg)(bxe,(0,p.A)({},Lxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Nxe.isMDXComponent=!0;const kxe={toc:[]},zxe="wrapper";function Pxe(e){let{components:n,...t}=e;return(0,s.yg)(zxe,(0,p.A)({},kxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Pxe.isMDXComponent=!0;const Ixe={toc:[]},Rxe="wrapper";function Wxe(e){let{components:n,...t}=e;return(0,s.yg)(Rxe,(0,p.A)({},Ixe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Wxe.isMDXComponent=!0;const Sxe={toc:[]},Bxe="wrapper";function Gxe(e){let{components:n,...t}=e;return(0,s.yg)(Bxe,(0,p.A)({},Sxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Gxe.isMDXComponent=!0;const Exe={toc:[]},Oxe="wrapper";function Uxe(e){let{components:n,...t}=e;return(0,s.yg)(Oxe,(0,p.A)({},Exe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Uxe.isMDXComponent=!0;const Fxe={toc:[]},Vxe="wrapper";function qxe(e){let{components:n,...t}=e;return(0,s.yg)(Vxe,(0,p.A)({},Fxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}qxe.isMDXComponent=!0;const jxe={toc:[]},Hxe="wrapper";function Yxe(e){let{components:n,...t}=e;return(0,s.yg)(Hxe,(0,p.A)({},jxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Yxe.isMDXComponent=!0;const Qxe={toc:[]},$xe="wrapper";function Kxe(e){let{components:n,...t}=e;return(0,s.yg)($xe,(0,p.A)({},Qxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Kxe.isMDXComponent=!0;const Jxe={toc:[]},Zxe="wrapper";function eAe(e){let{components:n,...t}=e;return(0,s.yg)(Zxe,(0,p.A)({},Jxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}eAe.isMDXComponent=!0;const nAe={toc:[]},tAe="wrapper";function oAe(e){let{components:n,...t}=e;return(0,s.yg)(tAe,(0,p.A)({},nAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}oAe.isMDXComponent=!0;const pAe={toc:[]},rAe="wrapper";function sAe(e){let{components:n,...t}=e;return(0,s.yg)(rAe,(0,p.A)({},pAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}sAe.isMDXComponent=!0;const cAe={toc:[]},aAe="wrapper";function iAe(e){let{components:n,...t}=e;return(0,s.yg)(aAe,(0,p.A)({},cAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}iAe.isMDXComponent=!0;const lAe={toc:[]},uAe="wrapper";function mAe(e){let{components:n,...t}=e;return(0,s.yg)(uAe,(0,p.A)({},lAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}mAe.isMDXComponent=!0;const yAe={toc:[]},dAe="wrapper";function hAe(e){let{components:n,...t}=e;return(0,s.yg)(dAe,(0,p.A)({},yAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}hAe.isMDXComponent=!0;const gAe={toc:[]},fAe="wrapper";function DAe(e){let{components:n,...t}=e;return(0,s.yg)(fAe,(0,p.A)({},gAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}DAe.isMDXComponent=!0;const MAe={toc:[]},XAe="wrapper";function _Ae(e){let{components:n,...t}=e;return(0,s.yg)(XAe,(0,p.A)({},MAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}_Ae.isMDXComponent=!0;const wAe={toc:[]},TAe="wrapper";function CAe(e){let{components:n,...t}=e;return(0,s.yg)(TAe,(0,p.A)({},wAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}CAe.isMDXComponent=!0;const xAe={toc:[]},AAe="wrapper";function vAe(e){let{components:n,...t}=e;return(0,s.yg)(AAe,(0,p.A)({},xAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vAe.isMDXComponent=!0;const LAe={toc:[]},bAe="wrapper";function NAe(e){let{components:n,...t}=e;return(0,s.yg)(bAe,(0,p.A)({},LAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}NAe.isMDXComponent=!0;const kAe={toc:[]},zAe="wrapper";function PAe(e){let{components:n,...t}=e;return(0,s.yg)(zAe,(0,p.A)({},kAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}PAe.isMDXComponent=!0;const IAe={toc:[]},RAe="wrapper";function WAe(e){let{components:n,...t}=e;return(0,s.yg)(RAe,(0,p.A)({},IAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}WAe.isMDXComponent=!0;const SAe={toc:[]},BAe="wrapper";function GAe(e){let{components:n,...t}=e;return(0,s.yg)(BAe,(0,p.A)({},SAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}GAe.isMDXComponent=!0;const EAe={toc:[]},OAe="wrapper";function UAe(e){let{components:n,...t}=e;return(0,s.yg)(OAe,(0,p.A)({},EAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}UAe.isMDXComponent=!0;const FAe={toc:[]},VAe="wrapper";function qAe(e){let{components:n,...t}=e;return(0,s.yg)(VAe,(0,p.A)({},FAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qAe.isMDXComponent=!0;const jAe={toc:[]},HAe="wrapper";function YAe(e){let{components:n,...t}=e;return(0,s.yg)(HAe,(0,p.A)({},jAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}YAe.isMDXComponent=!0;const QAe={toc:[]},$Ae="wrapper";function KAe(e){let{components:n,...t}=e;return(0,s.yg)($Ae,(0,p.A)({},QAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}KAe.isMDXComponent=!0;const JAe={toc:[]},ZAe="wrapper";function eve(e){let{components:n,...t}=e;return(0,s.yg)(ZAe,(0,p.A)({},JAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}eve.isMDXComponent=!0;const nve={toc:[]},tve="wrapper";function ove(e){let{components:n,...t}=e;return(0,s.yg)(tve,(0,p.A)({},nve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}ove.isMDXComponent=!0;const pve={toc:[]},rve="wrapper";function sve(e){let{components:n,...t}=e;return(0,s.yg)(rve,(0,p.A)({},pve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}sve.isMDXComponent=!0;const cve={toc:[]},ave="wrapper";function ive(e){let{components:n,...t}=e;return(0,s.yg)(ave,(0,p.A)({},cve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}ive.isMDXComponent=!0;const lve={toc:[]},uve="wrapper";function mve(e){let{components:n,...t}=e;return(0,s.yg)(uve,(0,p.A)({},lve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}mve.isMDXComponent=!0;const yve={toc:[]},dve="wrapper";function hve(e){let{components:n,...t}=e;return(0,s.yg)(dve,(0,p.A)({},yve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}hve.isMDXComponent=!0;const gve={toc:[]},fve="wrapper";function Dve(e){let{components:n,...t}=e;return(0,s.yg)(fve,(0,p.A)({},gve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Dve.isMDXComponent=!0;const Mve={toc:[]},Xve="wrapper";function _ve(e){let{components:n,...t}=e;return(0,s.yg)(Xve,(0,p.A)({},Mve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}_ve.isMDXComponent=!0;const wve={toc:[]},Tve="wrapper";function Cve(e){let{components:n,...t}=e;return(0,s.yg)(Tve,(0,p.A)({},wve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Cve.isMDXComponent=!0;const xve={toc:[]},Ave="wrapper";function vve(e){let{components:n,...t}=e;return(0,s.yg)(Ave,(0,p.A)({},xve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}vve.isMDXComponent=!0;const Lve={toc:[]},bve="wrapper";function Nve(e){let{components:n,...t}=e;return(0,s.yg)(bve,(0,p.A)({},Lve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Nve.isMDXComponent=!0;const kve={toc:[]},zve="wrapper";function Pve(e){let{components:n,...t}=e;return(0,s.yg)(zve,(0,p.A)({},kve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Pve.isMDXComponent=!0;const Ive={toc:[]},Rve="wrapper";function Wve(e){let{components:n,...t}=e;return(0,s.yg)(Rve,(0,p.A)({},Ive,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Wve.isMDXComponent=!0;const Sve={toc:[]},Bve="wrapper";function Gve(e){let{components:n,...t}=e;return(0,s.yg)(Bve,(0,p.A)({},Sve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Gve.isMDXComponent=!0;const Eve={toc:[]},Ove="wrapper";function Uve(e){let{components:n,...t}=e;return(0,s.yg)(Ove,(0,p.A)({},Eve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Uve.isMDXComponent=!0;const Fve={toc:[]},Vve="wrapper";function qve(e){let{components:n,...t}=e;return(0,s.yg)(Vve,(0,p.A)({},Fve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qve.isMDXComponent=!0;const jve={toc:[]},Hve="wrapper";function Yve(e){let{components:n,...t}=e;return(0,s.yg)(Hve,(0,p.A)({},jve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Yve.isMDXComponent=!0;const Qve={toc:[]},$ve="wrapper";function Kve(e){let{components:n,...t}=e;return(0,s.yg)($ve,(0,p.A)({},Qve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Kve.isMDXComponent=!0;const Jve={toc:[]},Zve="wrapper";function eLe(e){let{components:n,...t}=e;return(0,s.yg)(Zve,(0,p.A)({},Jve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eLe.isMDXComponent=!0;const nLe={toc:[]},tLe="wrapper";function oLe(e){let{components:n,...t}=e;return(0,s.yg)(tLe,(0,p.A)({},nLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}oLe.isMDXComponent=!0;const pLe={toc:[]},rLe="wrapper";function sLe(e){let{components:n,...t}=e;return(0,s.yg)(rLe,(0,p.A)({},pLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}sLe.isMDXComponent=!0;const cLe={toc:[]},aLe="wrapper";function iLe(e){let{components:n,...t}=e;return(0,s.yg)(aLe,(0,p.A)({},cLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}iLe.isMDXComponent=!0;const lLe={toc:[]},uLe="wrapper";function mLe(e){let{components:n,...t}=e;return(0,s.yg)(uLe,(0,p.A)({},lLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}mLe.isMDXComponent=!0;const yLe={toc:[]},dLe="wrapper";function hLe(e){let{components:n,...t}=e;return(0,s.yg)(dLe,(0,p.A)({},yLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}hLe.isMDXComponent=!0;const gLe={toc:[]},fLe="wrapper";function DLe(e){let{components:n,...t}=e;return(0,s.yg)(fLe,(0,p.A)({},gLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}DLe.isMDXComponent=!0;const MLe={toc:[]},XLe="wrapper";function _Le(e){let{components:n,...t}=e;return(0,s.yg)(XLe,(0,p.A)({},MLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {parser} from '@lezer/javascript';\nimport {Code, LezerHighlighter, makeScene2D} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  LezerHighlighter.registerParser(parser);\n  const code = createRef<Code>();\n\n  view.add(\n    <Code\n      ref={code}\n      offset={-1}\n      position={view.size().scale(-0.5).add(60)}\n      fontFamily={'JetBrains Mono, monospace'}\n      fontSize={36}\n      code={`\\\nfunction hello() {\n  console.log('Hello');\n}`}\n    />,\n  );\n\n  yield* code()\n    .code(\n      `\\\nfunction hello() {\n  console.warn('Hello World');\n}`,\n      1,\n    )\n    .wait(0.5)\n    .back(1)\n    .wait(0.5);\n});\n")))}_Le.isMDXComponent=!0;const wLe={toc:[]},TLe="wrapper";function CLe(e){let{components:n,...t}=e;return(0,s.yg)(TLe,(0,p.A)({},wLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for displaying and animating code."))}CLe.isMDXComponent=!0;const xLe={toc:[]},ALe="wrapper";function vLe(e){let{components:n,...t}=e;return(0,s.yg)(ALe,(0,p.A)({},xLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}vLe.isMDXComponent=!0;const LLe={toc:[]},bLe="wrapper";function NLe(e){let{components:n,...t}=e;return(0,s.yg)(bLe,(0,p.A)({},LLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}NLe.isMDXComponent=!0;const kLe={toc:[]},zLe="wrapper";function PLe(e){let{components:n,...t}=e;return(0,s.yg)(zLe,(0,p.A)({},kLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PLe.isMDXComponent=!0;const ILe={toc:[]},RLe="wrapper";function WLe(e){let{components:n,...t}=e;return(0,s.yg)(RLe,(0,p.A)({},ILe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}WLe.isMDXComponent=!0;const SLe={toc:[]},BLe="wrapper";function GLe(e){let{components:n,...t}=e;return(0,s.yg)(BLe,(0,p.A)({},SLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}GLe.isMDXComponent=!0;const ELe={toc:[]},OLe="wrapper";function ULe(e){let{components:n,...t}=e;return(0,s.yg)(OLe,(0,p.A)({},ELe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}ULe.isMDXComponent=!0;const FLe={toc:[]},VLe="wrapper";function qLe(e){let{components:n,...t}=e;return(0,s.yg)(VLe,(0,p.A)({},FLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qLe.isMDXComponent=!0;const jLe={toc:[]},HLe="wrapper";function YLe(e){let{components:n,...t}=e;return(0,s.yg)(HLe,(0,p.A)({},jLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}YLe.isMDXComponent=!0;const QLe={toc:[]},$Le="wrapper";function KLe(e){let{components:n,...t}=e;return(0,s.yg)($Le,(0,p.A)({},QLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}KLe.isMDXComponent=!0;const JLe={toc:[]},ZLe="wrapper";function ebe(e){let{components:n,...t}=e;return(0,s.yg)(ZLe,(0,p.A)({},JLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}ebe.isMDXComponent=!0;const nbe={toc:[]},tbe="wrapper";function obe(e){let{components:n,...t}=e;return(0,s.yg)(tbe,(0,p.A)({},nbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}obe.isMDXComponent=!0;const pbe={toc:[]},rbe="wrapper";function sbe(e){let{components:n,...t}=e;return(0,s.yg)(rbe,(0,p.A)({},pbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}sbe.isMDXComponent=!0;const cbe={toc:[]},abe="wrapper";function ibe(e){let{components:n,...t}=e;return(0,s.yg)(abe,(0,p.A)({},cbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ibe.isMDXComponent=!0;const lbe={toc:[]},ube="wrapper";function mbe(e){let{components:n,...t}=e;return(0,s.yg)(ube,(0,p.A)({},lbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}mbe.isMDXComponent=!0;const ybe={toc:[]},dbe="wrapper";function hbe(e){let{components:n,...t}=e;return(0,s.yg)(dbe,(0,p.A)({},ybe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to display."))}hbe.isMDXComponent=!0;const gbe={toc:[]},fbe="wrapper";function Dbe(e){let{components:n,...t}=e;return(0,s.yg)(fbe,(0,p.A)({},gbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This value will be passed to the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeHighlighter")),"\ndefined by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#highlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"highlighter"))," property. Different highlighters may use\nit differently."),(0,s.yg)("p",null,"The default ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter"))," uses it to select\nthe language parser to use. The parser for the given dialect can be\nregistered as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// Import the lezer parser:\nimport {parser} from '@lezer/javascript';\n\n// Register it in the highlighter:\nLezerHighlighter.registerParser(parser, 'js');\n\n// Use the dialect in a code node:\n<Code dialect=\"js\" code=\"const a = 7;\" />\n")),(0,s.yg)("p",null,"When no dialect is provided, the highlighter will use the default\nparser:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'// Register the default parser by omitting the dialect:\nLezerHighlighter.registerParser(parser);\n\n// Code nodes with no dialect will now use the default parser:\n<Code code="const a = 7;" />\n')))}Dbe.isMDXComponent=!0;const Mbe={toc:[]},Xbe="wrapper";function _be(e){let{components:n,...t}=e;return(0,s.yg)(Xbe,(0,p.A)({},Mbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The dialect to use for highlighting the code."))}_be.isMDXComponent=!0;const wbe={toc:[]},Tbe="wrapper";function Cbe(e){let{components:n,...t}=e;return(0,s.yg)(Tbe,(0,p.A)({},wbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check out ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.yg)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}Cbe.isMDXComponent=!0;const xbe={toc:[]},Abe="wrapper";function vbe(e){let{components:n,...t}=e;return(0,s.yg)(Abe,(0,p.A)({},xbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Make the unselected code blurry and transparent:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  drawHooks={{\n    token(ctx, text, position, color, selection) {\n      const blur = map(3, 0, selection);\n      const alpha = map(0.5, 1, selection);\n      ctx.globalAlpha *= alpha;\n      ctx.filter = `blur(${blur}px)`;\n      ctx.fillStyle = color;\n      ctx.fillText(text, position.x, position.y);\n    },\n  }}\n  // ...\n/>\n")))}vbe.isMDXComponent=!0;const Lbe={toc:[]},bbe="wrapper";function Nbe(e){let{components:n,...t}=e;return(0,s.yg)(bbe,(0,p.A)({},Lbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for the code."))}Nbe.isMDXComponent=!0;const kbe={toc:[]},zbe="wrapper";function Pbe(e){let{components:n,...t}=e;return(0,s.yg)(zbe,(0,p.A)({},kbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defaults to a shared ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}Pbe.isMDXComponent=!0;const Ibe={toc:[]},Rbe="wrapper";function Wbe(e){let{components:n,...t}=e;return(0,s.yg)(Rbe,(0,p.A)({},Ibe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code highlighter to use for this code node."))}Wbe.isMDXComponent=!0;const Sbe={toc:[]},Bbe="wrapper";function Gbe(e){let{components:n,...t}=e;return(0,s.yg)(Bbe,(0,p.A)({},Sbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Gbe.isMDXComponent=!0;const Ebe={toc:[]},Obe="wrapper";function Ube(e){let{components:n,...t}=e;return(0,s.yg)(Obe,(0,p.A)({},Ebe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ube.isMDXComponent=!0;const Fbe={toc:[]},Vbe="wrapper";function qbe(e){let{components:n,...t}=e;return(0,s.yg)(Vbe,(0,p.A)({},Fbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}qbe.isMDXComponent=!0;const jbe={toc:[]},Hbe="wrapper";function Ybe(e){let{components:n,...t}=e;return(0,s.yg)(Hbe,(0,p.A)({},jbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Ybe.isMDXComponent=!0;const Qbe={toc:[]},$be="wrapper";function Kbe(e){let{components:n,...t}=e;return(0,s.yg)($be,(0,p.A)({},Qbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Kbe.isMDXComponent=!0;const Jbe={toc:[]},Zbe="wrapper";function eNe(e){let{components:n,...t}=e;return(0,s.yg)(Zbe,(0,p.A)({},Jbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}eNe.isMDXComponent=!0;const nNe={toc:[]},tNe="wrapper";function oNe(e){let{components:n,...t}=e;return(0,s.yg)(tNe,(0,p.A)({},nNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}oNe.isMDXComponent=!0;const pNe={toc:[]},rNe="wrapper";function sNe(e){let{components:n,...t}=e;return(0,s.yg)(rNe,(0,p.A)({},pNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}sNe.isMDXComponent=!0;const cNe={toc:[]},aNe="wrapper";function iNe(e){let{components:n,...t}=e;return(0,s.yg)(aNe,(0,p.A)({},cNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}iNe.isMDXComponent=!0;const lNe={toc:[]},uNe="wrapper";function mNe(e){let{components:n,...t}=e;return(0,s.yg)(uNe,(0,p.A)({},lNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}mNe.isMDXComponent=!0;const yNe={toc:[]},dNe="wrapper";function hNe(e){let{components:n,...t}=e;return(0,s.yg)(dNe,(0,p.A)({},yNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}hNe.isMDXComponent=!0;const gNe={toc:[]},fNe="wrapper";function DNe(e){let{components:n,...t}=e;return(0,s.yg)(fNe,(0,p.A)({},gNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}DNe.isMDXComponent=!0;const MNe={toc:[]},XNe="wrapper";function _Ne(e){let{components:n,...t}=e;return(0,s.yg)(XNe,(0,p.A)({},MNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}_Ne.isMDXComponent=!0;const wNe={toc:[]},TNe="wrapper";function CNe(e){let{components:n,...t}=e;return(0,s.yg)(TNe,(0,p.A)({},wNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}CNe.isMDXComponent=!0;const xNe={toc:[]},ANe="wrapper";function vNe(e){let{components:n,...t}=e;return(0,s.yg)(ANe,(0,p.A)({},xNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}vNe.isMDXComponent=!0;const LNe={toc:[]},bNe="wrapper";function NNe(e){let{components:n,...t}=e;return(0,s.yg)(bNe,(0,p.A)({},LNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a single ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.yg)("p",null,"You can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.yg)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.yg)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}NNe.isMDXComponent=!0;const kNe={toc:[]},zNe="wrapper";function PNe(e){let{components:n,...t}=e;return(0,s.yg)(zNe,(0,p.A)({},kNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,'The following will select the word "console" in the code.\nBoth lines and columns are 0-based. So it will select a 7-character-long\n(',(0,s.yg)("inlineCode",{parentName:"p"},"7"),") word in the second line (",(0,s.yg)("inlineCode",{parentName:"p"},"1"),") starting at the third character (",(0,s.yg)("inlineCode",{parentName:"p"},"2"),")."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  selection={word(1, 2, 7)}\n  code={`\\\nfunction hello() => {\n  console.log('Hello');\n}`}\n  // ...\n/>\n")))}PNe.isMDXComponent=!0;const INe={toc:[]},RNe="wrapper";function WNe(e){let{components:n,...t}=e;return(0,s.yg)(RNe,(0,p.A)({},INe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The currently selected code range."))}WNe.isMDXComponent=!0;const SNe={toc:[]},BNe="wrapper";function GNe(e){let{components:n,...t}=e;return(0,s.yg)(BNe,(0,p.A)({},SNe,t,{components:n,mdxType:"MDXLayout"}))}GNe.isMDXComponent=!0;const ENe={toc:[]},ONe="wrapper";function UNe(e){let{components:n,...t}=e;return(0,s.yg)(ONe,(0,p.A)({},ENe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}UNe.isMDXComponent=!0;const FNe={toc:[]},VNe="wrapper";function qNe(e){let{components:n,...t}=e;return(0,s.yg)(VNe,(0,p.A)({},FNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qNe.isMDXComponent=!0;const jNe={toc:[]},HNe="wrapper";function YNe(e){let{components:n,...t}=e;return(0,s.yg)(HNe,(0,p.A)({},jNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}YNe.isMDXComponent=!0;const QNe={toc:[]},$Ne="wrapper";function KNe(e){let{components:n,...t}=e;return(0,s.yg)($Ne,(0,p.A)({},QNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}KNe.isMDXComponent=!0;const JNe={toc:[]},ZNe="wrapper";function eke(e){let{components:n,...t}=e;return(0,s.yg)(ZNe,(0,p.A)({},JNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}eke.isMDXComponent=!0;const nke={toc:[]},tke="wrapper";function oke(e){let{components:n,...t}=e;return(0,s.yg)(tke,(0,p.A)({},nke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}oke.isMDXComponent=!0;const pke={toc:[]},rke="wrapper";function ske(e){let{components:n,...t}=e;return(0,s.yg)(rke,(0,p.A)({},pke,t,{components:n,mdxType:"MDXLayout"}))}ske.isMDXComponent=!0;const cke={toc:[]},ake="wrapper";function ike(e){let{components:n,...t}=e;return(0,s.yg)(ake,(0,p.A)({},cke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ike.isMDXComponent=!0;const lke={toc:[]},uke="wrapper";function mke(e){let{components:n,...t}=e;return(0,s.yg)(uke,(0,p.A)({},lke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}mke.isMDXComponent=!0;const yke={toc:[]},dke="wrapper";function hke(e){let{components:n,...t}=e;return(0,s.yg)(dke,(0,p.A)({},yke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}hke.isMDXComponent=!0;const gke={toc:[]},fke="wrapper";function Dke(e){let{components:n,...t}=e;return(0,s.yg)(fke,(0,p.A)({},gke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Dke.isMDXComponent=!0;const Mke={toc:[]},Xke="wrapper";function _ke(e){let{components:n,...t}=e;return(0,s.yg)(Xke,(0,p.A)({},Mke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_ke.isMDXComponent=!0;const wke={toc:[]},Tke="wrapper";function Cke(e){let{components:n,...t}=e;return(0,s.yg)(Tke,(0,p.A)({},wke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Cke.isMDXComponent=!0;const xke={toc:[]},Ake="wrapper";function vke(e){let{components:n,...t}=e;return(0,s.yg)(Ake,(0,p.A)({},xke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}vke.isMDXComponent=!0;const Lke={toc:[]},bke="wrapper";function Nke(e){let{components:n,...t}=e;return(0,s.yg)(bke,(0,p.A)({},Lke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Nke.isMDXComponent=!0;const kke={toc:[]},zke="wrapper";function Pke(e){let{components:n,...t}=e;return(0,s.yg)(zke,(0,p.A)({},kke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Pke.isMDXComponent=!0;const Ike={toc:[]},Rke="wrapper";function Wke(e){let{components:n,...t}=e;return(0,s.yg)(Rke,(0,p.A)({},Ike,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Wke.isMDXComponent=!0;const Ske={toc:[]},Bke="wrapper";function Gke(e){let{components:n,...t}=e;return(0,s.yg)(Bke,(0,p.A)({},Ske,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Gke.isMDXComponent=!0;const Eke={toc:[]},Oke="wrapper";function Uke(e){let{components:n,...t}=e;return(0,s.yg)(Oke,(0,p.A)({},Eke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Uke.isMDXComponent=!0;const Fke={toc:[]},Vke="wrapper";function qke(e){let{components:n,...t}=e;return(0,s.yg)(Vke,(0,p.A)({},Fke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}qke.isMDXComponent=!0;const jke={toc:[]},Hke="wrapper";function Yke(e){let{components:n,...t}=e;return(0,s.yg)(Hke,(0,p.A)({},jke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Yke.isMDXComponent=!0;const Qke={toc:[]},$ke="wrapper";function Kke(e){let{components:n,...t}=e;return(0,s.yg)($ke,(0,p.A)({},Qke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Kke.isMDXComponent=!0;const Jke={toc:[]},Zke="wrapper";function eze(e){let{components:n,...t}=e;return(0,s.yg)(Zke,(0,p.A)({},Jke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}eze.isMDXComponent=!0;const nze={toc:[]},tze="wrapper";function oze(e){let{components:n,...t}=e;return(0,s.yg)(tze,(0,p.A)({},nze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}oze.isMDXComponent=!0;const pze={toc:[]},rze="wrapper";function sze(e){let{components:n,...t}=e;return(0,s.yg)(rze,(0,p.A)({},pze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sze.isMDXComponent=!0;const cze={toc:[]},aze="wrapper";function ize(e){let{components:n,...t}=e;return(0,s.yg)(aze,(0,p.A)({},cze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}ize.isMDXComponent=!0;const lze={toc:[]},uze="wrapper";function mze(e){let{components:n,...t}=e;return(0,s.yg)(uze,(0,p.A)({},lze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}mze.isMDXComponent=!0;const yze={toc:[]},dze="wrapper";function hze(e){let{components:n,...t}=e;return(0,s.yg)(dze,(0,p.A)({},yze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}hze.isMDXComponent=!0;const gze={toc:[]},fze="wrapper";function Dze(e){let{components:n,...t}=e;return(0,s.yg)(fze,(0,p.A)({},gze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Dze.isMDXComponent=!0;const Mze={toc:[]},Xze="wrapper";function _ze(e){let{components:n,...t}=e;return(0,s.yg)(Xze,(0,p.A)({},Mze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}_ze.isMDXComponent=!0;const wze={toc:[]},Tze="wrapper";function Cze(e){let{components:n,...t}=e;return(0,s.yg)(Tze,(0,p.A)({},wze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Cze.isMDXComponent=!0;const xze={toc:[]},Aze="wrapper";function vze(e){let{components:n,...t}=e;return(0,s.yg)(Aze,(0,p.A)({},xze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}vze.isMDXComponent=!0;const Lze={toc:[]},bze="wrapper";function Nze(e){let{components:n,...t}=e;return(0,s.yg)(bze,(0,p.A)({},Lze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Nze.isMDXComponent=!0;const kze={toc:[]},zze="wrapper";function Pze(e){let{components:n,...t}=e;return(0,s.yg)(zze,(0,p.A)({},kze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a child code signal."))}Pze.isMDXComponent=!0;const Ize={toc:[]},Rze="wrapper";function Wze(e){let{components:n,...t}=e;return(0,s.yg)(Rze,(0,p.A)({},Ize,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial code."))}Wze.isMDXComponent=!0;const Sze={toc:[]},Bze="wrapper";function Gze(e){let{components:n,...t}=e;return(0,s.yg)(Bze,(0,p.A)({},Sze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Gze.isMDXComponent=!0;const Eze={toc:[]},Oze="wrapper";function Uze(e){let{components:n,...t}=e;return(0,s.yg)(Oze,(0,p.A)({},Eze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Uze.isMDXComponent=!0;const Fze={toc:[]},Vze="wrapper";function qze(e){let{components:n,...t}=e;return(0,s.yg)(Vze,(0,p.A)({},Fze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qze.isMDXComponent=!0;const jze={toc:[]},Hze="wrapper";function Yze(e){let{components:n,...t}=e;return(0,s.yg)(Hze,(0,p.A)({},jze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Yze.isMDXComponent=!0;const Qze={toc:[]},$ze="wrapper";function Kze(e){let{components:n,...t}=e;return(0,s.yg)($ze,(0,p.A)({},Qze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Kze.isMDXComponent=!0;const Jze={toc:[]},Zze="wrapper";function ePe(e){let{components:n,...t}=e;return(0,s.yg)(Zze,(0,p.A)({},Jze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}ePe.isMDXComponent=!0;const nPe={toc:[]},tPe="wrapper";function oPe(e){let{components:n,...t}=e;return(0,s.yg)(tPe,(0,p.A)({},nPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}oPe.isMDXComponent=!0;const pPe={toc:[]},rPe="wrapper";function sPe(e){let{components:n,...t}=e;return(0,s.yg)(rPe,(0,p.A)({},pPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sPe.isMDXComponent=!0;const cPe={toc:[]},aPe="wrapper";function iPe(e){let{components:n,...t}=e;return(0,s.yg)(aPe,(0,p.A)({},cPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}iPe.isMDXComponent=!0;const lPe={toc:[]},uPe="wrapper";function mPe(e){let{components:n,...t}=e;return(0,s.yg)(uPe,(0,p.A)({},lPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}mPe.isMDXComponent=!0;const yPe={toc:[]},dPe="wrapper";function hPe(e){let{components:n,...t}=e;return(0,s.yg)(dPe,(0,p.A)({},yPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}hPe.isMDXComponent=!0;const gPe={toc:[]},fPe="wrapper";function DPe(e){let{components:n,...t}=e;return(0,s.yg)(fPe,(0,p.A)({},gPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}DPe.isMDXComponent=!0;const MPe={toc:[]},XPe="wrapper";function _Pe(e){let{components:n,...t}=e;return(0,s.yg)(XPe,(0,p.A)({},MPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_Pe.isMDXComponent=!0;const wPe={toc:[]},TPe="wrapper";function CPe(e){let{components:n,...t}=e;return(0,s.yg)(TPe,(0,p.A)({},wPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}CPe.isMDXComponent=!0;const xPe={toc:[]},APe="wrapper";function vPe(e){let{components:n,...t}=e;return(0,s.yg)(APe,(0,p.A)({},xPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vPe.isMDXComponent=!0;const LPe={toc:[]},bPe="wrapper";function NPe(e){let{components:n,...t}=e;return(0,s.yg)(bPe,(0,p.A)({},LPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all code ranges that match the given pattern."))}NPe.isMDXComponent=!0;const kPe={toc:[]},zPe="wrapper";function PPe(e){let{components:n,...t}=e;return(0,s.yg)(zPe,(0,p.A)({},kPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}PPe.isMDXComponent=!0;const IPe={toc:[]},RPe="wrapper";function WPe(e){let{components:n,...t}=e;return(0,s.yg)(RPe,(0,p.A)({},IPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}WPe.isMDXComponent=!0;const SPe={toc:[]},BPe="wrapper";function GPe(e){let{components:n,...t}=e;return(0,s.yg)(BPe,(0,p.A)({},SPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GPe.isMDXComponent=!0;const EPe={toc:[]},OPe="wrapper";function UPe(e){let{components:n,...t}=e;return(0,s.yg)(OPe,(0,p.A)({},EPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}UPe.isMDXComponent=!0;const FPe={toc:[]},VPe="wrapper";function qPe(e){let{components:n,...t}=e;return(0,s.yg)(VPe,(0,p.A)({},FPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qPe.isMDXComponent=!0;const jPe={toc:[]},HPe="wrapper";function YPe(e){let{components:n,...t}=e;return(0,s.yg)(HPe,(0,p.A)({},jPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}YPe.isMDXComponent=!0;const QPe={toc:[]},$Pe="wrapper";function KPe(e){let{components:n,...t}=e;return(0,s.yg)($Pe,(0,p.A)({},QPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}KPe.isMDXComponent=!0;const JPe={toc:[]},ZPe="wrapper";function eIe(e){let{components:n,...t}=e;return(0,s.yg)(ZPe,(0,p.A)({},JPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}eIe.isMDXComponent=!0;const nIe={toc:[]},tIe="wrapper";function oIe(e){let{components:n,...t}=e;return(0,s.yg)(tIe,(0,p.A)({},nIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oIe.isMDXComponent=!0;const pIe={toc:[]},rIe="wrapper";function sIe(e){let{components:n,...t}=e;return(0,s.yg)(rIe,(0,p.A)({},pIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first code range that matches the given pattern."))}sIe.isMDXComponent=!0;const cIe={toc:[]},aIe="wrapper";function iIe(e){let{components:n,...t}=e;return(0,s.yg)(aIe,(0,p.A)({},cIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}iIe.isMDXComponent=!0;const lIe={toc:[]},uIe="wrapper";function mIe(e){let{components:n,...t}=e;return(0,s.yg)(uIe,(0,p.A)({},lIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}mIe.isMDXComponent=!0;const yIe={toc:[]},dIe="wrapper";function hIe(e){let{components:n,...t}=e;return(0,s.yg)(dIe,(0,p.A)({},yIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hIe.isMDXComponent=!0;const gIe={toc:[]},fIe="wrapper";function DIe(e){let{components:n,...t}=e;return(0,s.yg)(fIe,(0,p.A)({},gIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}DIe.isMDXComponent=!0;const MIe={toc:[]},XIe="wrapper";function _Ie(e){let{components:n,...t}=e;return(0,s.yg)(XIe,(0,p.A)({},MIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_Ie.isMDXComponent=!0;const wIe={toc:[]},TIe="wrapper";function CIe(e){let{components:n,...t}=e;return(0,s.yg)(TIe,(0,p.A)({},wIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last code range that matches the given pattern."))}CIe.isMDXComponent=!0;const xIe={toc:[]},AIe="wrapper";function vIe(e){let{components:n,...t}=e;return(0,s.yg)(AIe,(0,p.A)({},xIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}vIe.isMDXComponent=!0;const LIe={toc:[]},bIe="wrapper";function NIe(e){let{components:n,...t}=e;return(0,s.yg)(bIe,(0,p.A)({},LIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}NIe.isMDXComponent=!0;const kIe={toc:[]},zIe="wrapper";function PIe(e){let{components:n,...t}=e;return(0,s.yg)(zIe,(0,p.A)({},kIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}PIe.isMDXComponent=!0;const IIe={toc:[]},RIe="wrapper";function WIe(e){let{components:n,...t}=e;return(0,s.yg)(RIe,(0,p.A)({},IIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}WIe.isMDXComponent=!0;const SIe={toc:[]},BIe="wrapper";function GIe(e){let{components:n,...t}=e;return(0,s.yg)(BIe,(0,p.A)({},SIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}GIe.isMDXComponent=!0;const EIe={toc:[]},OIe="wrapper";function UIe(e){let{components:n,...t}=e;return(0,s.yg)(OIe,(0,p.A)({},EIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bound box is in local space of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Code")," node."))}UIe.isMDXComponent=!0;const FIe={toc:[]},VIe="wrapper";function qIe(e){let{components:n,...t}=e;return(0,s.yg)(VIe,(0,p.A)({},FIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the bounding box of the given point (character) in the code."))}qIe.isMDXComponent=!0;const jIe={toc:[]},HIe="wrapper";function YIe(e){let{components:n,...t}=e;return(0,s.yg)(HIe,(0,p.A)({},jIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The point to get the bounding box for."))}YIe.isMDXComponent=!0;const QIe={toc:[]},$Ie="wrapper";function KIe(e){let{components:n,...t}=e;return(0,s.yg)($Ie,(0,p.A)({},QIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bound boxes are in local space of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Code")," node.\nEach line of code has a separate bounding box."))}KIe.isMDXComponent=!0;const JIe={toc:[]},ZIe="wrapper";function eRe(e){let{components:n,...t}=e;return(0,s.yg)(ZIe,(0,p.A)({},JIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return bounding boxes of all characters in the selection."))}eRe.isMDXComponent=!0;const nRe={toc:[]},tRe="wrapper";function oRe(e){let{components:n,...t}=e;return(0,s.yg)(tRe,(0,p.A)({},nRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The selection to get the bounding boxes for."))}oRe.isMDXComponent=!0;const pRe={toc:[]},rRe="wrapper";function sRe(e){let{components:n,...t}=e;return(0,s.yg)(rRe,(0,p.A)({},pRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}sRe.isMDXComponent=!0;const cRe={toc:[]},aRe="wrapper";function iRe(e){let{components:n,...t}=e;return(0,s.yg)(aRe,(0,p.A)({},cRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}iRe.isMDXComponent=!0;const lRe={toc:[]},uRe="wrapper";function mRe(e){let{components:n,...t}=e;return(0,s.yg)(uRe,(0,p.A)({},lRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}mRe.isMDXComponent=!0;const yRe={toc:[]},dRe="wrapper";function hRe(e){let{components:n,...t}=e;return(0,s.yg)(dRe,(0,p.A)({},yRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}hRe.isMDXComponent=!0;const gRe={toc:[]},fRe="wrapper";function DRe(e){let{components:n,...t}=e;return(0,s.yg)(fRe,(0,p.A)({},gRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}DRe.isMDXComponent=!0;const MRe={toc:[]},XRe="wrapper";function _Re(e){let{components:n,...t}=e;return(0,s.yg)(XRe,(0,p.A)({},MRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}_Re.isMDXComponent=!0;const wRe={toc:[]},TRe="wrapper";function CRe(e){let{components:n,...t}=e;return(0,s.yg)(TRe,(0,p.A)({},wRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}CRe.isMDXComponent=!0;const xRe={toc:[]},ARe="wrapper";function vRe(e){let{components:n,...t}=e;return(0,s.yg)(ARe,(0,p.A)({},xRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}vRe.isMDXComponent=!0;const LRe={toc:[]},bRe="wrapper";function NRe(e){let{components:n,...t}=e;return(0,s.yg)(bRe,(0,p.A)({},LRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}NRe.isMDXComponent=!0;const kRe={toc:[]},zRe="wrapper";function PRe(e){let{components:n,...t}=e;return(0,s.yg)(zRe,(0,p.A)({},kRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}PRe.isMDXComponent=!0;const IRe={toc:[]},RRe="wrapper";function WRe(e){let{components:n,...t}=e;return(0,s.yg)(RRe,(0,p.A)({},IRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}WRe.isMDXComponent=!0;const SRe={toc:[]},BRe="wrapper";function GRe(e){let{components:n,...t}=e;return(0,s.yg)(BRe,(0,p.A)({},SRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}GRe.isMDXComponent=!0;const ERe={toc:[]},ORe="wrapper";function URe(e){let{components:n,...t}=e;return(0,s.yg)(ORe,(0,p.A)({},ERe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}URe.isMDXComponent=!0;const FRe={toc:[]},VRe="wrapper";function qRe(e){let{components:n,...t}=e;return(0,s.yg)(VRe,(0,p.A)({},FRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}qRe.isMDXComponent=!0;const jRe={toc:[]},HRe="wrapper";function YRe(e){let{components:n,...t}=e;return(0,s.yg)(HRe,(0,p.A)({},jRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}YRe.isMDXComponent=!0;const QRe={toc:[]},$Re="wrapper";function KRe(e){let{components:n,...t}=e;return(0,s.yg)($Re,(0,p.A)({},QRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}KRe.isMDXComponent=!0;const JRe={toc:[]},ZRe="wrapper";function eWe(e){let{components:n,...t}=e;return(0,s.yg)(ZRe,(0,p.A)({},JRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}eWe.isMDXComponent=!0;const nWe={toc:[]},tWe="wrapper";function oWe(e){let{components:n,...t}=e;return(0,s.yg)(tWe,(0,p.A)({},nWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}oWe.isMDXComponent=!0;const pWe={toc:[]},rWe="wrapper";function sWe(e){let{components:n,...t}=e;return(0,s.yg)(rWe,(0,p.A)({},pWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}sWe.isMDXComponent=!0;const cWe={toc:[]},aWe="wrapper";function iWe(e){let{components:n,...t}=e;return(0,s.yg)(aWe,(0,p.A)({},cWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}iWe.isMDXComponent=!0;const lWe={toc:[]},uWe="wrapper";function mWe(e){let{components:n,...t}=e;return(0,s.yg)(uWe,(0,p.A)({},lWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mWe.isMDXComponent=!0;const yWe={toc:[]},dWe="wrapper";function hWe(e){let{components:n,...t}=e;return(0,s.yg)(dWe,(0,p.A)({},yWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}hWe.isMDXComponent=!0;const gWe={toc:[]},fWe="wrapper";function DWe(e){let{components:n,...t}=e;return(0,s.yg)(fWe,(0,p.A)({},gWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}DWe.isMDXComponent=!0;const MWe={toc:[]},XWe="wrapper";function _We(e){let{components:n,...t}=e;return(0,s.yg)(XWe,(0,p.A)({},MWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_We.isMDXComponent=!0;const wWe={toc:[]},TWe="wrapper";function CWe(e){let{components:n,...t}=e;return(0,s.yg)(TWe,(0,p.A)({},wWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}CWe.isMDXComponent=!0;const xWe={toc:[]},AWe="wrapper";function vWe(e){let{components:n,...t}=e;return(0,s.yg)(AWe,(0,p.A)({},xWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}vWe.isMDXComponent=!0;const LWe={toc:[]},bWe="wrapper";function NWe(e){let{components:n,...t}=e;return(0,s.yg)(bWe,(0,p.A)({},LWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}NWe.isMDXComponent=!0;const kWe={toc:[]},zWe="wrapper";function PWe(e){let{components:n,...t}=e;return(0,s.yg)(zWe,(0,p.A)({},kWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}PWe.isMDXComponent=!0;const IWe={toc:[]},RWe="wrapper";function WWe(e){let{components:n,...t}=e;return(0,s.yg)(RWe,(0,p.A)({},IWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}WWe.isMDXComponent=!0;const SWe={toc:[]},BWe="wrapper";function GWe(e){let{components:n,...t}=e;return(0,s.yg)(BWe,(0,p.A)({},SWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}GWe.isMDXComponent=!0;const EWe={toc:[]},OWe="wrapper";function UWe(e){let{components:n,...t}=e;return(0,s.yg)(OWe,(0,p.A)({},EWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}UWe.isMDXComponent=!0;const FWe={toc:[]},VWe="wrapper";function qWe(e){let{components:n,...t}=e;return(0,s.yg)(VWe,(0,p.A)({},FWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}qWe.isMDXComponent=!0;const jWe={toc:[]},HWe="wrapper";function YWe(e){let{components:n,...t}=e;return(0,s.yg)(HWe,(0,p.A)({},jWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}YWe.isMDXComponent=!0;const QWe={toc:[]},$We="wrapper";function KWe(e){let{components:n,...t}=e;return(0,s.yg)($We,(0,p.A)({},QWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}KWe.isMDXComponent=!0;const JWe={toc:[]},ZWe="wrapper";function eSe(e){let{components:n,...t}=e;return(0,s.yg)(ZWe,(0,p.A)({},JWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}eSe.isMDXComponent=!0;const nSe={toc:[]},tSe="wrapper";function oSe(e){let{components:n,...t}=e;return(0,s.yg)(tSe,(0,p.A)({},nSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}oSe.isMDXComponent=!0;const pSe={toc:[]},rSe="wrapper";function sSe(e){let{components:n,...t}=e;return(0,s.yg)(rSe,(0,p.A)({},pSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}sSe.isMDXComponent=!0;const cSe={toc:[]},aSe="wrapper";function iSe(e){let{components:n,...t}=e;return(0,s.yg)(aSe,(0,p.A)({},cSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}iSe.isMDXComponent=!0;const lSe={toc:[]},uSe="wrapper";function mSe(e){let{components:n,...t}=e;return(0,s.yg)(uSe,(0,p.A)({},lSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}mSe.isMDXComponent=!0;const ySe={toc:[]},dSe="wrapper";function hSe(e){let{components:n,...t}=e;return(0,s.yg)(dSe,(0,p.A)({},ySe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hSe.isMDXComponent=!0;const gSe={toc:[]},fSe="wrapper";function DSe(e){let{components:n,...t}=e;return(0,s.yg)(fSe,(0,p.A)({},gSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}DSe.isMDXComponent=!0;const MSe={toc:[]},XSe="wrapper";function _Se(e){let{components:n,...t}=e;return(0,s.yg)(XSe,(0,p.A)({},MSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}_Se.isMDXComponent=!0;const wSe={toc:[]},TSe="wrapper";function CSe(e){let{components:n,...t}=e;return(0,s.yg)(TSe,(0,p.A)({},wSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}CSe.isMDXComponent=!0;const xSe={toc:[]},ASe="wrapper";function vSe(e){let{components:n,...t}=e;return(0,s.yg)(ASe,(0,p.A)({},xSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}vSe.isMDXComponent=!0;const LSe={toc:[]},bSe="wrapper";function NSe(e){let{components:n,...t}=e;return(0,s.yg)(bSe,(0,p.A)({},LSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the currently displayed code as a string."))}NSe.isMDXComponent=!0;const kSe={toc:[]},zSe="wrapper";function PSe(e){let{components:n,...t}=e;return(0,s.yg)(zSe,(0,p.A)({},kSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}PSe.isMDXComponent=!0;const ISe={toc:[]},RSe="wrapper";function WSe(e){let{components:n,...t}=e;return(0,s.yg)(RSe,(0,p.A)({},ISe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}WSe.isMDXComponent=!0;const SSe={toc:[]},BSe="wrapper";function GSe(e){let{components:n,...t}=e;return(0,s.yg)(BSe,(0,p.A)({},SSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}GSe.isMDXComponent=!0;const ESe={toc:[]},OSe="wrapper";function USe(e){let{components:n,...t}=e;return(0,s.yg)(OSe,(0,p.A)({},ESe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}USe.isMDXComponent=!0;const FSe={toc:[]},VSe="wrapper";function qSe(e){let{components:n,...t}=e;return(0,s.yg)(VSe,(0,p.A)({},FSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}qSe.isMDXComponent=!0;const jSe={toc:[]},HSe="wrapper";function YSe(e){let{components:n,...t}=e;return(0,s.yg)(HSe,(0,p.A)({},jSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}YSe.isMDXComponent=!0;const QSe={toc:[]},$Se="wrapper";function KSe(e){let{components:n,...t}=e;return(0,s.yg)($Se,(0,p.A)({},QSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}KSe.isMDXComponent=!0;const JSe={toc:[]},ZSe="wrapper";function eBe(e){let{components:n,...t}=e;return(0,s.yg)(ZSe,(0,p.A)({},JSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}eBe.isMDXComponent=!0;const nBe={toc:[]},tBe="wrapper";function oBe(e){let{components:n,...t}=e;return(0,s.yg)(tBe,(0,p.A)({},nBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}oBe.isMDXComponent=!0;const pBe={toc:[]},rBe="wrapper";function sBe(e){let{components:n,...t}=e;return(0,s.yg)(rBe,(0,p.A)({},pBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}sBe.isMDXComponent=!0;const cBe={toc:[]},aBe="wrapper";function iBe(e){let{components:n,...t}=e;return(0,s.yg)(aBe,(0,p.A)({},cBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}iBe.isMDXComponent=!0;const lBe={toc:[]},uBe="wrapper";function mBe(e){let{components:n,...t}=e;return(0,s.yg)(uBe,(0,p.A)({},lBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}mBe.isMDXComponent=!0;const yBe={toc:[]},dBe="wrapper";function hBe(e){let{components:n,...t}=e;return(0,s.yg)(dBe,(0,p.A)({},yBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}hBe.isMDXComponent=!0;const gBe={toc:[]},fBe="wrapper";function DBe(e){let{components:n,...t}=e;return(0,s.yg)(fBe,(0,p.A)({},gBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}DBe.isMDXComponent=!0;const MBe={toc:[]},XBe="wrapper";function _Be(e){let{components:n,...t}=e;return(0,s.yg)(XBe,(0,p.A)({},MBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}_Be.isMDXComponent=!0;const wBe={toc:[]},TBe="wrapper";function CBe(e){let{components:n,...t}=e;return(0,s.yg)(TBe,(0,p.A)({},wBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}CBe.isMDXComponent=!0;const xBe={toc:[]},ABe="wrapper";function vBe(e){let{components:n,...t}=e;return(0,s.yg)(ABe,(0,p.A)({},xBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}vBe.isMDXComponent=!0;const LBe={toc:[]},bBe="wrapper";function NBe(e){let{components:n,...t}=e;return(0,s.yg)(bBe,(0,p.A)({},LBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}NBe.isMDXComponent=!0;const kBe={toc:[]},zBe="wrapper";function PBe(e){let{components:n,...t}=e;return(0,s.yg)(zBe,(0,p.A)({},kBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}PBe.isMDXComponent=!0;const IBe={toc:[]},RBe="wrapper";function WBe(e){let{components:n,...t}=e;return(0,s.yg)(RBe,(0,p.A)({},IBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}WBe.isMDXComponent=!0;const SBe={toc:[]},BBe="wrapper";function GBe(e){let{components:n,...t}=e;return(0,s.yg)(BBe,(0,p.A)({},SBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GBe.isMDXComponent=!0;const EBe={toc:[]},OBe="wrapper";function UBe(e){let{components:n,...t}=e;return(0,s.yg)(OBe,(0,p.A)({},EBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}UBe.isMDXComponent=!0;const FBe={toc:[]},VBe="wrapper";function qBe(e){let{components:n,...t}=e;return(0,s.yg)(VBe,(0,p.A)({},FBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}qBe.isMDXComponent=!0;const jBe={toc:[]},HBe="wrapper";function YBe(e){let{components:n,...t}=e;return(0,s.yg)(HBe,(0,p.A)({},jBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}YBe.isMDXComponent=!0;const QBe={toc:[]},$Be="wrapper";function KBe(e){let{components:n,...t}=e;return(0,s.yg)($Be,(0,p.A)({},QBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}KBe.isMDXComponent=!0;const JBe={toc:[]},ZBe="wrapper";function eGe(e){let{components:n,...t}=e;return(0,s.yg)(ZBe,(0,p.A)({},JBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eGe.isMDXComponent=!0;const nGe={toc:[]},tGe="wrapper";function oGe(e){let{components:n,...t}=e;return(0,s.yg)(tGe,(0,p.A)({},nGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}oGe.isMDXComponent=!0;const pGe={toc:[]},rGe="wrapper";function sGe(e){let{components:n,...t}=e;return(0,s.yg)(rGe,(0,p.A)({},pGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}sGe.isMDXComponent=!0;const cGe={toc:[]},aGe="wrapper";function iGe(e){let{components:n,...t}=e;return(0,s.yg)(aGe,(0,p.A)({},cGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}iGe.isMDXComponent=!0;const lGe={toc:[]},uGe="wrapper";function mGe(e){let{components:n,...t}=e;return(0,s.yg)(uGe,(0,p.A)({},lGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mGe.isMDXComponent=!0;const yGe={toc:[]},dGe="wrapper";function hGe(e){let{components:n,...t}=e;return(0,s.yg)(dGe,(0,p.A)({},yGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}hGe.isMDXComponent=!0;const gGe={toc:[]},fGe="wrapper";function DGe(e){let{components:n,...t}=e;return(0,s.yg)(fGe,(0,p.A)({},gGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}DGe.isMDXComponent=!0;const MGe={toc:[]},XGe="wrapper";function _Ge(e){let{components:n,...t}=e;return(0,s.yg)(XGe,(0,p.A)({},MGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_Ge.isMDXComponent=!0;const wGe={toc:[]},TGe="wrapper";function CGe(e){let{components:n,...t}=e;return(0,s.yg)(TGe,(0,p.A)({},wGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}CGe.isMDXComponent=!0;const xGe={toc:[]},AGe="wrapper";function vGe(e){let{components:n,...t}=e;return(0,s.yg)(AGe,(0,p.A)({},xGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}vGe.isMDXComponent=!0;const LGe={toc:[]},bGe="wrapper";function NGe(e){let{components:n,...t}=e;return(0,s.yg)(bGe,(0,p.A)({},LGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}NGe.isMDXComponent=!0;const kGe={toc:[]},zGe="wrapper";function PGe(e){let{components:n,...t}=e;return(0,s.yg)(zGe,(0,p.A)({},kGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}PGe.isMDXComponent=!0;const IGe={toc:[]},RGe="wrapper";function WGe(e){let{components:n,...t}=e;return(0,s.yg)(RGe,(0,p.A)({},IGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}WGe.isMDXComponent=!0;const SGe={toc:[]},BGe="wrapper";function GGe(e){let{components:n,...t}=e;return(0,s.yg)(BGe,(0,p.A)({},SGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}GGe.isMDXComponent=!0;const EGe={toc:[]},OGe="wrapper";function UGe(e){let{components:n,...t}=e;return(0,s.yg)(OGe,(0,p.A)({},EGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}UGe.isMDXComponent=!0;const FGe={toc:[]},VGe="wrapper";function qGe(e){let{components:n,...t}=e;return(0,s.yg)(VGe,(0,p.A)({},FGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qGe.isMDXComponent=!0;const jGe={toc:[]},HGe="wrapper";function YGe(e){let{components:n,...t}=e;return(0,s.yg)(HGe,(0,p.A)({},jGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}YGe.isMDXComponent=!0;const QGe={toc:[]},$Ge="wrapper";function KGe(e){let{components:n,...t}=e;return(0,s.yg)($Ge,(0,p.A)({},QGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}KGe.isMDXComponent=!0;const JGe={toc:[]},ZGe="wrapper";function eEe(e){let{components:n,...t}=e;return(0,s.yg)(ZGe,(0,p.A)({},JGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}eEe.isMDXComponent=!0;const nEe={toc:[]},tEe="wrapper";function oEe(e){let{components:n,...t}=e;return(0,s.yg)(tEe,(0,p.A)({},nEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}oEe.isMDXComponent=!0;const pEe={toc:[]},rEe="wrapper";function sEe(e){let{components:n,...t}=e;return(0,s.yg)(rEe,(0,p.A)({},pEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a standalone code signal."))}sEe.isMDXComponent=!0;const cEe={toc:[]},aEe="wrapper";function iEe(e){let{components:n,...t}=e;return(0,s.yg)(aEe,(0,p.A)({},cEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial code."))}iEe.isMDXComponent=!0;const lEe={toc:[]},uEe="wrapper";function mEe(e){let{components:n,...t}=e;return(0,s.yg)(uEe,(0,p.A)({},lEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom highlighter to use."))}mEe.isMDXComponent=!0;const yEe={toc:[]},dEe="wrapper";function hEe(e){let{components:n,...t}=e;return(0,s.yg)(dEe,(0,p.A)({},yEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom dialect to use."))}hEe.isMDXComponent=!0;const gEe={toc:[]},fEe="wrapper";function DEe(e){let{components:n,...t}=e;return(0,s.yg)(fEe,(0,p.A)({},gEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}DEe.isMDXComponent=!0;const MEe={toc:[]},XEe="wrapper";function _Ee(e){let{components:n,...t}=e;return(0,s.yg)(XEe,(0,p.A)({},MEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a cubic B\xe9zier curve."))}_Ee.isMDXComponent=!0;const wEe={toc:[]},TEe="wrapper";function CEe(e){let{components:n,...t}=e;return(0,s.yg)(TEe,(0,p.A)({},wEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}CEe.isMDXComponent=!0;const xEe={toc:[]},AEe="wrapper";function vEe(e){let{components:n,...t}=e;return(0,s.yg)(AEe,(0,p.A)({},xEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}vEe.isMDXComponent=!0;const LEe={toc:[]},bEe="wrapper";function NEe(e){let{components:n,...t}=e;return(0,s.yg)(bEe,(0,p.A)({},LEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NEe.isMDXComponent=!0;const kEe={toc:[]},zEe="wrapper";function PEe(e){let{components:n,...t}=e;return(0,s.yg)(zEe,(0,p.A)({},kEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}PEe.isMDXComponent=!0;const IEe={toc:[]},REe="wrapper";function WEe(e){let{components:n,...t}=e;return(0,s.yg)(REe,(0,p.A)({},IEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}WEe.isMDXComponent=!0;const SEe={toc:[]},BEe="wrapper";function GEe(e){let{components:n,...t}=e;return(0,s.yg)(BEe,(0,p.A)({},SEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}GEe.isMDXComponent=!0;const EEe={toc:[]},OEe="wrapper";function UEe(e){let{components:n,...t}=e;return(0,s.yg)(OEe,(0,p.A)({},EEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}UEe.isMDXComponent=!0;const FEe={toc:[]},VEe="wrapper";function qEe(e){let{components:n,...t}=e;return(0,s.yg)(VEe,(0,p.A)({},FEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}qEe.isMDXComponent=!0;const jEe={toc:[]},HEe="wrapper";function YEe(e){let{components:n,...t}=e;return(0,s.yg)(HEe,(0,p.A)({},jEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}YEe.isMDXComponent=!0;const QEe={toc:[]},$Ee="wrapper";function KEe(e){let{components:n,...t}=e;return(0,s.yg)($Ee,(0,p.A)({},QEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}KEe.isMDXComponent=!0;const JEe={toc:[]},ZEe="wrapper";function eOe(e){let{components:n,...t}=e;return(0,s.yg)(ZEe,(0,p.A)({},JEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}eOe.isMDXComponent=!0;const nOe={toc:[]},tOe="wrapper";function oOe(e){let{components:n,...t}=e;return(0,s.yg)(tOe,(0,p.A)({},nOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}oOe.isMDXComponent=!0;const pOe={toc:[]},rOe="wrapper";function sOe(e){let{components:n,...t}=e;return(0,s.yg)(rOe,(0,p.A)({},pOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}sOe.isMDXComponent=!0;const cOe={toc:[]},aOe="wrapper";function iOe(e){let{components:n,...t}=e;return(0,s.yg)(aOe,(0,p.A)({},cOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}iOe.isMDXComponent=!0;const lOe={toc:[]},uOe="wrapper";function mOe(e){let{components:n,...t}=e;return(0,s.yg)(uOe,(0,p.A)({},lOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}mOe.isMDXComponent=!0;const yOe={toc:[]},dOe="wrapper";function hOe(e){let{components:n,...t}=e;return(0,s.yg)(dOe,(0,p.A)({},yOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}hOe.isMDXComponent=!0;const gOe={toc:[]},fOe="wrapper";function DOe(e){let{components:n,...t}=e;return(0,s.yg)(fOe,(0,p.A)({},gOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}DOe.isMDXComponent=!0;const MOe={toc:[]},XOe="wrapper";function _Oe(e){let{components:n,...t}=e;return(0,s.yg)(XOe,(0,p.A)({},MOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}_Oe.isMDXComponent=!0;const wOe={toc:[]},TOe="wrapper";function COe(e){let{components:n,...t}=e;return(0,s.yg)(TOe,(0,p.A)({},wOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}COe.isMDXComponent=!0;const xOe={toc:[]},AOe="wrapper";function vOe(e){let{components:n,...t}=e;return(0,s.yg)(AOe,(0,p.A)({},xOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}vOe.isMDXComponent=!0;const LOe={toc:[]},bOe="wrapper";function NOe(e){let{components:n,...t}=e;return(0,s.yg)(bOe,(0,p.A)({},LOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NOe.isMDXComponent=!0;const kOe={toc:[]},zOe="wrapper";function POe(e){let{components:n,...t}=e;return(0,s.yg)(zOe,(0,p.A)({},kOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}POe.isMDXComponent=!0;const IOe={toc:[]},ROe="wrapper";function WOe(e){let{components:n,...t}=e;return(0,s.yg)(ROe,(0,p.A)({},IOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}WOe.isMDXComponent=!0;const SOe={toc:[]},BOe="wrapper";function GOe(e){let{components:n,...t}=e;return(0,s.yg)(BOe,(0,p.A)({},SOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}GOe.isMDXComponent=!0;const EOe={toc:[]},OOe="wrapper";function UOe(e){let{components:n,...t}=e;return(0,s.yg)(OOe,(0,p.A)({},EOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}UOe.isMDXComponent=!0;const FOe={toc:[]},VOe="wrapper";function qOe(e){let{components:n,...t}=e;return(0,s.yg)(VOe,(0,p.A)({},FOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}qOe.isMDXComponent=!0;const jOe={toc:[]},HOe="wrapper";function YOe(e){let{components:n,...t}=e;return(0,s.yg)(HOe,(0,p.A)({},jOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}YOe.isMDXComponent=!0;const QOe={toc:[]},$Oe="wrapper";function KOe(e){let{components:n,...t}=e;return(0,s.yg)($Oe,(0,p.A)({},QOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}KOe.isMDXComponent=!0;const JOe={toc:[]},ZOe="wrapper";function eUe(e){let{components:n,...t}=e;return(0,s.yg)(ZOe,(0,p.A)({},JOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}eUe.isMDXComponent=!0;const nUe={toc:[]},tUe="wrapper";function oUe(e){let{components:n,...t}=e;return(0,s.yg)(tUe,(0,p.A)({},nUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}oUe.isMDXComponent=!0;const pUe={toc:[]},rUe="wrapper";function sUe(e){let{components:n,...t}=e;return(0,s.yg)(rUe,(0,p.A)({},pUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}sUe.isMDXComponent=!0;const cUe={toc:[]},aUe="wrapper";function iUe(e){let{components:n,...t}=e;return(0,s.yg)(aUe,(0,p.A)({},cUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}iUe.isMDXComponent=!0;const lUe={toc:[]},uUe="wrapper";function mUe(e){let{components:n,...t}=e;return(0,s.yg)(uUe,(0,p.A)({},lUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start point of the B\xe9zier curve."))}mUe.isMDXComponent=!0;const yUe={toc:[]},dUe="wrapper";function hUe(e){let{components:n,...t}=e;return(0,s.yg)(dUe,(0,p.A)({},yUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The first control point of the B\xe9zier curve."))}hUe.isMDXComponent=!0;const gUe={toc:[]},fUe="wrapper";function DUe(e){let{components:n,...t}=e;return(0,s.yg)(fUe,(0,p.A)({},gUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The second control point of the B\xe9zier curve."))}DUe.isMDXComponent=!0;const MUe={toc:[]},XUe="wrapper";function _Ue(e){let{components:n,...t}=e;return(0,s.yg)(XUe,(0,p.A)({},MUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end point of the B\xe9zier curve."))}_Ue.isMDXComponent=!0;const wUe={toc:[]},TUe="wrapper";function CUe(e){let{components:n,...t}=e;return(0,s.yg)(TUe,(0,p.A)({},wUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}CUe.isMDXComponent=!0;const xUe={toc:[]},AUe="wrapper";function vUe(e){let{components:n,...t}=e;return(0,s.yg)(AUe,(0,p.A)({},xUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}vUe.isMDXComponent=!0;const LUe={toc:[]},bUe="wrapper";function NUe(e){let{components:n,...t}=e;return(0,s.yg)(bUe,(0,p.A)({},LUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}NUe.isMDXComponent=!0;const kUe={toc:[]},zUe="wrapper";function PUe(e){let{components:n,...t}=e;return(0,s.yg)(zUe,(0,p.A)({},kUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}PUe.isMDXComponent=!0;const IUe={toc:[]},RUe="wrapper";function WUe(e){let{components:n,...t}=e;return(0,s.yg)(RUe,(0,p.A)({},IUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}WUe.isMDXComponent=!0;const SUe={toc:[]},BUe="wrapper";function GUe(e){let{components:n,...t}=e;return(0,s.yg)(BUe,(0,p.A)({},SUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}GUe.isMDXComponent=!0;const EUe={toc:[]},OUe="wrapper";function UUe(e){let{components:n,...t}=e;return(0,s.yg)(OUe,(0,p.A)({},EUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}UUe.isMDXComponent=!0;const FUe={toc:[]},VUe="wrapper";function qUe(e){let{components:n,...t}=e;return(0,s.yg)(VUe,(0,p.A)({},FUe,t,{components:n,mdxType:"MDXLayout"}))}qUe.isMDXComponent=!0;const jUe={toc:[]},HUe="wrapper";function YUe(e){let{components:n,...t}=e;return(0,s.yg)(HUe,(0,p.A)({},jUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}YUe.isMDXComponent=!0;const QUe={toc:[]},$Ue="wrapper";function KUe(e){let{components:n,...t}=e;return(0,s.yg)($Ue,(0,p.A)({},QUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}KUe.isMDXComponent=!0;const JUe={toc:[]},ZUe="wrapper";function eFe(e){let{components:n,...t}=e;return(0,s.yg)(ZUe,(0,p.A)({},JUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}eFe.isMDXComponent=!0;const nFe={toc:[]},tFe="wrapper";function oFe(e){let{components:n,...t}=e;return(0,s.yg)(tFe,(0,p.A)({},nFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}oFe.isMDXComponent=!0;const pFe={toc:[]},rFe="wrapper";function sFe(e){let{components:n,...t}=e;return(0,s.yg)(rFe,(0,p.A)({},pFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}sFe.isMDXComponent=!0;const cFe={toc:[]},aFe="wrapper";function iFe(e){let{components:n,...t}=e;return(0,s.yg)(aFe,(0,p.A)({},cFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}iFe.isMDXComponent=!0;const lFe={toc:[]},uFe="wrapper";function mFe(e){let{components:n,...t}=e;return(0,s.yg)(uFe,(0,p.A)({},lFe,t,{components:n,mdxType:"MDXLayout"}))}mFe.isMDXComponent=!0;const yFe={toc:[]},dFe="wrapper";function hFe(e){let{components:n,...t}=e;return(0,s.yg)(dFe,(0,p.A)({},yFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}hFe.isMDXComponent=!0;const gFe={toc:[]},fFe="wrapper";function DFe(e){let{components:n,...t}=e;return(0,s.yg)(fFe,(0,p.A)({},gFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}DFe.isMDXComponent=!0;const MFe={toc:[]},XFe="wrapper";function _Fe(e){let{components:n,...t}=e;return(0,s.yg)(XFe,(0,p.A)({},MFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_Fe.isMDXComponent=!0;const wFe={toc:[]},TFe="wrapper";function CFe(e){let{components:n,...t}=e;return(0,s.yg)(TFe,(0,p.A)({},wFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}CFe.isMDXComponent=!0;const xFe={toc:[]},AFe="wrapper";function vFe(e){let{components:n,...t}=e;return(0,s.yg)(AFe,(0,p.A)({},xFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}vFe.isMDXComponent=!0;const LFe={toc:[]},bFe="wrapper";function NFe(e){let{components:n,...t}=e;return(0,s.yg)(bFe,(0,p.A)({},LFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}NFe.isMDXComponent=!0;const kFe={toc:[]},zFe="wrapper";function PFe(e){let{components:n,...t}=e;return(0,s.yg)(zFe,(0,p.A)({},kFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}PFe.isMDXComponent=!0;const IFe={toc:[]},RFe="wrapper";function WFe(e){let{components:n,...t}=e;return(0,s.yg)(RFe,(0,p.A)({},IFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}WFe.isMDXComponent=!0;const SFe={toc:[]},BFe="wrapper";function GFe(e){let{components:n,...t}=e;return(0,s.yg)(BFe,(0,p.A)({},SFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}GFe.isMDXComponent=!0;const EFe={toc:[]},OFe="wrapper";function UFe(e){let{components:n,...t}=e;return(0,s.yg)(OFe,(0,p.A)({},EFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}UFe.isMDXComponent=!0;const FFe={toc:[]},VFe="wrapper";function qFe(e){let{components:n,...t}=e;return(0,s.yg)(VFe,(0,p.A)({},FFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}qFe.isMDXComponent=!0;const jFe={toc:[]},HFe="wrapper";function YFe(e){let{components:n,...t}=e;return(0,s.yg)(HFe,(0,p.A)({},jFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}YFe.isMDXComponent=!0;const QFe={toc:[]},$Fe="wrapper";function KFe(e){let{components:n,...t}=e;return(0,s.yg)($Fe,(0,p.A)({},QFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}KFe.isMDXComponent=!0;const JFe={toc:[]},ZFe="wrapper";function eVe(e){let{components:n,...t}=e;return(0,s.yg)(ZFe,(0,p.A)({},JFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}eVe.isMDXComponent=!0;const nVe={toc:[]},tVe="wrapper";function oVe(e){let{components:n,...t}=e;return(0,s.yg)(tVe,(0,p.A)({},nVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}oVe.isMDXComponent=!0;const pVe={toc:[]},rVe="wrapper";function sVe(e){let{components:n,...t}=e;return(0,s.yg)(rVe,(0,p.A)({},pVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}sVe.isMDXComponent=!0;const cVe={toc:[]},aVe="wrapper";function iVe(e){let{components:n,...t}=e;return(0,s.yg)(aVe,(0,p.A)({},cVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}iVe.isMDXComponent=!0;const lVe={toc:[]},uVe="wrapper";function mVe(e){let{components:n,...t}=e;return(0,s.yg)(uVe,(0,p.A)({},lVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}mVe.isMDXComponent=!0;const yVe={toc:[]},dVe="wrapper";function hVe(e){let{components:n,...t}=e;return(0,s.yg)(dVe,(0,p.A)({},yVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}hVe.isMDXComponent=!0;const gVe={toc:[]},fVe="wrapper";function DVe(e){let{components:n,...t}=e;return(0,s.yg)(fVe,(0,p.A)({},gVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}DVe.isMDXComponent=!0;const MVe={toc:[]},XVe="wrapper";function _Ve(e){let{components:n,...t}=e;return(0,s.yg)(XVe,(0,p.A)({},MVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}_Ve.isMDXComponent=!0;const wVe={toc:[]},TVe="wrapper";function CVe(e){let{components:n,...t}=e;return(0,s.yg)(TVe,(0,p.A)({},wVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}CVe.isMDXComponent=!0;const xVe={toc:[]},AVe="wrapper";function vVe(e){let{components:n,...t}=e;return(0,s.yg)(AVe,(0,p.A)({},xVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}vVe.isMDXComponent=!0;const LVe={toc:[]},bVe="wrapper";function NVe(e){let{components:n,...t}=e;return(0,s.yg)(bVe,(0,p.A)({},LVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}NVe.isMDXComponent=!0;const kVe={toc:[]},zVe="wrapper";function PVe(e){let{components:n,...t}=e;return(0,s.yg)(zVe,(0,p.A)({},kVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}PVe.isMDXComponent=!0;const IVe={toc:[]},RVe="wrapper";function WVe(e){let{components:n,...t}=e;return(0,s.yg)(RVe,(0,p.A)({},IVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}WVe.isMDXComponent=!0;const SVe={toc:[]},BVe="wrapper";function GVe(e){let{components:n,...t}=e;return(0,s.yg)(BVe,(0,p.A)({},SVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}GVe.isMDXComponent=!0;const EVe={toc:[]},OVe="wrapper";function UVe(e){let{components:n,...t}=e;return(0,s.yg)(OVe,(0,p.A)({},EVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}UVe.isMDXComponent=!0;const FVe={toc:[]},VVe="wrapper";function qVe(e){let{components:n,...t}=e;return(0,s.yg)(VVe,(0,p.A)({},FVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}qVe.isMDXComponent=!0;const jVe={toc:[]},HVe="wrapper";function YVe(e){let{components:n,...t}=e;return(0,s.yg)(HVe,(0,p.A)({},jVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}YVe.isMDXComponent=!0;const QVe={toc:[]},$Ve="wrapper";function KVe(e){let{components:n,...t}=e;return(0,s.yg)($Ve,(0,p.A)({},QVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}KVe.isMDXComponent=!0;const JVe={toc:[]},ZVe="wrapper";function eqe(e){let{components:n,...t}=e;return(0,s.yg)(ZVe,(0,p.A)({},JVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}eqe.isMDXComponent=!0;const nqe={toc:[]},tqe="wrapper";function oqe(e){let{components:n,...t}=e;return(0,s.yg)(tqe,(0,p.A)({},nqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}oqe.isMDXComponent=!0;const pqe={toc:[]},rqe="wrapper";function sqe(e){let{components:n,...t}=e;return(0,s.yg)(rqe,(0,p.A)({},pqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}sqe.isMDXComponent=!0;const cqe={toc:[]},aqe="wrapper";function iqe(e){let{components:n,...t}=e;return(0,s.yg)(aqe,(0,p.A)({},cqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}iqe.isMDXComponent=!0;const lqe={toc:[]},uqe="wrapper";function mqe(e){let{components:n,...t}=e;return(0,s.yg)(uqe,(0,p.A)({},lqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}mqe.isMDXComponent=!0;const yqe={toc:[]},dqe="wrapper";function hqe(e){let{components:n,...t}=e;return(0,s.yg)(dqe,(0,p.A)({},yqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}hqe.isMDXComponent=!0;const gqe={toc:[]},fqe="wrapper";function Dqe(e){let{components:n,...t}=e;return(0,s.yg)(fqe,(0,p.A)({},gqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Dqe.isMDXComponent=!0;const Mqe={toc:[]},Xqe="wrapper";function _qe(e){let{components:n,...t}=e;return(0,s.yg)(Xqe,(0,p.A)({},Mqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}_qe.isMDXComponent=!0;const wqe={toc:[]},Tqe="wrapper";function Cqe(e){let{components:n,...t}=e;return(0,s.yg)(Tqe,(0,p.A)({},wqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Cqe.isMDXComponent=!0;const xqe={toc:[]},Aqe="wrapper";function vqe(e){let{components:n,...t}=e;return(0,s.yg)(Aqe,(0,p.A)({},xqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}vqe.isMDXComponent=!0;const Lqe={toc:[]},bqe="wrapper";function Nqe(e){let{components:n,...t}=e;return(0,s.yg)(bqe,(0,p.A)({},Lqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Nqe.isMDXComponent=!0;const kqe={toc:[]},zqe="wrapper";function Pqe(e){let{components:n,...t}=e;return(0,s.yg)(zqe,(0,p.A)({},kqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Pqe.isMDXComponent=!0;const Iqe={toc:[]},Rqe="wrapper";function Wqe(e){let{components:n,...t}=e;return(0,s.yg)(Rqe,(0,p.A)({},Iqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Wqe.isMDXComponent=!0;const Sqe={toc:[]},Bqe="wrapper";function Gqe(e){let{components:n,...t}=e;return(0,s.yg)(Bqe,(0,p.A)({},Sqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Gqe.isMDXComponent=!0;const Eqe={toc:[]},Oqe="wrapper";function Uqe(e){let{components:n,...t}=e;return(0,s.yg)(Oqe,(0,p.A)({},Eqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Uqe.isMDXComponent=!0;const Fqe={toc:[]},Vqe="wrapper";function qqe(e){let{components:n,...t}=e;return(0,s.yg)(Vqe,(0,p.A)({},Fqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}qqe.isMDXComponent=!0;const jqe={toc:[]},Hqe="wrapper";function Yqe(e){let{components:n,...t}=e;return(0,s.yg)(Hqe,(0,p.A)({},jqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Yqe.isMDXComponent=!0;const Qqe={toc:[]},$qe="wrapper";function Kqe(e){let{components:n,...t}=e;return(0,s.yg)($qe,(0,p.A)({},Qqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kqe.isMDXComponent=!0;const Jqe={toc:[]},Zqe="wrapper";function eje(e){let{components:n,...t}=e;return(0,s.yg)(Zqe,(0,p.A)({},Jqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}eje.isMDXComponent=!0;const nje={toc:[]},tje="wrapper";function oje(e){let{components:n,...t}=e;return(0,s.yg)(tje,(0,p.A)({},nje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}oje.isMDXComponent=!0;const pje={toc:[]},rje="wrapper";function sje(e){let{components:n,...t}=e;return(0,s.yg)(rje,(0,p.A)({},pje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}sje.isMDXComponent=!0;const cje={toc:[]},aje="wrapper";function ije(e){let{components:n,...t}=e;return(0,s.yg)(aje,(0,p.A)({},cje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}ije.isMDXComponent=!0;const lje={toc:[]},uje="wrapper";function mje(e){let{components:n,...t}=e;return(0,s.yg)(uje,(0,p.A)({},lje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mje.isMDXComponent=!0;const yje={toc:[]},dje="wrapper";function hje(e){let{components:n,...t}=e;return(0,s.yg)(dje,(0,p.A)({},yje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}hje.isMDXComponent=!0;const gje={toc:[]},fje="wrapper";function Dje(e){let{components:n,...t}=e;return(0,s.yg)(fje,(0,p.A)({},gje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Dje.isMDXComponent=!0;const Mje={toc:[]},Xje="wrapper";function _je(e){let{components:n,...t}=e;return(0,s.yg)(Xje,(0,p.A)({},Mje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}_je.isMDXComponent=!0;const wje={toc:[]},Tje="wrapper";function Cje(e){let{components:n,...t}=e;return(0,s.yg)(Tje,(0,p.A)({},wje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Cje.isMDXComponent=!0;const xje={toc:[]},Aje="wrapper";function vje(e){let{components:n,...t}=e;return(0,s.yg)(Aje,(0,p.A)({},xje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}vje.isMDXComponent=!0;const Lje={toc:[]},bje="wrapper";function Nje(e){let{components:n,...t}=e;return(0,s.yg)(bje,(0,p.A)({},Lje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Nje.isMDXComponent=!0;const kje={toc:[]},zje="wrapper";function Pje(e){let{components:n,...t}=e;return(0,s.yg)(zje,(0,p.A)({},kje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Pje.isMDXComponent=!0;const Ije={toc:[]},Rje="wrapper";function Wje(e){let{components:n,...t}=e;return(0,s.yg)(Rje,(0,p.A)({},Ije,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Wje.isMDXComponent=!0;const Sje={toc:[]},Bje="wrapper";function Gje(e){let{components:n,...t}=e;return(0,s.yg)(Bje,(0,p.A)({},Sje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Gje.isMDXComponent=!0;const Eje={toc:[]},Oje="wrapper";function Uje(e){let{components:n,...t}=e;return(0,s.yg)(Oje,(0,p.A)({},Eje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Uje.isMDXComponent=!0;const Fje={toc:[]},Vje="wrapper";function qje(e){let{components:n,...t}=e;return(0,s.yg)(Vje,(0,p.A)({},Fje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}qje.isMDXComponent=!0;const jje={toc:[]},Hje="wrapper";function Yje(e){let{components:n,...t}=e;return(0,s.yg)(Hje,(0,p.A)({},jje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Yje.isMDXComponent=!0;const Qje={toc:[]},$je="wrapper";function Kje(e){let{components:n,...t}=e;return(0,s.yg)($je,(0,p.A)({},Qje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Kje.isMDXComponent=!0;const Jje={toc:[]},Zje="wrapper";function eHe(e){let{components:n,...t}=e;return(0,s.yg)(Zje,(0,p.A)({},Jje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eHe.isMDXComponent=!0;const nHe={toc:[]},tHe="wrapper";function oHe(e){let{components:n,...t}=e;return(0,s.yg)(tHe,(0,p.A)({},nHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}oHe.isMDXComponent=!0;const pHe={toc:[]},rHe="wrapper";function sHe(e){let{components:n,...t}=e;return(0,s.yg)(rHe,(0,p.A)({},pHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}sHe.isMDXComponent=!0;const cHe={toc:[]},aHe="wrapper";function iHe(e){let{components:n,...t}=e;return(0,s.yg)(aHe,(0,p.A)({},cHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}iHe.isMDXComponent=!0;const lHe={toc:[]},uHe="wrapper";function mHe(e){let{components:n,...t}=e;return(0,s.yg)(uHe,(0,p.A)({},lHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}mHe.isMDXComponent=!0;const yHe={toc:[]},dHe="wrapper";function hHe(e){let{components:n,...t}=e;return(0,s.yg)(dHe,(0,p.A)({},yHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hHe.isMDXComponent=!0;const gHe={toc:[]},fHe="wrapper";function DHe(e){let{components:n,...t}=e;return(0,s.yg)(fHe,(0,p.A)({},gHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}DHe.isMDXComponent=!0;const MHe={toc:[]},XHe="wrapper";function _He(e){let{components:n,...t}=e;return(0,s.yg)(XHe,(0,p.A)({},MHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}_He.isMDXComponent=!0;const wHe={toc:[]},THe="wrapper";function CHe(e){let{components:n,...t}=e;return(0,s.yg)(THe,(0,p.A)({},wHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}CHe.isMDXComponent=!0;const xHe={toc:[]},AHe="wrapper";function vHe(e){let{components:n,...t}=e;return(0,s.yg)(AHe,(0,p.A)({},xHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}vHe.isMDXComponent=!0;const LHe={toc:[]},bHe="wrapper";function NHe(e){let{components:n,...t}=e;return(0,s.yg)(bHe,(0,p.A)({},LHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}NHe.isMDXComponent=!0;const kHe={toc:[]},zHe="wrapper";function PHe(e){let{components:n,...t}=e;return(0,s.yg)(zHe,(0,p.A)({},kHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}PHe.isMDXComponent=!0;const IHe={toc:[]},RHe="wrapper";function WHe(e){let{components:n,...t}=e;return(0,s.yg)(RHe,(0,p.A)({},IHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}WHe.isMDXComponent=!0;const SHe={toc:[]},BHe="wrapper";function GHe(e){let{components:n,...t}=e;return(0,s.yg)(BHe,(0,p.A)({},SHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}GHe.isMDXComponent=!0;const EHe={toc:[]},OHe="wrapper";function UHe(e){let{components:n,...t}=e;return(0,s.yg)(OHe,(0,p.A)({},EHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}UHe.isMDXComponent=!0;const FHe={toc:[]},VHe="wrapper";function qHe(e){let{components:n,...t}=e;return(0,s.yg)(VHe,(0,p.A)({},FHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qHe.isMDXComponent=!0;const jHe={toc:[]},HHe="wrapper";function YHe(e){let{components:n,...t}=e;return(0,s.yg)(HHe,(0,p.A)({},jHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}YHe.isMDXComponent=!0;const QHe={toc:[]},$He="wrapper";function KHe(e){let{components:n,...t}=e;return(0,s.yg)($He,(0,p.A)({},QHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}KHe.isMDXComponent=!0;const JHe={toc:[]},ZHe="wrapper";function eYe(e){let{components:n,...t}=e;return(0,s.yg)(ZHe,(0,p.A)({},JHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}eYe.isMDXComponent=!0;const nYe={toc:[]},tYe="wrapper";function oYe(e){let{components:n,...t}=e;return(0,s.yg)(tYe,(0,p.A)({},nYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}oYe.isMDXComponent=!0;const pYe={toc:[]},rYe="wrapper";function sYe(e){let{components:n,...t}=e;return(0,s.yg)(rYe,(0,p.A)({},pYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sYe.isMDXComponent=!0;const cYe={toc:[]},aYe="wrapper";function iYe(e){let{components:n,...t}=e;return(0,s.yg)(aYe,(0,p.A)({},cYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}iYe.isMDXComponent=!0;const lYe={toc:[]},uYe="wrapper";function mYe(e){let{components:n,...t}=e;return(0,s.yg)(uYe,(0,p.A)({},lYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}mYe.isMDXComponent=!0;const yYe={toc:[]},dYe="wrapper";function hYe(e){let{components:n,...t}=e;return(0,s.yg)(dYe,(0,p.A)({},yYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}hYe.isMDXComponent=!0;const gYe={toc:[]},fYe="wrapper";function DYe(e){let{components:n,...t}=e;return(0,s.yg)(fYe,(0,p.A)({},gYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}DYe.isMDXComponent=!0;const MYe={toc:[]},XYe="wrapper";function _Ye(e){let{components:n,...t}=e;return(0,s.yg)(XYe,(0,p.A)({},MYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_Ye.isMDXComponent=!0;const wYe={toc:[]},TYe="wrapper";function CYe(e){let{components:n,...t}=e;return(0,s.yg)(TYe,(0,p.A)({},wYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}CYe.isMDXComponent=!0;const xYe={toc:[]},AYe="wrapper";function vYe(e){let{components:n,...t}=e;return(0,s.yg)(AYe,(0,p.A)({},xYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}vYe.isMDXComponent=!0;const LYe={toc:[]},bYe="wrapper";function NYe(e){let{components:n,...t}=e;return(0,s.yg)(bYe,(0,p.A)({},LYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}NYe.isMDXComponent=!0;const kYe={toc:[]},zYe="wrapper";function PYe(e){let{components:n,...t}=e;return(0,s.yg)(zYe,(0,p.A)({},kYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}PYe.isMDXComponent=!0;const IYe={toc:[]},RYe="wrapper";function WYe(e){let{components:n,...t}=e;return(0,s.yg)(RYe,(0,p.A)({},IYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}WYe.isMDXComponent=!0;const SYe={toc:[]},BYe="wrapper";function GYe(e){let{components:n,...t}=e;return(0,s.yg)(BYe,(0,p.A)({},SYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}GYe.isMDXComponent=!0;const EYe={toc:[]},OYe="wrapper";function UYe(e){let{components:n,...t}=e;return(0,s.yg)(OYe,(0,p.A)({},EYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}UYe.isMDXComponent=!0;const FYe={toc:[]},VYe="wrapper";function qYe(e){let{components:n,...t}=e;return(0,s.yg)(VYe,(0,p.A)({},FYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qYe.isMDXComponent=!0;const jYe={toc:[]},HYe="wrapper";function YYe(e){let{components:n,...t}=e;return(0,s.yg)(HYe,(0,p.A)({},jYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}YYe.isMDXComponent=!0;const QYe={toc:[]},$Ye="wrapper";function KYe(e){let{components:n,...t}=e;return(0,s.yg)($Ye,(0,p.A)({},QYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}KYe.isMDXComponent=!0;const JYe={toc:[]},ZYe="wrapper";function eQe(e){let{components:n,...t}=e;return(0,s.yg)(ZYe,(0,p.A)({},JYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}eQe.isMDXComponent=!0;const nQe={toc:[]},tQe="wrapper";function oQe(e){let{components:n,...t}=e;return(0,s.yg)(tQe,(0,p.A)({},nQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}oQe.isMDXComponent=!0;const pQe={toc:[]},rQe="wrapper";function sQe(e){let{components:n,...t}=e;return(0,s.yg)(rQe,(0,p.A)({},pQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}sQe.isMDXComponent=!0;const cQe={toc:[]},aQe="wrapper";function iQe(e){let{components:n,...t}=e;return(0,s.yg)(aQe,(0,p.A)({},cQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}iQe.isMDXComponent=!0;const lQe={toc:[]},uQe="wrapper";function mQe(e){let{components:n,...t}=e;return(0,s.yg)(uQe,(0,p.A)({},lQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mQe.isMDXComponent=!0;const yQe={toc:[]},dQe="wrapper";function hQe(e){let{components:n,...t}=e;return(0,s.yg)(dQe,(0,p.A)({},yQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}hQe.isMDXComponent=!0;const gQe={toc:[]},fQe="wrapper";function DQe(e){let{components:n,...t}=e;return(0,s.yg)(fQe,(0,p.A)({},gQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}DQe.isMDXComponent=!0;const MQe={toc:[]},XQe="wrapper";function _Qe(e){let{components:n,...t}=e;return(0,s.yg)(XQe,(0,p.A)({},MQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}_Qe.isMDXComponent=!0;const wQe={toc:[]},TQe="wrapper";function CQe(e){let{components:n,...t}=e;return(0,s.yg)(TQe,(0,p.A)({},wQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}CQe.isMDXComponent=!0;const xQe={toc:[]},AQe="wrapper";function vQe(e){let{components:n,...t}=e;return(0,s.yg)(AQe,(0,p.A)({},xQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}vQe.isMDXComponent=!0;const LQe={toc:[]},bQe="wrapper";function NQe(e){let{components:n,...t}=e;return(0,s.yg)(bQe,(0,p.A)({},LQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}NQe.isMDXComponent=!0;const kQe={toc:[]},zQe="wrapper";function PQe(e){let{components:n,...t}=e;return(0,s.yg)(zQe,(0,p.A)({},kQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}PQe.isMDXComponent=!0;const IQe={toc:[]},RQe="wrapper";function WQe(e){let{components:n,...t}=e;return(0,s.yg)(RQe,(0,p.A)({},IQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}WQe.isMDXComponent=!0;const SQe={toc:[]},BQe="wrapper";function GQe(e){let{components:n,...t}=e;return(0,s.yg)(BQe,(0,p.A)({},SQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}GQe.isMDXComponent=!0;const EQe={toc:[]},OQe="wrapper";function UQe(e){let{components:n,...t}=e;return(0,s.yg)(OQe,(0,p.A)({},EQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}UQe.isMDXComponent=!0;const FQe={toc:[]},VQe="wrapper";function qQe(e){let{components:n,...t}=e;return(0,s.yg)(VQe,(0,p.A)({},FQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}qQe.isMDXComponent=!0;const jQe={toc:[]},HQe="wrapper";function YQe(e){let{components:n,...t}=e;return(0,s.yg)(HQe,(0,p.A)({},jQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}YQe.isMDXComponent=!0;const QQe={toc:[]},$Qe="wrapper";function KQe(e){let{components:n,...t}=e;return(0,s.yg)($Qe,(0,p.A)({},QQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}KQe.isMDXComponent=!0;const JQe={toc:[]},ZQe="wrapper";function e$e(e){let{components:n,...t}=e;return(0,s.yg)(ZQe,(0,p.A)({},JQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}e$e.isMDXComponent=!0;const n$e={toc:[]},t$e="wrapper";function o$e(e){let{components:n,...t}=e;return(0,s.yg)(t$e,(0,p.A)({},n$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}o$e.isMDXComponent=!0;const p$e={toc:[]},r$e="wrapper";function s$e(e){let{components:n,...t}=e;return(0,s.yg)(r$e,(0,p.A)({},p$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}s$e.isMDXComponent=!0;const c$e={toc:[]},a$e="wrapper";function i$e(e){let{components:n,...t}=e;return(0,s.yg)(a$e,(0,p.A)({},c$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}i$e.isMDXComponent=!0;const l$e={toc:[]},u$e="wrapper";function m$e(e){let{components:n,...t}=e;return(0,s.yg)(u$e,(0,p.A)({},l$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}m$e.isMDXComponent=!0;const y$e={toc:[]},d$e="wrapper";function h$e(e){let{components:n,...t}=e;return(0,s.yg)(d$e,(0,p.A)({},y$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}h$e.isMDXComponent=!0;const g$e={toc:[]},f$e="wrapper";function D$e(e){let{components:n,...t}=e;return(0,s.yg)(f$e,(0,p.A)({},g$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}D$e.isMDXComponent=!0;const M$e={toc:[]},X$e="wrapper";function _$e(e){let{components:n,...t}=e;return(0,s.yg)(X$e,(0,p.A)({},M$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}_$e.isMDXComponent=!0;const w$e={toc:[]},T$e="wrapper";function C$e(e){let{components:n,...t}=e;return(0,s.yg)(T$e,(0,p.A)({},w$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}C$e.isMDXComponent=!0;const x$e={toc:[]},A$e="wrapper";function v$e(e){let{components:n,...t}=e;return(0,s.yg)(A$e,(0,p.A)({},x$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}v$e.isMDXComponent=!0;const L$e={toc:[]},b$e="wrapper";function N$e(e){let{components:n,...t}=e;return(0,s.yg)(b$e,(0,p.A)({},L$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}N$e.isMDXComponent=!0;const k$e={toc:[]},z$e="wrapper";function P$e(e){let{components:n,...t}=e;return(0,s.yg)(z$e,(0,p.A)({},k$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}P$e.isMDXComponent=!0;const I$e={toc:[]},R$e="wrapper";function W$e(e){let{components:n,...t}=e;return(0,s.yg)(R$e,(0,p.A)({},I$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}W$e.isMDXComponent=!0;const S$e={toc:[]},B$e="wrapper";function G$e(e){let{components:n,...t}=e;return(0,s.yg)(B$e,(0,p.A)({},S$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}G$e.isMDXComponent=!0;const E$e={toc:[]},O$e="wrapper";function U$e(e){let{components:n,...t}=e;return(0,s.yg)(O$e,(0,p.A)({},E$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}U$e.isMDXComponent=!0;const F$e={toc:[]},V$e="wrapper";function q$e(e){let{components:n,...t}=e;return(0,s.yg)(V$e,(0,p.A)({},F$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}q$e.isMDXComponent=!0;const j$e={toc:[]},H$e="wrapper";function Y$e(e){let{components:n,...t}=e;return(0,s.yg)(H$e,(0,p.A)({},j$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Y$e.isMDXComponent=!0;const Q$e={toc:[]},$$e="wrapper";function K$e(e){let{components:n,...t}=e;return(0,s.yg)($$e,(0,p.A)({},Q$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}K$e.isMDXComponent=!0;const J$e={toc:[]},Z$e="wrapper";function eKe(e){let{components:n,...t}=e;return(0,s.yg)(Z$e,(0,p.A)({},J$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}eKe.isMDXComponent=!0;const nKe={toc:[]},tKe="wrapper";function oKe(e){let{components:n,...t}=e;return(0,s.yg)(tKe,(0,p.A)({},nKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}oKe.isMDXComponent=!0;const pKe={toc:[]},rKe="wrapper";function sKe(e){let{components:n,...t}=e;return(0,s.yg)(rKe,(0,p.A)({},pKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}sKe.isMDXComponent=!0;const cKe={toc:[]},aKe="wrapper";function iKe(e){let{components:n,...t}=e;return(0,s.yg)(aKe,(0,p.A)({},cKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}iKe.isMDXComponent=!0;const lKe={toc:[]},uKe="wrapper";function mKe(e){let{components:n,...t}=e;return(0,s.yg)(uKe,(0,p.A)({},lKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}mKe.isMDXComponent=!0;const yKe={toc:[]},dKe="wrapper";function hKe(e){let{components:n,...t}=e;return(0,s.yg)(dKe,(0,p.A)({},yKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}hKe.isMDXComponent=!0;const gKe={toc:[]},fKe="wrapper";function DKe(e){let{components:n,...t}=e;return(0,s.yg)(fKe,(0,p.A)({},gKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}DKe.isMDXComponent=!0;const MKe={toc:[]},XKe="wrapper";function _Ke(e){let{components:n,...t}=e;return(0,s.yg)(XKe,(0,p.A)({},MKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}_Ke.isMDXComponent=!0;const wKe={toc:[]},TKe="wrapper";function CKe(e){let{components:n,...t}=e;return(0,s.yg)(TKe,(0,p.A)({},wKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}CKe.isMDXComponent=!0;const xKe={toc:[]},AKe="wrapper";function vKe(e){let{components:n,...t}=e;return(0,s.yg)(AKe,(0,p.A)({},xKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}vKe.isMDXComponent=!0;const LKe={toc:[]},bKe="wrapper";function NKe(e){let{components:n,...t}=e;return(0,s.yg)(bKe,(0,p.A)({},LKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}NKe.isMDXComponent=!0;const kKe={toc:[]},zKe="wrapper";function PKe(e){let{components:n,...t}=e;return(0,s.yg)(zKe,(0,p.A)({},kKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}PKe.isMDXComponent=!0;const IKe={toc:[]},RKe="wrapper";function WKe(e){let{components:n,...t}=e;return(0,s.yg)(RKe,(0,p.A)({},IKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}WKe.isMDXComponent=!0;const SKe={toc:[]},BKe="wrapper";function GKe(e){let{components:n,...t}=e;return(0,s.yg)(BKe,(0,p.A)({},SKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}GKe.isMDXComponent=!0;const EKe={toc:[]},OKe="wrapper";function UKe(e){let{components:n,...t}=e;return(0,s.yg)(OKe,(0,p.A)({},EKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}UKe.isMDXComponent=!0;const FKe={toc:[]},VKe="wrapper";function qKe(e){let{components:n,...t}=e;return(0,s.yg)(VKe,(0,p.A)({},FKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}qKe.isMDXComponent=!0;const jKe={toc:[]},HKe="wrapper";function YKe(e){let{components:n,...t}=e;return(0,s.yg)(HKe,(0,p.A)({},jKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}YKe.isMDXComponent=!0;const QKe={toc:[]},$Ke="wrapper";function KKe(e){let{components:n,...t}=e;return(0,s.yg)($Ke,(0,p.A)({},QKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}KKe.isMDXComponent=!0;const JKe={toc:[]},ZKe="wrapper";function eJe(e){let{components:n,...t}=e;return(0,s.yg)(ZKe,(0,p.A)({},JKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}eJe.isMDXComponent=!0;const nJe={toc:[]},tJe="wrapper";function oJe(e){let{components:n,...t}=e;return(0,s.yg)(tJe,(0,p.A)({},nJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oJe.isMDXComponent=!0;const pJe={toc:[]},rJe="wrapper";function sJe(e){let{components:n,...t}=e;return(0,s.yg)(rJe,(0,p.A)({},pJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sJe.isMDXComponent=!0;const cJe={toc:[]},aJe="wrapper";function iJe(e){let{components:n,...t}=e;return(0,s.yg)(aJe,(0,p.A)({},cJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}iJe.isMDXComponent=!0;const lJe={toc:[]},uJe="wrapper";function mJe(e){let{components:n,...t}=e;return(0,s.yg)(uJe,(0,p.A)({},lJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}mJe.isMDXComponent=!0;const yJe={toc:[]},dJe="wrapper";function hJe(e){let{components:n,...t}=e;return(0,s.yg)(dJe,(0,p.A)({},yJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}hJe.isMDXComponent=!0;const gJe={toc:[]},fJe="wrapper";function DJe(e){let{components:n,...t}=e;return(0,s.yg)(fJe,(0,p.A)({},gJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}DJe.isMDXComponent=!0;const MJe={toc:[]},XJe="wrapper";function _Je(e){let{components:n,...t}=e;return(0,s.yg)(XJe,(0,p.A)({},MJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}_Je.isMDXComponent=!0;const wJe={toc:[]},TJe="wrapper";function CJe(e){let{components:n,...t}=e;return(0,s.yg)(TJe,(0,p.A)({},wJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}CJe.isMDXComponent=!0;const xJe={toc:[]},AJe="wrapper";function vJe(e){let{components:n,...t}=e;return(0,s.yg)(AJe,(0,p.A)({},xJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}vJe.isMDXComponent=!0;const LJe={toc:[]},bJe="wrapper";function NJe(e){let{components:n,...t}=e;return(0,s.yg)(bJe,(0,p.A)({},LJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}NJe.isMDXComponent=!0;const kJe={toc:[]},zJe="wrapper";function PJe(e){let{components:n,...t}=e;return(0,s.yg)(zJe,(0,p.A)({},kJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}PJe.isMDXComponent=!0;const IJe={toc:[]},RJe="wrapper";function WJe(e){let{components:n,...t}=e;return(0,s.yg)(RJe,(0,p.A)({},IJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}WJe.isMDXComponent=!0;const SJe={toc:[]},BJe="wrapper";function GJe(e){let{components:n,...t}=e;return(0,s.yg)(BJe,(0,p.A)({},SJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}GJe.isMDXComponent=!0;const EJe={toc:[]},OJe="wrapper";function UJe(e){let{components:n,...t}=e;return(0,s.yg)(OJe,(0,p.A)({},EJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}UJe.isMDXComponent=!0;const FJe={toc:[]},VJe="wrapper";function qJe(e){let{components:n,...t}=e;return(0,s.yg)(VJe,(0,p.A)({},FJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}qJe.isMDXComponent=!0;const jJe={toc:[]},HJe="wrapper";function YJe(e){let{components:n,...t}=e;return(0,s.yg)(HJe,(0,p.A)({},jJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}YJe.isMDXComponent=!0;const QJe={toc:[]},$Je="wrapper";function KJe(e){let{components:n,...t}=e;return(0,s.yg)($Je,(0,p.A)({},QJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}KJe.isMDXComponent=!0;const JJe={toc:[]},ZJe="wrapper";function eZe(e){let{components:n,...t}=e;return(0,s.yg)(ZJe,(0,p.A)({},JJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}eZe.isMDXComponent=!0;const nZe={toc:[]},tZe="wrapper";function oZe(e){let{components:n,...t}=e;return(0,s.yg)(tZe,(0,p.A)({},nZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}oZe.isMDXComponent=!0;const pZe={toc:[]},rZe="wrapper";function sZe(e){let{components:n,...t}=e;return(0,s.yg)(rZe,(0,p.A)({},pZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}sZe.isMDXComponent=!0;const cZe={toc:[]},aZe="wrapper";function iZe(e){let{components:n,...t}=e;return(0,s.yg)(aZe,(0,p.A)({},cZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}iZe.isMDXComponent=!0;const lZe={toc:[]},uZe="wrapper";function mZe(e){let{components:n,...t}=e;return(0,s.yg)(uZe,(0,p.A)({},lZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}mZe.isMDXComponent=!0;const yZe={toc:[]},dZe="wrapper";function hZe(e){let{components:n,...t}=e;return(0,s.yg)(dZe,(0,p.A)({},yZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}hZe.isMDXComponent=!0;const gZe={toc:[]},fZe="wrapper";function DZe(e){let{components:n,...t}=e;return(0,s.yg)(fZe,(0,p.A)({},gZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}DZe.isMDXComponent=!0;const MZe={toc:[]},XZe="wrapper";function _Ze(e){let{components:n,...t}=e;return(0,s.yg)(XZe,(0,p.A)({},MZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}_Ze.isMDXComponent=!0;const wZe={toc:[]},TZe="wrapper";function CZe(e){let{components:n,...t}=e;return(0,s.yg)(TZe,(0,p.A)({},wZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}CZe.isMDXComponent=!0;const xZe={toc:[]},AZe="wrapper";function vZe(e){let{components:n,...t}=e;return(0,s.yg)(AZe,(0,p.A)({},xZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}vZe.isMDXComponent=!0;const LZe={toc:[]},bZe="wrapper";function NZe(e){let{components:n,...t}=e;return(0,s.yg)(bZe,(0,p.A)({},LZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}NZe.isMDXComponent=!0;const kZe={toc:[]},zZe="wrapper";function PZe(e){let{components:n,...t}=e;return(0,s.yg)(zZe,(0,p.A)({},kZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}PZe.isMDXComponent=!0;const IZe={toc:[]},RZe="wrapper";function WZe(e){let{components:n,...t}=e;return(0,s.yg)(RZe,(0,p.A)({},IZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}WZe.isMDXComponent=!0;const SZe={toc:[]},BZe="wrapper";function GZe(e){let{components:n,...t}=e;return(0,s.yg)(BZe,(0,p.A)({},SZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}GZe.isMDXComponent=!0;const EZe={toc:[]},OZe="wrapper";function UZe(e){let{components:n,...t}=e;return(0,s.yg)(OZe,(0,p.A)({},EZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}UZe.isMDXComponent=!0;const FZe={toc:[]},VZe="wrapper";function qZe(e){let{components:n,...t}=e;return(0,s.yg)(VZe,(0,p.A)({},FZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qZe.isMDXComponent=!0;const jZe={toc:[]},HZe="wrapper";function YZe(e){let{components:n,...t}=e;return(0,s.yg)(HZe,(0,p.A)({},jZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}YZe.isMDXComponent=!0;const QZe={toc:[]},$Ze="wrapper";function KZe(e){let{components:n,...t}=e;return(0,s.yg)($Ze,(0,p.A)({},QZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}KZe.isMDXComponent=!0;const JZe={toc:[]},ZZe="wrapper";function e0e(e){let{components:n,...t}=e;return(0,s.yg)(ZZe,(0,p.A)({},JZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}e0e.isMDXComponent=!0;const n0e={toc:[]},t0e="wrapper";function o0e(e){let{components:n,...t}=e;return(0,s.yg)(t0e,(0,p.A)({},n0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}o0e.isMDXComponent=!0;const p0e={toc:[]},r0e="wrapper";function s0e(e){let{components:n,...t}=e;return(0,s.yg)(r0e,(0,p.A)({},p0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}s0e.isMDXComponent=!0;const c0e={toc:[]},a0e="wrapper";function i0e(e){let{components:n,...t}=e;return(0,s.yg)(a0e,(0,p.A)({},c0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}i0e.isMDXComponent=!0;const l0e={toc:[]},u0e="wrapper";function m0e(e){let{components:n,...t}=e;return(0,s.yg)(u0e,(0,p.A)({},l0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}m0e.isMDXComponent=!0;const y0e={toc:[]},d0e="wrapper";function h0e(e){let{components:n,...t}=e;return(0,s.yg)(d0e,(0,p.A)({},y0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}h0e.isMDXComponent=!0;const g0e={toc:[]},f0e="wrapper";function D0e(e){let{components:n,...t}=e;return(0,s.yg)(f0e,(0,p.A)({},g0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}D0e.isMDXComponent=!0;const M0e={toc:[]},X0e="wrapper";function _0e(e){let{components:n,...t}=e;return(0,s.yg)(X0e,(0,p.A)({},M0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}_0e.isMDXComponent=!0;const w0e={toc:[]},T0e="wrapper";function C0e(e){let{components:n,...t}=e;return(0,s.yg)(T0e,(0,p.A)({},w0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}C0e.isMDXComponent=!0;const x0e={toc:[]},A0e="wrapper";function v0e(e){let{components:n,...t}=e;return(0,s.yg)(A0e,(0,p.A)({},x0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}v0e.isMDXComponent=!0;const L0e={toc:[]},b0e="wrapper";function N0e(e){let{components:n,...t}=e;return(0,s.yg)(b0e,(0,p.A)({},L0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}N0e.isMDXComponent=!0;const k0e={toc:[]},z0e="wrapper";function P0e(e){let{components:n,...t}=e;return(0,s.yg)(z0e,(0,p.A)({},k0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}P0e.isMDXComponent=!0;const I0e={toc:[]},R0e="wrapper";function W0e(e){let{components:n,...t}=e;return(0,s.yg)(R0e,(0,p.A)({},I0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}W0e.isMDXComponent=!0;const S0e={toc:[]},B0e="wrapper";function G0e(e){let{components:n,...t}=e;return(0,s.yg)(B0e,(0,p.A)({},S0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}G0e.isMDXComponent=!0;const E0e={toc:[]},O0e="wrapper";function U0e(e){let{components:n,...t}=e;return(0,s.yg)(O0e,(0,p.A)({},E0e,t,{components:n,mdxType:"MDXLayout"}))}U0e.isMDXComponent=!0;const F0e={toc:[]},V0e="wrapper";function q0e(e){let{components:n,...t}=e;return(0,s.yg)(V0e,(0,p.A)({},F0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}q0e.isMDXComponent=!0;const j0e={toc:[]},H0e="wrapper";function Y0e(e){let{components:n,...t}=e;return(0,s.yg)(H0e,(0,p.A)({},j0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Y0e.isMDXComponent=!0;const Q0e={toc:[]},$0e="wrapper";function K0e(e){let{components:n,...t}=e;return(0,s.yg)($0e,(0,p.A)({},Q0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}K0e.isMDXComponent=!0;const J0e={toc:[]},Z0e="wrapper";function e3e(e){let{components:n,...t}=e;return(0,s.yg)(Z0e,(0,p.A)({},J0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}e3e.isMDXComponent=!0;const n3e={toc:[]},t3e="wrapper";function o3e(e){let{components:n,...t}=e;return(0,s.yg)(t3e,(0,p.A)({},n3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}o3e.isMDXComponent=!0;const p3e={toc:[]},r3e="wrapper";function s3e(e){let{components:n,...t}=e;return(0,s.yg)(r3e,(0,p.A)({},p3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}s3e.isMDXComponent=!0;const c3e={toc:[]},a3e="wrapper";function i3e(e){let{components:n,...t}=e;return(0,s.yg)(a3e,(0,p.A)({},c3e,t,{components:n,mdxType:"MDXLayout"}))}i3e.isMDXComponent=!0;const l3e={toc:[]},u3e="wrapper";function m3e(e){let{components:n,...t}=e;return(0,s.yg)(u3e,(0,p.A)({},l3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}m3e.isMDXComponent=!0;const y3e={toc:[]},d3e="wrapper";function h3e(e){let{components:n,...t}=e;return(0,s.yg)(d3e,(0,p.A)({},y3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}h3e.isMDXComponent=!0;const g3e={toc:[]},f3e="wrapper";function D3e(e){let{components:n,...t}=e;return(0,s.yg)(f3e,(0,p.A)({},g3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}D3e.isMDXComponent=!0;const M3e={toc:[]},X3e="wrapper";function _3e(e){let{components:n,...t}=e;return(0,s.yg)(X3e,(0,p.A)({},M3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}_3e.isMDXComponent=!0;const w3e={toc:[]},T3e="wrapper";function C3e(e){let{components:n,...t}=e;return(0,s.yg)(T3e,(0,p.A)({},w3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}C3e.isMDXComponent=!0;const x3e={toc:[]},A3e="wrapper";function v3e(e){let{components:n,...t}=e;return(0,s.yg)(A3e,(0,p.A)({},x3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}v3e.isMDXComponent=!0;const L3e={toc:[]},b3e="wrapper";function N3e(e){let{components:n,...t}=e;return(0,s.yg)(b3e,(0,p.A)({},L3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}N3e.isMDXComponent=!0;const k3e={toc:[]},z3e="wrapper";function P3e(e){let{components:n,...t}=e;return(0,s.yg)(z3e,(0,p.A)({},k3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}P3e.isMDXComponent=!0;const I3e={toc:[]},R3e="wrapper";function W3e(e){let{components:n,...t}=e;return(0,s.yg)(R3e,(0,p.A)({},I3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}W3e.isMDXComponent=!0;const S3e={toc:[]},B3e="wrapper";function G3e(e){let{components:n,...t}=e;return(0,s.yg)(B3e,(0,p.A)({},S3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}G3e.isMDXComponent=!0;const E3e={toc:[]},O3e="wrapper";function U3e(e){let{components:n,...t}=e;return(0,s.yg)(O3e,(0,p.A)({},E3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}U3e.isMDXComponent=!0;const F3e={toc:[]},V3e="wrapper";function q3e(e){let{components:n,...t}=e;return(0,s.yg)(V3e,(0,p.A)({},F3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}q3e.isMDXComponent=!0;const j3e={toc:[]},H3e="wrapper";function Y3e(e){let{components:n,...t}=e;return(0,s.yg)(H3e,(0,p.A)({},j3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Y3e.isMDXComponent=!0;const Q3e={toc:[]},$3e="wrapper";function K3e(e){let{components:n,...t}=e;return(0,s.yg)($3e,(0,p.A)({},Q3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}K3e.isMDXComponent=!0;const J3e={toc:[]},Z3e="wrapper";function e8e(e){let{components:n,...t}=e;return(0,s.yg)(Z3e,(0,p.A)({},J3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}e8e.isMDXComponent=!0;const n8e={toc:[]},t8e="wrapper";function o8e(e){let{components:n,...t}=e;return(0,s.yg)(t8e,(0,p.A)({},n8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}o8e.isMDXComponent=!0;const p8e={toc:[]},r8e="wrapper";function s8e(e){let{components:n,...t}=e;return(0,s.yg)(r8e,(0,p.A)({},p8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}s8e.isMDXComponent=!0;const c8e={toc:[]},a8e="wrapper";function i8e(e){let{components:n,...t}=e;return(0,s.yg)(a8e,(0,p.A)({},c8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}i8e.isMDXComponent=!0;const l8e={toc:[]},u8e="wrapper";function m8e(e){let{components:n,...t}=e;return(0,s.yg)(u8e,(0,p.A)({},l8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}m8e.isMDXComponent=!0;const y8e={toc:[]},d8e="wrapper";function h8e(e){let{components:n,...t}=e;return(0,s.yg)(d8e,(0,p.A)({},y8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}h8e.isMDXComponent=!0;const g8e={toc:[]},f8e="wrapper";function D8e(e){let{components:n,...t}=e;return(0,s.yg)(f8e,(0,p.A)({},g8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}D8e.isMDXComponent=!0;const M8e={toc:[]},X8e="wrapper";function _8e(e){let{components:n,...t}=e;return(0,s.yg)(X8e,(0,p.A)({},M8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}_8e.isMDXComponent=!0;const w8e={toc:[]},T8e="wrapper";function C8e(e){let{components:n,...t}=e;return(0,s.yg)(T8e,(0,p.A)({},w8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}C8e.isMDXComponent=!0;const x8e={toc:[]},A8e="wrapper";function v8e(e){let{components:n,...t}=e;return(0,s.yg)(A8e,(0,p.A)({},x8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}v8e.isMDXComponent=!0;const L8e={toc:[]},b8e="wrapper";function N8e(e){let{components:n,...t}=e;return(0,s.yg)(b8e,(0,p.A)({},L8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}N8e.isMDXComponent=!0;const k8e={toc:[]},z8e="wrapper";function P8e(e){let{components:n,...t}=e;return(0,s.yg)(z8e,(0,p.A)({},k8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}P8e.isMDXComponent=!0;const I8e={toc:[]},R8e="wrapper";function W8e(e){let{components:n,...t}=e;return(0,s.yg)(R8e,(0,p.A)({},I8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}W8e.isMDXComponent=!0;const S8e={toc:[]},B8e="wrapper";function G8e(e){let{components:n,...t}=e;return(0,s.yg)(B8e,(0,p.A)({},S8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}G8e.isMDXComponent=!0;const E8e={toc:[]},O8e="wrapper";function U8e(e){let{components:n,...t}=e;return(0,s.yg)(O8e,(0,p.A)({},E8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}U8e.isMDXComponent=!0;const F8e={toc:[]},V8e="wrapper";function q8e(e){let{components:n,...t}=e;return(0,s.yg)(V8e,(0,p.A)({},F8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}q8e.isMDXComponent=!0;const j8e={toc:[]},H8e="wrapper";function Y8e(e){let{components:n,...t}=e;return(0,s.yg)(H8e,(0,p.A)({},j8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Y8e.isMDXComponent=!0;const Q8e={toc:[]},$8e="wrapper";function K8e(e){let{components:n,...t}=e;return(0,s.yg)($8e,(0,p.A)({},Q8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}K8e.isMDXComponent=!0;const J8e={toc:[]},Z8e="wrapper";function e2e(e){let{components:n,...t}=e;return(0,s.yg)(Z8e,(0,p.A)({},J8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}e2e.isMDXComponent=!0;const n2e={toc:[]},t2e="wrapper";function o2e(e){let{components:n,...t}=e;return(0,s.yg)(t2e,(0,p.A)({},n2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}o2e.isMDXComponent=!0;const p2e={toc:[]},r2e="wrapper";function s2e(e){let{components:n,...t}=e;return(0,s.yg)(r2e,(0,p.A)({},p2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}s2e.isMDXComponent=!0;const c2e={toc:[]},a2e="wrapper";function i2e(e){let{components:n,...t}=e;return(0,s.yg)(a2e,(0,p.A)({},c2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}i2e.isMDXComponent=!0;const l2e={toc:[]},u2e="wrapper";function m2e(e){let{components:n,...t}=e;return(0,s.yg)(u2e,(0,p.A)({},l2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}m2e.isMDXComponent=!0;const y2e={toc:[]},d2e="wrapper";function h2e(e){let{components:n,...t}=e;return(0,s.yg)(d2e,(0,p.A)({},y2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}h2e.isMDXComponent=!0;const g2e={toc:[]},f2e="wrapper";function D2e(e){let{components:n,...t}=e;return(0,s.yg)(f2e,(0,p.A)({},g2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}D2e.isMDXComponent=!0;const M2e={toc:[]},X2e="wrapper";function _2e(e){let{components:n,...t}=e;return(0,s.yg)(X2e,(0,p.A)({},M2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}_2e.isMDXComponent=!0;const w2e={toc:[]},T2e="wrapper";function C2e(e){let{components:n,...t}=e;return(0,s.yg)(T2e,(0,p.A)({},w2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}C2e.isMDXComponent=!0;const x2e={toc:[]},A2e="wrapper";function v2e(e){let{components:n,...t}=e;return(0,s.yg)(A2e,(0,p.A)({},x2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}v2e.isMDXComponent=!0;const L2e={toc:[]},b2e="wrapper";function N2e(e){let{components:n,...t}=e;return(0,s.yg)(b2e,(0,p.A)({},L2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}N2e.isMDXComponent=!0;const k2e={toc:[]},z2e="wrapper";function P2e(e){let{components:n,...t}=e;return(0,s.yg)(z2e,(0,p.A)({},k2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}P2e.isMDXComponent=!0;const I2e={toc:[]},R2e="wrapper";function W2e(e){let{components:n,...t}=e;return(0,s.yg)(R2e,(0,p.A)({},I2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}W2e.isMDXComponent=!0;const S2e={toc:[]},B2e="wrapper";function G2e(e){let{components:n,...t}=e;return(0,s.yg)(B2e,(0,p.A)({},S2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}G2e.isMDXComponent=!0;const E2e={toc:[]},O2e="wrapper";function U2e(e){let{components:n,...t}=e;return(0,s.yg)(O2e,(0,p.A)({},E2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}U2e.isMDXComponent=!0;const F2e={toc:[]},V2e="wrapper";function q2e(e){let{components:n,...t}=e;return(0,s.yg)(V2e,(0,p.A)({},F2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}q2e.isMDXComponent=!0;const j2e={toc:[]},H2e="wrapper";function Y2e(e){let{components:n,...t}=e;return(0,s.yg)(H2e,(0,p.A)({},j2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Y2e.isMDXComponent=!0;const Q2e={toc:[]},$2e="wrapper";function K2e(e){let{components:n,...t}=e;return(0,s.yg)($2e,(0,p.A)({},Q2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}K2e.isMDXComponent=!0;const J2e={toc:[]},Z2e="wrapper";function e1e(e){let{components:n,...t}=e;return(0,s.yg)(Z2e,(0,p.A)({},J2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}e1e.isMDXComponent=!0;const n1e={toc:[]},t1e="wrapper";function o1e(e){let{components:n,...t}=e;return(0,s.yg)(t1e,(0,p.A)({},n1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}o1e.isMDXComponent=!0;const p1e={toc:[]},r1e="wrapper";function s1e(e){let{components:n,...t}=e;return(0,s.yg)(r1e,(0,p.A)({},p1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}s1e.isMDXComponent=!0;const c1e={toc:[]},a1e="wrapper";function i1e(e){let{components:n,...t}=e;return(0,s.yg)(a1e,(0,p.A)({},c1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}i1e.isMDXComponent=!0;const l1e={toc:[]},u1e="wrapper";function m1e(e){let{components:n,...t}=e;return(0,s.yg)(u1e,(0,p.A)({},l1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}m1e.isMDXComponent=!0;const y1e={toc:[]},d1e="wrapper";function h1e(e){let{components:n,...t}=e;return(0,s.yg)(d1e,(0,p.A)({},y1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}h1e.isMDXComponent=!0;const g1e={toc:[]},f1e="wrapper";function D1e(e){let{components:n,...t}=e;return(0,s.yg)(f1e,(0,p.A)({},g1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}D1e.isMDXComponent=!0;const M1e={toc:[]},X1e="wrapper";function _1e(e){let{components:n,...t}=e;return(0,s.yg)(X1e,(0,p.A)({},M1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_1e.isMDXComponent=!0;const w1e={toc:[]},T1e="wrapper";function C1e(e){let{components:n,...t}=e;return(0,s.yg)(T1e,(0,p.A)({},w1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}C1e.isMDXComponent=!0;const x1e={toc:[]},A1e="wrapper";function v1e(e){let{components:n,...t}=e;return(0,s.yg)(A1e,(0,p.A)({},x1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}v1e.isMDXComponent=!0;const L1e={toc:[]},b1e="wrapper";function N1e(e){let{components:n,...t}=e;return(0,s.yg)(b1e,(0,p.A)({},L1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}N1e.isMDXComponent=!0;const k1e={toc:[]},z1e="wrapper";function P1e(e){let{components:n,...t}=e;return(0,s.yg)(z1e,(0,p.A)({},k1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}P1e.isMDXComponent=!0;const I1e={toc:[]},R1e="wrapper";function W1e(e){let{components:n,...t}=e;return(0,s.yg)(R1e,(0,p.A)({},I1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}W1e.isMDXComponent=!0;const S1e={toc:[]},B1e="wrapper";function G1e(e){let{components:n,...t}=e;return(0,s.yg)(B1e,(0,p.A)({},S1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}G1e.isMDXComponent=!0;const E1e={toc:[]},O1e="wrapper";function U1e(e){let{components:n,...t}=e;return(0,s.yg)(O1e,(0,p.A)({},E1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}U1e.isMDXComponent=!0;const F1e={toc:[]},V1e="wrapper";function q1e(e){let{components:n,...t}=e;return(0,s.yg)(V1e,(0,p.A)({},F1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}q1e.isMDXComponent=!0;const j1e={toc:[]},H1e="wrapper";function Y1e(e){let{components:n,...t}=e;return(0,s.yg)(H1e,(0,p.A)({},j1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Y1e.isMDXComponent=!0;const Q1e={toc:[]},$1e="wrapper";function K1e(e){let{components:n,...t}=e;return(0,s.yg)($1e,(0,p.A)({},Q1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}K1e.isMDXComponent=!0;const J1e={toc:[]},Z1e="wrapper";function e4e(e){let{components:n,...t}=e;return(0,s.yg)(Z1e,(0,p.A)({},J1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}e4e.isMDXComponent=!0;const n4e={toc:[]},t4e="wrapper";function o4e(e){let{components:n,...t}=e;return(0,s.yg)(t4e,(0,p.A)({},n4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}o4e.isMDXComponent=!0;const p4e={toc:[]},r4e="wrapper";function s4e(e){let{components:n,...t}=e;return(0,s.yg)(r4e,(0,p.A)({},p4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}s4e.isMDXComponent=!0;const c4e={toc:[]},a4e="wrapper";function i4e(e){let{components:n,...t}=e;return(0,s.yg)(a4e,(0,p.A)({},c4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}i4e.isMDXComponent=!0;const l4e={toc:[]},u4e="wrapper";function m4e(e){let{components:n,...t}=e;return(0,s.yg)(u4e,(0,p.A)({},l4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}m4e.isMDXComponent=!0;const y4e={toc:[]},d4e="wrapper";function h4e(e){let{components:n,...t}=e;return(0,s.yg)(d4e,(0,p.A)({},y4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}h4e.isMDXComponent=!0;const g4e={toc:[]},f4e="wrapper";function D4e(e){let{components:n,...t}=e;return(0,s.yg)(f4e,(0,p.A)({},g4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}D4e.isMDXComponent=!0;const M4e={toc:[]},X4e="wrapper";function _4e(e){let{components:n,...t}=e;return(0,s.yg)(X4e,(0,p.A)({},M4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}_4e.isMDXComponent=!0;const w4e={toc:[]},T4e="wrapper";function C4e(e){let{components:n,...t}=e;return(0,s.yg)(T4e,(0,p.A)({},w4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}C4e.isMDXComponent=!0;const x4e={toc:[]},A4e="wrapper";function v4e(e){let{components:n,...t}=e;return(0,s.yg)(A4e,(0,p.A)({},x4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}v4e.isMDXComponent=!0;const L4e={toc:[]},b4e="wrapper";function N4e(e){let{components:n,...t}=e;return(0,s.yg)(b4e,(0,p.A)({},L4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}N4e.isMDXComponent=!0;const k4e={toc:[]},z4e="wrapper";function P4e(e){let{components:n,...t}=e;return(0,s.yg)(z4e,(0,p.A)({},k4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}P4e.isMDXComponent=!0;const I4e={toc:[]},R4e="wrapper";function W4e(e){let{components:n,...t}=e;return(0,s.yg)(R4e,(0,p.A)({},I4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}W4e.isMDXComponent=!0;const S4e={toc:[]},B4e="wrapper";function G4e(e){let{components:n,...t}=e;return(0,s.yg)(B4e,(0,p.A)({},S4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}G4e.isMDXComponent=!0;const E4e={toc:[]},O4e="wrapper";function U4e(e){let{components:n,...t}=e;return(0,s.yg)(O4e,(0,p.A)({},E4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}U4e.isMDXComponent=!0;const F4e={toc:[]},V4e="wrapper";function q4e(e){let{components:n,...t}=e;return(0,s.yg)(V4e,(0,p.A)({},F4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}q4e.isMDXComponent=!0;const j4e={toc:[]},H4e="wrapper";function Y4e(e){let{components:n,...t}=e;return(0,s.yg)(H4e,(0,p.A)({},j4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Y4e.isMDXComponent=!0;const Q4e={toc:[]},$4e="wrapper";function K4e(e){let{components:n,...t}=e;return(0,s.yg)($4e,(0,p.A)({},Q4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}K4e.isMDXComponent=!0;const J4e={toc:[]},Z4e="wrapper";function e6e(e){let{components:n,...t}=e;return(0,s.yg)(Z4e,(0,p.A)({},J4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}e6e.isMDXComponent=!0;const n6e={toc:[]},t6e="wrapper";function o6e(e){let{components:n,...t}=e;return(0,s.yg)(t6e,(0,p.A)({},n6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}o6e.isMDXComponent=!0;const p6e={toc:[]},r6e="wrapper";function s6e(e){let{components:n,...t}=e;return(0,s.yg)(r6e,(0,p.A)({},p6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}s6e.isMDXComponent=!0;const c6e={toc:[]},a6e="wrapper";function i6e(e){let{components:n,...t}=e;return(0,s.yg)(a6e,(0,p.A)({},c6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}i6e.isMDXComponent=!0;const l6e={toc:[]},u6e="wrapper";function m6e(e){let{components:n,...t}=e;return(0,s.yg)(u6e,(0,p.A)({},l6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}m6e.isMDXComponent=!0;const y6e={toc:[]},d6e="wrapper";function h6e(e){let{components:n,...t}=e;return(0,s.yg)(d6e,(0,p.A)({},y6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}h6e.isMDXComponent=!0;const g6e={toc:[]},f6e="wrapper";function D6e(e){let{components:n,...t}=e;return(0,s.yg)(f6e,(0,p.A)({},g6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}D6e.isMDXComponent=!0;const M6e={toc:[]},X6e="wrapper";function _6e(e){let{components:n,...t}=e;return(0,s.yg)(X6e,(0,p.A)({},M6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}_6e.isMDXComponent=!0;const w6e={toc:[]},T6e="wrapper";function C6e(e){let{components:n,...t}=e;return(0,s.yg)(T6e,(0,p.A)({},w6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}C6e.isMDXComponent=!0;const x6e={toc:[]},A6e="wrapper";function v6e(e){let{components:n,...t}=e;return(0,s.yg)(A6e,(0,p.A)({},x6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}v6e.isMDXComponent=!0;const L6e={toc:[]},b6e="wrapper";function N6e(e){let{components:n,...t}=e;return(0,s.yg)(b6e,(0,p.A)({},L6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}N6e.isMDXComponent=!0;const k6e={toc:[]},z6e="wrapper";function P6e(e){let{components:n,...t}=e;return(0,s.yg)(z6e,(0,p.A)({},k6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}P6e.isMDXComponent=!0;const I6e={toc:[]},R6e="wrapper";function W6e(e){let{components:n,...t}=e;return(0,s.yg)(R6e,(0,p.A)({},I6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}W6e.isMDXComponent=!0;const S6e={toc:[]},B6e="wrapper";function G6e(e){let{components:n,...t}=e;return(0,s.yg)(B6e,(0,p.A)({},S6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}G6e.isMDXComponent=!0;const E6e={toc:[]},O6e="wrapper";function U6e(e){let{components:n,...t}=e;return(0,s.yg)(O6e,(0,p.A)({},E6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}U6e.isMDXComponent=!0;const F6e={toc:[]},V6e="wrapper";function q6e(e){let{components:n,...t}=e;return(0,s.yg)(V6e,(0,p.A)({},F6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}q6e.isMDXComponent=!0;const j6e={toc:[]},H6e="wrapper";function Y6e(e){let{components:n,...t}=e;return(0,s.yg)(H6e,(0,p.A)({},j6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Y6e.isMDXComponent=!0;const Q6e={toc:[]},$6e="wrapper";function K6e(e){let{components:n,...t}=e;return(0,s.yg)($6e,(0,p.A)({},Q6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}K6e.isMDXComponent=!0;const J6e={toc:[]},Z6e="wrapper";function e5e(e){let{components:n,...t}=e;return(0,s.yg)(Z6e,(0,p.A)({},J6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}e5e.isMDXComponent=!0;const n5e={toc:[]},t5e="wrapper";function o5e(e){let{components:n,...t}=e;return(0,s.yg)(t5e,(0,p.A)({},n5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}o5e.isMDXComponent=!0;const p5e={toc:[]},r5e="wrapper";function s5e(e){let{components:n,...t}=e;return(0,s.yg)(r5e,(0,p.A)({},p5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}s5e.isMDXComponent=!0;const c5e={toc:[]},a5e="wrapper";function i5e(e){let{components:n,...t}=e;return(0,s.yg)(a5e,(0,p.A)({},c5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}i5e.isMDXComponent=!0;const l5e={toc:[]},u5e="wrapper";function m5e(e){let{components:n,...t}=e;return(0,s.yg)(u5e,(0,p.A)({},l5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}m5e.isMDXComponent=!0;const y5e={toc:[]},d5e="wrapper";function h5e(e){let{components:n,...t}=e;return(0,s.yg)(d5e,(0,p.A)({},y5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}h5e.isMDXComponent=!0;const g5e={toc:[]},f5e="wrapper";function D5e(e){let{components:n,...t}=e;return(0,s.yg)(f5e,(0,p.A)({},g5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}D5e.isMDXComponent=!0;const M5e={toc:[]},X5e="wrapper";function _5e(e){let{components:n,...t}=e;return(0,s.yg)(X5e,(0,p.A)({},M5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}_5e.isMDXComponent=!0;const w5e={toc:[]},T5e="wrapper";function C5e(e){let{components:n,...t}=e;return(0,s.yg)(T5e,(0,p.A)({},w5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}C5e.isMDXComponent=!0;const x5e={toc:[]},A5e="wrapper";function v5e(e){let{components:n,...t}=e;return(0,s.yg)(A5e,(0,p.A)({},x5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}v5e.isMDXComponent=!0;const L5e={toc:[]},b5e="wrapper";function N5e(e){let{components:n,...t}=e;return(0,s.yg)(b5e,(0,p.A)({},L5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}N5e.isMDXComponent=!0;const k5e={toc:[]},z5e="wrapper";function P5e(e){let{components:n,...t}=e;return(0,s.yg)(z5e,(0,p.A)({},k5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}P5e.isMDXComponent=!0;const I5e={toc:[]},R5e="wrapper";function W5e(e){let{components:n,...t}=e;return(0,s.yg)(R5e,(0,p.A)({},I5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}W5e.isMDXComponent=!0;const S5e={toc:[]},B5e="wrapper";function G5e(e){let{components:n,...t}=e;return(0,s.yg)(B5e,(0,p.A)({},S5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}G5e.isMDXComponent=!0;const E5e={toc:[]},O5e="wrapper";function U5e(e){let{components:n,...t}=e;return(0,s.yg)(O5e,(0,p.A)({},E5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}U5e.isMDXComponent=!0;const F5e={toc:[]},V5e="wrapper";function q5e(e){let{components:n,...t}=e;return(0,s.yg)(V5e,(0,p.A)({},F5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}q5e.isMDXComponent=!0;const j5e={toc:[]},H5e="wrapper";function Y5e(e){let{components:n,...t}=e;return(0,s.yg)(H5e,(0,p.A)({},j5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Y5e.isMDXComponent=!0;const Q5e={toc:[]},$5e="wrapper";function K5e(e){let{components:n,...t}=e;return(0,s.yg)($5e,(0,p.A)({},Q5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}K5e.isMDXComponent=!0;const J5e={toc:[]},Z5e="wrapper";function e7e(e){let{components:n,...t}=e;return(0,s.yg)(Z5e,(0,p.A)({},J5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}e7e.isMDXComponent=!0;const n7e={toc:[]},t7e="wrapper";function o7e(e){let{components:n,...t}=e;return(0,s.yg)(t7e,(0,p.A)({},n7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}o7e.isMDXComponent=!0;const p7e={toc:[]},r7e="wrapper";function s7e(e){let{components:n,...t}=e;return(0,s.yg)(r7e,(0,p.A)({},p7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}s7e.isMDXComponent=!0;const c7e={toc:[]},a7e="wrapper";function i7e(e){let{components:n,...t}=e;return(0,s.yg)(a7e,(0,p.A)({},c7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}i7e.isMDXComponent=!0;const l7e={toc:[]},u7e="wrapper";function m7e(e){let{components:n,...t}=e;return(0,s.yg)(u7e,(0,p.A)({},l7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}m7e.isMDXComponent=!0;const y7e={toc:[]},d7e="wrapper";function h7e(e){let{components:n,...t}=e;return(0,s.yg)(d7e,(0,p.A)({},y7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}h7e.isMDXComponent=!0;const g7e={toc:[]},f7e="wrapper";function D7e(e){let{components:n,...t}=e;return(0,s.yg)(f7e,(0,p.A)({},g7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}D7e.isMDXComponent=!0;const M7e={toc:[]},X7e="wrapper";function _7e(e){let{components:n,...t}=e;return(0,s.yg)(X7e,(0,p.A)({},M7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}_7e.isMDXComponent=!0;const w7e={toc:[]},T7e="wrapper";function C7e(e){let{components:n,...t}=e;return(0,s.yg)(T7e,(0,p.A)({},w7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}C7e.isMDXComponent=!0;const x7e={toc:[]},A7e="wrapper";function v7e(e){let{components:n,...t}=e;return(0,s.yg)(A7e,(0,p.A)({},x7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}v7e.isMDXComponent=!0;const L7e={toc:[]},b7e="wrapper";function N7e(e){let{components:n,...t}=e;return(0,s.yg)(b7e,(0,p.A)({},L7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}N7e.isMDXComponent=!0;const k7e={toc:[]},z7e="wrapper";function P7e(e){let{components:n,...t}=e;return(0,s.yg)(z7e,(0,p.A)({},k7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}P7e.isMDXComponent=!0;const I7e={toc:[]},R7e="wrapper";function W7e(e){let{components:n,...t}=e;return(0,s.yg)(R7e,(0,p.A)({},I7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}W7e.isMDXComponent=!0;const S7e={toc:[]},B7e="wrapper";function G7e(e){let{components:n,...t}=e;return(0,s.yg)(B7e,(0,p.A)({},S7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}G7e.isMDXComponent=!0;const E7e={toc:[]},O7e="wrapper";function U7e(e){let{components:n,...t}=e;return(0,s.yg)(O7e,(0,p.A)({},E7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}U7e.isMDXComponent=!0;const F7e={toc:[]},V7e="wrapper";function q7e(e){let{components:n,...t}=e;return(0,s.yg)(V7e,(0,p.A)({},F7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}q7e.isMDXComponent=!0;const j7e={toc:[]},H7e="wrapper";function Y7e(e){let{components:n,...t}=e;return(0,s.yg)(H7e,(0,p.A)({},j7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Y7e.isMDXComponent=!0;const Q7e={toc:[]},$7e="wrapper";function K7e(e){let{components:n,...t}=e;return(0,s.yg)($7e,(0,p.A)({},Q7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}K7e.isMDXComponent=!0;const J7e={toc:[]},Z7e="wrapper";function e9e(e){let{components:n,...t}=e;return(0,s.yg)(Z7e,(0,p.A)({},J7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}e9e.isMDXComponent=!0;const n9e={toc:[]},t9e="wrapper";function o9e(e){let{components:n,...t}=e;return(0,s.yg)(t9e,(0,p.A)({},n9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}o9e.isMDXComponent=!0;const p9e={toc:[]},r9e="wrapper";function s9e(e){let{components:n,...t}=e;return(0,s.yg)(r9e,(0,p.A)({},p9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}s9e.isMDXComponent=!0;const c9e={toc:[]},a9e="wrapper";function i9e(e){let{components:n,...t}=e;return(0,s.yg)(a9e,(0,p.A)({},c9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}i9e.isMDXComponent=!0;const l9e={toc:[]},u9e="wrapper";function m9e(e){let{components:n,...t}=e;return(0,s.yg)(u9e,(0,p.A)({},l9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}m9e.isMDXComponent=!0;const y9e={toc:[]},d9e="wrapper";function h9e(e){let{components:n,...t}=e;return(0,s.yg)(d9e,(0,p.A)({},y9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}h9e.isMDXComponent=!0;const g9e={toc:[]},f9e="wrapper";function D9e(e){let{components:n,...t}=e;return(0,s.yg)(f9e,(0,p.A)({},g9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}D9e.isMDXComponent=!0;const M9e={toc:[]},X9e="wrapper";function _9e(e){let{components:n,...t}=e;return(0,s.yg)(X9e,(0,p.A)({},M9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}_9e.isMDXComponent=!0;const w9e={toc:[]},T9e="wrapper";function C9e(e){let{components:n,...t}=e;return(0,s.yg)(T9e,(0,p.A)({},w9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}C9e.isMDXComponent=!0;const x9e={toc:[]},A9e="wrapper";function v9e(e){let{components:n,...t}=e;return(0,s.yg)(A9e,(0,p.A)({},x9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}v9e.isMDXComponent=!0;const L9e={toc:[]},b9e="wrapper";function N9e(e){let{components:n,...t}=e;return(0,s.yg)(b9e,(0,p.A)({},L9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}N9e.isMDXComponent=!0;const k9e={toc:[]},z9e="wrapper";function P9e(e){let{components:n,...t}=e;return(0,s.yg)(z9e,(0,p.A)({},k9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}P9e.isMDXComponent=!0;const I9e={toc:[]},R9e="wrapper";function W9e(e){let{components:n,...t}=e;return(0,s.yg)(R9e,(0,p.A)({},I9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}W9e.isMDXComponent=!0;const S9e={toc:[]},B9e="wrapper";function G9e(e){let{components:n,...t}=e;return(0,s.yg)(B9e,(0,p.A)({},S9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}G9e.isMDXComponent=!0;const E9e={toc:[]},O9e="wrapper";function U9e(e){let{components:n,...t}=e;return(0,s.yg)(O9e,(0,p.A)({},E9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}U9e.isMDXComponent=!0;const F9e={toc:[]},V9e="wrapper";function q9e(e){let{components:n,...t}=e;return(0,s.yg)(V9e,(0,p.A)({},F9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}q9e.isMDXComponent=!0;const j9e={toc:[]},H9e="wrapper";function Y9e(e){let{components:n,...t}=e;return(0,s.yg)(H9e,(0,p.A)({},j9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Y9e.isMDXComponent=!0;const Q9e={toc:[]},$9e="wrapper";function K9e(e){let{components:n,...t}=e;return(0,s.yg)($9e,(0,p.A)({},Q9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}K9e.isMDXComponent=!0;const J9e={toc:[]},Z9e="wrapper";function een(e){let{components:n,...t}=e;return(0,s.yg)(Z9e,(0,p.A)({},J9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}een.isMDXComponent=!0;const nen={toc:[]},ten="wrapper";function oen(e){let{components:n,...t}=e;return(0,s.yg)(ten,(0,p.A)({},nen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}oen.isMDXComponent=!0;const pen={toc:[]},ren="wrapper";function sen(e){let{components:n,...t}=e;return(0,s.yg)(ren,(0,p.A)({},pen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}sen.isMDXComponent=!0;const cen={toc:[]},aen="wrapper";function ien(e){let{components:n,...t}=e;return(0,s.yg)(aen,(0,p.A)({},cen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ien.isMDXComponent=!0;const len={toc:[]},uen="wrapper";function men(e){let{components:n,...t}=e;return(0,s.yg)(uen,(0,p.A)({},len,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}men.isMDXComponent=!0;const yen={toc:[]},den="wrapper";function hen(e){let{components:n,...t}=e;return(0,s.yg)(den,(0,p.A)({},yen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}hen.isMDXComponent=!0;const gen={toc:[]},fen="wrapper";function Den(e){let{components:n,...t}=e;return(0,s.yg)(fen,(0,p.A)({},gen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Den.isMDXComponent=!0;const Men={toc:[]},Xen="wrapper";function _en(e){let{components:n,...t}=e;return(0,s.yg)(Xen,(0,p.A)({},Men,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}_en.isMDXComponent=!0;const wen={toc:[]},Ten="wrapper";function Cen(e){let{components:n,...t}=e;return(0,s.yg)(Ten,(0,p.A)({},wen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Cen.isMDXComponent=!0;const xen={toc:[]},Aen="wrapper";function ven(e){let{components:n,...t}=e;return(0,s.yg)(Aen,(0,p.A)({},xen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}ven.isMDXComponent=!0;const Len={toc:[]},ben="wrapper";function Nen(e){let{components:n,...t}=e;return(0,s.yg)(ben,(0,p.A)({},Len,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@revideo/2d';\nimport {all, createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}Nen.isMDXComponent=!0;const ken={toc:[]},zen="wrapper";function Pen(e){let{components:n,...t}=e;return(0,s.yg)(zen,(0,p.A)({},ken,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a two-dimensional grid."))}Pen.isMDXComponent=!0;const Ien={toc:[]},Ren="wrapper";function Wen(e){let{components:n,...t}=e;return(0,s.yg)(Ren,(0,p.A)({},Ien,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Wen.isMDXComponent=!0;const Sen={toc:[]},Ben="wrapper";function Gen(e){let{components:n,...t}=e;return(0,s.yg)(Ben,(0,p.A)({},Sen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Gen.isMDXComponent=!0;const Een={toc:[]},Oen="wrapper";function Uen(e){let{components:n,...t}=e;return(0,s.yg)(Oen,(0,p.A)({},Een,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Uen.isMDXComponent=!0;const Fen={toc:[]},Ven="wrapper";function qen(e){let{components:n,...t}=e;return(0,s.yg)(Ven,(0,p.A)({},Fen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}qen.isMDXComponent=!0;const jen={toc:[]},Hen="wrapper";function Yen(e){let{components:n,...t}=e;return(0,s.yg)(Hen,(0,p.A)({},jen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Yen.isMDXComponent=!0;const Qen={toc:[]},$en="wrapper";function Ken(e){let{components:n,...t}=e;return(0,s.yg)($en,(0,p.A)({},Qen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Ken.isMDXComponent=!0;const Jen={toc:[]},Zen="wrapper";function enn(e){let{components:n,...t}=e;return(0,s.yg)(Zen,(0,p.A)({},Jen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}enn.isMDXComponent=!0;const nnn={toc:[]},tnn="wrapper";function onn(e){let{components:n,...t}=e;return(0,s.yg)(tnn,(0,p.A)({},nnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}onn.isMDXComponent=!0;const pnn={toc:[]},rnn="wrapper";function snn(e){let{components:n,...t}=e;return(0,s.yg)(rnn,(0,p.A)({},pnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}snn.isMDXComponent=!0;const cnn={toc:[]},ann="wrapper";function inn(e){let{components:n,...t}=e;return(0,s.yg)(ann,(0,p.A)({},cnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}inn.isMDXComponent=!0;const lnn={toc:[]},unn="wrapper";function mnn(e){let{components:n,...t}=e;return(0,s.yg)(unn,(0,p.A)({},lnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}mnn.isMDXComponent=!0;const ynn={toc:[]},dnn="wrapper";function hnn(e){let{components:n,...t}=e;return(0,s.yg)(dnn,(0,p.A)({},ynn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}hnn.isMDXComponent=!0;const gnn={toc:[]},fnn="wrapper";function Dnn(e){let{components:n,...t}=e;return(0,s.yg)(fnn,(0,p.A)({},gnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Dnn.isMDXComponent=!0;const Mnn={toc:[]},Xnn="wrapper";function _nn(e){let{components:n,...t}=e;return(0,s.yg)(Xnn,(0,p.A)({},Mnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}_nn.isMDXComponent=!0;const wnn={toc:[]},Tnn="wrapper";function Cnn(e){let{components:n,...t}=e;return(0,s.yg)(Tnn,(0,p.A)({},wnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}Cnn.isMDXComponent=!0;const xnn={toc:[]},Ann="wrapper";function vnn(e){let{components:n,...t}=e;return(0,s.yg)(Ann,(0,p.A)({},xnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the end of each grid line."))}vnn.isMDXComponent=!0;const Lnn={toc:[]},bnn="wrapper";function Nnn(e){let{components:n,...t}=e;return(0,s.yg)(bnn,(0,p.A)({},Lnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Nnn.isMDXComponent=!0;const knn={toc:[]},znn="wrapper";function Pnn(e){let{components:n,...t}=e;return(0,s.yg)(znn,(0,p.A)({},knn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Pnn.isMDXComponent=!0;const Inn={toc:[]},Rnn="wrapper";function Wnn(e){let{components:n,...t}=e;return(0,s.yg)(Rnn,(0,p.A)({},Inn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Wnn.isMDXComponent=!0;const Snn={toc:[]},Bnn="wrapper";function Gnn(e){let{components:n,...t}=e;return(0,s.yg)(Bnn,(0,p.A)({},Snn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Gnn.isMDXComponent=!0;const Enn={toc:[]},Onn="wrapper";function Unn(e){let{components:n,...t}=e;return(0,s.yg)(Onn,(0,p.A)({},Enn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Unn.isMDXComponent=!0;const Fnn={toc:[]},Vnn="wrapper";function qnn(e){let{components:n,...t}=e;return(0,s.yg)(Vnn,(0,p.A)({},Fnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}qnn.isMDXComponent=!0;const jnn={toc:[]},Hnn="wrapper";function Ynn(e){let{components:n,...t}=e;return(0,s.yg)(Hnn,(0,p.A)({},jnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Ynn.isMDXComponent=!0;const Qnn={toc:[]},$nn="wrapper";function Knn(e){let{components:n,...t}=e;return(0,s.yg)($nn,(0,p.A)({},Qnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Knn.isMDXComponent=!0;const Jnn={toc:[]},Znn="wrapper";function etn(e){let{components:n,...t}=e;return(0,s.yg)(Znn,(0,p.A)({},Jnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}etn.isMDXComponent=!0;const ntn={toc:[]},ttn="wrapper";function otn(e){let{components:n,...t}=e;return(0,s.yg)(ttn,(0,p.A)({},ntn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}otn.isMDXComponent=!0;const ptn={toc:[]},rtn="wrapper";function stn(e){let{components:n,...t}=e;return(0,s.yg)(rtn,(0,p.A)({},ptn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}stn.isMDXComponent=!0;const ctn={toc:[]},atn="wrapper";function itn(e){let{components:n,...t}=e;return(0,s.yg)(atn,(0,p.A)({},ctn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}itn.isMDXComponent=!0;const ltn={toc:[]},utn="wrapper";function mtn(e){let{components:n,...t}=e;return(0,s.yg)(utn,(0,p.A)({},ltn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mtn.isMDXComponent=!0;const ytn={toc:[]},dtn="wrapper";function htn(e){let{components:n,...t}=e;return(0,s.yg)(dtn,(0,p.A)({},ytn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}htn.isMDXComponent=!0;const gtn={toc:[]},ftn="wrapper";function Dtn(e){let{components:n,...t}=e;return(0,s.yg)(ftn,(0,p.A)({},gtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Dtn.isMDXComponent=!0;const Mtn={toc:[]},Xtn="wrapper";function _tn(e){let{components:n,...t}=e;return(0,s.yg)(Xtn,(0,p.A)({},Mtn,t,{components:n,mdxType:"MDXLayout"}))}_tn.isMDXComponent=!0;const wtn={toc:[]},Ttn="wrapper";function Ctn(e){let{components:n,...t}=e;return(0,s.yg)(Ttn,(0,p.A)({},wtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ctn.isMDXComponent=!0;const xtn={toc:[]},Atn="wrapper";function vtn(e){let{components:n,...t}=e;return(0,s.yg)(Atn,(0,p.A)({},xtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}vtn.isMDXComponent=!0;const Ltn={toc:[]},btn="wrapper";function Ntn(e){let{components:n,...t}=e;return(0,s.yg)(btn,(0,p.A)({},Ltn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Ntn.isMDXComponent=!0;const ktn={toc:[]},ztn="wrapper";function Ptn(e){let{components:n,...t}=e;return(0,s.yg)(ztn,(0,p.A)({},ktn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Ptn.isMDXComponent=!0;const Itn={toc:[]},Rtn="wrapper";function Wtn(e){let{components:n,...t}=e;return(0,s.yg)(Rtn,(0,p.A)({},Itn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Wtn.isMDXComponent=!0;const Stn={toc:[]},Btn="wrapper";function Gtn(e){let{components:n,...t}=e;return(0,s.yg)(Btn,(0,p.A)({},Stn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The spacing between the grid lines."))}Gtn.isMDXComponent=!0;const Etn={toc:[]},Otn="wrapper";function Utn(e){let{components:n,...t}=e;return(0,s.yg)(Otn,(0,p.A)({},Etn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Utn.isMDXComponent=!0;const Ftn={toc:[]},Vtn="wrapper";function qtn(e){let{components:n,...t}=e;return(0,s.yg)(Vtn,(0,p.A)({},Ftn,t,{components:n,mdxType:"MDXLayout"}))}qtn.isMDXComponent=!0;const jtn={toc:[]},Htn="wrapper";function Ytn(e){let{components:n,...t}=e;return(0,s.yg)(Htn,(0,p.A)({},jtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}Ytn.isMDXComponent=!0;const Qtn={toc:[]},$tn="wrapper";function Ktn(e){let{components:n,...t}=e;return(0,s.yg)($tn,(0,p.A)({},Qtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]},Ztn="wrapper";function eon(e){let{components:n,...t}=e;return(0,s.yg)(Ztn,(0,p.A)({},Jtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}eon.isMDXComponent=!0;const non={toc:[]},ton="wrapper";function oon(e){let{components:n,...t}=e;return(0,s.yg)(ton,(0,p.A)({},non,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}oon.isMDXComponent=!0;const pon={toc:[]},ron="wrapper";function son(e){let{components:n,...t}=e;return(0,s.yg)(ron,(0,p.A)({},pon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}son.isMDXComponent=!0;const con={toc:[]},aon="wrapper";function ion(e){let{components:n,...t}=e;return(0,s.yg)(aon,(0,p.A)({},con,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}ion.isMDXComponent=!0;const lon={toc:[]},uon="wrapper";function mon(e){let{components:n,...t}=e;return(0,s.yg)(uon,(0,p.A)({},lon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}mon.isMDXComponent=!0;const yon={toc:[]},don="wrapper";function hon(e){let{components:n,...t}=e;return(0,s.yg)(don,(0,p.A)({},yon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}hon.isMDXComponent=!0;const gon={toc:[]},fon="wrapper";function Don(e){let{components:n,...t}=e;return(0,s.yg)(fon,(0,p.A)({},gon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Don.isMDXComponent=!0;const Mon={toc:[]},Xon="wrapper";function _on(e){let{components:n,...t}=e;return(0,s.yg)(Xon,(0,p.A)({},Mon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}_on.isMDXComponent=!0;const won={toc:[]},Ton="wrapper";function Con(e){let{components:n,...t}=e;return(0,s.yg)(Ton,(0,p.A)({},won,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Con.isMDXComponent=!0;const xon={toc:[]},Aon="wrapper";function von(e){let{components:n,...t}=e;return(0,s.yg)(Aon,(0,p.A)({},xon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}von.isMDXComponent=!0;const Lon={toc:[]},bon="wrapper";function Non(e){let{components:n,...t}=e;return(0,s.yg)(bon,(0,p.A)({},Lon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Non.isMDXComponent=!0;const kon={toc:[]},zon="wrapper";function Pon(e){let{components:n,...t}=e;return(0,s.yg)(zon,(0,p.A)({},kon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Pon.isMDXComponent=!0;const Ion={toc:[]},Ron="wrapper";function Won(e){let{components:n,...t}=e;return(0,s.yg)(Ron,(0,p.A)({},Ion,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Won.isMDXComponent=!0;const Son={toc:[]},Bon="wrapper";function Gon(e){let{components:n,...t}=e;return(0,s.yg)(Bon,(0,p.A)({},Son,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Gon.isMDXComponent=!0;const Eon={toc:[]},Oon="wrapper";function Uon(e){let{components:n,...t}=e;return(0,s.yg)(Oon,(0,p.A)({},Eon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Uon.isMDXComponent=!0;const Fon={toc:[]},Von="wrapper";function qon(e){let{components:n,...t}=e;return(0,s.yg)(Von,(0,p.A)({},Fon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}qon.isMDXComponent=!0;const jon={toc:[]},Hon="wrapper";function Yon(e){let{components:n,...t}=e;return(0,s.yg)(Hon,(0,p.A)({},jon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Yon.isMDXComponent=!0;const Qon={toc:[]},$on="wrapper";function Kon(e){let{components:n,...t}=e;return(0,s.yg)($on,(0,p.A)({},Qon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Kon.isMDXComponent=!0;const Jon={toc:[]},Zon="wrapper";function epn(e){let{components:n,...t}=e;return(0,s.yg)(Zon,(0,p.A)({},Jon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}epn.isMDXComponent=!0;const npn={toc:[]},tpn="wrapper";function opn(e){let{components:n,...t}=e;return(0,s.yg)(tpn,(0,p.A)({},npn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}opn.isMDXComponent=!0;const ppn={toc:[]},rpn="wrapper";function spn(e){let{components:n,...t}=e;return(0,s.yg)(rpn,(0,p.A)({},ppn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}spn.isMDXComponent=!0;const cpn={toc:[]},apn="wrapper";function ipn(e){let{components:n,...t}=e;return(0,s.yg)(apn,(0,p.A)({},cpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}ipn.isMDXComponent=!0;const lpn={toc:[]},upn="wrapper";function mpn(e){let{components:n,...t}=e;return(0,s.yg)(upn,(0,p.A)({},lpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}mpn.isMDXComponent=!0;const ypn={toc:[]},dpn="wrapper";function hpn(e){let{components:n,...t}=e;return(0,s.yg)(dpn,(0,p.A)({},ypn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}hpn.isMDXComponent=!0;const gpn={toc:[]},fpn="wrapper";function Dpn(e){let{components:n,...t}=e;return(0,s.yg)(fpn,(0,p.A)({},gpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Dpn.isMDXComponent=!0;const Mpn={toc:[]},Xpn="wrapper";function _pn(e){let{components:n,...t}=e;return(0,s.yg)(Xpn,(0,p.A)({},Mpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}_pn.isMDXComponent=!0;const wpn={toc:[]},Tpn="wrapper";function Cpn(e){let{components:n,...t}=e;return(0,s.yg)(Tpn,(0,p.A)({},wpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Cpn.isMDXComponent=!0;const xpn={toc:[]},Apn="wrapper";function vpn(e){let{components:n,...t}=e;return(0,s.yg)(Apn,(0,p.A)({},xpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}vpn.isMDXComponent=!0;const Lpn={toc:[]},bpn="wrapper";function Npn(e){let{components:n,...t}=e;return(0,s.yg)(bpn,(0,p.A)({},Lpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Npn.isMDXComponent=!0;const kpn={toc:[]},zpn="wrapper";function Ppn(e){let{components:n,...t}=e;return(0,s.yg)(zpn,(0,p.A)({},kpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Ppn.isMDXComponent=!0;const Ipn={toc:[]},Rpn="wrapper";function Wpn(e){let{components:n,...t}=e;return(0,s.yg)(Rpn,(0,p.A)({},Ipn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Wpn.isMDXComponent=!0;const Spn={toc:[]},Bpn="wrapper";function Gpn(e){let{components:n,...t}=e;return(0,s.yg)(Bpn,(0,p.A)({},Spn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Gpn.isMDXComponent=!0;const Epn={toc:[]},Opn="wrapper";function Upn(e){let{components:n,...t}=e;return(0,s.yg)(Opn,(0,p.A)({},Epn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Upn.isMDXComponent=!0;const Fpn={toc:[]},Vpn="wrapper";function qpn(e){let{components:n,...t}=e;return(0,s.yg)(Vpn,(0,p.A)({},Fpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qpn.isMDXComponent=!0;const jpn={toc:[]},Hpn="wrapper";function Ypn(e){let{components:n,...t}=e;return(0,s.yg)(Hpn,(0,p.A)({},jpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Ypn.isMDXComponent=!0;const Qpn={toc:[]},$pn="wrapper";function Kpn(e){let{components:n,...t}=e;return(0,s.yg)($pn,(0,p.A)({},Qpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]},Zpn="wrapper";function ern(e){let{components:n,...t}=e;return(0,s.yg)(Zpn,(0,p.A)({},Jpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}ern.isMDXComponent=!0;const nrn={toc:[]},trn="wrapper";function orn(e){let{components:n,...t}=e;return(0,s.yg)(trn,(0,p.A)({},nrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}orn.isMDXComponent=!0;const prn={toc:[]},rrn="wrapper";function srn(e){let{components:n,...t}=e;return(0,s.yg)(rrn,(0,p.A)({},prn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}srn.isMDXComponent=!0;const crn={toc:[]},arn="wrapper";function irn(e){let{components:n,...t}=e;return(0,s.yg)(arn,(0,p.A)({},crn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}irn.isMDXComponent=!0;const lrn={toc:[]},urn="wrapper";function mrn(e){let{components:n,...t}=e;return(0,s.yg)(urn,(0,p.A)({},lrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mrn.isMDXComponent=!0;const yrn={toc:[]},drn="wrapper";function hrn(e){let{components:n,...t}=e;return(0,s.yg)(drn,(0,p.A)({},yrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}hrn.isMDXComponent=!0;const grn={toc:[]},frn="wrapper";function Drn(e){let{components:n,...t}=e;return(0,s.yg)(frn,(0,p.A)({},grn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Drn.isMDXComponent=!0;const Mrn={toc:[]},Xrn="wrapper";function _rn(e){let{components:n,...t}=e;return(0,s.yg)(Xrn,(0,p.A)({},Mrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}_rn.isMDXComponent=!0;const wrn={toc:[]},Trn="wrapper";function Crn(e){let{components:n,...t}=e;return(0,s.yg)(Trn,(0,p.A)({},wrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Crn.isMDXComponent=!0;const xrn={toc:[]},Arn="wrapper";function vrn(e){let{components:n,...t}=e;return(0,s.yg)(Arn,(0,p.A)({},xrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}vrn.isMDXComponent=!0;const Lrn={toc:[]},brn="wrapper";function Nrn(e){let{components:n,...t}=e;return(0,s.yg)(brn,(0,p.A)({},Lrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Nrn.isMDXComponent=!0;const krn={toc:[]},zrn="wrapper";function Prn(e){let{components:n,...t}=e;return(0,s.yg)(zrn,(0,p.A)({},krn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Prn.isMDXComponent=!0;const Irn={toc:[]},Rrn="wrapper";function Wrn(e){let{components:n,...t}=e;return(0,s.yg)(Rrn,(0,p.A)({},Irn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Wrn.isMDXComponent=!0;const Srn={toc:[]},Brn="wrapper";function Grn(e){let{components:n,...t}=e;return(0,s.yg)(Brn,(0,p.A)({},Srn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Grn.isMDXComponent=!0;const Ern={toc:[]},Orn="wrapper";function Urn(e){let{components:n,...t}=e;return(0,s.yg)(Orn,(0,p.A)({},Ern,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Urn.isMDXComponent=!0;const Frn={toc:[]},Vrn="wrapper";function qrn(e){let{components:n,...t}=e;return(0,s.yg)(Vrn,(0,p.A)({},Frn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}qrn.isMDXComponent=!0;const jrn={toc:[]},Hrn="wrapper";function Yrn(e){let{components:n,...t}=e;return(0,s.yg)(Hrn,(0,p.A)({},jrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Yrn.isMDXComponent=!0;const Qrn={toc:[]},$rn="wrapper";function Krn(e){let{components:n,...t}=e;return(0,s.yg)($rn,(0,p.A)({},Qrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Krn.isMDXComponent=!0;const Jrn={toc:[]},Zrn="wrapper";function esn(e){let{components:n,...t}=e;return(0,s.yg)(Zrn,(0,p.A)({},Jrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}esn.isMDXComponent=!0;const nsn={toc:[]},tsn="wrapper";function osn(e){let{components:n,...t}=e;return(0,s.yg)(tsn,(0,p.A)({},nsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}osn.isMDXComponent=!0;const psn={toc:[]},rsn="wrapper";function ssn(e){let{components:n,...t}=e;return(0,s.yg)(rsn,(0,p.A)({},psn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}ssn.isMDXComponent=!0;const csn={toc:[]},asn="wrapper";function isn(e){let{components:n,...t}=e;return(0,s.yg)(asn,(0,p.A)({},csn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}isn.isMDXComponent=!0;const lsn={toc:[]},usn="wrapper";function msn(e){let{components:n,...t}=e;return(0,s.yg)(usn,(0,p.A)({},lsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}msn.isMDXComponent=!0;const ysn={toc:[]},dsn="wrapper";function hsn(e){let{components:n,...t}=e;return(0,s.yg)(dsn,(0,p.A)({},ysn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}hsn.isMDXComponent=!0;const gsn={toc:[]},fsn="wrapper";function Dsn(e){let{components:n,...t}=e;return(0,s.yg)(fsn,(0,p.A)({},gsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Dsn.isMDXComponent=!0;const Msn={toc:[]},Xsn="wrapper";function _sn(e){let{components:n,...t}=e;return(0,s.yg)(Xsn,(0,p.A)({},Msn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_sn.isMDXComponent=!0;const wsn={toc:[]},Tsn="wrapper";function Csn(e){let{components:n,...t}=e;return(0,s.yg)(Tsn,(0,p.A)({},wsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Csn.isMDXComponent=!0;const xsn={toc:[]},Asn="wrapper";function vsn(e){let{components:n,...t}=e;return(0,s.yg)(Asn,(0,p.A)({},xsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}vsn.isMDXComponent=!0;const Lsn={toc:[]},bsn="wrapper";function Nsn(e){let{components:n,...t}=e;return(0,s.yg)(bsn,(0,p.A)({},Lsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Nsn.isMDXComponent=!0;const ksn={toc:[]},zsn="wrapper";function Psn(e){let{components:n,...t}=e;return(0,s.yg)(zsn,(0,p.A)({},ksn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Psn.isMDXComponent=!0;const Isn={toc:[]},Rsn="wrapper";function Wsn(e){let{components:n,...t}=e;return(0,s.yg)(Rsn,(0,p.A)({},Isn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Wsn.isMDXComponent=!0;const Ssn={toc:[]},Bsn="wrapper";function Gsn(e){let{components:n,...t}=e;return(0,s.yg)(Bsn,(0,p.A)({},Ssn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Gsn.isMDXComponent=!0;const Esn={toc:[]},Osn="wrapper";function Usn(e){let{components:n,...t}=e;return(0,s.yg)(Osn,(0,p.A)({},Esn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Usn.isMDXComponent=!0;const Fsn={toc:[]},Vsn="wrapper";function qsn(e){let{components:n,...t}=e;return(0,s.yg)(Vsn,(0,p.A)({},Fsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qsn.isMDXComponent=!0;const jsn={toc:[]},Hsn="wrapper";function Ysn(e){let{components:n,...t}=e;return(0,s.yg)(Hsn,(0,p.A)({},jsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Ysn.isMDXComponent=!0;const Qsn={toc:[]},$sn="wrapper";function Ksn(e){let{components:n,...t}=e;return(0,s.yg)($sn,(0,p.A)({},Qsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Ksn.isMDXComponent=!0;const Jsn={toc:[]},Zsn="wrapper";function ecn(e){let{components:n,...t}=e;return(0,s.yg)(Zsn,(0,p.A)({},Jsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ecn.isMDXComponent=!0;const ncn={toc:[]},tcn="wrapper";function ocn(e){let{components:n,...t}=e;return(0,s.yg)(tcn,(0,p.A)({},ncn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}ocn.isMDXComponent=!0;const pcn={toc:[]},rcn="wrapper";function scn(e){let{components:n,...t}=e;return(0,s.yg)(rcn,(0,p.A)({},pcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}scn.isMDXComponent=!0;const ccn={toc:[]},acn="wrapper";function icn(e){let{components:n,...t}=e;return(0,s.yg)(acn,(0,p.A)({},ccn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}icn.isMDXComponent=!0;const lcn={toc:[]},ucn="wrapper";function mcn(e){let{components:n,...t}=e;return(0,s.yg)(ucn,(0,p.A)({},lcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}mcn.isMDXComponent=!0;const ycn={toc:[]},dcn="wrapper";function hcn(e){let{components:n,...t}=e;return(0,s.yg)(dcn,(0,p.A)({},ycn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}hcn.isMDXComponent=!0;const gcn={toc:[]},fcn="wrapper";function Dcn(e){let{components:n,...t}=e;return(0,s.yg)(fcn,(0,p.A)({},gcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Dcn.isMDXComponent=!0;const Mcn={toc:[]},Xcn="wrapper";function _cn(e){let{components:n,...t}=e;return(0,s.yg)(Xcn,(0,p.A)({},Mcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}_cn.isMDXComponent=!0;const wcn={toc:[]},Tcn="wrapper";function Ccn(e){let{components:n,...t}=e;return(0,s.yg)(Tcn,(0,p.A)({},wcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Ccn.isMDXComponent=!0;const xcn={toc:[]},Acn="wrapper";function vcn(e){let{components:n,...t}=e;return(0,s.yg)(Acn,(0,p.A)({},xcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vcn.isMDXComponent=!0;const Lcn={toc:[]},bcn="wrapper";function Ncn(e){let{components:n,...t}=e;return(0,s.yg)(bcn,(0,p.A)({},Lcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Ncn.isMDXComponent=!0;const kcn={toc:[]},zcn="wrapper";function Pcn(e){let{components:n,...t}=e;return(0,s.yg)(zcn,(0,p.A)({},kcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Pcn.isMDXComponent=!0;const Icn={toc:[]},Rcn="wrapper";function Wcn(e){let{components:n,...t}=e;return(0,s.yg)(Rcn,(0,p.A)({},Icn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Wcn.isMDXComponent=!0;const Scn={toc:[]},Bcn="wrapper";function Gcn(e){let{components:n,...t}=e;return(0,s.yg)(Bcn,(0,p.A)({},Scn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Gcn.isMDXComponent=!0;const Ecn={toc:[]},Ocn="wrapper";function Ucn(e){let{components:n,...t}=e;return(0,s.yg)(Ocn,(0,p.A)({},Ecn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Ucn.isMDXComponent=!0;const Fcn={toc:[]},Vcn="wrapper";function qcn(e){let{components:n,...t}=e;return(0,s.yg)(Vcn,(0,p.A)({},Fcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qcn.isMDXComponent=!0;const jcn={toc:[]},Hcn="wrapper";function Ycn(e){let{components:n,...t}=e;return(0,s.yg)(Hcn,(0,p.A)({},jcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Ycn.isMDXComponent=!0;const Qcn={toc:[]},$cn="wrapper";function Kcn(e){let{components:n,...t}=e;return(0,s.yg)($cn,(0,p.A)({},Qcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Kcn.isMDXComponent=!0;const Jcn={toc:[]},Zcn="wrapper";function ean(e){let{components:n,...t}=e;return(0,s.yg)(Zcn,(0,p.A)({},Jcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}ean.isMDXComponent=!0;const nan={toc:[]},tan="wrapper";function oan(e){let{components:n,...t}=e;return(0,s.yg)(tan,(0,p.A)({},nan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}oan.isMDXComponent=!0;const pan={toc:[]},ran="wrapper";function san(e){let{components:n,...t}=e;return(0,s.yg)(ran,(0,p.A)({},pan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}san.isMDXComponent=!0;const can={toc:[]},aan="wrapper";function ian(e){let{components:n,...t}=e;return(0,s.yg)(aan,(0,p.A)({},can,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}ian.isMDXComponent=!0;const lan={toc:[]},uan="wrapper";function man(e){let{components:n,...t}=e;return(0,s.yg)(uan,(0,p.A)({},lan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}man.isMDXComponent=!0;const yan={toc:[]},dan="wrapper";function han(e){let{components:n,...t}=e;return(0,s.yg)(dan,(0,p.A)({},yan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}han.isMDXComponent=!0;const gan={toc:[]},fan="wrapper";function Dan(e){let{components:n,...t}=e;return(0,s.yg)(fan,(0,p.A)({},gan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Dan.isMDXComponent=!0;const Man={toc:[]},Xan="wrapper";function _an(e){let{components:n,...t}=e;return(0,s.yg)(Xan,(0,p.A)({},Man,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}_an.isMDXComponent=!0;const wan={toc:[]},Tan="wrapper";function Can(e){let{components:n,...t}=e;return(0,s.yg)(Tan,(0,p.A)({},wan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Can.isMDXComponent=!0;const xan={toc:[]},Aan="wrapper";function van(e){let{components:n,...t}=e;return(0,s.yg)(Aan,(0,p.A)({},xan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}van.isMDXComponent=!0;const Lan={toc:[]},ban="wrapper";function Nan(e){let{components:n,...t}=e;return(0,s.yg)(ban,(0,p.A)({},Lan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Nan.isMDXComponent=!0;const kan={toc:[]},zan="wrapper";function Pan(e){let{components:n,...t}=e;return(0,s.yg)(zan,(0,p.A)({},kan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Pan.isMDXComponent=!0;const Ian={toc:[]},Ran="wrapper";function Wan(e){let{components:n,...t}=e;return(0,s.yg)(Ran,(0,p.A)({},Ian,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Wan.isMDXComponent=!0;const San={toc:[]},Ban="wrapper";function Gan(e){let{components:n,...t}=e;return(0,s.yg)(Ban,(0,p.A)({},San,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Gan.isMDXComponent=!0;const Ean={toc:[]},Oan="wrapper";function Uan(e){let{components:n,...t}=e;return(0,s.yg)(Oan,(0,p.A)({},Ean,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Uan.isMDXComponent=!0;const Fan={toc:[]},Van="wrapper";function qan(e){let{components:n,...t}=e;return(0,s.yg)(Van,(0,p.A)({},Fan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}qan.isMDXComponent=!0;const jan={toc:[]},Han="wrapper";function Yan(e){let{components:n,...t}=e;return(0,s.yg)(Han,(0,p.A)({},jan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Yan.isMDXComponent=!0;const Qan={toc:[]},$an="wrapper";function Kan(e){let{components:n,...t}=e;return(0,s.yg)($an,(0,p.A)({},Qan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Kan.isMDXComponent=!0;const Jan={toc:[]},Zan="wrapper";function ein(e){let{components:n,...t}=e;return(0,s.yg)(Zan,(0,p.A)({},Jan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}ein.isMDXComponent=!0;const nin={toc:[]},tin="wrapper";function oin(e){let{components:n,...t}=e;return(0,s.yg)(tin,(0,p.A)({},nin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}oin.isMDXComponent=!0;const pin={toc:[]},rin="wrapper";function sin(e){let{components:n,...t}=e;return(0,s.yg)(rin,(0,p.A)({},pin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}sin.isMDXComponent=!0;const cin={toc:[]},ain="wrapper";function iin(e){let{components:n,...t}=e;return(0,s.yg)(ain,(0,p.A)({},cin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}iin.isMDXComponent=!0;const lin={toc:[]},uin="wrapper";function min(e){let{components:n,...t}=e;return(0,s.yg)(uin,(0,p.A)({},lin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}min.isMDXComponent=!0;const yin={toc:[]},din="wrapper";function hin(e){let{components:n,...t}=e;return(0,s.yg)(din,(0,p.A)({},yin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}hin.isMDXComponent=!0;const gin={toc:[]},fin="wrapper";function Din(e){let{components:n,...t}=e;return(0,s.yg)(fin,(0,p.A)({},gin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Din.isMDXComponent=!0;const Min={toc:[]},Xin="wrapper";function _in(e){let{components:n,...t}=e;return(0,s.yg)(Xin,(0,p.A)({},Min,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}_in.isMDXComponent=!0;const win={toc:[]},Tin="wrapper";function Cin(e){let{components:n,...t}=e;return(0,s.yg)(Tin,(0,p.A)({},win,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Cin.isMDXComponent=!0;const xin={toc:[]},Ain="wrapper";function vin(e){let{components:n,...t}=e;return(0,s.yg)(Ain,(0,p.A)({},xin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}vin.isMDXComponent=!0;const Lin={toc:[]},bin="wrapper";function Nin(e){let{components:n,...t}=e;return(0,s.yg)(bin,(0,p.A)({},Lin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Nin.isMDXComponent=!0;const kin={toc:[]},zin="wrapper";function Pin(e){let{components:n,...t}=e;return(0,s.yg)(zin,(0,p.A)({},kin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Pin.isMDXComponent=!0;const Iin={toc:[]},Rin="wrapper";function Win(e){let{components:n,...t}=e;return(0,s.yg)(Rin,(0,p.A)({},Iin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Win.isMDXComponent=!0;const Sin={toc:[]},Bin="wrapper";function Gin(e){let{components:n,...t}=e;return(0,s.yg)(Bin,(0,p.A)({},Sin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Gin.isMDXComponent=!0;const Ein={toc:[]},Oin="wrapper";function Uin(e){let{components:n,...t}=e;return(0,s.yg)(Oin,(0,p.A)({},Ein,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Uin.isMDXComponent=!0;const Fin={toc:[]},Vin="wrapper";function qin(e){let{components:n,...t}=e;return(0,s.yg)(Vin,(0,p.A)({},Fin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}qin.isMDXComponent=!0;const jin={toc:[]},Hin="wrapper";function Yin(e){let{components:n,...t}=e;return(0,s.yg)(Hin,(0,p.A)({},jin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Yin.isMDXComponent=!0;const Qin={toc:[]},$in="wrapper";function Kin(e){let{components:n,...t}=e;return(0,s.yg)($in,(0,p.A)({},Qin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Kin.isMDXComponent=!0;const Jin={toc:[]},Zin="wrapper";function eln(e){let{components:n,...t}=e;return(0,s.yg)(Zin,(0,p.A)({},Jin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eln.isMDXComponent=!0;const nln={toc:[]},tln="wrapper";function oln(e){let{components:n,...t}=e;return(0,s.yg)(tln,(0,p.A)({},nln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}oln.isMDXComponent=!0;const pln={toc:[]},rln="wrapper";function sln(e){let{components:n,...t}=e;return(0,s.yg)(rln,(0,p.A)({},pln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}sln.isMDXComponent=!0;const cln={toc:[]},aln="wrapper";function iln(e){let{components:n,...t}=e;return(0,s.yg)(aln,(0,p.A)({},cln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}iln.isMDXComponent=!0;const lln={toc:[]},uln="wrapper";function mln(e){let{components:n,...t}=e;return(0,s.yg)(uln,(0,p.A)({},lln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mln.isMDXComponent=!0;const yln={toc:[]},dln="wrapper";function hln(e){let{components:n,...t}=e;return(0,s.yg)(dln,(0,p.A)({},yln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}hln.isMDXComponent=!0;const gln={toc:[]},fln="wrapper";function Dln(e){let{components:n,...t}=e;return(0,s.yg)(fln,(0,p.A)({},gln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Dln.isMDXComponent=!0;const Mln={toc:[]},Xln="wrapper";function _ln(e){let{components:n,...t}=e;return(0,s.yg)(Xln,(0,p.A)({},Mln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_ln.isMDXComponent=!0;const wln={toc:[]},Tln="wrapper";function Cln(e){let{components:n,...t}=e;return(0,s.yg)(Tln,(0,p.A)({},wln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Cln.isMDXComponent=!0;const xln={toc:[]},Aln="wrapper";function vln(e){let{components:n,...t}=e;return(0,s.yg)(Aln,(0,p.A)({},xln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}vln.isMDXComponent=!0;const Lln={toc:[]},bln="wrapper";function Nln(e){let{components:n,...t}=e;return(0,s.yg)(bln,(0,p.A)({},Lln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Nln.isMDXComponent=!0;const kln={toc:[]},zln="wrapper";function Pln(e){let{components:n,...t}=e;return(0,s.yg)(zln,(0,p.A)({},kln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Pln.isMDXComponent=!0;const Iln={toc:[]},Rln="wrapper";function Wln(e){let{components:n,...t}=e;return(0,s.yg)(Rln,(0,p.A)({},Iln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Wln.isMDXComponent=!0;const Sln={toc:[]},Bln="wrapper";function Gln(e){let{components:n,...t}=e;return(0,s.yg)(Bln,(0,p.A)({},Sln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Gln.isMDXComponent=!0;const Eln={toc:[]},Oln="wrapper";function Uln(e){let{components:n,...t}=e;return(0,s.yg)(Oln,(0,p.A)({},Eln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Uln.isMDXComponent=!0;const Fln={toc:[]},Vln="wrapper";function qln(e){let{components:n,...t}=e;return(0,s.yg)(Vln,(0,p.A)({},Fln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qln.isMDXComponent=!0;const jln={toc:[]},Hln="wrapper";function Yln(e){let{components:n,...t}=e;return(0,s.yg)(Hln,(0,p.A)({},jln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Yln.isMDXComponent=!0;const Qln={toc:[]},$ln="wrapper";function Kln(e){let{components:n,...t}=e;return(0,s.yg)($ln,(0,p.A)({},Qln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Kln.isMDXComponent=!0;const Jln={toc:[]},Zln="wrapper";function eun(e){let{components:n,...t}=e;return(0,s.yg)(Zln,(0,p.A)({},Jln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}eun.isMDXComponent=!0;const nun={toc:[]},tun="wrapper";function oun(e){let{components:n,...t}=e;return(0,s.yg)(tun,(0,p.A)({},nun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}oun.isMDXComponent=!0;const pun={toc:[]},run="wrapper";function sun(e){let{components:n,...t}=e;return(0,s.yg)(run,(0,p.A)({},pun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}sun.isMDXComponent=!0;const cun={toc:[]},aun="wrapper";function iun(e){let{components:n,...t}=e;return(0,s.yg)(aun,(0,p.A)({},cun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}iun.isMDXComponent=!0;const lun={toc:[]},uun="wrapper";function mun(e){let{components:n,...t}=e;return(0,s.yg)(uun,(0,p.A)({},lun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}mun.isMDXComponent=!0;const yun={toc:[]},dun="wrapper";function hun(e){let{components:n,...t}=e;return(0,s.yg)(dun,(0,p.A)({},yun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}hun.isMDXComponent=!0;const gun={toc:[]},fun="wrapper";function Dun(e){let{components:n,...t}=e;return(0,s.yg)(fun,(0,p.A)({},gun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Dun.isMDXComponent=!0;const Mun={toc:[]},Xun="wrapper";function _un(e){let{components:n,...t}=e;return(0,s.yg)(Xun,(0,p.A)({},Mun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}_un.isMDXComponent=!0;const wun={toc:[]},Tun="wrapper";function Cun(e){let{components:n,...t}=e;return(0,s.yg)(Tun,(0,p.A)({},wun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Cun.isMDXComponent=!0;const xun={toc:[]},Aun="wrapper";function vun(e){let{components:n,...t}=e;return(0,s.yg)(Aun,(0,p.A)({},xun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}vun.isMDXComponent=!0;const Lun={toc:[]},bun="wrapper";function Nun(e){let{components:n,...t}=e;return(0,s.yg)(bun,(0,p.A)({},Lun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}Nun.isMDXComponent=!0;const kun={toc:[]},zun="wrapper";function Pun(e){let{components:n,...t}=e;return(0,s.yg)(zun,(0,p.A)({},kun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Pun.isMDXComponent=!0;const Iun={toc:[]},Run="wrapper";function Wun(e){let{components:n,...t}=e;return(0,s.yg)(Run,(0,p.A)({},Iun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Wun.isMDXComponent=!0;const Sun={toc:[]},Bun="wrapper";function Gun(e){let{components:n,...t}=e;return(0,s.yg)(Bun,(0,p.A)({},Sun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Gun.isMDXComponent=!0;const Eun={toc:[]},Oun="wrapper";function Uun(e){let{components:n,...t}=e;return(0,s.yg)(Oun,(0,p.A)({},Eun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Uun.isMDXComponent=!0;const Fun={toc:[]},Vun="wrapper";function qun(e){let{components:n,...t}=e;return(0,s.yg)(Vun,(0,p.A)({},Fun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qun.isMDXComponent=!0;const jun={toc:[]},Hun="wrapper";function Yun(e){let{components:n,...t}=e;return(0,s.yg)(Hun,(0,p.A)({},jun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Yun.isMDXComponent=!0;const Qun={toc:[]},$un="wrapper";function Kun(e){let{components:n,...t}=e;return(0,s.yg)($un,(0,p.A)({},Qun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Kun.isMDXComponent=!0;const Jun={toc:[]},Zun="wrapper";function emn(e){let{components:n,...t}=e;return(0,s.yg)(Zun,(0,p.A)({},Jun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}emn.isMDXComponent=!0;const nmn={toc:[]},tmn="wrapper";function omn(e){let{components:n,...t}=e;return(0,s.yg)(tmn,(0,p.A)({},nmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}omn.isMDXComponent=!0;const pmn={toc:[]},rmn="wrapper";function smn(e){let{components:n,...t}=e;return(0,s.yg)(rmn,(0,p.A)({},pmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}smn.isMDXComponent=!0;const cmn={toc:[]},amn="wrapper";function imn(e){let{components:n,...t}=e;return(0,s.yg)(amn,(0,p.A)({},cmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}imn.isMDXComponent=!0;const lmn={toc:[]},umn="wrapper";function mmn(e){let{components:n,...t}=e;return(0,s.yg)(umn,(0,p.A)({},lmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}mmn.isMDXComponent=!0;const ymn={toc:[]},dmn="wrapper";function hmn(e){let{components:n,...t}=e;return(0,s.yg)(dmn,(0,p.A)({},ymn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide the color in one of the following formats:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"named color like ",(0,s.yg)("inlineCode",{parentName:"li"},"red"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.yg)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.yg)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}hmn.isMDXComponent=!0;const gmn={toc:[]},fmn="wrapper";function Dmn(e){let{components:n,...t}=e;return(0,s.yg)(fmn,(0,p.A)({},gmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"'white'"))}Dmn.isMDXComponent=!0;const Mmn={toc:[]},Xmn="wrapper";function _mn(e){let{components:n,...t}=e;return(0,s.yg)(Xmn,(0,p.A)({},Mmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the icon"))}_mn.isMDXComponent=!0;const wmn={toc:[]},Tmn="wrapper";function Cmn(e){let{components:n,...t}=e;return(0,s.yg)(Tmn,(0,p.A)({},wmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Cmn.isMDXComponent=!0;const xmn={toc:[]},Amn="wrapper";function vmn(e){let{components:n,...t}=e;return(0,s.yg)(Amn,(0,p.A)({},xmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}vmn.isMDXComponent=!0;const Lmn={toc:[]},bmn="wrapper";function Nmn(e){let{components:n,...t}=e;return(0,s.yg)(bmn,(0,p.A)({},Lmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Nmn.isMDXComponent=!0;const kmn={toc:[]},zmn="wrapper";function Pmn(e){let{components:n,...t}=e;return(0,s.yg)(zmn,(0,p.A)({},kmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Pmn.isMDXComponent=!0;const Imn={toc:[]},Rmn="wrapper";function Wmn(e){let{components:n,...t}=e;return(0,s.yg)(Rmn,(0,p.A)({},Imn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Wmn.isMDXComponent=!0;const Smn={toc:[]},Bmn="wrapper";function Gmn(e){let{components:n,...t}=e;return(0,s.yg)(Bmn,(0,p.A)({},Smn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Gmn.isMDXComponent=!0;const Emn={toc:[]},Omn="wrapper";function Umn(e){let{components:n,...t}=e;return(0,s.yg)(Omn,(0,p.A)({},Emn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Umn.isMDXComponent=!0;const Fmn={toc:[]},Vmn="wrapper";function qmn(e){let{components:n,...t}=e;return(0,s.yg)(Vmn,(0,p.A)({},Fmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qmn.isMDXComponent=!0;const jmn={toc:[]},Hmn="wrapper";function Ymn(e){let{components:n,...t}=e;return(0,s.yg)(Hmn,(0,p.A)({},jmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Ymn.isMDXComponent=!0;const Qmn={toc:[]},$mn="wrapper";function Kmn(e){let{components:n,...t}=e;return(0,s.yg)($mn,(0,p.A)({},Qmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can find identifiers on ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Kmn.isMDXComponent=!0;const Jmn={toc:[]},Zmn="wrapper";function eyn(e){let{components:n,...t}=e;return(0,s.yg)(Zmn,(0,p.A)({},Jmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The identifier of the icon."))}eyn.isMDXComponent=!0;const nyn={toc:[]},tyn="wrapper";function oyn(e){let{components:n,...t}=e;return(0,s.yg)(tyn,(0,p.A)({},nyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}oyn.isMDXComponent=!0;const pyn={toc:[]},ryn="wrapper";function syn(e){let{components:n,...t}=e;return(0,s.yg)(ryn,(0,p.A)({},pyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}syn.isMDXComponent=!0;const cyn={toc:[]},ayn="wrapper";function iyn(e){let{components:n,...t}=e;return(0,s.yg)(ayn,(0,p.A)({},cyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}iyn.isMDXComponent=!0;const lyn={toc:[]},uyn="wrapper";function myn(e){let{components:n,...t}=e;return(0,s.yg)(uyn,(0,p.A)({},lyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}myn.isMDXComponent=!0;const yyn={toc:[]},dyn="wrapper";function hyn(e){let{components:n,...t}=e;return(0,s.yg)(dyn,(0,p.A)({},yyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}hyn.isMDXComponent=!0;const gyn={toc:[]},fyn="wrapper";function Dyn(e){let{components:n,...t}=e;return(0,s.yg)(fyn,(0,p.A)({},gyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Dyn.isMDXComponent=!0;const Myn={toc:[]},Xyn="wrapper";function _yn(e){let{components:n,...t}=e;return(0,s.yg)(Xyn,(0,p.A)({},Myn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}_yn.isMDXComponent=!0;const wyn={toc:[]},Tyn="wrapper";function Cyn(e){let{components:n,...t}=e;return(0,s.yg)(Tyn,(0,p.A)({},wyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Cyn.isMDXComponent=!0;const xyn={toc:[]},Ayn="wrapper";function vyn(e){let{components:n,...t}=e;return(0,s.yg)(Ayn,(0,p.A)({},xyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vyn.isMDXComponent=!0;const Lyn={toc:[]},byn="wrapper";function Nyn(e){let{components:n,...t}=e;return(0,s.yg)(byn,(0,p.A)({},Lyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Nyn.isMDXComponent=!0;const kyn={toc:[]},zyn="wrapper";function Pyn(e){let{components:n,...t}=e;return(0,s.yg)(zyn,(0,p.A)({},kyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Pyn.isMDXComponent=!0;const Iyn={toc:[]},Ryn="wrapper";function Wyn(e){let{components:n,...t}=e;return(0,s.yg)(Ryn,(0,p.A)({},Iyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Wyn.isMDXComponent=!0;const Syn={toc:[]},Byn="wrapper";function Gyn(e){let{components:n,...t}=e;return(0,s.yg)(Byn,(0,p.A)({},Syn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Gyn.isMDXComponent=!0;const Eyn={toc:[]},Oyn="wrapper";function Uyn(e){let{components:n,...t}=e;return(0,s.yg)(Oyn,(0,p.A)({},Eyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Uyn.isMDXComponent=!0;const Fyn={toc:[]},Vyn="wrapper";function qyn(e){let{components:n,...t}=e;return(0,s.yg)(Vyn,(0,p.A)({},Fyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qyn.isMDXComponent=!0;const jyn={toc:[]},Hyn="wrapper";function Yyn(e){let{components:n,...t}=e;return(0,s.yg)(Hyn,(0,p.A)({},jyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Yyn.isMDXComponent=!0;const Qyn={toc:[]},$yn="wrapper";function Kyn(e){let{components:n,...t}=e;return(0,s.yg)($yn,(0,p.A)({},Qyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Kyn.isMDXComponent=!0;const Jyn={toc:[]},Zyn="wrapper";function edn(e){let{components:n,...t}=e;return(0,s.yg)(Zyn,(0,p.A)({},Jyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}edn.isMDXComponent=!0;const ndn={toc:[]},tdn="wrapper";function odn(e){let{components:n,...t}=e;return(0,s.yg)(tdn,(0,p.A)({},ndn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}odn.isMDXComponent=!0;const pdn={toc:[]},rdn="wrapper";function sdn(e){let{components:n,...t}=e;return(0,s.yg)(rdn,(0,p.A)({},pdn,t,{components:n,mdxType:"MDXLayout"}))}sdn.isMDXComponent=!0;const cdn={toc:[]},adn="wrapper";function idn(e){let{components:n,...t}=e;return(0,s.yg)(adn,(0,p.A)({},cdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}idn.isMDXComponent=!0;const ldn={toc:[]},udn="wrapper";function mdn(e){let{components:n,...t}=e;return(0,s.yg)(udn,(0,p.A)({},ldn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}mdn.isMDXComponent=!0;const ydn={toc:[]},ddn="wrapper";function hdn(e){let{components:n,...t}=e;return(0,s.yg)(ddn,(0,p.A)({},ydn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}hdn.isMDXComponent=!0;const gdn={toc:[]},fdn="wrapper";function Ddn(e){let{components:n,...t}=e;return(0,s.yg)(fdn,(0,p.A)({},gdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Ddn.isMDXComponent=!0;const Mdn={toc:[]},Xdn="wrapper";function _dn(e){let{components:n,...t}=e;return(0,s.yg)(Xdn,(0,p.A)({},Mdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}_dn.isMDXComponent=!0;const wdn={toc:[]},Tdn="wrapper";function Cdn(e){let{components:n,...t}=e;return(0,s.yg)(Tdn,(0,p.A)({},wdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Cdn.isMDXComponent=!0;const xdn={toc:[]},Adn="wrapper";function vdn(e){let{components:n,...t}=e;return(0,s.yg)(Adn,(0,p.A)({},xdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}vdn.isMDXComponent=!0;const Ldn={toc:[]},bdn="wrapper";function Ndn(e){let{components:n,...t}=e;return(0,s.yg)(bdn,(0,p.A)({},Ldn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}Ndn.isMDXComponent=!0;const kdn={toc:[]},zdn="wrapper";function Pdn(e){let{components:n,...t}=e;return(0,s.yg)(zdn,(0,p.A)({},kdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Pdn.isMDXComponent=!0;const Idn={toc:[]},Rdn="wrapper";function Wdn(e){let{components:n,...t}=e;return(0,s.yg)(Rdn,(0,p.A)({},Idn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}Wdn.isMDXComponent=!0;const Sdn={toc:[]},Bdn="wrapper";function Gdn(e){let{components:n,...t}=e;return(0,s.yg)(Bdn,(0,p.A)({},Sdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}Gdn.isMDXComponent=!0;const Edn={toc:[]},Odn="wrapper";function Udn(e){let{components:n,...t}=e;return(0,s.yg)(Odn,(0,p.A)({},Edn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Udn.isMDXComponent=!0;const Fdn={toc:[]},Vdn="wrapper";function qdn(e){let{components:n,...t}=e;return(0,s.yg)(Vdn,(0,p.A)({},Fdn,t,{components:n,mdxType:"MDXLayout"}))}qdn.isMDXComponent=!0;const jdn={toc:[]},Hdn="wrapper";function Ydn(e){let{components:n,...t}=e;return(0,s.yg)(Hdn,(0,p.A)({},jdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Ydn.isMDXComponent=!0;const Qdn={toc:[]},$dn="wrapper";function Kdn(e){let{components:n,...t}=e;return(0,s.yg)($dn,(0,p.A)({},Qdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}Kdn.isMDXComponent=!0;const Jdn={toc:[]},Zdn="wrapper";function ehn(e){let{components:n,...t}=e;return(0,s.yg)(Zdn,(0,p.A)({},Jdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ehn.isMDXComponent=!0;const nhn={toc:[]},thn="wrapper";function ohn(e){let{components:n,...t}=e;return(0,s.yg)(thn,(0,p.A)({},nhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}ohn.isMDXComponent=!0;const phn={toc:[]},rhn="wrapper";function shn(e){let{components:n,...t}=e;return(0,s.yg)(rhn,(0,p.A)({},phn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}shn.isMDXComponent=!0;const chn={toc:[]},ahn="wrapper";function ihn(e){let{components:n,...t}=e;return(0,s.yg)(ahn,(0,p.A)({},chn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}ihn.isMDXComponent=!0;const lhn={toc:[]},uhn="wrapper";function mhn(e){let{components:n,...t}=e;return(0,s.yg)(uhn,(0,p.A)({},lhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}mhn.isMDXComponent=!0;const yhn={toc:[]},dhn="wrapper";function hhn(e){let{components:n,...t}=e;return(0,s.yg)(dhn,(0,p.A)({},yhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}hhn.isMDXComponent=!0;const ghn={toc:[]},fhn="wrapper";function Dhn(e){let{components:n,...t}=e;return(0,s.yg)(fhn,(0,p.A)({},ghn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Dhn.isMDXComponent=!0;const Mhn={toc:[]},Xhn="wrapper";function _hn(e){let{components:n,...t}=e;return(0,s.yg)(Xhn,(0,p.A)({},Mhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}_hn.isMDXComponent=!0;const whn={toc:[]},Thn="wrapper";function Chn(e){let{components:n,...t}=e;return(0,s.yg)(Thn,(0,p.A)({},whn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Chn.isMDXComponent=!0;const xhn={toc:[]},Ahn="wrapper";function vhn(e){let{components:n,...t}=e;return(0,s.yg)(Ahn,(0,p.A)({},xhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}vhn.isMDXComponent=!0;const Lhn={toc:[]},bhn="wrapper";function Nhn(e){let{components:n,...t}=e;return(0,s.yg)(bhn,(0,p.A)({},Lhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Nhn.isMDXComponent=!0;const khn={toc:[]},zhn="wrapper";function Phn(e){let{components:n,...t}=e;return(0,s.yg)(zhn,(0,p.A)({},khn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Phn.isMDXComponent=!0;const Ihn={toc:[]},Rhn="wrapper";function Whn(e){let{components:n,...t}=e;return(0,s.yg)(Rhn,(0,p.A)({},Ihn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Whn.isMDXComponent=!0;const Shn={toc:[]},Bhn="wrapper";function Ghn(e){let{components:n,...t}=e;return(0,s.yg)(Bhn,(0,p.A)({},Shn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ghn.isMDXComponent=!0;const Ehn={toc:[]},Ohn="wrapper";function Uhn(e){let{components:n,...t}=e;return(0,s.yg)(Ohn,(0,p.A)({},Ehn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Uhn.isMDXComponent=!0;const Fhn={toc:[]},Vhn="wrapper";function qhn(e){let{components:n,...t}=e;return(0,s.yg)(Vhn,(0,p.A)({},Fhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}qhn.isMDXComponent=!0;const jhn={toc:[]},Hhn="wrapper";function Yhn(e){let{components:n,...t}=e;return(0,s.yg)(Hhn,(0,p.A)({},jhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Yhn.isMDXComponent=!0;const Qhn={toc:[]},$hn="wrapper";function Khn(e){let{components:n,...t}=e;return(0,s.yg)($hn,(0,p.A)({},Qhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Khn.isMDXComponent=!0;const Jhn={toc:[]},Zhn="wrapper";function egn(e){let{components:n,...t}=e;return(0,s.yg)(Zhn,(0,p.A)({},Jhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}egn.isMDXComponent=!0;const ngn={toc:[]},tgn="wrapper";function ogn(e){let{components:n,...t}=e;return(0,s.yg)(tgn,(0,p.A)({},ngn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}ogn.isMDXComponent=!0;const pgn={toc:[]},rgn="wrapper";function sgn(e){let{components:n,...t}=e;return(0,s.yg)(rgn,(0,p.A)({},pgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}sgn.isMDXComponent=!0;const cgn={toc:[]},agn="wrapper";function ign(e){let{components:n,...t}=e;return(0,s.yg)(agn,(0,p.A)({},cgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}ign.isMDXComponent=!0;const lgn={toc:[]},ugn="wrapper";function mgn(e){let{components:n,...t}=e;return(0,s.yg)(ugn,(0,p.A)({},lgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}mgn.isMDXComponent=!0;const ygn={toc:[]},dgn="wrapper";function hgn(e){let{components:n,...t}=e;return(0,s.yg)(dgn,(0,p.A)({},ygn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}hgn.isMDXComponent=!0;const ggn={toc:[]},fgn="wrapper";function Dgn(e){let{components:n,...t}=e;return(0,s.yg)(fgn,(0,p.A)({},ggn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Dgn.isMDXComponent=!0;const Mgn={toc:[]},Xgn="wrapper";function _gn(e){let{components:n,...t}=e;return(0,s.yg)(Xgn,(0,p.A)({},Mgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}_gn.isMDXComponent=!0;const wgn={toc:[]},Tgn="wrapper";function Cgn(e){let{components:n,...t}=e;return(0,s.yg)(Tgn,(0,p.A)({},wgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Cgn.isMDXComponent=!0;const xgn={toc:[]},Agn="wrapper";function vgn(e){let{components:n,...t}=e;return(0,s.yg)(Agn,(0,p.A)({},xgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vgn.isMDXComponent=!0;const Lgn={toc:[]},bgn="wrapper";function Ngn(e){let{components:n,...t}=e;return(0,s.yg)(bgn,(0,p.A)({},Lgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Ngn.isMDXComponent=!0;const kgn={toc:[]},zgn="wrapper";function Pgn(e){let{components:n,...t}=e;return(0,s.yg)(zgn,(0,p.A)({},kgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Pgn.isMDXComponent=!0;const Ign={toc:[]},Rgn="wrapper";function Wgn(e){let{components:n,...t}=e;return(0,s.yg)(Rgn,(0,p.A)({},Ign,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Wgn.isMDXComponent=!0;const Sgn={toc:[]},Bgn="wrapper";function Ggn(e){let{components:n,...t}=e;return(0,s.yg)(Bgn,(0,p.A)({},Sgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Ggn.isMDXComponent=!0;const Egn={toc:[]},Ogn="wrapper";function Ugn(e){let{components:n,...t}=e;return(0,s.yg)(Ogn,(0,p.A)({},Egn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Ugn.isMDXComponent=!0;const Fgn={toc:[]},Vgn="wrapper";function qgn(e){let{components:n,...t}=e;return(0,s.yg)(Vgn,(0,p.A)({},Fgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}qgn.isMDXComponent=!0;const jgn={toc:[]},Hgn="wrapper";function Ygn(e){let{components:n,...t}=e;return(0,s.yg)(Hgn,(0,p.A)({},jgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Ygn.isMDXComponent=!0;const Qgn={toc:[]},$gn="wrapper";function Kgn(e){let{components:n,...t}=e;return(0,s.yg)($gn,(0,p.A)({},Qgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Kgn.isMDXComponent=!0;const Jgn={toc:[]},Zgn="wrapper";function efn(e){let{components:n,...t}=e;return(0,s.yg)(Zgn,(0,p.A)({},Jgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}efn.isMDXComponent=!0;const nfn={toc:[]},tfn="wrapper";function ofn(e){let{components:n,...t}=e;return(0,s.yg)(tfn,(0,p.A)({},nfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}ofn.isMDXComponent=!0;const pfn={toc:[]},rfn="wrapper";function sfn(e){let{components:n,...t}=e;return(0,s.yg)(rfn,(0,p.A)({},pfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}sfn.isMDXComponent=!0;const cfn={toc:[]},afn="wrapper";function ifn(e){let{components:n,...t}=e;return(0,s.yg)(afn,(0,p.A)({},cfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}ifn.isMDXComponent=!0;const lfn={toc:[]},ufn="wrapper";function mfn(e){let{components:n,...t}=e;return(0,s.yg)(ufn,(0,p.A)({},lfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}mfn.isMDXComponent=!0;const yfn={toc:[]},dfn="wrapper";function hfn(e){let{components:n,...t}=e;return(0,s.yg)(dfn,(0,p.A)({},yfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}hfn.isMDXComponent=!0;const gfn={toc:[]},ffn="wrapper";function Dfn(e){let{components:n,...t}=e;return(0,s.yg)(ffn,(0,p.A)({},gfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Dfn.isMDXComponent=!0;const Mfn={toc:[]},Xfn="wrapper";function _fn(e){let{components:n,...t}=e;return(0,s.yg)(Xfn,(0,p.A)({},Mfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}_fn.isMDXComponent=!0;const wfn={toc:[]},Tfn="wrapper";function Cfn(e){let{components:n,...t}=e;return(0,s.yg)(Tfn,(0,p.A)({},wfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Cfn.isMDXComponent=!0;const xfn={toc:[]},Afn="wrapper";function vfn(e){let{components:n,...t}=e;return(0,s.yg)(Afn,(0,p.A)({},xfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}vfn.isMDXComponent=!0;const Lfn={toc:[]},bfn="wrapper";function Nfn(e){let{components:n,...t}=e;return(0,s.yg)(bfn,(0,p.A)({},Lfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Nfn.isMDXComponent=!0;const kfn={toc:[]},zfn="wrapper";function Pfn(e){let{components:n,...t}=e;return(0,s.yg)(zfn,(0,p.A)({},kfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Pfn.isMDXComponent=!0;const Ifn={toc:[]},Rfn="wrapper";function Wfn(e){let{components:n,...t}=e;return(0,s.yg)(Rfn,(0,p.A)({},Ifn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Wfn.isMDXComponent=!0;const Sfn={toc:[]},Bfn="wrapper";function Gfn(e){let{components:n,...t}=e;return(0,s.yg)(Bfn,(0,p.A)({},Sfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Gfn.isMDXComponent=!0;const Efn={toc:[]},Ofn="wrapper";function Ufn(e){let{components:n,...t}=e;return(0,s.yg)(Ofn,(0,p.A)({},Efn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Ufn.isMDXComponent=!0;const Ffn={toc:[]},Vfn="wrapper";function qfn(e){let{components:n,...t}=e;return(0,s.yg)(Vfn,(0,p.A)({},Ffn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}qfn.isMDXComponent=!0;const jfn={toc:[]},Hfn="wrapper";function Yfn(e){let{components:n,...t}=e;return(0,s.yg)(Hfn,(0,p.A)({},jfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Yfn.isMDXComponent=!0;const Qfn={toc:[]},$fn="wrapper";function Kfn(e){let{components:n,...t}=e;return(0,s.yg)($fn,(0,p.A)({},Qfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]},Zfn="wrapper";function eDn(e){let{components:n,...t}=e;return(0,s.yg)(Zfn,(0,p.A)({},Jfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}eDn.isMDXComponent=!0;const nDn={toc:[]},tDn="wrapper";function oDn(e){let{components:n,...t}=e;return(0,s.yg)(tDn,(0,p.A)({},nDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oDn.isMDXComponent=!0;const pDn={toc:[]},rDn="wrapper";function sDn(e){let{components:n,...t}=e;return(0,s.yg)(rDn,(0,p.A)({},pDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}sDn.isMDXComponent=!0;const cDn={toc:[]},aDn="wrapper";function iDn(e){let{components:n,...t}=e;return(0,s.yg)(aDn,(0,p.A)({},cDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}iDn.isMDXComponent=!0;const lDn={toc:[]},uDn="wrapper";function mDn(e){let{components:n,...t}=e;return(0,s.yg)(uDn,(0,p.A)({},lDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}mDn.isMDXComponent=!0;const yDn={toc:[]},dDn="wrapper";function hDn(e){let{components:n,...t}=e;return(0,s.yg)(dDn,(0,p.A)({},yDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hDn.isMDXComponent=!0;const gDn={toc:[]},fDn="wrapper";function DDn(e){let{components:n,...t}=e;return(0,s.yg)(fDn,(0,p.A)({},gDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}DDn.isMDXComponent=!0;const MDn={toc:[]},XDn="wrapper";function _Dn(e){let{components:n,...t}=e;return(0,s.yg)(XDn,(0,p.A)({},MDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_Dn.isMDXComponent=!0;const wDn={toc:[]},TDn="wrapper";function CDn(e){let{components:n,...t}=e;return(0,s.yg)(TDn,(0,p.A)({},wDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}CDn.isMDXComponent=!0;const xDn={toc:[]},ADn="wrapper";function vDn(e){let{components:n,...t}=e;return(0,s.yg)(ADn,(0,p.A)({},xDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vDn.isMDXComponent=!0;const LDn={toc:[]},bDn="wrapper";function NDn(e){let{components:n,...t}=e;return(0,s.yg)(bDn,(0,p.A)({},LDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}NDn.isMDXComponent=!0;const kDn={toc:[]},zDn="wrapper";function PDn(e){let{components:n,...t}=e;return(0,s.yg)(zDn,(0,p.A)({},kDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}PDn.isMDXComponent=!0;const IDn={toc:[]},RDn="wrapper";function WDn(e){let{components:n,...t}=e;return(0,s.yg)(RDn,(0,p.A)({},IDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}WDn.isMDXComponent=!0;const SDn={toc:[]},BDn="wrapper";function GDn(e){let{components:n,...t}=e;return(0,s.yg)(BDn,(0,p.A)({},SDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GDn.isMDXComponent=!0;const EDn={toc:[]},ODn="wrapper";function UDn(e){let{components:n,...t}=e;return(0,s.yg)(ODn,(0,p.A)({},EDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}UDn.isMDXComponent=!0;const FDn={toc:[]},VDn="wrapper";function qDn(e){let{components:n,...t}=e;return(0,s.yg)(VDn,(0,p.A)({},FDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qDn.isMDXComponent=!0;const jDn={toc:[]},HDn="wrapper";function YDn(e){let{components:n,...t}=e;return(0,s.yg)(HDn,(0,p.A)({},jDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}YDn.isMDXComponent=!0;const QDn={toc:[]},$Dn="wrapper";function KDn(e){let{components:n,...t}=e;return(0,s.yg)($Dn,(0,p.A)({},QDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}KDn.isMDXComponent=!0;const JDn={toc:[]},ZDn="wrapper";function eMn(e){let{components:n,...t}=e;return(0,s.yg)(ZDn,(0,p.A)({},JDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}eMn.isMDXComponent=!0;const nMn={toc:[]},tMn="wrapper";function oMn(e){let{components:n,...t}=e;return(0,s.yg)(tMn,(0,p.A)({},nMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}oMn.isMDXComponent=!0;const pMn={toc:[]},rMn="wrapper";function sMn(e){let{components:n,...t}=e;return(0,s.yg)(rMn,(0,p.A)({},pMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}sMn.isMDXComponent=!0;const cMn={toc:[]},aMn="wrapper";function iMn(e){let{components:n,...t}=e;return(0,s.yg)(aMn,(0,p.A)({},cMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}iMn.isMDXComponent=!0;const lMn={toc:[]},uMn="wrapper";function mMn(e){let{components:n,...t}=e;return(0,s.yg)(uMn,(0,p.A)({},lMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"overrides ",(0,s.yg)("inlineCode",{parentName:"p"},"Image.src")," getter"))}mMn.isMDXComponent=!0;const yMn={toc:[]},dMn="wrapper";function hMn(e){let{components:n,...t}=e;return(0,s.yg)(dMn,(0,p.A)({},yMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hMn.isMDXComponent=!0;const gMn={toc:[]},fMn="wrapper";function DMn(e){let{components:n,...t}=e;return(0,s.yg)(fMn,(0,p.A)({},gMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}DMn.isMDXComponent=!0;const MMn={toc:[]},XMn="wrapper";function _Mn(e){let{components:n,...t}=e;return(0,s.yg)(XMn,(0,p.A)({},MMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}_Mn.isMDXComponent=!0;const wMn={toc:[]},TMn="wrapper";function CMn(e){let{components:n,...t}=e;return(0,s.yg)(TMn,(0,p.A)({},wMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}CMn.isMDXComponent=!0;const xMn={toc:[]},AMn="wrapper";function vMn(e){let{components:n,...t}=e;return(0,s.yg)(AMn,(0,p.A)({},xMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}vMn.isMDXComponent=!0;const LMn={toc:[]},bMn="wrapper";function NMn(e){let{components:n,...t}=e;return(0,s.yg)(bMn,(0,p.A)({},LMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}NMn.isMDXComponent=!0;const kMn={toc:[]},zMn="wrapper";function PMn(e){let{components:n,...t}=e;return(0,s.yg)(zMn,(0,p.A)({},kMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}PMn.isMDXComponent=!0;const IMn={toc:[]},RMn="wrapper";function WMn(e){let{components:n,...t}=e;return(0,s.yg)(RMn,(0,p.A)({},IMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}WMn.isMDXComponent=!0;const SMn={toc:[]},BMn="wrapper";function GMn(e){let{components:n,...t}=e;return(0,s.yg)(BMn,(0,p.A)({},SMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}GMn.isMDXComponent=!0;const EMn={toc:[]},OMn="wrapper";function UMn(e){let{components:n,...t}=e;return(0,s.yg)(OMn,(0,p.A)({},EMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}UMn.isMDXComponent=!0;const FMn={toc:[]},VMn="wrapper";function qMn(e){let{components:n,...t}=e;return(0,s.yg)(VMn,(0,p.A)({},FMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qMn.isMDXComponent=!0;const jMn={toc:[]},HMn="wrapper";function YMn(e){let{components:n,...t}=e;return(0,s.yg)(HMn,(0,p.A)({},jMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}YMn.isMDXComponent=!0;const QMn={toc:[]},$Mn="wrapper";function KMn(e){let{components:n,...t}=e;return(0,s.yg)($Mn,(0,p.A)({},QMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}KMn.isMDXComponent=!0;const JMn={toc:[]},ZMn="wrapper";function eXn(e){let{components:n,...t}=e;return(0,s.yg)(ZMn,(0,p.A)({},JMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}eXn.isMDXComponent=!0;const nXn={toc:[]},tXn="wrapper";function oXn(e){let{components:n,...t}=e;return(0,s.yg)(tXn,(0,p.A)({},nXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}oXn.isMDXComponent=!0;const pXn={toc:[]},rXn="wrapper";function sXn(e){let{components:n,...t}=e;return(0,s.yg)(rXn,(0,p.A)({},pXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sXn.isMDXComponent=!0;const cXn={toc:[]},aXn="wrapper";function iXn(e){let{components:n,...t}=e;return(0,s.yg)(aXn,(0,p.A)({},cXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}iXn.isMDXComponent=!0;const lXn={toc:[]},uXn="wrapper";function mXn(e){let{components:n,...t}=e;return(0,s.yg)(uXn,(0,p.A)({},lXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}mXn.isMDXComponent=!0;const yXn={toc:[]},dXn="wrapper";function hXn(e){let{components:n,...t}=e;return(0,s.yg)(dXn,(0,p.A)({},yXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}hXn.isMDXComponent=!0;const gXn={toc:[]},fXn="wrapper";function DXn(e){let{components:n,...t}=e;return(0,s.yg)(fXn,(0,p.A)({},gXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}DXn.isMDXComponent=!0;const MXn={toc:[]},XXn="wrapper";function _Xn(e){let{components:n,...t}=e;return(0,s.yg)(XXn,(0,p.A)({},MXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_Xn.isMDXComponent=!0;const wXn={toc:[]},TXn="wrapper";function CXn(e){let{components:n,...t}=e;return(0,s.yg)(TXn,(0,p.A)({},wXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}CXn.isMDXComponent=!0;const xXn={toc:[]},AXn="wrapper";function vXn(e){let{components:n,...t}=e;return(0,s.yg)(AXn,(0,p.A)({},xXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}vXn.isMDXComponent=!0;const LXn={toc:[]},bXn="wrapper";function NXn(e){let{components:n,...t}=e;return(0,s.yg)(bXn,(0,p.A)({},LXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}NXn.isMDXComponent=!0;const kXn={toc:[]},zXn="wrapper";function PXn(e){let{components:n,...t}=e;return(0,s.yg)(zXn,(0,p.A)({},kXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}PXn.isMDXComponent=!0;const IXn={toc:[]},RXn="wrapper";function WXn(e){let{components:n,...t}=e;return(0,s.yg)(RXn,(0,p.A)({},IXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}WXn.isMDXComponent=!0;const SXn={toc:[]},BXn="wrapper";function GXn(e){let{components:n,...t}=e;return(0,s.yg)(BXn,(0,p.A)({},SXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}GXn.isMDXComponent=!0;const EXn={toc:[]},OXn="wrapper";function UXn(e){let{components:n,...t}=e;return(0,s.yg)(OXn,(0,p.A)({},EXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}UXn.isMDXComponent=!0;const FXn={toc:[]},VXn="wrapper";function qXn(e){let{components:n,...t}=e;return(0,s.yg)(VXn,(0,p.A)({},FXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qXn.isMDXComponent=!0;const jXn={toc:[]},HXn="wrapper";function YXn(e){let{components:n,...t}=e;return(0,s.yg)(HXn,(0,p.A)({},jXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}YXn.isMDXComponent=!0;const QXn={toc:[]},$Xn="wrapper";function KXn(e){let{components:n,...t}=e;return(0,s.yg)($Xn,(0,p.A)({},QXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}KXn.isMDXComponent=!0;const JXn={toc:[]},ZXn="wrapper";function e_n(e){let{components:n,...t}=e;return(0,s.yg)(ZXn,(0,p.A)({},JXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}e_n.isMDXComponent=!0;const n_n={toc:[]},t_n="wrapper";function o_n(e){let{components:n,...t}=e;return(0,s.yg)(t_n,(0,p.A)({},n_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}o_n.isMDXComponent=!0;const p_n={toc:[]},r_n="wrapper";function s_n(e){let{components:n,...t}=e;return(0,s.yg)(r_n,(0,p.A)({},p_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}s_n.isMDXComponent=!0;const c_n={toc:[]},a_n="wrapper";function i_n(e){let{components:n,...t}=e;return(0,s.yg)(a_n,(0,p.A)({},c_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}i_n.isMDXComponent=!0;const l_n={toc:[]},u_n="wrapper";function m_n(e){let{components:n,...t}=e;return(0,s.yg)(u_n,(0,p.A)({},l_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}m_n.isMDXComponent=!0;const y_n={toc:[]},d_n="wrapper";function h_n(e){let{components:n,...t}=e;return(0,s.yg)(d_n,(0,p.A)({},y_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}h_n.isMDXComponent=!0;const g_n={toc:[]},f_n="wrapper";function D_n(e){let{components:n,...t}=e;return(0,s.yg)(f_n,(0,p.A)({},g_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}D_n.isMDXComponent=!0;const M_n={toc:[]},X_n="wrapper";function __n(e){let{components:n,...t}=e;return(0,s.yg)(X_n,(0,p.A)({},M_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}__n.isMDXComponent=!0;const w_n={toc:[]},T_n="wrapper";function C_n(e){let{components:n,...t}=e;return(0,s.yg)(T_n,(0,p.A)({},w_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}C_n.isMDXComponent=!0;const x_n={toc:[]},A_n="wrapper";function v_n(e){let{components:n,...t}=e;return(0,s.yg)(A_n,(0,p.A)({},x_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}v_n.isMDXComponent=!0;const L_n={toc:[]},b_n="wrapper";function N_n(e){let{components:n,...t}=e;return(0,s.yg)(b_n,(0,p.A)({},L_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}N_n.isMDXComponent=!0;const k_n={toc:[]},z_n="wrapper";function P_n(e){let{components:n,...t}=e;return(0,s.yg)(z_n,(0,p.A)({},k_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}P_n.isMDXComponent=!0;const I_n={toc:[]},R_n="wrapper";function W_n(e){let{components:n,...t}=e;return(0,s.yg)(R_n,(0,p.A)({},I_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}W_n.isMDXComponent=!0;const S_n={toc:[]},B_n="wrapper";function G_n(e){let{components:n,...t}=e;return(0,s.yg)(B_n,(0,p.A)({},S_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}G_n.isMDXComponent=!0;const E_n={toc:[]},O_n="wrapper";function U_n(e){let{components:n,...t}=e;return(0,s.yg)(O_n,(0,p.A)({},E_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}U_n.isMDXComponent=!0;const F_n={toc:[]},V_n="wrapper";function q_n(e){let{components:n,...t}=e;return(0,s.yg)(V_n,(0,p.A)({},F_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}q_n.isMDXComponent=!0;const j_n={toc:[]},H_n="wrapper";function Y_n(e){let{components:n,...t}=e;return(0,s.yg)(H_n,(0,p.A)({},j_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Y_n.isMDXComponent=!0;const Q_n={toc:[]},$_n="wrapper";function K_n(e){let{components:n,...t}=e;return(0,s.yg)($_n,(0,p.A)({},Q_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}K_n.isMDXComponent=!0;const J_n={toc:[]},Z_n="wrapper";function ewn(e){let{components:n,...t}=e;return(0,s.yg)(Z_n,(0,p.A)({},J_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}ewn.isMDXComponent=!0;const nwn={toc:[]},twn="wrapper";function own(e){let{components:n,...t}=e;return(0,s.yg)(twn,(0,p.A)({},nwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}own.isMDXComponent=!0;const pwn={toc:[]},rwn="wrapper";function swn(e){let{components:n,...t}=e;return(0,s.yg)(rwn,(0,p.A)({},pwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}swn.isMDXComponent=!0;const cwn={toc:[]},awn="wrapper";function iwn(e){let{components:n,...t}=e;return(0,s.yg)(awn,(0,p.A)({},cwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}iwn.isMDXComponent=!0;const lwn={toc:[]},uwn="wrapper";function mwn(e){let{components:n,...t}=e;return(0,s.yg)(uwn,(0,p.A)({},lwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}mwn.isMDXComponent=!0;const ywn={toc:[]},dwn="wrapper";function hwn(e){let{components:n,...t}=e;return(0,s.yg)(dwn,(0,p.A)({},ywn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}hwn.isMDXComponent=!0;const gwn={toc:[]},fwn="wrapper";function Dwn(e){let{components:n,...t}=e;return(0,s.yg)(fwn,(0,p.A)({},gwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Dwn.isMDXComponent=!0;const Mwn={toc:[]},Xwn="wrapper";function _wn(e){let{components:n,...t}=e;return(0,s.yg)(Xwn,(0,p.A)({},Mwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}_wn.isMDXComponent=!0;const wwn={toc:[]},Twn="wrapper";function Cwn(e){let{components:n,...t}=e;return(0,s.yg)(Twn,(0,p.A)({},wwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Cwn.isMDXComponent=!0;const xwn={toc:[]},Awn="wrapper";function vwn(e){let{components:n,...t}=e;return(0,s.yg)(Awn,(0,p.A)({},xwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}vwn.isMDXComponent=!0;const Lwn={toc:[]},bwn="wrapper";function Nwn(e){let{components:n,...t}=e;return(0,s.yg)(bwn,(0,p.A)({},Lwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Nwn.isMDXComponent=!0;const kwn={toc:[]},zwn="wrapper";function Pwn(e){let{components:n,...t}=e;return(0,s.yg)(zwn,(0,p.A)({},kwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Pwn.isMDXComponent=!0;const Iwn={toc:[]},Rwn="wrapper";function Wwn(e){let{components:n,...t}=e;return(0,s.yg)(Rwn,(0,p.A)({},Iwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Wwn.isMDXComponent=!0;const Swn={toc:[]},Bwn="wrapper";function Gwn(e){let{components:n,...t}=e;return(0,s.yg)(Bwn,(0,p.A)({},Swn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Gwn.isMDXComponent=!0;const Ewn={toc:[]},Own="wrapper";function Uwn(e){let{components:n,...t}=e;return(0,s.yg)(Own,(0,p.A)({},Ewn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Uwn.isMDXComponent=!0;const Fwn={toc:[]},Vwn="wrapper";function qwn(e){let{components:n,...t}=e;return(0,s.yg)(Vwn,(0,p.A)({},Fwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qwn.isMDXComponent=!0;const jwn={toc:[]},Hwn="wrapper";function Ywn(e){let{components:n,...t}=e;return(0,s.yg)(Hwn,(0,p.A)({},jwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Ywn.isMDXComponent=!0;const Qwn={toc:[]},$wn="wrapper";function Kwn(e){let{components:n,...t}=e;return(0,s.yg)($wn,(0,p.A)({},Qwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]},Zwn="wrapper";function eTn(e){let{components:n,...t}=e;return(0,s.yg)(Zwn,(0,p.A)({},Jwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}eTn.isMDXComponent=!0;const nTn={toc:[]},tTn="wrapper";function oTn(e){let{components:n,...t}=e;return(0,s.yg)(tTn,(0,p.A)({},nTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}oTn.isMDXComponent=!0;const pTn={toc:[]},rTn="wrapper";function sTn(e){let{components:n,...t}=e;return(0,s.yg)(rTn,(0,p.A)({},pTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sTn.isMDXComponent=!0;const cTn={toc:[]},aTn="wrapper";function iTn(e){let{components:n,...t}=e;return(0,s.yg)(aTn,(0,p.A)({},cTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}iTn.isMDXComponent=!0;const lTn={toc:[]},uTn="wrapper";function mTn(e){let{components:n,...t}=e;return(0,s.yg)(uTn,(0,p.A)({},lTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}mTn.isMDXComponent=!0;const yTn={toc:[]},dTn="wrapper";function hTn(e){let{components:n,...t}=e;return(0,s.yg)(dTn,(0,p.A)({},yTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}hTn.isMDXComponent=!0;const gTn={toc:[]},fTn="wrapper";function DTn(e){let{components:n,...t}=e;return(0,s.yg)(fTn,(0,p.A)({},gTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}DTn.isMDXComponent=!0;const MTn={toc:[]},XTn="wrapper";function _Tn(e){let{components:n,...t}=e;return(0,s.yg)(XTn,(0,p.A)({},MTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}_Tn.isMDXComponent=!0;const wTn={toc:[]},TTn="wrapper";function CTn(e){let{components:n,...t}=e;return(0,s.yg)(TTn,(0,p.A)({},wTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}CTn.isMDXComponent=!0;const xTn={toc:[]},ATn="wrapper";function vTn(e){let{components:n,...t}=e;return(0,s.yg)(ATn,(0,p.A)({},xTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}vTn.isMDXComponent=!0;const LTn={toc:[]},bTn="wrapper";function NTn(e){let{components:n,...t}=e;return(0,s.yg)(bTn,(0,p.A)({},LTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}NTn.isMDXComponent=!0;const kTn={toc:[]},zTn="wrapper";function PTn(e){let{components:n,...t}=e;return(0,s.yg)(zTn,(0,p.A)({},kTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}PTn.isMDXComponent=!0;const ITn={toc:[]},RTn="wrapper";function WTn(e){let{components:n,...t}=e;return(0,s.yg)(RTn,(0,p.A)({},ITn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}WTn.isMDXComponent=!0;const STn={toc:[]},BTn="wrapper";function GTn(e){let{components:n,...t}=e;return(0,s.yg)(BTn,(0,p.A)({},STn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}GTn.isMDXComponent=!0;const ETn={toc:[]},OTn="wrapper";function UTn(e){let{components:n,...t}=e;return(0,s.yg)(OTn,(0,p.A)({},ETn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}UTn.isMDXComponent=!0;const FTn={toc:[]},VTn="wrapper";function qTn(e){let{components:n,...t}=e;return(0,s.yg)(VTn,(0,p.A)({},FTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"overrides ",(0,s.yg)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}qTn.isMDXComponent=!0;const jTn={toc:[]},HTn="wrapper";function YTn(e){let{components:n,...t}=e;return(0,s.yg)(HTn,(0,p.A)({},jTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YTn.isMDXComponent=!0;const QTn={toc:[]},$Tn="wrapper";function KTn(e){let{components:n,...t}=e;return(0,s.yg)($Tn,(0,p.A)({},QTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}KTn.isMDXComponent=!0;const JTn={toc:[]},ZTn="wrapper";function eCn(e){let{components:n,...t}=e;return(0,s.yg)(ZTn,(0,p.A)({},JTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}eCn.isMDXComponent=!0;const nCn={toc:[]},tCn="wrapper";function oCn(e){let{components:n,...t}=e;return(0,s.yg)(tCn,(0,p.A)({},nCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oCn.isMDXComponent=!0;const pCn={toc:[]},rCn="wrapper";function sCn(e){let{components:n,...t}=e;return(0,s.yg)(rCn,(0,p.A)({},pCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}sCn.isMDXComponent=!0;const cCn={toc:[]},aCn="wrapper";function iCn(e){let{components:n,...t}=e;return(0,s.yg)(aCn,(0,p.A)({},cCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}iCn.isMDXComponent=!0;const lCn={toc:[]},uCn="wrapper";function mCn(e){let{components:n,...t}=e;return(0,s.yg)(uCn,(0,p.A)({},lCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Address to Iconify API for the requested Icon."))}mCn.isMDXComponent=!0;const yCn={toc:[]},dCn="wrapper";function hCn(e){let{components:n,...t}=e;return(0,s.yg)(dCn,(0,p.A)({},yCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create the URL that will be used as the Image source"))}hCn.isMDXComponent=!0;const gCn={toc:[]},fCn="wrapper";function DCn(e){let{components:n,...t}=e;return(0,s.yg)(fCn,(0,p.A)({},gCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}DCn.isMDXComponent=!0;const MCn={toc:[]},XCn="wrapper";function _Cn(e){let{components:n,...t}=e;return(0,s.yg)(XCn,(0,p.A)({},MCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_Cn.isMDXComponent=!0;const wCn={toc:[]},TCn="wrapper";function CCn(e){let{components:n,...t}=e;return(0,s.yg)(TCn,(0,p.A)({},wCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}CCn.isMDXComponent=!0;const xCn={toc:[]},ACn="wrapper";function vCn(e){let{components:n,...t}=e;return(0,s.yg)(ACn,(0,p.A)({},xCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}vCn.isMDXComponent=!0;const LCn={toc:[]},bCn="wrapper";function NCn(e){let{components:n,...t}=e;return(0,s.yg)(bCn,(0,p.A)({},LCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}NCn.isMDXComponent=!0;const kCn={toc:[]},zCn="wrapper";function PCn(e){let{components:n,...t}=e;return(0,s.yg)(zCn,(0,p.A)({},kCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}PCn.isMDXComponent=!0;const ICn={toc:[]},RCn="wrapper";function WCn(e){let{components:n,...t}=e;return(0,s.yg)(RCn,(0,p.A)({},ICn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}WCn.isMDXComponent=!0;const SCn={toc:[]},BCn="wrapper";function GCn(e){let{components:n,...t}=e;return(0,s.yg)(BCn,(0,p.A)({},SCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}GCn.isMDXComponent=!0;const ECn={toc:[]},OCn="wrapper";function UCn(e){let{components:n,...t}=e;return(0,s.yg)(OCn,(0,p.A)({},ECn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}UCn.isMDXComponent=!0;const FCn={toc:[]},VCn="wrapper";function qCn(e){let{components:n,...t}=e;return(0,s.yg)(VCn,(0,p.A)({},FCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}qCn.isMDXComponent=!0;const jCn={toc:[]},HCn="wrapper";function YCn(e){let{components:n,...t}=e;return(0,s.yg)(HCn,(0,p.A)({},jCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@revideo/2d';\nimport {all, waitFor} from '@revideo/core';\nimport {createRef} from '@revideo/core';\nimport {makeScene2D} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}YCn.isMDXComponent=!0;const QCn={toc:[]},$Cn="wrapper";function KCn(e){let{components:n,...t}=e;return(0,s.yg)($Cn,(0,p.A)({},QCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for displaying images."))}KCn.isMDXComponent=!0;const JCn={toc:[]},ZCn="wrapper";function exn(e){let{components:n,...t}=e;return(0,s.yg)(ZCn,(0,p.A)({},JCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}exn.isMDXComponent=!0;const nxn={toc:[]},txn="wrapper";function oxn(e){let{components:n,...t}=e;return(0,s.yg)(txn,(0,p.A)({},nxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}oxn.isMDXComponent=!0;const pxn={toc:[]},rxn="wrapper";function sxn(e){let{components:n,...t}=e;return(0,s.yg)(rxn,(0,p.A)({},pxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}sxn.isMDXComponent=!0;const cxn={toc:[]},axn="wrapper";function ixn(e){let{components:n,...t}=e;return(0,s.yg)(axn,(0,p.A)({},cxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}ixn.isMDXComponent=!0;const lxn={toc:[]},uxn="wrapper";function mxn(e){let{components:n,...t}=e;return(0,s.yg)(uxn,(0,p.A)({},lxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}mxn.isMDXComponent=!0;const yxn={toc:[]},dxn="wrapper";function hxn(e){let{components:n,...t}=e;return(0,s.yg)(dxn,(0,p.A)({},yxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}hxn.isMDXComponent=!0;const gxn={toc:[]},fxn="wrapper";function Dxn(e){let{components:n,...t}=e;return(0,s.yg)(fxn,(0,p.A)({},gxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Dxn.isMDXComponent=!0;const Mxn={toc:[]},Xxn="wrapper";function _xn(e){let{components:n,...t}=e;return(0,s.yg)(Xxn,(0,p.A)({},Mxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}_xn.isMDXComponent=!0;const wxn={toc:[]},Txn="wrapper";function Cxn(e){let{components:n,...t}=e;return(0,s.yg)(Txn,(0,p.A)({},wxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Cxn.isMDXComponent=!0;const xxn={toc:[]},Axn="wrapper";function vxn(e){let{components:n,...t}=e;return(0,s.yg)(Axn,(0,p.A)({},xxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}vxn.isMDXComponent=!0;const Lxn={toc:[]},bxn="wrapper";function Nxn(e){let{components:n,...t}=e;return(0,s.yg)(bxn,(0,p.A)({},Lxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Nxn.isMDXComponent=!0;const kxn={toc:[]},zxn="wrapper";function Pxn(e){let{components:n,...t}=e;return(0,s.yg)(zxn,(0,p.A)({},kxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Pxn.isMDXComponent=!0;const Ixn={toc:[]},Rxn="wrapper";function Wxn(e){let{components:n,...t}=e;return(0,s.yg)(Rxn,(0,p.A)({},Ixn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Wxn.isMDXComponent=!0;const Sxn={toc:[]},Bxn="wrapper";function Gxn(e){let{components:n,...t}=e;return(0,s.yg)(Bxn,(0,p.A)({},Sxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Gxn.isMDXComponent=!0;const Exn={toc:[]},Oxn="wrapper";function Uxn(e){let{components:n,...t}=e;return(0,s.yg)(Oxn,(0,p.A)({},Exn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Uxn.isMDXComponent=!0;const Fxn={toc:[]},Vxn="wrapper";function qxn(e){let{components:n,...t}=e;return(0,s.yg)(Vxn,(0,p.A)({},Fxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}qxn.isMDXComponent=!0;const jxn={toc:[]},Hxn="wrapper";function Yxn(e){let{components:n,...t}=e;return(0,s.yg)(Hxn,(0,p.A)({},jxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Yxn.isMDXComponent=!0;const Qxn={toc:[]},$xn="wrapper";function Kxn(e){let{components:n,...t}=e;return(0,s.yg)($xn,(0,p.A)({},Qxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Kxn.isMDXComponent=!0;const Jxn={toc:[]},Zxn="wrapper";function eAn(e){let{components:n,...t}=e;return(0,s.yg)(Zxn,(0,p.A)({},Jxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}eAn.isMDXComponent=!0;const nAn={toc:[]},tAn="wrapper";function oAn(e){let{components:n,...t}=e;return(0,s.yg)(tAn,(0,p.A)({},nAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}oAn.isMDXComponent=!0;const pAn={toc:[]},rAn="wrapper";function sAn(e){let{components:n,...t}=e;return(0,s.yg)(rAn,(0,p.A)({},pAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}sAn.isMDXComponent=!0;const cAn={toc:[]},aAn="wrapper";function iAn(e){let{components:n,...t}=e;return(0,s.yg)(aAn,(0,p.A)({},cAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}iAn.isMDXComponent=!0;const lAn={toc:[]},uAn="wrapper";function mAn(e){let{components:n,...t}=e;return(0,s.yg)(uAn,(0,p.A)({},lAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mAn.isMDXComponent=!0;const yAn={toc:[]},dAn="wrapper";function hAn(e){let{components:n,...t}=e;return(0,s.yg)(dAn,(0,p.A)({},yAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}hAn.isMDXComponent=!0;const gAn={toc:[]},fAn="wrapper";function DAn(e){let{components:n,...t}=e;return(0,s.yg)(fAn,(0,p.A)({},gAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}DAn.isMDXComponent=!0;const MAn={toc:[]},XAn="wrapper";function _An(e){let{components:n,...t}=e;return(0,s.yg)(XAn,(0,p.A)({},MAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_An.isMDXComponent=!0;const wAn={toc:[]},TAn="wrapper";function CAn(e){let{components:n,...t}=e;return(0,s.yg)(TAn,(0,p.A)({},wAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}CAn.isMDXComponent=!0;const xAn={toc:[]},AAn="wrapper";function vAn(e){let{components:n,...t}=e;return(0,s.yg)(AAn,(0,p.A)({},xAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}vAn.isMDXComponent=!0;const LAn={toc:[]},bAn="wrapper";function NAn(e){let{components:n,...t}=e;return(0,s.yg)(bAn,(0,p.A)({},LAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}NAn.isMDXComponent=!0;const kAn={toc:[]},zAn="wrapper";function PAn(e){let{components:n,...t}=e;return(0,s.yg)(zAn,(0,p.A)({},kAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}PAn.isMDXComponent=!0;const IAn={toc:[]},RAn="wrapper";function WAn(e){let{components:n,...t}=e;return(0,s.yg)(RAn,(0,p.A)({},IAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}WAn.isMDXComponent=!0;const SAn={toc:[]},BAn="wrapper";function GAn(e){let{components:n,...t}=e;return(0,s.yg)(BAn,(0,p.A)({},SAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}GAn.isMDXComponent=!0;const EAn={toc:[]},OAn="wrapper";function UAn(e){let{components:n,...t}=e;return(0,s.yg)(OAn,(0,p.A)({},EAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}UAn.isMDXComponent=!0;const FAn={toc:[]},VAn="wrapper";function qAn(e){let{components:n,...t}=e;return(0,s.yg)(VAn,(0,p.A)({},FAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qAn.isMDXComponent=!0;const jAn={toc:[]},HAn="wrapper";function YAn(e){let{components:n,...t}=e;return(0,s.yg)(HAn,(0,p.A)({},jAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}YAn.isMDXComponent=!0;const QAn={toc:[]},$An="wrapper";function KAn(e){let{components:n,...t}=e;return(0,s.yg)($An,(0,p.A)({},QAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}KAn.isMDXComponent=!0;const JAn={toc:[]},ZAn="wrapper";function evn(e){let{components:n,...t}=e;return(0,s.yg)(ZAn,(0,p.A)({},JAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}evn.isMDXComponent=!0;const nvn={toc:[]},tvn="wrapper";function ovn(e){let{components:n,...t}=e;return(0,s.yg)(tvn,(0,p.A)({},nvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ovn.isMDXComponent=!0;const pvn={toc:[]},rvn="wrapper";function svn(e){let{components:n,...t}=e;return(0,s.yg)(rvn,(0,p.A)({},pvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}svn.isMDXComponent=!0;const cvn={toc:[]},avn="wrapper";function ivn(e){let{components:n,...t}=e;return(0,s.yg)(avn,(0,p.A)({},cvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}ivn.isMDXComponent=!0;const lvn={toc:[]},uvn="wrapper";function mvn(e){let{components:n,...t}=e;return(0,s.yg)(uvn,(0,p.A)({},lvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}mvn.isMDXComponent=!0;const yvn={toc:[]},dvn="wrapper";function hvn(e){let{components:n,...t}=e;return(0,s.yg)(dvn,(0,p.A)({},yvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}hvn.isMDXComponent=!0;const gvn={toc:[]},fvn="wrapper";function Dvn(e){let{components:n,...t}=e;return(0,s.yg)(fvn,(0,p.A)({},gvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Dvn.isMDXComponent=!0;const Mvn={toc:[]},Xvn="wrapper";function _vn(e){let{components:n,...t}=e;return(0,s.yg)(Xvn,(0,p.A)({},Mvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}_vn.isMDXComponent=!0;const wvn={toc:[]},Tvn="wrapper";function Cvn(e){let{components:n,...t}=e;return(0,s.yg)(Tvn,(0,p.A)({},wvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Cvn.isMDXComponent=!0;const xvn={toc:[]},Avn="wrapper";function vvn(e){let{components:n,...t}=e;return(0,s.yg)(Avn,(0,p.A)({},xvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vvn.isMDXComponent=!0;const Lvn={toc:[]},bvn="wrapper";function Nvn(e){let{components:n,...t}=e;return(0,s.yg)(bvn,(0,p.A)({},Lvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Nvn.isMDXComponent=!0;const kvn={toc:[]},zvn="wrapper";function Pvn(e){let{components:n,...t}=e;return(0,s.yg)(zvn,(0,p.A)({},kvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Pvn.isMDXComponent=!0;const Ivn={toc:[]},Rvn="wrapper";function Wvn(e){let{components:n,...t}=e;return(0,s.yg)(Rvn,(0,p.A)({},Ivn,t,{components:n,mdxType:"MDXLayout"}))}Wvn.isMDXComponent=!0;const Svn={toc:[]},Bvn="wrapper";function Gvn(e){let{components:n,...t}=e;return(0,s.yg)(Bvn,(0,p.A)({},Svn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Gvn.isMDXComponent=!0;const Evn={toc:[]},Ovn="wrapper";function Uvn(e){let{components:n,...t}=e;return(0,s.yg)(Ovn,(0,p.A)({},Evn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Uvn.isMDXComponent=!0;const Fvn={toc:[]},Vvn="wrapper";function qvn(e){let{components:n,...t}=e;return(0,s.yg)(Vvn,(0,p.A)({},Fvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}qvn.isMDXComponent=!0;const jvn={toc:[]},Hvn="wrapper";function Yvn(e){let{components:n,...t}=e;return(0,s.yg)(Hvn,(0,p.A)({},jvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Yvn.isMDXComponent=!0;const Qvn={toc:[]},$vn="wrapper";function Kvn(e){let{components:n,...t}=e;return(0,s.yg)($vn,(0,p.A)({},Qvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Kvn.isMDXComponent=!0;const Jvn={toc:[]},Zvn="wrapper";function eLn(e){let{components:n,...t}=e;return(0,s.yg)(Zvn,(0,p.A)({},Jvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}eLn.isMDXComponent=!0;const nLn={toc:[]},tLn="wrapper";function oLn(e){let{components:n,...t}=e;return(0,s.yg)(tLn,(0,p.A)({},nLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}oLn.isMDXComponent=!0;const pLn={toc:[]},rLn="wrapper";function sLn(e){let{components:n,...t}=e;return(0,s.yg)(rLn,(0,p.A)({},pLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}sLn.isMDXComponent=!0;const cLn={toc:[]},aLn="wrapper";function iLn(e){let{components:n,...t}=e;return(0,s.yg)(aLn,(0,p.A)({},cLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}iLn.isMDXComponent=!0;const lLn={toc:[]},uLn="wrapper";function mLn(e){let{components:n,...t}=e;return(0,s.yg)(uLn,(0,p.A)({},lLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}mLn.isMDXComponent=!0;const yLn={toc:[]},dLn="wrapper";function hLn(e){let{components:n,...t}=e;return(0,s.yg)(dLn,(0,p.A)({},yLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}hLn.isMDXComponent=!0;const gLn={toc:[]},fLn="wrapper";function DLn(e){let{components:n,...t}=e;return(0,s.yg)(fLn,(0,p.A)({},gLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}DLn.isMDXComponent=!0;const MLn={toc:[]},XLn="wrapper";function _Ln(e){let{components:n,...t}=e;return(0,s.yg)(XLn,(0,p.A)({},MLn,t,{components:n,mdxType:"MDXLayout"}))}_Ln.isMDXComponent=!0;const wLn={toc:[]},TLn="wrapper";function CLn(e){let{components:n,...t}=e;return(0,s.yg)(TLn,(0,p.A)({},wLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}CLn.isMDXComponent=!0;const xLn={toc:[]},ALn="wrapper";function vLn(e){let{components:n,...t}=e;return(0,s.yg)(ALn,(0,p.A)({},xLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}vLn.isMDXComponent=!0;const LLn={toc:[]},bLn="wrapper";function NLn(e){let{components:n,...t}=e;return(0,s.yg)(bLn,(0,p.A)({},LLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}NLn.isMDXComponent=!0;const kLn={toc:[]},zLn="wrapper";function PLn(e){let{components:n,...t}=e;return(0,s.yg)(zLn,(0,p.A)({},kLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}PLn.isMDXComponent=!0;const ILn={toc:[]},RLn="wrapper";function WLn(e){let{components:n,...t}=e;return(0,s.yg)(RLn,(0,p.A)({},ILn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}WLn.isMDXComponent=!0;const SLn={toc:[]},BLn="wrapper";function GLn(e){let{components:n,...t}=e;return(0,s.yg)(BLn,(0,p.A)({},SLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}GLn.isMDXComponent=!0;const ELn={toc:[]},OLn="wrapper";function ULn(e){let{components:n,...t}=e;return(0,s.yg)(OLn,(0,p.A)({},ELn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ULn.isMDXComponent=!0;const FLn={toc:[]},VLn="wrapper";function qLn(e){let{components:n,...t}=e;return(0,s.yg)(VLn,(0,p.A)({},FLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}qLn.isMDXComponent=!0;const jLn={toc:[]},HLn="wrapper";function YLn(e){let{components:n,...t}=e;return(0,s.yg)(HLn,(0,p.A)({},jLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}YLn.isMDXComponent=!0;const QLn={toc:[]},$Ln="wrapper";function KLn(e){let{components:n,...t}=e;return(0,s.yg)($Ln,(0,p.A)({},QLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}KLn.isMDXComponent=!0;const JLn={toc:[]},ZLn="wrapper";function ebn(e){let{components:n,...t}=e;return(0,s.yg)(ZLn,(0,p.A)({},JLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}ebn.isMDXComponent=!0;const nbn={toc:[]},tbn="wrapper";function obn(e){let{components:n,...t}=e;return(0,s.yg)(tbn,(0,p.A)({},nbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}obn.isMDXComponent=!0;const pbn={toc:[]},rbn="wrapper";function sbn(e){let{components:n,...t}=e;return(0,s.yg)(rbn,(0,p.A)({},pbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}sbn.isMDXComponent=!0;const cbn={toc:[]},abn="wrapper";function ibn(e){let{components:n,...t}=e;return(0,s.yg)(abn,(0,p.A)({},cbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ibn.isMDXComponent=!0;const lbn={toc:[]},ubn="wrapper";function mbn(e){let{components:n,...t}=e;return(0,s.yg)(ubn,(0,p.A)({},lbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}mbn.isMDXComponent=!0;const ybn={toc:[]},dbn="wrapper";function hbn(e){let{components:n,...t}=e;return(0,s.yg)(dbn,(0,p.A)({},ybn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hbn.isMDXComponent=!0;const gbn={toc:[]},fbn="wrapper";function Dbn(e){let{components:n,...t}=e;return(0,s.yg)(fbn,(0,p.A)({},gbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Dbn.isMDXComponent=!0;const Mbn={toc:[]},Xbn="wrapper";function _bn(e){let{components:n,...t}=e;return(0,s.yg)(Xbn,(0,p.A)({},Mbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}_bn.isMDXComponent=!0;const wbn={toc:[]},Tbn="wrapper";function Cbn(e){let{components:n,...t}=e;return(0,s.yg)(Tbn,(0,p.A)({},wbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Cbn.isMDXComponent=!0;const xbn={toc:[]},Abn="wrapper";function vbn(e){let{components:n,...t}=e;return(0,s.yg)(Abn,(0,p.A)({},xbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}vbn.isMDXComponent=!0;const Lbn={toc:[]},bbn="wrapper";function Nbn(e){let{components:n,...t}=e;return(0,s.yg)(bbn,(0,p.A)({},Lbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Nbn.isMDXComponent=!0;const kbn={toc:[]},zbn="wrapper";function Pbn(e){let{components:n,...t}=e;return(0,s.yg)(zbn,(0,p.A)({},kbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Pbn.isMDXComponent=!0;const Ibn={toc:[]},Rbn="wrapper";function Wbn(e){let{components:n,...t}=e;return(0,s.yg)(Rbn,(0,p.A)({},Ibn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Wbn.isMDXComponent=!0;const Sbn={toc:[]},Bbn="wrapper";function Gbn(e){let{components:n,...t}=e;return(0,s.yg)(Bbn,(0,p.A)({},Sbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Gbn.isMDXComponent=!0;const Ebn={toc:[]},Obn="wrapper";function Ubn(e){let{components:n,...t}=e;return(0,s.yg)(Obn,(0,p.A)({},Ebn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Ubn.isMDXComponent=!0;const Fbn={toc:[]},Vbn="wrapper";function qbn(e){let{components:n,...t}=e;return(0,s.yg)(Vbn,(0,p.A)({},Fbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}qbn.isMDXComponent=!0;const jbn={toc:[]},Hbn="wrapper";function Ybn(e){let{components:n,...t}=e;return(0,s.yg)(Hbn,(0,p.A)({},jbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Ybn.isMDXComponent=!0;const Qbn={toc:[]},$bn="wrapper";function Kbn(e){let{components:n,...t}=e;return(0,s.yg)($bn,(0,p.A)({},Qbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Kbn.isMDXComponent=!0;const Jbn={toc:[]},Zbn="wrapper";function eNn(e){let{components:n,...t}=e;return(0,s.yg)(Zbn,(0,p.A)({},Jbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eNn.isMDXComponent=!0;const nNn={toc:[]},tNn="wrapper";function oNn(e){let{components:n,...t}=e;return(0,s.yg)(tNn,(0,p.A)({},nNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}oNn.isMDXComponent=!0;const pNn={toc:[]},rNn="wrapper";function sNn(e){let{components:n,...t}=e;return(0,s.yg)(rNn,(0,p.A)({},pNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}sNn.isMDXComponent=!0;const cNn={toc:[]},aNn="wrapper";function iNn(e){let{components:n,...t}=e;return(0,s.yg)(aNn,(0,p.A)({},cNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}iNn.isMDXComponent=!0;const lNn={toc:[]},uNn="wrapper";function mNn(e){let{components:n,...t}=e;return(0,s.yg)(uNn,(0,p.A)({},lNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}mNn.isMDXComponent=!0;const yNn={toc:[]},dNn="wrapper";function hNn(e){let{components:n,...t}=e;return(0,s.yg)(dNn,(0,p.A)({},yNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}hNn.isMDXComponent=!0;const gNn={toc:[]},fNn="wrapper";function DNn(e){let{components:n,...t}=e;return(0,s.yg)(fNn,(0,p.A)({},gNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}DNn.isMDXComponent=!0;const MNn={toc:[]},XNn="wrapper";function _Nn(e){let{components:n,...t}=e;return(0,s.yg)(XNn,(0,p.A)({},MNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}_Nn.isMDXComponent=!0;const wNn={toc:[]},TNn="wrapper";function CNn(e){let{components:n,...t}=e;return(0,s.yg)(TNn,(0,p.A)({},wNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}CNn.isMDXComponent=!0;const xNn={toc:[]},ANn="wrapper";function vNn(e){let{components:n,...t}=e;return(0,s.yg)(ANn,(0,p.A)({},xNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}vNn.isMDXComponent=!0;const LNn={toc:[]},bNn="wrapper";function NNn(e){let{components:n,...t}=e;return(0,s.yg)(bNn,(0,p.A)({},LNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}NNn.isMDXComponent=!0;const kNn={toc:[]},zNn="wrapper";function PNn(e){let{components:n,...t}=e;return(0,s.yg)(zNn,(0,p.A)({},kNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}PNn.isMDXComponent=!0;const INn={toc:[]},RNn="wrapper";function WNn(e){let{components:n,...t}=e;return(0,s.yg)(RNn,(0,p.A)({},INn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}WNn.isMDXComponent=!0;const SNn={toc:[]},BNn="wrapper";function GNn(e){let{components:n,...t}=e;return(0,s.yg)(BNn,(0,p.A)({},SNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}GNn.isMDXComponent=!0;const ENn={toc:[]},ONn="wrapper";function UNn(e){let{components:n,...t}=e;return(0,s.yg)(ONn,(0,p.A)({},ENn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}UNn.isMDXComponent=!0;const FNn={toc:[]},VNn="wrapper";function qNn(e){let{components:n,...t}=e;return(0,s.yg)(VNn,(0,p.A)({},FNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}qNn.isMDXComponent=!0;const jNn={toc:[]},HNn="wrapper";function YNn(e){let{components:n,...t}=e;return(0,s.yg)(HNn,(0,p.A)({},jNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}YNn.isMDXComponent=!0;const QNn={toc:[]},$Nn="wrapper";function KNn(e){let{components:n,...t}=e;return(0,s.yg)($Nn,(0,p.A)({},QNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}KNn.isMDXComponent=!0;const JNn={toc:[]},ZNn="wrapper";function ekn(e){let{components:n,...t}=e;return(0,s.yg)(ZNn,(0,p.A)({},JNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}ekn.isMDXComponent=!0;const nkn={toc:[]},tkn="wrapper";function okn(e){let{components:n,...t}=e;return(0,s.yg)(tkn,(0,p.A)({},nkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}okn.isMDXComponent=!0;const pkn={toc:[]},rkn="wrapper";function skn(e){let{components:n,...t}=e;return(0,s.yg)(rkn,(0,p.A)({},pkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}skn.isMDXComponent=!0;const ckn={toc:[]},akn="wrapper";function ikn(e){let{components:n,...t}=e;return(0,s.yg)(akn,(0,p.A)({},ckn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}ikn.isMDXComponent=!0;const lkn={toc:[]},ukn="wrapper";function mkn(e){let{components:n,...t}=e;return(0,s.yg)(ukn,(0,p.A)({},lkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mkn.isMDXComponent=!0;const ykn={toc:[]},dkn="wrapper";function hkn(e){let{components:n,...t}=e;return(0,s.yg)(dkn,(0,p.A)({},ykn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}hkn.isMDXComponent=!0;const gkn={toc:[]},fkn="wrapper";function Dkn(e){let{components:n,...t}=e;return(0,s.yg)(fkn,(0,p.A)({},gkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Dkn.isMDXComponent=!0;const Mkn={toc:[]},Xkn="wrapper";function _kn(e){let{components:n,...t}=e;return(0,s.yg)(Xkn,(0,p.A)({},Mkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}_kn.isMDXComponent=!0;const wkn={toc:[]},Tkn="wrapper";function Ckn(e){let{components:n,...t}=e;return(0,s.yg)(Tkn,(0,p.A)({},wkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Ckn.isMDXComponent=!0;const xkn={toc:[]},Akn="wrapper";function vkn(e){let{components:n,...t}=e;return(0,s.yg)(Akn,(0,p.A)({},xkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vkn.isMDXComponent=!0;const Lkn={toc:[]},bkn="wrapper";function Nkn(e){let{components:n,...t}=e;return(0,s.yg)(bkn,(0,p.A)({},Lkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Nkn.isMDXComponent=!0;const kkn={toc:[]},zkn="wrapper";function Pkn(e){let{components:n,...t}=e;return(0,s.yg)(zkn,(0,p.A)({},kkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Pkn.isMDXComponent=!0;const Ikn={toc:[]},Rkn="wrapper";function Wkn(e){let{components:n,...t}=e;return(0,s.yg)(Rkn,(0,p.A)({},Ikn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Wkn.isMDXComponent=!0;const Skn={toc:[]},Bkn="wrapper";function Gkn(e){let{components:n,...t}=e;return(0,s.yg)(Bkn,(0,p.A)({},Skn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Gkn.isMDXComponent=!0;const Ekn={toc:[]},Okn="wrapper";function Ukn(e){let{components:n,...t}=e;return(0,s.yg)(Okn,(0,p.A)({},Ekn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Ukn.isMDXComponent=!0;const Fkn={toc:[]},Vkn="wrapper";function qkn(e){let{components:n,...t}=e;return(0,s.yg)(Vkn,(0,p.A)({},Fkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qkn.isMDXComponent=!0;const jkn={toc:[]},Hkn="wrapper";function Ykn(e){let{components:n,...t}=e;return(0,s.yg)(Hkn,(0,p.A)({},jkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ykn.isMDXComponent=!0;const Qkn={toc:[]},$kn="wrapper";function Kkn(e){let{components:n,...t}=e;return(0,s.yg)($kn,(0,p.A)({},Qkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]},Zkn="wrapper";function ezn(e){let{components:n,...t}=e;return(0,s.yg)(Zkn,(0,p.A)({},Jkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}ezn.isMDXComponent=!0;const nzn={toc:[]},tzn="wrapper";function ozn(e){let{components:n,...t}=e;return(0,s.yg)(tzn,(0,p.A)({},nzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ozn.isMDXComponent=!0;const pzn={toc:[]},rzn="wrapper";function szn(e){let{components:n,...t}=e;return(0,s.yg)(rzn,(0,p.A)({},pzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}szn.isMDXComponent=!0;const czn={toc:[]},azn="wrapper";function izn(e){let{components:n,...t}=e;return(0,s.yg)(azn,(0,p.A)({},czn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}izn.isMDXComponent=!0;const lzn={toc:[]},uzn="wrapper";function mzn(e){let{components:n,...t}=e;return(0,s.yg)(uzn,(0,p.A)({},lzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}mzn.isMDXComponent=!0;const yzn={toc:[]},dzn="wrapper";function hzn(e){let{components:n,...t}=e;return(0,s.yg)(dzn,(0,p.A)({},yzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hzn.isMDXComponent=!0;const gzn={toc:[]},fzn="wrapper";function Dzn(e){let{components:n,...t}=e;return(0,s.yg)(fzn,(0,p.A)({},gzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Dzn.isMDXComponent=!0;const Mzn={toc:[]},Xzn="wrapper";function _zn(e){let{components:n,...t}=e;return(0,s.yg)(Xzn,(0,p.A)({},Mzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}_zn.isMDXComponent=!0;const wzn={toc:[]},Tzn="wrapper";function Czn(e){let{components:n,...t}=e;return(0,s.yg)(Tzn,(0,p.A)({},wzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Czn.isMDXComponent=!0;const xzn={toc:[]},Azn="wrapper";function vzn(e){let{components:n,...t}=e;return(0,s.yg)(Azn,(0,p.A)({},xzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}vzn.isMDXComponent=!0;const Lzn={toc:[]},bzn="wrapper";function Nzn(e){let{components:n,...t}=e;return(0,s.yg)(bzn,(0,p.A)({},Lzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}Nzn.isMDXComponent=!0;const kzn={toc:[]},zzn="wrapper";function Pzn(e){let{components:n,...t}=e;return(0,s.yg)(zzn,(0,p.A)({},kzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}Pzn.isMDXComponent=!0;const Izn={toc:[]},Rzn="wrapper";function Wzn(e){let{components:n,...t}=e;return(0,s.yg)(Rzn,(0,p.A)({},Izn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}Wzn.isMDXComponent=!0;const Szn={toc:[]},Bzn="wrapper";function Gzn(e){let{components:n,...t}=e;return(0,s.yg)(Bzn,(0,p.A)({},Szn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}Gzn.isMDXComponent=!0;const Ezn={toc:[]},Ozn="wrapper";function Uzn(e){let{components:n,...t}=e;return(0,s.yg)(Ozn,(0,p.A)({},Ezn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Uzn.isMDXComponent=!0;const Fzn={toc:[]},Vzn="wrapper";function qzn(e){let{components:n,...t}=e;return(0,s.yg)(Vzn,(0,p.A)({},Fzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}qzn.isMDXComponent=!0;const jzn={toc:[]},Hzn="wrapper";function Yzn(e){let{components:n,...t}=e;return(0,s.yg)(Hzn,(0,p.A)({},jzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Yzn.isMDXComponent=!0;const Qzn={toc:[]},$zn="wrapper";function Kzn(e){let{components:n,...t}=e;return(0,s.yg)($zn,(0,p.A)({},Qzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Kzn.isMDXComponent=!0;const Jzn={toc:[]},Zzn="wrapper";function ePn(e){let{components:n,...t}=e;return(0,s.yg)(Zzn,(0,p.A)({},Jzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}ePn.isMDXComponent=!0;const nPn={toc:[]},tPn="wrapper";function oPn(e){let{components:n,...t}=e;return(0,s.yg)(tPn,(0,p.A)({},nPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}oPn.isMDXComponent=!0;const pPn={toc:[]},rPn="wrapper";function sPn(e){let{components:n,...t}=e;return(0,s.yg)(rPn,(0,p.A)({},pPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}sPn.isMDXComponent=!0;const cPn={toc:[]},aPn="wrapper";function iPn(e){let{components:n,...t}=e;return(0,s.yg)(aPn,(0,p.A)({},cPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}iPn.isMDXComponent=!0;const lPn={toc:[]},uPn="wrapper";function mPn(e){let{components:n,...t}=e;return(0,s.yg)(uPn,(0,p.A)({},lPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}mPn.isMDXComponent=!0;const yPn={toc:[]},dPn="wrapper";function hPn(e){let{components:n,...t}=e;return(0,s.yg)(dPn,(0,p.A)({},yPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}hPn.isMDXComponent=!0;const gPn={toc:[]},fPn="wrapper";function DPn(e){let{components:n,...t}=e;return(0,s.yg)(fPn,(0,p.A)({},gPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}DPn.isMDXComponent=!0;const MPn={toc:[]},XPn="wrapper";function _Pn(e){let{components:n,...t}=e;return(0,s.yg)(XPn,(0,p.A)({},MPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}_Pn.isMDXComponent=!0;const wPn={toc:[]},TPn="wrapper";function CPn(e){let{components:n,...t}=e;return(0,s.yg)(TPn,(0,p.A)({},wPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}CPn.isMDXComponent=!0;const xPn={toc:[]},APn="wrapper";function vPn(e){let{components:n,...t}=e;return(0,s.yg)(APn,(0,p.A)({},xPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}vPn.isMDXComponent=!0;const LPn={toc:[]},bPn="wrapper";function NPn(e){let{components:n,...t}=e;return(0,s.yg)(bPn,(0,p.A)({},LPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}NPn.isMDXComponent=!0;const kPn={toc:[]},zPn="wrapper";function PPn(e){let{components:n,...t}=e;return(0,s.yg)(zPn,(0,p.A)({},kPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PPn.isMDXComponent=!0;const IPn={toc:[]},RPn="wrapper";function WPn(e){let{components:n,...t}=e;return(0,s.yg)(RPn,(0,p.A)({},IPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}WPn.isMDXComponent=!0;const SPn={toc:[]},BPn="wrapper";function GPn(e){let{components:n,...t}=e;return(0,s.yg)(BPn,(0,p.A)({},SPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}GPn.isMDXComponent=!0;const EPn={toc:[]},OPn="wrapper";function UPn(e){let{components:n,...t}=e;return(0,s.yg)(OPn,(0,p.A)({},EPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}UPn.isMDXComponent=!0;const FPn={toc:[]},VPn="wrapper";function qPn(e){let{components:n,...t}=e;return(0,s.yg)(VPn,(0,p.A)({},FPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}qPn.isMDXComponent=!0;const jPn={toc:[]},HPn="wrapper";function YPn(e){let{components:n,...t}=e;return(0,s.yg)(HPn,(0,p.A)({},jPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}YPn.isMDXComponent=!0;const QPn={toc:[]},$Pn="wrapper";function KPn(e){let{components:n,...t}=e;return(0,s.yg)($Pn,(0,p.A)({},QPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}KPn.isMDXComponent=!0;const JPn={toc:[]},ZPn="wrapper";function eIn(e){let{components:n,...t}=e;return(0,s.yg)(ZPn,(0,p.A)({},JPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}eIn.isMDXComponent=!0;const nIn={toc:[]},tIn="wrapper";function oIn(e){let{components:n,...t}=e;return(0,s.yg)(tIn,(0,p.A)({},nIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}oIn.isMDXComponent=!0;const pIn={toc:[]},rIn="wrapper";function sIn(e){let{components:n,...t}=e;return(0,s.yg)(rIn,(0,p.A)({},pIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}sIn.isMDXComponent=!0;const cIn={toc:[]},aIn="wrapper";function iIn(e){let{components:n,...t}=e;return(0,s.yg)(aIn,(0,p.A)({},cIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}iIn.isMDXComponent=!0;const lIn={toc:[]},uIn="wrapper";function mIn(e){let{components:n,...t}=e;return(0,s.yg)(uIn,(0,p.A)({},lIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}mIn.isMDXComponent=!0;const yIn={toc:[]},dIn="wrapper";function hIn(e){let{components:n,...t}=e;return(0,s.yg)(dIn,(0,p.A)({},yIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hIn.isMDXComponent=!0;const gIn={toc:[]},fIn="wrapper";function DIn(e){let{components:n,...t}=e;return(0,s.yg)(fIn,(0,p.A)({},gIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}DIn.isMDXComponent=!0;const MIn={toc:[]},XIn="wrapper";function _In(e){let{components:n,...t}=e;return(0,s.yg)(XIn,(0,p.A)({},MIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}_In.isMDXComponent=!0;const wIn={toc:[]},TIn="wrapper";function CIn(e){let{components:n,...t}=e;return(0,s.yg)(TIn,(0,p.A)({},wIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}CIn.isMDXComponent=!0;const xIn={toc:[]},AIn="wrapper";function vIn(e){let{components:n,...t}=e;return(0,s.yg)(AIn,(0,p.A)({},xIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}vIn.isMDXComponent=!0;const LIn={toc:[]},bIn="wrapper";function NIn(e){let{components:n,...t}=e;return(0,s.yg)(bIn,(0,p.A)({},LIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}NIn.isMDXComponent=!0;const kIn={toc:[]},zIn="wrapper";function PIn(e){let{components:n,...t}=e;return(0,s.yg)(zIn,(0,p.A)({},kIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}PIn.isMDXComponent=!0;const IIn={toc:[]},RIn="wrapper";function WIn(e){let{components:n,...t}=e;return(0,s.yg)(RIn,(0,p.A)({},IIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}WIn.isMDXComponent=!0;const SIn={toc:[]},BIn="wrapper";function GIn(e){let{components:n,...t}=e;return(0,s.yg)(BIn,(0,p.A)({},SIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}GIn.isMDXComponent=!0;const EIn={toc:[]},OIn="wrapper";function UIn(e){let{components:n,...t}=e;return(0,s.yg)(OIn,(0,p.A)({},EIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}UIn.isMDXComponent=!0;const FIn={toc:[]},VIn="wrapper";function qIn(e){let{components:n,...t}=e;return(0,s.yg)(VIn,(0,p.A)({},FIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qIn.isMDXComponent=!0;const jIn={toc:[]},HIn="wrapper";function YIn(e){let{components:n,...t}=e;return(0,s.yg)(HIn,(0,p.A)({},jIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}YIn.isMDXComponent=!0;const QIn={toc:[]},$In="wrapper";function KIn(e){let{components:n,...t}=e;return(0,s.yg)($In,(0,p.A)({},QIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}KIn.isMDXComponent=!0;const JIn={toc:[]},ZIn="wrapper";function eRn(e){let{components:n,...t}=e;return(0,s.yg)(ZIn,(0,p.A)({},JIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}eRn.isMDXComponent=!0;const nRn={toc:[]},tRn="wrapper";function oRn(e){let{components:n,...t}=e;return(0,s.yg)(tRn,(0,p.A)({},nRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}oRn.isMDXComponent=!0;const pRn={toc:[]},rRn="wrapper";function sRn(e){let{components:n,...t}=e;return(0,s.yg)(rRn,(0,p.A)({},pRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}sRn.isMDXComponent=!0;const cRn={toc:[]},aRn="wrapper";function iRn(e){let{components:n,...t}=e;return(0,s.yg)(aRn,(0,p.A)({},cRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}iRn.isMDXComponent=!0;const lRn={toc:[]},uRn="wrapper";function mRn(e){let{components:n,...t}=e;return(0,s.yg)(uRn,(0,p.A)({},lRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}mRn.isMDXComponent=!0;const yRn={toc:[]},dRn="wrapper";function hRn(e){let{components:n,...t}=e;return(0,s.yg)(dRn,(0,p.A)({},yRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}hRn.isMDXComponent=!0;const gRn={toc:[]},fRn="wrapper";function DRn(e){let{components:n,...t}=e;return(0,s.yg)(fRn,(0,p.A)({},gRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}DRn.isMDXComponent=!0;const MRn={toc:[]},XRn="wrapper";function _Rn(e){let{components:n,...t}=e;return(0,s.yg)(XRn,(0,p.A)({},MRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}_Rn.isMDXComponent=!0;const wRn={toc:[]},TRn="wrapper";function CRn(e){let{components:n,...t}=e;return(0,s.yg)(TRn,(0,p.A)({},wRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}CRn.isMDXComponent=!0;const xRn={toc:[]},ARn="wrapper";function vRn(e){let{components:n,...t}=e;return(0,s.yg)(ARn,(0,p.A)({},xRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}vRn.isMDXComponent=!0;const LRn={toc:[]},bRn="wrapper";function NRn(e){let{components:n,...t}=e;return(0,s.yg)(bRn,(0,p.A)({},LRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}NRn.isMDXComponent=!0;const kRn={toc:[]},zRn="wrapper";function PRn(e){let{components:n,...t}=e;return(0,s.yg)(zRn,(0,p.A)({},kRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}PRn.isMDXComponent=!0;const IRn={toc:[]},RRn="wrapper";function WRn(e){let{components:n,...t}=e;return(0,s.yg)(RRn,(0,p.A)({},IRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}WRn.isMDXComponent=!0;const SRn={toc:[]},BRn="wrapper";function GRn(e){let{components:n,...t}=e;return(0,s.yg)(BRn,(0,p.A)({},SRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}GRn.isMDXComponent=!0;const ERn={toc:[]},ORn="wrapper";function URn(e){let{components:n,...t}=e;return(0,s.yg)(ORn,(0,p.A)({},ERn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}URn.isMDXComponent=!0;const FRn={toc:[]},VRn="wrapper";function qRn(e){let{components:n,...t}=e;return(0,s.yg)(VRn,(0,p.A)({},FRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}qRn.isMDXComponent=!0;const jRn={toc:[]},HRn="wrapper";function YRn(e){let{components:n,...t}=e;return(0,s.yg)(HRn,(0,p.A)({},jRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}YRn.isMDXComponent=!0;const QRn={toc:[]},$Rn="wrapper";function KRn(e){let{components:n,...t}=e;return(0,s.yg)($Rn,(0,p.A)({},QRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}KRn.isMDXComponent=!0;const JRn={toc:[]},ZRn="wrapper";function eWn(e){let{components:n,...t}=e;return(0,s.yg)(ZRn,(0,p.A)({},JRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}eWn.isMDXComponent=!0;const nWn={toc:[]},tWn="wrapper";function oWn(e){let{components:n,...t}=e;return(0,s.yg)(tWn,(0,p.A)({},nWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}oWn.isMDXComponent=!0;const pWn={toc:[]},rWn="wrapper";function sWn(e){let{components:n,...t}=e;return(0,s.yg)(rWn,(0,p.A)({},pWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}sWn.isMDXComponent=!0;const cWn={toc:[]},aWn="wrapper";function iWn(e){let{components:n,...t}=e;return(0,s.yg)(aWn,(0,p.A)({},cWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}iWn.isMDXComponent=!0;const lWn={toc:[]},uWn="wrapper";function mWn(e){let{components:n,...t}=e;return(0,s.yg)(uWn,(0,p.A)({},lWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}mWn.isMDXComponent=!0;const yWn={toc:[]},dWn="wrapper";function hWn(e){let{components:n,...t}=e;return(0,s.yg)(dWn,(0,p.A)({},yWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}hWn.isMDXComponent=!0;const gWn={toc:[]},fWn="wrapper";function DWn(e){let{components:n,...t}=e;return(0,s.yg)(fWn,(0,p.A)({},gWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}DWn.isMDXComponent=!0;const MWn={toc:[]},XWn="wrapper";function _Wn(e){let{components:n,...t}=e;return(0,s.yg)(XWn,(0,p.A)({},MWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}_Wn.isMDXComponent=!0;const wWn={toc:[]},TWn="wrapper";function CWn(e){let{components:n,...t}=e;return(0,s.yg)(TWn,(0,p.A)({},wWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}CWn.isMDXComponent=!0;const xWn={toc:[]},AWn="wrapper";function vWn(e){let{components:n,...t}=e;return(0,s.yg)(AWn,(0,p.A)({},xWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}vWn.isMDXComponent=!0;const LWn={toc:[]},bWn="wrapper";function NWn(e){let{components:n,...t}=e;return(0,s.yg)(bWn,(0,p.A)({},LWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}NWn.isMDXComponent=!0;const kWn={toc:[]},zWn="wrapper";function PWn(e){let{components:n,...t}=e;return(0,s.yg)(zWn,(0,p.A)({},kWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PWn.isMDXComponent=!0;const IWn={toc:[]},RWn="wrapper";function WWn(e){let{components:n,...t}=e;return(0,s.yg)(RWn,(0,p.A)({},IWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}WWn.isMDXComponent=!0;const SWn={toc:[]},BWn="wrapper";function GWn(e){let{components:n,...t}=e;return(0,s.yg)(BWn,(0,p.A)({},SWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}GWn.isMDXComponent=!0;const EWn={toc:[]},OWn="wrapper";function UWn(e){let{components:n,...t}=e;return(0,s.yg)(OWn,(0,p.A)({},EWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}UWn.isMDXComponent=!0;const FWn={toc:[]},VWn="wrapper";function qWn(e){let{components:n,...t}=e;return(0,s.yg)(VWn,(0,p.A)({},FWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qWn.isMDXComponent=!0;const jWn={toc:[]},HWn="wrapper";function YWn(e){let{components:n,...t}=e;return(0,s.yg)(HWn,(0,p.A)({},jWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}YWn.isMDXComponent=!0;const QWn={toc:[]},$Wn="wrapper";function KWn(e){let{components:n,...t}=e;return(0,s.yg)($Wn,(0,p.A)({},QWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}KWn.isMDXComponent=!0;const JWn={toc:[]},ZWn="wrapper";function eSn(e){let{components:n,...t}=e;return(0,s.yg)(ZWn,(0,p.A)({},JWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}eSn.isMDXComponent=!0;const nSn={toc:[]},tSn="wrapper";function oSn(e){let{components:n,...t}=e;return(0,s.yg)(tSn,(0,p.A)({},nSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}oSn.isMDXComponent=!0;const pSn={toc:[]},rSn="wrapper";function sSn(e){let{components:n,...t}=e;return(0,s.yg)(rSn,(0,p.A)({},pSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}sSn.isMDXComponent=!0;const cSn={toc:[]},aSn="wrapper";function iSn(e){let{components:n,...t}=e;return(0,s.yg)(aSn,(0,p.A)({},cSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}iSn.isMDXComponent=!0;const lSn={toc:[]},uSn="wrapper";function mSn(e){let{components:n,...t}=e;return(0,s.yg)(uSn,(0,p.A)({},lSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}mSn.isMDXComponent=!0;const ySn={toc:[]},dSn="wrapper";function hSn(e){let{components:n,...t}=e;return(0,s.yg)(dSn,(0,p.A)({},ySn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}hSn.isMDXComponent=!0;const gSn={toc:[]},fSn="wrapper";function DSn(e){let{components:n,...t}=e;return(0,s.yg)(fSn,(0,p.A)({},gSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DSn.isMDXComponent=!0;const MSn={toc:[]},XSn="wrapper";function _Sn(e){let{components:n,...t}=e;return(0,s.yg)(XSn,(0,p.A)({},MSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}_Sn.isMDXComponent=!0;const wSn={toc:[]},TSn="wrapper";function CSn(e){let{components:n,...t}=e;return(0,s.yg)(TSn,(0,p.A)({},wSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}CSn.isMDXComponent=!0;const xSn={toc:[]},ASn="wrapper";function vSn(e){let{components:n,...t}=e;return(0,s.yg)(ASn,(0,p.A)({},xSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}vSn.isMDXComponent=!0;const LSn={toc:[]},bSn="wrapper";function NSn(e){let{components:n,...t}=e;return(0,s.yg)(bSn,(0,p.A)({},LSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}NSn.isMDXComponent=!0;const kSn={toc:[]},zSn="wrapper";function PSn(e){let{components:n,...t}=e;return(0,s.yg)(zSn,(0,p.A)({},kSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}PSn.isMDXComponent=!0;const ISn={toc:[]},RSn="wrapper";function WSn(e){let{components:n,...t}=e;return(0,s.yg)(RSn,(0,p.A)({},ISn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}WSn.isMDXComponent=!0;const SSn={toc:[]},BSn="wrapper";function GSn(e){let{components:n,...t}=e;return(0,s.yg)(BSn,(0,p.A)({},SSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GSn.isMDXComponent=!0;const ESn={toc:[]},OSn="wrapper";function USn(e){let{components:n,...t}=e;return(0,s.yg)(OSn,(0,p.A)({},ESn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}USn.isMDXComponent=!0;const FSn={toc:[]},VSn="wrapper";function qSn(e){let{components:n,...t}=e;return(0,s.yg)(VSn,(0,p.A)({},FSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qSn.isMDXComponent=!0;const jSn={toc:[]},HSn="wrapper";function YSn(e){let{components:n,...t}=e;return(0,s.yg)(HSn,(0,p.A)({},jSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}YSn.isMDXComponent=!0;const QSn={toc:[]},$Sn="wrapper";function KSn(e){let{components:n,...t}=e;return(0,s.yg)($Sn,(0,p.A)({},QSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}KSn.isMDXComponent=!0;const JSn={toc:[]},ZSn="wrapper";function eBn(e){let{components:n,...t}=e;return(0,s.yg)(ZSn,(0,p.A)({},JSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eBn.isMDXComponent=!0;const nBn={toc:[]},tBn="wrapper";function oBn(e){let{components:n,...t}=e;return(0,s.yg)(tBn,(0,p.A)({},nBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}oBn.isMDXComponent=!0;const pBn={toc:[]},rBn="wrapper";function sBn(e){let{components:n,...t}=e;return(0,s.yg)(rBn,(0,p.A)({},pBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}sBn.isMDXComponent=!0;const cBn={toc:[]},aBn="wrapper";function iBn(e){let{components:n,...t}=e;return(0,s.yg)(aBn,(0,p.A)({},cBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}iBn.isMDXComponent=!0;const lBn={toc:[]},uBn="wrapper";function mBn(e){let{components:n,...t}=e;return(0,s.yg)(uBn,(0,p.A)({},lBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node representing a knot of a ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.yg)("inlineCode",{parentName:"a"},"Spline")),"."))}mBn.isMDXComponent=!0;const yBn={toc:[]},dBn="wrapper";function hBn(e){let{components:n,...t}=e;return(0,s.yg)(dBn,(0,p.A)({},yBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}hBn.isMDXComponent=!0;const gBn={toc:[]},fBn="wrapper";function DBn(e){let{components:n,...t}=e;return(0,s.yg)(fBn,(0,p.A)({},gBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}DBn.isMDXComponent=!0;const MBn={toc:[]},XBn="wrapper";function _Bn(e){let{components:n,...t}=e;return(0,s.yg)(XBn,(0,p.A)({},MBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}_Bn.isMDXComponent=!0;const wBn={toc:[]},TBn="wrapper";function CBn(e){let{components:n,...t}=e;return(0,s.yg)(TBn,(0,p.A)({},wBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}CBn.isMDXComponent=!0;const xBn={toc:[]},ABn="wrapper";function vBn(e){let{components:n,...t}=e;return(0,s.yg)(ABn,(0,p.A)({},xBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}vBn.isMDXComponent=!0;const LBn={toc:[]},bBn="wrapper";function NBn(e){let{components:n,...t}=e;return(0,s.yg)(bBn,(0,p.A)({},LBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}NBn.isMDXComponent=!0;const kBn={toc:[]},zBn="wrapper";function PBn(e){let{components:n,...t}=e;return(0,s.yg)(zBn,(0,p.A)({},kBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}PBn.isMDXComponent=!0;const IBn={toc:[]},RBn="wrapper";function WBn(e){let{components:n,...t}=e;return(0,s.yg)(RBn,(0,p.A)({},IBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0"))}WBn.isMDXComponent=!0;const SBn={toc:[]},BBn="wrapper";function GBn(e){let{components:n,...t}=e;return(0,s.yg)(BBn,(0,p.A)({},SBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}GBn.isMDXComponent=!0;const EBn={toc:[]},OBn="wrapper";function UBn(e){let{components:n,...t}=e;return(0,s.yg)(OBn,(0,p.A)({},EBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}UBn.isMDXComponent=!0;const FBn={toc:[]},VBn="wrapper";function qBn(e){let{components:n,...t}=e;return(0,s.yg)(VBn,(0,p.A)({},FBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}qBn.isMDXComponent=!0;const jBn={toc:[]},HBn="wrapper";function YBn(e){let{components:n,...t}=e;return(0,s.yg)(HBn,(0,p.A)({},jBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}YBn.isMDXComponent=!0;const QBn={toc:[]},$Bn="wrapper";function KBn(e){let{components:n,...t}=e;return(0,s.yg)($Bn,(0,p.A)({},QBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mirrored position of the startHandle."))}KBn.isMDXComponent=!0;const JBn={toc:[]},ZBn="wrapper";function eGn(e){let{components:n,...t}=e;return(0,s.yg)(ZBn,(0,p.A)({},JBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}eGn.isMDXComponent=!0;const nGn={toc:[]},tGn="wrapper";function oGn(e){let{components:n,...t}=e;return(0,s.yg)(tGn,(0,p.A)({},nGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}oGn.isMDXComponent=!0;const pGn={toc:[]},rGn="wrapper";function sGn(e){let{components:n,...t}=e;return(0,s.yg)(rGn,(0,p.A)({},pGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}sGn.isMDXComponent=!0;const cGn={toc:[]},aGn="wrapper";function iGn(e){let{components:n,...t}=e;return(0,s.yg)(aGn,(0,p.A)({},cGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}iGn.isMDXComponent=!0;const lGn={toc:[]},uGn="wrapper";function mGn(e){let{components:n,...t}=e;return(0,s.yg)(uGn,(0,p.A)({},lGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}mGn.isMDXComponent=!0;const yGn={toc:[]},dGn="wrapper";function hGn(e){let{components:n,...t}=e;return(0,s.yg)(dGn,(0,p.A)({},yGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hGn.isMDXComponent=!0;const gGn={toc:[]},fGn="wrapper";function DGn(e){let{components:n,...t}=e;return(0,s.yg)(fGn,(0,p.A)({},gGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DGn.isMDXComponent=!0;const MGn={toc:[]},XGn="wrapper";function _Gn(e){let{components:n,...t}=e;return(0,s.yg)(XGn,(0,p.A)({},MGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}_Gn.isMDXComponent=!0;const wGn={toc:[]},TGn="wrapper";function CGn(e){let{components:n,...t}=e;return(0,s.yg)(TGn,(0,p.A)({},wGn,t,{components:n,mdxType:"MDXLayout"}))}CGn.isMDXComponent=!0;const xGn={toc:[]},AGn="wrapper";function vGn(e){let{components:n,...t}=e;return(0,s.yg)(AGn,(0,p.A)({},xGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}vGn.isMDXComponent=!0;const LGn={toc:[]},bGn="wrapper";function NGn(e){let{components:n,...t}=e;return(0,s.yg)(bGn,(0,p.A)({},LGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}NGn.isMDXComponent=!0;const kGn={toc:[]},zGn="wrapper";function PGn(e){let{components:n,...t}=e;return(0,s.yg)(zGn,(0,p.A)({},kGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}PGn.isMDXComponent=!0;const IGn={toc:[]},RGn="wrapper";function WGn(e){let{components:n,...t}=e;return(0,s.yg)(RGn,(0,p.A)({},IGn,t,{components:n,mdxType:"MDXLayout"}))}WGn.isMDXComponent=!0;const SGn={toc:[]},BGn="wrapper";function GGn(e){let{components:n,...t}=e;return(0,s.yg)(BGn,(0,p.A)({},SGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}GGn.isMDXComponent=!0;const EGn={toc:[]},OGn="wrapper";function UGn(e){let{components:n,...t}=e;return(0,s.yg)(OGn,(0,p.A)({},EGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mirrored position of the endHandle."))}UGn.isMDXComponent=!0;const FGn={toc:[]},VGn="wrapper";function qGn(e){let{components:n,...t}=e;return(0,s.yg)(VGn,(0,p.A)({},FGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}qGn.isMDXComponent=!0;const jGn={toc:[]},HGn="wrapper";function YGn(e){let{components:n,...t}=e;return(0,s.yg)(HGn,(0,p.A)({},jGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}YGn.isMDXComponent=!0;const QGn={toc:[]},$Gn="wrapper";function KGn(e){let{components:n,...t}=e;return(0,s.yg)($Gn,(0,p.A)({},QGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KGn.isMDXComponent=!0;const JGn={toc:[]},ZGn="wrapper";function eEn(e){let{components:n,...t}=e;return(0,s.yg)(ZGn,(0,p.A)({},JGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}eEn.isMDXComponent=!0;const nEn={toc:[]},tEn="wrapper";function oEn(e){let{components:n,...t}=e;return(0,s.yg)(tEn,(0,p.A)({},nEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}oEn.isMDXComponent=!0;const pEn={toc:[]},rEn="wrapper";function sEn(e){let{components:n,...t}=e;return(0,s.yg)(rEn,(0,p.A)({},pEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}sEn.isMDXComponent=!0;const cEn={toc:[]},aEn="wrapper";function iEn(e){let{components:n,...t}=e;return(0,s.yg)(aEn,(0,p.A)({},cEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}iEn.isMDXComponent=!0;const lEn={toc:[]},uEn="wrapper";function mEn(e){let{components:n,...t}=e;return(0,s.yg)(uEn,(0,p.A)({},lEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}mEn.isMDXComponent=!0;const yEn={toc:[]},dEn="wrapper";function hEn(e){let{components:n,...t}=e;return(0,s.yg)(dEn,(0,p.A)({},yEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}hEn.isMDXComponent=!0;const gEn={toc:[]},fEn="wrapper";function DEn(e){let{components:n,...t}=e;return(0,s.yg)(fEn,(0,p.A)({},gEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}DEn.isMDXComponent=!0;const MEn={toc:[]},XEn="wrapper";function _En(e){let{components:n,...t}=e;return(0,s.yg)(XEn,(0,p.A)({},MEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}_En.isMDXComponent=!0;const wEn={toc:[]},TEn="wrapper";function CEn(e){let{components:n,...t}=e;return(0,s.yg)(TEn,(0,p.A)({},wEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CEn.isMDXComponent=!0;const xEn={toc:[]},AEn="wrapper";function vEn(e){let{components:n,...t}=e;return(0,s.yg)(AEn,(0,p.A)({},xEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vEn.isMDXComponent=!0;const LEn={toc:[]},bEn="wrapper";function NEn(e){let{components:n,...t}=e;return(0,s.yg)(bEn,(0,p.A)({},LEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}NEn.isMDXComponent=!0;const kEn={toc:[]},zEn="wrapper";function PEn(e){let{components:n,...t}=e;return(0,s.yg)(zEn,(0,p.A)({},kEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}PEn.isMDXComponent=!0;const IEn={toc:[]},REn="wrapper";function WEn(e){let{components:n,...t}=e;return(0,s.yg)(REn,(0,p.A)({},IEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}WEn.isMDXComponent=!0;const SEn={toc:[]},BEn="wrapper";function GEn(e){let{components:n,...t}=e;return(0,s.yg)(BEn,(0,p.A)({},SEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}GEn.isMDXComponent=!0;const EEn={toc:[]},OEn="wrapper";function UEn(e){let{components:n,...t}=e;return(0,s.yg)(OEn,(0,p.A)({},EEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}UEn.isMDXComponent=!0;const FEn={toc:[]},VEn="wrapper";function qEn(e){let{components:n,...t}=e;return(0,s.yg)(VEn,(0,p.A)({},FEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}qEn.isMDXComponent=!0;const jEn={toc:[]},HEn="wrapper";function YEn(e){let{components:n,...t}=e;return(0,s.yg)(HEn,(0,p.A)({},jEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}YEn.isMDXComponent=!0;const QEn={toc:[]},$En="wrapper";function KEn(e){let{components:n,...t}=e;return(0,s.yg)($En,(0,p.A)({},QEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}KEn.isMDXComponent=!0;const JEn={toc:[]},ZEn="wrapper";function eOn(e){let{components:n,...t}=e;return(0,s.yg)(ZEn,(0,p.A)({},JEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}eOn.isMDXComponent=!0;const nOn={toc:[]},tOn="wrapper";function oOn(e){let{components:n,...t}=e;return(0,s.yg)(tOn,(0,p.A)({},nOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}oOn.isMDXComponent=!0;const pOn={toc:[]},rOn="wrapper";function sOn(e){let{components:n,...t}=e;return(0,s.yg)(rOn,(0,p.A)({},pOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sOn.isMDXComponent=!0;const cOn={toc:[]},aOn="wrapper";function iOn(e){let{components:n,...t}=e;return(0,s.yg)(aOn,(0,p.A)({},cOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}iOn.isMDXComponent=!0;const lOn={toc:[]},uOn="wrapper";function mOn(e){let{components:n,...t}=e;return(0,s.yg)(uOn,(0,p.A)({},lOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}mOn.isMDXComponent=!0;const yOn={toc:[]},dOn="wrapper";function hOn(e){let{components:n,...t}=e;return(0,s.yg)(dOn,(0,p.A)({},yOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hOn.isMDXComponent=!0;const gOn={toc:[]},fOn="wrapper";function DOn(e){let{components:n,...t}=e;return(0,s.yg)(fOn,(0,p.A)({},gOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}DOn.isMDXComponent=!0;const MOn={toc:[]},XOn="wrapper";function _On(e){let{components:n,...t}=e;return(0,s.yg)(XOn,(0,p.A)({},MOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}_On.isMDXComponent=!0;const wOn={toc:[]},TOn="wrapper";function COn(e){let{components:n,...t}=e;return(0,s.yg)(TOn,(0,p.A)({},wOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}COn.isMDXComponent=!0;const xOn={toc:[]},AOn="wrapper";function vOn(e){let{components:n,...t}=e;return(0,s.yg)(AOn,(0,p.A)({},xOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}vOn.isMDXComponent=!0;const LOn={toc:[]},bOn="wrapper";function NOn(e){let{components:n,...t}=e;return(0,s.yg)(bOn,(0,p.A)({},LOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}NOn.isMDXComponent=!0;const kOn={toc:[]},zOn="wrapper";function POn(e){let{components:n,...t}=e;return(0,s.yg)(zOn,(0,p.A)({},kOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}POn.isMDXComponent=!0;const IOn={toc:[]},ROn="wrapper";function WOn(e){let{components:n,...t}=e;return(0,s.yg)(ROn,(0,p.A)({},IOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}WOn.isMDXComponent=!0;const SOn={toc:[]},BOn="wrapper";function GOn(e){let{components:n,...t}=e;return(0,s.yg)(BOn,(0,p.A)({},SOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}GOn.isMDXComponent=!0;const EOn={toc:[]},OOn="wrapper";function UOn(e){let{components:n,...t}=e;return(0,s.yg)(OOn,(0,p.A)({},EOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}UOn.isMDXComponent=!0;const FOn={toc:[]},VOn="wrapper";function qOn(e){let{components:n,...t}=e;return(0,s.yg)(VOn,(0,p.A)({},FOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qOn.isMDXComponent=!0;const jOn={toc:[]},HOn="wrapper";function YOn(e){let{components:n,...t}=e;return(0,s.yg)(HOn,(0,p.A)({},jOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}YOn.isMDXComponent=!0;const QOn={toc:[]},$On="wrapper";function KOn(e){let{components:n,...t}=e;return(0,s.yg)($On,(0,p.A)({},QOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}KOn.isMDXComponent=!0;const JOn={toc:[]},ZOn="wrapper";function eUn(e){let{components:n,...t}=e;return(0,s.yg)(ZOn,(0,p.A)({},JOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eUn.isMDXComponent=!0;const nUn={toc:[]},tUn="wrapper";function oUn(e){let{components:n,...t}=e;return(0,s.yg)(tUn,(0,p.A)({},nUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}oUn.isMDXComponent=!0;const pUn={toc:[]},rUn="wrapper";function sUn(e){let{components:n,...t}=e;return(0,s.yg)(rUn,(0,p.A)({},pUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sUn.isMDXComponent=!0;const cUn={toc:[]},aUn="wrapper";function iUn(e){let{components:n,...t}=e;return(0,s.yg)(aUn,(0,p.A)({},cUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}iUn.isMDXComponent=!0;const lUn={toc:[]},uUn="wrapper";function mUn(e){let{components:n,...t}=e;return(0,s.yg)(uUn,(0,p.A)({},lUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mUn.isMDXComponent=!0;const yUn={toc:[]},dUn="wrapper";function hUn(e){let{components:n,...t}=e;return(0,s.yg)(dUn,(0,p.A)({},yUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}hUn.isMDXComponent=!0;const gUn={toc:[]},fUn="wrapper";function DUn(e){let{components:n,...t}=e;return(0,s.yg)(fUn,(0,p.A)({},gUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DUn.isMDXComponent=!0;const MUn={toc:[]},XUn="wrapper";function _Un(e){let{components:n,...t}=e;return(0,s.yg)(XUn,(0,p.A)({},MUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}_Un.isMDXComponent=!0;const wUn={toc:[]},TUn="wrapper";function CUn(e){let{components:n,...t}=e;return(0,s.yg)(TUn,(0,p.A)({},wUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}CUn.isMDXComponent=!0;const xUn={toc:[]},AUn="wrapper";function vUn(e){let{components:n,...t}=e;return(0,s.yg)(AUn,(0,p.A)({},xUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}vUn.isMDXComponent=!0;const LUn={toc:[]},bUn="wrapper";function NUn(e){let{components:n,...t}=e;return(0,s.yg)(bUn,(0,p.A)({},LUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}NUn.isMDXComponent=!0;const kUn={toc:[]},zUn="wrapper";function PUn(e){let{components:n,...t}=e;return(0,s.yg)(zUn,(0,p.A)({},kUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}PUn.isMDXComponent=!0;const IUn={toc:[]},RUn="wrapper";function WUn(e){let{components:n,...t}=e;return(0,s.yg)(RUn,(0,p.A)({},IUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}WUn.isMDXComponent=!0;const SUn={toc:[]},BUn="wrapper";function GUn(e){let{components:n,...t}=e;return(0,s.yg)(BUn,(0,p.A)({},SUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}GUn.isMDXComponent=!0;const EUn={toc:[]},OUn="wrapper";function UUn(e){let{components:n,...t}=e;return(0,s.yg)(OUn,(0,p.A)({},EUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}UUn.isMDXComponent=!0;const FUn={toc:[]},VUn="wrapper";function qUn(e){let{components:n,...t}=e;return(0,s.yg)(VUn,(0,p.A)({},FUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qUn.isMDXComponent=!0;const jUn={toc:[]},HUn="wrapper";function YUn(e){let{components:n,...t}=e;return(0,s.yg)(HUn,(0,p.A)({},jUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}YUn.isMDXComponent=!0;const QUn={toc:[]},$Un="wrapper";function KUn(e){let{components:n,...t}=e;return(0,s.yg)($Un,(0,p.A)({},QUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}KUn.isMDXComponent=!0;const JUn={toc:[]},ZUn="wrapper";function eFn(e){let{components:n,...t}=e;return(0,s.yg)(ZUn,(0,p.A)({},JUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}eFn.isMDXComponent=!0;const nFn={toc:[]},tFn="wrapper";function oFn(e){let{components:n,...t}=e;return(0,s.yg)(tFn,(0,p.A)({},nFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}oFn.isMDXComponent=!0;const pFn={toc:[]},rFn="wrapper";function sFn(e){let{components:n,...t}=e;return(0,s.yg)(rFn,(0,p.A)({},pFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}sFn.isMDXComponent=!0;const cFn={toc:[]},aFn="wrapper";function iFn(e){let{components:n,...t}=e;return(0,s.yg)(aFn,(0,p.A)({},cFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}iFn.isMDXComponent=!0;const lFn={toc:[]},uFn="wrapper";function mFn(e){let{components:n,...t}=e;return(0,s.yg)(uFn,(0,p.A)({},lFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}mFn.isMDXComponent=!0;const yFn={toc:[]},dFn="wrapper";function hFn(e){let{components:n,...t}=e;return(0,s.yg)(dFn,(0,p.A)({},yFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}hFn.isMDXComponent=!0;const gFn={toc:[]},fFn="wrapper";function DFn(e){let{components:n,...t}=e;return(0,s.yg)(fFn,(0,p.A)({},gFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}DFn.isMDXComponent=!0;const MFn={toc:[]},XFn="wrapper";function _Fn(e){let{components:n,...t}=e;return(0,s.yg)(XFn,(0,p.A)({},MFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}_Fn.isMDXComponent=!0;const wFn={toc:[]},TFn="wrapper";function CFn(e){let{components:n,...t}=e;return(0,s.yg)(TFn,(0,p.A)({},wFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}CFn.isMDXComponent=!0;const xFn={toc:[]},AFn="wrapper";function vFn(e){let{components:n,...t}=e;return(0,s.yg)(AFn,(0,p.A)({},xFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}vFn.isMDXComponent=!0;const LFn={toc:[]},bFn="wrapper";function NFn(e){let{components:n,...t}=e;return(0,s.yg)(bFn,(0,p.A)({},LFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}NFn.isMDXComponent=!0;const kFn={toc:[]},zFn="wrapper";function PFn(e){let{components:n,...t}=e;return(0,s.yg)(zFn,(0,p.A)({},kFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}PFn.isMDXComponent=!0;const IFn={toc:[]},RFn="wrapper";function WFn(e){let{components:n,...t}=e;return(0,s.yg)(RFn,(0,p.A)({},IFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}WFn.isMDXComponent=!0;const SFn={toc:[]},BFn="wrapper";function GFn(e){let{components:n,...t}=e;return(0,s.yg)(BFn,(0,p.A)({},SFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}GFn.isMDXComponent=!0;const EFn={toc:[]},OFn="wrapper";function UFn(e){let{components:n,...t}=e;return(0,s.yg)(OFn,(0,p.A)({},EFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}UFn.isMDXComponent=!0;const FFn={toc:[]},VFn="wrapper";function qFn(e){let{components:n,...t}=e;return(0,s.yg)(VFn,(0,p.A)({},FFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}qFn.isMDXComponent=!0;const jFn={toc:[]},HFn="wrapper";function YFn(e){let{components:n,...t}=e;return(0,s.yg)(HFn,(0,p.A)({},jFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}YFn.isMDXComponent=!0;const QFn={toc:[]},$Fn="wrapper";function KFn(e){let{components:n,...t}=e;return(0,s.yg)($Fn,(0,p.A)({},QFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}KFn.isMDXComponent=!0;const JFn={toc:[]},ZFn="wrapper";function eVn(e){let{components:n,...t}=e;return(0,s.yg)(ZFn,(0,p.A)({},JFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}eVn.isMDXComponent=!0;const nVn={toc:[]},tVn="wrapper";function oVn(e){let{components:n,...t}=e;return(0,s.yg)(tVn,(0,p.A)({},nVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}oVn.isMDXComponent=!0;const pVn={toc:[]},rVn="wrapper";function sVn(e){let{components:n,...t}=e;return(0,s.yg)(rVn,(0,p.A)({},pVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}sVn.isMDXComponent=!0;const cVn={toc:[]},aVn="wrapper";function iVn(e){let{components:n,...t}=e;return(0,s.yg)(aVn,(0,p.A)({},cVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iVn.isMDXComponent=!0;const lVn={toc:[]},uVn="wrapper";function mVn(e){let{components:n,...t}=e;return(0,s.yg)(uVn,(0,p.A)({},lVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}mVn.isMDXComponent=!0;const yVn={toc:[]},dVn="wrapper";function hVn(e){let{components:n,...t}=e;return(0,s.yg)(dVn,(0,p.A)({},yVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}hVn.isMDXComponent=!0;const gVn={toc:[]},fVn="wrapper";function DVn(e){let{components:n,...t}=e;return(0,s.yg)(fVn,(0,p.A)({},gVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}DVn.isMDXComponent=!0;const MVn={toc:[]},XVn="wrapper";function _Vn(e){let{components:n,...t}=e;return(0,s.yg)(XVn,(0,p.A)({},MVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}_Vn.isMDXComponent=!0;const wVn={toc:[]},TVn="wrapper";function CVn(e){let{components:n,...t}=e;return(0,s.yg)(TVn,(0,p.A)({},wVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}CVn.isMDXComponent=!0;const xVn={toc:[]},AVn="wrapper";function vVn(e){let{components:n,...t}=e;return(0,s.yg)(AVn,(0,p.A)({},xVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}vVn.isMDXComponent=!0;const LVn={toc:[]},bVn="wrapper";function NVn(e){let{components:n,...t}=e;return(0,s.yg)(bVn,(0,p.A)({},LVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NVn.isMDXComponent=!0;const kVn={toc:[]},zVn="wrapper";function PVn(e){let{components:n,...t}=e;return(0,s.yg)(zVn,(0,p.A)({},kVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}PVn.isMDXComponent=!0;const IVn={toc:[]},RVn="wrapper";function WVn(e){let{components:n,...t}=e;return(0,s.yg)(RVn,(0,p.A)({},IVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}WVn.isMDXComponent=!0;const SVn={toc:[]},BVn="wrapper";function GVn(e){let{components:n,...t}=e;return(0,s.yg)(BVn,(0,p.A)({},SVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}GVn.isMDXComponent=!0;const EVn={toc:[]},OVn="wrapper";function UVn(e){let{components:n,...t}=e;return(0,s.yg)(OVn,(0,p.A)({},EVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}UVn.isMDXComponent=!0;const FVn={toc:[]},VVn="wrapper";function qVn(e){let{components:n,...t}=e;return(0,s.yg)(VVn,(0,p.A)({},FVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}qVn.isMDXComponent=!0;const jVn={toc:[]},HVn="wrapper";function YVn(e){let{components:n,...t}=e;return(0,s.yg)(HVn,(0,p.A)({},jVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}YVn.isMDXComponent=!0;const QVn={toc:[]},$Vn="wrapper";function KVn(e){let{components:n,...t}=e;return(0,s.yg)($Vn,(0,p.A)({},QVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}KVn.isMDXComponent=!0;const JVn={toc:[]},ZVn="wrapper";function eqn(e){let{components:n,...t}=e;return(0,s.yg)(ZVn,(0,p.A)({},JVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}eqn.isMDXComponent=!0;const nqn={toc:[]},tqn="wrapper";function oqn(e){let{components:n,...t}=e;return(0,s.yg)(tqn,(0,p.A)({},nqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}oqn.isMDXComponent=!0;const pqn={toc:[]},rqn="wrapper";function sqn(e){let{components:n,...t}=e;return(0,s.yg)(rqn,(0,p.A)({},pqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}sqn.isMDXComponent=!0;const cqn={toc:[]},aqn="wrapper";function iqn(e){let{components:n,...t}=e;return(0,s.yg)(aqn,(0,p.A)({},cqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}iqn.isMDXComponent=!0;const lqn={toc:[]},uqn="wrapper";function mqn(e){let{components:n,...t}=e;return(0,s.yg)(uqn,(0,p.A)({},lqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}mqn.isMDXComponent=!0;const yqn={toc:[]},dqn="wrapper";function hqn(e){let{components:n,...t}=e;return(0,s.yg)(dqn,(0,p.A)({},yqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}hqn.isMDXComponent=!0;const gqn={toc:[]},fqn="wrapper";function Dqn(e){let{components:n,...t}=e;return(0,s.yg)(fqn,(0,p.A)({},gqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Dqn.isMDXComponent=!0;const Mqn={toc:[]},Xqn="wrapper";function _qn(e){let{components:n,...t}=e;return(0,s.yg)(Xqn,(0,p.A)({},Mqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_qn.isMDXComponent=!0;const wqn={toc:[]},Tqn="wrapper";function Cqn(e){let{components:n,...t}=e;return(0,s.yg)(Tqn,(0,p.A)({},wqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Cqn.isMDXComponent=!0;const xqn={toc:[]},Aqn="wrapper";function vqn(e){let{components:n,...t}=e;return(0,s.yg)(Aqn,(0,p.A)({},xqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}vqn.isMDXComponent=!0;const Lqn={toc:[]},bqn="wrapper";function Nqn(e){let{components:n,...t}=e;return(0,s.yg)(bqn,(0,p.A)({},Lqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Nqn.isMDXComponent=!0;const kqn={toc:[]},zqn="wrapper";function Pqn(e){let{components:n,...t}=e;return(0,s.yg)(zqn,(0,p.A)({},kqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pqn.isMDXComponent=!0;const Iqn={toc:[]},Rqn="wrapper";function Wqn(e){let{components:n,...t}=e;return(0,s.yg)(Rqn,(0,p.A)({},Iqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Wqn.isMDXComponent=!0;const Sqn={toc:[]},Bqn="wrapper";function Gqn(e){let{components:n,...t}=e;return(0,s.yg)(Bqn,(0,p.A)({},Sqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Gqn.isMDXComponent=!0;const Eqn={toc:[]},Oqn="wrapper";function Uqn(e){let{components:n,...t}=e;return(0,s.yg)(Oqn,(0,p.A)({},Eqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Uqn.isMDXComponent=!0;const Fqn={toc:[]},Vqn="wrapper";function qqn(e){let{components:n,...t}=e;return(0,s.yg)(Vqn,(0,p.A)({},Fqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qqn.isMDXComponent=!0;const jqn={toc:[]},Hqn="wrapper";function Yqn(e){let{components:n,...t}=e;return(0,s.yg)(Hqn,(0,p.A)({},jqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Yqn.isMDXComponent=!0;const Qqn={toc:[]},$qn="wrapper";function Kqn(e){let{components:n,...t}=e;return(0,s.yg)($qn,(0,p.A)({},Qqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Kqn.isMDXComponent=!0;const Jqn={toc:[]},Zqn="wrapper";function ejn(e){let{components:n,...t}=e;return(0,s.yg)(Zqn,(0,p.A)({},Jqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}ejn.isMDXComponent=!0;const njn={toc:[]},tjn="wrapper";function ojn(e){let{components:n,...t}=e;return(0,s.yg)(tjn,(0,p.A)({},njn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ojn.isMDXComponent=!0;const pjn={toc:[]},rjn="wrapper";function sjn(e){let{components:n,...t}=e;return(0,s.yg)(rjn,(0,p.A)({},pjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}sjn.isMDXComponent=!0;const cjn={toc:[]},ajn="wrapper";function ijn(e){let{components:n,...t}=e;return(0,s.yg)(ajn,(0,p.A)({},cjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}ijn.isMDXComponent=!0;const ljn={toc:[]},ujn="wrapper";function mjn(e){let{components:n,...t}=e;return(0,s.yg)(ujn,(0,p.A)({},ljn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}mjn.isMDXComponent=!0;const yjn={toc:[]},djn="wrapper";function hjn(e){let{components:n,...t}=e;return(0,s.yg)(djn,(0,p.A)({},yjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}hjn.isMDXComponent=!0;const gjn={toc:[]},fjn="wrapper";function Djn(e){let{components:n,...t}=e;return(0,s.yg)(fjn,(0,p.A)({},gjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Djn.isMDXComponent=!0;const Mjn={toc:[]},Xjn="wrapper";function _jn(e){let{components:n,...t}=e;return(0,s.yg)(Xjn,(0,p.A)({},Mjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}_jn.isMDXComponent=!0;const wjn={toc:[]},Tjn="wrapper";function Cjn(e){let{components:n,...t}=e;return(0,s.yg)(Tjn,(0,p.A)({},wjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Cjn.isMDXComponent=!0;const xjn={toc:[]},Ajn="wrapper";function vjn(e){let{components:n,...t}=e;return(0,s.yg)(Ajn,(0,p.A)({},xjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}vjn.isMDXComponent=!0;const Ljn={toc:[]},bjn="wrapper";function Njn(e){let{components:n,...t}=e;return(0,s.yg)(bjn,(0,p.A)({},Ljn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Njn.isMDXComponent=!0;const kjn={toc:[]},zjn="wrapper";function Pjn(e){let{components:n,...t}=e;return(0,s.yg)(zjn,(0,p.A)({},kjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Pjn.isMDXComponent=!0;const Ijn={toc:[]},Rjn="wrapper";function Wjn(e){let{components:n,...t}=e;return(0,s.yg)(Rjn,(0,p.A)({},Ijn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Wjn.isMDXComponent=!0;const Sjn={toc:[]},Bjn="wrapper";function Gjn(e){let{components:n,...t}=e;return(0,s.yg)(Bjn,(0,p.A)({},Sjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Gjn.isMDXComponent=!0;const Ejn={toc:[]},Ojn="wrapper";function Ujn(e){let{components:n,...t}=e;return(0,s.yg)(Ojn,(0,p.A)({},Ejn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Ujn.isMDXComponent=!0;const Fjn={toc:[]},Vjn="wrapper";function qjn(e){let{components:n,...t}=e;return(0,s.yg)(Vjn,(0,p.A)({},Fjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}qjn.isMDXComponent=!0;const jjn={toc:[]},Hjn="wrapper";function Yjn(e){let{components:n,...t}=e;return(0,s.yg)(Hjn,(0,p.A)({},jjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Yjn.isMDXComponent=!0;const Qjn={toc:[]},$jn="wrapper";function Kjn(e){let{components:n,...t}=e;return(0,s.yg)($jn,(0,p.A)({},Qjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Kjn.isMDXComponent=!0;const Jjn={toc:[]},Zjn="wrapper";function eHn(e){let{components:n,...t}=e;return(0,s.yg)(Zjn,(0,p.A)({},Jjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}eHn.isMDXComponent=!0;const nHn={toc:[]},tHn="wrapper";function oHn(e){let{components:n,...t}=e;return(0,s.yg)(tHn,(0,p.A)({},nHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oHn.isMDXComponent=!0;const pHn={toc:[]},rHn="wrapper";function sHn(e){let{components:n,...t}=e;return(0,s.yg)(rHn,(0,p.A)({},pHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}sHn.isMDXComponent=!0;const cHn={toc:[]},aHn="wrapper";function iHn(e){let{components:n,...t}=e;return(0,s.yg)(aHn,(0,p.A)({},cHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}iHn.isMDXComponent=!0;const lHn={toc:[]},uHn="wrapper";function mHn(e){let{components:n,...t}=e;return(0,s.yg)(uHn,(0,p.A)({},lHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for rendering equations with LaTeX."))}mHn.isMDXComponent=!0;const yHn={toc:[]},dHn="wrapper";function hHn(e){let{components:n,...t}=e;return(0,s.yg)(dHn,(0,p.A)({},yHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}hHn.isMDXComponent=!0;const gHn={toc:[]},fHn="wrapper";function DHn(e){let{components:n,...t}=e;return(0,s.yg)(fHn,(0,p.A)({},gHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}DHn.isMDXComponent=!0;const MHn={toc:[]},XHn="wrapper";function _Hn(e){let{components:n,...t}=e;return(0,s.yg)(XHn,(0,p.A)({},MHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}_Hn.isMDXComponent=!0;const wHn={toc:[]},THn="wrapper";function CHn(e){let{components:n,...t}=e;return(0,s.yg)(THn,(0,p.A)({},wHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}CHn.isMDXComponent=!0;const xHn={toc:[]},AHn="wrapper";function vHn(e){let{components:n,...t}=e;return(0,s.yg)(AHn,(0,p.A)({},xHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}vHn.isMDXComponent=!0;const LHn={toc:[]},bHn="wrapper";function NHn(e){let{components:n,...t}=e;return(0,s.yg)(bHn,(0,p.A)({},LHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}NHn.isMDXComponent=!0;const kHn={toc:[]},zHn="wrapper";function PHn(e){let{components:n,...t}=e;return(0,s.yg)(zHn,(0,p.A)({},kHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}PHn.isMDXComponent=!0;const IHn={toc:[]},RHn="wrapper";function WHn(e){let{components:n,...t}=e;return(0,s.yg)(RHn,(0,p.A)({},IHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}WHn.isMDXComponent=!0;const SHn={toc:[]},BHn="wrapper";function GHn(e){let{components:n,...t}=e;return(0,s.yg)(BHn,(0,p.A)({},SHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}GHn.isMDXComponent=!0;const EHn={toc:[]},OHn="wrapper";function UHn(e){let{components:n,...t}=e;return(0,s.yg)(OHn,(0,p.A)({},EHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}UHn.isMDXComponent=!0;const FHn={toc:[]},VHn="wrapper";function qHn(e){let{components:n,...t}=e;return(0,s.yg)(VHn,(0,p.A)({},FHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qHn.isMDXComponent=!0;const jHn={toc:[]},HHn="wrapper";function YHn(e){let{components:n,...t}=e;return(0,s.yg)(HHn,(0,p.A)({},jHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}YHn.isMDXComponent=!0;const QHn={toc:[]},$Hn="wrapper";function KHn(e){let{components:n,...t}=e;return(0,s.yg)($Hn,(0,p.A)({},QHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}KHn.isMDXComponent=!0;const JHn={toc:[]},ZHn="wrapper";function eYn(e){let{components:n,...t}=e;return(0,s.yg)(ZHn,(0,p.A)({},JHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}eYn.isMDXComponent=!0;const nYn={toc:[]},tYn="wrapper";function oYn(e){let{components:n,...t}=e;return(0,s.yg)(tYn,(0,p.A)({},nYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}oYn.isMDXComponent=!0;const pYn={toc:[]},rYn="wrapper";function sYn(e){let{components:n,...t}=e;return(0,s.yg)(rYn,(0,p.A)({},pYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}sYn.isMDXComponent=!0;const cYn={toc:[]},aYn="wrapper";function iYn(e){let{components:n,...t}=e;return(0,s.yg)(aYn,(0,p.A)({},cYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}iYn.isMDXComponent=!0;const lYn={toc:[]},uYn="wrapper";function mYn(e){let{components:n,...t}=e;return(0,s.yg)(uYn,(0,p.A)({},lYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}mYn.isMDXComponent=!0;const yYn={toc:[]},dYn="wrapper";function hYn(e){let{components:n,...t}=e;return(0,s.yg)(dYn,(0,p.A)({},yYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}hYn.isMDXComponent=!0;const gYn={toc:[]},fYn="wrapper";function DYn(e){let{components:n,...t}=e;return(0,s.yg)(fYn,(0,p.A)({},gYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}DYn.isMDXComponent=!0;const MYn={toc:[]},XYn="wrapper";function _Yn(e){let{components:n,...t}=e;return(0,s.yg)(XYn,(0,p.A)({},MYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}_Yn.isMDXComponent=!0;const wYn={toc:[]},TYn="wrapper";function CYn(e){let{components:n,...t}=e;return(0,s.yg)(TYn,(0,p.A)({},wYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}CYn.isMDXComponent=!0;const xYn={toc:[]},AYn="wrapper";function vYn(e){let{components:n,...t}=e;return(0,s.yg)(AYn,(0,p.A)({},xYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}vYn.isMDXComponent=!0;const LYn={toc:[]},bYn="wrapper";function NYn(e){let{components:n,...t}=e;return(0,s.yg)(bYn,(0,p.A)({},LYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}NYn.isMDXComponent=!0;const kYn={toc:[]},zYn="wrapper";function PYn(e){let{components:n,...t}=e;return(0,s.yg)(zYn,(0,p.A)({},kYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}PYn.isMDXComponent=!0;const IYn={toc:[]},RYn="wrapper";function WYn(e){let{components:n,...t}=e;return(0,s.yg)(RYn,(0,p.A)({},IYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}WYn.isMDXComponent=!0;const SYn={toc:[]},BYn="wrapper";function GYn(e){let{components:n,...t}=e;return(0,s.yg)(BYn,(0,p.A)({},SYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}GYn.isMDXComponent=!0;const EYn={toc:[]},OYn="wrapper";function UYn(e){let{components:n,...t}=e;return(0,s.yg)(OYn,(0,p.A)({},EYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}UYn.isMDXComponent=!0;const FYn={toc:[]},VYn="wrapper";function qYn(e){let{components:n,...t}=e;return(0,s.yg)(VYn,(0,p.A)({},FYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}qYn.isMDXComponent=!0;const jYn={toc:[]},HYn="wrapper";function YYn(e){let{components:n,...t}=e;return(0,s.yg)(HYn,(0,p.A)({},jYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}YYn.isMDXComponent=!0;const QYn={toc:[]},$Yn="wrapper";function KYn(e){let{components:n,...t}=e;return(0,s.yg)($Yn,(0,p.A)({},QYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}KYn.isMDXComponent=!0;const JYn={toc:[]},ZYn="wrapper";function eQn(e){let{components:n,...t}=e;return(0,s.yg)(ZYn,(0,p.A)({},JYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}eQn.isMDXComponent=!0;const nQn={toc:[]},tQn="wrapper";function oQn(e){let{components:n,...t}=e;return(0,s.yg)(tQn,(0,p.A)({},nQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}oQn.isMDXComponent=!0;const pQn={toc:[]},rQn="wrapper";function sQn(e){let{components:n,...t}=e;return(0,s.yg)(rQn,(0,p.A)({},pQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}sQn.isMDXComponent=!0;const cQn={toc:[]},aQn="wrapper";function iQn(e){let{components:n,...t}=e;return(0,s.yg)(aQn,(0,p.A)({},cQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}iQn.isMDXComponent=!0;const lQn={toc:[]},uQn="wrapper";function mQn(e){let{components:n,...t}=e;return(0,s.yg)(uQn,(0,p.A)({},lQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}mQn.isMDXComponent=!0;const yQn={toc:[]},dQn="wrapper";function hQn(e){let{components:n,...t}=e;return(0,s.yg)(dQn,(0,p.A)({},yQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}hQn.isMDXComponent=!0;const gQn={toc:[]},fQn="wrapper";function DQn(e){let{components:n,...t}=e;return(0,s.yg)(fQn,(0,p.A)({},gQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}DQn.isMDXComponent=!0;const MQn={toc:[]},XQn="wrapper";function _Qn(e){let{components:n,...t}=e;return(0,s.yg)(XQn,(0,p.A)({},MQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}_Qn.isMDXComponent=!0;const wQn={toc:[]},TQn="wrapper";function CQn(e){let{components:n,...t}=e;return(0,s.yg)(TQn,(0,p.A)({},wQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}CQn.isMDXComponent=!0;const xQn={toc:[]},AQn="wrapper";function vQn(e){let{components:n,...t}=e;return(0,s.yg)(AQn,(0,p.A)({},xQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}vQn.isMDXComponent=!0;const LQn={toc:[]},bQn="wrapper";function NQn(e){let{components:n,...t}=e;return(0,s.yg)(bQn,(0,p.A)({},LQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}NQn.isMDXComponent=!0;const kQn={toc:[]},zQn="wrapper";function PQn(e){let{components:n,...t}=e;return(0,s.yg)(zQn,(0,p.A)({},kQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}PQn.isMDXComponent=!0;const IQn={toc:[]},RQn="wrapper";function WQn(e){let{components:n,...t}=e;return(0,s.yg)(RQn,(0,p.A)({},IQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}WQn.isMDXComponent=!0;const SQn={toc:[]},BQn="wrapper";function GQn(e){let{components:n,...t}=e;return(0,s.yg)(BQn,(0,p.A)({},SQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}GQn.isMDXComponent=!0;const EQn={toc:[]},OQn="wrapper";function UQn(e){let{components:n,...t}=e;return(0,s.yg)(OQn,(0,p.A)({},EQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}UQn.isMDXComponent=!0;const FQn={toc:[]},VQn="wrapper";function qQn(e){let{components:n,...t}=e;return(0,s.yg)(VQn,(0,p.A)({},FQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qQn.isMDXComponent=!0;const jQn={toc:[]},HQn="wrapper";function YQn(e){let{components:n,...t}=e;return(0,s.yg)(HQn,(0,p.A)({},jQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}YQn.isMDXComponent=!0;const QQn={toc:[]},$Qn="wrapper";function KQn(e){let{components:n,...t}=e;return(0,s.yg)($Qn,(0,p.A)({},QQn,t,{components:n,mdxType:"MDXLayout"}))}KQn.isMDXComponent=!0;const JQn={toc:[]},ZQn="wrapper";function e$n(e){let{components:n,...t}=e;return(0,s.yg)(ZQn,(0,p.A)({},JQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}e$n.isMDXComponent=!0;const n$n={toc:[]},t$n="wrapper";function o$n(e){let{components:n,...t}=e;return(0,s.yg)(t$n,(0,p.A)({},n$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}o$n.isMDXComponent=!0;const p$n={toc:[]},r$n="wrapper";function s$n(e){let{components:n,...t}=e;return(0,s.yg)(r$n,(0,p.A)({},p$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}s$n.isMDXComponent=!0;const c$n={toc:[]},a$n="wrapper";function i$n(e){let{components:n,...t}=e;return(0,s.yg)(a$n,(0,p.A)({},c$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}i$n.isMDXComponent=!0;const l$n={toc:[]},u$n="wrapper";function m$n(e){let{components:n,...t}=e;return(0,s.yg)(u$n,(0,p.A)({},l$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}m$n.isMDXComponent=!0;const y$n={toc:[]},d$n="wrapper";function h$n(e){let{components:n,...t}=e;return(0,s.yg)(d$n,(0,p.A)({},y$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}h$n.isMDXComponent=!0;const g$n={toc:[]},f$n="wrapper";function D$n(e){let{components:n,...t}=e;return(0,s.yg)(f$n,(0,p.A)({},g$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}D$n.isMDXComponent=!0;const M$n={toc:[]},X$n="wrapper";function _$n(e){let{components:n,...t}=e;return(0,s.yg)(X$n,(0,p.A)({},M$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}_$n.isMDXComponent=!0;const w$n={toc:[]},T$n="wrapper";function C$n(e){let{components:n,...t}=e;return(0,s.yg)(T$n,(0,p.A)({},w$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}C$n.isMDXComponent=!0;const x$n={toc:[]},A$n="wrapper";function v$n(e){let{components:n,...t}=e;return(0,s.yg)(A$n,(0,p.A)({},x$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}v$n.isMDXComponent=!0;const L$n={toc:[]},b$n="wrapper";function N$n(e){let{components:n,...t}=e;return(0,s.yg)(b$n,(0,p.A)({},L$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}N$n.isMDXComponent=!0;const k$n={toc:[]},z$n="wrapper";function P$n(e){let{components:n,...t}=e;return(0,s.yg)(z$n,(0,p.A)({},k$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}P$n.isMDXComponent=!0;const I$n={toc:[]},R$n="wrapper";function W$n(e){let{components:n,...t}=e;return(0,s.yg)(R$n,(0,p.A)({},I$n,t,{components:n,mdxType:"MDXLayout"}))}W$n.isMDXComponent=!0;const S$n={toc:[]},B$n="wrapper";function G$n(e){let{components:n,...t}=e;return(0,s.yg)(B$n,(0,p.A)({},S$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}G$n.isMDXComponent=!0;const E$n={toc:[]},O$n="wrapper";function U$n(e){let{components:n,...t}=e;return(0,s.yg)(O$n,(0,p.A)({},E$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}U$n.isMDXComponent=!0;const F$n={toc:[]},V$n="wrapper";function q$n(e){let{components:n,...t}=e;return(0,s.yg)(V$n,(0,p.A)({},F$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}q$n.isMDXComponent=!0;const j$n={toc:[]},H$n="wrapper";function Y$n(e){let{components:n,...t}=e;return(0,s.yg)(H$n,(0,p.A)({},j$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Y$n.isMDXComponent=!0;const Q$n={toc:[]},$$n="wrapper";function K$n(e){let{components:n,...t}=e;return(0,s.yg)($$n,(0,p.A)({},Q$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}K$n.isMDXComponent=!0;const J$n={toc:[]},Z$n="wrapper";function eKn(e){let{components:n,...t}=e;return(0,s.yg)(Z$n,(0,p.A)({},J$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}eKn.isMDXComponent=!0;const nKn={toc:[]},tKn="wrapper";function oKn(e){let{components:n,...t}=e;return(0,s.yg)(tKn,(0,p.A)({},nKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}oKn.isMDXComponent=!0;const pKn={toc:[]},rKn="wrapper";function sKn(e){let{components:n,...t}=e;return(0,s.yg)(rKn,(0,p.A)({},pKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}sKn.isMDXComponent=!0;const cKn={toc:[]},aKn="wrapper";function iKn(e){let{components:n,...t}=e;return(0,s.yg)(aKn,(0,p.A)({},cKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}iKn.isMDXComponent=!0;const lKn={toc:[]},uKn="wrapper";function mKn(e){let{components:n,...t}=e;return(0,s.yg)(uKn,(0,p.A)({},lKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}mKn.isMDXComponent=!0;const yKn={toc:[]},dKn="wrapper";function hKn(e){let{components:n,...t}=e;return(0,s.yg)(dKn,(0,p.A)({},yKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}hKn.isMDXComponent=!0;const gKn={toc:[]},fKn="wrapper";function DKn(e){let{components:n,...t}=e;return(0,s.yg)(fKn,(0,p.A)({},gKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}DKn.isMDXComponent=!0;const MKn={toc:[]},XKn="wrapper";function _Kn(e){let{components:n,...t}=e;return(0,s.yg)(XKn,(0,p.A)({},MKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_Kn.isMDXComponent=!0;const wKn={toc:[]},TKn="wrapper";function CKn(e){let{components:n,...t}=e;return(0,s.yg)(TKn,(0,p.A)({},wKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}CKn.isMDXComponent=!0;const xKn={toc:[]},AKn="wrapper";function vKn(e){let{components:n,...t}=e;return(0,s.yg)(AKn,(0,p.A)({},xKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}vKn.isMDXComponent=!0;const LKn={toc:[]},bKn="wrapper";function NKn(e){let{components:n,...t}=e;return(0,s.yg)(bKn,(0,p.A)({},LKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}NKn.isMDXComponent=!0;const kKn={toc:[]},zKn="wrapper";function PKn(e){let{components:n,...t}=e;return(0,s.yg)(zKn,(0,p.A)({},kKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}PKn.isMDXComponent=!0;const IKn={toc:[]},RKn="wrapper";function WKn(e){let{components:n,...t}=e;return(0,s.yg)(RKn,(0,p.A)({},IKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}WKn.isMDXComponent=!0;const SKn={toc:[]},BKn="wrapper";function GKn(e){let{components:n,...t}=e;return(0,s.yg)(BKn,(0,p.A)({},SKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}GKn.isMDXComponent=!0;const EKn={toc:[]},OKn="wrapper";function UKn(e){let{components:n,...t}=e;return(0,s.yg)(OKn,(0,p.A)({},EKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}UKn.isMDXComponent=!0;const FKn={toc:[]},VKn="wrapper";function qKn(e){let{components:n,...t}=e;return(0,s.yg)(VKn,(0,p.A)({},FKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}qKn.isMDXComponent=!0;const jKn={toc:[]},HKn="wrapper";function YKn(e){let{components:n,...t}=e;return(0,s.yg)(HKn,(0,p.A)({},jKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}YKn.isMDXComponent=!0;const QKn={toc:[]},$Kn="wrapper";function KKn(e){let{components:n,...t}=e;return(0,s.yg)($Kn,(0,p.A)({},QKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}KKn.isMDXComponent=!0;const JKn={toc:[]},ZKn="wrapper";function eJn(e){let{components:n,...t}=e;return(0,s.yg)(ZKn,(0,p.A)({},JKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}eJn.isMDXComponent=!0;const nJn={toc:[]},tJn="wrapper";function oJn(e){let{components:n,...t}=e;return(0,s.yg)(tJn,(0,p.A)({},nJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}oJn.isMDXComponent=!0;const pJn={toc:[]},rJn="wrapper";function sJn(e){let{components:n,...t}=e;return(0,s.yg)(rJn,(0,p.A)({},pJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}sJn.isMDXComponent=!0;const cJn={toc:[]},aJn="wrapper";function iJn(e){let{components:n,...t}=e;return(0,s.yg)(aJn,(0,p.A)({},cJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}iJn.isMDXComponent=!0;const lJn={toc:[]},uJn="wrapper";function mJn(e){let{components:n,...t}=e;return(0,s.yg)(uJn,(0,p.A)({},lJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}mJn.isMDXComponent=!0;const yJn={toc:[]},dJn="wrapper";function hJn(e){let{components:n,...t}=e;return(0,s.yg)(dJn,(0,p.A)({},yJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}hJn.isMDXComponent=!0;const gJn={toc:[]},fJn="wrapper";function DJn(e){let{components:n,...t}=e;return(0,s.yg)(fJn,(0,p.A)({},gJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DJn.isMDXComponent=!0;const MJn={toc:[]},XJn="wrapper";function _Jn(e){let{components:n,...t}=e;return(0,s.yg)(XJn,(0,p.A)({},MJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}_Jn.isMDXComponent=!0;const wJn={toc:[]},TJn="wrapper";function CJn(e){let{components:n,...t}=e;return(0,s.yg)(TJn,(0,p.A)({},wJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}CJn.isMDXComponent=!0;const xJn={toc:[]},AJn="wrapper";function vJn(e){let{components:n,...t}=e;return(0,s.yg)(AJn,(0,p.A)({},xJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}vJn.isMDXComponent=!0;const LJn={toc:[]},bJn="wrapper";function NJn(e){let{components:n,...t}=e;return(0,s.yg)(bJn,(0,p.A)({},LJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}NJn.isMDXComponent=!0;const kJn={toc:[]},zJn="wrapper";function PJn(e){let{components:n,...t}=e;return(0,s.yg)(zJn,(0,p.A)({},kJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}PJn.isMDXComponent=!0;const IJn={toc:[]},RJn="wrapper";function WJn(e){let{components:n,...t}=e;return(0,s.yg)(RJn,(0,p.A)({},IJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}WJn.isMDXComponent=!0;const SJn={toc:[]},BJn="wrapper";function GJn(e){let{components:n,...t}=e;return(0,s.yg)(BJn,(0,p.A)({},SJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}GJn.isMDXComponent=!0;const EJn={toc:[]},OJn="wrapper";function UJn(e){let{components:n,...t}=e;return(0,s.yg)(OJn,(0,p.A)({},EJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}UJn.isMDXComponent=!0;const FJn={toc:[]},VJn="wrapper";function qJn(e){let{components:n,...t}=e;return(0,s.yg)(VJn,(0,p.A)({},FJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}qJn.isMDXComponent=!0;const jJn={toc:[]},HJn="wrapper";function YJn(e){let{components:n,...t}=e;return(0,s.yg)(HJn,(0,p.A)({},jJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}YJn.isMDXComponent=!0;const QJn={toc:[]},$Jn="wrapper";function KJn(e){let{components:n,...t}=e;return(0,s.yg)($Jn,(0,p.A)({},QJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}KJn.isMDXComponent=!0;const JJn={toc:[]},ZJn="wrapper";function eZn(e){let{components:n,...t}=e;return(0,s.yg)(ZJn,(0,p.A)({},JJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}eZn.isMDXComponent=!0;const nZn={toc:[]},tZn="wrapper";function oZn(e){let{components:n,...t}=e;return(0,s.yg)(tZn,(0,p.A)({},nZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}oZn.isMDXComponent=!0;const pZn={toc:[]},rZn="wrapper";function sZn(e){let{components:n,...t}=e;return(0,s.yg)(rZn,(0,p.A)({},pZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}sZn.isMDXComponent=!0;const cZn={toc:[]},aZn="wrapper";function iZn(e){let{components:n,...t}=e;return(0,s.yg)(aZn,(0,p.A)({},cZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}iZn.isMDXComponent=!0;const lZn={toc:[]},uZn="wrapper";function mZn(e){let{components:n,...t}=e;return(0,s.yg)(uZn,(0,p.A)({},lZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}mZn.isMDXComponent=!0;const yZn={toc:[]},dZn="wrapper";function hZn(e){let{components:n,...t}=e;return(0,s.yg)(dZn,(0,p.A)({},yZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}hZn.isMDXComponent=!0;const gZn={toc:[]},fZn="wrapper";function DZn(e){let{components:n,...t}=e;return(0,s.yg)(fZn,(0,p.A)({},gZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}DZn.isMDXComponent=!0;const MZn={toc:[]},XZn="wrapper";function _Zn(e){let{components:n,...t}=e;return(0,s.yg)(XZn,(0,p.A)({},MZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}_Zn.isMDXComponent=!0;const wZn={toc:[]},TZn="wrapper";function CZn(e){let{components:n,...t}=e;return(0,s.yg)(TZn,(0,p.A)({},wZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}CZn.isMDXComponent=!0;const xZn={toc:[]},AZn="wrapper";function vZn(e){let{components:n,...t}=e;return(0,s.yg)(AZn,(0,p.A)({},xZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}vZn.isMDXComponent=!0;const LZn={toc:[]},bZn="wrapper";function NZn(e){let{components:n,...t}=e;return(0,s.yg)(bZn,(0,p.A)({},LZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}NZn.isMDXComponent=!0;const kZn={toc:[]},zZn="wrapper";function PZn(e){let{components:n,...t}=e;return(0,s.yg)(zZn,(0,p.A)({},kZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}PZn.isMDXComponent=!0;const IZn={toc:[]},RZn="wrapper";function WZn(e){let{components:n,...t}=e;return(0,s.yg)(RZn,(0,p.A)({},IZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}WZn.isMDXComponent=!0;const SZn={toc:[]},BZn="wrapper";function GZn(e){let{components:n,...t}=e;return(0,s.yg)(BZn,(0,p.A)({},SZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}GZn.isMDXComponent=!0;const EZn={toc:[]},OZn="wrapper";function UZn(e){let{components:n,...t}=e;return(0,s.yg)(OZn,(0,p.A)({},EZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}UZn.isMDXComponent=!0;const FZn={toc:[]},VZn="wrapper";function qZn(e){let{components:n,...t}=e;return(0,s.yg)(VZn,(0,p.A)({},FZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}qZn.isMDXComponent=!0;const jZn={toc:[]},HZn="wrapper";function YZn(e){let{components:n,...t}=e;return(0,s.yg)(HZn,(0,p.A)({},jZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}YZn.isMDXComponent=!0;const QZn={toc:[]},$Zn="wrapper";function KZn(e){let{components:n,...t}=e;return(0,s.yg)($Zn,(0,p.A)({},QZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}KZn.isMDXComponent=!0;const JZn={toc:[]},ZZn="wrapper";function e0n(e){let{components:n,...t}=e;return(0,s.yg)(ZZn,(0,p.A)({},JZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}e0n.isMDXComponent=!0;const n0n={toc:[]},t0n="wrapper";function o0n(e){let{components:n,...t}=e;return(0,s.yg)(t0n,(0,p.A)({},n0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}o0n.isMDXComponent=!0;const p0n={toc:[]},r0n="wrapper";function s0n(e){let{components:n,...t}=e;return(0,s.yg)(r0n,(0,p.A)({},p0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}s0n.isMDXComponent=!0;const c0n={toc:[]},a0n="wrapper";function i0n(e){let{components:n,...t}=e;return(0,s.yg)(a0n,(0,p.A)({},c0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}i0n.isMDXComponent=!0;const l0n={toc:[]},u0n="wrapper";function m0n(e){let{components:n,...t}=e;return(0,s.yg)(u0n,(0,p.A)({},l0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}m0n.isMDXComponent=!0;const y0n={toc:[]},d0n="wrapper";function h0n(e){let{components:n,...t}=e;return(0,s.yg)(d0n,(0,p.A)({},y0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}h0n.isMDXComponent=!0;const g0n={toc:[]},f0n="wrapper";function D0n(e){let{components:n,...t}=e;return(0,s.yg)(f0n,(0,p.A)({},g0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}D0n.isMDXComponent=!0;const M0n={toc:[]},X0n="wrapper";function _0n(e){let{components:n,...t}=e;return(0,s.yg)(X0n,(0,p.A)({},M0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}_0n.isMDXComponent=!0;const w0n={toc:[]},T0n="wrapper";function C0n(e){let{components:n,...t}=e;return(0,s.yg)(T0n,(0,p.A)({},w0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}C0n.isMDXComponent=!0;const x0n={toc:[]},A0n="wrapper";function v0n(e){let{components:n,...t}=e;return(0,s.yg)(A0n,(0,p.A)({},x0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}v0n.isMDXComponent=!0;const L0n={toc:[]},b0n="wrapper";function N0n(e){let{components:n,...t}=e;return(0,s.yg)(b0n,(0,p.A)({},L0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}N0n.isMDXComponent=!0;const k0n={toc:[]},z0n="wrapper";function P0n(e){let{components:n,...t}=e;return(0,s.yg)(z0n,(0,p.A)({},k0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}P0n.isMDXComponent=!0;const I0n={toc:[]},R0n="wrapper";function W0n(e){let{components:n,...t}=e;return(0,s.yg)(R0n,(0,p.A)({},I0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}W0n.isMDXComponent=!0;const S0n={toc:[]},B0n="wrapper";function G0n(e){let{components:n,...t}=e;return(0,s.yg)(B0n,(0,p.A)({},S0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}G0n.isMDXComponent=!0;const E0n={toc:[]},O0n="wrapper";function U0n(e){let{components:n,...t}=e;return(0,s.yg)(O0n,(0,p.A)({},E0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}U0n.isMDXComponent=!0;const F0n={toc:[]},V0n="wrapper";function q0n(e){let{components:n,...t}=e;return(0,s.yg)(V0n,(0,p.A)({},F0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}q0n.isMDXComponent=!0;const j0n={toc:[]},H0n="wrapper";function Y0n(e){let{components:n,...t}=e;return(0,s.yg)(H0n,(0,p.A)({},j0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}Y0n.isMDXComponent=!0;const Q0n={toc:[]},$0n="wrapper";function K0n(e){let{components:n,...t}=e;return(0,s.yg)($0n,(0,p.A)({},Q0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}K0n.isMDXComponent=!0;const J0n={toc:[]},Z0n="wrapper";function e3n(e){let{components:n,...t}=e;return(0,s.yg)(Z0n,(0,p.A)({},J0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}e3n.isMDXComponent=!0;const n3n={toc:[]},t3n="wrapper";function o3n(e){let{components:n,...t}=e;return(0,s.yg)(t3n,(0,p.A)({},n3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}o3n.isMDXComponent=!0;const p3n={toc:[]},r3n="wrapper";function s3n(e){let{components:n,...t}=e;return(0,s.yg)(r3n,(0,p.A)({},p3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}s3n.isMDXComponent=!0;const c3n={toc:[]},a3n="wrapper";function i3n(e){let{components:n,...t}=e;return(0,s.yg)(a3n,(0,p.A)({},c3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}i3n.isMDXComponent=!0;const l3n={toc:[]},u3n="wrapper";function m3n(e){let{components:n,...t}=e;return(0,s.yg)(u3n,(0,p.A)({},l3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}m3n.isMDXComponent=!0;const y3n={toc:[]},d3n="wrapper";function h3n(e){let{components:n,...t}=e;return(0,s.yg)(d3n,(0,p.A)({},y3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}h3n.isMDXComponent=!0;const g3n={toc:[]},f3n="wrapper";function D3n(e){let{components:n,...t}=e;return(0,s.yg)(f3n,(0,p.A)({},g3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}D3n.isMDXComponent=!0;const M3n={toc:[]},X3n="wrapper";function _3n(e){let{components:n,...t}=e;return(0,s.yg)(X3n,(0,p.A)({},M3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}_3n.isMDXComponent=!0;const w3n={toc:[]},T3n="wrapper";function C3n(e){let{components:n,...t}=e;return(0,s.yg)(T3n,(0,p.A)({},w3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}C3n.isMDXComponent=!0;const x3n={toc:[]},A3n="wrapper";function v3n(e){let{components:n,...t}=e;return(0,s.yg)(A3n,(0,p.A)({},x3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}v3n.isMDXComponent=!0;const L3n={toc:[]},b3n="wrapper";function N3n(e){let{components:n,...t}=e;return(0,s.yg)(b3n,(0,p.A)({},L3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}N3n.isMDXComponent=!0;const k3n={toc:[]},z3n="wrapper";function P3n(e){let{components:n,...t}=e;return(0,s.yg)(z3n,(0,p.A)({},k3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}P3n.isMDXComponent=!0;const I3n={toc:[]},R3n="wrapper";function W3n(e){let{components:n,...t}=e;return(0,s.yg)(R3n,(0,p.A)({},I3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}W3n.isMDXComponent=!0;const S3n={toc:[]},B3n="wrapper";function G3n(e){let{components:n,...t}=e;return(0,s.yg)(B3n,(0,p.A)({},S3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}G3n.isMDXComponent=!0;const E3n={toc:[]},O3n="wrapper";function U3n(e){let{components:n,...t}=e;return(0,s.yg)(O3n,(0,p.A)({},E3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}U3n.isMDXComponent=!0;const F3n={toc:[]},V3n="wrapper";function q3n(e){let{components:n,...t}=e;return(0,s.yg)(V3n,(0,p.A)({},F3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}q3n.isMDXComponent=!0;const j3n={toc:[]},H3n="wrapper";function Y3n(e){let{components:n,...t}=e;return(0,s.yg)(H3n,(0,p.A)({},j3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Y3n.isMDXComponent=!0;const Q3n={toc:[]},$3n="wrapper";function K3n(e){let{components:n,...t}=e;return(0,s.yg)($3n,(0,p.A)({},Q3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}K3n.isMDXComponent=!0;const J3n={toc:[]},Z3n="wrapper";function e8n(e){let{components:n,...t}=e;return(0,s.yg)(Z3n,(0,p.A)({},J3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}e8n.isMDXComponent=!0;const n8n={toc:[]},t8n="wrapper";function o8n(e){let{components:n,...t}=e;return(0,s.yg)(t8n,(0,p.A)({},n8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}o8n.isMDXComponent=!0;const p8n={toc:[]},r8n="wrapper";function s8n(e){let{components:n,...t}=e;return(0,s.yg)(r8n,(0,p.A)({},p8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}s8n.isMDXComponent=!0;const c8n={toc:[]},a8n="wrapper";function i8n(e){let{components:n,...t}=e;return(0,s.yg)(a8n,(0,p.A)({},c8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}i8n.isMDXComponent=!0;const l8n={toc:[]},u8n="wrapper";function m8n(e){let{components:n,...t}=e;return(0,s.yg)(u8n,(0,p.A)({},l8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}m8n.isMDXComponent=!0;const y8n={toc:[]},d8n="wrapper";function h8n(e){let{components:n,...t}=e;return(0,s.yg)(d8n,(0,p.A)({},y8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}h8n.isMDXComponent=!0;const g8n={toc:[]},f8n="wrapper";function D8n(e){let{components:n,...t}=e;return(0,s.yg)(f8n,(0,p.A)({},g8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}D8n.isMDXComponent=!0;const M8n={toc:[]},X8n="wrapper";function _8n(e){let{components:n,...t}=e;return(0,s.yg)(X8n,(0,p.A)({},M8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_8n.isMDXComponent=!0;const w8n={toc:[]},T8n="wrapper";function C8n(e){let{components:n,...t}=e;return(0,s.yg)(T8n,(0,p.A)({},w8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}C8n.isMDXComponent=!0;const x8n={toc:[]},A8n="wrapper";function v8n(e){let{components:n,...t}=e;return(0,s.yg)(A8n,(0,p.A)({},x8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}v8n.isMDXComponent=!0;const L8n={toc:[]},b8n="wrapper";function N8n(e){let{components:n,...t}=e;return(0,s.yg)(b8n,(0,p.A)({},L8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}N8n.isMDXComponent=!0;const k8n={toc:[]},z8n="wrapper";function P8n(e){let{components:n,...t}=e;return(0,s.yg)(z8n,(0,p.A)({},k8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}P8n.isMDXComponent=!0;const I8n={toc:[]},R8n="wrapper";function W8n(e){let{components:n,...t}=e;return(0,s.yg)(R8n,(0,p.A)({},I8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}W8n.isMDXComponent=!0;const S8n={toc:[]},B8n="wrapper";function G8n(e){let{components:n,...t}=e;return(0,s.yg)(B8n,(0,p.A)({},S8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}G8n.isMDXComponent=!0;const E8n={toc:[]},O8n="wrapper";function U8n(e){let{components:n,...t}=e;return(0,s.yg)(O8n,(0,p.A)({},E8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}U8n.isMDXComponent=!0;const F8n={toc:[]},V8n="wrapper";function q8n(e){let{components:n,...t}=e;return(0,s.yg)(V8n,(0,p.A)({},F8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}q8n.isMDXComponent=!0;const j8n={toc:[]},H8n="wrapper";function Y8n(e){let{components:n,...t}=e;return(0,s.yg)(H8n,(0,p.A)({},j8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Y8n.isMDXComponent=!0;const Q8n={toc:[]},$8n="wrapper";function K8n(e){let{components:n,...t}=e;return(0,s.yg)($8n,(0,p.A)({},Q8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}K8n.isMDXComponent=!0;const J8n={toc:[]},Z8n="wrapper";function e2n(e){let{components:n,...t}=e;return(0,s.yg)(Z8n,(0,p.A)({},J8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}e2n.isMDXComponent=!0;const n2n={toc:[]},t2n="wrapper";function o2n(e){let{components:n,...t}=e;return(0,s.yg)(t2n,(0,p.A)({},n2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}o2n.isMDXComponent=!0;const p2n={toc:[]},r2n="wrapper";function s2n(e){let{components:n,...t}=e;return(0,s.yg)(r2n,(0,p.A)({},p2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}s2n.isMDXComponent=!0;const c2n={toc:[]},a2n="wrapper";function i2n(e){let{components:n,...t}=e;return(0,s.yg)(a2n,(0,p.A)({},c2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}i2n.isMDXComponent=!0;const l2n={toc:[]},u2n="wrapper";function m2n(e){let{components:n,...t}=e;return(0,s.yg)(u2n,(0,p.A)({},l2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}m2n.isMDXComponent=!0;const y2n={toc:[]},d2n="wrapper";function h2n(e){let{components:n,...t}=e;return(0,s.yg)(d2n,(0,p.A)({},y2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}h2n.isMDXComponent=!0;const g2n={toc:[]},f2n="wrapper";function D2n(e){let{components:n,...t}=e;return(0,s.yg)(f2n,(0,p.A)({},g2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}D2n.isMDXComponent=!0;const M2n={toc:[]},X2n="wrapper";function _2n(e){let{components:n,...t}=e;return(0,s.yg)(X2n,(0,p.A)({},M2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}_2n.isMDXComponent=!0;const w2n={toc:[]},T2n="wrapper";function C2n(e){let{components:n,...t}=e;return(0,s.yg)(T2n,(0,p.A)({},w2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}C2n.isMDXComponent=!0;const x2n={toc:[]},A2n="wrapper";function v2n(e){let{components:n,...t}=e;return(0,s.yg)(A2n,(0,p.A)({},x2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}v2n.isMDXComponent=!0;const L2n={toc:[]},b2n="wrapper";function N2n(e){let{components:n,...t}=e;return(0,s.yg)(b2n,(0,p.A)({},L2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}N2n.isMDXComponent=!0;const k2n={toc:[]},z2n="wrapper";function P2n(e){let{components:n,...t}=e;return(0,s.yg)(z2n,(0,p.A)({},k2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}P2n.isMDXComponent=!0;const I2n={toc:[]},R2n="wrapper";function W2n(e){let{components:n,...t}=e;return(0,s.yg)(R2n,(0,p.A)({},I2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}W2n.isMDXComponent=!0;const S2n={toc:[]},B2n="wrapper";function G2n(e){let{components:n,...t}=e;return(0,s.yg)(B2n,(0,p.A)({},S2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}G2n.isMDXComponent=!0;const E2n={toc:[]},O2n="wrapper";function U2n(e){let{components:n,...t}=e;return(0,s.yg)(O2n,(0,p.A)({},E2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}U2n.isMDXComponent=!0;const F2n={toc:[]},V2n="wrapper";function q2n(e){let{components:n,...t}=e;return(0,s.yg)(V2n,(0,p.A)({},F2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}q2n.isMDXComponent=!0;const j2n={toc:[]},H2n="wrapper";function Y2n(e){let{components:n,...t}=e;return(0,s.yg)(H2n,(0,p.A)({},j2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Y2n.isMDXComponent=!0;const Q2n={toc:[]},$2n="wrapper";function K2n(e){let{components:n,...t}=e;return(0,s.yg)($2n,(0,p.A)({},Q2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}K2n.isMDXComponent=!0;const J2n={toc:[]},Z2n="wrapper";function e1n(e){let{components:n,...t}=e;return(0,s.yg)(Z2n,(0,p.A)({},J2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}e1n.isMDXComponent=!0;const n1n={toc:[]},t1n="wrapper";function o1n(e){let{components:n,...t}=e;return(0,s.yg)(t1n,(0,p.A)({},n1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}o1n.isMDXComponent=!0;const p1n={toc:[]},r1n="wrapper";function s1n(e){let{components:n,...t}=e;return(0,s.yg)(r1n,(0,p.A)({},p1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}s1n.isMDXComponent=!0;const c1n={toc:[]},a1n="wrapper";function i1n(e){let{components:n,...t}=e;return(0,s.yg)(a1n,(0,p.A)({},c1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}i1n.isMDXComponent=!0;const l1n={toc:[]},u1n="wrapper";function m1n(e){let{components:n,...t}=e;return(0,s.yg)(u1n,(0,p.A)({},l1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}m1n.isMDXComponent=!0;const y1n={toc:[]},d1n="wrapper";function h1n(e){let{components:n,...t}=e;return(0,s.yg)(d1n,(0,p.A)({},y1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}h1n.isMDXComponent=!0;const g1n={toc:[]},f1n="wrapper";function D1n(e){let{components:n,...t}=e;return(0,s.yg)(f1n,(0,p.A)({},g1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}D1n.isMDXComponent=!0;const M1n={toc:[]},X1n="wrapper";function _1n(e){let{components:n,...t}=e;return(0,s.yg)(X1n,(0,p.A)({},M1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}_1n.isMDXComponent=!0;const w1n={toc:[]},T1n="wrapper";function C1n(e){let{components:n,...t}=e;return(0,s.yg)(T1n,(0,p.A)({},w1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}C1n.isMDXComponent=!0;const x1n={toc:[]},A1n="wrapper";function v1n(e){let{components:n,...t}=e;return(0,s.yg)(A1n,(0,p.A)({},x1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}v1n.isMDXComponent=!0;const L1n={toc:[]},b1n="wrapper";function N1n(e){let{components:n,...t}=e;return(0,s.yg)(b1n,(0,p.A)({},L1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}N1n.isMDXComponent=!0;const k1n={toc:[]},z1n="wrapper";function P1n(e){let{components:n,...t}=e;return(0,s.yg)(z1n,(0,p.A)({},k1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}P1n.isMDXComponent=!0;const I1n={toc:[]},R1n="wrapper";function W1n(e){let{components:n,...t}=e;return(0,s.yg)(R1n,(0,p.A)({},I1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}W1n.isMDXComponent=!0;const S1n={toc:[]},B1n="wrapper";function G1n(e){let{components:n,...t}=e;return(0,s.yg)(B1n,(0,p.A)({},S1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}G1n.isMDXComponent=!0;const E1n={toc:[]},O1n="wrapper";function U1n(e){let{components:n,...t}=e;return(0,s.yg)(O1n,(0,p.A)({},E1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}U1n.isMDXComponent=!0;const F1n={toc:[]},V1n="wrapper";function q1n(e){let{components:n,...t}=e;return(0,s.yg)(V1n,(0,p.A)({},F1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}q1n.isMDXComponent=!0;const j1n={toc:[]},H1n="wrapper";function Y1n(e){let{components:n,...t}=e;return(0,s.yg)(H1n,(0,p.A)({},j1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Y1n.isMDXComponent=!0;const Q1n={toc:[]},$1n="wrapper";function K1n(e){let{components:n,...t}=e;return(0,s.yg)($1n,(0,p.A)({},Q1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}K1n.isMDXComponent=!0;const J1n={toc:[]},Z1n="wrapper";function e4n(e){let{components:n,...t}=e;return(0,s.yg)(Z1n,(0,p.A)({},J1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}e4n.isMDXComponent=!0;const n4n={toc:[]},t4n="wrapper";function o4n(e){let{components:n,...t}=e;return(0,s.yg)(t4n,(0,p.A)({},n4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}o4n.isMDXComponent=!0;const p4n={toc:[]},r4n="wrapper";function s4n(e){let{components:n,...t}=e;return(0,s.yg)(r4n,(0,p.A)({},p4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}s4n.isMDXComponent=!0;const c4n={toc:[]},a4n="wrapper";function i4n(e){let{components:n,...t}=e;return(0,s.yg)(a4n,(0,p.A)({},c4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}i4n.isMDXComponent=!0;const l4n={toc:[]},u4n="wrapper";function m4n(e){let{components:n,...t}=e;return(0,s.yg)(u4n,(0,p.A)({},l4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}m4n.isMDXComponent=!0;const y4n={toc:[]},d4n="wrapper";function h4n(e){let{components:n,...t}=e;return(0,s.yg)(d4n,(0,p.A)({},y4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}h4n.isMDXComponent=!0;const g4n={toc:[]},f4n="wrapper";function D4n(e){let{components:n,...t}=e;return(0,s.yg)(f4n,(0,p.A)({},g4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}D4n.isMDXComponent=!0;const M4n={toc:[]},X4n="wrapper";function _4n(e){let{components:n,...t}=e;return(0,s.yg)(X4n,(0,p.A)({},M4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}_4n.isMDXComponent=!0;const w4n={toc:[]},T4n="wrapper";function C4n(e){let{components:n,...t}=e;return(0,s.yg)(T4n,(0,p.A)({},w4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}C4n.isMDXComponent=!0;const x4n={toc:[]},A4n="wrapper";function v4n(e){let{components:n,...t}=e;return(0,s.yg)(A4n,(0,p.A)({},x4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}v4n.isMDXComponent=!0;const L4n={toc:[]},b4n="wrapper";function N4n(e){let{components:n,...t}=e;return(0,s.yg)(b4n,(0,p.A)({},L4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}N4n.isMDXComponent=!0;const k4n={toc:[]},z4n="wrapper";function P4n(e){let{components:n,...t}=e;return(0,s.yg)(z4n,(0,p.A)({},k4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}P4n.isMDXComponent=!0;const I4n={toc:[]},R4n="wrapper";function W4n(e){let{components:n,...t}=e;return(0,s.yg)(R4n,(0,p.A)({},I4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}W4n.isMDXComponent=!0;const S4n={toc:[]},B4n="wrapper";function G4n(e){let{components:n,...t}=e;return(0,s.yg)(B4n,(0,p.A)({},S4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}G4n.isMDXComponent=!0;const E4n={toc:[]},O4n="wrapper";function U4n(e){let{components:n,...t}=e;return(0,s.yg)(O4n,(0,p.A)({},E4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}U4n.isMDXComponent=!0;const F4n={toc:[]},V4n="wrapper";function q4n(e){let{components:n,...t}=e;return(0,s.yg)(V4n,(0,p.A)({},F4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}q4n.isMDXComponent=!0;const j4n={toc:[]},H4n="wrapper";function Y4n(e){let{components:n,...t}=e;return(0,s.yg)(H4n,(0,p.A)({},j4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Y4n.isMDXComponent=!0;const Q4n={toc:[]},$4n="wrapper";function K4n(e){let{components:n,...t}=e;return(0,s.yg)($4n,(0,p.A)({},Q4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}K4n.isMDXComponent=!0;const J4n={toc:[]},Z4n="wrapper";function e6n(e){let{components:n,...t}=e;return(0,s.yg)(Z4n,(0,p.A)({},J4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}e6n.isMDXComponent=!0;const n6n={toc:[]},t6n="wrapper";function o6n(e){let{components:n,...t}=e;return(0,s.yg)(t6n,(0,p.A)({},n6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}o6n.isMDXComponent=!0;const p6n={toc:[]},r6n="wrapper";function s6n(e){let{components:n,...t}=e;return(0,s.yg)(r6n,(0,p.A)({},p6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}s6n.isMDXComponent=!0;const c6n={toc:[]},a6n="wrapper";function i6n(e){let{components:n,...t}=e;return(0,s.yg)(a6n,(0,p.A)({},c6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}i6n.isMDXComponent=!0;const l6n={toc:[]},u6n="wrapper";function m6n(e){let{components:n,...t}=e;return(0,s.yg)(u6n,(0,p.A)({},l6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}m6n.isMDXComponent=!0;const y6n={toc:[]},d6n="wrapper";function h6n(e){let{components:n,...t}=e;return(0,s.yg)(d6n,(0,p.A)({},y6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}h6n.isMDXComponent=!0;const g6n={toc:[]},f6n="wrapper";function D6n(e){let{components:n,...t}=e;return(0,s.yg)(f6n,(0,p.A)({},g6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}D6n.isMDXComponent=!0;const M6n={toc:[]},X6n="wrapper";function _6n(e){let{components:n,...t}=e;return(0,s.yg)(X6n,(0,p.A)({},M6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_6n.isMDXComponent=!0;const w6n={toc:[]},T6n="wrapper";function C6n(e){let{components:n,...t}=e;return(0,s.yg)(T6n,(0,p.A)({},w6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}C6n.isMDXComponent=!0;const x6n={toc:[]},A6n="wrapper";function v6n(e){let{components:n,...t}=e;return(0,s.yg)(A6n,(0,p.A)({},x6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}v6n.isMDXComponent=!0;const L6n={toc:[]},b6n="wrapper";function N6n(e){let{components:n,...t}=e;return(0,s.yg)(b6n,(0,p.A)({},L6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}N6n.isMDXComponent=!0;const k6n={toc:[]},z6n="wrapper";function P6n(e){let{components:n,...t}=e;return(0,s.yg)(z6n,(0,p.A)({},k6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}P6n.isMDXComponent=!0;const I6n={toc:[]},R6n="wrapper";function W6n(e){let{components:n,...t}=e;return(0,s.yg)(R6n,(0,p.A)({},I6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}W6n.isMDXComponent=!0;const S6n={toc:[]},B6n="wrapper";function G6n(e){let{components:n,...t}=e;return(0,s.yg)(B6n,(0,p.A)({},S6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}G6n.isMDXComponent=!0;const E6n={toc:[]},O6n="wrapper";function U6n(e){let{components:n,...t}=e;return(0,s.yg)(O6n,(0,p.A)({},E6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}U6n.isMDXComponent=!0;const F6n={toc:[]},V6n="wrapper";function q6n(e){let{components:n,...t}=e;return(0,s.yg)(V6n,(0,p.A)({},F6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}q6n.isMDXComponent=!0;const j6n={toc:[]},H6n="wrapper";function Y6n(e){let{components:n,...t}=e;return(0,s.yg)(H6n,(0,p.A)({},j6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Y6n.isMDXComponent=!0;const Q6n={toc:[]},$6n="wrapper";function K6n(e){let{components:n,...t}=e;return(0,s.yg)($6n,(0,p.A)({},Q6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}K6n.isMDXComponent=!0;const J6n={toc:[]},Z6n="wrapper";function e5n(e){let{components:n,...t}=e;return(0,s.yg)(Z6n,(0,p.A)({},J6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}e5n.isMDXComponent=!0;const n5n={toc:[]},t5n="wrapper";function o5n(e){let{components:n,...t}=e;return(0,s.yg)(t5n,(0,p.A)({},n5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}o5n.isMDXComponent=!0;const p5n={toc:[]},r5n="wrapper";function s5n(e){let{components:n,...t}=e;return(0,s.yg)(r5n,(0,p.A)({},p5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}s5n.isMDXComponent=!0;const c5n={toc:[]},a5n="wrapper";function i5n(e){let{components:n,...t}=e;return(0,s.yg)(a5n,(0,p.A)({},c5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}i5n.isMDXComponent=!0;const l5n={toc:[]},u5n="wrapper";function m5n(e){let{components:n,...t}=e;return(0,s.yg)(u5n,(0,p.A)({},l5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}m5n.isMDXComponent=!0;const y5n={toc:[]},d5n="wrapper";function h5n(e){let{components:n,...t}=e;return(0,s.yg)(d5n,(0,p.A)({},y5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}h5n.isMDXComponent=!0;const g5n={toc:[]},f5n="wrapper";function D5n(e){let{components:n,...t}=e;return(0,s.yg)(f5n,(0,p.A)({},g5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}D5n.isMDXComponent=!0;const M5n={toc:[]},X5n="wrapper";function _5n(e){let{components:n,...t}=e;return(0,s.yg)(X5n,(0,p.A)({},M5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}_5n.isMDXComponent=!0;const w5n={toc:[]},T5n="wrapper";function C5n(e){let{components:n,...t}=e;return(0,s.yg)(T5n,(0,p.A)({},w5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}C5n.isMDXComponent=!0;const x5n={toc:[]},A5n="wrapper";function v5n(e){let{components:n,...t}=e;return(0,s.yg)(A5n,(0,p.A)({},x5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}v5n.isMDXComponent=!0;const L5n={toc:[]},b5n="wrapper";function N5n(e){let{components:n,...t}=e;return(0,s.yg)(b5n,(0,p.A)({},L5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}N5n.isMDXComponent=!0;const k5n={toc:[]},z5n="wrapper";function P5n(e){let{components:n,...t}=e;return(0,s.yg)(z5n,(0,p.A)({},k5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}P5n.isMDXComponent=!0;const I5n={toc:[]},R5n="wrapper";function W5n(e){let{components:n,...t}=e;return(0,s.yg)(R5n,(0,p.A)({},I5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}W5n.isMDXComponent=!0;const S5n={toc:[]},B5n="wrapper";function G5n(e){let{components:n,...t}=e;return(0,s.yg)(B5n,(0,p.A)({},S5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}G5n.isMDXComponent=!0;const E5n={toc:[]},O5n="wrapper";function U5n(e){let{components:n,...t}=e;return(0,s.yg)(O5n,(0,p.A)({},E5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}U5n.isMDXComponent=!0;const F5n={toc:[]},V5n="wrapper";function q5n(e){let{components:n,...t}=e;return(0,s.yg)(V5n,(0,p.A)({},F5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}q5n.isMDXComponent=!0;const j5n={toc:[]},H5n="wrapper";function Y5n(e){let{components:n,...t}=e;return(0,s.yg)(H5n,(0,p.A)({},j5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Y5n.isMDXComponent=!0;const Q5n={toc:[]},$5n="wrapper";function K5n(e){let{components:n,...t}=e;return(0,s.yg)($5n,(0,p.A)({},Q5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}K5n.isMDXComponent=!0;const J5n={toc:[]},Z5n="wrapper";function e7n(e){let{components:n,...t}=e;return(0,s.yg)(Z5n,(0,p.A)({},J5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}e7n.isMDXComponent=!0;const n7n={toc:[]},t7n="wrapper";function o7n(e){let{components:n,...t}=e;return(0,s.yg)(t7n,(0,p.A)({},n7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}o7n.isMDXComponent=!0;const p7n={toc:[]},r7n="wrapper";function s7n(e){let{components:n,...t}=e;return(0,s.yg)(r7n,(0,p.A)({},p7n,t,{components:n,mdxType:"MDXLayout"}))}s7n.isMDXComponent=!0;const c7n={toc:[]},a7n="wrapper";function i7n(e){let{components:n,...t}=e;return(0,s.yg)(a7n,(0,p.A)({},c7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}i7n.isMDXComponent=!0;const l7n={toc:[]},u7n="wrapper";function m7n(e){let{components:n,...t}=e;return(0,s.yg)(u7n,(0,p.A)({},l7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}m7n.isMDXComponent=!0;const y7n={toc:[]},d7n="wrapper";function h7n(e){let{components:n,...t}=e;return(0,s.yg)(d7n,(0,p.A)({},y7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}h7n.isMDXComponent=!0;const g7n={toc:[]},f7n="wrapper";function D7n(e){let{components:n,...t}=e;return(0,s.yg)(f7n,(0,p.A)({},g7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}D7n.isMDXComponent=!0;const M7n={toc:[]},X7n="wrapper";function _7n(e){let{components:n,...t}=e;return(0,s.yg)(X7n,(0,p.A)({},M7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}_7n.isMDXComponent=!0;const w7n={toc:[]},T7n="wrapper";function C7n(e){let{components:n,...t}=e;return(0,s.yg)(T7n,(0,p.A)({},w7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}C7n.isMDXComponent=!0;const x7n={toc:[]},A7n="wrapper";function v7n(e){let{components:n,...t}=e;return(0,s.yg)(A7n,(0,p.A)({},x7n,t,{components:n,mdxType:"MDXLayout"}))}v7n.isMDXComponent=!0;const L7n={toc:[]},b7n="wrapper";function N7n(e){let{components:n,...t}=e;return(0,s.yg)(b7n,(0,p.A)({},L7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}N7n.isMDXComponent=!0;const k7n={toc:[]},z7n="wrapper";function P7n(e){let{components:n,...t}=e;return(0,s.yg)(z7n,(0,p.A)({},k7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}P7n.isMDXComponent=!0;const I7n={toc:[]},R7n="wrapper";function W7n(e){let{components:n,...t}=e;return(0,s.yg)(R7n,(0,p.A)({},I7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}W7n.isMDXComponent=!0;const S7n={toc:[]},B7n="wrapper";function G7n(e){let{components:n,...t}=e;return(0,s.yg)(B7n,(0,p.A)({},S7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}G7n.isMDXComponent=!0;const E7n={toc:[]},O7n="wrapper";function U7n(e){let{components:n,...t}=e;return(0,s.yg)(O7n,(0,p.A)({},E7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}U7n.isMDXComponent=!0;const F7n={toc:[]},V7n="wrapper";function q7n(e){let{components:n,...t}=e;return(0,s.yg)(V7n,(0,p.A)({},F7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}q7n.isMDXComponent=!0;const j7n={toc:[]},H7n="wrapper";function Y7n(e){let{components:n,...t}=e;return(0,s.yg)(H7n,(0,p.A)({},j7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Y7n.isMDXComponent=!0;const Q7n={toc:[]},$7n="wrapper";function K7n(e){let{components:n,...t}=e;return(0,s.yg)($7n,(0,p.A)({},Q7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}K7n.isMDXComponent=!0;const J7n={toc:[]},Z7n="wrapper";function e9n(e){let{components:n,...t}=e;return(0,s.yg)(Z7n,(0,p.A)({},J7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}e9n.isMDXComponent=!0;const n9n={toc:[]},t9n="wrapper";function o9n(e){let{components:n,...t}=e;return(0,s.yg)(t9n,(0,p.A)({},n9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}o9n.isMDXComponent=!0;const p9n={toc:[]},r9n="wrapper";function s9n(e){let{components:n,...t}=e;return(0,s.yg)(r9n,(0,p.A)({},p9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}s9n.isMDXComponent=!0;const c9n={toc:[]},a9n="wrapper";function i9n(e){let{components:n,...t}=e;return(0,s.yg)(a9n,(0,p.A)({},c9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}i9n.isMDXComponent=!0;const l9n={toc:[]},u9n="wrapper";function m9n(e){let{components:n,...t}=e;return(0,s.yg)(u9n,(0,p.A)({},l9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}m9n.isMDXComponent=!0;const y9n={toc:[]},d9n="wrapper";function h9n(e){let{components:n,...t}=e;return(0,s.yg)(d9n,(0,p.A)({},y9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}h9n.isMDXComponent=!0;const g9n={toc:[]},f9n="wrapper";function D9n(e){let{components:n,...t}=e;return(0,s.yg)(f9n,(0,p.A)({},g9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}D9n.isMDXComponent=!0;const M9n={toc:[]},X9n="wrapper";function _9n(e){let{components:n,...t}=e;return(0,s.yg)(X9n,(0,p.A)({},M9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}_9n.isMDXComponent=!0;const w9n={toc:[]},T9n="wrapper";function C9n(e){let{components:n,...t}=e;return(0,s.yg)(T9n,(0,p.A)({},w9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}C9n.isMDXComponent=!0;const x9n={toc:[]},A9n="wrapper";function v9n(e){let{components:n,...t}=e;return(0,s.yg)(A9n,(0,p.A)({},x9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}v9n.isMDXComponent=!0;const L9n={toc:[]},b9n="wrapper";function N9n(e){let{components:n,...t}=e;return(0,s.yg)(b9n,(0,p.A)({},L9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}N9n.isMDXComponent=!0;const k9n={toc:[]},z9n="wrapper";function P9n(e){let{components:n,...t}=e;return(0,s.yg)(z9n,(0,p.A)({},k9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}P9n.isMDXComponent=!0;const I9n={toc:[]},R9n="wrapper";function W9n(e){let{components:n,...t}=e;return(0,s.yg)(R9n,(0,p.A)({},I9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}W9n.isMDXComponent=!0;const S9n={toc:[]},B9n="wrapper";function G9n(e){let{components:n,...t}=e;return(0,s.yg)(B9n,(0,p.A)({},S9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}G9n.isMDXComponent=!0;const E9n={toc:[]},O9n="wrapper";function U9n(e){let{components:n,...t}=e;return(0,s.yg)(O9n,(0,p.A)({},E9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}U9n.isMDXComponent=!0;const F9n={toc:[]},V9n="wrapper";function q9n(e){let{components:n,...t}=e;return(0,s.yg)(V9n,(0,p.A)({},F9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}q9n.isMDXComponent=!0;const j9n={toc:[]},H9n="wrapper";function Y9n(e){let{components:n,...t}=e;return(0,s.yg)(H9n,(0,p.A)({},j9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Y9n.isMDXComponent=!0;const Q9n={toc:[]},$9n="wrapper";function K9n(e){let{components:n,...t}=e;return(0,s.yg)($9n,(0,p.A)({},Q9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}K9n.isMDXComponent=!0;const J9n={toc:[]},Z9n="wrapper";function eet(e){let{components:n,...t}=e;return(0,s.yg)(Z9n,(0,p.A)({},J9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}eet.isMDXComponent=!0;const net={toc:[]},tet="wrapper";function oet(e){let{components:n,...t}=e;return(0,s.yg)(tet,(0,p.A)({},net,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}oet.isMDXComponent=!0;const pet={toc:[]},ret="wrapper";function set(e){let{components:n,...t}=e;return(0,s.yg)(ret,(0,p.A)({},pet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}set.isMDXComponent=!0;const cet={toc:[]},aet="wrapper";function iet(e){let{components:n,...t}=e;return(0,s.yg)(aet,(0,p.A)({},cet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}iet.isMDXComponent=!0;const uet={toc:[]},met="wrapper";function yet(e){let{components:n,...t}=e;return(0,s.yg)(met,(0,p.A)({},uet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yet.isMDXComponent=!0;const det={toc:[]},het="wrapper";function get(e){let{components:n,...t}=e;return(0,s.yg)(het,(0,p.A)({},det,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}get.isMDXComponent=!0;const fet={toc:[]},Det="wrapper";function Met(e){let{components:n,...t}=e;return(0,s.yg)(Det,(0,p.A)({},fet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Met.isMDXComponent=!0;const Xet={toc:[]},_et="wrapper";function wet(e){let{components:n,...t}=e;return(0,s.yg)(_et,(0,p.A)({},Xet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wet.isMDXComponent=!0;const Tet={toc:[]},Cet="wrapper";function xet(e){let{components:n,...t}=e;return(0,s.yg)(Cet,(0,p.A)({},Tet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}xet.isMDXComponent=!0;const Aet={toc:[]},vet="wrapper";function Let(e){let{components:n,...t}=e;return(0,s.yg)(vet,(0,p.A)({},Aet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Let.isMDXComponent=!0;const bet={toc:[]},Net="wrapper";function ket(e){let{components:n,...t}=e;return(0,s.yg)(Net,(0,p.A)({},bet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}ket.isMDXComponent=!0;const zet={toc:[]},Pet="wrapper";function Iet(e){let{components:n,...t}=e;return(0,s.yg)(Pet,(0,p.A)({},zet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Iet.isMDXComponent=!0;const Ret={toc:[]},Wet="wrapper";function Set(e){let{components:n,...t}=e;return(0,s.yg)(Wet,(0,p.A)({},Ret,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Set.isMDXComponent=!0;const Bet={toc:[]},Get="wrapper";function Eet(e){let{components:n,...t}=e;return(0,s.yg)(Get,(0,p.A)({},Bet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Eet.isMDXComponent=!0;const Oet={toc:[]},Uet="wrapper";function Fet(e){let{components:n,...t}=e;return(0,s.yg)(Uet,(0,p.A)({},Oet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fet.isMDXComponent=!0;const Vet={toc:[]},qet="wrapper";function jet(e){let{components:n,...t}=e;return(0,s.yg)(qet,(0,p.A)({},Vet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}jet.isMDXComponent=!0;const Het={toc:[]},Yet="wrapper";function Qet(e){let{components:n,...t}=e;return(0,s.yg)(Yet,(0,p.A)({},Het,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qet.isMDXComponent=!0;const $et={toc:[]},Ket="wrapper";function Jet(e){let{components:n,...t}=e;return(0,s.yg)(Ket,(0,p.A)({},$et,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Jet.isMDXComponent=!0;const Zet={toc:[]},ent="wrapper";function nnt(e){let{components:n,...t}=e;return(0,s.yg)(ent,(0,p.A)({},Zet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nnt.isMDXComponent=!0;const tnt={toc:[]},ont="wrapper";function pnt(e){let{components:n,...t}=e;return(0,s.yg)(ont,(0,p.A)({},tnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}pnt.isMDXComponent=!0;const rnt={toc:[]},snt="wrapper";function cnt(e){let{components:n,...t}=e;return(0,s.yg)(snt,(0,p.A)({},rnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cnt.isMDXComponent=!0;const ant={toc:[]},int="wrapper";function lnt(e){let{components:n,...t}=e;return(0,s.yg)(int,(0,p.A)({},ant,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}lnt.isMDXComponent=!0;const unt={toc:[]},mnt="wrapper";function ynt(e){let{components:n,...t}=e;return(0,s.yg)(mnt,(0,p.A)({},unt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ynt.isMDXComponent=!0;const dnt={toc:[]},hnt="wrapper";function gnt(e){let{components:n,...t}=e;return(0,s.yg)(hnt,(0,p.A)({},dnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}gnt.isMDXComponent=!0;const fnt={toc:[]},Dnt="wrapper";function Mnt(e){let{components:n,...t}=e;return(0,s.yg)(Dnt,(0,p.A)({},fnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mnt.isMDXComponent=!0;const Xnt={toc:[]},_nt="wrapper";function wnt(e){let{components:n,...t}=e;return(0,s.yg)(_nt,(0,p.A)({},Xnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}wnt.isMDXComponent=!0;const Tnt={toc:[]},Cnt="wrapper";function xnt(e){let{components:n,...t}=e;return(0,s.yg)(Cnt,(0,p.A)({},Tnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xnt.isMDXComponent=!0;const Ant={toc:[]},vnt="wrapper";function Lnt(e){let{components:n,...t}=e;return(0,s.yg)(vnt,(0,p.A)({},Ant,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Lnt.isMDXComponent=!0;const bnt={toc:[]},Nnt="wrapper";function knt(e){let{components:n,...t}=e;return(0,s.yg)(Nnt,(0,p.A)({},bnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}knt.isMDXComponent=!0;const znt={toc:[]},Pnt="wrapper";function Int(e){let{components:n,...t}=e;return(0,s.yg)(Pnt,(0,p.A)({},znt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Int.isMDXComponent=!0;const Rnt={toc:[]},Wnt="wrapper";function Snt(e){let{components:n,...t}=e;return(0,s.yg)(Wnt,(0,p.A)({},Rnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Snt.isMDXComponent=!0;const Bnt={toc:[]},Gnt="wrapper";function Ent(e){let{components:n,...t}=e;return(0,s.yg)(Gnt,(0,p.A)({},Bnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ent.isMDXComponent=!0;const Ont={toc:[]},Unt="wrapper";function Fnt(e){let{components:n,...t}=e;return(0,s.yg)(Unt,(0,p.A)({},Ont,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Fnt.isMDXComponent=!0;const Vnt={toc:[]},qnt="wrapper";function jnt(e){let{components:n,...t}=e;return(0,s.yg)(qnt,(0,p.A)({},Vnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}jnt.isMDXComponent=!0;const Hnt={toc:[]},Ynt="wrapper";function Qnt(e){let{components:n,...t}=e;return(0,s.yg)(Ynt,(0,p.A)({},Hnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Qnt.isMDXComponent=!0;const $nt={toc:[]},Knt="wrapper";function Jnt(e){let{components:n,...t}=e;return(0,s.yg)(Knt,(0,p.A)({},$nt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Jnt.isMDXComponent=!0;const Znt={toc:[]},ett="wrapper";function ntt(e){let{components:n,...t}=e;return(0,s.yg)(ett,(0,p.A)({},Znt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}ntt.isMDXComponent=!0;const ttt={toc:[]},ott="wrapper";function ptt(e){let{components:n,...t}=e;return(0,s.yg)(ott,(0,p.A)({},ttt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}ptt.isMDXComponent=!0;const rtt={toc:[]},stt="wrapper";function ctt(e){let{components:n,...t}=e;return(0,s.yg)(stt,(0,p.A)({},rtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}ctt.isMDXComponent=!0;const att={toc:[]},itt="wrapper";function ltt(e){let{components:n,...t}=e;return(0,s.yg)(itt,(0,p.A)({},att,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}ltt.isMDXComponent=!0;const utt={toc:[]},mtt="wrapper";function ytt(e){let{components:n,...t}=e;return(0,s.yg)(mtt,(0,p.A)({},utt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}ytt.isMDXComponent=!0;const dtt={toc:[]},htt="wrapper";function gtt(e){let{components:n,...t}=e;return(0,s.yg)(htt,(0,p.A)({},dtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gtt.isMDXComponent=!0;const ftt={toc:[]},Dtt="wrapper";function Mtt(e){let{components:n,...t}=e;return(0,s.yg)(Dtt,(0,p.A)({},ftt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Mtt.isMDXComponent=!0;const Xtt={toc:[]},_tt="wrapper";function wtt(e){let{components:n,...t}=e;return(0,s.yg)(_tt,(0,p.A)({},Xtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wtt.isMDXComponent=!0;const Ttt={toc:[]},Ctt="wrapper";function xtt(e){let{components:n,...t}=e;return(0,s.yg)(Ctt,(0,p.A)({},Ttt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}xtt.isMDXComponent=!0;const Att={toc:[]},vtt="wrapper";function Ltt(e){let{components:n,...t}=e;return(0,s.yg)(vtt,(0,p.A)({},Att,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Ltt.isMDXComponent=!0;const btt={toc:[]},Ntt="wrapper";function ktt(e){let{components:n,...t}=e;return(0,s.yg)(Ntt,(0,p.A)({},btt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ktt.isMDXComponent=!0;const ztt={toc:[]},Ptt="wrapper";function Itt(e){let{components:n,...t}=e;return(0,s.yg)(Ptt,(0,p.A)({},ztt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Itt.isMDXComponent=!0;const Rtt={toc:[]},Wtt="wrapper";function Stt(e){let{components:n,...t}=e;return(0,s.yg)(Wtt,(0,p.A)({},Rtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Stt.isMDXComponent=!0;const Btt={toc:[]},Gtt="wrapper";function Ett(e){let{components:n,...t}=e;return(0,s.yg)(Gtt,(0,p.A)({},Btt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Ett.isMDXComponent=!0;const Ott={toc:[]},Utt="wrapper";function Ftt(e){let{components:n,...t}=e;return(0,s.yg)(Utt,(0,p.A)({},Ott,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Ftt.isMDXComponent=!0;const Vtt={toc:[]},qtt="wrapper";function jtt(e){let{components:n,...t}=e;return(0,s.yg)(qtt,(0,p.A)({},Vtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}jtt.isMDXComponent=!0;const Htt={toc:[]},Ytt="wrapper";function Qtt(e){let{components:n,...t}=e;return(0,s.yg)(Ytt,(0,p.A)({},Htt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Qtt.isMDXComponent=!0;const $tt={toc:[]},Ktt="wrapper";function Jtt(e){let{components:n,...t}=e;return(0,s.yg)(Ktt,(0,p.A)({},$tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Jtt.isMDXComponent=!0;const Ztt={toc:[]},eot="wrapper";function not(e){let{components:n,...t}=e;return(0,s.yg)(eot,(0,p.A)({},Ztt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}not.isMDXComponent=!0;const tot={toc:[]},oot="wrapper";function pot(e){let{components:n,...t}=e;return(0,s.yg)(oot,(0,p.A)({},tot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pot.isMDXComponent=!0;const rot={toc:[]},sot="wrapper";function cot(e){let{components:n,...t}=e;return(0,s.yg)(sot,(0,p.A)({},rot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}cot.isMDXComponent=!0;const aot={toc:[]},iot="wrapper";function lot(e){let{components:n,...t}=e;return(0,s.yg)(iot,(0,p.A)({},aot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}lot.isMDXComponent=!0;const uot={toc:[]},mot="wrapper";function yot(e){let{components:n,...t}=e;return(0,s.yg)(mot,(0,p.A)({},uot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}yot.isMDXComponent=!0;const dot={toc:[]},hot="wrapper";function got(e){let{components:n,...t}=e;return(0,s.yg)(hot,(0,p.A)({},dot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}got.isMDXComponent=!0;const fot={toc:[]},Dot="wrapper";function Mot(e){let{components:n,...t}=e;return(0,s.yg)(Dot,(0,p.A)({},fot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Mot.isMDXComponent=!0;const Xot={toc:[]},_ot="wrapper";function wot(e){let{components:n,...t}=e;return(0,s.yg)(_ot,(0,p.A)({},Xot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wot.isMDXComponent=!0;const Tot={toc:[]},Cot="wrapper";function xot(e){let{components:n,...t}=e;return(0,s.yg)(Cot,(0,p.A)({},Tot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}xot.isMDXComponent=!0;const Aot={toc:[]},vot="wrapper";function Lot(e){let{components:n,...t}=e;return(0,s.yg)(vot,(0,p.A)({},Aot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Lot.isMDXComponent=!0;const bot={toc:[]},Not="wrapper";function kot(e){let{components:n,...t}=e;return(0,s.yg)(Not,(0,p.A)({},bot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}kot.isMDXComponent=!0;const zot={toc:[]},Pot="wrapper";function Iot(e){let{components:n,...t}=e;return(0,s.yg)(Pot,(0,p.A)({},zot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Iot.isMDXComponent=!0;const Rot={toc:[]},Wot="wrapper";function Sot(e){let{components:n,...t}=e;return(0,s.yg)(Wot,(0,p.A)({},Rot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Sot.isMDXComponent=!0;const Bot={toc:[]},Got="wrapper";function Eot(e){let{components:n,...t}=e;return(0,s.yg)(Got,(0,p.A)({},Bot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Eot.isMDXComponent=!0;const Oot={toc:[]},Uot="wrapper";function Fot(e){let{components:n,...t}=e;return(0,s.yg)(Uot,(0,p.A)({},Oot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fot.isMDXComponent=!0;const Vot={toc:[]},qot="wrapper";function jot(e){let{components:n,...t}=e;return(0,s.yg)(qot,(0,p.A)({},Vot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}jot.isMDXComponent=!0;const Hot={toc:[]},Yot="wrapper";function Qot(e){let{components:n,...t}=e;return(0,s.yg)(Yot,(0,p.A)({},Hot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Qot.isMDXComponent=!0;const $ot={toc:[]},Kot="wrapper";function Jot(e){let{components:n,...t}=e;return(0,s.yg)(Kot,(0,p.A)({},$ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Jot.isMDXComponent=!0;const Zot={toc:[]},ept="wrapper";function npt(e){let{components:n,...t}=e;return(0,s.yg)(ept,(0,p.A)({},Zot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}npt.isMDXComponent=!0;const tpt={toc:[]},opt="wrapper";function ppt(e){let{components:n,...t}=e;return(0,s.yg)(opt,(0,p.A)({},tpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}ppt.isMDXComponent=!0;const rpt={toc:[]},spt="wrapper";function cpt(e){let{components:n,...t}=e;return(0,s.yg)(spt,(0,p.A)({},rpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}cpt.isMDXComponent=!0;const apt={toc:[]},ipt="wrapper";function lpt(e){let{components:n,...t}=e;return(0,s.yg)(ipt,(0,p.A)({},apt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}lpt.isMDXComponent=!0;const upt={toc:[]},mpt="wrapper";function ypt(e){let{components:n,...t}=e;return(0,s.yg)(mpt,(0,p.A)({},upt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}ypt.isMDXComponent=!0;const dpt={toc:[]},hpt="wrapper";function gpt(e){let{components:n,...t}=e;return(0,s.yg)(hpt,(0,p.A)({},dpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}gpt.isMDXComponent=!0;const fpt={toc:[]},Dpt="wrapper";function Mpt(e){let{components:n,...t}=e;return(0,s.yg)(Dpt,(0,p.A)({},fpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Mpt.isMDXComponent=!0;const Xpt={toc:[]},_pt="wrapper";function wpt(e){let{components:n,...t}=e;return(0,s.yg)(_pt,(0,p.A)({},Xpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}wpt.isMDXComponent=!0;const Tpt={toc:[]},Cpt="wrapper";function xpt(e){let{components:n,...t}=e;return(0,s.yg)(Cpt,(0,p.A)({},Tpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}xpt.isMDXComponent=!0;const Apt={toc:[]},vpt="wrapper";function Lpt(e){let{components:n,...t}=e;return(0,s.yg)(vpt,(0,p.A)({},Apt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Lpt.isMDXComponent=!0;const bpt={toc:[]},Npt="wrapper";function kpt(e){let{components:n,...t}=e;return(0,s.yg)(Npt,(0,p.A)({},bpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}kpt.isMDXComponent=!0;const zpt={toc:[]},Ppt="wrapper";function Ipt(e){let{components:n,...t}=e;return(0,s.yg)(Ppt,(0,p.A)({},zpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Ipt.isMDXComponent=!0;const Rpt={toc:[]},Wpt="wrapper";function Spt(e){let{components:n,...t}=e;return(0,s.yg)(Wpt,(0,p.A)({},Rpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Spt.isMDXComponent=!0;const Bpt={toc:[]},Gpt="wrapper";function Ept(e){let{components:n,...t}=e;return(0,s.yg)(Gpt,(0,p.A)({},Bpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Ept.isMDXComponent=!0;const Opt={toc:[]},Upt="wrapper";function Fpt(e){let{components:n,...t}=e;return(0,s.yg)(Upt,(0,p.A)({},Opt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Fpt.isMDXComponent=!0;const Vpt={toc:[]},qpt="wrapper";function jpt(e){let{components:n,...t}=e;return(0,s.yg)(qpt,(0,p.A)({},Vpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}jpt.isMDXComponent=!0;const Hpt={toc:[]},Ypt="wrapper";function Qpt(e){let{components:n,...t}=e;return(0,s.yg)(Ypt,(0,p.A)({},Hpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Qpt.isMDXComponent=!0;const $pt={toc:[]},Kpt="wrapper";function Jpt(e){let{components:n,...t}=e;return(0,s.yg)(Kpt,(0,p.A)({},$pt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Jpt.isMDXComponent=!0;const Zpt={toc:[]},ert="wrapper";function nrt(e){let{components:n,...t}=e;return(0,s.yg)(ert,(0,p.A)({},Zpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}nrt.isMDXComponent=!0;const trt={toc:[]},ort="wrapper";function prt(e){let{components:n,...t}=e;return(0,s.yg)(ort,(0,p.A)({},trt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}prt.isMDXComponent=!0;const rrt={toc:[]},srt="wrapper";function crt(e){let{components:n,...t}=e;return(0,s.yg)(srt,(0,p.A)({},rrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}crt.isMDXComponent=!0;const art={toc:[]},irt="wrapper";function lrt(e){let{components:n,...t}=e;return(0,s.yg)(irt,(0,p.A)({},art,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}lrt.isMDXComponent=!0;const urt={toc:[]},mrt="wrapper";function yrt(e){let{components:n,...t}=e;return(0,s.yg)(mrt,(0,p.A)({},urt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}yrt.isMDXComponent=!0;const drt={toc:[]},hrt="wrapper";function grt(e){let{components:n,...t}=e;return(0,s.yg)(hrt,(0,p.A)({},drt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}grt.isMDXComponent=!0;const frt={toc:[]},Drt="wrapper";function Mrt(e){let{components:n,...t}=e;return(0,s.yg)(Drt,(0,p.A)({},frt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Mrt.isMDXComponent=!0;const Xrt={toc:[]},_rt="wrapper";function wrt(e){let{components:n,...t}=e;return(0,s.yg)(_rt,(0,p.A)({},Xrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}wrt.isMDXComponent=!0;const Trt={toc:[]},Crt="wrapper";function xrt(e){let{components:n,...t}=e;return(0,s.yg)(Crt,(0,p.A)({},Trt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xrt.isMDXComponent=!0;const Art={toc:[]},vrt="wrapper";function Lrt(e){let{components:n,...t}=e;return(0,s.yg)(vrt,(0,p.A)({},Art,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Lrt.isMDXComponent=!0;const brt={toc:[]},Nrt="wrapper";function krt(e){let{components:n,...t}=e;return(0,s.yg)(Nrt,(0,p.A)({},brt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}krt.isMDXComponent=!0;const zrt={toc:[]},Prt="wrapper";function Irt(e){let{components:n,...t}=e;return(0,s.yg)(Prt,(0,p.A)({},zrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Irt.isMDXComponent=!0;const Rrt={toc:[]},Wrt="wrapper";function Srt(e){let{components:n,...t}=e;return(0,s.yg)(Wrt,(0,p.A)({},Rrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Srt.isMDXComponent=!0;const Brt={toc:[]},Grt="wrapper";function Ert(e){let{components:n,...t}=e;return(0,s.yg)(Grt,(0,p.A)({},Brt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Ert.isMDXComponent=!0;const Ort={toc:[]},Urt="wrapper";function Frt(e){let{components:n,...t}=e;return(0,s.yg)(Urt,(0,p.A)({},Ort,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Frt.isMDXComponent=!0;const Vrt={toc:[]},qrt="wrapper";function jrt(e){let{components:n,...t}=e;return(0,s.yg)(qrt,(0,p.A)({},Vrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}jrt.isMDXComponent=!0;const Hrt={toc:[]},Yrt="wrapper";function Qrt(e){let{components:n,...t}=e;return(0,s.yg)(Yrt,(0,p.A)({},Hrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Qrt.isMDXComponent=!0;const $rt={toc:[]},Krt="wrapper";function Jrt(e){let{components:n,...t}=e;return(0,s.yg)(Krt,(0,p.A)({},$rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Jrt.isMDXComponent=!0;const Zrt={toc:[]},est="wrapper";function nst(e){let{components:n,...t}=e;return(0,s.yg)(est,(0,p.A)({},Zrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}nst.isMDXComponent=!0;const tst={toc:[]},ost="wrapper";function pst(e){let{components:n,...t}=e;return(0,s.yg)(ost,(0,p.A)({},tst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}pst.isMDXComponent=!0;const rst={toc:[]},sst="wrapper";function cst(e){let{components:n,...t}=e;return(0,s.yg)(sst,(0,p.A)({},rst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cst.isMDXComponent=!0;const ast={toc:[]},ist="wrapper";function lst(e){let{components:n,...t}=e;return(0,s.yg)(ist,(0,p.A)({},ast,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lst.isMDXComponent=!0;const ust={toc:[]},mst="wrapper";function yst(e){let{components:n,...t}=e;return(0,s.yg)(mst,(0,p.A)({},ust,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}yst.isMDXComponent=!0;const dst={toc:[]},hst="wrapper";function gst(e){let{components:n,...t}=e;return(0,s.yg)(hst,(0,p.A)({},dst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gst.isMDXComponent=!0;const fst={toc:[]},Dst="wrapper";function Mst(e){let{components:n,...t}=e;return(0,s.yg)(Dst,(0,p.A)({},fst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Mst.isMDXComponent=!0;const Xst={toc:[]},_st="wrapper";function wst(e){let{components:n,...t}=e;return(0,s.yg)(_st,(0,p.A)({},Xst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wst.isMDXComponent=!0;const Tst={toc:[]},Cst="wrapper";function xst(e){let{components:n,...t}=e;return(0,s.yg)(Cst,(0,p.A)({},Tst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xst.isMDXComponent=!0;const Ast={toc:[]},vst="wrapper";function Lst(e){let{components:n,...t}=e;return(0,s.yg)(vst,(0,p.A)({},Ast,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Lst.isMDXComponent=!0;const bst={toc:[]},Nst="wrapper";function kst(e){let{components:n,...t}=e;return(0,s.yg)(Nst,(0,p.A)({},bst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kst.isMDXComponent=!0;const zst={toc:[]},Pst="wrapper";function Ist(e){let{components:n,...t}=e;return(0,s.yg)(Pst,(0,p.A)({},zst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Ist.isMDXComponent=!0;const Rst={toc:[]},Wst="wrapper";function Sst(e){let{components:n,...t}=e;return(0,s.yg)(Wst,(0,p.A)({},Rst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render any polygonal shape defined by a set of\npoints."))}Sst.isMDXComponent=!0;const Bst={toc:[]},Gst="wrapper";function Est(e){let{components:n,...t}=e;return(0,s.yg)(Gst,(0,p.A)({},Bst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple line\nimport {makeScene2D, Line} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [150, 50],\n        [0, -50],\n        [-150, 50],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={40}\n      startArrow\n    />,\n  );\n});\n\n// snippet Polygon\nimport {makeScene2D, Line} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [-200, 70],\n        [150, 70],\n        [100, -70],\n        [-100, -70],\n      ]}\n      fill={'lightseagreen'}\n      closed\n    />,\n  );\n});\n\n// snippet Using signals\nimport {makeScene2D, Line} from '@revideo/2d';\nimport {createSignal} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const tip = createSignal(-150);\n  view.add(\n    <Line\n      points={[\n        [-150, 70],\n        [150, 70],\n        // this point is dynamically calculated based on the signal:\n        () => [tip(), -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      closed\n    />,\n  );\n\n  yield* tip(150, 1).back(1);\n});\n\n// snippet Tweening points\nimport {makeScene2D, Line} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const line = createRef<Line>();\n  view.add(\n    <Line\n      ref={line}\n      points={[\n        [-150, 70],\n        [150, 70],\n        [0, -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={20}\n      closed\n    />,\n  );\n\n  yield* line()\n    .points(\n      [\n        [-150, 0],\n        [0, 100],\n        [150, 0],\n        [150, -70],\n        [-150, -70],\n      ],\n      2,\n    )\n    .back(2);\n});\n")))}Est.isMDXComponent=!0;const Ost={toc:[]},Ust="wrapper";function Fst(e){let{components:n,...t}=e;return(0,s.yg)(Ust,(0,p.A)({},Ost,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing lines and polygons."))}Fst.isMDXComponent=!0;const Vst={toc:[]},qst="wrapper";function jst(e){let{components:n,...t}=e;return(0,s.yg)(qst,(0,p.A)({},Vst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}jst.isMDXComponent=!0;const Hst={toc:[]},Yst="wrapper";function Qst(e){let{components:n,...t}=e;return(0,s.yg)(Yst,(0,p.A)({},Hst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Qst.isMDXComponent=!0;const $st={toc:[]},Kst="wrapper";function Jst(e){let{components:n,...t}=e;return(0,s.yg)(Kst,(0,p.A)({},$st,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Jst.isMDXComponent=!0;const Zst={toc:[]},ect="wrapper";function nct(e){let{components:n,...t}=e;return(0,s.yg)(ect,(0,p.A)({},Zst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}nct.isMDXComponent=!0;const tct={toc:[]},oct="wrapper";function pct(e){let{components:n,...t}=e;return(0,s.yg)(oct,(0,p.A)({},tct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}pct.isMDXComponent=!0;const rct={toc:[]},sct="wrapper";function cct(e){let{components:n,...t}=e;return(0,s.yg)(sct,(0,p.A)({},rct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}cct.isMDXComponent=!0;const act={toc:[]},ict="wrapper";function lct(e){let{components:n,...t}=e;return(0,s.yg)(ict,(0,p.A)({},act,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}lct.isMDXComponent=!0;const uct={toc:[]},mct="wrapper";function yct(e){let{components:n,...t}=e;return(0,s.yg)(mct,(0,p.A)({},uct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}yct.isMDXComponent=!0;const dct={toc:[]},hct="wrapper";function gct(e){let{components:n,...t}=e;return(0,s.yg)(hct,(0,p.A)({},dct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}gct.isMDXComponent=!0;const fct={toc:[]},Dct="wrapper";function Mct(e){let{components:n,...t}=e;return(0,s.yg)(Dct,(0,p.A)({},fct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Mct.isMDXComponent=!0;const Xct={toc:[]},_ct="wrapper";function wct(e){let{components:n,...t}=e;return(0,s.yg)(_ct,(0,p.A)({},Xct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wct.isMDXComponent=!0;const Tct={toc:[]},Cct="wrapper";function xct(e){let{components:n,...t}=e;return(0,s.yg)(Cct,(0,p.A)({},Tct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}xct.isMDXComponent=!0;const Act={toc:[]},vct="wrapper";function Lct(e){let{components:n,...t}=e;return(0,s.yg)(vct,(0,p.A)({},Act,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Lct.isMDXComponent=!0;const bct={toc:[]},Nct="wrapper";function kct(e){let{components:n,...t}=e;return(0,s.yg)(Nct,(0,p.A)({},bct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}kct.isMDXComponent=!0;const zct={toc:[]},Pct="wrapper";function Ict(e){let{components:n,...t}=e;return(0,s.yg)(Pct,(0,p.A)({},zct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ict.isMDXComponent=!0;const Rct={toc:[]},Wct="wrapper";function Sct(e){let{components:n,...t}=e;return(0,s.yg)(Wct,(0,p.A)({},Rct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Sct.isMDXComponent=!0;const Bct={toc:[]},Gct="wrapper";function Ect(e){let{components:n,...t}=e;return(0,s.yg)(Gct,(0,p.A)({},Bct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Ect.isMDXComponent=!0;const Oct={toc:[]},Uct="wrapper";function Fct(e){let{components:n,...t}=e;return(0,s.yg)(Uct,(0,p.A)({},Oct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Fct.isMDXComponent=!0;const Vct={toc:[]},qct="wrapper";function jct(e){let{components:n,...t}=e;return(0,s.yg)(qct,(0,p.A)({},Vct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}jct.isMDXComponent=!0;const Hct={toc:[]},Yct="wrapper";function Qct(e){let{components:n,...t}=e;return(0,s.yg)(Yct,(0,p.A)({},Hct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Qct.isMDXComponent=!0;const $ct={toc:[]},Kct="wrapper";function Jct(e){let{components:n,...t}=e;return(0,s.yg)(Kct,(0,p.A)({},$ct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Jct.isMDXComponent=!0;const Zct={toc:[]},eat="wrapper";function nat(e){let{components:n,...t}=e;return(0,s.yg)(eat,(0,p.A)({},Zct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}nat.isMDXComponent=!0;const tat={toc:[]},oat="wrapper";function pat(e){let{components:n,...t}=e;return(0,s.yg)(oat,(0,p.A)({},tat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pat.isMDXComponent=!0;const rat={toc:[]},sat="wrapper";function cat(e){let{components:n,...t}=e;return(0,s.yg)(sat,(0,p.A)({},rat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}cat.isMDXComponent=!0;const aat={toc:[]},iat="wrapper";function lat(e){let{components:n,...t}=e;return(0,s.yg)(iat,(0,p.A)({},aat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lat.isMDXComponent=!0;const uat={toc:[]},mat="wrapper";function yat(e){let{components:n,...t}=e;return(0,s.yg)(mat,(0,p.A)({},uat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}yat.isMDXComponent=!0;const dat={toc:[]},hat="wrapper";function gat(e){let{components:n,...t}=e;return(0,s.yg)(hat,(0,p.A)({},dat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}gat.isMDXComponent=!0;const fat={toc:[]},Dat="wrapper";function Mat(e){let{components:n,...t}=e;return(0,s.yg)(Dat,(0,p.A)({},fat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Mat.isMDXComponent=!0;const Xat={toc:[]},_at="wrapper";function wat(e){let{components:n,...t}=e;return(0,s.yg)(_at,(0,p.A)({},Xat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wat.isMDXComponent=!0;const Tat={toc:[]},Cat="wrapper";function xat(e){let{components:n,...t}=e;return(0,s.yg)(Cat,(0,p.A)({},Tat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}xat.isMDXComponent=!0;const Aat={toc:[]},vat="wrapper";function Lat(e){let{components:n,...t}=e;return(0,s.yg)(vat,(0,p.A)({},Aat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Lat.isMDXComponent=!0;const bat={toc:[]},Nat="wrapper";function kat(e){let{components:n,...t}=e;return(0,s.yg)(Nat,(0,p.A)({},bat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}kat.isMDXComponent=!0;const zat={toc:[]},Pat="wrapper";function Iat(e){let{components:n,...t}=e;return(0,s.yg)(Pat,(0,p.A)({},zat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}Iat.isMDXComponent=!0;const Rat={toc:[]},Wat="wrapper";function Sat(e){let{components:n,...t}=e;return(0,s.yg)(Wat,(0,p.A)({},Rat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The points of the line."))}Sat.isMDXComponent=!0;const Bat={toc:[]},Gat="wrapper";function Eat(e){let{components:n,...t}=e;return(0,s.yg)(Gat,(0,p.A)({},Bat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Eat.isMDXComponent=!0;const Oat={toc:[]},Uat="wrapper";function Fat(e){let{components:n,...t}=e;return(0,s.yg)(Uat,(0,p.A)({},Oat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Fat.isMDXComponent=!0;const Vat={toc:[]},qat="wrapper";function jat(e){let{components:n,...t}=e;return(0,s.yg)(qat,(0,p.A)({},Vat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the line's corners."))}jat.isMDXComponent=!0;const Hat={toc:[]},Yat="wrapper";function Qat(e){let{components:n,...t}=e;return(0,s.yg)(Yat,(0,p.A)({},Hat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Qat.isMDXComponent=!0;const $at={toc:[]},Kat="wrapper";function Jat(e){let{components:n,...t}=e;return(0,s.yg)(Kat,(0,p.A)({},$at,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Jat.isMDXComponent=!0;const Zat={toc:[]},eit="wrapper";function nit(e){let{components:n,...t}=e;return(0,s.yg)(eit,(0,p.A)({},Zat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nit.isMDXComponent=!0;const tit={toc:[]},oit="wrapper";function pit(e){let{components:n,...t}=e;return(0,s.yg)(oit,(0,p.A)({},tit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pit.isMDXComponent=!0;const rit={toc:[]},sit="wrapper";function cit(e){let{components:n,...t}=e;return(0,s.yg)(sit,(0,p.A)({},rit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}cit.isMDXComponent=!0;const ait={toc:[]},iit="wrapper";function lit(e){let{components:n,...t}=e;return(0,s.yg)(iit,(0,p.A)({},ait,t,{components:n,mdxType:"MDXLayout"}))}lit.isMDXComponent=!0;const uit={toc:[]},mit="wrapper";function yit(e){let{components:n,...t}=e;return(0,s.yg)(mit,(0,p.A)({},uit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}yit.isMDXComponent=!0;const dit={toc:[]},hit="wrapper";function git(e){let{components:n,...t}=e;return(0,s.yg)(hit,(0,p.A)({},dit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}git.isMDXComponent=!0;const fit={toc:[]},Dit="wrapper";function Mit(e){let{components:n,...t}=e;return(0,s.yg)(Dit,(0,p.A)({},fit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Mit.isMDXComponent=!0;const Xit={toc:[]},_it="wrapper";function wit(e){let{components:n,...t}=e;return(0,s.yg)(_it,(0,p.A)({},Xit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}wit.isMDXComponent=!0;const Tit={toc:[]},Cit="wrapper";function xit(e){let{components:n,...t}=e;return(0,s.yg)(Cit,(0,p.A)({},Tit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}xit.isMDXComponent=!0;const Ait={toc:[]},vit="wrapper";function Lit(e){let{components:n,...t}=e;return(0,s.yg)(vit,(0,p.A)({},Ait,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Lit.isMDXComponent=!0;const bit={toc:[]},Nit="wrapper";function kit(e){let{components:n,...t}=e;return(0,s.yg)(Nit,(0,p.A)({},bit,t,{components:n,mdxType:"MDXLayout"}))}kit.isMDXComponent=!0;const zit={toc:[]},Pit="wrapper";function Iit(e){let{components:n,...t}=e;return(0,s.yg)(Pit,(0,p.A)({},zit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Iit.isMDXComponent=!0;const Rit={toc:[]},Wit="wrapper";function Sit(e){let{components:n,...t}=e;return(0,s.yg)(Wit,(0,p.A)({},Rit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Sit.isMDXComponent=!0;const Bit={toc:[]},Git="wrapper";function Eit(e){let{components:n,...t}=e;return(0,s.yg)(Git,(0,p.A)({},Bit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Eit.isMDXComponent=!0;const Oit={toc:[]},Uit="wrapper";function Fit(e){let{components:n,...t}=e;return(0,s.yg)(Uit,(0,p.A)({},Oit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Fit.isMDXComponent=!0;const Vit={toc:[]},qit="wrapper";function jit(e){let{components:n,...t}=e;return(0,s.yg)(qit,(0,p.A)({},Vit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jit.isMDXComponent=!0;const Hit={toc:[]},Yit="wrapper";function Qit(e){let{components:n,...t}=e;return(0,s.yg)(Yit,(0,p.A)({},Hit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Qit.isMDXComponent=!0;const $it={toc:[]},Kit="wrapper";function Jit(e){let{components:n,...t}=e;return(0,s.yg)(Kit,(0,p.A)({},$it,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Jit.isMDXComponent=!0;const Zit={toc:[]},elt="wrapper";function nlt(e){let{components:n,...t}=e;return(0,s.yg)(elt,(0,p.A)({},Zit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}nlt.isMDXComponent=!0;const tlt={toc:[]},olt="wrapper";function plt(e){let{components:n,...t}=e;return(0,s.yg)(olt,(0,p.A)({},tlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}plt.isMDXComponent=!0;const rlt={toc:[]},slt="wrapper";function clt(e){let{components:n,...t}=e;return(0,s.yg)(slt,(0,p.A)({},rlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}clt.isMDXComponent=!0;const alt={toc:[]},ilt="wrapper";function llt(e){let{components:n,...t}=e;return(0,s.yg)(ilt,(0,p.A)({},alt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}llt.isMDXComponent=!0;const ult={toc:[]},mlt="wrapper";function ylt(e){let{components:n,...t}=e;return(0,s.yg)(mlt,(0,p.A)({},ult,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ylt.isMDXComponent=!0;const dlt={toc:[]},hlt="wrapper";function glt(e){let{components:n,...t}=e;return(0,s.yg)(hlt,(0,p.A)({},dlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}glt.isMDXComponent=!0;const flt={toc:[]},Dlt="wrapper";function Mlt(e){let{components:n,...t}=e;return(0,s.yg)(Dlt,(0,p.A)({},flt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Mlt.isMDXComponent=!0;const Xlt={toc:[]},_lt="wrapper";function wlt(e){let{components:n,...t}=e;return(0,s.yg)(_lt,(0,p.A)({},Xlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}wlt.isMDXComponent=!0;const Tlt={toc:[]},Clt="wrapper";function xlt(e){let{components:n,...t}=e;return(0,s.yg)(Clt,(0,p.A)({},Tlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}xlt.isMDXComponent=!0;const Alt={toc:[]},vlt="wrapper";function Llt(e){let{components:n,...t}=e;return(0,s.yg)(vlt,(0,p.A)({},Alt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Llt.isMDXComponent=!0;const blt={toc:[]},Nlt="wrapper";function klt(e){let{components:n,...t}=e;return(0,s.yg)(Nlt,(0,p.A)({},blt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}klt.isMDXComponent=!0;const zlt={toc:[]},Plt="wrapper";function Ilt(e){let{components:n,...t}=e;return(0,s.yg)(Plt,(0,p.A)({},zlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Ilt.isMDXComponent=!0;const Rlt={toc:[]},Wlt="wrapper";function Slt(e){let{components:n,...t}=e;return(0,s.yg)(Wlt,(0,p.A)({},Rlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Slt.isMDXComponent=!0;const Blt={toc:[]},Glt="wrapper";function Elt(e){let{components:n,...t}=e;return(0,s.yg)(Glt,(0,p.A)({},Blt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Elt.isMDXComponent=!0;const Olt={toc:[]},Ult="wrapper";function Flt(e){let{components:n,...t}=e;return(0,s.yg)(Ult,(0,p.A)({},Olt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Flt.isMDXComponent=!0;const Vlt={toc:[]},qlt="wrapper";function jlt(e){let{components:n,...t}=e;return(0,s.yg)(qlt,(0,p.A)({},Vlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}jlt.isMDXComponent=!0;const Hlt={toc:[]},Ylt="wrapper";function Qlt(e){let{components:n,...t}=e;return(0,s.yg)(Ylt,(0,p.A)({},Hlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Qlt.isMDXComponent=!0;const $lt={toc:[]},Klt="wrapper";function Jlt(e){let{components:n,...t}=e;return(0,s.yg)(Klt,(0,p.A)({},$lt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Jlt.isMDXComponent=!0;const Zlt={toc:[]},eut="wrapper";function nut(e){let{components:n,...t}=e;return(0,s.yg)(eut,(0,p.A)({},Zlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}nut.isMDXComponent=!0;const tut={toc:[]},out="wrapper";function put(e){let{components:n,...t}=e;return(0,s.yg)(out,(0,p.A)({},tut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}put.isMDXComponent=!0;const rut={toc:[]},sut="wrapper";function cut(e){let{components:n,...t}=e;return(0,s.yg)(sut,(0,p.A)({},rut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cut.isMDXComponent=!0;const aut={toc:[]},iut="wrapper";function lut(e){let{components:n,...t}=e;return(0,s.yg)(iut,(0,p.A)({},aut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}lut.isMDXComponent=!0;const uut={toc:[]},mut="wrapper";function yut(e){let{components:n,...t}=e;return(0,s.yg)(mut,(0,p.A)({},uut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}yut.isMDXComponent=!0;const dut={toc:[]},hut="wrapper";function gut(e){let{components:n,...t}=e;return(0,s.yg)(hut,(0,p.A)({},dut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}gut.isMDXComponent=!0;const fut={toc:[]},Dut="wrapper";function Mut(e){let{components:n,...t}=e;return(0,s.yg)(Dut,(0,p.A)({},fut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Mut.isMDXComponent=!0;const Xut={toc:[]},_ut="wrapper";function wut(e){let{components:n,...t}=e;return(0,s.yg)(_ut,(0,p.A)({},Xut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}wut.isMDXComponent=!0;const Tut={toc:[]},Cut="wrapper";function xut(e){let{components:n,...t}=e;return(0,s.yg)(Cut,(0,p.A)({},Tut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}xut.isMDXComponent=!0;const Aut={toc:[]},vut="wrapper";function Lut(e){let{components:n,...t}=e;return(0,s.yg)(vut,(0,p.A)({},Aut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Lut.isMDXComponent=!0;const but={toc:[]},Nut="wrapper";function kut(e){let{components:n,...t}=e;return(0,s.yg)(Nut,(0,p.A)({},but,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}kut.isMDXComponent=!0;const zut={toc:[]},Put="wrapper";function Iut(e){let{components:n,...t}=e;return(0,s.yg)(Put,(0,p.A)({},zut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Iut.isMDXComponent=!0;const Rut={toc:[]},Wut="wrapper";function Sut(e){let{components:n,...t}=e;return(0,s.yg)(Wut,(0,p.A)({},Rut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Sut.isMDXComponent=!0;const But={toc:[]},Gut="wrapper";function Eut(e){let{components:n,...t}=e;return(0,s.yg)(Gut,(0,p.A)({},But,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Eut.isMDXComponent=!0;const Out={toc:[]},Uut="wrapper";function Fut(e){let{components:n,...t}=e;return(0,s.yg)(Uut,(0,p.A)({},Out,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Fut.isMDXComponent=!0;const Vut={toc:[]},qut="wrapper";function jut(e){let{components:n,...t}=e;return(0,s.yg)(qut,(0,p.A)({},Vut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jut.isMDXComponent=!0;const Hut={toc:[]},Yut="wrapper";function Qut(e){let{components:n,...t}=e;return(0,s.yg)(Yut,(0,p.A)({},Hut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Qut.isMDXComponent=!0;const $ut={toc:[]},Kut="wrapper";function Jut(e){let{components:n,...t}=e;return(0,s.yg)(Kut,(0,p.A)({},$ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Jut.isMDXComponent=!0;const Zut={toc:[]},emt="wrapper";function nmt(e){let{components:n,...t}=e;return(0,s.yg)(emt,(0,p.A)({},Zut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}nmt.isMDXComponent=!0;const tmt={toc:[]},omt="wrapper";function pmt(e){let{components:n,...t}=e;return(0,s.yg)(omt,(0,p.A)({},tmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}pmt.isMDXComponent=!0;const rmt={toc:[]},smt="wrapper";function cmt(e){let{components:n,...t}=e;return(0,s.yg)(smt,(0,p.A)({},rmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cmt.isMDXComponent=!0;const amt={toc:[]},imt="wrapper";function lmt(e){let{components:n,...t}=e;return(0,s.yg)(imt,(0,p.A)({},amt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}lmt.isMDXComponent=!0;const umt={toc:[]},mmt="wrapper";function ymt(e){let{components:n,...t}=e;return(0,s.yg)(mmt,(0,p.A)({},umt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}ymt.isMDXComponent=!0;const dmt={toc:[]},hmt="wrapper";function gmt(e){let{components:n,...t}=e;return(0,s.yg)(hmt,(0,p.A)({},dmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}gmt.isMDXComponent=!0;const fmt={toc:[]},Dmt="wrapper";function Mmt(e){let{components:n,...t}=e;return(0,s.yg)(Dmt,(0,p.A)({},fmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Mmt.isMDXComponent=!0;const Xmt={toc:[]},_mt="wrapper";function wmt(e){let{components:n,...t}=e;return(0,s.yg)(_mt,(0,p.A)({},Xmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wmt.isMDXComponent=!0;const Tmt={toc:[]},Cmt="wrapper";function xmt(e){let{components:n,...t}=e;return(0,s.yg)(Cmt,(0,p.A)({},Tmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}xmt.isMDXComponent=!0;const Amt={toc:[]},vmt="wrapper";function Lmt(e){let{components:n,...t}=e;return(0,s.yg)(vmt,(0,p.A)({},Amt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Lmt.isMDXComponent=!0;const bmt={toc:[]},Nmt="wrapper";function kmt(e){let{components:n,...t}=e;return(0,s.yg)(Nmt,(0,p.A)({},bmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kmt.isMDXComponent=!0;const zmt={toc:[]},Pmt="wrapper";function Imt(e){let{components:n,...t}=e;return(0,s.yg)(Pmt,(0,p.A)({},zmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Imt.isMDXComponent=!0;const Rmt={toc:[]},Wmt="wrapper";function Smt(e){let{components:n,...t}=e;return(0,s.yg)(Wmt,(0,p.A)({},Rmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Smt.isMDXComponent=!0;const Bmt={toc:[]},Gmt="wrapper";function Emt(e){let{components:n,...t}=e;return(0,s.yg)(Gmt,(0,p.A)({},Bmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Emt.isMDXComponent=!0;const Omt={toc:[]},Umt="wrapper";function Fmt(e){let{components:n,...t}=e;return(0,s.yg)(Umt,(0,p.A)({},Omt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fmt.isMDXComponent=!0;const Vmt={toc:[]},qmt="wrapper";function jmt(e){let{components:n,...t}=e;return(0,s.yg)(qmt,(0,p.A)({},Vmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}jmt.isMDXComponent=!0;const Hmt={toc:[]},Ymt="wrapper";function Qmt(e){let{components:n,...t}=e;return(0,s.yg)(Ymt,(0,p.A)({},Hmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qmt.isMDXComponent=!0;const $mt={toc:[]},Kmt="wrapper";function Jmt(e){let{components:n,...t}=e;return(0,s.yg)(Kmt,(0,p.A)({},$mt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Jmt.isMDXComponent=!0;const Zmt={toc:[]},eyt="wrapper";function nyt(e){let{components:n,...t}=e;return(0,s.yg)(eyt,(0,p.A)({},Zmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nyt.isMDXComponent=!0;const tyt={toc:[]},oyt="wrapper";function pyt(e){let{components:n,...t}=e;return(0,s.yg)(oyt,(0,p.A)({},tyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}pyt.isMDXComponent=!0;const ryt={toc:[]},syt="wrapper";function cyt(e){let{components:n,...t}=e;return(0,s.yg)(syt,(0,p.A)({},ryt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cyt.isMDXComponent=!0;const ayt={toc:[]},iyt="wrapper";function lyt(e){let{components:n,...t}=e;return(0,s.yg)(iyt,(0,p.A)({},ayt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}lyt.isMDXComponent=!0;const uyt={toc:[]},myt="wrapper";function yyt(e){let{components:n,...t}=e;return(0,s.yg)(myt,(0,p.A)({},uyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yyt.isMDXComponent=!0;const dyt={toc:[]},hyt="wrapper";function gyt(e){let{components:n,...t}=e;return(0,s.yg)(hyt,(0,p.A)({},dyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}gyt.isMDXComponent=!0;const fyt={toc:[]},Dyt="wrapper";function Myt(e){let{components:n,...t}=e;return(0,s.yg)(Dyt,(0,p.A)({},fyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Myt.isMDXComponent=!0;const Xyt={toc:[]},_yt="wrapper";function wyt(e){let{components:n,...t}=e;return(0,s.yg)(_yt,(0,p.A)({},Xyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}wyt.isMDXComponent=!0;const Tyt={toc:[]},Cyt="wrapper";function xyt(e){let{components:n,...t}=e;return(0,s.yg)(Cyt,(0,p.A)({},Tyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}xyt.isMDXComponent=!0;const Ayt={toc:[]},vyt="wrapper";function Lyt(e){let{components:n,...t}=e;return(0,s.yg)(vyt,(0,p.A)({},Ayt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Lyt.isMDXComponent=!0;const byt={toc:[]},Nyt="wrapper";function kyt(e){let{components:n,...t}=e;return(0,s.yg)(Nyt,(0,p.A)({},byt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}kyt.isMDXComponent=!0;const zyt={toc:[]},Pyt="wrapper";function Iyt(e){let{components:n,...t}=e;return(0,s.yg)(Pyt,(0,p.A)({},zyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Iyt.isMDXComponent=!0;const Ryt={toc:[]},Wyt="wrapper";function Syt(e){let{components:n,...t}=e;return(0,s.yg)(Wyt,(0,p.A)({},Ryt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Syt.isMDXComponent=!0;const Byt={toc:[]},Gyt="wrapper";function Eyt(e){let{components:n,...t}=e;return(0,s.yg)(Gyt,(0,p.A)({},Byt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Eyt.isMDXComponent=!0;const Oyt={toc:[]},Uyt="wrapper";function Fyt(e){let{components:n,...t}=e;return(0,s.yg)(Uyt,(0,p.A)({},Oyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Fyt.isMDXComponent=!0;const Vyt={toc:[]},qyt="wrapper";function jyt(e){let{components:n,...t}=e;return(0,s.yg)(qyt,(0,p.A)({},Vyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jyt.isMDXComponent=!0;const Hyt={toc:[]},Yyt="wrapper";function Qyt(e){let{components:n,...t}=e;return(0,s.yg)(Yyt,(0,p.A)({},Hyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Qyt.isMDXComponent=!0;const $yt={toc:[]},Kyt="wrapper";function Jyt(e){let{components:n,...t}=e;return(0,s.yg)(Kyt,(0,p.A)({},$yt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Jyt.isMDXComponent=!0;const Zyt={toc:[]},edt="wrapper";function ndt(e){let{components:n,...t}=e;return(0,s.yg)(edt,(0,p.A)({},Zyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}ndt.isMDXComponent=!0;const tdt={toc:[]},odt="wrapper";function pdt(e){let{components:n,...t}=e;return(0,s.yg)(odt,(0,p.A)({},tdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}pdt.isMDXComponent=!0;const rdt={toc:[]},sdt="wrapper";function cdt(e){let{components:n,...t}=e;return(0,s.yg)(sdt,(0,p.A)({},rdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}cdt.isMDXComponent=!0;const adt={toc:[]},idt="wrapper";function ldt(e){let{components:n,...t}=e;return(0,s.yg)(idt,(0,p.A)({},adt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ldt.isMDXComponent=!0;const udt={toc:[]},mdt="wrapper";function ydt(e){let{components:n,...t}=e;return(0,s.yg)(mdt,(0,p.A)({},udt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}ydt.isMDXComponent=!0;const ddt={toc:[]},hdt="wrapper";function gdt(e){let{components:n,...t}=e;return(0,s.yg)(hdt,(0,p.A)({},ddt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gdt.isMDXComponent=!0;const fdt={toc:[]},Ddt="wrapper";function Mdt(e){let{components:n,...t}=e;return(0,s.yg)(Ddt,(0,p.A)({},fdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Mdt.isMDXComponent=!0;const Xdt={toc:[]},_dt="wrapper";function wdt(e){let{components:n,...t}=e;return(0,s.yg)(_dt,(0,p.A)({},Xdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wdt.isMDXComponent=!0;const Tdt={toc:[]},Cdt="wrapper";function xdt(e){let{components:n,...t}=e;return(0,s.yg)(Cdt,(0,p.A)({},Tdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}xdt.isMDXComponent=!0;const Adt={toc:[]},vdt="wrapper";function Ldt(e){let{components:n,...t}=e;return(0,s.yg)(vdt,(0,p.A)({},Adt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Ldt.isMDXComponent=!0;const bdt={toc:[]},Ndt="wrapper";function kdt(e){let{components:n,...t}=e;return(0,s.yg)(Ndt,(0,p.A)({},bdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kdt.isMDXComponent=!0;const zdt={toc:[]},Pdt="wrapper";function Idt(e){let{components:n,...t}=e;return(0,s.yg)(Pdt,(0,p.A)({},zdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Idt.isMDXComponent=!0;const Rdt={toc:[]},Wdt="wrapper";function Sdt(e){let{components:n,...t}=e;return(0,s.yg)(Wdt,(0,p.A)({},Rdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Sdt.isMDXComponent=!0;const Bdt={toc:[]},Gdt="wrapper";function Edt(e){let{components:n,...t}=e;return(0,s.yg)(Gdt,(0,p.A)({},Bdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Edt.isMDXComponent=!0;const Odt={toc:[]},Udt="wrapper";function Fdt(e){let{components:n,...t}=e;return(0,s.yg)(Udt,(0,p.A)({},Odt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Fdt.isMDXComponent=!0;const Vdt={toc:[]},qdt="wrapper";function jdt(e){let{components:n,...t}=e;return(0,s.yg)(qdt,(0,p.A)({},Vdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}jdt.isMDXComponent=!0;const Hdt={toc:[]},Ydt="wrapper";function Qdt(e){let{components:n,...t}=e;return(0,s.yg)(Ydt,(0,p.A)({},Hdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Qdt.isMDXComponent=!0;const $dt={toc:[]},Kdt="wrapper";function Jdt(e){let{components:n,...t}=e;return(0,s.yg)(Kdt,(0,p.A)({},$dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Jdt.isMDXComponent=!0;const Zdt={toc:[]},eht="wrapper";function nht(e){let{components:n,...t}=e;return(0,s.yg)(eht,(0,p.A)({},Zdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}nht.isMDXComponent=!0;const tht={toc:[]},oht="wrapper";function pht(e){let{components:n,...t}=e;return(0,s.yg)(oht,(0,p.A)({},tht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}pht.isMDXComponent=!0;const rht={toc:[]},sht="wrapper";function cht(e){let{components:n,...t}=e;return(0,s.yg)(sht,(0,p.A)({},rht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cht.isMDXComponent=!0;const aht={toc:[]},iht="wrapper";function lht(e){let{components:n,...t}=e;return(0,s.yg)(iht,(0,p.A)({},aht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lht.isMDXComponent=!0;const uht={toc:[]},mht="wrapper";function yht(e){let{components:n,...t}=e;return(0,s.yg)(mht,(0,p.A)({},uht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}yht.isMDXComponent=!0;const dht={toc:[]},hht="wrapper";function ght(e){let{components:n,...t}=e;return(0,s.yg)(hht,(0,p.A)({},dht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ght.isMDXComponent=!0;const fht={toc:[]},Dht="wrapper";function Mht(e){let{components:n,...t}=e;return(0,s.yg)(Dht,(0,p.A)({},fht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Mht.isMDXComponent=!0;const Xht={toc:[]},_ht="wrapper";function wht(e){let{components:n,...t}=e;return(0,s.yg)(_ht,(0,p.A)({},Xht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wht.isMDXComponent=!0;const Tht={toc:[]},Cht="wrapper";function xht(e){let{components:n,...t}=e;return(0,s.yg)(Cht,(0,p.A)({},Tht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}xht.isMDXComponent=!0;const Aht={toc:[]},vht="wrapper";function Lht(e){let{components:n,...t}=e;return(0,s.yg)(vht,(0,p.A)({},Aht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Lht.isMDXComponent=!0;const bht={toc:[]},Nht="wrapper";function kht(e){let{components:n,...t}=e;return(0,s.yg)(Nht,(0,p.A)({},bht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}kht.isMDXComponent=!0;const zht={toc:[]},Pht="wrapper";function Iht(e){let{components:n,...t}=e;return(0,s.yg)(Pht,(0,p.A)({},zht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Iht.isMDXComponent=!0;const Rht={toc:[]},Wht="wrapper";function Sht(e){let{components:n,...t}=e;return(0,s.yg)(Wht,(0,p.A)({},Rht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Sht.isMDXComponent=!0;const Bht={toc:[]},Ght="wrapper";function Eht(e){let{components:n,...t}=e;return(0,s.yg)(Ght,(0,p.A)({},Bht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Eht.isMDXComponent=!0;const Oht={toc:[]},Uht="wrapper";function Fht(e){let{components:n,...t}=e;return(0,s.yg)(Uht,(0,p.A)({},Oht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Fht.isMDXComponent=!0;const Vht={toc:[]},qht="wrapper";function jht(e){let{components:n,...t}=e;return(0,s.yg)(qht,(0,p.A)({},Vht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}jht.isMDXComponent=!0;const Hht={toc:[]},Yht="wrapper";function Qht(e){let{components:n,...t}=e;return(0,s.yg)(Yht,(0,p.A)({},Hht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Qht.isMDXComponent=!0;const $ht={toc:[]},Kht="wrapper";function Jht(e){let{components:n,...t}=e;return(0,s.yg)(Kht,(0,p.A)({},$ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Jht.isMDXComponent=!0;const Zht={toc:[]},egt="wrapper";function ngt(e){let{components:n,...t}=e;return(0,s.yg)(egt,(0,p.A)({},Zht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}ngt.isMDXComponent=!0;const tgt={toc:[]},ogt="wrapper";function pgt(e){let{components:n,...t}=e;return(0,s.yg)(ogt,(0,p.A)({},tgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}pgt.isMDXComponent=!0;const rgt={toc:[]},sgt="wrapper";function cgt(e){let{components:n,...t}=e;return(0,s.yg)(sgt,(0,p.A)({},rgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}cgt.isMDXComponent=!0;const agt={toc:[]},igt="wrapper";function lgt(e){let{components:n,...t}=e;return(0,s.yg)(igt,(0,p.A)({},agt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}lgt.isMDXComponent=!0;const ugt={toc:[]},mgt="wrapper";function ygt(e){let{components:n,...t}=e;return(0,s.yg)(mgt,(0,p.A)({},ugt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}ygt.isMDXComponent=!0;const dgt={toc:[]},hgt="wrapper";function ggt(e){let{components:n,...t}=e;return(0,s.yg)(hgt,(0,p.A)({},dgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}ggt.isMDXComponent=!0;const fgt={toc:[]},Dgt="wrapper";function Mgt(e){let{components:n,...t}=e;return(0,s.yg)(Dgt,(0,p.A)({},fgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Mgt.isMDXComponent=!0;const Xgt={toc:[]},_gt="wrapper";function wgt(e){let{components:n,...t}=e;return(0,s.yg)(_gt,(0,p.A)({},Xgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}wgt.isMDXComponent=!0;const Tgt={toc:[]},Cgt="wrapper";function xgt(e){let{components:n,...t}=e;return(0,s.yg)(Cgt,(0,p.A)({},Tgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xgt.isMDXComponent=!0;const Agt={toc:[]},vgt="wrapper";function Lgt(e){let{components:n,...t}=e;return(0,s.yg)(vgt,(0,p.A)({},Agt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Lgt.isMDXComponent=!0;const bgt={toc:[]},Ngt="wrapper";function kgt(e){let{components:n,...t}=e;return(0,s.yg)(Ngt,(0,p.A)({},bgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}kgt.isMDXComponent=!0;const zgt={toc:[]},Pgt="wrapper";function Igt(e){let{components:n,...t}=e;return(0,s.yg)(Pgt,(0,p.A)({},zgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Igt.isMDXComponent=!0;const Rgt={toc:[]},Wgt="wrapper";function Sgt(e){let{components:n,...t}=e;return(0,s.yg)(Wgt,(0,p.A)({},Rgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Sgt.isMDXComponent=!0;const Bgt={toc:[]},Ggt="wrapper";function Egt(e){let{components:n,...t}=e;return(0,s.yg)(Ggt,(0,p.A)({},Bgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Egt.isMDXComponent=!0;const Ogt={toc:[]},Ugt="wrapper";function Fgt(e){let{components:n,...t}=e;return(0,s.yg)(Ugt,(0,p.A)({},Ogt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Fgt.isMDXComponent=!0;const Vgt={toc:[]},qgt="wrapper";function jgt(e){let{components:n,...t}=e;return(0,s.yg)(qgt,(0,p.A)({},Vgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jgt.isMDXComponent=!0;const Hgt={toc:[]},Ygt="wrapper";function Qgt(e){let{components:n,...t}=e;return(0,s.yg)(Ygt,(0,p.A)({},Hgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Qgt.isMDXComponent=!0;const $gt={toc:[]},Kgt="wrapper";function Jgt(e){let{components:n,...t}=e;return(0,s.yg)(Kgt,(0,p.A)({},$gt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Jgt.isMDXComponent=!0;const Zgt={toc:[]},eft="wrapper";function nft(e){let{components:n,...t}=e;return(0,s.yg)(eft,(0,p.A)({},Zgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}nft.isMDXComponent=!0;const tft={toc:[]},oft="wrapper";function pft(e){let{components:n,...t}=e;return(0,s.yg)(oft,(0,p.A)({},tft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}pft.isMDXComponent=!0;const rft={toc:[]},sft="wrapper";function cft(e){let{components:n,...t}=e;return(0,s.yg)(sft,(0,p.A)({},rft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}cft.isMDXComponent=!0;const aft={toc:[]},ift="wrapper";function lft(e){let{components:n,...t}=e;return(0,s.yg)(ift,(0,p.A)({},aft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}lft.isMDXComponent=!0;const uft={toc:[]},mft="wrapper";function yft(e){let{components:n,...t}=e;return(0,s.yg)(mft,(0,p.A)({},uft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}yft.isMDXComponent=!0;const dft={toc:[]},hft="wrapper";function gft(e){let{components:n,...t}=e;return(0,s.yg)(hft,(0,p.A)({},dft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}gft.isMDXComponent=!0;const fft={toc:[]},Dft="wrapper";function Mft(e){let{components:n,...t}=e;return(0,s.yg)(Dft,(0,p.A)({},fft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Mft.isMDXComponent=!0;const Xft={toc:[]},_ft="wrapper";function wft(e){let{components:n,...t}=e;return(0,s.yg)(_ft,(0,p.A)({},Xft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}wft.isMDXComponent=!0;const Tft={toc:[]},Cft="wrapper";function xft(e){let{components:n,...t}=e;return(0,s.yg)(Cft,(0,p.A)({},Tft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}xft.isMDXComponent=!0;const Aft={toc:[]},vft="wrapper";function Lft(e){let{components:n,...t}=e;return(0,s.yg)(vft,(0,p.A)({},Aft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Lft.isMDXComponent=!0;const bft={toc:[]},Nft="wrapper";function kft(e){let{components:n,...t}=e;return(0,s.yg)(Nft,(0,p.A)({},bft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}kft.isMDXComponent=!0;const zft={toc:[]},Pft="wrapper";function Ift(e){let{components:n,...t}=e;return(0,s.yg)(Pft,(0,p.A)({},zft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Ift.isMDXComponent=!0;const Rft={toc:[]},Wft="wrapper";function Sft(e){let{components:n,...t}=e;return(0,s.yg)(Wft,(0,p.A)({},Rft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Sft.isMDXComponent=!0;const Bft={toc:[]},Gft="wrapper";function Eft(e){let{components:n,...t}=e;return(0,s.yg)(Gft,(0,p.A)({},Bft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Eft.isMDXComponent=!0;const Oft={toc:[]},Uft="wrapper";function Fft(e){let{components:n,...t}=e;return(0,s.yg)(Uft,(0,p.A)({},Oft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Fft.isMDXComponent=!0;const Vft={toc:[]},qft="wrapper";function jft(e){let{components:n,...t}=e;return(0,s.yg)(qft,(0,p.A)({},Vft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}jft.isMDXComponent=!0;const Hft={toc:[]},Yft="wrapper";function Qft(e){let{components:n,...t}=e;return(0,s.yg)(Yft,(0,p.A)({},Hft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Qft.isMDXComponent=!0;const $ft={toc:[]},Kft="wrapper";function Jft(e){let{components:n,...t}=e;return(0,s.yg)(Kft,(0,p.A)({},$ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Jft.isMDXComponent=!0;const Zft={toc:[]},eDt="wrapper";function nDt(e){let{components:n,...t}=e;return(0,s.yg)(eDt,(0,p.A)({},Zft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}nDt.isMDXComponent=!0;const tDt={toc:[]},oDt="wrapper";function pDt(e){let{components:n,...t}=e;return(0,s.yg)(oDt,(0,p.A)({},tDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pDt.isMDXComponent=!0;const rDt={toc:[]},sDt="wrapper";function cDt(e){let{components:n,...t}=e;return(0,s.yg)(sDt,(0,p.A)({},rDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}cDt.isMDXComponent=!0;const aDt={toc:[]},iDt="wrapper";function lDt(e){let{components:n,...t}=e;return(0,s.yg)(iDt,(0,p.A)({},aDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}lDt.isMDXComponent=!0;const uDt={toc:[]},mDt="wrapper";function yDt(e){let{components:n,...t}=e;return(0,s.yg)(mDt,(0,p.A)({},uDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}yDt.isMDXComponent=!0;const dDt={toc:[]},hDt="wrapper";function gDt(e){let{components:n,...t}=e;return(0,s.yg)(hDt,(0,p.A)({},dDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}gDt.isMDXComponent=!0;const fDt={toc:[]},DDt="wrapper";function MDt(e){let{components:n,...t}=e;return(0,s.yg)(DDt,(0,p.A)({},fDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}MDt.isMDXComponent=!0;const XDt={toc:[]},_Dt="wrapper";function wDt(e){let{components:n,...t}=e;return(0,s.yg)(_Dt,(0,p.A)({},XDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}wDt.isMDXComponent=!0;const TDt={toc:[]},CDt="wrapper";function xDt(e){let{components:n,...t}=e;return(0,s.yg)(CDt,(0,p.A)({},TDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xDt.isMDXComponent=!0;const ADt={toc:[]},vDt="wrapper";function LDt(e){let{components:n,...t}=e;return(0,s.yg)(vDt,(0,p.A)({},ADt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}LDt.isMDXComponent=!0;const bDt={toc:[]},NDt="wrapper";function kDt(e){let{components:n,...t}=e;return(0,s.yg)(NDt,(0,p.A)({},bDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kDt.isMDXComponent=!0;const zDt={toc:[]},PDt="wrapper";function IDt(e){let{components:n,...t}=e;return(0,s.yg)(PDt,(0,p.A)({},zDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}IDt.isMDXComponent=!0;const RDt={toc:[]},WDt="wrapper";function SDt(e){let{components:n,...t}=e;return(0,s.yg)(WDt,(0,p.A)({},RDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}SDt.isMDXComponent=!0;const BDt={toc:[]},GDt="wrapper";function EDt(e){let{components:n,...t}=e;return(0,s.yg)(GDt,(0,p.A)({},BDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}EDt.isMDXComponent=!0;const ODt={toc:[]},UDt="wrapper";function FDt(e){let{components:n,...t}=e;return(0,s.yg)(UDt,(0,p.A)({},ODt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}FDt.isMDXComponent=!0;const VDt={toc:[]},qDt="wrapper";function jDt(e){let{components:n,...t}=e;return(0,s.yg)(qDt,(0,p.A)({},VDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jDt.isMDXComponent=!0;const HDt={toc:[]},YDt="wrapper";function QDt(e){let{components:n,...t}=e;return(0,s.yg)(YDt,(0,p.A)({},HDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}QDt.isMDXComponent=!0;const $Dt={toc:[]},KDt="wrapper";function JDt(e){let{components:n,...t}=e;return(0,s.yg)(KDt,(0,p.A)({},$Dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}JDt.isMDXComponent=!0;const ZDt={toc:[]},eMt="wrapper";function nMt(e){let{components:n,...t}=e;return(0,s.yg)(eMt,(0,p.A)({},ZDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}nMt.isMDXComponent=!0;const tMt={toc:[]},oMt="wrapper";function pMt(e){let{components:n,...t}=e;return(0,s.yg)(oMt,(0,p.A)({},tMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pMt.isMDXComponent=!0;const rMt={toc:[]},sMt="wrapper";function cMt(e){let{components:n,...t}=e;return(0,s.yg)(sMt,(0,p.A)({},rMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}cMt.isMDXComponent=!0;const aMt={toc:[]},iMt="wrapper";function lMt(e){let{components:n,...t}=e;return(0,s.yg)(iMt,(0,p.A)({},aMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}lMt.isMDXComponent=!0;const uMt={toc:[]},mMt="wrapper";function yMt(e){let{components:n,...t}=e;return(0,s.yg)(mMt,(0,p.A)({},uMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}yMt.isMDXComponent=!0;const dMt={toc:[]},hMt="wrapper";function gMt(e){let{components:n,...t}=e;return(0,s.yg)(hMt,(0,p.A)({},dMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gMt.isMDXComponent=!0;const fMt={toc:[]},DMt="wrapper";function MMt(e){let{components:n,...t}=e;return(0,s.yg)(DMt,(0,p.A)({},fMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}MMt.isMDXComponent=!0;const XMt={toc:[]},_Mt="wrapper";function wMt(e){let{components:n,...t}=e;return(0,s.yg)(_Mt,(0,p.A)({},XMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}wMt.isMDXComponent=!0;const TMt={toc:[]},CMt="wrapper";function xMt(e){let{components:n,...t}=e;return(0,s.yg)(CMt,(0,p.A)({},TMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}xMt.isMDXComponent=!0;const AMt={toc:[]},vMt="wrapper";function LMt(e){let{components:n,...t}=e;return(0,s.yg)(vMt,(0,p.A)({},AMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}LMt.isMDXComponent=!0;const bMt={toc:[]},NMt="wrapper";function kMt(e){let{components:n,...t}=e;return(0,s.yg)(NMt,(0,p.A)({},bMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}kMt.isMDXComponent=!0;const zMt={toc:[]},PMt="wrapper";function IMt(e){let{components:n,...t}=e;return(0,s.yg)(PMt,(0,p.A)({},zMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}IMt.isMDXComponent=!0;const RMt={toc:[]},WMt="wrapper";function SMt(e){let{components:n,...t}=e;return(0,s.yg)(WMt,(0,p.A)({},RMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}SMt.isMDXComponent=!0;const BMt={toc:[]},GMt="wrapper";function EMt(e){let{components:n,...t}=e;return(0,s.yg)(GMt,(0,p.A)({},BMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}EMt.isMDXComponent=!0;const OMt={toc:[]},UMt="wrapper";function FMt(e){let{components:n,...t}=e;return(0,s.yg)(UMt,(0,p.A)({},OMt,t,{components:n,mdxType:"MDXLayout"}))}FMt.isMDXComponent=!0;const VMt={toc:[]},qMt="wrapper";function jMt(e){let{components:n,...t}=e;return(0,s.yg)(qMt,(0,p.A)({},VMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}jMt.isMDXComponent=!0;const HMt={toc:[]},YMt="wrapper";function QMt(e){let{components:n,...t}=e;return(0,s.yg)(YMt,(0,p.A)({},HMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}QMt.isMDXComponent=!0;const $Mt={toc:[]},KMt="wrapper";function JMt(e){let{components:n,...t}=e;return(0,s.yg)(KMt,(0,p.A)({},$Mt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}JMt.isMDXComponent=!0;const ZMt={toc:[]},eXt="wrapper";function nXt(e){let{components:n,...t}=e;return(0,s.yg)(eXt,(0,p.A)({},ZMt,t,{components:n,mdxType:"MDXLayout"}))}nXt.isMDXComponent=!0;const tXt={toc:[]},oXt="wrapper";function pXt(e){let{components:n,...t}=e;return(0,s.yg)(oXt,(0,p.A)({},tXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}pXt.isMDXComponent=!0;const rXt={toc:[]},sXt="wrapper";function cXt(e){let{components:n,...t}=e;return(0,s.yg)(sXt,(0,p.A)({},rXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}cXt.isMDXComponent=!0;const aXt={toc:[]},iXt="wrapper";function lXt(e){let{components:n,...t}=e;return(0,s.yg)(iXt,(0,p.A)({},aXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}lXt.isMDXComponent=!0;const uXt={toc:[]},mXt="wrapper";function yXt(e){let{components:n,...t}=e;return(0,s.yg)(mXt,(0,p.A)({},uXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}yXt.isMDXComponent=!0;const dXt={toc:[]},hXt="wrapper";function gXt(e){let{components:n,...t}=e;return(0,s.yg)(hXt,(0,p.A)({},dXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}gXt.isMDXComponent=!0;const fXt={toc:[]},DXt="wrapper";function MXt(e){let{components:n,...t}=e;return(0,s.yg)(DXt,(0,p.A)({},fXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}MXt.isMDXComponent=!0;const XXt={toc:[]},_Xt="wrapper";function wXt(e){let{components:n,...t}=e;return(0,s.yg)(_Xt,(0,p.A)({},XXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}wXt.isMDXComponent=!0;const TXt={toc:[]},CXt="wrapper";function xXt(e){let{components:n,...t}=e;return(0,s.yg)(CXt,(0,p.A)({},TXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}xXt.isMDXComponent=!0;const AXt={toc:[]},vXt="wrapper";function LXt(e){let{components:n,...t}=e;return(0,s.yg)(vXt,(0,p.A)({},AXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}LXt.isMDXComponent=!0;const bXt={toc:[]},NXt="wrapper";function kXt(e){let{components:n,...t}=e;return(0,s.yg)(NXt,(0,p.A)({},bXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}kXt.isMDXComponent=!0;const zXt={toc:[]},PXt="wrapper";function IXt(e){let{components:n,...t}=e;return(0,s.yg)(PXt,(0,p.A)({},zXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}IXt.isMDXComponent=!0;const RXt={toc:[]},WXt="wrapper";function SXt(e){let{components:n,...t}=e;return(0,s.yg)(WXt,(0,p.A)({},RXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}SXt.isMDXComponent=!0;const BXt={toc:[]},GXt="wrapper";function EXt(e){let{components:n,...t}=e;return(0,s.yg)(GXt,(0,p.A)({},BXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}EXt.isMDXComponent=!0;const OXt={toc:[]},UXt="wrapper";function FXt(e){let{components:n,...t}=e;return(0,s.yg)(UXt,(0,p.A)({},OXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}FXt.isMDXComponent=!0;const VXt={toc:[]},qXt="wrapper";function jXt(e){let{components:n,...t}=e;return(0,s.yg)(qXt,(0,p.A)({},VXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}jXt.isMDXComponent=!0;const HXt={toc:[]},YXt="wrapper";function QXt(e){let{components:n,...t}=e;return(0,s.yg)(YXt,(0,p.A)({},HXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}QXt.isMDXComponent=!0;const $Xt={toc:[]},KXt="wrapper";function JXt(e){let{components:n,...t}=e;return(0,s.yg)(KXt,(0,p.A)({},$Xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}JXt.isMDXComponent=!0;const ZXt={toc:[]},e_t="wrapper";function n_t(e){let{components:n,...t}=e;return(0,s.yg)(e_t,(0,p.A)({},ZXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}n_t.isMDXComponent=!0;const t_t={toc:[]},o_t="wrapper";function p_t(e){let{components:n,...t}=e;return(0,s.yg)(o_t,(0,p.A)({},t_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}p_t.isMDXComponent=!0;const r_t={toc:[]},s_t="wrapper";function c_t(e){let{components:n,...t}=e;return(0,s.yg)(s_t,(0,p.A)({},r_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}c_t.isMDXComponent=!0;const a_t={toc:[]},i_t="wrapper";function l_t(e){let{components:n,...t}=e;return(0,s.yg)(i_t,(0,p.A)({},a_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}l_t.isMDXComponent=!0;const u_t={toc:[]},m_t="wrapper";function y_t(e){let{components:n,...t}=e;return(0,s.yg)(m_t,(0,p.A)({},u_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}y_t.isMDXComponent=!0;const d_t={toc:[]},h_t="wrapper";function g_t(e){let{components:n,...t}=e;return(0,s.yg)(h_t,(0,p.A)({},d_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}g_t.isMDXComponent=!0;const f_t={toc:[]},D_t="wrapper";function M_t(e){let{components:n,...t}=e;return(0,s.yg)(D_t,(0,p.A)({},f_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}M_t.isMDXComponent=!0;const X_t={toc:[]},__t="wrapper";function w_t(e){let{components:n,...t}=e;return(0,s.yg)(__t,(0,p.A)({},X_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}w_t.isMDXComponent=!0;const T_t={toc:[]},C_t="wrapper";function x_t(e){let{components:n,...t}=e;return(0,s.yg)(C_t,(0,p.A)({},T_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}x_t.isMDXComponent=!0;const A_t={toc:[]},v_t="wrapper";function L_t(e){let{components:n,...t}=e;return(0,s.yg)(v_t,(0,p.A)({},A_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}L_t.isMDXComponent=!0;const b_t={toc:[]},N_t="wrapper";function k_t(e){let{components:n,...t}=e;return(0,s.yg)(N_t,(0,p.A)({},b_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}k_t.isMDXComponent=!0;const z_t={toc:[]},P_t="wrapper";function I_t(e){let{components:n,...t}=e;return(0,s.yg)(P_t,(0,p.A)({},z_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}I_t.isMDXComponent=!0;const R_t={toc:[]},W_t="wrapper";function S_t(e){let{components:n,...t}=e;return(0,s.yg)(W_t,(0,p.A)({},R_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}S_t.isMDXComponent=!0;const B_t={toc:[]},G_t="wrapper";function E_t(e){let{components:n,...t}=e;return(0,s.yg)(G_t,(0,p.A)({},B_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}E_t.isMDXComponent=!0;const O_t={toc:[]},U_t="wrapper";function F_t(e){let{components:n,...t}=e;return(0,s.yg)(U_t,(0,p.A)({},O_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}F_t.isMDXComponent=!0;const V_t={toc:[]},q_t="wrapper";function j_t(e){let{components:n,...t}=e;return(0,s.yg)(q_t,(0,p.A)({},V_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}j_t.isMDXComponent=!0;const H_t={toc:[]},Y_t="wrapper";function Q_t(e){let{components:n,...t}=e;return(0,s.yg)(Y_t,(0,p.A)({},H_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Q_t.isMDXComponent=!0;const $_t={toc:[]},K_t="wrapper";function J_t(e){let{components:n,...t}=e;return(0,s.yg)(K_t,(0,p.A)({},$_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}J_t.isMDXComponent=!0;const Z_t={toc:[]},ewt="wrapper";function nwt(e){let{components:n,...t}=e;return(0,s.yg)(ewt,(0,p.A)({},Z_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nwt.isMDXComponent=!0;const twt={toc:[]},owt="wrapper";function pwt(e){let{components:n,...t}=e;return(0,s.yg)(owt,(0,p.A)({},twt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pwt.isMDXComponent=!0;const rwt={toc:[]},swt="wrapper";function cwt(e){let{components:n,...t}=e;return(0,s.yg)(swt,(0,p.A)({},rwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}cwt.isMDXComponent=!0;const awt={toc:[]},iwt="wrapper";function lwt(e){let{components:n,...t}=e;return(0,s.yg)(iwt,(0,p.A)({},awt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lwt.isMDXComponent=!0;const uwt={toc:[]},mwt="wrapper";function ywt(e){let{components:n,...t}=e;return(0,s.yg)(mwt,(0,p.A)({},uwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}ywt.isMDXComponent=!0;const dwt={toc:[]},hwt="wrapper";function gwt(e){let{components:n,...t}=e;return(0,s.yg)(hwt,(0,p.A)({},dwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gwt.isMDXComponent=!0;const fwt={toc:[]},Dwt="wrapper";function Mwt(e){let{components:n,...t}=e;return(0,s.yg)(Dwt,(0,p.A)({},fwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mwt.isMDXComponent=!0;const Xwt={toc:[]},_wt="wrapper";function wwt(e){let{components:n,...t}=e;return(0,s.yg)(_wt,(0,p.A)({},Xwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wwt.isMDXComponent=!0;const Twt={toc:[]},Cwt="wrapper";function xwt(e){let{components:n,...t}=e;return(0,s.yg)(Cwt,(0,p.A)({},Twt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}xwt.isMDXComponent=!0;const Awt={toc:[]},vwt="wrapper";function Lwt(e){let{components:n,...t}=e;return(0,s.yg)(vwt,(0,p.A)({},Awt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Lwt.isMDXComponent=!0;const bwt={toc:[]},Nwt="wrapper";function kwt(e){let{components:n,...t}=e;return(0,s.yg)(Nwt,(0,p.A)({},bwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}kwt.isMDXComponent=!0;const zwt={toc:[]},Pwt="wrapper";function Iwt(e){let{components:n,...t}=e;return(0,s.yg)(Pwt,(0,p.A)({},zwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Iwt.isMDXComponent=!0;const Rwt={toc:[]},Wwt="wrapper";function Swt(e){let{components:n,...t}=e;return(0,s.yg)(Wwt,(0,p.A)({},Rwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Swt.isMDXComponent=!0;const Bwt={toc:[]},Gwt="wrapper";function Ewt(e){let{components:n,...t}=e;return(0,s.yg)(Gwt,(0,p.A)({},Bwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Ewt.isMDXComponent=!0;const Owt={toc:[]},Uwt="wrapper";function Fwt(e){let{components:n,...t}=e;return(0,s.yg)(Uwt,(0,p.A)({},Owt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Fwt.isMDXComponent=!0;const Vwt={toc:[]},qwt="wrapper";function jwt(e){let{components:n,...t}=e;return(0,s.yg)(qwt,(0,p.A)({},Vwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}jwt.isMDXComponent=!0;const Hwt={toc:[]},Ywt="wrapper";function Qwt(e){let{components:n,...t}=e;return(0,s.yg)(Ywt,(0,p.A)({},Hwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Qwt.isMDXComponent=!0;const $wt={toc:[]},Kwt="wrapper";function Jwt(e){let{components:n,...t}=e;return(0,s.yg)(Kwt,(0,p.A)({},$wt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Jwt.isMDXComponent=!0;const Zwt={toc:[]},eTt="wrapper";function nTt(e){let{components:n,...t}=e;return(0,s.yg)(eTt,(0,p.A)({},Zwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}nTt.isMDXComponent=!0;const tTt={toc:[]},oTt="wrapper";function pTt(e){let{components:n,...t}=e;return(0,s.yg)(oTt,(0,p.A)({},tTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}pTt.isMDXComponent=!0;const rTt={toc:[]},sTt="wrapper";function cTt(e){let{components:n,...t}=e;return(0,s.yg)(sTt,(0,p.A)({},rTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}cTt.isMDXComponent=!0;const aTt={toc:[]},iTt="wrapper";function lTt(e){let{components:n,...t}=e;return(0,s.yg)(iTt,(0,p.A)({},aTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}lTt.isMDXComponent=!0;const uTt={toc:[]},mTt="wrapper";function yTt(e){let{components:n,...t}=e;return(0,s.yg)(mTt,(0,p.A)({},uTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}yTt.isMDXComponent=!0;const dTt={toc:[]},hTt="wrapper";function gTt(e){let{components:n,...t}=e;return(0,s.yg)(hTt,(0,p.A)({},dTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}gTt.isMDXComponent=!0;const fTt={toc:[]},DTt="wrapper";function MTt(e){let{components:n,...t}=e;return(0,s.yg)(DTt,(0,p.A)({},fTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}MTt.isMDXComponent=!0;const XTt={toc:[]},_Tt="wrapper";function wTt(e){let{components:n,...t}=e;return(0,s.yg)(_Tt,(0,p.A)({},XTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}wTt.isMDXComponent=!0;const TTt={toc:[]},CTt="wrapper";function xTt(e){let{components:n,...t}=e;return(0,s.yg)(CTt,(0,p.A)({},TTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xTt.isMDXComponent=!0;const ATt={toc:[]},vTt="wrapper";function LTt(e){let{components:n,...t}=e;return(0,s.yg)(vTt,(0,p.A)({},ATt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}LTt.isMDXComponent=!0;const bTt={toc:[]},NTt="wrapper";function kTt(e){let{components:n,...t}=e;return(0,s.yg)(NTt,(0,p.A)({},bTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}kTt.isMDXComponent=!0;const zTt={toc:[]},PTt="wrapper";function ITt(e){let{components:n,...t}=e;return(0,s.yg)(PTt,(0,p.A)({},zTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}ITt.isMDXComponent=!0;const RTt={toc:[]},WTt="wrapper";function STt(e){let{components:n,...t}=e;return(0,s.yg)(WTt,(0,p.A)({},RTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}STt.isMDXComponent=!0;const BTt={toc:[]},GTt="wrapper";function ETt(e){let{components:n,...t}=e;return(0,s.yg)(GTt,(0,p.A)({},BTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}ETt.isMDXComponent=!0;const OTt={toc:[]},UTt="wrapper";function FTt(e){let{components:n,...t}=e;return(0,s.yg)(UTt,(0,p.A)({},OTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}FTt.isMDXComponent=!0;const VTt={toc:[]},qTt="wrapper";function jTt(e){let{components:n,...t}=e;return(0,s.yg)(qTt,(0,p.A)({},VTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}jTt.isMDXComponent=!0;const HTt={toc:[]},YTt="wrapper";function QTt(e){let{components:n,...t}=e;return(0,s.yg)(YTt,(0,p.A)({},HTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}QTt.isMDXComponent=!0;const $Tt={toc:[]},KTt="wrapper";function JTt(e){let{components:n,...t}=e;return(0,s.yg)(KTt,(0,p.A)({},$Tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}JTt.isMDXComponent=!0;const ZTt={toc:[]},eCt="wrapper";function nCt(e){let{components:n,...t}=e;return(0,s.yg)(eCt,(0,p.A)({},ZTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nCt.isMDXComponent=!0;const tCt={toc:[]},oCt="wrapper";function pCt(e){let{components:n,...t}=e;return(0,s.yg)(oCt,(0,p.A)({},tCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}pCt.isMDXComponent=!0;const rCt={toc:[]},sCt="wrapper";function cCt(e){let{components:n,...t}=e;return(0,s.yg)(sCt,(0,p.A)({},rCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}cCt.isMDXComponent=!0;const aCt={toc:[]},iCt="wrapper";function lCt(e){let{components:n,...t}=e;return(0,s.yg)(iCt,(0,p.A)({},aCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lCt.isMDXComponent=!0;const uCt={toc:[]},mCt="wrapper";function yCt(e){let{components:n,...t}=e;return(0,s.yg)(mCt,(0,p.A)({},uCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yCt.isMDXComponent=!0;const dCt={toc:[]},hCt="wrapper";function gCt(e){let{components:n,...t}=e;return(0,s.yg)(hCt,(0,p.A)({},dCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}gCt.isMDXComponent=!0;const fCt={toc:[]},DCt="wrapper";function MCt(e){let{components:n,...t}=e;return(0,s.yg)(DCt,(0,p.A)({},fCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}MCt.isMDXComponent=!0;const XCt={toc:[]},_Ct="wrapper";function wCt(e){let{components:n,...t}=e;return(0,s.yg)(_Ct,(0,p.A)({},XCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}wCt.isMDXComponent=!0;const TCt={toc:[]},CCt="wrapper";function xCt(e){let{components:n,...t}=e;return(0,s.yg)(CCt,(0,p.A)({},TCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}xCt.isMDXComponent=!0;const ACt={toc:[]},vCt="wrapper";function LCt(e){let{components:n,...t}=e;return(0,s.yg)(vCt,(0,p.A)({},ACt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}LCt.isMDXComponent=!0;const bCt={toc:[]},NCt="wrapper";function kCt(e){let{components:n,...t}=e;return(0,s.yg)(NCt,(0,p.A)({},bCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}kCt.isMDXComponent=!0;const zCt={toc:[]},PCt="wrapper";function ICt(e){let{components:n,...t}=e;return(0,s.yg)(PCt,(0,p.A)({},zCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ICt.isMDXComponent=!0;const RCt={toc:[]},WCt="wrapper";function SCt(e){let{components:n,...t}=e;return(0,s.yg)(WCt,(0,p.A)({},RCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}SCt.isMDXComponent=!0;const BCt={toc:[]},GCt="wrapper";function ECt(e){let{components:n,...t}=e;return(0,s.yg)(GCt,(0,p.A)({},BCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ECt.isMDXComponent=!0;const OCt={toc:[]},UCt="wrapper";function FCt(e){let{components:n,...t}=e;return(0,s.yg)(UCt,(0,p.A)({},OCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}FCt.isMDXComponent=!0;const VCt={toc:[]},qCt="wrapper";function jCt(e){let{components:n,...t}=e;return(0,s.yg)(qCt,(0,p.A)({},VCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}jCt.isMDXComponent=!0;const HCt={toc:[]},YCt="wrapper";function QCt(e){let{components:n,...t}=e;return(0,s.yg)(YCt,(0,p.A)({},HCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}QCt.isMDXComponent=!0;const $Ct={toc:[]},KCt="wrapper";function JCt(e){let{components:n,...t}=e;return(0,s.yg)(KCt,(0,p.A)({},$Ct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}JCt.isMDXComponent=!0;const ZCt={toc:[]},ext="wrapper";function nxt(e){let{components:n,...t}=e;return(0,s.yg)(ext,(0,p.A)({},ZCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}nxt.isMDXComponent=!0;const txt={toc:[]},oxt="wrapper";function pxt(e){let{components:n,...t}=e;return(0,s.yg)(oxt,(0,p.A)({},txt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}pxt.isMDXComponent=!0;const rxt={toc:[]},sxt="wrapper";function cxt(e){let{components:n,...t}=e;return(0,s.yg)(sxt,(0,p.A)({},rxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cxt.isMDXComponent=!0;const axt={toc:[]},ixt="wrapper";function lxt(e){let{components:n,...t}=e;return(0,s.yg)(ixt,(0,p.A)({},axt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}lxt.isMDXComponent=!0;const uxt={toc:[]},mxt="wrapper";function yxt(e){let{components:n,...t}=e;return(0,s.yg)(mxt,(0,p.A)({},uxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}yxt.isMDXComponent=!0;const dxt={toc:[]},hxt="wrapper";function gxt(e){let{components:n,...t}=e;return(0,s.yg)(hxt,(0,p.A)({},dxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}gxt.isMDXComponent=!0;const fxt={toc:[]},Dxt="wrapper";function Mxt(e){let{components:n,...t}=e;return(0,s.yg)(Dxt,(0,p.A)({},fxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Mxt.isMDXComponent=!0;const Xxt={toc:[]},_xt="wrapper";function wxt(e){let{components:n,...t}=e;return(0,s.yg)(_xt,(0,p.A)({},Xxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}wxt.isMDXComponent=!0;const Txt={toc:[]},Cxt="wrapper";function xxt(e){let{components:n,...t}=e;return(0,s.yg)(Cxt,(0,p.A)({},Txt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}xxt.isMDXComponent=!0;const Axt={toc:[]},vxt="wrapper";function Lxt(e){let{components:n,...t}=e;return(0,s.yg)(vxt,(0,p.A)({},Axt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Lxt.isMDXComponent=!0;const bxt={toc:[]},Nxt="wrapper";function kxt(e){let{components:n,...t}=e;return(0,s.yg)(Nxt,(0,p.A)({},bxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}kxt.isMDXComponent=!0;const zxt={toc:[]},Pxt="wrapper";function Ixt(e){let{components:n,...t}=e;return(0,s.yg)(Pxt,(0,p.A)({},zxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Ixt.isMDXComponent=!0;const Rxt={toc:[]},Wxt="wrapper";function Sxt(e){let{components:n,...t}=e;return(0,s.yg)(Wxt,(0,p.A)({},Rxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Sxt.isMDXComponent=!0;const Bxt={toc:[]},Gxt="wrapper";function Ext(e){let{components:n,...t}=e;return(0,s.yg)(Gxt,(0,p.A)({},Bxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Ext.isMDXComponent=!0;const Oxt={toc:[]},Uxt="wrapper";function Fxt(e){let{components:n,...t}=e;return(0,s.yg)(Uxt,(0,p.A)({},Oxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Fxt.isMDXComponent=!0;const Vxt={toc:[]},qxt="wrapper";function jxt(e){let{components:n,...t}=e;return(0,s.yg)(qxt,(0,p.A)({},Vxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}jxt.isMDXComponent=!0;const Hxt={toc:[]},Yxt="wrapper";function Qxt(e){let{components:n,...t}=e;return(0,s.yg)(Yxt,(0,p.A)({},Hxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Qxt.isMDXComponent=!0;const $xt={toc:[]},Kxt="wrapper";function Jxt(e){let{components:n,...t}=e;return(0,s.yg)(Kxt,(0,p.A)({},$xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Jxt.isMDXComponent=!0;const Zxt={toc:[]},eAt="wrapper";function nAt(e){let{components:n,...t}=e;return(0,s.yg)(eAt,(0,p.A)({},Zxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}nAt.isMDXComponent=!0;const tAt={toc:[]},oAt="wrapper";function pAt(e){let{components:n,...t}=e;return(0,s.yg)(oAt,(0,p.A)({},tAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}pAt.isMDXComponent=!0;const rAt={toc:[]},sAt="wrapper";function cAt(e){let{components:n,...t}=e;return(0,s.yg)(sAt,(0,p.A)({},rAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}cAt.isMDXComponent=!0;const aAt={toc:[]},iAt="wrapper";function lAt(e){let{components:n,...t}=e;return(0,s.yg)(iAt,(0,p.A)({},aAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}lAt.isMDXComponent=!0;const uAt={toc:[]},mAt="wrapper";function yAt(e){let{components:n,...t}=e;return(0,s.yg)(mAt,(0,p.A)({},uAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yAt.isMDXComponent=!0;const dAt={toc:[]},hAt="wrapper";function gAt(e){let{components:n,...t}=e;return(0,s.yg)(hAt,(0,p.A)({},dAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}gAt.isMDXComponent=!0;const fAt={toc:[]},DAt="wrapper";function MAt(e){let{components:n,...t}=e;return(0,s.yg)(DAt,(0,p.A)({},fAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}MAt.isMDXComponent=!0;const XAt={toc:[]},_At="wrapper";function wAt(e){let{components:n,...t}=e;return(0,s.yg)(_At,(0,p.A)({},XAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}wAt.isMDXComponent=!0;const TAt={toc:[]},CAt="wrapper";function xAt(e){let{components:n,...t}=e;return(0,s.yg)(CAt,(0,p.A)({},TAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}xAt.isMDXComponent=!0;const AAt={toc:[]},vAt="wrapper";function LAt(e){let{components:n,...t}=e;return(0,s.yg)(vAt,(0,p.A)({},AAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LAt.isMDXComponent=!0;const bAt={toc:[]},NAt="wrapper";function kAt(e){let{components:n,...t}=e;return(0,s.yg)(NAt,(0,p.A)({},bAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}kAt.isMDXComponent=!0;const zAt={toc:[]},PAt="wrapper";function IAt(e){let{components:n,...t}=e;return(0,s.yg)(PAt,(0,p.A)({},zAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}IAt.isMDXComponent=!0;const RAt={toc:[]},WAt="wrapper";function SAt(e){let{components:n,...t}=e;return(0,s.yg)(WAt,(0,p.A)({},RAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}SAt.isMDXComponent=!0;const BAt={toc:[]},GAt="wrapper";function EAt(e){let{components:n,...t}=e;return(0,s.yg)(GAt,(0,p.A)({},BAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}EAt.isMDXComponent=!0;const OAt={toc:[]},UAt="wrapper";function FAt(e){let{components:n,...t}=e;return(0,s.yg)(UAt,(0,p.A)({},OAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}FAt.isMDXComponent=!0;const VAt={toc:[]},qAt="wrapper";function jAt(e){let{components:n,...t}=e;return(0,s.yg)(qAt,(0,p.A)({},VAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}jAt.isMDXComponent=!0;const HAt={toc:[]},YAt="wrapper";function QAt(e){let{components:n,...t}=e;return(0,s.yg)(YAt,(0,p.A)({},HAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}QAt.isMDXComponent=!0;const $At={toc:[]},KAt="wrapper";function JAt(e){let{components:n,...t}=e;return(0,s.yg)(KAt,(0,p.A)({},$At,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}JAt.isMDXComponent=!0;const ZAt={toc:[]},evt="wrapper";function nvt(e){let{components:n,...t}=e;return(0,s.yg)(evt,(0,p.A)({},ZAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nvt.isMDXComponent=!0;const tvt={toc:[]},ovt="wrapper";function pvt(e){let{components:n,...t}=e;return(0,s.yg)(ovt,(0,p.A)({},tvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pvt.isMDXComponent=!0;const rvt={toc:[]},svt="wrapper";function cvt(e){let{components:n,...t}=e;return(0,s.yg)(svt,(0,p.A)({},rvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cvt.isMDXComponent=!0;const avt={toc:[]},ivt="wrapper";function lvt(e){let{components:n,...t}=e;return(0,s.yg)(ivt,(0,p.A)({},avt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}lvt.isMDXComponent=!0;const uvt={toc:[]},mvt="wrapper";function yvt(e){let{components:n,...t}=e;return(0,s.yg)(mvt,(0,p.A)({},uvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yvt.isMDXComponent=!0;const dvt={toc:[]},hvt="wrapper";function gvt(e){let{components:n,...t}=e;return(0,s.yg)(hvt,(0,p.A)({},dvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}gvt.isMDXComponent=!0;const fvt={toc:[]},Dvt="wrapper";function Mvt(e){let{components:n,...t}=e;return(0,s.yg)(Dvt,(0,p.A)({},fvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Mvt.isMDXComponent=!0;const Xvt={toc:[]},_vt="wrapper";function wvt(e){let{components:n,...t}=e;return(0,s.yg)(_vt,(0,p.A)({},Xvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}wvt.isMDXComponent=!0;const Tvt={toc:[]},Cvt="wrapper";function xvt(e){let{components:n,...t}=e;return(0,s.yg)(Cvt,(0,p.A)({},Tvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xvt.isMDXComponent=!0;const Avt={toc:[]},vvt="wrapper";function Lvt(e){let{components:n,...t}=e;return(0,s.yg)(vvt,(0,p.A)({},Avt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Lvt.isMDXComponent=!0;const bvt={toc:[]},Nvt="wrapper";function kvt(e){let{components:n,...t}=e;return(0,s.yg)(Nvt,(0,p.A)({},bvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}kvt.isMDXComponent=!0;const zvt={toc:[]},Pvt="wrapper";function Ivt(e){let{components:n,...t}=e;return(0,s.yg)(Pvt,(0,p.A)({},zvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Ivt.isMDXComponent=!0;const Rvt={toc:[]},Wvt="wrapper";function Svt(e){let{components:n,...t}=e;return(0,s.yg)(Wvt,(0,p.A)({},Rvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Svt.isMDXComponent=!0;const Bvt={toc:[]},Gvt="wrapper";function Evt(e){let{components:n,...t}=e;return(0,s.yg)(Gvt,(0,p.A)({},Bvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Evt.isMDXComponent=!0;const Ovt={toc:[]},Uvt="wrapper";function Fvt(e){let{components:n,...t}=e;return(0,s.yg)(Uvt,(0,p.A)({},Ovt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Fvt.isMDXComponent=!0;const Vvt={toc:[]},qvt="wrapper";function jvt(e){let{components:n,...t}=e;return(0,s.yg)(qvt,(0,p.A)({},Vvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}jvt.isMDXComponent=!0;const Hvt={toc:[]},Yvt="wrapper";function Qvt(e){let{components:n,...t}=e;return(0,s.yg)(Yvt,(0,p.A)({},Hvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Qvt.isMDXComponent=!0;const $vt={toc:[]},Kvt="wrapper";function Jvt(e){let{components:n,...t}=e;return(0,s.yg)(Kvt,(0,p.A)({},$vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Jvt.isMDXComponent=!0;const Zvt={toc:[]},eLt="wrapper";function nLt(e){let{components:n,...t}=e;return(0,s.yg)(eLt,(0,p.A)({},Zvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}nLt.isMDXComponent=!0;const tLt={toc:[]},oLt="wrapper";function pLt(e){let{components:n,...t}=e;return(0,s.yg)(oLt,(0,p.A)({},tLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}pLt.isMDXComponent=!0;const rLt={toc:[]},sLt="wrapper";function cLt(e){let{components:n,...t}=e;return(0,s.yg)(sLt,(0,p.A)({},rLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cLt.isMDXComponent=!0;const aLt={toc:[]},iLt="wrapper";function lLt(e){let{components:n,...t}=e;return(0,s.yg)(iLt,(0,p.A)({},aLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lLt.isMDXComponent=!0;const uLt={toc:[]},mLt="wrapper";function yLt(e){let{components:n,...t}=e;return(0,s.yg)(mLt,(0,p.A)({},uLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}yLt.isMDXComponent=!0;const dLt={toc:[]},hLt="wrapper";function gLt(e){let{components:n,...t}=e;return(0,s.yg)(hLt,(0,p.A)({},dLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}gLt.isMDXComponent=!0;const fLt={toc:[]},DLt="wrapper";function MLt(e){let{components:n,...t}=e;return(0,s.yg)(DLt,(0,p.A)({},fLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}MLt.isMDXComponent=!0;const XLt={toc:[]},_Lt="wrapper";function wLt(e){let{components:n,...t}=e;return(0,s.yg)(_Lt,(0,p.A)({},XLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}wLt.isMDXComponent=!0;const TLt={toc:[]},CLt="wrapper";function xLt(e){let{components:n,...t}=e;return(0,s.yg)(CLt,(0,p.A)({},TLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xLt.isMDXComponent=!0;const ALt={toc:[]},vLt="wrapper";function LLt(e){let{components:n,...t}=e;return(0,s.yg)(vLt,(0,p.A)({},ALt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}LLt.isMDXComponent=!0;const bLt={toc:[]},NLt="wrapper";function kLt(e){let{components:n,...t}=e;return(0,s.yg)(NLt,(0,p.A)({},bLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kLt.isMDXComponent=!0;const zLt={toc:[]},PLt="wrapper";function ILt(e){let{components:n,...t}=e;return(0,s.yg)(PLt,(0,p.A)({},zLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}ILt.isMDXComponent=!0;const RLt={toc:[]},WLt="wrapper";function SLt(e){let{components:n,...t}=e;return(0,s.yg)(WLt,(0,p.A)({},RLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}SLt.isMDXComponent=!0;const BLt={toc:[]},GLt="wrapper";function ELt(e){let{components:n,...t}=e;return(0,s.yg)(GLt,(0,p.A)({},BLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}ELt.isMDXComponent=!0;const OLt={toc:[]},ULt="wrapper";function FLt(e){let{components:n,...t}=e;return(0,s.yg)(ULt,(0,p.A)({},OLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}FLt.isMDXComponent=!0;const VLt={toc:[]},qLt="wrapper";function jLt(e){let{components:n,...t}=e;return(0,s.yg)(qLt,(0,p.A)({},VLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}jLt.isMDXComponent=!0;const HLt={toc:[]},YLt="wrapper";function QLt(e){let{components:n,...t}=e;return(0,s.yg)(YLt,(0,p.A)({},HLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}QLt.isMDXComponent=!0;const $Lt={toc:[]},KLt="wrapper";function JLt(e){let{components:n,...t}=e;return(0,s.yg)(KLt,(0,p.A)({},$Lt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}JLt.isMDXComponent=!0;const ZLt={toc:[]},ebt="wrapper";function nbt(e){let{components:n,...t}=e;return(0,s.yg)(ebt,(0,p.A)({},ZLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}nbt.isMDXComponent=!0;const tbt={toc:[]},obt="wrapper";function pbt(e){let{components:n,...t}=e;return(0,s.yg)(obt,(0,p.A)({},tbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}pbt.isMDXComponent=!0;const rbt={toc:[]},sbt="wrapper";function cbt(e){let{components:n,...t}=e;return(0,s.yg)(sbt,(0,p.A)({},rbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}cbt.isMDXComponent=!0;const abt={toc:[]},ibt="wrapper";function lbt(e){let{components:n,...t}=e;return(0,s.yg)(ibt,(0,p.A)({},abt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}lbt.isMDXComponent=!0;const ubt={toc:[]},mbt="wrapper";function ybt(e){let{components:n,...t}=e;return(0,s.yg)(mbt,(0,p.A)({},ubt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ybt.isMDXComponent=!0;const dbt={toc:[]},hbt="wrapper";function gbt(e){let{components:n,...t}=e;return(0,s.yg)(hbt,(0,p.A)({},dbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}gbt.isMDXComponent=!0;const fbt={toc:[]},Dbt="wrapper";function Mbt(e){let{components:n,...t}=e;return(0,s.yg)(Dbt,(0,p.A)({},fbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Mbt.isMDXComponent=!0;const Xbt={toc:[]},_bt="wrapper";function wbt(e){let{components:n,...t}=e;return(0,s.yg)(_bt,(0,p.A)({},Xbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}wbt.isMDXComponent=!0;const Tbt={toc:[]},Cbt="wrapper";function xbt(e){let{components:n,...t}=e;return(0,s.yg)(Cbt,(0,p.A)({},Tbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}xbt.isMDXComponent=!0;const Abt={toc:[]},vbt="wrapper";function Lbt(e){let{components:n,...t}=e;return(0,s.yg)(vbt,(0,p.A)({},Abt,t,{components:n,mdxType:"MDXLayout"}))}Lbt.isMDXComponent=!0;const bbt={toc:[]},Nbt="wrapper";function kbt(e){let{components:n,...t}=e;return(0,s.yg)(Nbt,(0,p.A)({},bbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kbt.isMDXComponent=!0;const zbt={toc:[]},Pbt="wrapper";function Ibt(e){let{components:n,...t}=e;return(0,s.yg)(Pbt,(0,p.A)({},zbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Ibt.isMDXComponent=!0;const Rbt={toc:[]},Wbt="wrapper";function Sbt(e){let{components:n,...t}=e;return(0,s.yg)(Wbt,(0,p.A)({},Rbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Sbt.isMDXComponent=!0;const Bbt={toc:[]},Gbt="wrapper";function Ebt(e){let{components:n,...t}=e;return(0,s.yg)(Gbt,(0,p.A)({},Bbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Ebt.isMDXComponent=!0;const Obt={toc:[]},Ubt="wrapper";function Fbt(e){let{components:n,...t}=e;return(0,s.yg)(Ubt,(0,p.A)({},Obt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Fbt.isMDXComponent=!0;const Vbt={toc:[]},qbt="wrapper";function jbt(e){let{components:n,...t}=e;return(0,s.yg)(qbt,(0,p.A)({},Vbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}jbt.isMDXComponent=!0;const Hbt={toc:[]},Ybt="wrapper";function Qbt(e){let{components:n,...t}=e;return(0,s.yg)(Ybt,(0,p.A)({},Hbt,t,{components:n,mdxType:"MDXLayout"}))}Qbt.isMDXComponent=!0;const $bt={toc:[]},Kbt="wrapper";function Jbt(e){let{components:n,...t}=e;return(0,s.yg)(Kbt,(0,p.A)({},$bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Jbt.isMDXComponent=!0;const Zbt={toc:[]},eNt="wrapper";function nNt(e){let{components:n,...t}=e;return(0,s.yg)(eNt,(0,p.A)({},Zbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}nNt.isMDXComponent=!0;const tNt={toc:[]},oNt="wrapper";function pNt(e){let{components:n,...t}=e;return(0,s.yg)(oNt,(0,p.A)({},tNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pNt.isMDXComponent=!0;const rNt={toc:[]},sNt="wrapper";function cNt(e){let{components:n,...t}=e;return(0,s.yg)(sNt,(0,p.A)({},rNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}cNt.isMDXComponent=!0;const aNt={toc:[]},iNt="wrapper";function lNt(e){let{components:n,...t}=e;return(0,s.yg)(iNt,(0,p.A)({},aNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lNt.isMDXComponent=!0;const uNt={toc:[]},mNt="wrapper";function yNt(e){let{components:n,...t}=e;return(0,s.yg)(mNt,(0,p.A)({},uNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}yNt.isMDXComponent=!0;const dNt={toc:[]},hNt="wrapper";function gNt(e){let{components:n,...t}=e;return(0,s.yg)(hNt,(0,p.A)({},dNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}gNt.isMDXComponent=!0;const fNt={toc:[]},DNt="wrapper";function MNt(e){let{components:n,...t}=e;return(0,s.yg)(DNt,(0,p.A)({},fNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}MNt.isMDXComponent=!0;const XNt={toc:[]},_Nt="wrapper";function wNt(e){let{components:n,...t}=e;return(0,s.yg)(_Nt,(0,p.A)({},XNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wNt.isMDXComponent=!0;const TNt={toc:[]},CNt="wrapper";function xNt(e){let{components:n,...t}=e;return(0,s.yg)(CNt,(0,p.A)({},TNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}xNt.isMDXComponent=!0;const ANt={toc:[]},vNt="wrapper";function LNt(e){let{components:n,...t}=e;return(0,s.yg)(vNt,(0,p.A)({},ANt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LNt.isMDXComponent=!0;const bNt={toc:[]},NNt="wrapper";function kNt(e){let{components:n,...t}=e;return(0,s.yg)(NNt,(0,p.A)({},bNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}kNt.isMDXComponent=!0;const zNt={toc:[]},PNt="wrapper";function INt(e){let{components:n,...t}=e;return(0,s.yg)(PNt,(0,p.A)({},zNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}INt.isMDXComponent=!0;const RNt={toc:[]},WNt="wrapper";function SNt(e){let{components:n,...t}=e;return(0,s.yg)(WNt,(0,p.A)({},RNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}SNt.isMDXComponent=!0;const BNt={toc:[]},GNt="wrapper";function ENt(e){let{components:n,...t}=e;return(0,s.yg)(GNt,(0,p.A)({},BNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}ENt.isMDXComponent=!0;const ONt={toc:[]},UNt="wrapper";function FNt(e){let{components:n,...t}=e;return(0,s.yg)(UNt,(0,p.A)({},ONt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}FNt.isMDXComponent=!0;const VNt={toc:[]},qNt="wrapper";function jNt(e){let{components:n,...t}=e;return(0,s.yg)(qNt,(0,p.A)({},VNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}jNt.isMDXComponent=!0;const HNt={toc:[]},YNt="wrapper";function QNt(e){let{components:n,...t}=e;return(0,s.yg)(YNt,(0,p.A)({},HNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}QNt.isMDXComponent=!0;const $Nt={toc:[]},KNt="wrapper";function JNt(e){let{components:n,...t}=e;return(0,s.yg)(KNt,(0,p.A)({},$Nt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}JNt.isMDXComponent=!0;const ZNt={toc:[]},ekt="wrapper";function nkt(e){let{components:n,...t}=e;return(0,s.yg)(ekt,(0,p.A)({},ZNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}nkt.isMDXComponent=!0;const tkt={toc:[]},okt="wrapper";function pkt(e){let{components:n,...t}=e;return(0,s.yg)(okt,(0,p.A)({},tkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}pkt.isMDXComponent=!0;const rkt={toc:[]},skt="wrapper";function ckt(e){let{components:n,...t}=e;return(0,s.yg)(skt,(0,p.A)({},rkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}ckt.isMDXComponent=!0;const akt={toc:[]},ikt="wrapper";function lkt(e){let{components:n,...t}=e;return(0,s.yg)(ikt,(0,p.A)({},akt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}lkt.isMDXComponent=!0;const ukt={toc:[]},mkt="wrapper";function ykt(e){let{components:n,...t}=e;return(0,s.yg)(mkt,(0,p.A)({},ukt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}ykt.isMDXComponent=!0;const dkt={toc:[]},hkt="wrapper";function gkt(e){let{components:n,...t}=e;return(0,s.yg)(hkt,(0,p.A)({},dkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}gkt.isMDXComponent=!0;const fkt={toc:[]},Dkt="wrapper";function Mkt(e){let{components:n,...t}=e;return(0,s.yg)(Dkt,(0,p.A)({},fkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Mkt.isMDXComponent=!0;const Xkt={toc:[]},_kt="wrapper";function wkt(e){let{components:n,...t}=e;return(0,s.yg)(_kt,(0,p.A)({},Xkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wkt.isMDXComponent=!0;const Tkt={toc:[]},Ckt="wrapper";function xkt(e){let{components:n,...t}=e;return(0,s.yg)(Ckt,(0,p.A)({},Tkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}xkt.isMDXComponent=!0;const Akt={toc:[]},vkt="wrapper";function Lkt(e){let{components:n,...t}=e;return(0,s.yg)(vkt,(0,p.A)({},Akt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Lkt.isMDXComponent=!0;const bkt={toc:[]},Nkt="wrapper";function kkt(e){let{components:n,...t}=e;return(0,s.yg)(Nkt,(0,p.A)({},bkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}kkt.isMDXComponent=!0;const zkt={toc:[]},Pkt="wrapper";function Ikt(e){let{components:n,...t}=e;return(0,s.yg)(Pkt,(0,p.A)({},zkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Ikt.isMDXComponent=!0;const Rkt={toc:[]},Wkt="wrapper";function Skt(e){let{components:n,...t}=e;return(0,s.yg)(Wkt,(0,p.A)({},Rkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Skt.isMDXComponent=!0;const Bkt={toc:[]},Gkt="wrapper";function Ekt(e){let{components:n,...t}=e;return(0,s.yg)(Gkt,(0,p.A)({},Bkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Ekt.isMDXComponent=!0;const Okt={toc:[]},Ukt="wrapper";function Fkt(e){let{components:n,...t}=e;return(0,s.yg)(Ukt,(0,p.A)({},Okt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Fkt.isMDXComponent=!0;const Vkt={toc:[]},qkt="wrapper";function jkt(e){let{components:n,...t}=e;return(0,s.yg)(qkt,(0,p.A)({},Vkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}jkt.isMDXComponent=!0;const Hkt={toc:[]},Ykt="wrapper";function Qkt(e){let{components:n,...t}=e;return(0,s.yg)(Ykt,(0,p.A)({},Hkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Qkt.isMDXComponent=!0;const $kt={toc:[]},Kkt="wrapper";function Jkt(e){let{components:n,...t}=e;return(0,s.yg)(Kkt,(0,p.A)({},$kt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Jkt.isMDXComponent=!0;const Zkt={toc:[]},ezt="wrapper";function nzt(e){let{components:n,...t}=e;return(0,s.yg)(ezt,(0,p.A)({},Zkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}nzt.isMDXComponent=!0;const tzt={toc:[]},ozt="wrapper";function pzt(e){let{components:n,...t}=e;return(0,s.yg)(ozt,(0,p.A)({},tzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pzt.isMDXComponent=!0;const rzt={toc:[]},szt="wrapper";function czt(e){let{components:n,...t}=e;return(0,s.yg)(szt,(0,p.A)({},rzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}czt.isMDXComponent=!0;const azt={toc:[]},izt="wrapper";function lzt(e){let{components:n,...t}=e;return(0,s.yg)(izt,(0,p.A)({},azt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lzt.isMDXComponent=!0;const uzt={toc:[]},mzt="wrapper";function yzt(e){let{components:n,...t}=e;return(0,s.yg)(mzt,(0,p.A)({},uzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}yzt.isMDXComponent=!0;const dzt={toc:[]},hzt="wrapper";function gzt(e){let{components:n,...t}=e;return(0,s.yg)(hzt,(0,p.A)({},dzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}gzt.isMDXComponent=!0;const fzt={toc:[]},Dzt="wrapper";function Mzt(e){let{components:n,...t}=e;return(0,s.yg)(Dzt,(0,p.A)({},fzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Mzt.isMDXComponent=!0;const Xzt={toc:[]},_zt="wrapper";function wzt(e){let{components:n,...t}=e;return(0,s.yg)(_zt,(0,p.A)({},Xzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}wzt.isMDXComponent=!0;const Tzt={toc:[]},Czt="wrapper";function xzt(e){let{components:n,...t}=e;return(0,s.yg)(Czt,(0,p.A)({},Tzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xzt.isMDXComponent=!0;const Azt={toc:[]},vzt="wrapper";function Lzt(e){let{components:n,...t}=e;return(0,s.yg)(vzt,(0,p.A)({},Azt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Lzt.isMDXComponent=!0;const bzt={toc:[]},Nzt="wrapper";function kzt(e){let{components:n,...t}=e;return(0,s.yg)(Nzt,(0,p.A)({},bzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}kzt.isMDXComponent=!0;const zzt={toc:[]},Pzt="wrapper";function Izt(e){let{components:n,...t}=e;return(0,s.yg)(Pzt,(0,p.A)({},zzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Izt.isMDXComponent=!0;const Rzt={toc:[]},Wzt="wrapper";function Szt(e){let{components:n,...t}=e;return(0,s.yg)(Wzt,(0,p.A)({},Rzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Szt.isMDXComponent=!0;const Bzt={toc:[]},Gzt="wrapper";function Ezt(e){let{components:n,...t}=e;return(0,s.yg)(Gzt,(0,p.A)({},Bzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Ezt.isMDXComponent=!0;const Ozt={toc:[]},Uzt="wrapper";function Fzt(e){let{components:n,...t}=e;return(0,s.yg)(Uzt,(0,p.A)({},Ozt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Fzt.isMDXComponent=!0;const Vzt={toc:[]},qzt="wrapper";function jzt(e){let{components:n,...t}=e;return(0,s.yg)(qzt,(0,p.A)({},Vzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}jzt.isMDXComponent=!0;const Hzt={toc:[]},Yzt="wrapper";function Qzt(e){let{components:n,...t}=e;return(0,s.yg)(Yzt,(0,p.A)({},Hzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qzt.isMDXComponent=!0;const $zt={toc:[]},Kzt="wrapper";function Jzt(e){let{components:n,...t}=e;return(0,s.yg)(Kzt,(0,p.A)({},$zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Jzt.isMDXComponent=!0;const Zzt={toc:[]},ePt="wrapper";function nPt(e){let{components:n,...t}=e;return(0,s.yg)(ePt,(0,p.A)({},Zzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nPt.isMDXComponent=!0;const tPt={toc:[]},oPt="wrapper";function pPt(e){let{components:n,...t}=e;return(0,s.yg)(oPt,(0,p.A)({},tPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}pPt.isMDXComponent=!0;const rPt={toc:[]},sPt="wrapper";function cPt(e){let{components:n,...t}=e;return(0,s.yg)(sPt,(0,p.A)({},rPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cPt.isMDXComponent=!0;const aPt={toc:[]},iPt="wrapper";function lPt(e){let{components:n,...t}=e;return(0,s.yg)(iPt,(0,p.A)({},aPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lPt.isMDXComponent=!0;const uPt={toc:[]},mPt="wrapper";function yPt(e){let{components:n,...t}=e;return(0,s.yg)(mPt,(0,p.A)({},uPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yPt.isMDXComponent=!0;const dPt={toc:[]},hPt="wrapper";function gPt(e){let{components:n,...t}=e;return(0,s.yg)(hPt,(0,p.A)({},dPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}gPt.isMDXComponent=!0;const fPt={toc:[]},DPt="wrapper";function MPt(e){let{components:n,...t}=e;return(0,s.yg)(DPt,(0,p.A)({},fPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}MPt.isMDXComponent=!0;const XPt={toc:[]},_Pt="wrapper";function wPt(e){let{components:n,...t}=e;return(0,s.yg)(_Pt,(0,p.A)({},XPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}wPt.isMDXComponent=!0;const TPt={toc:[]},CPt="wrapper";function xPt(e){let{components:n,...t}=e;return(0,s.yg)(CPt,(0,p.A)({},TPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xPt.isMDXComponent=!0;const APt={toc:[]},vPt="wrapper";function LPt(e){let{components:n,...t}=e;return(0,s.yg)(vPt,(0,p.A)({},APt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}LPt.isMDXComponent=!0;const bPt={toc:[]},NPt="wrapper";function kPt(e){let{components:n,...t}=e;return(0,s.yg)(NPt,(0,p.A)({},bPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kPt.isMDXComponent=!0;const zPt={toc:[]},PPt="wrapper";function IPt(e){let{components:n,...t}=e;return(0,s.yg)(PPt,(0,p.A)({},zPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}IPt.isMDXComponent=!0;const RPt={toc:[]},WPt="wrapper";function SPt(e){let{components:n,...t}=e;return(0,s.yg)(WPt,(0,p.A)({},RPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}SPt.isMDXComponent=!0;const BPt={toc:[]},GPt="wrapper";function EPt(e){let{components:n,...t}=e;return(0,s.yg)(GPt,(0,p.A)({},BPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}EPt.isMDXComponent=!0;const OPt={toc:[]},UPt="wrapper";function FPt(e){let{components:n,...t}=e;return(0,s.yg)(UPt,(0,p.A)({},OPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}FPt.isMDXComponent=!0;const VPt={toc:[]},qPt="wrapper";function jPt(e){let{components:n,...t}=e;return(0,s.yg)(qPt,(0,p.A)({},VPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}jPt.isMDXComponent=!0;const HPt={toc:[]},YPt="wrapper";function QPt(e){let{components:n,...t}=e;return(0,s.yg)(YPt,(0,p.A)({},HPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}QPt.isMDXComponent=!0;const $Pt={toc:[]},KPt="wrapper";function JPt(e){let{components:n,...t}=e;return(0,s.yg)(KPt,(0,p.A)({},$Pt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}JPt.isMDXComponent=!0;const ZPt={toc:[]},eIt="wrapper";function nIt(e){let{components:n,...t}=e;return(0,s.yg)(eIt,(0,p.A)({},ZPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}nIt.isMDXComponent=!0;const tIt={toc:[]},oIt="wrapper";function pIt(e){let{components:n,...t}=e;return(0,s.yg)(oIt,(0,p.A)({},tIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}pIt.isMDXComponent=!0;const rIt={toc:[]},sIt="wrapper";function cIt(e){let{components:n,...t}=e;return(0,s.yg)(sIt,(0,p.A)({},rIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}cIt.isMDXComponent=!0;const aIt={toc:[]},iIt="wrapper";function lIt(e){let{components:n,...t}=e;return(0,s.yg)(iIt,(0,p.A)({},aIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lIt.isMDXComponent=!0;const uIt={toc:[]},mIt="wrapper";function yIt(e){let{components:n,...t}=e;return(0,s.yg)(mIt,(0,p.A)({},uIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}yIt.isMDXComponent=!0;const dIt={toc:[]},hIt="wrapper";function gIt(e){let{components:n,...t}=e;return(0,s.yg)(hIt,(0,p.A)({},dIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}gIt.isMDXComponent=!0;const fIt={toc:[]},DIt="wrapper";function MIt(e){let{components:n,...t}=e;return(0,s.yg)(DIt,(0,p.A)({},fIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}MIt.isMDXComponent=!0;const XIt={toc:[]},_It="wrapper";function wIt(e){let{components:n,...t}=e;return(0,s.yg)(_It,(0,p.A)({},XIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}wIt.isMDXComponent=!0;const TIt={toc:[]},CIt="wrapper";function xIt(e){let{components:n,...t}=e;return(0,s.yg)(CIt,(0,p.A)({},TIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}xIt.isMDXComponent=!0;const AIt={toc:[]},vIt="wrapper";function LIt(e){let{components:n,...t}=e;return(0,s.yg)(vIt,(0,p.A)({},AIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LIt.isMDXComponent=!0;const bIt={toc:[]},NIt="wrapper";function kIt(e){let{components:n,...t}=e;return(0,s.yg)(NIt,(0,p.A)({},bIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}kIt.isMDXComponent=!0;const zIt={toc:[]},PIt="wrapper";function IIt(e){let{components:n,...t}=e;return(0,s.yg)(PIt,(0,p.A)({},zIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}IIt.isMDXComponent=!0;const RIt={toc:[]},WIt="wrapper";function SIt(e){let{components:n,...t}=e;return(0,s.yg)(WIt,(0,p.A)({},RIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}SIt.isMDXComponent=!0;const BIt={toc:[]},GIt="wrapper";function EIt(e){let{components:n,...t}=e;return(0,s.yg)(GIt,(0,p.A)({},BIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}EIt.isMDXComponent=!0;const OIt={toc:[]},UIt="wrapper";function FIt(e){let{components:n,...t}=e;return(0,s.yg)(UIt,(0,p.A)({},OIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}FIt.isMDXComponent=!0;const VIt={toc:[]},qIt="wrapper";function jIt(e){let{components:n,...t}=e;return(0,s.yg)(qIt,(0,p.A)({},VIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}jIt.isMDXComponent=!0;const HIt={toc:[]},YIt="wrapper";function QIt(e){let{components:n,...t}=e;return(0,s.yg)(YIt,(0,p.A)({},HIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}QIt.isMDXComponent=!0;const $It={toc:[]},KIt="wrapper";function JIt(e){let{components:n,...t}=e;return(0,s.yg)(KIt,(0,p.A)({},$It,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}JIt.isMDXComponent=!0;const ZIt={toc:[]},eRt="wrapper";function nRt(e){let{components:n,...t}=e;return(0,s.yg)(eRt,(0,p.A)({},ZIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}nRt.isMDXComponent=!0;const tRt={toc:[]},oRt="wrapper";function pRt(e){let{components:n,...t}=e;return(0,s.yg)(oRt,(0,p.A)({},tRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pRt.isMDXComponent=!0;const rRt={toc:[]},sRt="wrapper";function cRt(e){let{components:n,...t}=e;return(0,s.yg)(sRt,(0,p.A)({},rRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}cRt.isMDXComponent=!0;const aRt={toc:[]},iRt="wrapper";function lRt(e){let{components:n,...t}=e;return(0,s.yg)(iRt,(0,p.A)({},aRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}lRt.isMDXComponent=!0;const uRt={toc:[]},mRt="wrapper";function yRt(e){let{components:n,...t}=e;return(0,s.yg)(mRt,(0,p.A)({},uRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}yRt.isMDXComponent=!0;const dRt={toc:[]},hRt="wrapper";function gRt(e){let{components:n,...t}=e;return(0,s.yg)(hRt,(0,p.A)({},dRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}gRt.isMDXComponent=!0;const fRt={toc:[]},DRt="wrapper";function MRt(e){let{components:n,...t}=e;return(0,s.yg)(DRt,(0,p.A)({},fRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}MRt.isMDXComponent=!0;const XRt={toc:[]},_Rt="wrapper";function wRt(e){let{components:n,...t}=e;return(0,s.yg)(_Rt,(0,p.A)({},XRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}wRt.isMDXComponent=!0;const TRt={toc:[]},CRt="wrapper";function xRt(e){let{components:n,...t}=e;return(0,s.yg)(CRt,(0,p.A)({},TRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}xRt.isMDXComponent=!0;const ARt={toc:[]},vRt="wrapper";function LRt(e){let{components:n,...t}=e;return(0,s.yg)(vRt,(0,p.A)({},ARt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}LRt.isMDXComponent=!0;const bRt={toc:[]},NRt="wrapper";function kRt(e){let{components:n,...t}=e;return(0,s.yg)(NRt,(0,p.A)({},bRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}kRt.isMDXComponent=!0;const zRt={toc:[]},PRt="wrapper";function IRt(e){let{components:n,...t}=e;return(0,s.yg)(PRt,(0,p.A)({},zRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}IRt.isMDXComponent=!0;const RRt={toc:[]},WRt="wrapper";function SRt(e){let{components:n,...t}=e;return(0,s.yg)(WRt,(0,p.A)({},RRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}SRt.isMDXComponent=!0;const BRt={toc:[]},GRt="wrapper";function ERt(e){let{components:n,...t}=e;return(0,s.yg)(GRt,(0,p.A)({},BRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ERt.isMDXComponent=!0;const ORt={toc:[]},URt="wrapper";function FRt(e){let{components:n,...t}=e;return(0,s.yg)(URt,(0,p.A)({},ORt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}FRt.isMDXComponent=!0;const VRt={toc:[]},qRt="wrapper";function jRt(e){let{components:n,...t}=e;return(0,s.yg)(qRt,(0,p.A)({},VRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}jRt.isMDXComponent=!0;const HRt={toc:[]},YRt="wrapper";function QRt(e){let{components:n,...t}=e;return(0,s.yg)(YRt,(0,p.A)({},HRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}QRt.isMDXComponent=!0;const $Rt={toc:[]},KRt="wrapper";function JRt(e){let{components:n,...t}=e;return(0,s.yg)(KRt,(0,p.A)({},$Rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}JRt.isMDXComponent=!0;const ZRt={toc:[]},eWt="wrapper";function nWt(e){let{components:n,...t}=e;return(0,s.yg)(eWt,(0,p.A)({},ZRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}nWt.isMDXComponent=!0;const tWt={toc:[]},oWt="wrapper";function pWt(e){let{components:n,...t}=e;return(0,s.yg)(oWt,(0,p.A)({},tWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}pWt.isMDXComponent=!0;const rWt={toc:[]},sWt="wrapper";function cWt(e){let{components:n,...t}=e;return(0,s.yg)(sWt,(0,p.A)({},rWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}cWt.isMDXComponent=!0;const aWt={toc:[]},iWt="wrapper";function lWt(e){let{components:n,...t}=e;return(0,s.yg)(iWt,(0,p.A)({},aWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}lWt.isMDXComponent=!0;const uWt={toc:[]},mWt="wrapper";function yWt(e){let{components:n,...t}=e;return(0,s.yg)(mWt,(0,p.A)({},uWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}yWt.isMDXComponent=!0;const dWt={toc:[]},hWt="wrapper";function gWt(e){let{components:n,...t}=e;return(0,s.yg)(hWt,(0,p.A)({},dWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}gWt.isMDXComponent=!0;const fWt={toc:[]},DWt="wrapper";function MWt(e){let{components:n,...t}=e;return(0,s.yg)(DWt,(0,p.A)({},fWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}MWt.isMDXComponent=!0;const XWt={toc:[]},_Wt="wrapper";function wWt(e){let{components:n,...t}=e;return(0,s.yg)(_Wt,(0,p.A)({},XWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}wWt.isMDXComponent=!0;const TWt={toc:[]},CWt="wrapper";function xWt(e){let{components:n,...t}=e;return(0,s.yg)(CWt,(0,p.A)({},TWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}xWt.isMDXComponent=!0;const AWt={toc:[]},vWt="wrapper";function LWt(e){let{components:n,...t}=e;return(0,s.yg)(vWt,(0,p.A)({},AWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}LWt.isMDXComponent=!0;const bWt={toc:[]},NWt="wrapper";function kWt(e){let{components:n,...t}=e;return(0,s.yg)(NWt,(0,p.A)({},bWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}kWt.isMDXComponent=!0;const zWt={toc:[]},PWt="wrapper";function IWt(e){let{components:n,...t}=e;return(0,s.yg)(PWt,(0,p.A)({},zWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}IWt.isMDXComponent=!0;const RWt={toc:[]},WWt="wrapper";function SWt(e){let{components:n,...t}=e;return(0,s.yg)(WWt,(0,p.A)({},RWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}SWt.isMDXComponent=!0;const BWt={toc:[]},GWt="wrapper";function EWt(e){let{components:n,...t}=e;return(0,s.yg)(GWt,(0,p.A)({},BWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}EWt.isMDXComponent=!0;const OWt={toc:[]},UWt="wrapper";function FWt(e){let{components:n,...t}=e;return(0,s.yg)(UWt,(0,p.A)({},OWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}FWt.isMDXComponent=!0;const VWt={toc:[]},qWt="wrapper";function jWt(e){let{components:n,...t}=e;return(0,s.yg)(qWt,(0,p.A)({},VWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}jWt.isMDXComponent=!0;const HWt={toc:[]},YWt="wrapper";function QWt(e){let{components:n,...t}=e;return(0,s.yg)(YWt,(0,p.A)({},HWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}QWt.isMDXComponent=!0;const $Wt={toc:[]},KWt="wrapper";function JWt(e){let{components:n,...t}=e;return(0,s.yg)(KWt,(0,p.A)({},$Wt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}JWt.isMDXComponent=!0;const ZWt={toc:[]},eSt="wrapper";function nSt(e){let{components:n,...t}=e;return(0,s.yg)(eSt,(0,p.A)({},ZWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}nSt.isMDXComponent=!0;const tSt={toc:[]},oSt="wrapper";function pSt(e){let{components:n,...t}=e;return(0,s.yg)(oSt,(0,p.A)({},tSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}pSt.isMDXComponent=!0;const rSt={toc:[]},sSt="wrapper";function cSt(e){let{components:n,...t}=e;return(0,s.yg)(sSt,(0,p.A)({},rSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}cSt.isMDXComponent=!0;const aSt={toc:[]},iSt="wrapper";function lSt(e){let{components:n,...t}=e;return(0,s.yg)(iSt,(0,p.A)({},aSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}lSt.isMDXComponent=!0;const uSt={toc:[]},mSt="wrapper";function ySt(e){let{components:n,...t}=e;return(0,s.yg)(mSt,(0,p.A)({},uSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}ySt.isMDXComponent=!0;const dSt={toc:[]},hSt="wrapper";function gSt(e){let{components:n,...t}=e;return(0,s.yg)(hSt,(0,p.A)({},dSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}gSt.isMDXComponent=!0;const fSt={toc:[]},DSt="wrapper";function MSt(e){let{components:n,...t}=e;return(0,s.yg)(DSt,(0,p.A)({},fSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}MSt.isMDXComponent=!0;const XSt={toc:[]},_St="wrapper";function wSt(e){let{components:n,...t}=e;return(0,s.yg)(_St,(0,p.A)({},XSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wSt.isMDXComponent=!0;const TSt={toc:[]},CSt="wrapper";function xSt(e){let{components:n,...t}=e;return(0,s.yg)(CSt,(0,p.A)({},TSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}xSt.isMDXComponent=!0;const ASt={toc:[]},vSt="wrapper";function LSt(e){let{components:n,...t}=e;return(0,s.yg)(vSt,(0,p.A)({},ASt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}LSt.isMDXComponent=!0;const bSt={toc:[]},NSt="wrapper";function kSt(e){let{components:n,...t}=e;return(0,s.yg)(NSt,(0,p.A)({},bSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}kSt.isMDXComponent=!0;const zSt={toc:[]},PSt="wrapper";function ISt(e){let{components:n,...t}=e;return(0,s.yg)(PSt,(0,p.A)({},zSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}ISt.isMDXComponent=!0;const RSt={toc:[]},WSt="wrapper";function SSt(e){let{components:n,...t}=e;return(0,s.yg)(WSt,(0,p.A)({},RSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}SSt.isMDXComponent=!0;const BSt={toc:[]},GSt="wrapper";function ESt(e){let{components:n,...t}=e;return(0,s.yg)(GSt,(0,p.A)({},BSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}ESt.isMDXComponent=!0;const OSt={toc:[]},USt="wrapper";function FSt(e){let{components:n,...t}=e;return(0,s.yg)(USt,(0,p.A)({},OSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}FSt.isMDXComponent=!0;const VSt={toc:[]},qSt="wrapper";function jSt(e){let{components:n,...t}=e;return(0,s.yg)(qSt,(0,p.A)({},VSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}jSt.isMDXComponent=!0;const HSt={toc:[]},YSt="wrapper";function QSt(e){let{components:n,...t}=e;return(0,s.yg)(YSt,(0,p.A)({},HSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}QSt.isMDXComponent=!0;const $St={toc:[]},KSt="wrapper";function JSt(e){let{components:n,...t}=e;return(0,s.yg)(KSt,(0,p.A)({},$St,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}JSt.isMDXComponent=!0;const ZSt={toc:[]},eBt="wrapper";function nBt(e){let{components:n,...t}=e;return(0,s.yg)(eBt,(0,p.A)({},ZSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}nBt.isMDXComponent=!0;const tBt={toc:[]},oBt="wrapper";function pBt(e){let{components:n,...t}=e;return(0,s.yg)(oBt,(0,p.A)({},tBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}pBt.isMDXComponent=!0;const rBt={toc:[]},sBt="wrapper";function cBt(e){let{components:n,...t}=e;return(0,s.yg)(sBt,(0,p.A)({},rBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cBt.isMDXComponent=!0;const aBt={toc:[]},iBt="wrapper";function lBt(e){let{components:n,...t}=e;return(0,s.yg)(iBt,(0,p.A)({},aBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lBt.isMDXComponent=!0;const uBt={toc:[]},mBt="wrapper";function yBt(e){let{components:n,...t}=e;return(0,s.yg)(mBt,(0,p.A)({},uBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}yBt.isMDXComponent=!0;const dBt={toc:[]},hBt="wrapper";function gBt(e){let{components:n,...t}=e;return(0,s.yg)(hBt,(0,p.A)({},dBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}gBt.isMDXComponent=!0;const fBt={toc:[]},DBt="wrapper";function MBt(e){let{components:n,...t}=e;return(0,s.yg)(DBt,(0,p.A)({},fBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}MBt.isMDXComponent=!0;const XBt={toc:[]},_Bt="wrapper";function wBt(e){let{components:n,...t}=e;return(0,s.yg)(_Bt,(0,p.A)({},XBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wBt.isMDXComponent=!0;const TBt={toc:[]},CBt="wrapper";function xBt(e){let{components:n,...t}=e;return(0,s.yg)(CBt,(0,p.A)({},TBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}xBt.isMDXComponent=!0;const ABt={toc:[]},vBt="wrapper";function LBt(e){let{components:n,...t}=e;return(0,s.yg)(vBt,(0,p.A)({},ABt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}LBt.isMDXComponent=!0;const bBt={toc:[]},NBt="wrapper";function kBt(e){let{components:n,...t}=e;return(0,s.yg)(NBt,(0,p.A)({},bBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}kBt.isMDXComponent=!0;const zBt={toc:[]},PBt="wrapper";function IBt(e){let{components:n,...t}=e;return(0,s.yg)(PBt,(0,p.A)({},zBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}IBt.isMDXComponent=!0;const RBt={toc:[]},WBt="wrapper";function SBt(e){let{components:n,...t}=e;return(0,s.yg)(WBt,(0,p.A)({},RBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}SBt.isMDXComponent=!0;const BBt={toc:[]},GBt="wrapper";function EBt(e){let{components:n,...t}=e;return(0,s.yg)(GBt,(0,p.A)({},BBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}EBt.isMDXComponent=!0;const OBt={toc:[]},UBt="wrapper";function FBt(e){let{components:n,...t}=e;return(0,s.yg)(UBt,(0,p.A)({},OBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}FBt.isMDXComponent=!0;const VBt={toc:[]},qBt="wrapper";function jBt(e){let{components:n,...t}=e;return(0,s.yg)(qBt,(0,p.A)({},VBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}jBt.isMDXComponent=!0;const HBt={toc:[]},YBt="wrapper";function QBt(e){let{components:n,...t}=e;return(0,s.yg)(YBt,(0,p.A)({},HBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}QBt.isMDXComponent=!0;const $Bt={toc:[]},KBt="wrapper";function JBt(e){let{components:n,...t}=e;return(0,s.yg)(KBt,(0,p.A)({},$Bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}JBt.isMDXComponent=!0;const ZBt={toc:[]},eGt="wrapper";function nGt(e){let{components:n,...t}=e;return(0,s.yg)(eGt,(0,p.A)({},ZBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nGt.isMDXComponent=!0;const tGt={toc:[]},oGt="wrapper";function pGt(e){let{components:n,...t}=e;return(0,s.yg)(oGt,(0,p.A)({},tGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pGt.isMDXComponent=!0;const rGt={toc:[]},sGt="wrapper";function cGt(e){let{components:n,...t}=e;return(0,s.yg)(sGt,(0,p.A)({},rGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}cGt.isMDXComponent=!0;const aGt={toc:[]},iGt="wrapper";function lGt(e){let{components:n,...t}=e;return(0,s.yg)(iGt,(0,p.A)({},aGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lGt.isMDXComponent=!0;const uGt={toc:[]},mGt="wrapper";function yGt(e){let{components:n,...t}=e;return(0,s.yg)(mGt,(0,p.A)({},uGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}yGt.isMDXComponent=!0;const dGt={toc:[]},hGt="wrapper";function gGt(e){let{components:n,...t}=e;return(0,s.yg)(hGt,(0,p.A)({},dGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.yg)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.yg)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}gGt.isMDXComponent=!0;const fGt={toc:[]},DGt="wrapper";function MGt(e){let{components:n,...t}=e;return(0,s.yg)(DGt,(0,p.A)({},fGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      radius={30}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}MGt.isMDXComponent=!0;const XGt={toc:[]},_Gt="wrapper";function wGt(e){let{components:n,...t}=e;return(0,s.yg)(_Gt,(0,p.A)({},XGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing regular polygons."))}wGt.isMDXComponent=!0;const TGt={toc:[]},CGt="wrapper";function xGt(e){let{components:n,...t}=e;return(0,s.yg)(CGt,(0,p.A)({},TGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}xGt.isMDXComponent=!0;const AGt={toc:[]},vGt="wrapper";function LGt(e){let{components:n,...t}=e;return(0,s.yg)(vGt,(0,p.A)({},AGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}LGt.isMDXComponent=!0;const bGt={toc:[]},NGt="wrapper";function kGt(e){let{components:n,...t}=e;return(0,s.yg)(NGt,(0,p.A)({},bGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}kGt.isMDXComponent=!0;const zGt={toc:[]},PGt="wrapper";function IGt(e){let{components:n,...t}=e;return(0,s.yg)(PGt,(0,p.A)({},zGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}IGt.isMDXComponent=!0;const RGt={toc:[]},WGt="wrapper";function SGt(e){let{components:n,...t}=e;return(0,s.yg)(WGt,(0,p.A)({},RGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}SGt.isMDXComponent=!0;const BGt={toc:[]},GGt="wrapper";function EGt(e){let{components:n,...t}=e;return(0,s.yg)(GGt,(0,p.A)({},BGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}EGt.isMDXComponent=!0;const OGt={toc:[]},UGt="wrapper";function FGt(e){let{components:n,...t}=e;return(0,s.yg)(UGt,(0,p.A)({},OGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}FGt.isMDXComponent=!0;const VGt={toc:[]},qGt="wrapper";function jGt(e){let{components:n,...t}=e;return(0,s.yg)(qGt,(0,p.A)({},VGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}jGt.isMDXComponent=!0;const HGt={toc:[]},YGt="wrapper";function QGt(e){let{components:n,...t}=e;return(0,s.yg)(YGt,(0,p.A)({},HGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}QGt.isMDXComponent=!0;const $Gt={toc:[]},KGt="wrapper";function JGt(e){let{components:n,...t}=e;return(0,s.yg)(KGt,(0,p.A)({},$Gt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}JGt.isMDXComponent=!0;const ZGt={toc:[]},eEt="wrapper";function nEt(e){let{components:n,...t}=e;return(0,s.yg)(eEt,(0,p.A)({},ZGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}nEt.isMDXComponent=!0;const tEt={toc:[]},oEt="wrapper";function pEt(e){let{components:n,...t}=e;return(0,s.yg)(oEt,(0,p.A)({},tEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}pEt.isMDXComponent=!0;const rEt={toc:[]},sEt="wrapper";function cEt(e){let{components:n,...t}=e;return(0,s.yg)(sEt,(0,p.A)({},rEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cEt.isMDXComponent=!0;const aEt={toc:[]},iEt="wrapper";function lEt(e){let{components:n,...t}=e;return(0,s.yg)(iEt,(0,p.A)({},aEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}lEt.isMDXComponent=!0;const uEt={toc:[]},mEt="wrapper";function yEt(e){let{components:n,...t}=e;return(0,s.yg)(mEt,(0,p.A)({},uEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yEt.isMDXComponent=!0;const dEt={toc:[]},hEt="wrapper";function gEt(e){let{components:n,...t}=e;return(0,s.yg)(hEt,(0,p.A)({},dEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gEt.isMDXComponent=!0;const fEt={toc:[]},DEt="wrapper";function MEt(e){let{components:n,...t}=e;return(0,s.yg)(DEt,(0,p.A)({},fEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}MEt.isMDXComponent=!0;const XEt={toc:[]},_Et="wrapper";function wEt(e){let{components:n,...t}=e;return(0,s.yg)(_Et,(0,p.A)({},XEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}wEt.isMDXComponent=!0;const TEt={toc:[]},CEt="wrapper";function xEt(e){let{components:n,...t}=e;return(0,s.yg)(CEt,(0,p.A)({},TEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}xEt.isMDXComponent=!0;const AEt={toc:[]},vEt="wrapper";function LEt(e){let{components:n,...t}=e;return(0,s.yg)(vEt,(0,p.A)({},AEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}LEt.isMDXComponent=!0;const bEt={toc:[]},NEt="wrapper";function kEt(e){let{components:n,...t}=e;return(0,s.yg)(NEt,(0,p.A)({},bEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kEt.isMDXComponent=!0;const zEt={toc:[]},PEt="wrapper";function IEt(e){let{components:n,...t}=e;return(0,s.yg)(PEt,(0,p.A)({},zEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}IEt.isMDXComponent=!0;const REt={toc:[]},WEt="wrapper";function SEt(e){let{components:n,...t}=e;return(0,s.yg)(WEt,(0,p.A)({},REt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}SEt.isMDXComponent=!0;const BEt={toc:[]},GEt="wrapper";function EEt(e){let{components:n,...t}=e;return(0,s.yg)(GEt,(0,p.A)({},BEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}EEt.isMDXComponent=!0;const OEt={toc:[]},UEt="wrapper";function FEt(e){let{components:n,...t}=e;return(0,s.yg)(UEt,(0,p.A)({},OEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}FEt.isMDXComponent=!0;const VEt={toc:[]},qEt="wrapper";function jEt(e){let{components:n,...t}=e;return(0,s.yg)(qEt,(0,p.A)({},VEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}jEt.isMDXComponent=!0;const HEt={toc:[]},YEt="wrapper";function QEt(e){let{components:n,...t}=e;return(0,s.yg)(YEt,(0,p.A)({},HEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}QEt.isMDXComponent=!0;const $Et={toc:[]},KEt="wrapper";function JEt(e){let{components:n,...t}=e;return(0,s.yg)(KEt,(0,p.A)({},$Et,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}JEt.isMDXComponent=!0;const ZEt={toc:[]},eOt="wrapper";function nOt(e){let{components:n,...t}=e;return(0,s.yg)(eOt,(0,p.A)({},ZEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nOt.isMDXComponent=!0;const tOt={toc:[]},oOt="wrapper";function pOt(e){let{components:n,...t}=e;return(0,s.yg)(oOt,(0,p.A)({},tOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}pOt.isMDXComponent=!0;const rOt={toc:[]},sOt="wrapper";function cOt(e){let{components:n,...t}=e;return(0,s.yg)(sOt,(0,p.A)({},rOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}cOt.isMDXComponent=!0;const aOt={toc:[]},iOt="wrapper";function lOt(e){let{components:n,...t}=e;return(0,s.yg)(iOt,(0,p.A)({},aOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}lOt.isMDXComponent=!0;const uOt={toc:[]},mOt="wrapper";function yOt(e){let{components:n,...t}=e;return(0,s.yg)(mOt,(0,p.A)({},uOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}yOt.isMDXComponent=!0;const dOt={toc:[]},hOt="wrapper";function gOt(e){let{components:n,...t}=e;return(0,s.yg)(hOt,(0,p.A)({},dOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}gOt.isMDXComponent=!0;const fOt={toc:[]},DOt="wrapper";function MOt(e){let{components:n,...t}=e;return(0,s.yg)(DOt,(0,p.A)({},fOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  radius={30}\n  size={320}\n  sides={3}\n  stroke={'#fff'}\n  lineWidth={8}\n/>\n")))}MOt.isMDXComponent=!0;const XOt={toc:[]},_Ot="wrapper";function wOt(e){let{components:n,...t}=e;return(0,s.yg)(_Ot,(0,p.A)({},XOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the polygon's corners."))}wOt.isMDXComponent=!0;const TOt={toc:[]},COt="wrapper";function xOt(e){let{components:n,...t}=e;return(0,s.yg)(COt,(0,p.A)({},TOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}xOt.isMDXComponent=!0;const AOt={toc:[]},vOt="wrapper";function LOt(e){let{components:n,...t}=e;return(0,s.yg)(vOt,(0,p.A)({},AOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}LOt.isMDXComponent=!0;const bOt={toc:[]},NOt="wrapper";function kOt(e){let{components:n,...t}=e;return(0,s.yg)(NOt,(0,p.A)({},bOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kOt.isMDXComponent=!0;const zOt={toc:[]},POt="wrapper";function IOt(e){let{components:n,...t}=e;return(0,s.yg)(POt,(0,p.A)({},zOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}IOt.isMDXComponent=!0;const ROt={toc:[]},WOt="wrapper";function SOt(e){let{components:n,...t}=e;return(0,s.yg)(WOt,(0,p.A)({},ROt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}SOt.isMDXComponent=!0;const BOt={toc:[]},GOt="wrapper";function EOt(e){let{components:n,...t}=e;return(0,s.yg)(GOt,(0,p.A)({},BOt,t,{components:n,mdxType:"MDXLayout"}))}EOt.isMDXComponent=!0;const OOt={toc:[]},UOt="wrapper";function FOt(e){let{components:n,...t}=e;return(0,s.yg)(UOt,(0,p.A)({},OOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"For example, a value of 6 creates a hexagon."))}FOt.isMDXComponent=!0;const VOt={toc:[]},qOt="wrapper";function jOt(e){let{components:n,...t}=e;return(0,s.yg)(qOt,(0,p.A)({},VOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}jOt.isMDXComponent=!0;const HOt={toc:[]},YOt="wrapper";function QOt(e){let{components:n,...t}=e;return(0,s.yg)(YOt,(0,p.A)({},HOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of sides of the polygon."))}QOt.isMDXComponent=!0;const $Ot={toc:[]},KOt="wrapper";function JOt(e){let{components:n,...t}=e;return(0,s.yg)(KOt,(0,p.A)({},$Ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}JOt.isMDXComponent=!0;const ZOt={toc:[]},eUt="wrapper";function nUt(e){let{components:n,...t}=e;return(0,s.yg)(eUt,(0,p.A)({},ZOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nUt.isMDXComponent=!0;const tUt={toc:[]},oUt="wrapper";function pUt(e){let{components:n,...t}=e;return(0,s.yg)(oUt,(0,p.A)({},tUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}pUt.isMDXComponent=!0;const rUt={toc:[]},sUt="wrapper";function cUt(e){let{components:n,...t}=e;return(0,s.yg)(sUt,(0,p.A)({},rUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}cUt.isMDXComponent=!0;const aUt={toc:[]},iUt="wrapper";function lUt(e){let{components:n,...t}=e;return(0,s.yg)(iUt,(0,p.A)({},aUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}lUt.isMDXComponent=!0;const uUt={toc:[]},mUt="wrapper";function yUt(e){let{components:n,...t}=e;return(0,s.yg)(mUt,(0,p.A)({},uUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}yUt.isMDXComponent=!0;const dUt={toc:[]},hUt="wrapper";function gUt(e){let{components:n,...t}=e;return(0,s.yg)(hUt,(0,p.A)({},dUt,t,{components:n,mdxType:"MDXLayout"}))}gUt.isMDXComponent=!0;const fUt={toc:[]},DUt="wrapper";function MUt(e){let{components:n,...t}=e;return(0,s.yg)(DUt,(0,p.A)({},fUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}MUt.isMDXComponent=!0;const XUt={toc:[]},_Ut="wrapper";function wUt(e){let{components:n,...t}=e;return(0,s.yg)(_Ut,(0,p.A)({},XUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}wUt.isMDXComponent=!0;const TUt={toc:[]},CUt="wrapper";function xUt(e){let{components:n,...t}=e;return(0,s.yg)(CUt,(0,p.A)({},TUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xUt.isMDXComponent=!0;const AUt={toc:[]},vUt="wrapper";function LUt(e){let{components:n,...t}=e;return(0,s.yg)(vUt,(0,p.A)({},AUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}LUt.isMDXComponent=!0;const bUt={toc:[]},NUt="wrapper";function kUt(e){let{components:n,...t}=e;return(0,s.yg)(NUt,(0,p.A)({},bUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kUt.isMDXComponent=!0;const zUt={toc:[]},PUt="wrapper";function IUt(e){let{components:n,...t}=e;return(0,s.yg)(PUt,(0,p.A)({},zUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}IUt.isMDXComponent=!0;const RUt={toc:[]},WUt="wrapper";function SUt(e){let{components:n,...t}=e;return(0,s.yg)(WUt,(0,p.A)({},RUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}SUt.isMDXComponent=!0;const BUt={toc:[]},GUt="wrapper";function EUt(e){let{components:n,...t}=e;return(0,s.yg)(GUt,(0,p.A)({},BUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}EUt.isMDXComponent=!0;const OUt={toc:[]},UUt="wrapper";function FUt(e){let{components:n,...t}=e;return(0,s.yg)(UUt,(0,p.A)({},OUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}FUt.isMDXComponent=!0;const VUt={toc:[]},qUt="wrapper";function jUt(e){let{components:n,...t}=e;return(0,s.yg)(qUt,(0,p.A)({},VUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}jUt.isMDXComponent=!0;const HUt={toc:[]},YUt="wrapper";function QUt(e){let{components:n,...t}=e;return(0,s.yg)(YUt,(0,p.A)({},HUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}QUt.isMDXComponent=!0;const $Ut={toc:[]},KUt="wrapper";function JUt(e){let{components:n,...t}=e;return(0,s.yg)(KUt,(0,p.A)({},$Ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}JUt.isMDXComponent=!0;const ZUt={toc:[]},eFt="wrapper";function nFt(e){let{components:n,...t}=e;return(0,s.yg)(eFt,(0,p.A)({},ZUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}nFt.isMDXComponent=!0;const tFt={toc:[]},oFt="wrapper";function pFt(e){let{components:n,...t}=e;return(0,s.yg)(oFt,(0,p.A)({},tFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}pFt.isMDXComponent=!0;const rFt={toc:[]},sFt="wrapper";function cFt(e){let{components:n,...t}=e;return(0,s.yg)(sFt,(0,p.A)({},rFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}cFt.isMDXComponent=!0;const aFt={toc:[]},iFt="wrapper";function lFt(e){let{components:n,...t}=e;return(0,s.yg)(iFt,(0,p.A)({},aFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}lFt.isMDXComponent=!0;const uFt={toc:[]},mFt="wrapper";function yFt(e){let{components:n,...t}=e;return(0,s.yg)(mFt,(0,p.A)({},uFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}yFt.isMDXComponent=!0;const dFt={toc:[]},hFt="wrapper";function gFt(e){let{components:n,...t}=e;return(0,s.yg)(hFt,(0,p.A)({},dFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}gFt.isMDXComponent=!0;const fFt={toc:[]},DFt="wrapper";function MFt(e){let{components:n,...t}=e;return(0,s.yg)(DFt,(0,p.A)({},fFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}MFt.isMDXComponent=!0;const XFt={toc:[]},_Ft="wrapper";function wFt(e){let{components:n,...t}=e;return(0,s.yg)(_Ft,(0,p.A)({},XFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}wFt.isMDXComponent=!0;const TFt={toc:[]},CFt="wrapper";function xFt(e){let{components:n,...t}=e;return(0,s.yg)(CFt,(0,p.A)({},TFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}xFt.isMDXComponent=!0;const AFt={toc:[]},vFt="wrapper";function LFt(e){let{components:n,...t}=e;return(0,s.yg)(vFt,(0,p.A)({},AFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}LFt.isMDXComponent=!0;const bFt={toc:[]},NFt="wrapper";function kFt(e){let{components:n,...t}=e;return(0,s.yg)(NFt,(0,p.A)({},bFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}kFt.isMDXComponent=!0;const zFt={toc:[]},PFt="wrapper";function IFt(e){let{components:n,...t}=e;return(0,s.yg)(PFt,(0,p.A)({},zFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}IFt.isMDXComponent=!0;const RFt={toc:[]},WFt="wrapper";function SFt(e){let{components:n,...t}=e;return(0,s.yg)(WFt,(0,p.A)({},RFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}SFt.isMDXComponent=!0;const BFt={toc:[]},GFt="wrapper";function EFt(e){let{components:n,...t}=e;return(0,s.yg)(GFt,(0,p.A)({},BFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}EFt.isMDXComponent=!0;const OFt={toc:[]},UFt="wrapper";function FFt(e){let{components:n,...t}=e;return(0,s.yg)(UFt,(0,p.A)({},OFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}FFt.isMDXComponent=!0;const VFt={toc:[]},qFt="wrapper";function jFt(e){let{components:n,...t}=e;return(0,s.yg)(qFt,(0,p.A)({},VFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}jFt.isMDXComponent=!0;const HFt={toc:[]},YFt="wrapper";function QFt(e){let{components:n,...t}=e;return(0,s.yg)(YFt,(0,p.A)({},HFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}QFt.isMDXComponent=!0;const $Ft={toc:[]},KFt="wrapper";function JFt(e){let{components:n,...t}=e;return(0,s.yg)(KFt,(0,p.A)({},$Ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}JFt.isMDXComponent=!0;const ZFt={toc:[]},eVt="wrapper";function nVt(e){let{components:n,...t}=e;return(0,s.yg)(eVt,(0,p.A)({},ZFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}nVt.isMDXComponent=!0;const tVt={toc:[]},oVt="wrapper";function pVt(e){let{components:n,...t}=e;return(0,s.yg)(oVt,(0,p.A)({},tVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}pVt.isMDXComponent=!0;const rVt={toc:[]},sVt="wrapper";function cVt(e){let{components:n,...t}=e;return(0,s.yg)(sVt,(0,p.A)({},rVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}cVt.isMDXComponent=!0;const aVt={toc:[]},iVt="wrapper";function lVt(e){let{components:n,...t}=e;return(0,s.yg)(iVt,(0,p.A)({},aVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}lVt.isMDXComponent=!0;const uVt={toc:[]},mVt="wrapper";function yVt(e){let{components:n,...t}=e;return(0,s.yg)(mVt,(0,p.A)({},uVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}yVt.isMDXComponent=!0;const dVt={toc:[]},hVt="wrapper";function gVt(e){let{components:n,...t}=e;return(0,s.yg)(hVt,(0,p.A)({},dVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}gVt.isMDXComponent=!0;const fVt={toc:[]},DVt="wrapper";function MVt(e){let{components:n,...t}=e;return(0,s.yg)(DVt,(0,p.A)({},fVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}MVt.isMDXComponent=!0;const XVt={toc:[]},_Vt="wrapper";function wVt(e){let{components:n,...t}=e;return(0,s.yg)(_Vt,(0,p.A)({},XVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}wVt.isMDXComponent=!0;const TVt={toc:[]},CVt="wrapper";function xVt(e){let{components:n,...t}=e;return(0,s.yg)(CVt,(0,p.A)({},TVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}xVt.isMDXComponent=!0;const AVt={toc:[]},vVt="wrapper";function LVt(e){let{components:n,...t}=e;return(0,s.yg)(vVt,(0,p.A)({},AVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}LVt.isMDXComponent=!0;const bVt={toc:[]},NVt="wrapper";function kVt(e){let{components:n,...t}=e;return(0,s.yg)(NVt,(0,p.A)({},bVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kVt.isMDXComponent=!0;const zVt={toc:[]},PVt="wrapper";function IVt(e){let{components:n,...t}=e;return(0,s.yg)(PVt,(0,p.A)({},zVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}IVt.isMDXComponent=!0;const RVt={toc:[]},WVt="wrapper";function SVt(e){let{components:n,...t}=e;return(0,s.yg)(WVt,(0,p.A)({},RVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}SVt.isMDXComponent=!0;const BVt={toc:[]},GVt="wrapper";function EVt(e){let{components:n,...t}=e;return(0,s.yg)(GVt,(0,p.A)({},BVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}EVt.isMDXComponent=!0;const OVt={toc:[]},UVt="wrapper";function FVt(e){let{components:n,...t}=e;return(0,s.yg)(UVt,(0,p.A)({},OVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}FVt.isMDXComponent=!0;const VVt={toc:[]},qVt="wrapper";function jVt(e){let{components:n,...t}=e;return(0,s.yg)(qVt,(0,p.A)({},VVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}jVt.isMDXComponent=!0;const HVt={toc:[]},YVt="wrapper";function QVt(e){let{components:n,...t}=e;return(0,s.yg)(YVt,(0,p.A)({},HVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}QVt.isMDXComponent=!0;const $Vt={toc:[]},KVt="wrapper";function JVt(e){let{components:n,...t}=e;return(0,s.yg)(KVt,(0,p.A)({},$Vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}JVt.isMDXComponent=!0;const ZVt={toc:[]},eqt="wrapper";function nqt(e){let{components:n,...t}=e;return(0,s.yg)(eqt,(0,p.A)({},ZVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}nqt.isMDXComponent=!0;const tqt={toc:[]},oqt="wrapper";function pqt(e){let{components:n,...t}=e;return(0,s.yg)(oqt,(0,p.A)({},tqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}pqt.isMDXComponent=!0;const rqt={toc:[]},sqt="wrapper";function cqt(e){let{components:n,...t}=e;return(0,s.yg)(sqt,(0,p.A)({},rqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}cqt.isMDXComponent=!0;const aqt={toc:[]},iqt="wrapper";function lqt(e){let{components:n,...t}=e;return(0,s.yg)(iqt,(0,p.A)({},aqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}lqt.isMDXComponent=!0;const uqt={toc:[]},mqt="wrapper";function yqt(e){let{components:n,...t}=e;return(0,s.yg)(mqt,(0,p.A)({},uqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yqt.isMDXComponent=!0;const dqt={toc:[]},hqt="wrapper";function gqt(e){let{components:n,...t}=e;return(0,s.yg)(hqt,(0,p.A)({},dqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gqt.isMDXComponent=!0;const fqt={toc:[]},Dqt="wrapper";function Mqt(e){let{components:n,...t}=e;return(0,s.yg)(Dqt,(0,p.A)({},fqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Mqt.isMDXComponent=!0;const Xqt={toc:[]},_qt="wrapper";function wqt(e){let{components:n,...t}=e;return(0,s.yg)(_qt,(0,p.A)({},Xqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wqt.isMDXComponent=!0;const Tqt={toc:[]},Cqt="wrapper";function xqt(e){let{components:n,...t}=e;return(0,s.yg)(Cqt,(0,p.A)({},Tqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xqt.isMDXComponent=!0;const Aqt={toc:[]},vqt="wrapper";function Lqt(e){let{components:n,...t}=e;return(0,s.yg)(vqt,(0,p.A)({},Aqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Lqt.isMDXComponent=!0;const bqt={toc:[]},Nqt="wrapper";function kqt(e){let{components:n,...t}=e;return(0,s.yg)(Nqt,(0,p.A)({},bqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kqt.isMDXComponent=!0;const zqt={toc:[]},Pqt="wrapper";function Iqt(e){let{components:n,...t}=e;return(0,s.yg)(Pqt,(0,p.A)({},zqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Iqt.isMDXComponent=!0;const Rqt={toc:[]},Wqt="wrapper";function Sqt(e){let{components:n,...t}=e;return(0,s.yg)(Wqt,(0,p.A)({},Rqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Sqt.isMDXComponent=!0;const Bqt={toc:[]},Gqt="wrapper";function Eqt(e){let{components:n,...t}=e;return(0,s.yg)(Gqt,(0,p.A)({},Bqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Eqt.isMDXComponent=!0;const Oqt={toc:[]},Uqt="wrapper";function Fqt(e){let{components:n,...t}=e;return(0,s.yg)(Uqt,(0,p.A)({},Oqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Fqt.isMDXComponent=!0;const Vqt={toc:[]},qqt="wrapper";function jqt(e){let{components:n,...t}=e;return(0,s.yg)(qqt,(0,p.A)({},Vqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jqt.isMDXComponent=!0;const Hqt={toc:[]},Yqt="wrapper";function Qqt(e){let{components:n,...t}=e;return(0,s.yg)(Yqt,(0,p.A)({},Hqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Qqt.isMDXComponent=!0;const $qt={toc:[]},Kqt="wrapper";function Jqt(e){let{components:n,...t}=e;return(0,s.yg)(Kqt,(0,p.A)({},$qt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jqt.isMDXComponent=!0;const Zqt={toc:[]},ejt="wrapper";function njt(e){let{components:n,...t}=e;return(0,s.yg)(ejt,(0,p.A)({},Zqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}njt.isMDXComponent=!0;const tjt={toc:[]},ojt="wrapper";function pjt(e){let{components:n,...t}=e;return(0,s.yg)(ojt,(0,p.A)({},tjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pjt.isMDXComponent=!0;const rjt={toc:[]},sjt="wrapper";function cjt(e){let{components:n,...t}=e;return(0,s.yg)(sjt,(0,p.A)({},rjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}cjt.isMDXComponent=!0;const ajt={toc:[]},ijt="wrapper";function ljt(e){let{components:n,...t}=e;return(0,s.yg)(ijt,(0,p.A)({},ajt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ljt.isMDXComponent=!0;const ujt={toc:[]},mjt="wrapper";function yjt(e){let{components:n,...t}=e;return(0,s.yg)(mjt,(0,p.A)({},ujt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}yjt.isMDXComponent=!0;const djt={toc:[]},hjt="wrapper";function gjt(e){let{components:n,...t}=e;return(0,s.yg)(hjt,(0,p.A)({},djt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}gjt.isMDXComponent=!0;const fjt={toc:[]},Djt="wrapper";function Mjt(e){let{components:n,...t}=e;return(0,s.yg)(Djt,(0,p.A)({},fjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Mjt.isMDXComponent=!0;const Xjt={toc:[]},_jt="wrapper";function wjt(e){let{components:n,...t}=e;return(0,s.yg)(_jt,(0,p.A)({},Xjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}wjt.isMDXComponent=!0;const Tjt={toc:[]},Cjt="wrapper";function xjt(e){let{components:n,...t}=e;return(0,s.yg)(Cjt,(0,p.A)({},Tjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}xjt.isMDXComponent=!0;const Ajt={toc:[]},vjt="wrapper";function Ljt(e){let{components:n,...t}=e;return(0,s.yg)(vjt,(0,p.A)({},Ajt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Ljt.isMDXComponent=!0;const bjt={toc:[]},Njt="wrapper";function kjt(e){let{components:n,...t}=e;return(0,s.yg)(Njt,(0,p.A)({},bjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kjt.isMDXComponent=!0;const zjt={toc:[]},Pjt="wrapper";function Ijt(e){let{components:n,...t}=e;return(0,s.yg)(Pjt,(0,p.A)({},zjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Ijt.isMDXComponent=!0;const Rjt={toc:[]},Wjt="wrapper";function Sjt(e){let{components:n,...t}=e;return(0,s.yg)(Wjt,(0,p.A)({},Rjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Sjt.isMDXComponent=!0;const Bjt={toc:[]},Gjt="wrapper";function Ejt(e){let{components:n,...t}=e;return(0,s.yg)(Gjt,(0,p.A)({},Bjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Ejt.isMDXComponent=!0;const Ojt={toc:[]},Ujt="wrapper";function Fjt(e){let{components:n,...t}=e;return(0,s.yg)(Ujt,(0,p.A)({},Ojt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Fjt.isMDXComponent=!0;const Vjt={toc:[]},qjt="wrapper";function jjt(e){let{components:n,...t}=e;return(0,s.yg)(qjt,(0,p.A)({},Vjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}jjt.isMDXComponent=!0;const Hjt={toc:[]},Yjt="wrapper";function Qjt(e){let{components:n,...t}=e;return(0,s.yg)(Yjt,(0,p.A)({},Hjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Qjt.isMDXComponent=!0;const $jt={toc:[]},Kjt="wrapper";function Jjt(e){let{components:n,...t}=e;return(0,s.yg)(Kjt,(0,p.A)({},$jt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Jjt.isMDXComponent=!0;const Zjt={toc:[]},eHt="wrapper";function nHt(e){let{components:n,...t}=e;return(0,s.yg)(eHt,(0,p.A)({},Zjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}nHt.isMDXComponent=!0;const tHt={toc:[]},oHt="wrapper";function pHt(e){let{components:n,...t}=e;return(0,s.yg)(oHt,(0,p.A)({},tHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}pHt.isMDXComponent=!0;const rHt={toc:[]},sHt="wrapper";function cHt(e){let{components:n,...t}=e;return(0,s.yg)(sHt,(0,p.A)({},rHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cHt.isMDXComponent=!0;const aHt={toc:[]},iHt="wrapper";function lHt(e){let{components:n,...t}=e;return(0,s.yg)(iHt,(0,p.A)({},aHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lHt.isMDXComponent=!0;const uHt={toc:[]},mHt="wrapper";function yHt(e){let{components:n,...t}=e;return(0,s.yg)(mHt,(0,p.A)({},uHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}yHt.isMDXComponent=!0;const dHt={toc:[]},hHt="wrapper";function gHt(e){let{components:n,...t}=e;return(0,s.yg)(hHt,(0,p.A)({},dHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}gHt.isMDXComponent=!0;const fHt={toc:[]},DHt="wrapper";function MHt(e){let{components:n,...t}=e;return(0,s.yg)(DHt,(0,p.A)({},fHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}MHt.isMDXComponent=!0;const XHt={toc:[]},_Ht="wrapper";function wHt(e){let{components:n,...t}=e;return(0,s.yg)(_Ht,(0,p.A)({},XHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}wHt.isMDXComponent=!0;const THt={toc:[]},CHt="wrapper";function xHt(e){let{components:n,...t}=e;return(0,s.yg)(CHt,(0,p.A)({},THt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}xHt.isMDXComponent=!0;const AHt={toc:[]},vHt="wrapper";function LHt(e){let{components:n,...t}=e;return(0,s.yg)(vHt,(0,p.A)({},AHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}LHt.isMDXComponent=!0;const bHt={toc:[]},NHt="wrapper";function kHt(e){let{components:n,...t}=e;return(0,s.yg)(NHt,(0,p.A)({},bHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}kHt.isMDXComponent=!0;const zHt={toc:[]},PHt="wrapper";function IHt(e){let{components:n,...t}=e;return(0,s.yg)(PHt,(0,p.A)({},zHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}IHt.isMDXComponent=!0;const RHt={toc:[]},WHt="wrapper";function SHt(e){let{components:n,...t}=e;return(0,s.yg)(WHt,(0,p.A)({},RHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}SHt.isMDXComponent=!0;const BHt={toc:[]},GHt="wrapper";function EHt(e){let{components:n,...t}=e;return(0,s.yg)(GHt,(0,p.A)({},BHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}EHt.isMDXComponent=!0;const OHt={toc:[]},UHt="wrapper";function FHt(e){let{components:n,...t}=e;return(0,s.yg)(UHt,(0,p.A)({},OHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}FHt.isMDXComponent=!0;const VHt={toc:[]},qHt="wrapper";function jHt(e){let{components:n,...t}=e;return(0,s.yg)(qHt,(0,p.A)({},VHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jHt.isMDXComponent=!0;const HHt={toc:[]},YHt="wrapper";function QHt(e){let{components:n,...t}=e;return(0,s.yg)(YHt,(0,p.A)({},HHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}QHt.isMDXComponent=!0;const $Ht={toc:[]},KHt="wrapper";function JHt(e){let{components:n,...t}=e;return(0,s.yg)(KHt,(0,p.A)({},$Ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}JHt.isMDXComponent=!0;const ZHt={toc:[]},eYt="wrapper";function nYt(e){let{components:n,...t}=e;return(0,s.yg)(eYt,(0,p.A)({},ZHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nYt.isMDXComponent=!0;const tYt={toc:[]},oYt="wrapper";function pYt(e){let{components:n,...t}=e;return(0,s.yg)(oYt,(0,p.A)({},tYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}pYt.isMDXComponent=!0;const rYt={toc:[]},sYt="wrapper";function cYt(e){let{components:n,...t}=e;return(0,s.yg)(sYt,(0,p.A)({},rYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}cYt.isMDXComponent=!0;const aYt={toc:[]},iYt="wrapper";function lYt(e){let{components:n,...t}=e;return(0,s.yg)(iYt,(0,p.A)({},aYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}lYt.isMDXComponent=!0;const uYt={toc:[]},mYt="wrapper";function yYt(e){let{components:n,...t}=e;return(0,s.yg)(mYt,(0,p.A)({},uYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}yYt.isMDXComponent=!0;const dYt={toc:[]},hYt="wrapper";function gYt(e){let{components:n,...t}=e;return(0,s.yg)(hYt,(0,p.A)({},dYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gYt.isMDXComponent=!0;const fYt={toc:[]},DYt="wrapper";function MYt(e){let{components:n,...t}=e;return(0,s.yg)(DYt,(0,p.A)({},fYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}MYt.isMDXComponent=!0;const XYt={toc:[]},_Yt="wrapper";function wYt(e){let{components:n,...t}=e;return(0,s.yg)(_Yt,(0,p.A)({},XYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wYt.isMDXComponent=!0;const TYt={toc:[]},CYt="wrapper";function xYt(e){let{components:n,...t}=e;return(0,s.yg)(CYt,(0,p.A)({},TYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}xYt.isMDXComponent=!0;const AYt={toc:[]},vYt="wrapper";function LYt(e){let{components:n,...t}=e;return(0,s.yg)(vYt,(0,p.A)({},AYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}LYt.isMDXComponent=!0;const bYt={toc:[]},NYt="wrapper";function kYt(e){let{components:n,...t}=e;return(0,s.yg)(NYt,(0,p.A)({},bYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}kYt.isMDXComponent=!0;const zYt={toc:[]},PYt="wrapper";function IYt(e){let{components:n,...t}=e;return(0,s.yg)(PYt,(0,p.A)({},zYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}IYt.isMDXComponent=!0;const RYt={toc:[]},WYt="wrapper";function SYt(e){let{components:n,...t}=e;return(0,s.yg)(WYt,(0,p.A)({},RYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}SYt.isMDXComponent=!0;const BYt={toc:[]},GYt="wrapper";function EYt(e){let{components:n,...t}=e;return(0,s.yg)(GYt,(0,p.A)({},BYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}EYt.isMDXComponent=!0;const OYt={toc:[]},UYt="wrapper";function FYt(e){let{components:n,...t}=e;return(0,s.yg)(UYt,(0,p.A)({},OYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}FYt.isMDXComponent=!0;const VYt={toc:[]},qYt="wrapper";function jYt(e){let{components:n,...t}=e;return(0,s.yg)(qYt,(0,p.A)({},VYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}jYt.isMDXComponent=!0;const HYt={toc:[]},YYt="wrapper";function QYt(e){let{components:n,...t}=e;return(0,s.yg)(YYt,(0,p.A)({},HYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}QYt.isMDXComponent=!0;const $Yt={toc:[]},KYt="wrapper";function JYt(e){let{components:n,...t}=e;return(0,s.yg)(KYt,(0,p.A)({},$Yt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}JYt.isMDXComponent=!0;const ZYt={toc:[]},eQt="wrapper";function nQt(e){let{components:n,...t}=e;return(0,s.yg)(eQt,(0,p.A)({},ZYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}nQt.isMDXComponent=!0;const tQt={toc:[]},oQt="wrapper";function pQt(e){let{components:n,...t}=e;return(0,s.yg)(oQt,(0,p.A)({},tQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}pQt.isMDXComponent=!0;const rQt={toc:[]},sQt="wrapper";function cQt(e){let{components:n,...t}=e;return(0,s.yg)(sQt,(0,p.A)({},rQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}cQt.isMDXComponent=!0;const aQt={toc:[]},iQt="wrapper";function lQt(e){let{components:n,...t}=e;return(0,s.yg)(iQt,(0,p.A)({},aQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}lQt.isMDXComponent=!0;const uQt={toc:[]},mQt="wrapper";function yQt(e){let{components:n,...t}=e;return(0,s.yg)(mQt,(0,p.A)({},uQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}yQt.isMDXComponent=!0;const dQt={toc:[]},hQt="wrapper";function gQt(e){let{components:n,...t}=e;return(0,s.yg)(hQt,(0,p.A)({},dQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}gQt.isMDXComponent=!0;const fQt={toc:[]},DQt="wrapper";function MQt(e){let{components:n,...t}=e;return(0,s.yg)(DQt,(0,p.A)({},fQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}MQt.isMDXComponent=!0;const XQt={toc:[]},_Qt="wrapper";function wQt(e){let{components:n,...t}=e;return(0,s.yg)(_Qt,(0,p.A)({},XQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}wQt.isMDXComponent=!0;const TQt={toc:[]},CQt="wrapper";function xQt(e){let{components:n,...t}=e;return(0,s.yg)(CQt,(0,p.A)({},TQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}xQt.isMDXComponent=!0;const AQt={toc:[]},vQt="wrapper";function LQt(e){let{components:n,...t}=e;return(0,s.yg)(vQt,(0,p.A)({},AQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}LQt.isMDXComponent=!0;const bQt={toc:[]},NQt="wrapper";function kQt(e){let{components:n,...t}=e;return(0,s.yg)(NQt,(0,p.A)({},bQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}kQt.isMDXComponent=!0;const zQt={toc:[]},PQt="wrapper";function IQt(e){let{components:n,...t}=e;return(0,s.yg)(PQt,(0,p.A)({},zQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}IQt.isMDXComponent=!0;const RQt={toc:[]},WQt="wrapper";function SQt(e){let{components:n,...t}=e;return(0,s.yg)(WQt,(0,p.A)({},RQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}SQt.isMDXComponent=!0;const BQt={toc:[]},GQt="wrapper";function EQt(e){let{components:n,...t}=e;return(0,s.yg)(GQt,(0,p.A)({},BQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}EQt.isMDXComponent=!0;const OQt={toc:[]},UQt="wrapper";function FQt(e){let{components:n,...t}=e;return(0,s.yg)(UQt,(0,p.A)({},OQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}FQt.isMDXComponent=!0;const VQt={toc:[]},qQt="wrapper";function jQt(e){let{components:n,...t}=e;return(0,s.yg)(qQt,(0,p.A)({},VQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}jQt.isMDXComponent=!0;const HQt={toc:[]},YQt="wrapper";function QQt(e){let{components:n,...t}=e;return(0,s.yg)(YQt,(0,p.A)({},HQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}QQt.isMDXComponent=!0;const $Qt={toc:[]},KQt="wrapper";function JQt(e){let{components:n,...t}=e;return(0,s.yg)(KQt,(0,p.A)({},$Qt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}JQt.isMDXComponent=!0;const ZQt={toc:[]},e$t="wrapper";function n$t(e){let{components:n,...t}=e;return(0,s.yg)(e$t,(0,p.A)({},ZQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}n$t.isMDXComponent=!0;const t$t={toc:[]},o$t="wrapper";function p$t(e){let{components:n,...t}=e;return(0,s.yg)(o$t,(0,p.A)({},t$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}p$t.isMDXComponent=!0;const r$t={toc:[]},s$t="wrapper";function c$t(e){let{components:n,...t}=e;return(0,s.yg)(s$t,(0,p.A)({},r$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}c$t.isMDXComponent=!0;const a$t={toc:[]},i$t="wrapper";function l$t(e){let{components:n,...t}=e;return(0,s.yg)(i$t,(0,p.A)({},a$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}l$t.isMDXComponent=!0;const u$t={toc:[]},m$t="wrapper";function y$t(e){let{components:n,...t}=e;return(0,s.yg)(m$t,(0,p.A)({},u$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}y$t.isMDXComponent=!0;const d$t={toc:[]},h$t="wrapper";function g$t(e){let{components:n,...t}=e;return(0,s.yg)(h$t,(0,p.A)({},d$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}g$t.isMDXComponent=!0;const f$t={toc:[]},D$t="wrapper";function M$t(e){let{components:n,...t}=e;return(0,s.yg)(D$t,(0,p.A)({},f$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}M$t.isMDXComponent=!0;const X$t={toc:[]},_$t="wrapper";function w$t(e){let{components:n,...t}=e;return(0,s.yg)(_$t,(0,p.A)({},X$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}w$t.isMDXComponent=!0;const T$t={toc:[]},C$t="wrapper";function x$t(e){let{components:n,...t}=e;return(0,s.yg)(C$t,(0,p.A)({},T$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}x$t.isMDXComponent=!0;const A$t={toc:[]},v$t="wrapper";function L$t(e){let{components:n,...t}=e;return(0,s.yg)(v$t,(0,p.A)({},A$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}L$t.isMDXComponent=!0;const b$t={toc:[]},N$t="wrapper";function k$t(e){let{components:n,...t}=e;return(0,s.yg)(N$t,(0,p.A)({},b$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}k$t.isMDXComponent=!0;const z$t={toc:[]},P$t="wrapper";function I$t(e){let{components:n,...t}=e;return(0,s.yg)(P$t,(0,p.A)({},z$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}I$t.isMDXComponent=!0;const R$t={toc:[]},W$t="wrapper";function S$t(e){let{components:n,...t}=e;return(0,s.yg)(W$t,(0,p.A)({},R$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}S$t.isMDXComponent=!0;const B$t={toc:[]},G$t="wrapper";function E$t(e){let{components:n,...t}=e;return(0,s.yg)(G$t,(0,p.A)({},B$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}E$t.isMDXComponent=!0;const O$t={toc:[]},U$t="wrapper";function F$t(e){let{components:n,...t}=e;return(0,s.yg)(U$t,(0,p.A)({},O$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}F$t.isMDXComponent=!0;const V$t={toc:[]},q$t="wrapper";function j$t(e){let{components:n,...t}=e;return(0,s.yg)(q$t,(0,p.A)({},V$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}j$t.isMDXComponent=!0;const H$t={toc:[]},Y$t="wrapper";function Q$t(e){let{components:n,...t}=e;return(0,s.yg)(Y$t,(0,p.A)({},H$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Q$t.isMDXComponent=!0;const $$t={toc:[]},K$t="wrapper";function J$t(e){let{components:n,...t}=e;return(0,s.yg)(K$t,(0,p.A)({},$$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}J$t.isMDXComponent=!0;const Z$t={toc:[]},eKt="wrapper";function nKt(e){let{components:n,...t}=e;return(0,s.yg)(eKt,(0,p.A)({},Z$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}nKt.isMDXComponent=!0;const tKt={toc:[]},oKt="wrapper";function pKt(e){let{components:n,...t}=e;return(0,s.yg)(oKt,(0,p.A)({},tKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}pKt.isMDXComponent=!0;const rKt={toc:[]},sKt="wrapper";function cKt(e){let{components:n,...t}=e;return(0,s.yg)(sKt,(0,p.A)({},rKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cKt.isMDXComponent=!0;const aKt={toc:[]},iKt="wrapper";function lKt(e){let{components:n,...t}=e;return(0,s.yg)(iKt,(0,p.A)({},aKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lKt.isMDXComponent=!0;const uKt={toc:[]},mKt="wrapper";function yKt(e){let{components:n,...t}=e;return(0,s.yg)(mKt,(0,p.A)({},uKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}yKt.isMDXComponent=!0;const dKt={toc:[]},hKt="wrapper";function gKt(e){let{components:n,...t}=e;return(0,s.yg)(hKt,(0,p.A)({},dKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gKt.isMDXComponent=!0;const fKt={toc:[]},DKt="wrapper";function MKt(e){let{components:n,...t}=e;return(0,s.yg)(DKt,(0,p.A)({},fKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}MKt.isMDXComponent=!0;const XKt={toc:[]},_Kt="wrapper";function wKt(e){let{components:n,...t}=e;return(0,s.yg)(_Kt,(0,p.A)({},XKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wKt.isMDXComponent=!0;const TKt={toc:[]},CKt="wrapper";function xKt(e){let{components:n,...t}=e;return(0,s.yg)(CKt,(0,p.A)({},TKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xKt.isMDXComponent=!0;const AKt={toc:[]},vKt="wrapper";function LKt(e){let{components:n,...t}=e;return(0,s.yg)(vKt,(0,p.A)({},AKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}LKt.isMDXComponent=!0;const bKt={toc:[]},NKt="wrapper";function kKt(e){let{components:n,...t}=e;return(0,s.yg)(NKt,(0,p.A)({},bKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kKt.isMDXComponent=!0;const zKt={toc:[]},PKt="wrapper";function IKt(e){let{components:n,...t}=e;return(0,s.yg)(PKt,(0,p.A)({},zKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}IKt.isMDXComponent=!0;const RKt={toc:[]},WKt="wrapper";function SKt(e){let{components:n,...t}=e;return(0,s.yg)(WKt,(0,p.A)({},RKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}SKt.isMDXComponent=!0;const BKt={toc:[]},GKt="wrapper";function EKt(e){let{components:n,...t}=e;return(0,s.yg)(GKt,(0,p.A)({},BKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}EKt.isMDXComponent=!0;const OKt={toc:[]},UKt="wrapper";function FKt(e){let{components:n,...t}=e;return(0,s.yg)(UKt,(0,p.A)({},OKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}FKt.isMDXComponent=!0;const VKt={toc:[]},qKt="wrapper";function jKt(e){let{components:n,...t}=e;return(0,s.yg)(qKt,(0,p.A)({},VKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}jKt.isMDXComponent=!0;const HKt={toc:[]},YKt="wrapper";function QKt(e){let{components:n,...t}=e;return(0,s.yg)(YKt,(0,p.A)({},HKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}QKt.isMDXComponent=!0;const $Kt={toc:[]},KKt="wrapper";function JKt(e){let{components:n,...t}=e;return(0,s.yg)(KKt,(0,p.A)({},$Kt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}JKt.isMDXComponent=!0;const ZKt={toc:[]},eJt="wrapper";function nJt(e){let{components:n,...t}=e;return(0,s.yg)(eJt,(0,p.A)({},ZKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}nJt.isMDXComponent=!0;const tJt={toc:[]},oJt="wrapper";function pJt(e){let{components:n,...t}=e;return(0,s.yg)(oJt,(0,p.A)({},tJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}pJt.isMDXComponent=!0;const rJt={toc:[]},sJt="wrapper";function cJt(e){let{components:n,...t}=e;return(0,s.yg)(sJt,(0,p.A)({},rJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}cJt.isMDXComponent=!0;const aJt={toc:[]},iJt="wrapper";function lJt(e){let{components:n,...t}=e;return(0,s.yg)(iJt,(0,p.A)({},aJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}lJt.isMDXComponent=!0;const uJt={toc:[]},mJt="wrapper";function yJt(e){let{components:n,...t}=e;return(0,s.yg)(mJt,(0,p.A)({},uJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}yJt.isMDXComponent=!0;const dJt={toc:[]},hJt="wrapper";function gJt(e){let{components:n,...t}=e;return(0,s.yg)(hJt,(0,p.A)({},dJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}gJt.isMDXComponent=!0;const fJt={toc:[]},DJt="wrapper";function MJt(e){let{components:n,...t}=e;return(0,s.yg)(DJt,(0,p.A)({},fJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}MJt.isMDXComponent=!0;const XJt={toc:[]},_Jt="wrapper";function wJt(e){let{components:n,...t}=e;return(0,s.yg)(_Jt,(0,p.A)({},XJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}wJt.isMDXComponent=!0;const TJt={toc:[]},CJt="wrapper";function xJt(e){let{components:n,...t}=e;return(0,s.yg)(CJt,(0,p.A)({},TJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}xJt.isMDXComponent=!0;const AJt={toc:[]},vJt="wrapper";function LJt(e){let{components:n,...t}=e;return(0,s.yg)(vJt,(0,p.A)({},AJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}LJt.isMDXComponent=!0;const bJt={toc:[]},NJt="wrapper";function kJt(e){let{components:n,...t}=e;return(0,s.yg)(NJt,(0,p.A)({},bJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kJt.isMDXComponent=!0;const zJt={toc:[]},PJt="wrapper";function IJt(e){let{components:n,...t}=e;return(0,s.yg)(PJt,(0,p.A)({},zJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IJt.isMDXComponent=!0;const RJt={toc:[]},WJt="wrapper";function SJt(e){let{components:n,...t}=e;return(0,s.yg)(WJt,(0,p.A)({},RJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}SJt.isMDXComponent=!0;const BJt={toc:[]},GJt="wrapper";function EJt(e){let{components:n,...t}=e;return(0,s.yg)(GJt,(0,p.A)({},BJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}EJt.isMDXComponent=!0;const OJt={toc:[]},UJt="wrapper";function FJt(e){let{components:n,...t}=e;return(0,s.yg)(UJt,(0,p.A)({},OJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}FJt.isMDXComponent=!0;const VJt={toc:[]},qJt="wrapper";function jJt(e){let{components:n,...t}=e;return(0,s.yg)(qJt,(0,p.A)({},VJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}jJt.isMDXComponent=!0;const HJt={toc:[]},YJt="wrapper";function QJt(e){let{components:n,...t}=e;return(0,s.yg)(YJt,(0,p.A)({},HJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QJt.isMDXComponent=!0;const $Jt={toc:[]},KJt="wrapper";function JJt(e){let{components:n,...t}=e;return(0,s.yg)(KJt,(0,p.A)({},$Jt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}JJt.isMDXComponent=!0;const ZJt={toc:[]},eZt="wrapper";function nZt(e){let{components:n,...t}=e;return(0,s.yg)(eZt,(0,p.A)({},ZJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}nZt.isMDXComponent=!0;const tZt={toc:[]},oZt="wrapper";function pZt(e){let{components:n,...t}=e;return(0,s.yg)(oZt,(0,p.A)({},tZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}pZt.isMDXComponent=!0;const rZt={toc:[]},sZt="wrapper";function cZt(e){let{components:n,...t}=e;return(0,s.yg)(sZt,(0,p.A)({},rZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}cZt.isMDXComponent=!0;const aZt={toc:[]},iZt="wrapper";function lZt(e){let{components:n,...t}=e;return(0,s.yg)(iZt,(0,p.A)({},aZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}lZt.isMDXComponent=!0;const uZt={toc:[]},mZt="wrapper";function yZt(e){let{components:n,...t}=e;return(0,s.yg)(mZt,(0,p.A)({},uZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}yZt.isMDXComponent=!0;const dZt={toc:[]},hZt="wrapper";function gZt(e){let{components:n,...t}=e;return(0,s.yg)(hZt,(0,p.A)({},dZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}gZt.isMDXComponent=!0;const fZt={toc:[]},DZt="wrapper";function MZt(e){let{components:n,...t}=e;return(0,s.yg)(DZt,(0,p.A)({},fZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}MZt.isMDXComponent=!0;const XZt={toc:[]},_Zt="wrapper";function wZt(e){let{components:n,...t}=e;return(0,s.yg)(_Zt,(0,p.A)({},XZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}wZt.isMDXComponent=!0;const TZt={toc:[]},CZt="wrapper";function xZt(e){let{components:n,...t}=e;return(0,s.yg)(CZt,(0,p.A)({},TZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}xZt.isMDXComponent=!0;const AZt={toc:[]},vZt="wrapper";function LZt(e){let{components:n,...t}=e;return(0,s.yg)(vZt,(0,p.A)({},AZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}LZt.isMDXComponent=!0;const bZt={toc:[]},NZt="wrapper";function kZt(e){let{components:n,...t}=e;return(0,s.yg)(NZt,(0,p.A)({},bZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start point of the B\xe9zier curve."))}kZt.isMDXComponent=!0;const zZt={toc:[]},PZt="wrapper";function IZt(e){let{components:n,...t}=e;return(0,s.yg)(PZt,(0,p.A)({},zZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The control point of the B\xe9zier curve."))}IZt.isMDXComponent=!0;const RZt={toc:[]},WZt="wrapper";function SZt(e){let{components:n,...t}=e;return(0,s.yg)(WZt,(0,p.A)({},RZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end point of the B\xe9zier curve."))}SZt.isMDXComponent=!0;const BZt={toc:[]},GZt="wrapper";function EZt(e){let{components:n,...t}=e;return(0,s.yg)(GZt,(0,p.A)({},BZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}EZt.isMDXComponent=!0;const OZt={toc:[]},UZt="wrapper";function FZt(e){let{components:n,...t}=e;return(0,s.yg)(UZt,(0,p.A)({},OZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}FZt.isMDXComponent=!0;const VZt={toc:[]},qZt="wrapper";function jZt(e){let{components:n,...t}=e;return(0,s.yg)(qZt,(0,p.A)({},VZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}jZt.isMDXComponent=!0;const HZt={toc:[]},YZt="wrapper";function QZt(e){let{components:n,...t}=e;return(0,s.yg)(YZt,(0,p.A)({},HZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}QZt.isMDXComponent=!0;const $Zt={toc:[]},KZt="wrapper";function JZt(e){let{components:n,...t}=e;return(0,s.yg)(KZt,(0,p.A)({},$Zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}JZt.isMDXComponent=!0;const ZZt={toc:[]},e0t="wrapper";function n0t(e){let{components:n,...t}=e;return(0,s.yg)(e0t,(0,p.A)({},ZZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}n0t.isMDXComponent=!0;const t0t={toc:[]},o0t="wrapper";function p0t(e){let{components:n,...t}=e;return(0,s.yg)(o0t,(0,p.A)({},t0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}p0t.isMDXComponent=!0;const r0t={toc:[]},s0t="wrapper";function c0t(e){let{components:n,...t}=e;return(0,s.yg)(s0t,(0,p.A)({},r0t,t,{components:n,mdxType:"MDXLayout"}))}c0t.isMDXComponent=!0;const a0t={toc:[]},i0t="wrapper";function l0t(e){let{components:n,...t}=e;return(0,s.yg)(i0t,(0,p.A)({},a0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}l0t.isMDXComponent=!0;const u0t={toc:[]},m0t="wrapper";function y0t(e){let{components:n,...t}=e;return(0,s.yg)(m0t,(0,p.A)({},u0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}y0t.isMDXComponent=!0;const d0t={toc:[]},h0t="wrapper";function g0t(e){let{components:n,...t}=e;return(0,s.yg)(h0t,(0,p.A)({},d0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}g0t.isMDXComponent=!0;const f0t={toc:[]},D0t="wrapper";function M0t(e){let{components:n,...t}=e;return(0,s.yg)(D0t,(0,p.A)({},f0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}M0t.isMDXComponent=!0;const X0t={toc:[]},_0t="wrapper";function w0t(e){let{components:n,...t}=e;return(0,s.yg)(_0t,(0,p.A)({},X0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}w0t.isMDXComponent=!0;const T0t={toc:[]},C0t="wrapper";function x0t(e){let{components:n,...t}=e;return(0,s.yg)(C0t,(0,p.A)({},T0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}x0t.isMDXComponent=!0;const A0t={toc:[]},v0t="wrapper";function L0t(e){let{components:n,...t}=e;return(0,s.yg)(v0t,(0,p.A)({},A0t,t,{components:n,mdxType:"MDXLayout"}))}L0t.isMDXComponent=!0;const b0t={toc:[]},N0t="wrapper";function k0t(e){let{components:n,...t}=e;return(0,s.yg)(N0t,(0,p.A)({},b0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}k0t.isMDXComponent=!0;const z0t={toc:[]},P0t="wrapper";function I0t(e){let{components:n,...t}=e;return(0,s.yg)(P0t,(0,p.A)({},z0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}I0t.isMDXComponent=!0;const R0t={toc:[]},W0t="wrapper";function S0t(e){let{components:n,...t}=e;return(0,s.yg)(W0t,(0,p.A)({},R0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}S0t.isMDXComponent=!0;const B0t={toc:[]},G0t="wrapper";function E0t(e){let{components:n,...t}=e;return(0,s.yg)(G0t,(0,p.A)({},B0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}E0t.isMDXComponent=!0;const O0t={toc:[]},U0t="wrapper";function F0t(e){let{components:n,...t}=e;return(0,s.yg)(U0t,(0,p.A)({},O0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}F0t.isMDXComponent=!0;const V0t={toc:[]},q0t="wrapper";function j0t(e){let{components:n,...t}=e;return(0,s.yg)(q0t,(0,p.A)({},V0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}j0t.isMDXComponent=!0;const H0t={toc:[]},Y0t="wrapper";function Q0t(e){let{components:n,...t}=e;return(0,s.yg)(Y0t,(0,p.A)({},H0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Q0t.isMDXComponent=!0;const $0t={toc:[]},K0t="wrapper";function J0t(e){let{components:n,...t}=e;return(0,s.yg)(K0t,(0,p.A)({},$0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}J0t.isMDXComponent=!0;const Z0t={toc:[]},e3t="wrapper";function n3t(e){let{components:n,...t}=e;return(0,s.yg)(e3t,(0,p.A)({},Z0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}n3t.isMDXComponent=!0;const t3t={toc:[]},o3t="wrapper";function p3t(e){let{components:n,...t}=e;return(0,s.yg)(o3t,(0,p.A)({},t3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}p3t.isMDXComponent=!0;const r3t={toc:[]},s3t="wrapper";function c3t(e){let{components:n,...t}=e;return(0,s.yg)(s3t,(0,p.A)({},r3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}c3t.isMDXComponent=!0;const a3t={toc:[]},i3t="wrapper";function l3t(e){let{components:n,...t}=e;return(0,s.yg)(i3t,(0,p.A)({},a3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}l3t.isMDXComponent=!0;const u3t={toc:[]},m3t="wrapper";function y3t(e){let{components:n,...t}=e;return(0,s.yg)(m3t,(0,p.A)({},u3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}y3t.isMDXComponent=!0;const d3t={toc:[]},h3t="wrapper";function g3t(e){let{components:n,...t}=e;return(0,s.yg)(h3t,(0,p.A)({},d3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}g3t.isMDXComponent=!0;const f3t={toc:[]},D3t="wrapper";function M3t(e){let{components:n,...t}=e;return(0,s.yg)(D3t,(0,p.A)({},f3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}M3t.isMDXComponent=!0;const X3t={toc:[]},_3t="wrapper";function w3t(e){let{components:n,...t}=e;return(0,s.yg)(_3t,(0,p.A)({},X3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}w3t.isMDXComponent=!0;const T3t={toc:[]},C3t="wrapper";function x3t(e){let{components:n,...t}=e;return(0,s.yg)(C3t,(0,p.A)({},T3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}x3t.isMDXComponent=!0;const A3t={toc:[]},v3t="wrapper";function L3t(e){let{components:n,...t}=e;return(0,s.yg)(v3t,(0,p.A)({},A3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}L3t.isMDXComponent=!0;const b3t={toc:[]},N3t="wrapper";function k3t(e){let{components:n,...t}=e;return(0,s.yg)(N3t,(0,p.A)({},b3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}k3t.isMDXComponent=!0;const z3t={toc:[]},P3t="wrapper";function I3t(e){let{components:n,...t}=e;return(0,s.yg)(P3t,(0,p.A)({},z3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}I3t.isMDXComponent=!0;const R3t={toc:[]},W3t="wrapper";function S3t(e){let{components:n,...t}=e;return(0,s.yg)(W3t,(0,p.A)({},R3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}S3t.isMDXComponent=!0;const B3t={toc:[]},G3t="wrapper";function E3t(e){let{components:n,...t}=e;return(0,s.yg)(G3t,(0,p.A)({},B3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}E3t.isMDXComponent=!0;const O3t={toc:[]},U3t="wrapper";function F3t(e){let{components:n,...t}=e;return(0,s.yg)(U3t,(0,p.A)({},O3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}F3t.isMDXComponent=!0;const V3t={toc:[]},q3t="wrapper";function j3t(e){let{components:n,...t}=e;return(0,s.yg)(q3t,(0,p.A)({},V3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}j3t.isMDXComponent=!0;const H3t={toc:[]},Y3t="wrapper";function Q3t(e){let{components:n,...t}=e;return(0,s.yg)(Y3t,(0,p.A)({},H3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Q3t.isMDXComponent=!0;const $3t={toc:[]},K3t="wrapper";function J3t(e){let{components:n,...t}=e;return(0,s.yg)(K3t,(0,p.A)({},$3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}J3t.isMDXComponent=!0;const Z3t={toc:[]},e8t="wrapper";function n8t(e){let{components:n,...t}=e;return(0,s.yg)(e8t,(0,p.A)({},Z3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}n8t.isMDXComponent=!0;const t8t={toc:[]},o8t="wrapper";function p8t(e){let{components:n,...t}=e;return(0,s.yg)(o8t,(0,p.A)({},t8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}p8t.isMDXComponent=!0;const r8t={toc:[]},s8t="wrapper";function c8t(e){let{components:n,...t}=e;return(0,s.yg)(s8t,(0,p.A)({},r8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}c8t.isMDXComponent=!0;const a8t={toc:[]},i8t="wrapper";function l8t(e){let{components:n,...t}=e;return(0,s.yg)(i8t,(0,p.A)({},a8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}l8t.isMDXComponent=!0;const u8t={toc:[]},m8t="wrapper";function y8t(e){let{components:n,...t}=e;return(0,s.yg)(m8t,(0,p.A)({},u8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}y8t.isMDXComponent=!0;const d8t={toc:[]},h8t="wrapper";function g8t(e){let{components:n,...t}=e;return(0,s.yg)(h8t,(0,p.A)({},d8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}g8t.isMDXComponent=!0;const f8t={toc:[]},D8t="wrapper";function M8t(e){let{components:n,...t}=e;return(0,s.yg)(D8t,(0,p.A)({},f8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}M8t.isMDXComponent=!0;const X8t={toc:[]},_8t="wrapper";function w8t(e){let{components:n,...t}=e;return(0,s.yg)(_8t,(0,p.A)({},X8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}w8t.isMDXComponent=!0;const T8t={toc:[]},C8t="wrapper";function x8t(e){let{components:n,...t}=e;return(0,s.yg)(C8t,(0,p.A)({},T8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}x8t.isMDXComponent=!0;const A8t={toc:[]},v8t="wrapper";function L8t(e){let{components:n,...t}=e;return(0,s.yg)(v8t,(0,p.A)({},A8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}L8t.isMDXComponent=!0;const b8t={toc:[]},N8t="wrapper";function k8t(e){let{components:n,...t}=e;return(0,s.yg)(N8t,(0,p.A)({},b8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}k8t.isMDXComponent=!0;const z8t={toc:[]},P8t="wrapper";function I8t(e){let{components:n,...t}=e;return(0,s.yg)(P8t,(0,p.A)({},z8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}I8t.isMDXComponent=!0;const R8t={toc:[]},W8t="wrapper";function S8t(e){let{components:n,...t}=e;return(0,s.yg)(W8t,(0,p.A)({},R8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}S8t.isMDXComponent=!0;const B8t={toc:[]},G8t="wrapper";function E8t(e){let{components:n,...t}=e;return(0,s.yg)(G8t,(0,p.A)({},B8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}E8t.isMDXComponent=!0;const O8t={toc:[]},U8t="wrapper";function F8t(e){let{components:n,...t}=e;return(0,s.yg)(U8t,(0,p.A)({},O8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}F8t.isMDXComponent=!0;const V8t={toc:[]},q8t="wrapper";function j8t(e){let{components:n,...t}=e;return(0,s.yg)(q8t,(0,p.A)({},V8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}j8t.isMDXComponent=!0;const H8t={toc:[]},Y8t="wrapper";function Q8t(e){let{components:n,...t}=e;return(0,s.yg)(Y8t,(0,p.A)({},H8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Q8t.isMDXComponent=!0;const $8t={toc:[]},K8t="wrapper";function J8t(e){let{components:n,...t}=e;return(0,s.yg)(K8t,(0,p.A)({},$8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}J8t.isMDXComponent=!0;const Z8t={toc:[]},e2t="wrapper";function n2t(e){let{components:n,...t}=e;return(0,s.yg)(e2t,(0,p.A)({},Z8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}n2t.isMDXComponent=!0;const t2t={toc:[]},o2t="wrapper";function p2t(e){let{components:n,...t}=e;return(0,s.yg)(o2t,(0,p.A)({},t2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}p2t.isMDXComponent=!0;const r2t={toc:[]},s2t="wrapper";function c2t(e){let{components:n,...t}=e;return(0,s.yg)(s2t,(0,p.A)({},r2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}c2t.isMDXComponent=!0;const a2t={toc:[]},i2t="wrapper";function l2t(e){let{components:n,...t}=e;return(0,s.yg)(i2t,(0,p.A)({},a2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}l2t.isMDXComponent=!0;const u2t={toc:[]},m2t="wrapper";function y2t(e){let{components:n,...t}=e;return(0,s.yg)(m2t,(0,p.A)({},u2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}y2t.isMDXComponent=!0;const d2t={toc:[]},h2t="wrapper";function g2t(e){let{components:n,...t}=e;return(0,s.yg)(h2t,(0,p.A)({},d2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}g2t.isMDXComponent=!0;const f2t={toc:[]},D2t="wrapper";function M2t(e){let{components:n,...t}=e;return(0,s.yg)(D2t,(0,p.A)({},f2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}M2t.isMDXComponent=!0;const X2t={toc:[]},_2t="wrapper";function w2t(e){let{components:n,...t}=e;return(0,s.yg)(_2t,(0,p.A)({},X2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}w2t.isMDXComponent=!0;const T2t={toc:[]},C2t="wrapper";function x2t(e){let{components:n,...t}=e;return(0,s.yg)(C2t,(0,p.A)({},T2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}x2t.isMDXComponent=!0;const A2t={toc:[]},v2t="wrapper";function L2t(e){let{components:n,...t}=e;return(0,s.yg)(v2t,(0,p.A)({},A2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}L2t.isMDXComponent=!0;const b2t={toc:[]},N2t="wrapper";function k2t(e){let{components:n,...t}=e;return(0,s.yg)(N2t,(0,p.A)({},b2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}k2t.isMDXComponent=!0;const z2t={toc:[]},P2t="wrapper";function I2t(e){let{components:n,...t}=e;return(0,s.yg)(P2t,(0,p.A)({},z2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}I2t.isMDXComponent=!0;const R2t={toc:[]},W2t="wrapper";function S2t(e){let{components:n,...t}=e;return(0,s.yg)(W2t,(0,p.A)({},R2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}S2t.isMDXComponent=!0;const B2t={toc:[]},G2t="wrapper";function E2t(e){let{components:n,...t}=e;return(0,s.yg)(G2t,(0,p.A)({},B2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}E2t.isMDXComponent=!0;const O2t={toc:[]},U2t="wrapper";function F2t(e){let{components:n,...t}=e;return(0,s.yg)(U2t,(0,p.A)({},O2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}F2t.isMDXComponent=!0;const V2t={toc:[]},q2t="wrapper";function j2t(e){let{components:n,...t}=e;return(0,s.yg)(q2t,(0,p.A)({},V2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}j2t.isMDXComponent=!0;const H2t={toc:[]},Y2t="wrapper";function Q2t(e){let{components:n,...t}=e;return(0,s.yg)(Y2t,(0,p.A)({},H2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Q2t.isMDXComponent=!0;const $2t={toc:[]},K2t="wrapper";function J2t(e){let{components:n,...t}=e;return(0,s.yg)(K2t,(0,p.A)({},$2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}J2t.isMDXComponent=!0;const Z2t={toc:[]},e1t="wrapper";function n1t(e){let{components:n,...t}=e;return(0,s.yg)(e1t,(0,p.A)({},Z2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}n1t.isMDXComponent=!0;const t1t={toc:[]},o1t="wrapper";function p1t(e){let{components:n,...t}=e;return(0,s.yg)(o1t,(0,p.A)({},t1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}p1t.isMDXComponent=!0;const r1t={toc:[]},s1t="wrapper";function c1t(e){let{components:n,...t}=e;return(0,s.yg)(s1t,(0,p.A)({},r1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}c1t.isMDXComponent=!0;const a1t={toc:[]},i1t="wrapper";function l1t(e){let{components:n,...t}=e;return(0,s.yg)(i1t,(0,p.A)({},a1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}l1t.isMDXComponent=!0;const u1t={toc:[]},m1t="wrapper";function y1t(e){let{components:n,...t}=e;return(0,s.yg)(m1t,(0,p.A)({},u1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}y1t.isMDXComponent=!0;const d1t={toc:[]},h1t="wrapper";function g1t(e){let{components:n,...t}=e;return(0,s.yg)(h1t,(0,p.A)({},d1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}g1t.isMDXComponent=!0;const f1t={toc:[]},D1t="wrapper";function M1t(e){let{components:n,...t}=e;return(0,s.yg)(D1t,(0,p.A)({},f1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}M1t.isMDXComponent=!0;const X1t={toc:[]},_1t="wrapper";function w1t(e){let{components:n,...t}=e;return(0,s.yg)(_1t,(0,p.A)({},X1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}w1t.isMDXComponent=!0;const T1t={toc:[]},C1t="wrapper";function x1t(e){let{components:n,...t}=e;return(0,s.yg)(C1t,(0,p.A)({},T1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}x1t.isMDXComponent=!0;const A1t={toc:[]},v1t="wrapper";function L1t(e){let{components:n,...t}=e;return(0,s.yg)(v1t,(0,p.A)({},A1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}L1t.isMDXComponent=!0;const b1t={toc:[]},N1t="wrapper";function k1t(e){let{components:n,...t}=e;return(0,s.yg)(N1t,(0,p.A)({},b1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}k1t.isMDXComponent=!0;const z1t={toc:[]},P1t="wrapper";function I1t(e){let{components:n,...t}=e;return(0,s.yg)(P1t,(0,p.A)({},z1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}I1t.isMDXComponent=!0;const R1t={toc:[]},W1t="wrapper";function S1t(e){let{components:n,...t}=e;return(0,s.yg)(W1t,(0,p.A)({},R1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}S1t.isMDXComponent=!0;const B1t={toc:[]},G1t="wrapper";function E1t(e){let{components:n,...t}=e;return(0,s.yg)(G1t,(0,p.A)({},B1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}E1t.isMDXComponent=!0;const O1t={toc:[]},U1t="wrapper";function F1t(e){let{components:n,...t}=e;return(0,s.yg)(U1t,(0,p.A)({},O1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}F1t.isMDXComponent=!0;const V1t={toc:[]},q1t="wrapper";function j1t(e){let{components:n,...t}=e;return(0,s.yg)(q1t,(0,p.A)({},V1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}j1t.isMDXComponent=!0;const H1t={toc:[]},Y1t="wrapper";function Q1t(e){let{components:n,...t}=e;return(0,s.yg)(Y1t,(0,p.A)({},H1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Q1t.isMDXComponent=!0;const $1t={toc:[]},K1t="wrapper";function J1t(e){let{components:n,...t}=e;return(0,s.yg)(K1t,(0,p.A)({},$1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}J1t.isMDXComponent=!0;const Z1t={toc:[]},e4t="wrapper";function n4t(e){let{components:n,...t}=e;return(0,s.yg)(e4t,(0,p.A)({},Z1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}n4t.isMDXComponent=!0;const t4t={toc:[]},o4t="wrapper";function p4t(e){let{components:n,...t}=e;return(0,s.yg)(o4t,(0,p.A)({},t4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}p4t.isMDXComponent=!0;const r4t={toc:[]},s4t="wrapper";function c4t(e){let{components:n,...t}=e;return(0,s.yg)(s4t,(0,p.A)({},r4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}c4t.isMDXComponent=!0;const a4t={toc:[]},i4t="wrapper";function l4t(e){let{components:n,...t}=e;return(0,s.yg)(i4t,(0,p.A)({},a4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}l4t.isMDXComponent=!0;const u4t={toc:[]},m4t="wrapper";function y4t(e){let{components:n,...t}=e;return(0,s.yg)(m4t,(0,p.A)({},u4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}y4t.isMDXComponent=!0;const d4t={toc:[]},h4t="wrapper";function g4t(e){let{components:n,...t}=e;return(0,s.yg)(h4t,(0,p.A)({},d4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}g4t.isMDXComponent=!0;const f4t={toc:[]},D4t="wrapper";function M4t(e){let{components:n,...t}=e;return(0,s.yg)(D4t,(0,p.A)({},f4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}M4t.isMDXComponent=!0;const X4t={toc:[]},_4t="wrapper";function w4t(e){let{components:n,...t}=e;return(0,s.yg)(_4t,(0,p.A)({},X4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}w4t.isMDXComponent=!0;const T4t={toc:[]},C4t="wrapper";function x4t(e){let{components:n,...t}=e;return(0,s.yg)(C4t,(0,p.A)({},T4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}x4t.isMDXComponent=!0;const A4t={toc:[]},v4t="wrapper";function L4t(e){let{components:n,...t}=e;return(0,s.yg)(v4t,(0,p.A)({},A4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}L4t.isMDXComponent=!0;const b4t={toc:[]},N4t="wrapper";function k4t(e){let{components:n,...t}=e;return(0,s.yg)(N4t,(0,p.A)({},b4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}k4t.isMDXComponent=!0;const z4t={toc:[]},P4t="wrapper";function I4t(e){let{components:n,...t}=e;return(0,s.yg)(P4t,(0,p.A)({},z4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}I4t.isMDXComponent=!0;const R4t={toc:[]},W4t="wrapper";function S4t(e){let{components:n,...t}=e;return(0,s.yg)(W4t,(0,p.A)({},R4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}S4t.isMDXComponent=!0;const B4t={toc:[]},G4t="wrapper";function E4t(e){let{components:n,...t}=e;return(0,s.yg)(G4t,(0,p.A)({},B4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}E4t.isMDXComponent=!0;const O4t={toc:[]},U4t="wrapper";function F4t(e){let{components:n,...t}=e;return(0,s.yg)(U4t,(0,p.A)({},O4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}F4t.isMDXComponent=!0;const V4t={toc:[]},q4t="wrapper";function j4t(e){let{components:n,...t}=e;return(0,s.yg)(q4t,(0,p.A)({},V4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}j4t.isMDXComponent=!0;const H4t={toc:[]},Y4t="wrapper";function Q4t(e){let{components:n,...t}=e;return(0,s.yg)(Y4t,(0,p.A)({},H4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Q4t.isMDXComponent=!0;const $4t={toc:[]},K4t="wrapper";function J4t(e){let{components:n,...t}=e;return(0,s.yg)(K4t,(0,p.A)({},$4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}J4t.isMDXComponent=!0;const Z4t={toc:[]},e6t="wrapper";function n6t(e){let{components:n,...t}=e;return(0,s.yg)(e6t,(0,p.A)({},Z4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}n6t.isMDXComponent=!0;const t6t={toc:[]},o6t="wrapper";function p6t(e){let{components:n,...t}=e;return(0,s.yg)(o6t,(0,p.A)({},t6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}p6t.isMDXComponent=!0;const r6t={toc:[]},s6t="wrapper";function c6t(e){let{components:n,...t}=e;return(0,s.yg)(s6t,(0,p.A)({},r6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}c6t.isMDXComponent=!0;const a6t={toc:[]},i6t="wrapper";function l6t(e){let{components:n,...t}=e;return(0,s.yg)(i6t,(0,p.A)({},a6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}l6t.isMDXComponent=!0;const u6t={toc:[]},m6t="wrapper";function y6t(e){let{components:n,...t}=e;return(0,s.yg)(m6t,(0,p.A)({},u6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}y6t.isMDXComponent=!0;const d6t={toc:[]},h6t="wrapper";function g6t(e){let{components:n,...t}=e;return(0,s.yg)(h6t,(0,p.A)({},d6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}g6t.isMDXComponent=!0;const f6t={toc:[]},D6t="wrapper";function M6t(e){let{components:n,...t}=e;return(0,s.yg)(D6t,(0,p.A)({},f6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}M6t.isMDXComponent=!0;const X6t={toc:[]},_6t="wrapper";function w6t(e){let{components:n,...t}=e;return(0,s.yg)(_6t,(0,p.A)({},X6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}w6t.isMDXComponent=!0;const T6t={toc:[]},C6t="wrapper";function x6t(e){let{components:n,...t}=e;return(0,s.yg)(C6t,(0,p.A)({},T6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}x6t.isMDXComponent=!0;const A6t={toc:[]},v6t="wrapper";function L6t(e){let{components:n,...t}=e;return(0,s.yg)(v6t,(0,p.A)({},A6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}L6t.isMDXComponent=!0;const b6t={toc:[]},N6t="wrapper";function k6t(e){let{components:n,...t}=e;return(0,s.yg)(N6t,(0,p.A)({},b6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}k6t.isMDXComponent=!0;const z6t={toc:[]},P6t="wrapper";function I6t(e){let{components:n,...t}=e;return(0,s.yg)(P6t,(0,p.A)({},z6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}I6t.isMDXComponent=!0;const R6t={toc:[]},W6t="wrapper";function S6t(e){let{components:n,...t}=e;return(0,s.yg)(W6t,(0,p.A)({},R6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}S6t.isMDXComponent=!0;const B6t={toc:[]},G6t="wrapper";function E6t(e){let{components:n,...t}=e;return(0,s.yg)(G6t,(0,p.A)({},B6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}E6t.isMDXComponent=!0;const O6t={toc:[]},U6t="wrapper";function F6t(e){let{components:n,...t}=e;return(0,s.yg)(U6t,(0,p.A)({},O6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}F6t.isMDXComponent=!0;const V6t={toc:[]},q6t="wrapper";function j6t(e){let{components:n,...t}=e;return(0,s.yg)(q6t,(0,p.A)({},V6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}j6t.isMDXComponent=!0;const H6t={toc:[]},Y6t="wrapper";function Q6t(e){let{components:n,...t}=e;return(0,s.yg)(Y6t,(0,p.A)({},H6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Q6t.isMDXComponent=!0;const $6t={toc:[]},K6t="wrapper";function J6t(e){let{components:n,...t}=e;return(0,s.yg)(K6t,(0,p.A)({},$6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}J6t.isMDXComponent=!0;const Z6t={toc:[]},e5t="wrapper";function n5t(e){let{components:n,...t}=e;return(0,s.yg)(e5t,(0,p.A)({},Z6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}n5t.isMDXComponent=!0;const t5t={toc:[]},o5t="wrapper";function p5t(e){let{components:n,...t}=e;return(0,s.yg)(o5t,(0,p.A)({},t5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}p5t.isMDXComponent=!0;const r5t={toc:[]},s5t="wrapper";function c5t(e){let{components:n,...t}=e;return(0,s.yg)(s5t,(0,p.A)({},r5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}c5t.isMDXComponent=!0;const a5t={toc:[]},i5t="wrapper";function l5t(e){let{components:n,...t}=e;return(0,s.yg)(i5t,(0,p.A)({},a5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}l5t.isMDXComponent=!0;const u5t={toc:[]},m5t="wrapper";function y5t(e){let{components:n,...t}=e;return(0,s.yg)(m5t,(0,p.A)({},u5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}y5t.isMDXComponent=!0;const d5t={toc:[]},h5t="wrapper";function g5t(e){let{components:n,...t}=e;return(0,s.yg)(h5t,(0,p.A)({},d5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}g5t.isMDXComponent=!0;const f5t={toc:[]},D5t="wrapper";function M5t(e){let{components:n,...t}=e;return(0,s.yg)(D5t,(0,p.A)({},f5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}M5t.isMDXComponent=!0;const X5t={toc:[]},_5t="wrapper";function w5t(e){let{components:n,...t}=e;return(0,s.yg)(_5t,(0,p.A)({},X5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}w5t.isMDXComponent=!0;const T5t={toc:[]},C5t="wrapper";function x5t(e){let{components:n,...t}=e;return(0,s.yg)(C5t,(0,p.A)({},T5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}x5t.isMDXComponent=!0;const A5t={toc:[]},v5t="wrapper";function L5t(e){let{components:n,...t}=e;return(0,s.yg)(v5t,(0,p.A)({},A5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}L5t.isMDXComponent=!0;const b5t={toc:[]},N5t="wrapper";function k5t(e){let{components:n,...t}=e;return(0,s.yg)(N5t,(0,p.A)({},b5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}k5t.isMDXComponent=!0;const z5t={toc:[]},P5t="wrapper";function I5t(e){let{components:n,...t}=e;return(0,s.yg)(P5t,(0,p.A)({},z5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}I5t.isMDXComponent=!0;const R5t={toc:[]},W5t="wrapper";function S5t(e){let{components:n,...t}=e;return(0,s.yg)(W5t,(0,p.A)({},R5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}S5t.isMDXComponent=!0;const B5t={toc:[]},G5t="wrapper";function E5t(e){let{components:n,...t}=e;return(0,s.yg)(G5t,(0,p.A)({},B5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}E5t.isMDXComponent=!0;const O5t={toc:[]},U5t="wrapper";function F5t(e){let{components:n,...t}=e;return(0,s.yg)(U5t,(0,p.A)({},O5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}F5t.isMDXComponent=!0;const V5t={toc:[]},q5t="wrapper";function j5t(e){let{components:n,...t}=e;return(0,s.yg)(q5t,(0,p.A)({},V5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}j5t.isMDXComponent=!0;const H5t={toc:[]},Y5t="wrapper";function Q5t(e){let{components:n,...t}=e;return(0,s.yg)(Y5t,(0,p.A)({},H5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Q5t.isMDXComponent=!0;const $5t={toc:[]},K5t="wrapper";function J5t(e){let{components:n,...t}=e;return(0,s.yg)(K5t,(0,p.A)({},$5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}J5t.isMDXComponent=!0;const Z5t={toc:[]},e7t="wrapper";function n7t(e){let{components:n,...t}=e;return(0,s.yg)(e7t,(0,p.A)({},Z5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}n7t.isMDXComponent=!0;const t7t={toc:[]},o7t="wrapper";function p7t(e){let{components:n,...t}=e;return(0,s.yg)(o7t,(0,p.A)({},t7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}p7t.isMDXComponent=!0;const r7t={toc:[]},s7t="wrapper";function c7t(e){let{components:n,...t}=e;return(0,s.yg)(s7t,(0,p.A)({},r7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}c7t.isMDXComponent=!0;const a7t={toc:[]},i7t="wrapper";function l7t(e){let{components:n,...t}=e;return(0,s.yg)(i7t,(0,p.A)({},a7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}l7t.isMDXComponent=!0;const u7t={toc:[]},m7t="wrapper";function y7t(e){let{components:n,...t}=e;return(0,s.yg)(m7t,(0,p.A)({},u7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}y7t.isMDXComponent=!0;const d7t={toc:[]},h7t="wrapper";function g7t(e){let{components:n,...t}=e;return(0,s.yg)(h7t,(0,p.A)({},d7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}g7t.isMDXComponent=!0;const f7t={toc:[]},D7t="wrapper";function M7t(e){let{components:n,...t}=e;return(0,s.yg)(D7t,(0,p.A)({},f7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}M7t.isMDXComponent=!0;const X7t={toc:[]},_7t="wrapper";function w7t(e){let{components:n,...t}=e;return(0,s.yg)(_7t,(0,p.A)({},X7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}w7t.isMDXComponent=!0;const T7t={toc:[]},C7t="wrapper";function x7t(e){let{components:n,...t}=e;return(0,s.yg)(C7t,(0,p.A)({},T7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}x7t.isMDXComponent=!0;const A7t={toc:[]},v7t="wrapper";function L7t(e){let{components:n,...t}=e;return(0,s.yg)(v7t,(0,p.A)({},A7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}L7t.isMDXComponent=!0;const b7t={toc:[]},N7t="wrapper";function k7t(e){let{components:n,...t}=e;return(0,s.yg)(N7t,(0,p.A)({},b7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}k7t.isMDXComponent=!0;const z7t={toc:[]},P7t="wrapper";function I7t(e){let{components:n,...t}=e;return(0,s.yg)(P7t,(0,p.A)({},z7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}I7t.isMDXComponent=!0;const R7t={toc:[]},W7t="wrapper";function S7t(e){let{components:n,...t}=e;return(0,s.yg)(W7t,(0,p.A)({},R7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}S7t.isMDXComponent=!0;const B7t={toc:[]},G7t="wrapper";function E7t(e){let{components:n,...t}=e;return(0,s.yg)(G7t,(0,p.A)({},B7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}E7t.isMDXComponent=!0;const O7t={toc:[]},U7t="wrapper";function F7t(e){let{components:n,...t}=e;return(0,s.yg)(U7t,(0,p.A)({},O7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}F7t.isMDXComponent=!0;const V7t={toc:[]},q7t="wrapper";function j7t(e){let{components:n,...t}=e;return(0,s.yg)(q7t,(0,p.A)({},V7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}j7t.isMDXComponent=!0;const H7t={toc:[]},Y7t="wrapper";function Q7t(e){let{components:n,...t}=e;return(0,s.yg)(Y7t,(0,p.A)({},H7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Q7t.isMDXComponent=!0;const $7t={toc:[]},K7t="wrapper";function J7t(e){let{components:n,...t}=e;return(0,s.yg)(K7t,(0,p.A)({},$7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}J7t.isMDXComponent=!0;const Z7t={toc:[]},e9t="wrapper";function n9t(e){let{components:n,...t}=e;return(0,s.yg)(e9t,(0,p.A)({},Z7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}n9t.isMDXComponent=!0;const t9t={toc:[]},o9t="wrapper";function p9t(e){let{components:n,...t}=e;return(0,s.yg)(o9t,(0,p.A)({},t9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}p9t.isMDXComponent=!0;const r9t={toc:[]},s9t="wrapper";function c9t(e){let{components:n,...t}=e;return(0,s.yg)(s9t,(0,p.A)({},r9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}c9t.isMDXComponent=!0;const a9t={toc:[]},i9t="wrapper";function l9t(e){let{components:n,...t}=e;return(0,s.yg)(i9t,(0,p.A)({},a9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}l9t.isMDXComponent=!0;const u9t={toc:[]},m9t="wrapper";function y9t(e){let{components:n,...t}=e;return(0,s.yg)(m9t,(0,p.A)({},u9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}y9t.isMDXComponent=!0;const d9t={toc:[]},h9t="wrapper";function g9t(e){let{components:n,...t}=e;return(0,s.yg)(h9t,(0,p.A)({},d9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}g9t.isMDXComponent=!0;const f9t={toc:[]},D9t="wrapper";function M9t(e){let{components:n,...t}=e;return(0,s.yg)(D9t,(0,p.A)({},f9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}M9t.isMDXComponent=!0;const X9t={toc:[]},_9t="wrapper";function w9t(e){let{components:n,...t}=e;return(0,s.yg)(_9t,(0,p.A)({},X9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}w9t.isMDXComponent=!0;const T9t={toc:[]},C9t="wrapper";function x9t(e){let{components:n,...t}=e;return(0,s.yg)(C9t,(0,p.A)({},T9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}x9t.isMDXComponent=!0;const A9t={toc:[]},v9t="wrapper";function L9t(e){let{components:n,...t}=e;return(0,s.yg)(v9t,(0,p.A)({},A9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}L9t.isMDXComponent=!0;const b9t={toc:[]},N9t="wrapper";function k9t(e){let{components:n,...t}=e;return(0,s.yg)(N9t,(0,p.A)({},b9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}k9t.isMDXComponent=!0;const z9t={toc:[]},P9t="wrapper";function I9t(e){let{components:n,...t}=e;return(0,s.yg)(P9t,(0,p.A)({},z9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}I9t.isMDXComponent=!0;const R9t={toc:[]},W9t="wrapper";function S9t(e){let{components:n,...t}=e;return(0,s.yg)(W9t,(0,p.A)({},R9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}S9t.isMDXComponent=!0;const B9t={toc:[]},G9t="wrapper";function E9t(e){let{components:n,...t}=e;return(0,s.yg)(G9t,(0,p.A)({},B9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}E9t.isMDXComponent=!0;const O9t={toc:[]},U9t="wrapper";function F9t(e){let{components:n,...t}=e;return(0,s.yg)(U9t,(0,p.A)({},O9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}F9t.isMDXComponent=!0;const V9t={toc:[]},q9t="wrapper";function j9t(e){let{components:n,...t}=e;return(0,s.yg)(q9t,(0,p.A)({},V9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}j9t.isMDXComponent=!0;const H9t={toc:[]},Y9t="wrapper";function Q9t(e){let{components:n,...t}=e;return(0,s.yg)(Y9t,(0,p.A)({},H9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@revideo/2d';\nimport {Ray} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}Q9t.isMDXComponent=!0;const $9t={toc:[]},K9t="wrapper";function J9t(e){let{components:n,...t}=e;return(0,s.yg)(K9t,(0,p.A)({},$9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing an individual line segment."))}J9t.isMDXComponent=!0;const Z9t={toc:[]},eeo="wrapper";function neo(e){let{components:n,...t}=e;return(0,s.yg)(eeo,(0,p.A)({},Z9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}neo.isMDXComponent=!0;const teo={toc:[]},oeo="wrapper";function peo(e){let{components:n,...t}=e;return(0,s.yg)(oeo,(0,p.A)({},teo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}peo.isMDXComponent=!0;const reo={toc:[]},seo="wrapper";function ceo(e){let{components:n,...t}=e;return(0,s.yg)(seo,(0,p.A)({},reo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ceo.isMDXComponent=!0;const aeo={toc:[]},ieo="wrapper";function leo(e){let{components:n,...t}=e;return(0,s.yg)(ieo,(0,p.A)({},aeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}leo.isMDXComponent=!0;const ueo={toc:[]},meo="wrapper";function yeo(e){let{components:n,...t}=e;return(0,s.yg)(meo,(0,p.A)({},ueo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}yeo.isMDXComponent=!0;const deo={toc:[]},heo="wrapper";function geo(e){let{components:n,...t}=e;return(0,s.yg)(heo,(0,p.A)({},deo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}geo.isMDXComponent=!0;const feo={toc:[]},Deo="wrapper";function Meo(e){let{components:n,...t}=e;return(0,s.yg)(Deo,(0,p.A)({},feo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Meo.isMDXComponent=!0;const Xeo={toc:[]},_eo="wrapper";function weo(e){let{components:n,...t}=e;return(0,s.yg)(_eo,(0,p.A)({},Xeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}weo.isMDXComponent=!0;const Teo={toc:[]},Ceo="wrapper";function xeo(e){let{components:n,...t}=e;return(0,s.yg)(Ceo,(0,p.A)({},Teo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}xeo.isMDXComponent=!0;const Aeo={toc:[]},veo="wrapper";function Leo(e){let{components:n,...t}=e;return(0,s.yg)(veo,(0,p.A)({},Aeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Leo.isMDXComponent=!0;const beo={toc:[]},Neo="wrapper";function keo(e){let{components:n,...t}=e;return(0,s.yg)(Neo,(0,p.A)({},beo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}keo.isMDXComponent=!0;const zeo={toc:[]},Peo="wrapper";function Ieo(e){let{components:n,...t}=e;return(0,s.yg)(Peo,(0,p.A)({},zeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Ieo.isMDXComponent=!0;const Reo={toc:[]},Weo="wrapper";function Seo(e){let{components:n,...t}=e;return(0,s.yg)(Weo,(0,p.A)({},Reo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Seo.isMDXComponent=!0;const Beo={toc:[]},Geo="wrapper";function Eeo(e){let{components:n,...t}=e;return(0,s.yg)(Geo,(0,p.A)({},Beo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Eeo.isMDXComponent=!0;const Oeo={toc:[]},Ueo="wrapper";function Feo(e){let{components:n,...t}=e;return(0,s.yg)(Ueo,(0,p.A)({},Oeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Feo.isMDXComponent=!0;const Veo={toc:[]},qeo="wrapper";function jeo(e){let{components:n,...t}=e;return(0,s.yg)(qeo,(0,p.A)({},Veo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jeo.isMDXComponent=!0;const Heo={toc:[]},Yeo="wrapper";function Qeo(e){let{components:n,...t}=e;return(0,s.yg)(Yeo,(0,p.A)({},Heo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Qeo.isMDXComponent=!0;const $eo={toc:[]},Keo="wrapper";function Jeo(e){let{components:n,...t}=e;return(0,s.yg)(Keo,(0,p.A)({},$eo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Jeo.isMDXComponent=!0;const Zeo={toc:[]},eno="wrapper";function nno(e){let{components:n,...t}=e;return(0,s.yg)(eno,(0,p.A)({},Zeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}nno.isMDXComponent=!0;const tno={toc:[]},ono="wrapper";function pno(e){let{components:n,...t}=e;return(0,s.yg)(ono,(0,p.A)({},tno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}pno.isMDXComponent=!0;const rno={toc:[]},sno="wrapper";function cno(e){let{components:n,...t}=e;return(0,s.yg)(sno,(0,p.A)({},rno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cno.isMDXComponent=!0;const ano={toc:[]},ino="wrapper";function lno(e){let{components:n,...t}=e;return(0,s.yg)(ino,(0,p.A)({},ano,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}lno.isMDXComponent=!0;const uno={toc:[]},mno="wrapper";function yno(e){let{components:n,...t}=e;return(0,s.yg)(mno,(0,p.A)({},uno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}yno.isMDXComponent=!0;const dno={toc:[]},hno="wrapper";function gno(e){let{components:n,...t}=e;return(0,s.yg)(hno,(0,p.A)({},dno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}gno.isMDXComponent=!0;const fno={toc:[]},Dno="wrapper";function Mno(e){let{components:n,...t}=e;return(0,s.yg)(Dno,(0,p.A)({},fno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting point of the ray."))}Mno.isMDXComponent=!0;const Xno={toc:[]},_no="wrapper";function wno(e){let{components:n,...t}=e;return(0,s.yg)(_no,(0,p.A)({},Xno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}wno.isMDXComponent=!0;const Tno={toc:[]},Cno="wrapper";function xno(e){let{components:n,...t}=e;return(0,s.yg)(Cno,(0,p.A)({},Tno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}xno.isMDXComponent=!0;const Ano={toc:[]},vno="wrapper";function Lno(e){let{components:n,...t}=e;return(0,s.yg)(vno,(0,p.A)({},Ano,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Lno.isMDXComponent=!0;const bno={toc:[]},Nno="wrapper";function kno(e){let{components:n,...t}=e;return(0,s.yg)(Nno,(0,p.A)({},bno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}kno.isMDXComponent=!0;const zno={toc:[]},Pno="wrapper";function Ino(e){let{components:n,...t}=e;return(0,s.yg)(Pno,(0,p.A)({},zno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ino.isMDXComponent=!0;const Rno={toc:[]},Wno="wrapper";function Sno(e){let{components:n,...t}=e;return(0,s.yg)(Wno,(0,p.A)({},Rno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Sno.isMDXComponent=!0;const Bno={toc:[]},Gno="wrapper";function Eno(e){let{components:n,...t}=e;return(0,s.yg)(Gno,(0,p.A)({},Bno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Eno.isMDXComponent=!0;const Ono={toc:[]},Uno="wrapper";function Fno(e){let{components:n,...t}=e;return(0,s.yg)(Uno,(0,p.A)({},Ono,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Fno.isMDXComponent=!0;const Vno={toc:[]},qno="wrapper";function jno(e){let{components:n,...t}=e;return(0,s.yg)(qno,(0,p.A)({},Vno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jno.isMDXComponent=!0;const Hno={toc:[]},Yno="wrapper";function Qno(e){let{components:n,...t}=e;return(0,s.yg)(Yno,(0,p.A)({},Hno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Qno.isMDXComponent=!0;const $no={toc:[]},Kno="wrapper";function Jno(e){let{components:n,...t}=e;return(0,s.yg)(Kno,(0,p.A)({},$no,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Jno.isMDXComponent=!0;const Zno={toc:[]},eto="wrapper";function nto(e){let{components:n,...t}=e;return(0,s.yg)(eto,(0,p.A)({},Zno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}nto.isMDXComponent=!0;const tto={toc:[]},oto="wrapper";function pto(e){let{components:n,...t}=e;return(0,s.yg)(oto,(0,p.A)({},tto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}pto.isMDXComponent=!0;const rto={toc:[]},sto="wrapper";function cto(e){let{components:n,...t}=e;return(0,s.yg)(sto,(0,p.A)({},rto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cto.isMDXComponent=!0;const ato={toc:[]},ito="wrapper";function lto(e){let{components:n,...t}=e;return(0,s.yg)(ito,(0,p.A)({},ato,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}lto.isMDXComponent=!0;const uto={toc:[]},mto="wrapper";function yto(e){let{components:n,...t}=e;return(0,s.yg)(mto,(0,p.A)({},uto,t,{components:n,mdxType:"MDXLayout"}))}yto.isMDXComponent=!0;const dto={toc:[]},hto="wrapper";function gto(e){let{components:n,...t}=e;return(0,s.yg)(hto,(0,p.A)({},dto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gto.isMDXComponent=!0;const fto={toc:[]},Dto="wrapper";function Mto(e){let{components:n,...t}=e;return(0,s.yg)(Dto,(0,p.A)({},fto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Mto.isMDXComponent=!0;const Xto={toc:[]},_to="wrapper";function wto(e){let{components:n,...t}=e;return(0,s.yg)(_to,(0,p.A)({},Xto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}wto.isMDXComponent=!0;const Tto={toc:[]},Cto="wrapper";function xto(e){let{components:n,...t}=e;return(0,s.yg)(Cto,(0,p.A)({},Tto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}xto.isMDXComponent=!0;const Ato={toc:[]},vto="wrapper";function Lto(e){let{components:n,...t}=e;return(0,s.yg)(vto,(0,p.A)({},Ato,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Lto.isMDXComponent=!0;const bto={toc:[]},Nto="wrapper";function kto(e){let{components:n,...t}=e;return(0,s.yg)(Nto,(0,p.A)({},bto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}kto.isMDXComponent=!0;const zto={toc:[]},Pto="wrapper";function Ito(e){let{components:n,...t}=e;return(0,s.yg)(Pto,(0,p.A)({},zto,t,{components:n,mdxType:"MDXLayout"}))}Ito.isMDXComponent=!0;const Rto={toc:[]},Wto="wrapper";function Sto(e){let{components:n,...t}=e;return(0,s.yg)(Wto,(0,p.A)({},Rto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Sto.isMDXComponent=!0;const Bto={toc:[]},Gto="wrapper";function Eto(e){let{components:n,...t}=e;return(0,s.yg)(Gto,(0,p.A)({},Bto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Eto.isMDXComponent=!0;const Oto={toc:[]},Uto="wrapper";function Fto(e){let{components:n,...t}=e;return(0,s.yg)(Uto,(0,p.A)({},Oto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Fto.isMDXComponent=!0;const Vto={toc:[]},qto="wrapper";function jto(e){let{components:n,...t}=e;return(0,s.yg)(qto,(0,p.A)({},Vto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}jto.isMDXComponent=!0;const Hto={toc:[]},Yto="wrapper";function Qto(e){let{components:n,...t}=e;return(0,s.yg)(Yto,(0,p.A)({},Hto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Qto.isMDXComponent=!0;const $to={toc:[]},Kto="wrapper";function Jto(e){let{components:n,...t}=e;return(0,s.yg)(Kto,(0,p.A)({},$to,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Jto.isMDXComponent=!0;const Zto={toc:[]},eoo="wrapper";function noo(e){let{components:n,...t}=e;return(0,s.yg)(eoo,(0,p.A)({},Zto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending point of the ray."))}noo.isMDXComponent=!0;const too={toc:[]},ooo="wrapper";function poo(e){let{components:n,...t}=e;return(0,s.yg)(ooo,(0,p.A)({},too,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}poo.isMDXComponent=!0;const roo={toc:[]},soo="wrapper";function coo(e){let{components:n,...t}=e;return(0,s.yg)(soo,(0,p.A)({},roo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}coo.isMDXComponent=!0;const aoo={toc:[]},ioo="wrapper";function loo(e){let{components:n,...t}=e;return(0,s.yg)(ioo,(0,p.A)({},aoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}loo.isMDXComponent=!0;const uoo={toc:[]},moo="wrapper";function yoo(e){let{components:n,...t}=e;return(0,s.yg)(moo,(0,p.A)({},uoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}yoo.isMDXComponent=!0;const doo={toc:[]},hoo="wrapper";function goo(e){let{components:n,...t}=e;return(0,s.yg)(hoo,(0,p.A)({},doo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}goo.isMDXComponent=!0;const foo={toc:[]},Doo="wrapper";function Moo(e){let{components:n,...t}=e;return(0,s.yg)(Doo,(0,p.A)({},foo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Moo.isMDXComponent=!0;const Xoo={toc:[]},_oo="wrapper";function woo(e){let{components:n,...t}=e;return(0,s.yg)(_oo,(0,p.A)({},Xoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}woo.isMDXComponent=!0;const Too={toc:[]},Coo="wrapper";function xoo(e){let{components:n,...t}=e;return(0,s.yg)(Coo,(0,p.A)({},Too,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}xoo.isMDXComponent=!0;const Aoo={toc:[]},voo="wrapper";function Loo(e){let{components:n,...t}=e;return(0,s.yg)(voo,(0,p.A)({},Aoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Loo.isMDXComponent=!0;const boo={toc:[]},Noo="wrapper";function koo(e){let{components:n,...t}=e;return(0,s.yg)(Noo,(0,p.A)({},boo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}koo.isMDXComponent=!0;const zoo={toc:[]},Poo="wrapper";function Ioo(e){let{components:n,...t}=e;return(0,s.yg)(Poo,(0,p.A)({},zoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ioo.isMDXComponent=!0;const Roo={toc:[]},Woo="wrapper";function Soo(e){let{components:n,...t}=e;return(0,s.yg)(Woo,(0,p.A)({},Roo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Soo.isMDXComponent=!0;const Boo={toc:[]},Goo="wrapper";function Eoo(e){let{components:n,...t}=e;return(0,s.yg)(Goo,(0,p.A)({},Boo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Eoo.isMDXComponent=!0;const Ooo={toc:[]},Uoo="wrapper";function Foo(e){let{components:n,...t}=e;return(0,s.yg)(Uoo,(0,p.A)({},Ooo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Foo.isMDXComponent=!0;const Voo={toc:[]},qoo="wrapper";function joo(e){let{components:n,...t}=e;return(0,s.yg)(qoo,(0,p.A)({},Voo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}joo.isMDXComponent=!0;const Hoo={toc:[]},Yoo="wrapper";function Qoo(e){let{components:n,...t}=e;return(0,s.yg)(Yoo,(0,p.A)({},Hoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Qoo.isMDXComponent=!0;const $oo={toc:[]},Koo="wrapper";function Joo(e){let{components:n,...t}=e;return(0,s.yg)(Koo,(0,p.A)({},$oo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Joo.isMDXComponent=!0;const Zoo={toc:[]},epo="wrapper";function npo(e){let{components:n,...t}=e;return(0,s.yg)(epo,(0,p.A)({},Zoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}npo.isMDXComponent=!0;const tpo={toc:[]},opo="wrapper";function ppo(e){let{components:n,...t}=e;return(0,s.yg)(opo,(0,p.A)({},tpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}ppo.isMDXComponent=!0;const rpo={toc:[]},spo="wrapper";function cpo(e){let{components:n,...t}=e;return(0,s.yg)(spo,(0,p.A)({},rpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}cpo.isMDXComponent=!0;const apo={toc:[]},ipo="wrapper";function lpo(e){let{components:n,...t}=e;return(0,s.yg)(ipo,(0,p.A)({},apo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lpo.isMDXComponent=!0;const upo={toc:[]},mpo="wrapper";function ypo(e){let{components:n,...t}=e;return(0,s.yg)(mpo,(0,p.A)({},upo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ypo.isMDXComponent=!0;const dpo={toc:[]},hpo="wrapper";function gpo(e){let{components:n,...t}=e;return(0,s.yg)(hpo,(0,p.A)({},dpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}gpo.isMDXComponent=!0;const fpo={toc:[]},Dpo="wrapper";function Mpo(e){let{components:n,...t}=e;return(0,s.yg)(Dpo,(0,p.A)({},fpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Mpo.isMDXComponent=!0;const Xpo={toc:[]},_po="wrapper";function wpo(e){let{components:n,...t}=e;return(0,s.yg)(_po,(0,p.A)({},Xpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}wpo.isMDXComponent=!0;const Tpo={toc:[]},Cpo="wrapper";function xpo(e){let{components:n,...t}=e;return(0,s.yg)(Cpo,(0,p.A)({},Tpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}xpo.isMDXComponent=!0;const Apo={toc:[]},vpo="wrapper";function Lpo(e){let{components:n,...t}=e;return(0,s.yg)(vpo,(0,p.A)({},Apo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Lpo.isMDXComponent=!0;const bpo={toc:[]},Npo="wrapper";function kpo(e){let{components:n,...t}=e;return(0,s.yg)(Npo,(0,p.A)({},bpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}kpo.isMDXComponent=!0;const zpo={toc:[]},Ppo="wrapper";function Ipo(e){let{components:n,...t}=e;return(0,s.yg)(Ppo,(0,p.A)({},zpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Ipo.isMDXComponent=!0;const Rpo={toc:[]},Wpo="wrapper";function Spo(e){let{components:n,...t}=e;return(0,s.yg)(Wpo,(0,p.A)({},Rpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Spo.isMDXComponent=!0;const Bpo={toc:[]},Gpo="wrapper";function Epo(e){let{components:n,...t}=e;return(0,s.yg)(Gpo,(0,p.A)({},Bpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Epo.isMDXComponent=!0;const Opo={toc:[]},Upo="wrapper";function Fpo(e){let{components:n,...t}=e;return(0,s.yg)(Upo,(0,p.A)({},Opo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Fpo.isMDXComponent=!0;const Vpo={toc:[]},qpo="wrapper";function jpo(e){let{components:n,...t}=e;return(0,s.yg)(qpo,(0,p.A)({},Vpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}jpo.isMDXComponent=!0;const Hpo={toc:[]},Ypo="wrapper";function Qpo(e){let{components:n,...t}=e;return(0,s.yg)(Ypo,(0,p.A)({},Hpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Qpo.isMDXComponent=!0;const $po={toc:[]},Kpo="wrapper";function Jpo(e){let{components:n,...t}=e;return(0,s.yg)(Kpo,(0,p.A)({},$po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Jpo.isMDXComponent=!0;const Zpo={toc:[]},ero="wrapper";function nro(e){let{components:n,...t}=e;return(0,s.yg)(ero,(0,p.A)({},Zpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}nro.isMDXComponent=!0;const tro={toc:[]},oro="wrapper";function pro(e){let{components:n,...t}=e;return(0,s.yg)(oro,(0,p.A)({},tro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}pro.isMDXComponent=!0;const rro={toc:[]},sro="wrapper";function cro(e){let{components:n,...t}=e;return(0,s.yg)(sro,(0,p.A)({},rro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}cro.isMDXComponent=!0;const aro={toc:[]},iro="wrapper";function lro(e){let{components:n,...t}=e;return(0,s.yg)(iro,(0,p.A)({},aro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}lro.isMDXComponent=!0;const uro={toc:[]},mro="wrapper";function yro(e){let{components:n,...t}=e;return(0,s.yg)(mro,(0,p.A)({},uro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yro.isMDXComponent=!0;const dro={toc:[]},hro="wrapper";function gro(e){let{components:n,...t}=e;return(0,s.yg)(hro,(0,p.A)({},dro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}gro.isMDXComponent=!0;const fro={toc:[]},Dro="wrapper";function Mro(e){let{components:n,...t}=e;return(0,s.yg)(Dro,(0,p.A)({},fro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Mro.isMDXComponent=!0;const Xro={toc:[]},_ro="wrapper";function wro(e){let{components:n,...t}=e;return(0,s.yg)(_ro,(0,p.A)({},Xro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wro.isMDXComponent=!0;const Tro={toc:[]},Cro="wrapper";function xro(e){let{components:n,...t}=e;return(0,s.yg)(Cro,(0,p.A)({},Tro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}xro.isMDXComponent=!0;const Aro={toc:[]},vro="wrapper";function Lro(e){let{components:n,...t}=e;return(0,s.yg)(vro,(0,p.A)({},Aro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Lro.isMDXComponent=!0;const bro={toc:[]},Nro="wrapper";function kro(e){let{components:n,...t}=e;return(0,s.yg)(Nro,(0,p.A)({},bro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}kro.isMDXComponent=!0;const zro={toc:[]},Pro="wrapper";function Iro(e){let{components:n,...t}=e;return(0,s.yg)(Pro,(0,p.A)({},zro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Iro.isMDXComponent=!0;const Rro={toc:[]},Wro="wrapper";function Sro(e){let{components:n,...t}=e;return(0,s.yg)(Wro,(0,p.A)({},Rro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Sro.isMDXComponent=!0;const Bro={toc:[]},Gro="wrapper";function Ero(e){let{components:n,...t}=e;return(0,s.yg)(Gro,(0,p.A)({},Bro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Ero.isMDXComponent=!0;const Oro={toc:[]},Uro="wrapper";function Fro(e){let{components:n,...t}=e;return(0,s.yg)(Uro,(0,p.A)({},Oro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fro.isMDXComponent=!0;const Vro={toc:[]},qro="wrapper";function jro(e){let{components:n,...t}=e;return(0,s.yg)(qro,(0,p.A)({},Vro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}jro.isMDXComponent=!0;const Hro={toc:[]},Yro="wrapper";function Qro(e){let{components:n,...t}=e;return(0,s.yg)(Yro,(0,p.A)({},Hro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qro.isMDXComponent=!0;const $ro={toc:[]},Kro="wrapper";function Jro(e){let{components:n,...t}=e;return(0,s.yg)(Kro,(0,p.A)({},$ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Jro.isMDXComponent=!0;const Zro={toc:[]},eso="wrapper";function nso(e){let{components:n,...t}=e;return(0,s.yg)(eso,(0,p.A)({},Zro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nso.isMDXComponent=!0;const tso={toc:[]},oso="wrapper";function pso(e){let{components:n,...t}=e;return(0,s.yg)(oso,(0,p.A)({},tso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}pso.isMDXComponent=!0;const rso={toc:[]},sso="wrapper";function cso(e){let{components:n,...t}=e;return(0,s.yg)(sso,(0,p.A)({},rso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cso.isMDXComponent=!0;const aso={toc:[]},iso="wrapper";function lso(e){let{components:n,...t}=e;return(0,s.yg)(iso,(0,p.A)({},aso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}lso.isMDXComponent=!0;const uso={toc:[]},mso="wrapper";function yso(e){let{components:n,...t}=e;return(0,s.yg)(mso,(0,p.A)({},uso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yso.isMDXComponent=!0;const dso={toc:[]},hso="wrapper";function gso(e){let{components:n,...t}=e;return(0,s.yg)(hso,(0,p.A)({},dso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}gso.isMDXComponent=!0;const fso={toc:[]},Dso="wrapper";function Mso(e){let{components:n,...t}=e;return(0,s.yg)(Dso,(0,p.A)({},fso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mso.isMDXComponent=!0;const Xso={toc:[]},_so="wrapper";function wso(e){let{components:n,...t}=e;return(0,s.yg)(_so,(0,p.A)({},Xso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}wso.isMDXComponent=!0;const Tso={toc:[]},Cso="wrapper";function xso(e){let{components:n,...t}=e;return(0,s.yg)(Cso,(0,p.A)({},Tso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xso.isMDXComponent=!0;const Aso={toc:[]},vso="wrapper";function Lso(e){let{components:n,...t}=e;return(0,s.yg)(vso,(0,p.A)({},Aso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Lso.isMDXComponent=!0;const bso={toc:[]},Nso="wrapper";function kso(e){let{components:n,...t}=e;return(0,s.yg)(Nso,(0,p.A)({},bso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kso.isMDXComponent=!0;const zso={toc:[]},Pso="wrapper";function Iso(e){let{components:n,...t}=e;return(0,s.yg)(Pso,(0,p.A)({},zso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Iso.isMDXComponent=!0;const Rso={toc:[]},Wso="wrapper";function Sso(e){let{components:n,...t}=e;return(0,s.yg)(Wso,(0,p.A)({},Rso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Sso.isMDXComponent=!0;const Bso={toc:[]},Gso="wrapper";function Eso(e){let{components:n,...t}=e;return(0,s.yg)(Gso,(0,p.A)({},Bso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Eso.isMDXComponent=!0;const Oso={toc:[]},Uso="wrapper";function Fso(e){let{components:n,...t}=e;return(0,s.yg)(Uso,(0,p.A)({},Oso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Fso.isMDXComponent=!0;const Vso={toc:[]},qso="wrapper";function jso(e){let{components:n,...t}=e;return(0,s.yg)(qso,(0,p.A)({},Vso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}jso.isMDXComponent=!0;const Hso={toc:[]},Yso="wrapper";function Qso(e){let{components:n,...t}=e;return(0,s.yg)(Yso,(0,p.A)({},Hso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Qso.isMDXComponent=!0;const $so={toc:[]},Kso="wrapper";function Jso(e){let{components:n,...t}=e;return(0,s.yg)(Kso,(0,p.A)({},$so,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Jso.isMDXComponent=!0;const Zso={toc:[]},eco="wrapper";function nco(e){let{components:n,...t}=e;return(0,s.yg)(eco,(0,p.A)({},Zso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}nco.isMDXComponent=!0;const tco={toc:[]},oco="wrapper";function pco(e){let{components:n,...t}=e;return(0,s.yg)(oco,(0,p.A)({},tco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}pco.isMDXComponent=!0;const rco={toc:[]},sco="wrapper";function cco(e){let{components:n,...t}=e;return(0,s.yg)(sco,(0,p.A)({},rco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}cco.isMDXComponent=!0;const aco={toc:[]},ico="wrapper";function lco(e){let{components:n,...t}=e;return(0,s.yg)(ico,(0,p.A)({},aco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}lco.isMDXComponent=!0;const uco={toc:[]},mco="wrapper";function yco(e){let{components:n,...t}=e;return(0,s.yg)(mco,(0,p.A)({},uco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}yco.isMDXComponent=!0;const dco={toc:[]},hco="wrapper";function gco(e){let{components:n,...t}=e;return(0,s.yg)(hco,(0,p.A)({},dco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gco.isMDXComponent=!0;const fco={toc:[]},Dco="wrapper";function Mco(e){let{components:n,...t}=e;return(0,s.yg)(Dco,(0,p.A)({},fco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Mco.isMDXComponent=!0;const Xco={toc:[]},_co="wrapper";function wco(e){let{components:n,...t}=e;return(0,s.yg)(_co,(0,p.A)({},Xco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wco.isMDXComponent=!0;const Tco={toc:[]},Cco="wrapper";function xco(e){let{components:n,...t}=e;return(0,s.yg)(Cco,(0,p.A)({},Tco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}xco.isMDXComponent=!0;const Aco={toc:[]},vco="wrapper";function Lco(e){let{components:n,...t}=e;return(0,s.yg)(vco,(0,p.A)({},Aco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Lco.isMDXComponent=!0;const bco={toc:[]},Nco="wrapper";function kco(e){let{components:n,...t}=e;return(0,s.yg)(Nco,(0,p.A)({},bco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kco.isMDXComponent=!0;const zco={toc:[]},Pco="wrapper";function Ico(e){let{components:n,...t}=e;return(0,s.yg)(Pco,(0,p.A)({},zco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Ico.isMDXComponent=!0;const Rco={toc:[]},Wco="wrapper";function Sco(e){let{components:n,...t}=e;return(0,s.yg)(Wco,(0,p.A)({},Rco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Sco.isMDXComponent=!0;const Bco={toc:[]},Gco="wrapper";function Eco(e){let{components:n,...t}=e;return(0,s.yg)(Gco,(0,p.A)({},Bco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Eco.isMDXComponent=!0;const Oco={toc:[]},Uco="wrapper";function Fco(e){let{components:n,...t}=e;return(0,s.yg)(Uco,(0,p.A)({},Oco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Fco.isMDXComponent=!0;const Vco={toc:[]},qco="wrapper";function jco(e){let{components:n,...t}=e;return(0,s.yg)(qco,(0,p.A)({},Vco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}jco.isMDXComponent=!0;const Hco={toc:[]},Yco="wrapper";function Qco(e){let{components:n,...t}=e;return(0,s.yg)(Yco,(0,p.A)({},Hco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Qco.isMDXComponent=!0;const $co={toc:[]},Kco="wrapper";function Jco(e){let{components:n,...t}=e;return(0,s.yg)(Kco,(0,p.A)({},$co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Jco.isMDXComponent=!0;const Zco={toc:[]},eao="wrapper";function nao(e){let{components:n,...t}=e;return(0,s.yg)(eao,(0,p.A)({},Zco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nao.isMDXComponent=!0;const tao={toc:[]},oao="wrapper";function pao(e){let{components:n,...t}=e;return(0,s.yg)(oao,(0,p.A)({},tao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pao.isMDXComponent=!0;const rao={toc:[]},sao="wrapper";function cao(e){let{components:n,...t}=e;return(0,s.yg)(sao,(0,p.A)({},rao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}cao.isMDXComponent=!0;const aao={toc:[]},iao="wrapper";function lao(e){let{components:n,...t}=e;return(0,s.yg)(iao,(0,p.A)({},aao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}lao.isMDXComponent=!0;const uao={toc:[]},mao="wrapper";function yao(e){let{components:n,...t}=e;return(0,s.yg)(mao,(0,p.A)({},uao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}yao.isMDXComponent=!0;const dao={toc:[]},hao="wrapper";function gao(e){let{components:n,...t}=e;return(0,s.yg)(hao,(0,p.A)({},dao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gao.isMDXComponent=!0;const fao={toc:[]},Dao="wrapper";function Mao(e){let{components:n,...t}=e;return(0,s.yg)(Dao,(0,p.A)({},fao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Mao.isMDXComponent=!0;const Xao={toc:[]},_ao="wrapper";function wao(e){let{components:n,...t}=e;return(0,s.yg)(_ao,(0,p.A)({},Xao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wao.isMDXComponent=!0;const Tao={toc:[]},Cao="wrapper";function xao(e){let{components:n,...t}=e;return(0,s.yg)(Cao,(0,p.A)({},Tao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}xao.isMDXComponent=!0;const Aao={toc:[]},vao="wrapper";function Lao(e){let{components:n,...t}=e;return(0,s.yg)(vao,(0,p.A)({},Aao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Lao.isMDXComponent=!0;const bao={toc:[]},Nao="wrapper";function kao(e){let{components:n,...t}=e;return(0,s.yg)(Nao,(0,p.A)({},bao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}kao.isMDXComponent=!0;const zao={toc:[]},Pao="wrapper";function Iao(e){let{components:n,...t}=e;return(0,s.yg)(Pao,(0,p.A)({},zao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Iao.isMDXComponent=!0;const Rao={toc:[]},Wao="wrapper";function Sao(e){let{components:n,...t}=e;return(0,s.yg)(Wao,(0,p.A)({},Rao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Sao.isMDXComponent=!0;const Bao={toc:[]},Gao="wrapper";function Eao(e){let{components:n,...t}=e;return(0,s.yg)(Gao,(0,p.A)({},Bao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Eao.isMDXComponent=!0;const Oao={toc:[]},Uao="wrapper";function Fao(e){let{components:n,...t}=e;return(0,s.yg)(Uao,(0,p.A)({},Oao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fao.isMDXComponent=!0;const Vao={toc:[]},qao="wrapper";function jao(e){let{components:n,...t}=e;return(0,s.yg)(qao,(0,p.A)({},Vao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}jao.isMDXComponent=!0;const Hao={toc:[]},Yao="wrapper";function Qao(e){let{components:n,...t}=e;return(0,s.yg)(Yao,(0,p.A)({},Hao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Qao.isMDXComponent=!0;const $ao={toc:[]},Kao="wrapper";function Jao(e){let{components:n,...t}=e;return(0,s.yg)(Kao,(0,p.A)({},$ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Jao.isMDXComponent=!0;const Zao={toc:[]},eio="wrapper";function nio(e){let{components:n,...t}=e;return(0,s.yg)(eio,(0,p.A)({},Zao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}nio.isMDXComponent=!0;const tio={toc:[]},oio="wrapper";function pio(e){let{components:n,...t}=e;return(0,s.yg)(oio,(0,p.A)({},tio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}pio.isMDXComponent=!0;const rio={toc:[]},sio="wrapper";function cio(e){let{components:n,...t}=e;return(0,s.yg)(sio,(0,p.A)({},rio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}cio.isMDXComponent=!0;const aio={toc:[]},iio="wrapper";function lio(e){let{components:n,...t}=e;return(0,s.yg)(iio,(0,p.A)({},aio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}lio.isMDXComponent=!0;const uio={toc:[]},mio="wrapper";function yio(e){let{components:n,...t}=e;return(0,s.yg)(mio,(0,p.A)({},uio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}yio.isMDXComponent=!0;const dio={toc:[]},hio="wrapper";function gio(e){let{components:n,...t}=e;return(0,s.yg)(hio,(0,p.A)({},dio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}gio.isMDXComponent=!0;const fio={toc:[]},Dio="wrapper";function Mio(e){let{components:n,...t}=e;return(0,s.yg)(Dio,(0,p.A)({},fio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Mio.isMDXComponent=!0;const Xio={toc:[]},_io="wrapper";function wio(e){let{components:n,...t}=e;return(0,s.yg)(_io,(0,p.A)({},Xio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}wio.isMDXComponent=!0;const Tio={toc:[]},Cio="wrapper";function xio(e){let{components:n,...t}=e;return(0,s.yg)(Cio,(0,p.A)({},Tio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}xio.isMDXComponent=!0;const Aio={toc:[]},vio="wrapper";function Lio(e){let{components:n,...t}=e;return(0,s.yg)(vio,(0,p.A)({},Aio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Lio.isMDXComponent=!0;const bio={toc:[]},Nio="wrapper";function kio(e){let{components:n,...t}=e;return(0,s.yg)(Nio,(0,p.A)({},bio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kio.isMDXComponent=!0;const zio={toc:[]},Pio="wrapper";function Iio(e){let{components:n,...t}=e;return(0,s.yg)(Pio,(0,p.A)({},zio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Iio.isMDXComponent=!0;const Rio={toc:[]},Wio="wrapper";function Sio(e){let{components:n,...t}=e;return(0,s.yg)(Wio,(0,p.A)({},Rio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Sio.isMDXComponent=!0;const Bio={toc:[]},Gio="wrapper";function Eio(e){let{components:n,...t}=e;return(0,s.yg)(Gio,(0,p.A)({},Bio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Eio.isMDXComponent=!0;const Oio={toc:[]},Uio="wrapper";function Fio(e){let{components:n,...t}=e;return(0,s.yg)(Uio,(0,p.A)({},Oio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Fio.isMDXComponent=!0;const Vio={toc:[]},qio="wrapper";function jio(e){let{components:n,...t}=e;return(0,s.yg)(qio,(0,p.A)({},Vio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}jio.isMDXComponent=!0;const Hio={toc:[]},Yio="wrapper";function Qio(e){let{components:n,...t}=e;return(0,s.yg)(Yio,(0,p.A)({},Hio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Qio.isMDXComponent=!0;const $io={toc:[]},Kio="wrapper";function Jio(e){let{components:n,...t}=e;return(0,s.yg)(Kio,(0,p.A)({},$io,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Jio.isMDXComponent=!0;const Zio={toc:[]},elo="wrapper";function nlo(e){let{components:n,...t}=e;return(0,s.yg)(elo,(0,p.A)({},Zio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}nlo.isMDXComponent=!0;const tlo={toc:[]},olo="wrapper";function plo(e){let{components:n,...t}=e;return(0,s.yg)(olo,(0,p.A)({},tlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}plo.isMDXComponent=!0;const rlo={toc:[]},slo="wrapper";function clo(e){let{components:n,...t}=e;return(0,s.yg)(slo,(0,p.A)({},rlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}clo.isMDXComponent=!0;const alo={toc:[]},ilo="wrapper";function llo(e){let{components:n,...t}=e;return(0,s.yg)(ilo,(0,p.A)({},alo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}llo.isMDXComponent=!0;const ulo={toc:[]},mlo="wrapper";function ylo(e){let{components:n,...t}=e;return(0,s.yg)(mlo,(0,p.A)({},ulo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}ylo.isMDXComponent=!0;const dlo={toc:[]},hlo="wrapper";function glo(e){let{components:n,...t}=e;return(0,s.yg)(hlo,(0,p.A)({},dlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}glo.isMDXComponent=!0;const flo={toc:[]},Dlo="wrapper";function Mlo(e){let{components:n,...t}=e;return(0,s.yg)(Dlo,(0,p.A)({},flo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Mlo.isMDXComponent=!0;const Xlo={toc:[]},_lo="wrapper";function wlo(e){let{components:n,...t}=e;return(0,s.yg)(_lo,(0,p.A)({},Xlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}wlo.isMDXComponent=!0;const Tlo={toc:[]},Clo="wrapper";function xlo(e){let{components:n,...t}=e;return(0,s.yg)(Clo,(0,p.A)({},Tlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}xlo.isMDXComponent=!0;const Alo={toc:[]},vlo="wrapper";function Llo(e){let{components:n,...t}=e;return(0,s.yg)(vlo,(0,p.A)({},Alo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Llo.isMDXComponent=!0;const blo={toc:[]},Nlo="wrapper";function klo(e){let{components:n,...t}=e;return(0,s.yg)(Nlo,(0,p.A)({},blo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}klo.isMDXComponent=!0;const zlo={toc:[]},Plo="wrapper";function Ilo(e){let{components:n,...t}=e;return(0,s.yg)(Plo,(0,p.A)({},zlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Ilo.isMDXComponent=!0;const Rlo={toc:[]},Wlo="wrapper";function Slo(e){let{components:n,...t}=e;return(0,s.yg)(Wlo,(0,p.A)({},Rlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Slo.isMDXComponent=!0;const Blo={toc:[]},Glo="wrapper";function Elo(e){let{components:n,...t}=e;return(0,s.yg)(Glo,(0,p.A)({},Blo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Elo.isMDXComponent=!0;const Olo={toc:[]},Ulo="wrapper";function Flo(e){let{components:n,...t}=e;return(0,s.yg)(Ulo,(0,p.A)({},Olo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Flo.isMDXComponent=!0;const Vlo={toc:[]},qlo="wrapper";function jlo(e){let{components:n,...t}=e;return(0,s.yg)(qlo,(0,p.A)({},Vlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}jlo.isMDXComponent=!0;const Hlo={toc:[]},Ylo="wrapper";function Qlo(e){let{components:n,...t}=e;return(0,s.yg)(Ylo,(0,p.A)({},Hlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Qlo.isMDXComponent=!0;const $lo={toc:[]},Klo="wrapper";function Jlo(e){let{components:n,...t}=e;return(0,s.yg)(Klo,(0,p.A)({},$lo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Jlo.isMDXComponent=!0;const Zlo={toc:[]},euo="wrapper";function nuo(e){let{components:n,...t}=e;return(0,s.yg)(euo,(0,p.A)({},Zlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}nuo.isMDXComponent=!0;const tuo={toc:[]},ouo="wrapper";function puo(e){let{components:n,...t}=e;return(0,s.yg)(ouo,(0,p.A)({},tuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}puo.isMDXComponent=!0;const ruo={toc:[]},suo="wrapper";function cuo(e){let{components:n,...t}=e;return(0,s.yg)(suo,(0,p.A)({},ruo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}cuo.isMDXComponent=!0;const auo={toc:[]},iuo="wrapper";function luo(e){let{components:n,...t}=e;return(0,s.yg)(iuo,(0,p.A)({},auo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}luo.isMDXComponent=!0;const uuo={toc:[]},muo="wrapper";function yuo(e){let{components:n,...t}=e;return(0,s.yg)(muo,(0,p.A)({},uuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}yuo.isMDXComponent=!0;const duo={toc:[]},huo="wrapper";function guo(e){let{components:n,...t}=e;return(0,s.yg)(huo,(0,p.A)({},duo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}guo.isMDXComponent=!0;const fuo={toc:[]},Duo="wrapper";function Muo(e){let{components:n,...t}=e;return(0,s.yg)(Duo,(0,p.A)({},fuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Muo.isMDXComponent=!0;const Xuo={toc:[]},_uo="wrapper";function wuo(e){let{components:n,...t}=e;return(0,s.yg)(_uo,(0,p.A)({},Xuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}wuo.isMDXComponent=!0;const Tuo={toc:[]},Cuo="wrapper";function xuo(e){let{components:n,...t}=e;return(0,s.yg)(Cuo,(0,p.A)({},Tuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}xuo.isMDXComponent=!0;const Auo={toc:[]},vuo="wrapper";function Luo(e){let{components:n,...t}=e;return(0,s.yg)(vuo,(0,p.A)({},Auo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Luo.isMDXComponent=!0;const buo={toc:[]},Nuo="wrapper";function kuo(e){let{components:n,...t}=e;return(0,s.yg)(Nuo,(0,p.A)({},buo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kuo.isMDXComponent=!0;const zuo={toc:[]},Puo="wrapper";function Iuo(e){let{components:n,...t}=e;return(0,s.yg)(Puo,(0,p.A)({},zuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Iuo.isMDXComponent=!0;const Ruo={toc:[]},Wuo="wrapper";function Suo(e){let{components:n,...t}=e;return(0,s.yg)(Wuo,(0,p.A)({},Ruo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Suo.isMDXComponent=!0;const Buo={toc:[]},Guo="wrapper";function Euo(e){let{components:n,...t}=e;return(0,s.yg)(Guo,(0,p.A)({},Buo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Euo.isMDXComponent=!0;const Ouo={toc:[]},Uuo="wrapper";function Fuo(e){let{components:n,...t}=e;return(0,s.yg)(Uuo,(0,p.A)({},Ouo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Fuo.isMDXComponent=!0;const Vuo={toc:[]},quo="wrapper";function juo(e){let{components:n,...t}=e;return(0,s.yg)(quo,(0,p.A)({},Vuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}juo.isMDXComponent=!0;const Huo={toc:[]},Yuo="wrapper";function Quo(e){let{components:n,...t}=e;return(0,s.yg)(Yuo,(0,p.A)({},Huo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Quo.isMDXComponent=!0;const $uo={toc:[]},Kuo="wrapper";function Juo(e){let{components:n,...t}=e;return(0,s.yg)(Kuo,(0,p.A)({},$uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Juo.isMDXComponent=!0;const Zuo={toc:[]},emo="wrapper";function nmo(e){let{components:n,...t}=e;return(0,s.yg)(emo,(0,p.A)({},Zuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}nmo.isMDXComponent=!0;const tmo={toc:[]},omo="wrapper";function pmo(e){let{components:n,...t}=e;return(0,s.yg)(omo,(0,p.A)({},tmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}pmo.isMDXComponent=!0;const rmo={toc:[]},smo="wrapper";function cmo(e){let{components:n,...t}=e;return(0,s.yg)(smo,(0,p.A)({},rmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}cmo.isMDXComponent=!0;const amo={toc:[]},imo="wrapper";function lmo(e){let{components:n,...t}=e;return(0,s.yg)(imo,(0,p.A)({},amo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lmo.isMDXComponent=!0;const umo={toc:[]},mmo="wrapper";function ymo(e){let{components:n,...t}=e;return(0,s.yg)(mmo,(0,p.A)({},umo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}ymo.isMDXComponent=!0;const dmo={toc:[]},hmo="wrapper";function gmo(e){let{components:n,...t}=e;return(0,s.yg)(hmo,(0,p.A)({},dmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}gmo.isMDXComponent=!0;const fmo={toc:[]},Dmo="wrapper";function Mmo(e){let{components:n,...t}=e;return(0,s.yg)(Dmo,(0,p.A)({},fmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Mmo.isMDXComponent=!0;const Xmo={toc:[]},_mo="wrapper";function wmo(e){let{components:n,...t}=e;return(0,s.yg)(_mo,(0,p.A)({},Xmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}wmo.isMDXComponent=!0;const Tmo={toc:[]},Cmo="wrapper";function xmo(e){let{components:n,...t}=e;return(0,s.yg)(Cmo,(0,p.A)({},Tmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}xmo.isMDXComponent=!0;const Amo={toc:[]},vmo="wrapper";function Lmo(e){let{components:n,...t}=e;return(0,s.yg)(vmo,(0,p.A)({},Amo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Lmo.isMDXComponent=!0;const bmo={toc:[]},Nmo="wrapper";function kmo(e){let{components:n,...t}=e;return(0,s.yg)(Nmo,(0,p.A)({},bmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}kmo.isMDXComponent=!0;const zmo={toc:[]},Pmo="wrapper";function Imo(e){let{components:n,...t}=e;return(0,s.yg)(Pmo,(0,p.A)({},zmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Imo.isMDXComponent=!0;const Rmo={toc:[]},Wmo="wrapper";function Smo(e){let{components:n,...t}=e;return(0,s.yg)(Wmo,(0,p.A)({},Rmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Smo.isMDXComponent=!0;const Bmo={toc:[]},Gmo="wrapper";function Emo(e){let{components:n,...t}=e;return(0,s.yg)(Gmo,(0,p.A)({},Bmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Emo.isMDXComponent=!0;const Omo={toc:[]},Umo="wrapper";function Fmo(e){let{components:n,...t}=e;return(0,s.yg)(Umo,(0,p.A)({},Omo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Fmo.isMDXComponent=!0;const Vmo={toc:[]},qmo="wrapper";function jmo(e){let{components:n,...t}=e;return(0,s.yg)(qmo,(0,p.A)({},Vmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jmo.isMDXComponent=!0;const Hmo={toc:[]},Ymo="wrapper";function Qmo(e){let{components:n,...t}=e;return(0,s.yg)(Ymo,(0,p.A)({},Hmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Qmo.isMDXComponent=!0;const $mo={toc:[]},Kmo="wrapper";function Jmo(e){let{components:n,...t}=e;return(0,s.yg)(Kmo,(0,p.A)({},$mo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Jmo.isMDXComponent=!0;const Zmo={toc:[]},eyo="wrapper";function nyo(e){let{components:n,...t}=e;return(0,s.yg)(eyo,(0,p.A)({},Zmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}nyo.isMDXComponent=!0;const tyo={toc:[]},oyo="wrapper";function pyo(e){let{components:n,...t}=e;return(0,s.yg)(oyo,(0,p.A)({},tyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}pyo.isMDXComponent=!0;const ryo={toc:[]},syo="wrapper";function cyo(e){let{components:n,...t}=e;return(0,s.yg)(syo,(0,p.A)({},ryo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}cyo.isMDXComponent=!0;const ayo={toc:[]},iyo="wrapper";function lyo(e){let{components:n,...t}=e;return(0,s.yg)(iyo,(0,p.A)({},ayo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}lyo.isMDXComponent=!0;const uyo={toc:[]},myo="wrapper";function yyo(e){let{components:n,...t}=e;return(0,s.yg)(myo,(0,p.A)({},uyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}yyo.isMDXComponent=!0;const dyo={toc:[]},hyo="wrapper";function gyo(e){let{components:n,...t}=e;return(0,s.yg)(hyo,(0,p.A)({},dyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}gyo.isMDXComponent=!0;const fyo={toc:[]},Dyo="wrapper";function Myo(e){let{components:n,...t}=e;return(0,s.yg)(Dyo,(0,p.A)({},fyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Myo.isMDXComponent=!0;const Xyo={toc:[]},_yo="wrapper";function wyo(e){let{components:n,...t}=e;return(0,s.yg)(_yo,(0,p.A)({},Xyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}wyo.isMDXComponent=!0;const Tyo={toc:[]},Cyo="wrapper";function xyo(e){let{components:n,...t}=e;return(0,s.yg)(Cyo,(0,p.A)({},Tyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}xyo.isMDXComponent=!0;const Ayo={toc:[]},vyo="wrapper";function Lyo(e){let{components:n,...t}=e;return(0,s.yg)(vyo,(0,p.A)({},Ayo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Lyo.isMDXComponent=!0;const byo={toc:[]},Nyo="wrapper";function kyo(e){let{components:n,...t}=e;return(0,s.yg)(Nyo,(0,p.A)({},byo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}kyo.isMDXComponent=!0;const zyo={toc:[]},Pyo="wrapper";function Iyo(e){let{components:n,...t}=e;return(0,s.yg)(Pyo,(0,p.A)({},zyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Iyo.isMDXComponent=!0;const Ryo={toc:[]},Wyo="wrapper";function Syo(e){let{components:n,...t}=e;return(0,s.yg)(Wyo,(0,p.A)({},Ryo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Syo.isMDXComponent=!0;const Byo={toc:[]},Gyo="wrapper";function Eyo(e){let{components:n,...t}=e;return(0,s.yg)(Gyo,(0,p.A)({},Byo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Eyo.isMDXComponent=!0;const Oyo={toc:[]},Uyo="wrapper";function Fyo(e){let{components:n,...t}=e;return(0,s.yg)(Uyo,(0,p.A)({},Oyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Fyo.isMDXComponent=!0;const Vyo={toc:[]},qyo="wrapper";function jyo(e){let{components:n,...t}=e;return(0,s.yg)(qyo,(0,p.A)({},Vyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}jyo.isMDXComponent=!0;const Hyo={toc:[]},Yyo="wrapper";function Qyo(e){let{components:n,...t}=e;return(0,s.yg)(Yyo,(0,p.A)({},Hyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Qyo.isMDXComponent=!0;const $yo={toc:[]},Kyo="wrapper";function Jyo(e){let{components:n,...t}=e;return(0,s.yg)(Kyo,(0,p.A)({},$yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Jyo.isMDXComponent=!0;const Zyo={toc:[]},edo="wrapper";function ndo(e){let{components:n,...t}=e;return(0,s.yg)(edo,(0,p.A)({},Zyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ndo.isMDXComponent=!0;const tdo={toc:[]},odo="wrapper";function pdo(e){let{components:n,...t}=e;return(0,s.yg)(odo,(0,p.A)({},tdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}pdo.isMDXComponent=!0;const rdo={toc:[]},sdo="wrapper";function cdo(e){let{components:n,...t}=e;return(0,s.yg)(sdo,(0,p.A)({},rdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}cdo.isMDXComponent=!0;const ado={toc:[]},ido="wrapper";function ldo(e){let{components:n,...t}=e;return(0,s.yg)(ido,(0,p.A)({},ado,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}ldo.isMDXComponent=!0;const udo={toc:[]},mdo="wrapper";function ydo(e){let{components:n,...t}=e;return(0,s.yg)(mdo,(0,p.A)({},udo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}ydo.isMDXComponent=!0;const ddo={toc:[]},hdo="wrapper";function gdo(e){let{components:n,...t}=e;return(0,s.yg)(hdo,(0,p.A)({},ddo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}gdo.isMDXComponent=!0;const fdo={toc:[]},Ddo="wrapper";function Mdo(e){let{components:n,...t}=e;return(0,s.yg)(Ddo,(0,p.A)({},fdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Mdo.isMDXComponent=!0;const Xdo={toc:[]},_do="wrapper";function wdo(e){let{components:n,...t}=e;return(0,s.yg)(_do,(0,p.A)({},Xdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}wdo.isMDXComponent=!0;const Tdo={toc:[]},Cdo="wrapper";function xdo(e){let{components:n,...t}=e;return(0,s.yg)(Cdo,(0,p.A)({},Tdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xdo.isMDXComponent=!0;const Ado={toc:[]},vdo="wrapper";function Ldo(e){let{components:n,...t}=e;return(0,s.yg)(vdo,(0,p.A)({},Ado,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Ldo.isMDXComponent=!0;const bdo={toc:[]},Ndo="wrapper";function kdo(e){let{components:n,...t}=e;return(0,s.yg)(Ndo,(0,p.A)({},bdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}kdo.isMDXComponent=!0;const zdo={toc:[]},Pdo="wrapper";function Ido(e){let{components:n,...t}=e;return(0,s.yg)(Pdo,(0,p.A)({},zdo,t,{components:n,mdxType:"MDXLayout"}))}Ido.isMDXComponent=!0;const Rdo={toc:[]},Wdo="wrapper";function Sdo(e){let{components:n,...t}=e;return(0,s.yg)(Wdo,(0,p.A)({},Rdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Sdo.isMDXComponent=!0;const Bdo={toc:[]},Gdo="wrapper";function Edo(e){let{components:n,...t}=e;return(0,s.yg)(Gdo,(0,p.A)({},Bdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Edo.isMDXComponent=!0;const Odo={toc:[]},Udo="wrapper";function Fdo(e){let{components:n,...t}=e;return(0,s.yg)(Udo,(0,p.A)({},Odo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Fdo.isMDXComponent=!0;const Vdo={toc:[]},qdo="wrapper";function jdo(e){let{components:n,...t}=e;return(0,s.yg)(qdo,(0,p.A)({},Vdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}jdo.isMDXComponent=!0;const Hdo={toc:[]},Ydo="wrapper";function Qdo(e){let{components:n,...t}=e;return(0,s.yg)(Ydo,(0,p.A)({},Hdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Qdo.isMDXComponent=!0;const $do={toc:[]},Kdo="wrapper";function Jdo(e){let{components:n,...t}=e;return(0,s.yg)(Kdo,(0,p.A)({},$do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Jdo.isMDXComponent=!0;const Zdo={toc:[]},eho="wrapper";function nho(e){let{components:n,...t}=e;return(0,s.yg)(eho,(0,p.A)({},Zdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}nho.isMDXComponent=!0;const tho={toc:[]},oho="wrapper";function pho(e){let{components:n,...t}=e;return(0,s.yg)(oho,(0,p.A)({},tho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}pho.isMDXComponent=!0;const rho={toc:[]},sho="wrapper";function cho(e){let{components:n,...t}=e;return(0,s.yg)(sho,(0,p.A)({},rho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}cho.isMDXComponent=!0;const aho={toc:[]},iho="wrapper";function lho(e){let{components:n,...t}=e;return(0,s.yg)(iho,(0,p.A)({},aho,t,{components:n,mdxType:"MDXLayout"}))}lho.isMDXComponent=!0;const uho={toc:[]},mho="wrapper";function yho(e){let{components:n,...t}=e;return(0,s.yg)(mho,(0,p.A)({},uho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}yho.isMDXComponent=!0;const dho={toc:[]},hho="wrapper";function gho(e){let{components:n,...t}=e;return(0,s.yg)(hho,(0,p.A)({},dho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}gho.isMDXComponent=!0;const fho={toc:[]},Dho="wrapper";function Mho(e){let{components:n,...t}=e;return(0,s.yg)(Dho,(0,p.A)({},fho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mho.isMDXComponent=!0;const Xho={toc:[]},_ho="wrapper";function who(e){let{components:n,...t}=e;return(0,s.yg)(_ho,(0,p.A)({},Xho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}who.isMDXComponent=!0;const Tho={toc:[]},Cho="wrapper";function xho(e){let{components:n,...t}=e;return(0,s.yg)(Cho,(0,p.A)({},Tho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xho.isMDXComponent=!0;const Aho={toc:[]},vho="wrapper";function Lho(e){let{components:n,...t}=e;return(0,s.yg)(vho,(0,p.A)({},Aho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Lho.isMDXComponent=!0;const bho={toc:[]},Nho="wrapper";function kho(e){let{components:n,...t}=e;return(0,s.yg)(Nho,(0,p.A)({},bho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kho.isMDXComponent=!0;const zho={toc:[]},Pho="wrapper";function Iho(e){let{components:n,...t}=e;return(0,s.yg)(Pho,(0,p.A)({},zho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Iho.isMDXComponent=!0;const Rho={toc:[]},Who="wrapper";function Sho(e){let{components:n,...t}=e;return(0,s.yg)(Who,(0,p.A)({},Rho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Sho.isMDXComponent=!0;const Bho={toc:[]},Gho="wrapper";function Eho(e){let{components:n,...t}=e;return(0,s.yg)(Gho,(0,p.A)({},Bho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Eho.isMDXComponent=!0;const Oho={toc:[]},Uho="wrapper";function Fho(e){let{components:n,...t}=e;return(0,s.yg)(Uho,(0,p.A)({},Oho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Fho.isMDXComponent=!0;const Vho={toc:[]},qho="wrapper";function jho(e){let{components:n,...t}=e;return(0,s.yg)(qho,(0,p.A)({},Vho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}jho.isMDXComponent=!0;const Hho={toc:[]},Yho="wrapper";function Qho(e){let{components:n,...t}=e;return(0,s.yg)(Yho,(0,p.A)({},Hho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Qho.isMDXComponent=!0;const $ho={toc:[]},Kho="wrapper";function Jho(e){let{components:n,...t}=e;return(0,s.yg)(Kho,(0,p.A)({},$ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Jho.isMDXComponent=!0;const Zho={toc:[]},ego="wrapper";function ngo(e){let{components:n,...t}=e;return(0,s.yg)(ego,(0,p.A)({},Zho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}ngo.isMDXComponent=!0;const tgo={toc:[]},ogo="wrapper";function pgo(e){let{components:n,...t}=e;return(0,s.yg)(ogo,(0,p.A)({},tgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}pgo.isMDXComponent=!0;const rgo={toc:[]},sgo="wrapper";function cgo(e){let{components:n,...t}=e;return(0,s.yg)(sgo,(0,p.A)({},rgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cgo.isMDXComponent=!0;const ago={toc:[]},igo="wrapper";function lgo(e){let{components:n,...t}=e;return(0,s.yg)(igo,(0,p.A)({},ago,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}lgo.isMDXComponent=!0;const ugo={toc:[]},mgo="wrapper";function ygo(e){let{components:n,...t}=e;return(0,s.yg)(mgo,(0,p.A)({},ugo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}ygo.isMDXComponent=!0;const dgo={toc:[]},hgo="wrapper";function ggo(e){let{components:n,...t}=e;return(0,s.yg)(hgo,(0,p.A)({},dgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}ggo.isMDXComponent=!0;const fgo={toc:[]},Dgo="wrapper";function Mgo(e){let{components:n,...t}=e;return(0,s.yg)(Dgo,(0,p.A)({},fgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Mgo.isMDXComponent=!0;const Xgo={toc:[]},_go="wrapper";function wgo(e){let{components:n,...t}=e;return(0,s.yg)(_go,(0,p.A)({},Xgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}wgo.isMDXComponent=!0;const Tgo={toc:[]},Cgo="wrapper";function xgo(e){let{components:n,...t}=e;return(0,s.yg)(Cgo,(0,p.A)({},Tgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}xgo.isMDXComponent=!0;const Ago={toc:[]},vgo="wrapper";function Lgo(e){let{components:n,...t}=e;return(0,s.yg)(vgo,(0,p.A)({},Ago,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Lgo.isMDXComponent=!0;const bgo={toc:[]},Ngo="wrapper";function kgo(e){let{components:n,...t}=e;return(0,s.yg)(Ngo,(0,p.A)({},bgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}kgo.isMDXComponent=!0;const zgo={toc:[]},Pgo="wrapper";function Igo(e){let{components:n,...t}=e;return(0,s.yg)(Pgo,(0,p.A)({},zgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Igo.isMDXComponent=!0;const Rgo={toc:[]},Wgo="wrapper";function Sgo(e){let{components:n,...t}=e;return(0,s.yg)(Wgo,(0,p.A)({},Rgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Sgo.isMDXComponent=!0;const Bgo={toc:[]},Ggo="wrapper";function Ego(e){let{components:n,...t}=e;return(0,s.yg)(Ggo,(0,p.A)({},Bgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Ego.isMDXComponent=!0;const Ogo={toc:[]},Ugo="wrapper";function Fgo(e){let{components:n,...t}=e;return(0,s.yg)(Ugo,(0,p.A)({},Ogo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Fgo.isMDXComponent=!0;const Vgo={toc:[]},qgo="wrapper";function jgo(e){let{components:n,...t}=e;return(0,s.yg)(qgo,(0,p.A)({},Vgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}jgo.isMDXComponent=!0;const Hgo={toc:[]},Ygo="wrapper";function Qgo(e){let{components:n,...t}=e;return(0,s.yg)(Ygo,(0,p.A)({},Hgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Qgo.isMDXComponent=!0;const $go={toc:[]},Kgo="wrapper";function Jgo(e){let{components:n,...t}=e;return(0,s.yg)(Kgo,(0,p.A)({},$go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Jgo.isMDXComponent=!0;const Zgo={toc:[]},efo="wrapper";function nfo(e){let{components:n,...t}=e;return(0,s.yg)(efo,(0,p.A)({},Zgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}nfo.isMDXComponent=!0;const tfo={toc:[]},ofo="wrapper";function pfo(e){let{components:n,...t}=e;return(0,s.yg)(ofo,(0,p.A)({},tfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}pfo.isMDXComponent=!0;const rfo={toc:[]},sfo="wrapper";function cfo(e){let{components:n,...t}=e;return(0,s.yg)(sfo,(0,p.A)({},rfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}cfo.isMDXComponent=!0;const afo={toc:[]},ifo="wrapper";function lfo(e){let{components:n,...t}=e;return(0,s.yg)(ifo,(0,p.A)({},afo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}lfo.isMDXComponent=!0;const ufo={toc:[]},mfo="wrapper";function yfo(e){let{components:n,...t}=e;return(0,s.yg)(mfo,(0,p.A)({},ufo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}yfo.isMDXComponent=!0;const dfo={toc:[]},hfo="wrapper";function gfo(e){let{components:n,...t}=e;return(0,s.yg)(hfo,(0,p.A)({},dfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}gfo.isMDXComponent=!0;const ffo={toc:[]},Dfo="wrapper";function Mfo(e){let{components:n,...t}=e;return(0,s.yg)(Dfo,(0,p.A)({},ffo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Mfo.isMDXComponent=!0;const Xfo={toc:[]},_fo="wrapper";function wfo(e){let{components:n,...t}=e;return(0,s.yg)(_fo,(0,p.A)({},Xfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}wfo.isMDXComponent=!0;const Tfo={toc:[]},Cfo="wrapper";function xfo(e){let{components:n,...t}=e;return(0,s.yg)(Cfo,(0,p.A)({},Tfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xfo.isMDXComponent=!0;const Afo={toc:[]},vfo="wrapper";function Lfo(e){let{components:n,...t}=e;return(0,s.yg)(vfo,(0,p.A)({},Afo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Lfo.isMDXComponent=!0;const bfo={toc:[]},Nfo="wrapper";function kfo(e){let{components:n,...t}=e;return(0,s.yg)(Nfo,(0,p.A)({},bfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}kfo.isMDXComponent=!0;const zfo={toc:[]},Pfo="wrapper";function Ifo(e){let{components:n,...t}=e;return(0,s.yg)(Pfo,(0,p.A)({},zfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Ifo.isMDXComponent=!0;const Rfo={toc:[]},Wfo="wrapper";function Sfo(e){let{components:n,...t}=e;return(0,s.yg)(Wfo,(0,p.A)({},Rfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Sfo.isMDXComponent=!0;const Bfo={toc:[]},Gfo="wrapper";function Efo(e){let{components:n,...t}=e;return(0,s.yg)(Gfo,(0,p.A)({},Bfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Efo.isMDXComponent=!0;const Ofo={toc:[]},Ufo="wrapper";function Ffo(e){let{components:n,...t}=e;return(0,s.yg)(Ufo,(0,p.A)({},Ofo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Ffo.isMDXComponent=!0;const Vfo={toc:[]},qfo="wrapper";function jfo(e){let{components:n,...t}=e;return(0,s.yg)(qfo,(0,p.A)({},Vfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jfo.isMDXComponent=!0;const Hfo={toc:[]},Yfo="wrapper";function Qfo(e){let{components:n,...t}=e;return(0,s.yg)(Yfo,(0,p.A)({},Hfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Qfo.isMDXComponent=!0;const $fo={toc:[]},Kfo="wrapper";function Jfo(e){let{components:n,...t}=e;return(0,s.yg)(Kfo,(0,p.A)({},$fo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Jfo.isMDXComponent=!0;const Zfo={toc:[]},eDo="wrapper";function nDo(e){let{components:n,...t}=e;return(0,s.yg)(eDo,(0,p.A)({},Zfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}nDo.isMDXComponent=!0;const tDo={toc:[]},oDo="wrapper";function pDo(e){let{components:n,...t}=e;return(0,s.yg)(oDo,(0,p.A)({},tDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}pDo.isMDXComponent=!0;const rDo={toc:[]},sDo="wrapper";function cDo(e){let{components:n,...t}=e;return(0,s.yg)(sDo,(0,p.A)({},rDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}cDo.isMDXComponent=!0;const aDo={toc:[]},iDo="wrapper";function lDo(e){let{components:n,...t}=e;return(0,s.yg)(iDo,(0,p.A)({},aDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lDo.isMDXComponent=!0;const uDo={toc:[]},mDo="wrapper";function yDo(e){let{components:n,...t}=e;return(0,s.yg)(mDo,(0,p.A)({},uDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yDo.isMDXComponent=!0;const dDo={toc:[]},hDo="wrapper";function gDo(e){let{components:n,...t}=e;return(0,s.yg)(hDo,(0,p.A)({},dDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gDo.isMDXComponent=!0;const fDo={toc:[]},DDo="wrapper";function MDo(e){let{components:n,...t}=e;return(0,s.yg)(DDo,(0,p.A)({},fDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}MDo.isMDXComponent=!0;const XDo={toc:[]},_Do="wrapper";function wDo(e){let{components:n,...t}=e;return(0,s.yg)(_Do,(0,p.A)({},XDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wDo.isMDXComponent=!0;const TDo={toc:[]},CDo="wrapper";function xDo(e){let{components:n,...t}=e;return(0,s.yg)(CDo,(0,p.A)({},TDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xDo.isMDXComponent=!0;const ADo={toc:[]},vDo="wrapper";function LDo(e){let{components:n,...t}=e;return(0,s.yg)(vDo,(0,p.A)({},ADo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LDo.isMDXComponent=!0;const bDo={toc:[]},NDo="wrapper";function kDo(e){let{components:n,...t}=e;return(0,s.yg)(NDo,(0,p.A)({},bDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}kDo.isMDXComponent=!0;const zDo={toc:[]},PDo="wrapper";function IDo(e){let{components:n,...t}=e;return(0,s.yg)(PDo,(0,p.A)({},zDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}IDo.isMDXComponent=!0;const RDo={toc:[]},WDo="wrapper";function SDo(e){let{components:n,...t}=e;return(0,s.yg)(WDo,(0,p.A)({},RDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}SDo.isMDXComponent=!0;const BDo={toc:[]},GDo="wrapper";function EDo(e){let{components:n,...t}=e;return(0,s.yg)(GDo,(0,p.A)({},BDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}EDo.isMDXComponent=!0;const ODo={toc:[]},UDo="wrapper";function FDo(e){let{components:n,...t}=e;return(0,s.yg)(UDo,(0,p.A)({},ODo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}FDo.isMDXComponent=!0;const VDo={toc:[]},qDo="wrapper";function jDo(e){let{components:n,...t}=e;return(0,s.yg)(qDo,(0,p.A)({},VDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jDo.isMDXComponent=!0;const HDo={toc:[]},YDo="wrapper";function QDo(e){let{components:n,...t}=e;return(0,s.yg)(YDo,(0,p.A)({},HDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}QDo.isMDXComponent=!0;const $Do={toc:[]},KDo="wrapper";function JDo(e){let{components:n,...t}=e;return(0,s.yg)(KDo,(0,p.A)({},$Do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JDo.isMDXComponent=!0;const ZDo={toc:[]},eMo="wrapper";function nMo(e){let{components:n,...t}=e;return(0,s.yg)(eMo,(0,p.A)({},ZDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}nMo.isMDXComponent=!0;const tMo={toc:[]},oMo="wrapper";function pMo(e){let{components:n,...t}=e;return(0,s.yg)(oMo,(0,p.A)({},tMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pMo.isMDXComponent=!0;const rMo={toc:[]},sMo="wrapper";function cMo(e){let{components:n,...t}=e;return(0,s.yg)(sMo,(0,p.A)({},rMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}cMo.isMDXComponent=!0;const aMo={toc:[]},iMo="wrapper";function lMo(e){let{components:n,...t}=e;return(0,s.yg)(iMo,(0,p.A)({},aMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}lMo.isMDXComponent=!0;const uMo={toc:[]},mMo="wrapper";function yMo(e){let{components:n,...t}=e;return(0,s.yg)(mMo,(0,p.A)({},uMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yMo.isMDXComponent=!0;const dMo={toc:[]},hMo="wrapper";function gMo(e){let{components:n,...t}=e;return(0,s.yg)(hMo,(0,p.A)({},dMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}gMo.isMDXComponent=!0;const fMo={toc:[]},DMo="wrapper";function MMo(e){let{components:n,...t}=e;return(0,s.yg)(DMo,(0,p.A)({},fMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}MMo.isMDXComponent=!0;const XMo={toc:[]},_Mo="wrapper";function wMo(e){let{components:n,...t}=e;return(0,s.yg)(_Mo,(0,p.A)({},XMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}wMo.isMDXComponent=!0;const TMo={toc:[]},CMo="wrapper";function xMo(e){let{components:n,...t}=e;return(0,s.yg)(CMo,(0,p.A)({},TMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}xMo.isMDXComponent=!0;const AMo={toc:[]},vMo="wrapper";function LMo(e){let{components:n,...t}=e;return(0,s.yg)(vMo,(0,p.A)({},AMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}LMo.isMDXComponent=!0;const bMo={toc:[]},NMo="wrapper";function kMo(e){let{components:n,...t}=e;return(0,s.yg)(NMo,(0,p.A)({},bMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}kMo.isMDXComponent=!0;const zMo={toc:[]},PMo="wrapper";function IMo(e){let{components:n,...t}=e;return(0,s.yg)(PMo,(0,p.A)({},zMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}IMo.isMDXComponent=!0;const RMo={toc:[]},WMo="wrapper";function SMo(e){let{components:n,...t}=e;return(0,s.yg)(WMo,(0,p.A)({},RMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}SMo.isMDXComponent=!0;const BMo={toc:[]},GMo="wrapper";function EMo(e){let{components:n,...t}=e;return(0,s.yg)(GMo,(0,p.A)({},BMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}EMo.isMDXComponent=!0;const OMo={toc:[]},UMo="wrapper";function FMo(e){let{components:n,...t}=e;return(0,s.yg)(UMo,(0,p.A)({},OMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}FMo.isMDXComponent=!0;const VMo={toc:[]},qMo="wrapper";function jMo(e){let{components:n,...t}=e;return(0,s.yg)(qMo,(0,p.A)({},VMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}jMo.isMDXComponent=!0;const HMo={toc:[]},YMo="wrapper";function QMo(e){let{components:n,...t}=e;return(0,s.yg)(YMo,(0,p.A)({},HMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QMo.isMDXComponent=!0;const $Mo={toc:[]},KMo="wrapper";function JMo(e){let{components:n,...t}=e;return(0,s.yg)(KMo,(0,p.A)({},$Mo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}JMo.isMDXComponent=!0;const ZMo={toc:[]},eXo="wrapper";function nXo(e){let{components:n,...t}=e;return(0,s.yg)(eXo,(0,p.A)({},ZMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nXo.isMDXComponent=!0;const tXo={toc:[]},oXo="wrapper";function pXo(e){let{components:n,...t}=e;return(0,s.yg)(oXo,(0,p.A)({},tXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pXo.isMDXComponent=!0;const rXo={toc:[]},sXo="wrapper";function cXo(e){let{components:n,...t}=e;return(0,s.yg)(sXo,(0,p.A)({},rXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}cXo.isMDXComponent=!0;const aXo={toc:[]},iXo="wrapper";function lXo(e){let{components:n,...t}=e;return(0,s.yg)(iXo,(0,p.A)({},aXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lXo.isMDXComponent=!0;const uXo={toc:[]},mXo="wrapper";function yXo(e){let{components:n,...t}=e;return(0,s.yg)(mXo,(0,p.A)({},uXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}yXo.isMDXComponent=!0;const dXo={toc:[]},hXo="wrapper";function gXo(e){let{components:n,...t}=e;return(0,s.yg)(hXo,(0,p.A)({},dXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}gXo.isMDXComponent=!0;const fXo={toc:[]},DXo="wrapper";function MXo(e){let{components:n,...t}=e;return(0,s.yg)(DXo,(0,p.A)({},fXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MXo.isMDXComponent=!0;const XXo={toc:[]},_Xo="wrapper";function wXo(e){let{components:n,...t}=e;return(0,s.yg)(_Xo,(0,p.A)({},XXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}wXo.isMDXComponent=!0;const TXo={toc:[]},CXo="wrapper";function xXo(e){let{components:n,...t}=e;return(0,s.yg)(CXo,(0,p.A)({},TXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}xXo.isMDXComponent=!0;const AXo={toc:[]},vXo="wrapper";function LXo(e){let{components:n,...t}=e;return(0,s.yg)(vXo,(0,p.A)({},AXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}LXo.isMDXComponent=!0;const bXo={toc:[]},NXo="wrapper";function kXo(e){let{components:n,...t}=e;return(0,s.yg)(NXo,(0,p.A)({},bXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kXo.isMDXComponent=!0;const zXo={toc:[]},PXo="wrapper";function IXo(e){let{components:n,...t}=e;return(0,s.yg)(PXo,(0,p.A)({},zXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}IXo.isMDXComponent=!0;const RXo={toc:[]},WXo="wrapper";function SXo(e){let{components:n,...t}=e;return(0,s.yg)(WXo,(0,p.A)({},RXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}SXo.isMDXComponent=!0;const BXo={toc:[]},GXo="wrapper";function EXo(e){let{components:n,...t}=e;return(0,s.yg)(GXo,(0,p.A)({},BXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}EXo.isMDXComponent=!0;const OXo={toc:[]},UXo="wrapper";function FXo(e){let{components:n,...t}=e;return(0,s.yg)(UXo,(0,p.A)({},OXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}FXo.isMDXComponent=!0;const VXo={toc:[]},qXo="wrapper";function jXo(e){let{components:n,...t}=e;return(0,s.yg)(qXo,(0,p.A)({},VXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}jXo.isMDXComponent=!0;const HXo={toc:[]},YXo="wrapper";function QXo(e){let{components:n,...t}=e;return(0,s.yg)(YXo,(0,p.A)({},HXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}QXo.isMDXComponent=!0;const $Xo={toc:[]},KXo="wrapper";function JXo(e){let{components:n,...t}=e;return(0,s.yg)(KXo,(0,p.A)({},$Xo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}JXo.isMDXComponent=!0;const ZXo={toc:[]},e_o="wrapper";function n_o(e){let{components:n,...t}=e;return(0,s.yg)(e_o,(0,p.A)({},ZXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}n_o.isMDXComponent=!0;const t_o={toc:[]},o_o="wrapper";function p_o(e){let{components:n,...t}=e;return(0,s.yg)(o_o,(0,p.A)({},t_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}p_o.isMDXComponent=!0;const r_o={toc:[]},s_o="wrapper";function c_o(e){let{components:n,...t}=e;return(0,s.yg)(s_o,(0,p.A)({},r_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}c_o.isMDXComponent=!0;const a_o={toc:[]},i_o="wrapper";function l_o(e){let{components:n,...t}=e;return(0,s.yg)(i_o,(0,p.A)({},a_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}l_o.isMDXComponent=!0;const u_o={toc:[]},m_o="wrapper";function y_o(e){let{components:n,...t}=e;return(0,s.yg)(m_o,(0,p.A)({},u_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}y_o.isMDXComponent=!0;const d_o={toc:[]},h_o="wrapper";function g_o(e){let{components:n,...t}=e;return(0,s.yg)(h_o,(0,p.A)({},d_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}g_o.isMDXComponent=!0;const f_o={toc:[]},D_o="wrapper";function M_o(e){let{components:n,...t}=e;return(0,s.yg)(D_o,(0,p.A)({},f_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}M_o.isMDXComponent=!0;const X_o={toc:[]},__o="wrapper";function w_o(e){let{components:n,...t}=e;return(0,s.yg)(__o,(0,p.A)({},X_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}w_o.isMDXComponent=!0;const T_o={toc:[]},C_o="wrapper";function x_o(e){let{components:n,...t}=e;return(0,s.yg)(C_o,(0,p.A)({},T_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}x_o.isMDXComponent=!0;const A_o={toc:[]},v_o="wrapper";function L_o(e){let{components:n,...t}=e;return(0,s.yg)(v_o,(0,p.A)({},A_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}L_o.isMDXComponent=!0;const b_o={toc:[]},N_o="wrapper";function k_o(e){let{components:n,...t}=e;return(0,s.yg)(N_o,(0,p.A)({},b_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}k_o.isMDXComponent=!0;const z_o={toc:[]},P_o="wrapper";function I_o(e){let{components:n,...t}=e;return(0,s.yg)(P_o,(0,p.A)({},z_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}I_o.isMDXComponent=!0;const R_o={toc:[]},W_o="wrapper";function S_o(e){let{components:n,...t}=e;return(0,s.yg)(W_o,(0,p.A)({},R_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}S_o.isMDXComponent=!0;const B_o={toc:[]},G_o="wrapper";function E_o(e){let{components:n,...t}=e;return(0,s.yg)(G_o,(0,p.A)({},B_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}E_o.isMDXComponent=!0;const O_o={toc:[]},U_o="wrapper";function F_o(e){let{components:n,...t}=e;return(0,s.yg)(U_o,(0,p.A)({},O_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}F_o.isMDXComponent=!0;const V_o={toc:[]},q_o="wrapper";function j_o(e){let{components:n,...t}=e;return(0,s.yg)(q_o,(0,p.A)({},V_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}j_o.isMDXComponent=!0;const H_o={toc:[]},Y_o="wrapper";function Q_o(e){let{components:n,...t}=e;return(0,s.yg)(Y_o,(0,p.A)({},H_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Q_o.isMDXComponent=!0;const $_o={toc:[]},K_o="wrapper";function J_o(e){let{components:n,...t}=e;return(0,s.yg)(K_o,(0,p.A)({},$_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}J_o.isMDXComponent=!0;const Z_o={toc:[]},ewo="wrapper";function nwo(e){let{components:n,...t}=e;return(0,s.yg)(ewo,(0,p.A)({},Z_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}nwo.isMDXComponent=!0;const two={toc:[]},owo="wrapper";function pwo(e){let{components:n,...t}=e;return(0,s.yg)(owo,(0,p.A)({},two,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pwo.isMDXComponent=!0;const rwo={toc:[]},swo="wrapper";function cwo(e){let{components:n,...t}=e;return(0,s.yg)(swo,(0,p.A)({},rwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}cwo.isMDXComponent=!0;const awo={toc:[]},iwo="wrapper";function lwo(e){let{components:n,...t}=e;return(0,s.yg)(iwo,(0,p.A)({},awo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}lwo.isMDXComponent=!0;const uwo={toc:[]},mwo="wrapper";function ywo(e){let{components:n,...t}=e;return(0,s.yg)(mwo,(0,p.A)({},uwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}ywo.isMDXComponent=!0;const dwo={toc:[]},hwo="wrapper";function gwo(e){let{components:n,...t}=e;return(0,s.yg)(hwo,(0,p.A)({},dwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}gwo.isMDXComponent=!0;const fwo={toc:[]},Dwo="wrapper";function Mwo(e){let{components:n,...t}=e;return(0,s.yg)(Dwo,(0,p.A)({},fwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Mwo.isMDXComponent=!0;const Xwo={toc:[]},_wo="wrapper";function wwo(e){let{components:n,...t}=e;return(0,s.yg)(_wo,(0,p.A)({},Xwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}wwo.isMDXComponent=!0;const Two={toc:[]},Cwo="wrapper";function xwo(e){let{components:n,...t}=e;return(0,s.yg)(Cwo,(0,p.A)({},Two,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}xwo.isMDXComponent=!0;const Awo={toc:[]},vwo="wrapper";function Lwo(e){let{components:n,...t}=e;return(0,s.yg)(vwo,(0,p.A)({},Awo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Lwo.isMDXComponent=!0;const bwo={toc:[]},Nwo="wrapper";function kwo(e){let{components:n,...t}=e;return(0,s.yg)(Nwo,(0,p.A)({},bwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}kwo.isMDXComponent=!0;const zwo={toc:[]},Pwo="wrapper";function Iwo(e){let{components:n,...t}=e;return(0,s.yg)(Pwo,(0,p.A)({},zwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Iwo.isMDXComponent=!0;const Rwo={toc:[]},Wwo="wrapper";function Swo(e){let{components:n,...t}=e;return(0,s.yg)(Wwo,(0,p.A)({},Rwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Swo.isMDXComponent=!0;const Bwo={toc:[]},Gwo="wrapper";function Ewo(e){let{components:n,...t}=e;return(0,s.yg)(Gwo,(0,p.A)({},Bwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Ewo.isMDXComponent=!0;const Owo={toc:[]},Uwo="wrapper";function Fwo(e){let{components:n,...t}=e;return(0,s.yg)(Uwo,(0,p.A)({},Owo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Fwo.isMDXComponent=!0;const Vwo={toc:[]},qwo="wrapper";function jwo(e){let{components:n,...t}=e;return(0,s.yg)(qwo,(0,p.A)({},Vwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}jwo.isMDXComponent=!0;const Hwo={toc:[]},Ywo="wrapper";function Qwo(e){let{components:n,...t}=e;return(0,s.yg)(Ywo,(0,p.A)({},Hwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Qwo.isMDXComponent=!0;const $wo={toc:[]},Kwo="wrapper";function Jwo(e){let{components:n,...t}=e;return(0,s.yg)(Kwo,(0,p.A)({},$wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Jwo.isMDXComponent=!0;const Zwo={toc:[]},eTo="wrapper";function nTo(e){let{components:n,...t}=e;return(0,s.yg)(eTo,(0,p.A)({},Zwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}nTo.isMDXComponent=!0;const tTo={toc:[]},oTo="wrapper";function pTo(e){let{components:n,...t}=e;return(0,s.yg)(oTo,(0,p.A)({},tTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}pTo.isMDXComponent=!0;const rTo={toc:[]},sTo="wrapper";function cTo(e){let{components:n,...t}=e;return(0,s.yg)(sTo,(0,p.A)({},rTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}cTo.isMDXComponent=!0;const aTo={toc:[]},iTo="wrapper";function lTo(e){let{components:n,...t}=e;return(0,s.yg)(iTo,(0,p.A)({},aTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}lTo.isMDXComponent=!0;const uTo={toc:[]},mTo="wrapper";function yTo(e){let{components:n,...t}=e;return(0,s.yg)(mTo,(0,p.A)({},uTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}yTo.isMDXComponent=!0;const dTo={toc:[]},hTo="wrapper";function gTo(e){let{components:n,...t}=e;return(0,s.yg)(hTo,(0,p.A)({},dTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}gTo.isMDXComponent=!0;const fTo={toc:[]},DTo="wrapper";function MTo(e){let{components:n,...t}=e;return(0,s.yg)(DTo,(0,p.A)({},fTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}MTo.isMDXComponent=!0;const XTo={toc:[]},_To="wrapper";function wTo(e){let{components:n,...t}=e;return(0,s.yg)(_To,(0,p.A)({},XTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}wTo.isMDXComponent=!0;const TTo={toc:[]},CTo="wrapper";function xTo(e){let{components:n,...t}=e;return(0,s.yg)(CTo,(0,p.A)({},TTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}xTo.isMDXComponent=!0;const ATo={toc:[]},vTo="wrapper";function LTo(e){let{components:n,...t}=e;return(0,s.yg)(vTo,(0,p.A)({},ATo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}LTo.isMDXComponent=!0;const bTo={toc:[]},NTo="wrapper";function kTo(e){let{components:n,...t}=e;return(0,s.yg)(NTo,(0,p.A)({},bTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}kTo.isMDXComponent=!0;const zTo={toc:[]},PTo="wrapper";function ITo(e){let{components:n,...t}=e;return(0,s.yg)(PTo,(0,p.A)({},zTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}ITo.isMDXComponent=!0;const RTo={toc:[]},WTo="wrapper";function STo(e){let{components:n,...t}=e;return(0,s.yg)(WTo,(0,p.A)({},RTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}STo.isMDXComponent=!0;const BTo={toc:[]},GTo="wrapper";function ETo(e){let{components:n,...t}=e;return(0,s.yg)(GTo,(0,p.A)({},BTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}ETo.isMDXComponent=!0;const OTo={toc:[]},UTo="wrapper";function FTo(e){let{components:n,...t}=e;return(0,s.yg)(UTo,(0,p.A)({},OTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}FTo.isMDXComponent=!0;const VTo={toc:[]},qTo="wrapper";function jTo(e){let{components:n,...t}=e;return(0,s.yg)(qTo,(0,p.A)({},VTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jTo.isMDXComponent=!0;const HTo={toc:[]},YTo="wrapper";function QTo(e){let{components:n,...t}=e;return(0,s.yg)(YTo,(0,p.A)({},HTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}QTo.isMDXComponent=!0;const $To={toc:[]},KTo="wrapper";function JTo(e){let{components:n,...t}=e;return(0,s.yg)(KTo,(0,p.A)({},$To,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}JTo.isMDXComponent=!0;const ZTo={toc:[]},eCo="wrapper";function nCo(e){let{components:n,...t}=e;return(0,s.yg)(eCo,(0,p.A)({},ZTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nCo.isMDXComponent=!0;const tCo={toc:[]},oCo="wrapper";function pCo(e){let{components:n,...t}=e;return(0,s.yg)(oCo,(0,p.A)({},tCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pCo.isMDXComponent=!0;const rCo={toc:[]},sCo="wrapper";function cCo(e){let{components:n,...t}=e;return(0,s.yg)(sCo,(0,p.A)({},rCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}cCo.isMDXComponent=!0;const aCo={toc:[]},iCo="wrapper";function lCo(e){let{components:n,...t}=e;return(0,s.yg)(iCo,(0,p.A)({},aCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}lCo.isMDXComponent=!0;const uCo={toc:[]},mCo="wrapper";function yCo(e){let{components:n,...t}=e;return(0,s.yg)(mCo,(0,p.A)({},uCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}yCo.isMDXComponent=!0;const dCo={toc:[]},hCo="wrapper";function gCo(e){let{components:n,...t}=e;return(0,s.yg)(hCo,(0,p.A)({},dCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}gCo.isMDXComponent=!0;const fCo={toc:[]},DCo="wrapper";function MCo(e){let{components:n,...t}=e;return(0,s.yg)(DCo,(0,p.A)({},fCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}MCo.isMDXComponent=!0;const XCo={toc:[]},_Co="wrapper";function wCo(e){let{components:n,...t}=e;return(0,s.yg)(_Co,(0,p.A)({},XCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}wCo.isMDXComponent=!0;const TCo={toc:[]},CCo="wrapper";function xCo(e){let{components:n,...t}=e;return(0,s.yg)(CCo,(0,p.A)({},TCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xCo.isMDXComponent=!0;const ACo={toc:[]},vCo="wrapper";function LCo(e){let{components:n,...t}=e;return(0,s.yg)(vCo,(0,p.A)({},ACo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}LCo.isMDXComponent=!0;const bCo={toc:[]},NCo="wrapper";function kCo(e){let{components:n,...t}=e;return(0,s.yg)(NCo,(0,p.A)({},bCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you're not interested in animating SVG, you can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,s.yg)("inlineCode",{parentName:"a"},"Img"))," instead."))}kCo.isMDXComponent=!0;const zCo={toc:[]},PCo="wrapper";function ICo(e){let{components:n,...t}=e;return(0,s.yg)(PCo,(0,p.A)({},zCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A Node for drawing and animating SVG images."))}ICo.isMDXComponent=!0;const RCo={toc:[]},WCo="wrapper";function SCo(e){let{components:n,...t}=e;return(0,s.yg)(WCo,(0,p.A)({},RCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}SCo.isMDXComponent=!0;const BCo={toc:[]},GCo="wrapper";function ECo(e){let{components:n,...t}=e;return(0,s.yg)(GCo,(0,p.A)({},BCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}ECo.isMDXComponent=!0;const OCo={toc:[]},UCo="wrapper";function FCo(e){let{components:n,...t}=e;return(0,s.yg)(UCo,(0,p.A)({},OCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}FCo.isMDXComponent=!0;const VCo={toc:[]},qCo="wrapper";function jCo(e){let{components:n,...t}=e;return(0,s.yg)(qCo,(0,p.A)({},VCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}jCo.isMDXComponent=!0;const HCo={toc:[]},YCo="wrapper";function QCo(e){let{components:n,...t}=e;return(0,s.yg)(YCo,(0,p.A)({},HCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}QCo.isMDXComponent=!0;const $Co={toc:[]},KCo="wrapper";function JCo(e){let{components:n,...t}=e;return(0,s.yg)(KCo,(0,p.A)({},$Co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}JCo.isMDXComponent=!0;const ZCo={toc:[]},exo="wrapper";function nxo(e){let{components:n,...t}=e;return(0,s.yg)(exo,(0,p.A)({},ZCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}nxo.isMDXComponent=!0;const txo={toc:[]},oxo="wrapper";function pxo(e){let{components:n,...t}=e;return(0,s.yg)(oxo,(0,p.A)({},txo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}pxo.isMDXComponent=!0;const rxo={toc:[]},sxo="wrapper";function cxo(e){let{components:n,...t}=e;return(0,s.yg)(sxo,(0,p.A)({},rxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cxo.isMDXComponent=!0;const axo={toc:[]},ixo="wrapper";function lxo(e){let{components:n,...t}=e;return(0,s.yg)(ixo,(0,p.A)({},axo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}lxo.isMDXComponent=!0;const uxo={toc:[]},mxo="wrapper";function yxo(e){let{components:n,...t}=e;return(0,s.yg)(mxo,(0,p.A)({},uxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}yxo.isMDXComponent=!0;const dxo={toc:[]},hxo="wrapper";function gxo(e){let{components:n,...t}=e;return(0,s.yg)(hxo,(0,p.A)({},dxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}gxo.isMDXComponent=!0;const fxo={toc:[]},Dxo="wrapper";function Mxo(e){let{components:n,...t}=e;return(0,s.yg)(Dxo,(0,p.A)({},fxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Mxo.isMDXComponent=!0;const Xxo={toc:[]},_xo="wrapper";function wxo(e){let{components:n,...t}=e;return(0,s.yg)(_xo,(0,p.A)({},Xxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wxo.isMDXComponent=!0;const Txo={toc:[]},Cxo="wrapper";function xxo(e){let{components:n,...t}=e;return(0,s.yg)(Cxo,(0,p.A)({},Txo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}xxo.isMDXComponent=!0;const Axo={toc:[]},vxo="wrapper";function Lxo(e){let{components:n,...t}=e;return(0,s.yg)(vxo,(0,p.A)({},Axo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Lxo.isMDXComponent=!0;const bxo={toc:[]},Nxo="wrapper";function kxo(e){let{components:n,...t}=e;return(0,s.yg)(Nxo,(0,p.A)({},bxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}kxo.isMDXComponent=!0;const zxo={toc:[]},Pxo="wrapper";function Ixo(e){let{components:n,...t}=e;return(0,s.yg)(Pxo,(0,p.A)({},zxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Ixo.isMDXComponent=!0;const Rxo={toc:[]},Wxo="wrapper";function Sxo(e){let{components:n,...t}=e;return(0,s.yg)(Wxo,(0,p.A)({},Rxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Sxo.isMDXComponent=!0;const Bxo={toc:[]},Gxo="wrapper";function Exo(e){let{components:n,...t}=e;return(0,s.yg)(Gxo,(0,p.A)({},Bxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Exo.isMDXComponent=!0;const Oxo={toc:[]},Uxo="wrapper";function Fxo(e){let{components:n,...t}=e;return(0,s.yg)(Uxo,(0,p.A)({},Oxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Fxo.isMDXComponent=!0;const Vxo={toc:[]},qxo="wrapper";function jxo(e){let{components:n,...t}=e;return(0,s.yg)(qxo,(0,p.A)({},Vxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}jxo.isMDXComponent=!0;const Hxo={toc:[]},Yxo="wrapper";function Qxo(e){let{components:n,...t}=e;return(0,s.yg)(Yxo,(0,p.A)({},Hxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Qxo.isMDXComponent=!0;const $xo={toc:[]},Kxo="wrapper";function Jxo(e){let{components:n,...t}=e;return(0,s.yg)(Kxo,(0,p.A)({},$xo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Jxo.isMDXComponent=!0;const Zxo={toc:[]},eAo="wrapper";function nAo(e){let{components:n,...t}=e;return(0,s.yg)(eAo,(0,p.A)({},Zxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}nAo.isMDXComponent=!0;const tAo={toc:[]},oAo="wrapper";function pAo(e){let{components:n,...t}=e;return(0,s.yg)(oAo,(0,p.A)({},tAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}pAo.isMDXComponent=!0;const rAo={toc:[]},sAo="wrapper";function cAo(e){let{components:n,...t}=e;return(0,s.yg)(sAo,(0,p.A)({},rAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cAo.isMDXComponent=!0;const aAo={toc:[]},iAo="wrapper";function lAo(e){let{components:n,...t}=e;return(0,s.yg)(iAo,(0,p.A)({},aAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lAo.isMDXComponent=!0;const uAo={toc:[]},mAo="wrapper";function yAo(e){let{components:n,...t}=e;return(0,s.yg)(mAo,(0,p.A)({},uAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}yAo.isMDXComponent=!0;const dAo={toc:[]},hAo="wrapper";function gAo(e){let{components:n,...t}=e;return(0,s.yg)(hAo,(0,p.A)({},dAo,t,{components:n,mdxType:"MDXLayout"}))}gAo.isMDXComponent=!0;const fAo={toc:[]},DAo="wrapper";function MAo(e){let{components:n,...t}=e;return(0,s.yg)(DAo,(0,p.A)({},fAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}MAo.isMDXComponent=!0;const XAo={toc:[]},_Ao="wrapper";function wAo(e){let{components:n,...t}=e;return(0,s.yg)(_Ao,(0,p.A)({},XAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wAo.isMDXComponent=!0;const TAo={toc:[]},CAo="wrapper";function xAo(e){let{components:n,...t}=e;return(0,s.yg)(CAo,(0,p.A)({},TAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}xAo.isMDXComponent=!0;const AAo={toc:[]},vAo="wrapper";function LAo(e){let{components:n,...t}=e;return(0,s.yg)(vAo,(0,p.A)({},AAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}LAo.isMDXComponent=!0;const bAo={toc:[]},NAo="wrapper";function kAo(e){let{components:n,...t}=e;return(0,s.yg)(NAo,(0,p.A)({},bAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}kAo.isMDXComponent=!0;const zAo={toc:[]},PAo="wrapper";function IAo(e){let{components:n,...t}=e;return(0,s.yg)(PAo,(0,p.A)({},zAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}IAo.isMDXComponent=!0;const RAo={toc:[]},WAo="wrapper";function SAo(e){let{components:n,...t}=e;return(0,s.yg)(WAo,(0,p.A)({},RAo,t,{components:n,mdxType:"MDXLayout"}))}SAo.isMDXComponent=!0;const BAo={toc:[]},GAo="wrapper";function EAo(e){let{components:n,...t}=e;return(0,s.yg)(GAo,(0,p.A)({},BAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"SVG string to be rendered"))}EAo.isMDXComponent=!0;const OAo={toc:[]},UAo="wrapper";function FAo(e){let{components:n,...t}=e;return(0,s.yg)(UAo,(0,p.A)({},OAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}FAo.isMDXComponent=!0;const VAo={toc:[]},qAo="wrapper";function jAo(e){let{components:n,...t}=e;return(0,s.yg)(qAo,(0,p.A)({},VAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}jAo.isMDXComponent=!0;const HAo={toc:[]},YAo="wrapper";function QAo(e){let{components:n,...t}=e;return(0,s.yg)(YAo,(0,p.A)({},HAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}QAo.isMDXComponent=!0;const $Ao={toc:[]},KAo="wrapper";function JAo(e){let{components:n,...t}=e;return(0,s.yg)(KAo,(0,p.A)({},$Ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}JAo.isMDXComponent=!0;const ZAo={toc:[]},evo="wrapper";function nvo(e){let{components:n,...t}=e;return(0,s.yg)(evo,(0,p.A)({},ZAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}nvo.isMDXComponent=!0;const tvo={toc:[]},ovo="wrapper";function pvo(e){let{components:n,...t}=e;return(0,s.yg)(ovo,(0,p.A)({},tvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}pvo.isMDXComponent=!0;const rvo={toc:[]},svo="wrapper";function cvo(e){let{components:n,...t}=e;return(0,s.yg)(svo,(0,p.A)({},rvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Child to wrap all SVG node"))}cvo.isMDXComponent=!0;const avo={toc:[]},ivo="wrapper";function lvo(e){let{components:n,...t}=e;return(0,s.yg)(ivo,(0,p.A)({},avo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}lvo.isMDXComponent=!0;const uvo={toc:[]},mvo="wrapper";function yvo(e){let{components:n,...t}=e;return(0,s.yg)(mvo,(0,p.A)({},uvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yvo.isMDXComponent=!0;const dvo={toc:[]},hvo="wrapper";function gvo(e){let{components:n,...t}=e;return(0,s.yg)(hvo,(0,p.A)({},dvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}gvo.isMDXComponent=!0;const fvo={toc:[]},Dvo="wrapper";function Mvo(e){let{components:n,...t}=e;return(0,s.yg)(Dvo,(0,p.A)({},fvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Mvo.isMDXComponent=!0;const Xvo={toc:[]},_vo="wrapper";function wvo(e){let{components:n,...t}=e;return(0,s.yg)(_vo,(0,p.A)({},Xvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wvo.isMDXComponent=!0;const Tvo={toc:[]},Cvo="wrapper";function xvo(e){let{components:n,...t}=e;return(0,s.yg)(Cvo,(0,p.A)({},Tvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}xvo.isMDXComponent=!0;const Avo={toc:[]},vvo="wrapper";function Lvo(e){let{components:n,...t}=e;return(0,s.yg)(vvo,(0,p.A)({},Avo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Lvo.isMDXComponent=!0;const bvo={toc:[]},Nvo="wrapper";function kvo(e){let{components:n,...t}=e;return(0,s.yg)(Nvo,(0,p.A)({},bvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}kvo.isMDXComponent=!0;const zvo={toc:[]},Pvo="wrapper";function Ivo(e){let{components:n,...t}=e;return(0,s.yg)(Pvo,(0,p.A)({},zvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Ivo.isMDXComponent=!0;const Rvo={toc:[]},Wvo="wrapper";function Svo(e){let{components:n,...t}=e;return(0,s.yg)(Wvo,(0,p.A)({},Rvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Svo.isMDXComponent=!0;const Bvo={toc:[]},Gvo="wrapper";function Evo(e){let{components:n,...t}=e;return(0,s.yg)(Gvo,(0,p.A)({},Bvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}Evo.isMDXComponent=!0;const Ovo={toc:[]},Uvo="wrapper";function Fvo(e){let{components:n,...t}=e;return(0,s.yg)(Uvo,(0,p.A)({},Ovo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," to convert."))}Fvo.isMDXComponent=!0;const Vvo={toc:[]},qvo="wrapper";function jvo(e){let{components:n,...t}=e;return(0,s.yg)(qvo,(0,p.A)({},Vvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGShapeData")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGShape"),"."))}jvo.isMDXComponent=!0;const Hvo={toc:[]},Yvo="wrapper";function Qvo(e){let{components:n,...t}=e;return(0,s.yg)(Yvo,(0,p.A)({},Hvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGShapeData")," to convert."))}Qvo.isMDXComponent=!0;const $vo={toc:[]},Kvo="wrapper";function Jvo(e){let{components:n,...t}=e;return(0,s.yg)(Kvo,(0,p.A)({},$vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Jvo.isMDXComponent=!0;const Zvo={toc:[]},eLo="wrapper";function nLo(e){let{components:n,...t}=e;return(0,s.yg)(eLo,(0,p.A)({},Zvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nLo.isMDXComponent=!0;const tLo={toc:[]},oLo="wrapper";function pLo(e){let{components:n,...t}=e;return(0,s.yg)(oLo,(0,p.A)({},tLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}pLo.isMDXComponent=!0;const rLo={toc:[]},sLo="wrapper";function cLo(e){let{components:n,...t}=e;return(0,s.yg)(sLo,(0,p.A)({},rLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}cLo.isMDXComponent=!0;const aLo={toc:[]},iLo="wrapper";function lLo(e){let{components:n,...t}=e;return(0,s.yg)(iLo,(0,p.A)({},aLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}lLo.isMDXComponent=!0;const uLo={toc:[]},mLo="wrapper";function yLo(e){let{components:n,...t}=e;return(0,s.yg)(mLo,(0,p.A)({},uLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}yLo.isMDXComponent=!0;const dLo={toc:[]},hLo="wrapper";function gLo(e){let{components:n,...t}=e;return(0,s.yg)(hLo,(0,p.A)({},dLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}gLo.isMDXComponent=!0;const fLo={toc:[]},DLo="wrapper";function MLo(e){let{components:n,...t}=e;return(0,s.yg)(DLo,(0,p.A)({},fLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}MLo.isMDXComponent=!0;const XLo={toc:[]},_Lo="wrapper";function wLo(e){let{components:n,...t}=e;return(0,s.yg)(_Lo,(0,p.A)({},XLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}wLo.isMDXComponent=!0;const TLo={toc:[]},CLo="wrapper";function xLo(e){let{components:n,...t}=e;return(0,s.yg)(CLo,(0,p.A)({},TLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}xLo.isMDXComponent=!0;const ALo={toc:[]},vLo="wrapper";function LLo(e){let{components:n,...t}=e;return(0,s.yg)(vLo,(0,p.A)({},ALo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}LLo.isMDXComponent=!0;const bLo={toc:[]},NLo="wrapper";function kLo(e){let{components:n,...t}=e;return(0,s.yg)(NLo,(0,p.A)({},bLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}kLo.isMDXComponent=!0;const zLo={toc:[]},PLo="wrapper";function ILo(e){let{components:n,...t}=e;return(0,s.yg)(PLo,(0,p.A)({},zLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ILo.isMDXComponent=!0;const RLo={toc:[]},WLo="wrapper";function SLo(e){let{components:n,...t}=e;return(0,s.yg)(WLo,(0,p.A)({},RLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}SLo.isMDXComponent=!0;const BLo={toc:[]},GLo="wrapper";function ELo(e){let{components:n,...t}=e;return(0,s.yg)(GLo,(0,p.A)({},BLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ELo.isMDXComponent=!0;const OLo={toc:[]},ULo="wrapper";function FLo(e){let{components:n,...t}=e;return(0,s.yg)(ULo,(0,p.A)({},OLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}FLo.isMDXComponent=!0;const VLo={toc:[]},qLo="wrapper";function jLo(e){let{components:n,...t}=e;return(0,s.yg)(qLo,(0,p.A)({},VLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jLo.isMDXComponent=!0;const HLo={toc:[]},YLo="wrapper";function QLo(e){let{components:n,...t}=e;return(0,s.yg)(YLo,(0,p.A)({},HLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QLo.isMDXComponent=!0;const $Lo={toc:[]},KLo="wrapper";function JLo(e){let{components:n,...t}=e;return(0,s.yg)(KLo,(0,p.A)({},$Lo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}JLo.isMDXComponent=!0;const ZLo={toc:[]},ebo="wrapper";function nbo(e){let{components:n,...t}=e;return(0,s.yg)(ebo,(0,p.A)({},ZLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}nbo.isMDXComponent=!0;const tbo={toc:[]},obo="wrapper";function pbo(e){let{components:n,...t}=e;return(0,s.yg)(obo,(0,p.A)({},tbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}pbo.isMDXComponent=!0;const rbo={toc:[]},sbo="wrapper";function cbo(e){let{components:n,...t}=e;return(0,s.yg)(sbo,(0,p.A)({},rbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}cbo.isMDXComponent=!0;const abo={toc:[]},ibo="wrapper";function lbo(e){let{components:n,...t}=e;return(0,s.yg)(ibo,(0,p.A)({},abo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lbo.isMDXComponent=!0;const ubo={toc:[]},mbo="wrapper";function ybo(e){let{components:n,...t}=e;return(0,s.yg)(mbo,(0,p.A)({},ubo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}ybo.isMDXComponent=!0;const dbo={toc:[]},hbo="wrapper";function gbo(e){let{components:n,...t}=e;return(0,s.yg)(hbo,(0,p.A)({},dbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gbo.isMDXComponent=!0;const fbo={toc:[]},Dbo="wrapper";function Mbo(e){let{components:n,...t}=e;return(0,s.yg)(Dbo,(0,p.A)({},fbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Mbo.isMDXComponent=!0;const Xbo={toc:[]},_bo="wrapper";function wbo(e){let{components:n,...t}=e;return(0,s.yg)(_bo,(0,p.A)({},Xbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wbo.isMDXComponent=!0;const Tbo={toc:[]},Cbo="wrapper";function xbo(e){let{components:n,...t}=e;return(0,s.yg)(Cbo,(0,p.A)({},Tbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xbo.isMDXComponent=!0;const Abo={toc:[]},vbo="wrapper";function Lbo(e){let{components:n,...t}=e;return(0,s.yg)(vbo,(0,p.A)({},Abo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Lbo.isMDXComponent=!0;const bbo={toc:[]},Nbo="wrapper";function kbo(e){let{components:n,...t}=e;return(0,s.yg)(Nbo,(0,p.A)({},bbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}kbo.isMDXComponent=!0;const zbo={toc:[]},Pbo="wrapper";function Ibo(e){let{components:n,...t}=e;return(0,s.yg)(Pbo,(0,p.A)({},zbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ibo.isMDXComponent=!0;const Rbo={toc:[]},Wbo="wrapper";function Sbo(e){let{components:n,...t}=e;return(0,s.yg)(Wbo,(0,p.A)({},Rbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Sbo.isMDXComponent=!0;const Bbo={toc:[]},Gbo="wrapper";function Ebo(e){let{components:n,...t}=e;return(0,s.yg)(Gbo,(0,p.A)({},Bbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ebo.isMDXComponent=!0;const Obo={toc:[]},Ubo="wrapper";function Fbo(e){let{components:n,...t}=e;return(0,s.yg)(Ubo,(0,p.A)({},Obo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Fbo.isMDXComponent=!0;const Vbo={toc:[]},qbo="wrapper";function jbo(e){let{components:n,...t}=e;return(0,s.yg)(qbo,(0,p.A)({},Vbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jbo.isMDXComponent=!0;const Hbo={toc:[]},Ybo="wrapper";function Qbo(e){let{components:n,...t}=e;return(0,s.yg)(Ybo,(0,p.A)({},Hbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Qbo.isMDXComponent=!0;const $bo={toc:[]},Kbo="wrapper";function Jbo(e){let{components:n,...t}=e;return(0,s.yg)(Kbo,(0,p.A)({},$bo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jbo.isMDXComponent=!0;const Zbo={toc:[]},eNo="wrapper";function nNo(e){let{components:n,...t}=e;return(0,s.yg)(eNo,(0,p.A)({},Zbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}nNo.isMDXComponent=!0;const tNo={toc:[]},oNo="wrapper";function pNo(e){let{components:n,...t}=e;return(0,s.yg)(oNo,(0,p.A)({},tNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pNo.isMDXComponent=!0;const rNo={toc:[]},sNo="wrapper";function cNo(e){let{components:n,...t}=e;return(0,s.yg)(sNo,(0,p.A)({},rNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a tweening list to tween between two SVG nodes."))}cNo.isMDXComponent=!0;const aNo={toc:[]},iNo="wrapper";function lNo(e){let{components:n,...t}=e;return(0,s.yg)(iNo,(0,p.A)({},aNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial node,"))}lNo.isMDXComponent=!0;const uNo={toc:[]},mNo="wrapper";function yNo(e){let{components:n,...t}=e;return(0,s.yg)(mNo,(0,p.A)({},uNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The final node."))}yNo.isMDXComponent=!0;const dNo={toc:[]},hNo="wrapper";function gNo(e){let{components:n,...t}=e;return(0,s.yg)(hNo,(0,p.A)({},dNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the tween."))}gNo.isMDXComponent=!0;const fNo={toc:[]},DNo="wrapper";function MNo(e){let{components:n,...t}=e;return(0,s.yg)(DNo,(0,p.A)({},fNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function."))}MNo.isMDXComponent=!0;const XNo={toc:[]},_No="wrapper";function wNo(e){let{components:n,...t}=e;return(0,s.yg)(_No,(0,p.A)({},XNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}wNo.isMDXComponent=!0;const TNo={toc:[]},CNo="wrapper";function xNo(e){let{components:n,...t}=e;return(0,s.yg)(CNo,(0,p.A)({},TNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}xNo.isMDXComponent=!0;const ANo={toc:[]},vNo="wrapper";function LNo(e){let{components:n,...t}=e;return(0,s.yg)(vNo,(0,p.A)({},ANo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all SVG nodes with the given id."))}LNo.isMDXComponent=!0;const bNo={toc:[]},NNo="wrapper";function kNo(e){let{components:n,...t}=e;return(0,s.yg)(NNo,(0,p.A)({},bNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An id to query."))}kNo.isMDXComponent=!0;const zNo={toc:[]},PNo="wrapper";function INo(e){let{components:n,...t}=e;return(0,s.yg)(PNo,(0,p.A)({},zNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}INo.isMDXComponent=!0;const RNo={toc:[]},WNo="wrapper";function SNo(e){let{components:n,...t}=e;return(0,s.yg)(WNo,(0,p.A)({},RNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}SNo.isMDXComponent=!0;const BNo={toc:[]},GNo="wrapper";function ENo(e){let{components:n,...t}=e;return(0,s.yg)(GNo,(0,p.A)({},BNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}ENo.isMDXComponent=!0;const ONo={toc:[]},UNo="wrapper";function FNo(e){let{components:n,...t}=e;return(0,s.yg)(UNo,(0,p.A)({},ONo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}FNo.isMDXComponent=!0;const VNo={toc:[]},qNo="wrapper";function jNo(e){let{components:n,...t}=e;return(0,s.yg)(qNo,(0,p.A)({},VNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jNo.isMDXComponent=!0;const HNo={toc:[]},YNo="wrapper";function QNo(e){let{components:n,...t}=e;return(0,s.yg)(YNo,(0,p.A)({},HNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}QNo.isMDXComponent=!0;const $No={toc:[]},KNo="wrapper";function JNo(e){let{components:n,...t}=e;return(0,s.yg)(KNo,(0,p.A)({},$No,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}JNo.isMDXComponent=!0;const ZNo={toc:[]},eko="wrapper";function nko(e){let{components:n,...t}=e;return(0,s.yg)(eko,(0,p.A)({},ZNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}nko.isMDXComponent=!0;const tko={toc:[]},oko="wrapper";function pko(e){let{components:n,...t}=e;return(0,s.yg)(oko,(0,p.A)({},tko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}pko.isMDXComponent=!0;const rko={toc:[]},sko="wrapper";function cko(e){let{components:n,...t}=e;return(0,s.yg)(sko,(0,p.A)({},rko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}cko.isMDXComponent=!0;const ako={toc:[]},iko="wrapper";function lko(e){let{components:n,...t}=e;return(0,s.yg)(iko,(0,p.A)({},ako,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lko.isMDXComponent=!0;const uko={toc:[]},mko="wrapper";function yko(e){let{components:n,...t}=e;return(0,s.yg)(mko,(0,p.A)({},uko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}yko.isMDXComponent=!0;const dko={toc:[]},hko="wrapper";function gko(e){let{components:n,...t}=e;return(0,s.yg)(hko,(0,p.A)({},dko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gko.isMDXComponent=!0;const fko={toc:[]},Dko="wrapper";function Mko(e){let{components:n,...t}=e;return(0,s.yg)(Dko,(0,p.A)({},fko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Mko.isMDXComponent=!0;const Xko={toc:[]},_ko="wrapper";function wko(e){let{components:n,...t}=e;return(0,s.yg)(_ko,(0,p.A)({},Xko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wko.isMDXComponent=!0;const Tko={toc:[]},Cko="wrapper";function xko(e){let{components:n,...t}=e;return(0,s.yg)(Cko,(0,p.A)({},Tko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}xko.isMDXComponent=!0;const Ako={toc:[]},vko="wrapper";function Lko(e){let{components:n,...t}=e;return(0,s.yg)(vko,(0,p.A)({},Ako,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Lko.isMDXComponent=!0;const bko={toc:[]},Nko="wrapper";function kko(e){let{components:n,...t}=e;return(0,s.yg)(Nko,(0,p.A)({},bko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kko.isMDXComponent=!0;const zko={toc:[]},Pko="wrapper";function Iko(e){let{components:n,...t}=e;return(0,s.yg)(Pko,(0,p.A)({},zko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Iko.isMDXComponent=!0;const Rko={toc:[]},Wko="wrapper";function Sko(e){let{components:n,...t}=e;return(0,s.yg)(Wko,(0,p.A)({},Rko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Sko.isMDXComponent=!0;const Bko={toc:[]},Gko="wrapper";function Eko(e){let{components:n,...t}=e;return(0,s.yg)(Gko,(0,p.A)({},Bko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Eko.isMDXComponent=!0;const Oko={toc:[]},Uko="wrapper";function Fko(e){let{components:n,...t}=e;return(0,s.yg)(Uko,(0,p.A)({},Oko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Fko.isMDXComponent=!0;const Vko={toc:[]},qko="wrapper";function jko(e){let{components:n,...t}=e;return(0,s.yg)(qko,(0,p.A)({},Vko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}jko.isMDXComponent=!0;const Hko={toc:[]},Yko="wrapper";function Qko(e){let{components:n,...t}=e;return(0,s.yg)(Yko,(0,p.A)({},Hko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Qko.isMDXComponent=!0;const $ko={toc:[]},Kko="wrapper";function Jko(e){let{components:n,...t}=e;return(0,s.yg)(Kko,(0,p.A)({},$ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Jko.isMDXComponent=!0;const Zko={toc:[]},ezo="wrapper";function nzo(e){let{components:n,...t}=e;return(0,s.yg)(ezo,(0,p.A)({},Zko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}nzo.isMDXComponent=!0;const tzo={toc:[]},ozo="wrapper";function pzo(e){let{components:n,...t}=e;return(0,s.yg)(ozo,(0,p.A)({},tzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}pzo.isMDXComponent=!0;const rzo={toc:[]},szo="wrapper";function czo(e){let{components:n,...t}=e;return(0,s.yg)(szo,(0,p.A)({},rzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}czo.isMDXComponent=!0;const azo={toc:[]},izo="wrapper";function lzo(e){let{components:n,...t}=e;return(0,s.yg)(izo,(0,p.A)({},azo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lzo.isMDXComponent=!0;const uzo={toc:[]},mzo="wrapper";function yzo(e){let{components:n,...t}=e;return(0,s.yg)(mzo,(0,p.A)({},uzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}yzo.isMDXComponent=!0;const dzo={toc:[]},hzo="wrapper";function gzo(e){let{components:n,...t}=e;return(0,s.yg)(hzo,(0,p.A)({},dzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gzo.isMDXComponent=!0;const fzo={toc:[]},Dzo="wrapper";function Mzo(e){let{components:n,...t}=e;return(0,s.yg)(Dzo,(0,p.A)({},fzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Mzo.isMDXComponent=!0;const Xzo={toc:[]},_zo="wrapper";function wzo(e){let{components:n,...t}=e;return(0,s.yg)(_zo,(0,p.A)({},Xzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wzo.isMDXComponent=!0;const Tzo={toc:[]},Czo="wrapper";function xzo(e){let{components:n,...t}=e;return(0,s.yg)(Czo,(0,p.A)({},Tzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}xzo.isMDXComponent=!0;const Azo={toc:[]},vzo="wrapper";function Lzo(e){let{components:n,...t}=e;return(0,s.yg)(vzo,(0,p.A)({},Azo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Lzo.isMDXComponent=!0;const bzo={toc:[]},Nzo="wrapper";function kzo(e){let{components:n,...t}=e;return(0,s.yg)(Nzo,(0,p.A)({},bzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}kzo.isMDXComponent=!0;const zzo={toc:[]},Pzo="wrapper";function Izo(e){let{components:n,...t}=e;return(0,s.yg)(Pzo,(0,p.A)({},zzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Izo.isMDXComponent=!0;const Rzo={toc:[]},Wzo="wrapper";function Szo(e){let{components:n,...t}=e;return(0,s.yg)(Wzo,(0,p.A)({},Rzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Szo.isMDXComponent=!0;const Bzo={toc:[]},Gzo="wrapper";function Ezo(e){let{components:n,...t}=e;return(0,s.yg)(Gzo,(0,p.A)({},Bzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Ezo.isMDXComponent=!0;const Ozo={toc:[]},Uzo="wrapper";function Fzo(e){let{components:n,...t}=e;return(0,s.yg)(Uzo,(0,p.A)({},Ozo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Fzo.isMDXComponent=!0;const Vzo={toc:[]},qzo="wrapper";function jzo(e){let{components:n,...t}=e;return(0,s.yg)(qzo,(0,p.A)({},Vzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}jzo.isMDXComponent=!0;const Hzo={toc:[]},Yzo="wrapper";function Qzo(e){let{components:n,...t}=e;return(0,s.yg)(Yzo,(0,p.A)({},Hzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Qzo.isMDXComponent=!0;const $zo={toc:[]},Kzo="wrapper";function Jzo(e){let{components:n,...t}=e;return(0,s.yg)(Kzo,(0,p.A)({},$zo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Jzo.isMDXComponent=!0;const Zzo={toc:[]},ePo="wrapper";function nPo(e){let{components:n,...t}=e;return(0,s.yg)(ePo,(0,p.A)({},Zzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}nPo.isMDXComponent=!0;const tPo={toc:[]},oPo="wrapper";function pPo(e){let{components:n,...t}=e;return(0,s.yg)(oPo,(0,p.A)({},tPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert an SVG string to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}pPo.isMDXComponent=!0;const rPo={toc:[]},sPo="wrapper";function cPo(e){let{components:n,...t}=e;return(0,s.yg)(sPo,(0,p.A)({},rPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An SVG string to be parsed."))}cPo.isMDXComponent=!0;const aPo={toc:[]},iPo="wrapper";function lPo(e){let{components:n,...t}=e;return(0,s.yg)(iPo,(0,p.A)({},aPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}lPo.isMDXComponent=!0;const uPo={toc:[]},mPo="wrapper";function yPo(e){let{components:n,...t}=e;return(0,s.yg)(mPo,(0,p.A)({},uPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}yPo.isMDXComponent=!0;const dPo={toc:[]},hPo="wrapper";function gPo(e){let{components:n,...t}=e;return(0,s.yg)(hPo,(0,p.A)({},dPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}gPo.isMDXComponent=!0;const fPo={toc:[]},DPo="wrapper";function MPo(e){let{components:n,...t}=e;return(0,s.yg)(DPo,(0,p.A)({},fPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}MPo.isMDXComponent=!0;const XPo={toc:[]},_Po="wrapper";function wPo(e){let{components:n,...t}=e;return(0,s.yg)(_Po,(0,p.A)({},XPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}wPo.isMDXComponent=!0;const TPo={toc:[]},CPo="wrapper";function xPo(e){let{components:n,...t}=e;return(0,s.yg)(CPo,(0,p.A)({},TPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}xPo.isMDXComponent=!0;const APo={toc:[]},vPo="wrapper";function LPo(e){let{components:n,...t}=e;return(0,s.yg)(vPo,(0,p.A)({},APo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}LPo.isMDXComponent=!0;const bPo={toc:[]},NPo="wrapper";function kPo(e){let{components:n,...t}=e;return(0,s.yg)(NPo,(0,p.A)({},bPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}kPo.isMDXComponent=!0;const zPo={toc:[]},PPo="wrapper";function IPo(e){let{components:n,...t}=e;return(0,s.yg)(PPo,(0,p.A)({},zPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}IPo.isMDXComponent=!0;const RPo={toc:[]},WPo="wrapper";function SPo(e){let{components:n,...t}=e;return(0,s.yg)(WPo,(0,p.A)({},RPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}SPo.isMDXComponent=!0;const BPo={toc:[]},GPo="wrapper";function EPo(e){let{components:n,...t}=e;return(0,s.yg)(GPo,(0,p.A)({},BPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}EPo.isMDXComponent=!0;const OPo={toc:[]},UPo="wrapper";function FPo(e){let{components:n,...t}=e;return(0,s.yg)(UPo,(0,p.A)({},OPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}FPo.isMDXComponent=!0;const VPo={toc:[]},qPo="wrapper";function jPo(e){let{components:n,...t}=e;return(0,s.yg)(qPo,(0,p.A)({},VPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}jPo.isMDXComponent=!0;const HPo={toc:[]},YPo="wrapper";function QPo(e){let{components:n,...t}=e;return(0,s.yg)(YPo,(0,p.A)({},HPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}QPo.isMDXComponent=!0;const $Po={toc:[]},KPo="wrapper";function JPo(e){let{components:n,...t}=e;return(0,s.yg)(KPo,(0,p.A)({},$Po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}JPo.isMDXComponent=!0;const ZPo={toc:[]},eIo="wrapper";function nIo(e){let{components:n,...t}=e;return(0,s.yg)(eIo,(0,p.A)({},ZPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}nIo.isMDXComponent=!0;const tIo={toc:[]},oIo="wrapper";function pIo(e){let{components:n,...t}=e;return(0,s.yg)(oIo,(0,p.A)({},tIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pIo.isMDXComponent=!0;const rIo={toc:[]},sIo="wrapper";function cIo(e){let{components:n,...t}=e;return(0,s.yg)(sIo,(0,p.A)({},rIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}cIo.isMDXComponent=!0;const aIo={toc:[]},iIo="wrapper";function lIo(e){let{components:n,...t}=e;return(0,s.yg)(iIo,(0,p.A)({},aIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}lIo.isMDXComponent=!0;const uIo={toc:[]},mIo="wrapper";function yIo(e){let{components:n,...t}=e;return(0,s.yg)(mIo,(0,p.A)({},uIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}yIo.isMDXComponent=!0;const dIo={toc:[]},hIo="wrapper";function gIo(e){let{components:n,...t}=e;return(0,s.yg)(hIo,(0,p.A)({},dIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gIo.isMDXComponent=!0;const fIo={toc:[]},DIo="wrapper";function MIo(e){let{components:n,...t}=e;return(0,s.yg)(DIo,(0,p.A)({},fIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}MIo.isMDXComponent=!0;const XIo={toc:[]},_Io="wrapper";function wIo(e){let{components:n,...t}=e;return(0,s.yg)(_Io,(0,p.A)({},XIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}wIo.isMDXComponent=!0;const TIo={toc:[]},CIo="wrapper";function xIo(e){let{components:n,...t}=e;return(0,s.yg)(CIo,(0,p.A)({},TIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xIo.isMDXComponent=!0;const AIo={toc:[]},vIo="wrapper";function LIo(e){let{components:n,...t}=e;return(0,s.yg)(vIo,(0,p.A)({},AIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}LIo.isMDXComponent=!0;const bIo={toc:[]},NIo="wrapper";function kIo(e){let{components:n,...t}=e;return(0,s.yg)(NIo,(0,p.A)({},bIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kIo.isMDXComponent=!0;const zIo={toc:[]},PIo="wrapper";function IIo(e){let{components:n,...t}=e;return(0,s.yg)(PIo,(0,p.A)({},zIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}IIo.isMDXComponent=!0;const RIo={toc:[]},WIo="wrapper";function SIo(e){let{components:n,...t}=e;return(0,s.yg)(WIo,(0,p.A)({},RIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}SIo.isMDXComponent=!0;const BIo={toc:[]},GIo="wrapper";function EIo(e){let{components:n,...t}=e;return(0,s.yg)(GIo,(0,p.A)({},BIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}EIo.isMDXComponent=!0;const OIo={toc:[]},UIo="wrapper";function FIo(e){let{components:n,...t}=e;return(0,s.yg)(UIo,(0,p.A)({},OIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}FIo.isMDXComponent=!0;const VIo={toc:[]},qIo="wrapper";function jIo(e){let{components:n,...t}=e;return(0,s.yg)(qIo,(0,p.A)({},VIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}jIo.isMDXComponent=!0;const HIo={toc:[]},YIo="wrapper";function QIo(e){let{components:n,...t}=e;return(0,s.yg)(YIo,(0,p.A)({},HIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}QIo.isMDXComponent=!0;const $Io={toc:[]},KIo="wrapper";function JIo(e){let{components:n,...t}=e;return(0,s.yg)(KIo,(0,p.A)({},$Io,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JIo.isMDXComponent=!0;const ZIo={toc:[]},eRo="wrapper";function nRo(e){let{components:n,...t}=e;return(0,s.yg)(eRo,(0,p.A)({},ZIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}nRo.isMDXComponent=!0;const tRo={toc:[]},oRo="wrapper";function pRo(e){let{components:n,...t}=e;return(0,s.yg)(oRo,(0,p.A)({},tRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}pRo.isMDXComponent=!0;const rRo={toc:[]},sRo="wrapper";function cRo(e){let{components:n,...t}=e;return(0,s.yg)(sRo,(0,p.A)({},rRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cRo.isMDXComponent=!0;const aRo={toc:[]},iRo="wrapper";function lRo(e){let{components:n,...t}=e;return(0,s.yg)(iRo,(0,p.A)({},aRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lRo.isMDXComponent=!0;const uRo={toc:[]},mRo="wrapper";function yRo(e){let{components:n,...t}=e;return(0,s.yg)(mRo,(0,p.A)({},uRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}yRo.isMDXComponent=!0;const dRo={toc:[]},hRo="wrapper";function gRo(e){let{components:n,...t}=e;return(0,s.yg)(hRo,(0,p.A)({},dRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gRo.isMDXComponent=!0;const fRo={toc:[]},DRo="wrapper";function MRo(e){let{components:n,...t}=e;return(0,s.yg)(DRo,(0,p.A)({},fRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}MRo.isMDXComponent=!0;const XRo={toc:[]},_Ro="wrapper";function wRo(e){let{components:n,...t}=e;return(0,s.yg)(_Ro,(0,p.A)({},XRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wRo.isMDXComponent=!0;const TRo={toc:[]},CRo="wrapper";function xRo(e){let{components:n,...t}=e;return(0,s.yg)(CRo,(0,p.A)({},TRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xRo.isMDXComponent=!0;const ARo={toc:[]},vRo="wrapper";function LRo(e){let{components:n,...t}=e;return(0,s.yg)(vRo,(0,p.A)({},ARo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}LRo.isMDXComponent=!0;const bRo={toc:[]},NRo="wrapper";function kRo(e){let{components:n,...t}=e;return(0,s.yg)(NRo,(0,p.A)({},bRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kRo.isMDXComponent=!0;const zRo={toc:[]},PRo="wrapper";function IRo(e){let{components:n,...t}=e;return(0,s.yg)(PRo,(0,p.A)({},zRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}IRo.isMDXComponent=!0;const RRo={toc:[]},WRo="wrapper";function SRo(e){let{components:n,...t}=e;return(0,s.yg)(WRo,(0,p.A)({},RRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"MotionCanvas Shape properties"))}SRo.isMDXComponent=!0;const BRo={toc:[]},GRo="wrapper";function ERo(e){let{components:n,...t}=e;return(0,s.yg)(GRo,(0,p.A)({},BRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get position, rotation and scale from Matrix transformation as Shape properties"))}ERo.isMDXComponent=!0;const ORo={toc:[]},URo="wrapper";function FRo(e){let{components:n,...t}=e;return(0,s.yg)(URo,(0,p.A)({},ORo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Matrix transformation"))}FRo.isMDXComponent=!0;const VRo={toc:[]},qRo="wrapper";function jRo(e){let{components:n,...t}=e;return(0,s.yg)(qRo,(0,p.A)({},VRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," that can be used to build SVGDocument."))}jRo.isMDXComponent=!0;const HRo={toc:[]},YRo="wrapper";function QRo(e){let{components:n,...t}=e;return(0,s.yg)(YRo,(0,p.A)({},HRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse an SVG string as ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData"),"."))}QRo.isMDXComponent=!0;const $Ro={toc:[]},KRo="wrapper";function JRo(e){let{components:n,...t}=e;return(0,s.yg)(KRo,(0,p.A)({},$Ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"And SVG string to be parsed."))}JRo.isMDXComponent=!0;const ZRo={toc:[]},eWo="wrapper";function nWo(e){let{components:n,...t}=e;return(0,s.yg)(eWo,(0,p.A)({},ZRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}nWo.isMDXComponent=!0;const tWo={toc:[]},oWo="wrapper";function pWo(e){let{components:n,...t}=e;return(0,s.yg)(oWo,(0,p.A)({},tWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}pWo.isMDXComponent=!0;const rWo={toc:[]},sWo="wrapper";function cWo(e){let{components:n,...t}=e;return(0,s.yg)(sWo,(0,p.A)({},rWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cWo.isMDXComponent=!0;const aWo={toc:[]},iWo="wrapper";function lWo(e){let{components:n,...t}=e;return(0,s.yg)(iWo,(0,p.A)({},aWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}lWo.isMDXComponent=!0;const uWo={toc:[]},mWo="wrapper";function yWo(e){let{components:n,...t}=e;return(0,s.yg)(mWo,(0,p.A)({},uWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}yWo.isMDXComponent=!0;const dWo={toc:[]},hWo="wrapper";function gWo(e){let{components:n,...t}=e;return(0,s.yg)(hWo,(0,p.A)({},dWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}gWo.isMDXComponent=!0;const fWo={toc:[]},DWo="wrapper";function MWo(e){let{components:n,...t}=e;return(0,s.yg)(DWo,(0,p.A)({},fWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}MWo.isMDXComponent=!0;const XWo={toc:[]},_Wo="wrapper";function wWo(e){let{components:n,...t}=e;return(0,s.yg)(_Wo,(0,p.A)({},XWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}wWo.isMDXComponent=!0;const TWo={toc:[]},CWo="wrapper";function xWo(e){let{components:n,...t}=e;return(0,s.yg)(CWo,(0,p.A)({},TWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}xWo.isMDXComponent=!0;const AWo={toc:[]},vWo="wrapper";function LWo(e){let{components:n,...t}=e;return(0,s.yg)(vWo,(0,p.A)({},AWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}LWo.isMDXComponent=!0;const bWo={toc:[]},NWo="wrapper";function kWo(e){let{components:n,...t}=e;return(0,s.yg)(NWo,(0,p.A)({},bWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}kWo.isMDXComponent=!0;const zWo={toc:[]},PWo="wrapper";function IWo(e){let{components:n,...t}=e;return(0,s.yg)(PWo,(0,p.A)({},zWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}IWo.isMDXComponent=!0;const RWo={toc:[]},WWo="wrapper";function SWo(e){let{components:n,...t}=e;return(0,s.yg)(WWo,(0,p.A)({},RWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SWo.isMDXComponent=!0;const BWo={toc:[]},GWo="wrapper";function EWo(e){let{components:n,...t}=e;return(0,s.yg)(GWo,(0,p.A)({},BWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}EWo.isMDXComponent=!0;const OWo={toc:[]},UWo="wrapper";function FWo(e){let{components:n,...t}=e;return(0,s.yg)(UWo,(0,p.A)({},OWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}FWo.isMDXComponent=!0;const VWo={toc:[]},qWo="wrapper";function jWo(e){let{components:n,...t}=e;return(0,s.yg)(qWo,(0,p.A)({},VWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}jWo.isMDXComponent=!0;const HWo={toc:[]},YWo="wrapper";function QWo(e){let{components:n,...t}=e;return(0,s.yg)(YWo,(0,p.A)({},HWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}QWo.isMDXComponent=!0;const $Wo={toc:[]},KWo="wrapper";function JWo(e){let{components:n,...t}=e;return(0,s.yg)(KWo,(0,p.A)({},$Wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}JWo.isMDXComponent=!0;const ZWo={toc:[]},eSo="wrapper";function nSo(e){let{components:n,...t}=e;return(0,s.yg)(eSo,(0,p.A)({},ZWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nSo.isMDXComponent=!0;const tSo={toc:[]},oSo="wrapper";function pSo(e){let{components:n,...t}=e;return(0,s.yg)(oSo,(0,p.A)({},tSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}pSo.isMDXComponent=!0;const rSo={toc:[]},sSo="wrapper";function cSo(e){let{components:n,...t}=e;return(0,s.yg)(sSo,(0,p.A)({},rSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}cSo.isMDXComponent=!0;const aSo={toc:[]},iSo="wrapper";function lSo(e){let{components:n,...t}=e;return(0,s.yg)(iSo,(0,p.A)({},aSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}lSo.isMDXComponent=!0;const uSo={toc:[]},mSo="wrapper";function ySo(e){let{components:n,...t}=e;return(0,s.yg)(mSo,(0,p.A)({},uSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ySo.isMDXComponent=!0;const dSo={toc:[]},hSo="wrapper";function gSo(e){let{components:n,...t}=e;return(0,s.yg)(hSo,(0,p.A)({},dSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}gSo.isMDXComponent=!0;const fSo={toc:[]},DSo="wrapper";function MSo(e){let{components:n,...t}=e;return(0,s.yg)(DSo,(0,p.A)({},fSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}MSo.isMDXComponent=!0;const XSo={toc:[]},_So="wrapper";function wSo(e){let{components:n,...t}=e;return(0,s.yg)(_So,(0,p.A)({},XSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}wSo.isMDXComponent=!0;const TSo={toc:[]},CSo="wrapper";function xSo(e){let{components:n,...t}=e;return(0,s.yg)(CSo,(0,p.A)({},TSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xSo.isMDXComponent=!0;const ASo={toc:[]},vSo="wrapper";function LSo(e){let{components:n,...t}=e;return(0,s.yg)(vSo,(0,p.A)({},ASo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LSo.isMDXComponent=!0;const bSo={toc:[]},NSo="wrapper";function kSo(e){let{components:n,...t}=e;return(0,s.yg)(NSo,(0,p.A)({},bSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}kSo.isMDXComponent=!0;const zSo={toc:[]},PSo="wrapper";function ISo(e){let{components:n,...t}=e;return(0,s.yg)(PSo,(0,p.A)({},zSo,t,{components:n,mdxType:"MDXLayout"}))}ISo.isMDXComponent=!0;const RSo={toc:[]},WSo="wrapper";function SSo(e){let{components:n,...t}=e;return(0,s.yg)(WSo,(0,p.A)({},RSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}SSo.isMDXComponent=!0;const BSo={toc:[]},GSo="wrapper";function ESo(e){let{components:n,...t}=e;return(0,s.yg)(GSo,(0,p.A)({},BSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ESo.isMDXComponent=!0;const OSo={toc:[]},USo="wrapper";function FSo(e){let{components:n,...t}=e;return(0,s.yg)(USo,(0,p.A)({},OSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}FSo.isMDXComponent=!0;const VSo={toc:[]},qSo="wrapper";function jSo(e){let{components:n,...t}=e;return(0,s.yg)(qSo,(0,p.A)({},VSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}jSo.isMDXComponent=!0;const HSo={toc:[]},YSo="wrapper";function QSo(e){let{components:n,...t}=e;return(0,s.yg)(YSo,(0,p.A)({},HSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}QSo.isMDXComponent=!0;const $So={toc:[]},KSo="wrapper";function JSo(e){let{components:n,...t}=e;return(0,s.yg)(KSo,(0,p.A)({},$So,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}JSo.isMDXComponent=!0;const ZSo={toc:[]},eBo="wrapper";function nBo(e){let{components:n,...t}=e;return(0,s.yg)(eBo,(0,p.A)({},ZSo,t,{components:n,mdxType:"MDXLayout"}))}nBo.isMDXComponent=!0;const tBo={toc:[]},oBo="wrapper";function pBo(e){let{components:n,...t}=e;return(0,s.yg)(oBo,(0,p.A)({},tBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}pBo.isMDXComponent=!0;const rBo={toc:[]},sBo="wrapper";function cBo(e){let{components:n,...t}=e;return(0,s.yg)(sBo,(0,p.A)({},rBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}cBo.isMDXComponent=!0;const aBo={toc:[]},iBo="wrapper";function lBo(e){let{components:n,...t}=e;return(0,s.yg)(iBo,(0,p.A)({},aBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lBo.isMDXComponent=!0;const uBo={toc:[]},mBo="wrapper";function yBo(e){let{components:n,...t}=e;return(0,s.yg)(mBo,(0,p.A)({},uBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}yBo.isMDXComponent=!0;const dBo={toc:[]},hBo="wrapper";function gBo(e){let{components:n,...t}=e;return(0,s.yg)(hBo,(0,p.A)({},dBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}gBo.isMDXComponent=!0;const fBo={toc:[]},DBo="wrapper";function MBo(e){let{components:n,...t}=e;return(0,s.yg)(DBo,(0,p.A)({},fBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}MBo.isMDXComponent=!0;const XBo={toc:[]},_Bo="wrapper";function wBo(e){let{components:n,...t}=e;return(0,s.yg)(_Bo,(0,p.A)({},XBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}wBo.isMDXComponent=!0;const TBo={toc:[]},CBo="wrapper";function xBo(e){let{components:n,...t}=e;return(0,s.yg)(CBo,(0,p.A)({},TBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}xBo.isMDXComponent=!0;const ABo={toc:[]},vBo="wrapper";function LBo(e){let{components:n,...t}=e;return(0,s.yg)(vBo,(0,p.A)({},ABo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}LBo.isMDXComponent=!0;const bBo={toc:[]},NBo="wrapper";function kBo(e){let{components:n,...t}=e;return(0,s.yg)(NBo,(0,p.A)({},bBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}kBo.isMDXComponent=!0;const zBo={toc:[]},PBo="wrapper";function IBo(e){let{components:n,...t}=e;return(0,s.yg)(PBo,(0,p.A)({},zBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}IBo.isMDXComponent=!0;const RBo={toc:[]},WBo="wrapper";function SBo(e){let{components:n,...t}=e;return(0,s.yg)(WBo,(0,p.A)({},RBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}SBo.isMDXComponent=!0;const BBo={toc:[]},GBo="wrapper";function EBo(e){let{components:n,...t}=e;return(0,s.yg)(GBo,(0,p.A)({},BBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}EBo.isMDXComponent=!0;const OBo={toc:[]},UBo="wrapper";function FBo(e){let{components:n,...t}=e;return(0,s.yg)(UBo,(0,p.A)({},OBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}FBo.isMDXComponent=!0;const VBo={toc:[]},qBo="wrapper";function jBo(e){let{components:n,...t}=e;return(0,s.yg)(qBo,(0,p.A)({},VBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}jBo.isMDXComponent=!0;const HBo={toc:[]},YBo="wrapper";function QBo(e){let{components:n,...t}=e;return(0,s.yg)(YBo,(0,p.A)({},HBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}QBo.isMDXComponent=!0;const $Bo={toc:[]},KBo="wrapper";function JBo(e){let{components:n,...t}=e;return(0,s.yg)(KBo,(0,p.A)({},$Bo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}JBo.isMDXComponent=!0;const ZBo={toc:[]},eGo="wrapper";function nGo(e){let{components:n,...t}=e;return(0,s.yg)(eGo,(0,p.A)({},ZBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nGo.isMDXComponent=!0;const tGo={toc:[]},oGo="wrapper";function pGo(e){let{components:n,...t}=e;return(0,s.yg)(oGo,(0,p.A)({},tGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}pGo.isMDXComponent=!0;const rGo={toc:[]},sGo="wrapper";function cGo(e){let{components:n,...t}=e;return(0,s.yg)(sGo,(0,p.A)({},rGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}cGo.isMDXComponent=!0;const aGo={toc:[]},iGo="wrapper";function lGo(e){let{components:n,...t}=e;return(0,s.yg)(iGo,(0,p.A)({},aGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}lGo.isMDXComponent=!0;const uGo={toc:[]},mGo="wrapper";function yGo(e){let{components:n,...t}=e;return(0,s.yg)(mGo,(0,p.A)({},uGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}yGo.isMDXComponent=!0;const dGo={toc:[]},hGo="wrapper";function gGo(e){let{components:n,...t}=e;return(0,s.yg)(hGo,(0,p.A)({},dGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}gGo.isMDXComponent=!0;const fGo={toc:[]},DGo="wrapper";function MGo(e){let{components:n,...t}=e;return(0,s.yg)(DGo,(0,p.A)({},fGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}MGo.isMDXComponent=!0;const XGo={toc:[]},_Go="wrapper";function wGo(e){let{components:n,...t}=e;return(0,s.yg)(_Go,(0,p.A)({},XGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}wGo.isMDXComponent=!0;const TGo={toc:[]},CGo="wrapper";function xGo(e){let{components:n,...t}=e;return(0,s.yg)(CGo,(0,p.A)({},TGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}xGo.isMDXComponent=!0;const AGo={toc:[]},vGo="wrapper";function LGo(e){let{components:n,...t}=e;return(0,s.yg)(vGo,(0,p.A)({},AGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}LGo.isMDXComponent=!0;const bGo={toc:[]},NGo="wrapper";function kGo(e){let{components:n,...t}=e;return(0,s.yg)(NGo,(0,p.A)({},bGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}kGo.isMDXComponent=!0;const zGo={toc:[]},PGo="wrapper";function IGo(e){let{components:n,...t}=e;return(0,s.yg)(PGo,(0,p.A)({},zGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}IGo.isMDXComponent=!0;const RGo={toc:[]},WGo="wrapper";function SGo(e){let{components:n,...t}=e;return(0,s.yg)(WGo,(0,p.A)({},RGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}SGo.isMDXComponent=!0;const BGo={toc:[]},GGo="wrapper";function EGo(e){let{components:n,...t}=e;return(0,s.yg)(GGo,(0,p.A)({},BGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}EGo.isMDXComponent=!0;const OGo={toc:[]},UGo="wrapper";function FGo(e){let{components:n,...t}=e;return(0,s.yg)(UGo,(0,p.A)({},OGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}FGo.isMDXComponent=!0;const VGo={toc:[]},qGo="wrapper";function jGo(e){let{components:n,...t}=e;return(0,s.yg)(qGo,(0,p.A)({},VGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jGo.isMDXComponent=!0;const HGo={toc:[]},YGo="wrapper";function QGo(e){let{components:n,...t}=e;return(0,s.yg)(YGo,(0,p.A)({},HGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QGo.isMDXComponent=!0;const $Go={toc:[]},KGo="wrapper";function JGo(e){let{components:n,...t}=e;return(0,s.yg)(KGo,(0,p.A)({},$Go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}JGo.isMDXComponent=!0;const ZGo={toc:[]},eEo="wrapper";function nEo(e){let{components:n,...t}=e;return(0,s.yg)(eEo,(0,p.A)({},ZGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}nEo.isMDXComponent=!0;const tEo={toc:[]},oEo="wrapper";function pEo(e){let{components:n,...t}=e;return(0,s.yg)(oEo,(0,p.A)({},tEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}pEo.isMDXComponent=!0;const rEo={toc:[]},sEo="wrapper";function cEo(e){let{components:n,...t}=e;return(0,s.yg)(sEo,(0,p.A)({},rEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}cEo.isMDXComponent=!0;const aEo={toc:[]},iEo="wrapper";function lEo(e){let{components:n,...t}=e;return(0,s.yg)(iEo,(0,p.A)({},aEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lEo.isMDXComponent=!0;const uEo={toc:[]},mEo="wrapper";function yEo(e){let{components:n,...t}=e;return(0,s.yg)(mEo,(0,p.A)({},uEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yEo.isMDXComponent=!0;const dEo={toc:[]},hEo="wrapper";function gEo(e){let{components:n,...t}=e;return(0,s.yg)(hEo,(0,p.A)({},dEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gEo.isMDXComponent=!0;const fEo={toc:[]},DEo="wrapper";function MEo(e){let{components:n,...t}=e;return(0,s.yg)(DEo,(0,p.A)({},fEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}MEo.isMDXComponent=!0;const XEo={toc:[]},_Eo="wrapper";function wEo(e){let{components:n,...t}=e;return(0,s.yg)(_Eo,(0,p.A)({},XEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wEo.isMDXComponent=!0;const TEo={toc:[]},CEo="wrapper";function xEo(e){let{components:n,...t}=e;return(0,s.yg)(CEo,(0,p.A)({},TEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xEo.isMDXComponent=!0;const AEo={toc:[]},vEo="wrapper";function LEo(e){let{components:n,...t}=e;return(0,s.yg)(vEo,(0,p.A)({},AEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LEo.isMDXComponent=!0;const bEo={toc:[]},NEo="wrapper";function kEo(e){let{components:n,...t}=e;return(0,s.yg)(NEo,(0,p.A)({},bEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}kEo.isMDXComponent=!0;const zEo={toc:[]},PEo="wrapper";function IEo(e){let{components:n,...t}=e;return(0,s.yg)(PEo,(0,p.A)({},zEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}IEo.isMDXComponent=!0;const REo={toc:[]},WEo="wrapper";function SEo(e){let{components:n,...t}=e;return(0,s.yg)(WEo,(0,p.A)({},REo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}SEo.isMDXComponent=!0;const BEo={toc:[]},GEo="wrapper";function EEo(e){let{components:n,...t}=e;return(0,s.yg)(GEo,(0,p.A)({},BEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}EEo.isMDXComponent=!0;const OEo={toc:[]},UEo="wrapper";function FEo(e){let{components:n,...t}=e;return(0,s.yg)(UEo,(0,p.A)({},OEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}FEo.isMDXComponent=!0;const VEo={toc:[]},qEo="wrapper";function jEo(e){let{components:n,...t}=e;return(0,s.yg)(qEo,(0,p.A)({},VEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jEo.isMDXComponent=!0;const HEo={toc:[]},YEo="wrapper";function QEo(e){let{components:n,...t}=e;return(0,s.yg)(YEo,(0,p.A)({},HEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}QEo.isMDXComponent=!0;const $Eo={toc:[]},KEo="wrapper";function JEo(e){let{components:n,...t}=e;return(0,s.yg)(KEo,(0,p.A)({},$Eo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JEo.isMDXComponent=!0;const ZEo={toc:[]},eOo="wrapper";function nOo(e){let{components:n,...t}=e;return(0,s.yg)(eOo,(0,p.A)({},ZEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}nOo.isMDXComponent=!0;const tOo={toc:[]},oOo="wrapper";function pOo(e){let{components:n,...t}=e;return(0,s.yg)(oOo,(0,p.A)({},tOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pOo.isMDXComponent=!0;const rOo={toc:[]},sOo="wrapper";function cOo(e){let{components:n,...t}=e;return(0,s.yg)(sOo,(0,p.A)({},rOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}cOo.isMDXComponent=!0;const aOo={toc:[]},iOo="wrapper";function lOo(e){let{components:n,...t}=e;return(0,s.yg)(iOo,(0,p.A)({},aOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}lOo.isMDXComponent=!0;const uOo={toc:[]},mOo="wrapper";function yOo(e){let{components:n,...t}=e;return(0,s.yg)(mOo,(0,p.A)({},uOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yOo.isMDXComponent=!0;const dOo={toc:[]},hOo="wrapper";function gOo(e){let{components:n,...t}=e;return(0,s.yg)(hOo,(0,p.A)({},dOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}gOo.isMDXComponent=!0;const fOo={toc:[]},DOo="wrapper";function MOo(e){let{components:n,...t}=e;return(0,s.yg)(DOo,(0,p.A)({},fOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}MOo.isMDXComponent=!0;const XOo={toc:[]},_Oo="wrapper";function wOo(e){let{components:n,...t}=e;return(0,s.yg)(_Oo,(0,p.A)({},XOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}wOo.isMDXComponent=!0;const TOo={toc:[]},COo="wrapper";function xOo(e){let{components:n,...t}=e;return(0,s.yg)(COo,(0,p.A)({},TOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}xOo.isMDXComponent=!0;const AOo={toc:[]},vOo="wrapper";function LOo(e){let{components:n,...t}=e;return(0,s.yg)(vOo,(0,p.A)({},AOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}LOo.isMDXComponent=!0;const bOo={toc:[]},NOo="wrapper";function kOo(e){let{components:n,...t}=e;return(0,s.yg)(NOo,(0,p.A)({},bOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}kOo.isMDXComponent=!0;const zOo={toc:[]},POo="wrapper";function IOo(e){let{components:n,...t}=e;return(0,s.yg)(POo,(0,p.A)({},zOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}IOo.isMDXComponent=!0;const ROo={toc:[]},WOo="wrapper";function SOo(e){let{components:n,...t}=e;return(0,s.yg)(WOo,(0,p.A)({},ROo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}SOo.isMDXComponent=!0;const BOo={toc:[]},GOo="wrapper";function EOo(e){let{components:n,...t}=e;return(0,s.yg)(GOo,(0,p.A)({},BOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}EOo.isMDXComponent=!0;const OOo={toc:[]},UOo="wrapper";function FOo(e){let{components:n,...t}=e;return(0,s.yg)(UOo,(0,p.A)({},OOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}FOo.isMDXComponent=!0;const VOo={toc:[]},qOo="wrapper";function jOo(e){let{components:n,...t}=e;return(0,s.yg)(qOo,(0,p.A)({},VOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}jOo.isMDXComponent=!0;const HOo={toc:[]},YOo="wrapper";function QOo(e){let{components:n,...t}=e;return(0,s.yg)(YOo,(0,p.A)({},HOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QOo.isMDXComponent=!0;const $Oo={toc:[]},KOo="wrapper";function JOo(e){let{components:n,...t}=e;return(0,s.yg)(KOo,(0,p.A)({},$Oo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}JOo.isMDXComponent=!0;const ZOo={toc:[]},eUo="wrapper";function nUo(e){let{components:n,...t}=e;return(0,s.yg)(eUo,(0,p.A)({},ZOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nUo.isMDXComponent=!0;const tUo={toc:[]},oUo="wrapper";function pUo(e){let{components:n,...t}=e;return(0,s.yg)(oUo,(0,p.A)({},tUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pUo.isMDXComponent=!0;const rUo={toc:[]},sUo="wrapper";function cUo(e){let{components:n,...t}=e;return(0,s.yg)(sUo,(0,p.A)({},rUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}cUo.isMDXComponent=!0;const aUo={toc:[]},iUo="wrapper";function lUo(e){let{components:n,...t}=e;return(0,s.yg)(iUo,(0,p.A)({},aUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lUo.isMDXComponent=!0;const uUo={toc:[]},mUo="wrapper";function yUo(e){let{components:n,...t}=e;return(0,s.yg)(mUo,(0,p.A)({},uUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}yUo.isMDXComponent=!0;const dUo={toc:[]},hUo="wrapper";function gUo(e){let{components:n,...t}=e;return(0,s.yg)(hUo,(0,p.A)({},dUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}gUo.isMDXComponent=!0;const fUo={toc:[]},DUo="wrapper";function MUo(e){let{components:n,...t}=e;return(0,s.yg)(DUo,(0,p.A)({},fUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MUo.isMDXComponent=!0;const XUo={toc:[]},_Uo="wrapper";function wUo(e){let{components:n,...t}=e;return(0,s.yg)(_Uo,(0,p.A)({},XUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}wUo.isMDXComponent=!0;const TUo={toc:[]},CUo="wrapper";function xUo(e){let{components:n,...t}=e;return(0,s.yg)(CUo,(0,p.A)({},TUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}xUo.isMDXComponent=!0;const AUo={toc:[]},vUo="wrapper";function LUo(e){let{components:n,...t}=e;return(0,s.yg)(vUo,(0,p.A)({},AUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}LUo.isMDXComponent=!0;const bUo={toc:[]},NUo="wrapper";function kUo(e){let{components:n,...t}=e;return(0,s.yg)(NUo,(0,p.A)({},bUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kUo.isMDXComponent=!0;const zUo={toc:[]},PUo="wrapper";function IUo(e){let{components:n,...t}=e;return(0,s.yg)(PUo,(0,p.A)({},zUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}IUo.isMDXComponent=!0;const RUo={toc:[]},WUo="wrapper";function SUo(e){let{components:n,...t}=e;return(0,s.yg)(WUo,(0,p.A)({},RUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}SUo.isMDXComponent=!0;const BUo={toc:[]},GUo="wrapper";function EUo(e){let{components:n,...t}=e;return(0,s.yg)(GUo,(0,p.A)({},BUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}EUo.isMDXComponent=!0;const OUo={toc:[]},UUo="wrapper";function FUo(e){let{components:n,...t}=e;return(0,s.yg)(UUo,(0,p.A)({},OUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}FUo.isMDXComponent=!0;const VUo={toc:[]},qUo="wrapper";function jUo(e){let{components:n,...t}=e;return(0,s.yg)(qUo,(0,p.A)({},VUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}jUo.isMDXComponent=!0;const HUo={toc:[]},YUo="wrapper";function QUo(e){let{components:n,...t}=e;return(0,s.yg)(YUo,(0,p.A)({},HUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}QUo.isMDXComponent=!0;const $Uo={toc:[]},KUo="wrapper";function JUo(e){let{components:n,...t}=e;return(0,s.yg)(KUo,(0,p.A)({},$Uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}JUo.isMDXComponent=!0;const ZUo={toc:[]},eFo="wrapper";function nFo(e){let{components:n,...t}=e;return(0,s.yg)(eFo,(0,p.A)({},ZUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nFo.isMDXComponent=!0;const tFo={toc:[]},oFo="wrapper";function pFo(e){let{components:n,...t}=e;return(0,s.yg)(oFo,(0,p.A)({},tFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}pFo.isMDXComponent=!0;const rFo={toc:[]},sFo="wrapper";function cFo(e){let{components:n,...t}=e;return(0,s.yg)(sFo,(0,p.A)({},rFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}cFo.isMDXComponent=!0;const aFo={toc:[]},iFo="wrapper";function lFo(e){let{components:n,...t}=e;return(0,s.yg)(iFo,(0,p.A)({},aFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}lFo.isMDXComponent=!0;const uFo={toc:[]},mFo="wrapper";function yFo(e){let{components:n,...t}=e;return(0,s.yg)(mFo,(0,p.A)({},uFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}yFo.isMDXComponent=!0;const dFo={toc:[]},hFo="wrapper";function gFo(e){let{components:n,...t}=e;return(0,s.yg)(hFo,(0,p.A)({},dFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gFo.isMDXComponent=!0;const fFo={toc:[]},DFo="wrapper";function MFo(e){let{components:n,...t}=e;return(0,s.yg)(DFo,(0,p.A)({},fFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}MFo.isMDXComponent=!0;const XFo={toc:[]},_Fo="wrapper";function wFo(e){let{components:n,...t}=e;return(0,s.yg)(_Fo,(0,p.A)({},XFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wFo.isMDXComponent=!0;const TFo={toc:[]},CFo="wrapper";function xFo(e){let{components:n,...t}=e;return(0,s.yg)(CFo,(0,p.A)({},TFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}xFo.isMDXComponent=!0;const AFo={toc:[]},vFo="wrapper";function LFo(e){let{components:n,...t}=e;return(0,s.yg)(vFo,(0,p.A)({},AFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}LFo.isMDXComponent=!0;const bFo={toc:[]},NFo="wrapper";function kFo(e){let{components:n,...t}=e;return(0,s.yg)(NFo,(0,p.A)({},bFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}kFo.isMDXComponent=!0;const zFo={toc:[]},PFo="wrapper";function IFo(e){let{components:n,...t}=e;return(0,s.yg)(PFo,(0,p.A)({},zFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}IFo.isMDXComponent=!0;const RFo={toc:[]},WFo="wrapper";function SFo(e){let{components:n,...t}=e;return(0,s.yg)(WFo,(0,p.A)({},RFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}SFo.isMDXComponent=!0;const BFo={toc:[]},GFo="wrapper";function EFo(e){let{components:n,...t}=e;return(0,s.yg)(GFo,(0,p.A)({},BFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}EFo.isMDXComponent=!0;const OFo={toc:[]},UFo="wrapper";function FFo(e){let{components:n,...t}=e;return(0,s.yg)(UFo,(0,p.A)({},OFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}FFo.isMDXComponent=!0;const VFo={toc:[]},qFo="wrapper";function jFo(e){let{components:n,...t}=e;return(0,s.yg)(qFo,(0,p.A)({},VFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}jFo.isMDXComponent=!0;const HFo={toc:[]},YFo="wrapper";function QFo(e){let{components:n,...t}=e;return(0,s.yg)(YFo,(0,p.A)({},HFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}QFo.isMDXComponent=!0;const $Fo={toc:[]},KFo="wrapper";function JFo(e){let{components:n,...t}=e;return(0,s.yg)(KFo,(0,p.A)({},$Fo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}JFo.isMDXComponent=!0;const ZFo={toc:[]},eVo="wrapper";function nVo(e){let{components:n,...t}=e;return(0,s.yg)(eVo,(0,p.A)({},ZFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}nVo.isMDXComponent=!0;const tVo={toc:[]},oVo="wrapper";function pVo(e){let{components:n,...t}=e;return(0,s.yg)(oVo,(0,p.A)({},tVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}pVo.isMDXComponent=!0;const rVo={toc:[]},sVo="wrapper";function cVo(e){let{components:n,...t}=e;return(0,s.yg)(sVo,(0,p.A)({},rVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}cVo.isMDXComponent=!0;const aVo={toc:[]},iVo="wrapper";function lVo(e){let{components:n,...t}=e;return(0,s.yg)(iVo,(0,p.A)({},aVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}lVo.isMDXComponent=!0;const uVo={toc:[]},mVo="wrapper";function yVo(e){let{components:n,...t}=e;return(0,s.yg)(mVo,(0,p.A)({},uVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}yVo.isMDXComponent=!0;const dVo={toc:[]},hVo="wrapper";function gVo(e){let{components:n,...t}=e;return(0,s.yg)(hVo,(0,p.A)({},dVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}gVo.isMDXComponent=!0;const fVo={toc:[]},DVo="wrapper";function MVo(e){let{components:n,...t}=e;return(0,s.yg)(DVo,(0,p.A)({},fVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}MVo.isMDXComponent=!0;const XVo={toc:[]},_Vo="wrapper";function wVo(e){let{components:n,...t}=e;return(0,s.yg)(_Vo,(0,p.A)({},XVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wVo.isMDXComponent=!0;const TVo={toc:[]},CVo="wrapper";function xVo(e){let{components:n,...t}=e;return(0,s.yg)(CVo,(0,p.A)({},TVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}xVo.isMDXComponent=!0;const AVo={toc:[]},vVo="wrapper";function LVo(e){let{components:n,...t}=e;return(0,s.yg)(vVo,(0,p.A)({},AVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}LVo.isMDXComponent=!0;const bVo={toc:[]},NVo="wrapper";function kVo(e){let{components:n,...t}=e;return(0,s.yg)(NVo,(0,p.A)({},bVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kVo.isMDXComponent=!0;const zVo={toc:[]},PVo="wrapper";function IVo(e){let{components:n,...t}=e;return(0,s.yg)(PVo,(0,p.A)({},zVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}IVo.isMDXComponent=!0;const RVo={toc:[]},WVo="wrapper";function SVo(e){let{components:n,...t}=e;return(0,s.yg)(WVo,(0,p.A)({},RVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}SVo.isMDXComponent=!0;const BVo={toc:[]},GVo="wrapper";function EVo(e){let{components:n,...t}=e;return(0,s.yg)(GVo,(0,p.A)({},BVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}EVo.isMDXComponent=!0;const OVo={toc:[]},UVo="wrapper";function FVo(e){let{components:n,...t}=e;return(0,s.yg)(UVo,(0,p.A)({},OVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}FVo.isMDXComponent=!0;const VVo={toc:[]},qVo="wrapper";function jVo(e){let{components:n,...t}=e;return(0,s.yg)(qVo,(0,p.A)({},VVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}jVo.isMDXComponent=!0;const HVo={toc:[]},YVo="wrapper";function QVo(e){let{components:n,...t}=e;return(0,s.yg)(YVo,(0,p.A)({},HVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}QVo.isMDXComponent=!0;const $Vo={toc:[]},KVo="wrapper";function JVo(e){let{components:n,...t}=e;return(0,s.yg)(KVo,(0,p.A)({},$Vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}JVo.isMDXComponent=!0;const ZVo={toc:[]},eqo="wrapper";function nqo(e){let{components:n,...t}=e;return(0,s.yg)(eqo,(0,p.A)({},ZVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}nqo.isMDXComponent=!0;const tqo={toc:[]},oqo="wrapper";function pqo(e){let{components:n,...t}=e;return(0,s.yg)(oqo,(0,p.A)({},tqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}pqo.isMDXComponent=!0;const rqo={toc:[]},sqo="wrapper";function cqo(e){let{components:n,...t}=e;return(0,s.yg)(sqo,(0,p.A)({},rqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}cqo.isMDXComponent=!0;const aqo={toc:[]},iqo="wrapper";function lqo(e){let{components:n,...t}=e;return(0,s.yg)(iqo,(0,p.A)({},aqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}lqo.isMDXComponent=!0;const uqo={toc:[]},mqo="wrapper";function yqo(e){let{components:n,...t}=e;return(0,s.yg)(mqo,(0,p.A)({},uqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}yqo.isMDXComponent=!0;const dqo={toc:[]},hqo="wrapper";function gqo(e){let{components:n,...t}=e;return(0,s.yg)(hqo,(0,p.A)({},dqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gqo.isMDXComponent=!0;const fqo={toc:[]},Dqo="wrapper";function Mqo(e){let{components:n,...t}=e;return(0,s.yg)(Dqo,(0,p.A)({},fqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Mqo.isMDXComponent=!0;const Xqo={toc:[]},_qo="wrapper";function wqo(e){let{components:n,...t}=e;return(0,s.yg)(_qo,(0,p.A)({},Xqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}wqo.isMDXComponent=!0;const Tqo={toc:[]},Cqo="wrapper";function xqo(e){let{components:n,...t}=e;return(0,s.yg)(Cqo,(0,p.A)({},Tqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xqo.isMDXComponent=!0;const Aqo={toc:[]},vqo="wrapper";function Lqo(e){let{components:n,...t}=e;return(0,s.yg)(vqo,(0,p.A)({},Aqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Lqo.isMDXComponent=!0;const bqo={toc:[]},Nqo="wrapper";function kqo(e){let{components:n,...t}=e;return(0,s.yg)(Nqo,(0,p.A)({},bqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}kqo.isMDXComponent=!0;const zqo={toc:[]},Pqo="wrapper";function Iqo(e){let{components:n,...t}=e;return(0,s.yg)(Pqo,(0,p.A)({},zqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Iqo.isMDXComponent=!0;const Rqo={toc:[]},Wqo="wrapper";function Sqo(e){let{components:n,...t}=e;return(0,s.yg)(Wqo,(0,p.A)({},Rqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Sqo.isMDXComponent=!0;const Bqo={toc:[]},Gqo="wrapper";function Eqo(e){let{components:n,...t}=e;return(0,s.yg)(Gqo,(0,p.A)({},Bqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Eqo.isMDXComponent=!0;const Oqo={toc:[]},Uqo="wrapper";function Fqo(e){let{components:n,...t}=e;return(0,s.yg)(Uqo,(0,p.A)({},Oqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Fqo.isMDXComponent=!0;const Vqo={toc:[]},qqo="wrapper";function jqo(e){let{components:n,...t}=e;return(0,s.yg)(qqo,(0,p.A)({},Vqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}jqo.isMDXComponent=!0;const Hqo={toc:[]},Yqo="wrapper";function Qqo(e){let{components:n,...t}=e;return(0,s.yg)(Yqo,(0,p.A)({},Hqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Qqo.isMDXComponent=!0;const $qo={toc:[]},Kqo="wrapper";function Jqo(e){let{components:n,...t}=e;return(0,s.yg)(Kqo,(0,p.A)({},$qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Jqo.isMDXComponent=!0;const Zqo={toc:[]},ejo="wrapper";function njo(e){let{components:n,...t}=e;return(0,s.yg)(ejo,(0,p.A)({},Zqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}njo.isMDXComponent=!0;const tjo={toc:[]},ojo="wrapper";function pjo(e){let{components:n,...t}=e;return(0,s.yg)(ojo,(0,p.A)({},tjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}pjo.isMDXComponent=!0;const rjo={toc:[]},sjo="wrapper";function cjo(e){let{components:n,...t}=e;return(0,s.yg)(sjo,(0,p.A)({},rjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}cjo.isMDXComponent=!0;const ajo={toc:[]},ijo="wrapper";function ljo(e){let{components:n,...t}=e;return(0,s.yg)(ijo,(0,p.A)({},ajo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}ljo.isMDXComponent=!0;const ujo={toc:[]},mjo="wrapper";function yjo(e){let{components:n,...t}=e;return(0,s.yg)(mjo,(0,p.A)({},ujo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defining knots using the ",(0,s.yg)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.yg)("p",null,"Defining knots with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.yg)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}yjo.isMDXComponent=!0;const djo={toc:[]},hjo="wrapper";function gjo(e){let{components:n,...t}=e;return(0,s.yg)(hjo,(0,p.A)({},djo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a smooth line through a number of points."))}gjo.isMDXComponent=!0;const fjo={toc:[]},Djo="wrapper";function Mjo(e){let{components:n,...t}=e;return(0,s.yg)(Djo,(0,p.A)({},fjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Mjo.isMDXComponent=!0;const Xjo={toc:[]},_jo="wrapper";function wjo(e){let{components:n,...t}=e;return(0,s.yg)(_jo,(0,p.A)({},Xjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}wjo.isMDXComponent=!0;const Tjo={toc:[]},Cjo="wrapper";function xjo(e){let{components:n,...t}=e;return(0,s.yg)(Cjo,(0,p.A)({},Tjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xjo.isMDXComponent=!0;const Ajo={toc:[]},vjo="wrapper";function Ljo(e){let{components:n,...t}=e;return(0,s.yg)(vjo,(0,p.A)({},Ajo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Ljo.isMDXComponent=!0;const bjo={toc:[]},Njo="wrapper";function kjo(e){let{components:n,...t}=e;return(0,s.yg)(Njo,(0,p.A)({},bjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}kjo.isMDXComponent=!0;const zjo={toc:[]},Pjo="wrapper";function Ijo(e){let{components:n,...t}=e;return(0,s.yg)(Pjo,(0,p.A)({},zjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Ijo.isMDXComponent=!0;const Rjo={toc:[]},Wjo="wrapper";function Sjo(e){let{components:n,...t}=e;return(0,s.yg)(Wjo,(0,p.A)({},Rjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Sjo.isMDXComponent=!0;const Bjo={toc:[]},Gjo="wrapper";function Ejo(e){let{components:n,...t}=e;return(0,s.yg)(Gjo,(0,p.A)({},Bjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Ejo.isMDXComponent=!0;const Ojo={toc:[]},Ujo="wrapper";function Fjo(e){let{components:n,...t}=e;return(0,s.yg)(Ujo,(0,p.A)({},Ojo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Fjo.isMDXComponent=!0;const Vjo={toc:[]},qjo="wrapper";function jjo(e){let{components:n,...t}=e;return(0,s.yg)(qjo,(0,p.A)({},Vjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}jjo.isMDXComponent=!0;const Hjo={toc:[]},Yjo="wrapper";function Qjo(e){let{components:n,...t}=e;return(0,s.yg)(Yjo,(0,p.A)({},Hjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Qjo.isMDXComponent=!0;const $jo={toc:[]},Kjo="wrapper";function Jjo(e){let{components:n,...t}=e;return(0,s.yg)(Kjo,(0,p.A)({},$jo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Jjo.isMDXComponent=!0;const Zjo={toc:[]},eHo="wrapper";function nHo(e){let{components:n,...t}=e;return(0,s.yg)(eHo,(0,p.A)({},Zjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}nHo.isMDXComponent=!0;const tHo={toc:[]},oHo="wrapper";function pHo(e){let{components:n,...t}=e;return(0,s.yg)(oHo,(0,p.A)({},tHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}pHo.isMDXComponent=!0;const rHo={toc:[]},sHo="wrapper";function cHo(e){let{components:n,...t}=e;return(0,s.yg)(sHo,(0,p.A)({},rHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cHo.isMDXComponent=!0;const aHo={toc:[]},iHo="wrapper";function lHo(e){let{components:n,...t}=e;return(0,s.yg)(iHo,(0,p.A)({},aHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lHo.isMDXComponent=!0;const uHo={toc:[]},mHo="wrapper";function yHo(e){let{components:n,...t}=e;return(0,s.yg)(mHo,(0,p.A)({},uHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}yHo.isMDXComponent=!0;const dHo={toc:[]},hHo="wrapper";function gHo(e){let{components:n,...t}=e;return(0,s.yg)(hHo,(0,p.A)({},dHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}gHo.isMDXComponent=!0;const fHo={toc:[]},DHo="wrapper";function MHo(e){let{components:n,...t}=e;return(0,s.yg)(DHo,(0,p.A)({},fHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}MHo.isMDXComponent=!0;const XHo={toc:[]},_Ho="wrapper";function wHo(e){let{components:n,...t}=e;return(0,s.yg)(_Ho,(0,p.A)({},XHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}wHo.isMDXComponent=!0;const THo={toc:[]},CHo="wrapper";function xHo(e){let{components:n,...t}=e;return(0,s.yg)(CHo,(0,p.A)({},THo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xHo.isMDXComponent=!0;const AHo={toc:[]},vHo="wrapper";function LHo(e){let{components:n,...t}=e;return(0,s.yg)(vHo,(0,p.A)({},AHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}LHo.isMDXComponent=!0;const bHo={toc:[]},NHo="wrapper";function kHo(e){let{components:n,...t}=e;return(0,s.yg)(NHo,(0,p.A)({},bHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kHo.isMDXComponent=!0;const zHo={toc:[]},PHo="wrapper";function IHo(e){let{components:n,...t}=e;return(0,s.yg)(PHo,(0,p.A)({},zHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}IHo.isMDXComponent=!0;const RHo={toc:[]},WHo="wrapper";function SHo(e){let{components:n,...t}=e;return(0,s.yg)(WHo,(0,p.A)({},RHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}SHo.isMDXComponent=!0;const BHo={toc:[]},GHo="wrapper";function EHo(e){let{components:n,...t}=e;return(0,s.yg)(GHo,(0,p.A)({},BHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}EHo.isMDXComponent=!0;const OHo={toc:[]},UHo="wrapper";function FHo(e){let{components:n,...t}=e;return(0,s.yg)(UHo,(0,p.A)({},OHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}FHo.isMDXComponent=!0;const VHo={toc:[]},qHo="wrapper";function jHo(e){let{components:n,...t}=e;return(0,s.yg)(qHo,(0,p.A)({},VHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}jHo.isMDXComponent=!0;const HHo={toc:[]},YHo="wrapper";function QHo(e){let{components:n,...t}=e;return(0,s.yg)(YHo,(0,p.A)({},HHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}QHo.isMDXComponent=!0;const $Ho={toc:[]},KHo="wrapper";function JHo(e){let{components:n,...t}=e;return(0,s.yg)(KHo,(0,p.A)({},$Ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}JHo.isMDXComponent=!0;const ZHo={toc:[]},eYo="wrapper";function nYo(e){let{components:n,...t}=e;return(0,s.yg)(eYo,(0,p.A)({},ZHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}nYo.isMDXComponent=!0;const tYo={toc:[]},oYo="wrapper";function pYo(e){let{components:n,...t}=e;return(0,s.yg)(oYo,(0,p.A)({},tYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}pYo.isMDXComponent=!0;const rYo={toc:[]},sYo="wrapper";function cYo(e){let{components:n,...t}=e;return(0,s.yg)(sYo,(0,p.A)({},rYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."))}cYo.isMDXComponent=!0;const aYo={toc:[]},iYo="wrapper";function lYo(e){let{components:n,...t}=e;return(0,s.yg)(iYo,(0,p.A)({},aYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}lYo.isMDXComponent=!0;const uYo={toc:[]},mYo="wrapper";function yYo(e){let{components:n,...t}=e;return(0,s.yg)(mYo,(0,p.A)({},uYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}yYo.isMDXComponent=!0;const dYo={toc:[]},hYo="wrapper";function gYo(e){let{components:n,...t}=e;return(0,s.yg)(hYo,(0,p.A)({},dYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}gYo.isMDXComponent=!0;const fYo={toc:[]},DYo="wrapper";function MYo(e){let{components:n,...t}=e;return(0,s.yg)(DYo,(0,p.A)({},fYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}MYo.isMDXComponent=!0;const XYo={toc:[]},_Yo="wrapper";function wYo(e){let{components:n,...t}=e;return(0,s.yg)(_Yo,(0,p.A)({},XYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}wYo.isMDXComponent=!0;const TYo={toc:[]},CYo="wrapper";function xYo(e){let{components:n,...t}=e;return(0,s.yg)(CYo,(0,p.A)({},TYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xYo.isMDXComponent=!0;const AYo={toc:[]},vYo="wrapper";function LYo(e){let{components:n,...t}=e;return(0,s.yg)(vYo,(0,p.A)({},AYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LYo.isMDXComponent=!0;const bYo={toc:[]},NYo="wrapper";function kYo(e){let{components:n,...t}=e;return(0,s.yg)(NYo,(0,p.A)({},bYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}kYo.isMDXComponent=!0;const zYo={toc:[]},PYo="wrapper";function IYo(e){let{components:n,...t}=e;return(0,s.yg)(PYo,(0,p.A)({},zYo,t,{components:n,mdxType:"MDXLayout"}))}IYo.isMDXComponent=!0;const RYo={toc:[]},WYo="wrapper";function SYo(e){let{components:n,...t}=e;return(0,s.yg)(WYo,(0,p.A)({},RYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}SYo.isMDXComponent=!0;const BYo={toc:[]},GYo="wrapper";function EYo(e){let{components:n,...t}=e;return(0,s.yg)(GYo,(0,p.A)({},BYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}EYo.isMDXComponent=!0;const OYo={toc:[]},UYo="wrapper";function FYo(e){let{components:n,...t}=e;return(0,s.yg)(UYo,(0,p.A)({},OYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}FYo.isMDXComponent=!0;const VYo={toc:[]},qYo="wrapper";function jYo(e){let{components:n,...t}=e;return(0,s.yg)(qYo,(0,p.A)({},VYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}jYo.isMDXComponent=!0;const HYo={toc:[]},YYo="wrapper";function QYo(e){let{components:n,...t}=e;return(0,s.yg)(YYo,(0,p.A)({},HYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}QYo.isMDXComponent=!0;const $Yo={toc:[]},KYo="wrapper";function JYo(e){let{components:n,...t}=e;return(0,s.yg)(KYo,(0,p.A)({},$Yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property is only applied to knots that don't use explicit handles."))}JYo.isMDXComponent=!0;const ZYo={toc:[]},eQo="wrapper";function nQo(e){let{components:n,...t}=e;return(0,s.yg)(eQo,(0,p.A)({},ZYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0.4"))}nQo.isMDXComponent=!0;const tQo={toc:[]},oQo="wrapper";function pQo(e){let{components:n,...t}=e;return(0,s.yg)(oQo,(0,p.A)({},tQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The smoothness of the spline when using auto-calculated handles."))}pQo.isMDXComponent=!0;const rQo={toc:[]},sQo="wrapper";function cQo(e){let{components:n,...t}=e;return(0,s.yg)(sQo,(0,p.A)({},rQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}cQo.isMDXComponent=!0;const aQo={toc:[]},iQo="wrapper";function lQo(e){let{components:n,...t}=e;return(0,s.yg)(iQo,(0,p.A)({},aQo,t,{components:n,mdxType:"MDXLayout"}))}lQo.isMDXComponent=!0;const uQo={toc:[]},mQo="wrapper";function yQo(e){let{components:n,...t}=e;return(0,s.yg)(mQo,(0,p.A)({},uQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}yQo.isMDXComponent=!0;const dQo={toc:[]},hQo="wrapper";function gQo(e){let{components:n,...t}=e;return(0,s.yg)(hQo,(0,p.A)({},dQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}gQo.isMDXComponent=!0;const fQo={toc:[]},DQo="wrapper";function MQo(e){let{components:n,...t}=e;return(0,s.yg)(DQo,(0,p.A)({},fQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MQo.isMDXComponent=!0;const XQo={toc:[]},_Qo="wrapper";function wQo(e){let{components:n,...t}=e;return(0,s.yg)(_Qo,(0,p.A)({},XQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}wQo.isMDXComponent=!0;const TQo={toc:[]},CQo="wrapper";function xQo(e){let{components:n,...t}=e;return(0,s.yg)(CQo,(0,p.A)({},TQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xQo.isMDXComponent=!0;const AQo={toc:[]},vQo="wrapper";function LQo(e){let{components:n,...t}=e;return(0,s.yg)(vQo,(0,p.A)({},AQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}LQo.isMDXComponent=!0;const bQo={toc:[]},NQo="wrapper";function kQo(e){let{components:n,...t}=e;return(0,s.yg)(NQo,(0,p.A)({},bQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kQo.isMDXComponent=!0;const zQo={toc:[]},PQo="wrapper";function IQo(e){let{components:n,...t}=e;return(0,s.yg)(PQo,(0,p.A)({},zQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}IQo.isMDXComponent=!0;const RQo={toc:[]},WQo="wrapper";function SQo(e){let{components:n,...t}=e;return(0,s.yg)(WQo,(0,p.A)({},RQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}SQo.isMDXComponent=!0;const BQo={toc:[]},GQo="wrapper";function EQo(e){let{components:n,...t}=e;return(0,s.yg)(GQo,(0,p.A)({},BQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}EQo.isMDXComponent=!0;const OQo={toc:[]},UQo="wrapper";function FQo(e){let{components:n,...t}=e;return(0,s.yg)(UQo,(0,p.A)({},OQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}FQo.isMDXComponent=!0;const VQo={toc:[]},qQo="wrapper";function jQo(e){let{components:n,...t}=e;return(0,s.yg)(qQo,(0,p.A)({},VQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}jQo.isMDXComponent=!0;const HQo={toc:[]},YQo="wrapper";function QQo(e){let{components:n,...t}=e;return(0,s.yg)(YQo,(0,p.A)({},HQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}QQo.isMDXComponent=!0;const $Qo={toc:[]},KQo="wrapper";function JQo(e){let{components:n,...t}=e;return(0,s.yg)(KQo,(0,p.A)({},$Qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}JQo.isMDXComponent=!0;const ZQo={toc:[]},e$o="wrapper";function n$o(e){let{components:n,...t}=e;return(0,s.yg)(e$o,(0,p.A)({},ZQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}n$o.isMDXComponent=!0;const t$o={toc:[]},o$o="wrapper";function p$o(e){let{components:n,...t}=e;return(0,s.yg)(o$o,(0,p.A)({},t$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}p$o.isMDXComponent=!0;const r$o={toc:[]},s$o="wrapper";function c$o(e){let{components:n,...t}=e;return(0,s.yg)(s$o,(0,p.A)({},r$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}c$o.isMDXComponent=!0;const a$o={toc:[]},i$o="wrapper";function l$o(e){let{components:n,...t}=e;return(0,s.yg)(i$o,(0,p.A)({},a$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}l$o.isMDXComponent=!0;const u$o={toc:[]},m$o="wrapper";function y$o(e){let{components:n,...t}=e;return(0,s.yg)(m$o,(0,p.A)({},u$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}y$o.isMDXComponent=!0;const d$o={toc:[]},h$o="wrapper";function g$o(e){let{components:n,...t}=e;return(0,s.yg)(h$o,(0,p.A)({},d$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}g$o.isMDXComponent=!0;const f$o={toc:[]},D$o="wrapper";function M$o(e){let{components:n,...t}=e;return(0,s.yg)(D$o,(0,p.A)({},f$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}M$o.isMDXComponent=!0;const X$o={toc:[]},_$o="wrapper";function w$o(e){let{components:n,...t}=e;return(0,s.yg)(_$o,(0,p.A)({},X$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}w$o.isMDXComponent=!0;const T$o={toc:[]},C$o="wrapper";function x$o(e){let{components:n,...t}=e;return(0,s.yg)(C$o,(0,p.A)({},T$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}x$o.isMDXComponent=!0;const A$o={toc:[]},v$o="wrapper";function L$o(e){let{components:n,...t}=e;return(0,s.yg)(v$o,(0,p.A)({},A$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}L$o.isMDXComponent=!0;const b$o={toc:[]},N$o="wrapper";function k$o(e){let{components:n,...t}=e;return(0,s.yg)(N$o,(0,p.A)({},b$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}k$o.isMDXComponent=!0;const z$o={toc:[]},P$o="wrapper";function I$o(e){let{components:n,...t}=e;return(0,s.yg)(P$o,(0,p.A)({},z$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}I$o.isMDXComponent=!0;const R$o={toc:[]},W$o="wrapper";function S$o(e){let{components:n,...t}=e;return(0,s.yg)(W$o,(0,p.A)({},R$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}S$o.isMDXComponent=!0;const B$o={toc:[]},G$o="wrapper";function E$o(e){let{components:n,...t}=e;return(0,s.yg)(G$o,(0,p.A)({},B$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}E$o.isMDXComponent=!0;const O$o={toc:[]},U$o="wrapper";function F$o(e){let{components:n,...t}=e;return(0,s.yg)(U$o,(0,p.A)({},O$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}F$o.isMDXComponent=!0;const V$o={toc:[]},q$o="wrapper";function j$o(e){let{components:n,...t}=e;return(0,s.yg)(q$o,(0,p.A)({},V$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}j$o.isMDXComponent=!0;const H$o={toc:[]},Y$o="wrapper";function Q$o(e){let{components:n,...t}=e;return(0,s.yg)(Y$o,(0,p.A)({},H$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Q$o.isMDXComponent=!0;const $$o={toc:[]},K$o="wrapper";function J$o(e){let{components:n,...t}=e;return(0,s.yg)(K$o,(0,p.A)({},$$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}J$o.isMDXComponent=!0;const Z$o={toc:[]},eKo="wrapper";function nKo(e){let{components:n,...t}=e;return(0,s.yg)(eKo,(0,p.A)({},Z$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}nKo.isMDXComponent=!0;const tKo={toc:[]},oKo="wrapper";function pKo(e){let{components:n,...t}=e;return(0,s.yg)(oKo,(0,p.A)({},tKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}pKo.isMDXComponent=!0;const rKo={toc:[]},sKo="wrapper";function cKo(e){let{components:n,...t}=e;return(0,s.yg)(sKo,(0,p.A)({},rKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}cKo.isMDXComponent=!0;const aKo={toc:[]},iKo="wrapper";function lKo(e){let{components:n,...t}=e;return(0,s.yg)(iKo,(0,p.A)({},aKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}lKo.isMDXComponent=!0;const uKo={toc:[]},mKo="wrapper";function yKo(e){let{components:n,...t}=e;return(0,s.yg)(mKo,(0,p.A)({},uKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}yKo.isMDXComponent=!0;const dKo={toc:[]},hKo="wrapper";function gKo(e){let{components:n,...t}=e;return(0,s.yg)(hKo,(0,p.A)({},dKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}gKo.isMDXComponent=!0;const fKo={toc:[]},DKo="wrapper";function MKo(e){let{components:n,...t}=e;return(0,s.yg)(DKo,(0,p.A)({},fKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}MKo.isMDXComponent=!0;const XKo={toc:[]},_Ko="wrapper";function wKo(e){let{components:n,...t}=e;return(0,s.yg)(_Ko,(0,p.A)({},XKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}wKo.isMDXComponent=!0;const TKo={toc:[]},CKo="wrapper";function xKo(e){let{components:n,...t}=e;return(0,s.yg)(CKo,(0,p.A)({},TKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xKo.isMDXComponent=!0;const AKo={toc:[]},vKo="wrapper";function LKo(e){let{components:n,...t}=e;return(0,s.yg)(vKo,(0,p.A)({},AKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}LKo.isMDXComponent=!0;const bKo={toc:[]},NKo="wrapper";function kKo(e){let{components:n,...t}=e;return(0,s.yg)(NKo,(0,p.A)({},bKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}kKo.isMDXComponent=!0;const zKo={toc:[]},PKo="wrapper";function IKo(e){let{components:n,...t}=e;return(0,s.yg)(PKo,(0,p.A)({},zKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}IKo.isMDXComponent=!0;const RKo={toc:[]},WKo="wrapper";function SKo(e){let{components:n,...t}=e;return(0,s.yg)(WKo,(0,p.A)({},RKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}SKo.isMDXComponent=!0;const BKo={toc:[]},GKo="wrapper";function EKo(e){let{components:n,...t}=e;return(0,s.yg)(GKo,(0,p.A)({},BKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}EKo.isMDXComponent=!0;const OKo={toc:[]},UKo="wrapper";function FKo(e){let{components:n,...t}=e;return(0,s.yg)(UKo,(0,p.A)({},OKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}FKo.isMDXComponent=!0;const VKo={toc:[]},qKo="wrapper";function jKo(e){let{components:n,...t}=e;return(0,s.yg)(qKo,(0,p.A)({},VKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jKo.isMDXComponent=!0;const HKo={toc:[]},YKo="wrapper";function QKo(e){let{components:n,...t}=e;return(0,s.yg)(YKo,(0,p.A)({},HKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QKo.isMDXComponent=!0;const $Ko={toc:[]},KKo="wrapper";function JKo(e){let{components:n,...t}=e;return(0,s.yg)(KKo,(0,p.A)({},$Ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}JKo.isMDXComponent=!0;const ZKo={toc:[]},eJo="wrapper";function nJo(e){let{components:n,...t}=e;return(0,s.yg)(eJo,(0,p.A)({},ZKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}nJo.isMDXComponent=!0;const tJo={toc:[]},oJo="wrapper";function pJo(e){let{components:n,...t}=e;return(0,s.yg)(oJo,(0,p.A)({},tJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}pJo.isMDXComponent=!0;const rJo={toc:[]},sJo="wrapper";function cJo(e){let{components:n,...t}=e;return(0,s.yg)(sJo,(0,p.A)({},rJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}cJo.isMDXComponent=!0;const aJo={toc:[]},iJo="wrapper";function lJo(e){let{components:n,...t}=e;return(0,s.yg)(iJo,(0,p.A)({},aJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lJo.isMDXComponent=!0;const uJo={toc:[]},mJo="wrapper";function yJo(e){let{components:n,...t}=e;return(0,s.yg)(mJo,(0,p.A)({},uJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yJo.isMDXComponent=!0;const dJo={toc:[]},hJo="wrapper";function gJo(e){let{components:n,...t}=e;return(0,s.yg)(hJo,(0,p.A)({},dJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gJo.isMDXComponent=!0;const fJo={toc:[]},DJo="wrapper";function MJo(e){let{components:n,...t}=e;return(0,s.yg)(DJo,(0,p.A)({},fJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}MJo.isMDXComponent=!0;const XJo={toc:[]},_Jo="wrapper";function wJo(e){let{components:n,...t}=e;return(0,s.yg)(_Jo,(0,p.A)({},XJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wJo.isMDXComponent=!0;const TJo={toc:[]},CJo="wrapper";function xJo(e){let{components:n,...t}=e;return(0,s.yg)(CJo,(0,p.A)({},TJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xJo.isMDXComponent=!0;const AJo={toc:[]},vJo="wrapper";function LJo(e){let{components:n,...t}=e;return(0,s.yg)(vJo,(0,p.A)({},AJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LJo.isMDXComponent=!0;const bJo={toc:[]},NJo="wrapper";function kJo(e){let{components:n,...t}=e;return(0,s.yg)(NJo,(0,p.A)({},bJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}kJo.isMDXComponent=!0;const zJo={toc:[]},PJo="wrapper";function IJo(e){let{components:n,...t}=e;return(0,s.yg)(PJo,(0,p.A)({},zJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}IJo.isMDXComponent=!0;const RJo={toc:[]},WJo="wrapper";function SJo(e){let{components:n,...t}=e;return(0,s.yg)(WJo,(0,p.A)({},RJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}SJo.isMDXComponent=!0;const BJo={toc:[]},GJo="wrapper";function EJo(e){let{components:n,...t}=e;return(0,s.yg)(GJo,(0,p.A)({},BJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}EJo.isMDXComponent=!0;const OJo={toc:[]},UJo="wrapper";function FJo(e){let{components:n,...t}=e;return(0,s.yg)(UJo,(0,p.A)({},OJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}FJo.isMDXComponent=!0;const VJo={toc:[]},qJo="wrapper";function jJo(e){let{components:n,...t}=e;return(0,s.yg)(qJo,(0,p.A)({},VJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jJo.isMDXComponent=!0;const HJo={toc:[]},YJo="wrapper";function QJo(e){let{components:n,...t}=e;return(0,s.yg)(YJo,(0,p.A)({},HJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}QJo.isMDXComponent=!0;const $Jo={toc:[]},KJo="wrapper";function JJo(e){let{components:n,...t}=e;return(0,s.yg)(KJo,(0,p.A)({},$Jo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JJo.isMDXComponent=!0;const ZJo={toc:[]},eZo="wrapper";function nZo(e){let{components:n,...t}=e;return(0,s.yg)(eZo,(0,p.A)({},ZJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}nZo.isMDXComponent=!0;const tZo={toc:[]},oZo="wrapper";function pZo(e){let{components:n,...t}=e;return(0,s.yg)(oZo,(0,p.A)({},tZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pZo.isMDXComponent=!0;const rZo={toc:[]},sZo="wrapper";function cZo(e){let{components:n,...t}=e;return(0,s.yg)(sZo,(0,p.A)({},rZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}cZo.isMDXComponent=!0;const aZo={toc:[]},iZo="wrapper";function lZo(e){let{components:n,...t}=e;return(0,s.yg)(iZo,(0,p.A)({},aZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}lZo.isMDXComponent=!0;const uZo={toc:[]},mZo="wrapper";function yZo(e){let{components:n,...t}=e;return(0,s.yg)(mZo,(0,p.A)({},uZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yZo.isMDXComponent=!0;const dZo={toc:[]},hZo="wrapper";function gZo(e){let{components:n,...t}=e;return(0,s.yg)(hZo,(0,p.A)({},dZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}gZo.isMDXComponent=!0;const fZo={toc:[]},DZo="wrapper";function MZo(e){let{components:n,...t}=e;return(0,s.yg)(DZo,(0,p.A)({},fZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}MZo.isMDXComponent=!0;const XZo={toc:[]},_Zo="wrapper";function wZo(e){let{components:n,...t}=e;return(0,s.yg)(_Zo,(0,p.A)({},XZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}wZo.isMDXComponent=!0;const TZo={toc:[]},CZo="wrapper";function xZo(e){let{components:n,...t}=e;return(0,s.yg)(CZo,(0,p.A)({},TZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}xZo.isMDXComponent=!0;const AZo={toc:[]},vZo="wrapper";function LZo(e){let{components:n,...t}=e;return(0,s.yg)(vZo,(0,p.A)({},AZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}LZo.isMDXComponent=!0;const bZo={toc:[]},NZo="wrapper";function kZo(e){let{components:n,...t}=e;return(0,s.yg)(NZo,(0,p.A)({},bZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}kZo.isMDXComponent=!0;const zZo={toc:[]},PZo="wrapper";function IZo(e){let{components:n,...t}=e;return(0,s.yg)(PZo,(0,p.A)({},zZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}IZo.isMDXComponent=!0;const RZo={toc:[]},WZo="wrapper";function SZo(e){let{components:n,...t}=e;return(0,s.yg)(WZo,(0,p.A)({},RZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}SZo.isMDXComponent=!0;const BZo={toc:[]},GZo="wrapper";function EZo(e){let{components:n,...t}=e;return(0,s.yg)(GZo,(0,p.A)({},BZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}EZo.isMDXComponent=!0;const OZo={toc:[]},UZo="wrapper";function FZo(e){let{components:n,...t}=e;return(0,s.yg)(UZo,(0,p.A)({},OZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}FZo.isMDXComponent=!0;const VZo={toc:[]},qZo="wrapper";function jZo(e){let{components:n,...t}=e;return(0,s.yg)(qZo,(0,p.A)({},VZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}jZo.isMDXComponent=!0;const HZo={toc:[]},YZo="wrapper";function QZo(e){let{components:n,...t}=e;return(0,s.yg)(YZo,(0,p.A)({},HZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QZo.isMDXComponent=!0;const $Zo={toc:[]},KZo="wrapper";function JZo(e){let{components:n,...t}=e;return(0,s.yg)(KZo,(0,p.A)({},$Zo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}JZo.isMDXComponent=!0;const ZZo={toc:[]},e0o="wrapper";function n0o(e){let{components:n,...t}=e;return(0,s.yg)(e0o,(0,p.A)({},ZZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}n0o.isMDXComponent=!0;const t0o={toc:[]},o0o="wrapper";function p0o(e){let{components:n,...t}=e;return(0,s.yg)(o0o,(0,p.A)({},t0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}p0o.isMDXComponent=!0;const r0o={toc:[]},s0o="wrapper";function c0o(e){let{components:n,...t}=e;return(0,s.yg)(s0o,(0,p.A)({},r0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}c0o.isMDXComponent=!0;const a0o={toc:[]},i0o="wrapper";function l0o(e){let{components:n,...t}=e;return(0,s.yg)(i0o,(0,p.A)({},a0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}l0o.isMDXComponent=!0;const u0o={toc:[]},m0o="wrapper";function y0o(e){let{components:n,...t}=e;return(0,s.yg)(m0o,(0,p.A)({},u0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}y0o.isMDXComponent=!0;const d0o={toc:[]},h0o="wrapper";function g0o(e){let{components:n,...t}=e;return(0,s.yg)(h0o,(0,p.A)({},d0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}g0o.isMDXComponent=!0;const f0o={toc:[]},D0o="wrapper";function M0o(e){let{components:n,...t}=e;return(0,s.yg)(D0o,(0,p.A)({},f0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}M0o.isMDXComponent=!0;const X0o={toc:[]},_0o="wrapper";function w0o(e){let{components:n,...t}=e;return(0,s.yg)(_0o,(0,p.A)({},X0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}w0o.isMDXComponent=!0;const T0o={toc:[]},C0o="wrapper";function x0o(e){let{components:n,...t}=e;return(0,s.yg)(C0o,(0,p.A)({},T0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}x0o.isMDXComponent=!0;const A0o={toc:[]},v0o="wrapper";function L0o(e){let{components:n,...t}=e;return(0,s.yg)(v0o,(0,p.A)({},A0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}L0o.isMDXComponent=!0;const b0o={toc:[]},N0o="wrapper";function k0o(e){let{components:n,...t}=e;return(0,s.yg)(N0o,(0,p.A)({},b0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}k0o.isMDXComponent=!0;const z0o={toc:[]},P0o="wrapper";function I0o(e){let{components:n,...t}=e;return(0,s.yg)(P0o,(0,p.A)({},z0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}I0o.isMDXComponent=!0;const R0o={toc:[]},W0o="wrapper";function S0o(e){let{components:n,...t}=e;return(0,s.yg)(W0o,(0,p.A)({},R0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}S0o.isMDXComponent=!0;const B0o={toc:[]},G0o="wrapper";function E0o(e){let{components:n,...t}=e;return(0,s.yg)(G0o,(0,p.A)({},B0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}E0o.isMDXComponent=!0;const O0o={toc:[]},U0o="wrapper";function F0o(e){let{components:n,...t}=e;return(0,s.yg)(U0o,(0,p.A)({},O0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}F0o.isMDXComponent=!0;const V0o={toc:[]},q0o="wrapper";function j0o(e){let{components:n,...t}=e;return(0,s.yg)(q0o,(0,p.A)({},V0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}j0o.isMDXComponent=!0;const H0o={toc:[]},Y0o="wrapper";function Q0o(e){let{components:n,...t}=e;return(0,s.yg)(Y0o,(0,p.A)({},H0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Q0o.isMDXComponent=!0;const $0o={toc:[]},K0o="wrapper";function J0o(e){let{components:n,...t}=e;return(0,s.yg)(K0o,(0,p.A)({},$0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}J0o.isMDXComponent=!0;const Z0o={toc:[]},e3o="wrapper";function n3o(e){let{components:n,...t}=e;return(0,s.yg)(e3o,(0,p.A)({},Z0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}n3o.isMDXComponent=!0;const t3o={toc:[]},o3o="wrapper";function p3o(e){let{components:n,...t}=e;return(0,s.yg)(o3o,(0,p.A)({},t3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}p3o.isMDXComponent=!0;const r3o={toc:[]},s3o="wrapper";function c3o(e){let{components:n,...t}=e;return(0,s.yg)(s3o,(0,p.A)({},r3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}c3o.isMDXComponent=!0;const a3o={toc:[]},i3o="wrapper";function l3o(e){let{components:n,...t}=e;return(0,s.yg)(i3o,(0,p.A)({},a3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}l3o.isMDXComponent=!0;const u3o={toc:[]},m3o="wrapper";function y3o(e){let{components:n,...t}=e;return(0,s.yg)(m3o,(0,p.A)({},u3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}y3o.isMDXComponent=!0;const d3o={toc:[]},h3o="wrapper";function g3o(e){let{components:n,...t}=e;return(0,s.yg)(h3o,(0,p.A)({},d3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}g3o.isMDXComponent=!0;const f3o={toc:[]},D3o="wrapper";function M3o(e){let{components:n,...t}=e;return(0,s.yg)(D3o,(0,p.A)({},f3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}M3o.isMDXComponent=!0;const X3o={toc:[]},_3o="wrapper";function w3o(e){let{components:n,...t}=e;return(0,s.yg)(_3o,(0,p.A)({},X3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}w3o.isMDXComponent=!0;const T3o={toc:[]},C3o="wrapper";function x3o(e){let{components:n,...t}=e;return(0,s.yg)(C3o,(0,p.A)({},T3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}x3o.isMDXComponent=!0;const A3o={toc:[]},v3o="wrapper";function L3o(e){let{components:n,...t}=e;return(0,s.yg)(v3o,(0,p.A)({},A3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}L3o.isMDXComponent=!0;const b3o={toc:[]},N3o="wrapper";function k3o(e){let{components:n,...t}=e;return(0,s.yg)(N3o,(0,p.A)({},b3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}k3o.isMDXComponent=!0;const z3o={toc:[]},P3o="wrapper";function I3o(e){let{components:n,...t}=e;return(0,s.yg)(P3o,(0,p.A)({},z3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}I3o.isMDXComponent=!0;const R3o={toc:[]},W3o="wrapper";function S3o(e){let{components:n,...t}=e;return(0,s.yg)(W3o,(0,p.A)({},R3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}S3o.isMDXComponent=!0;const B3o={toc:[]},G3o="wrapper";function E3o(e){let{components:n,...t}=e;return(0,s.yg)(G3o,(0,p.A)({},B3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}E3o.isMDXComponent=!0;const O3o={toc:[]},U3o="wrapper";function F3o(e){let{components:n,...t}=e;return(0,s.yg)(U3o,(0,p.A)({},O3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}F3o.isMDXComponent=!0;const V3o={toc:[]},q3o="wrapper";function j3o(e){let{components:n,...t}=e;return(0,s.yg)(q3o,(0,p.A)({},V3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}j3o.isMDXComponent=!0;const H3o={toc:[]},Y3o="wrapper";function Q3o(e){let{components:n,...t}=e;return(0,s.yg)(Y3o,(0,p.A)({},H3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Q3o.isMDXComponent=!0;const $3o={toc:[]},K3o="wrapper";function J3o(e){let{components:n,...t}=e;return(0,s.yg)(K3o,(0,p.A)({},$3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}J3o.isMDXComponent=!0;const Z3o={toc:[]},e8o="wrapper";function n8o(e){let{components:n,...t}=e;return(0,s.yg)(e8o,(0,p.A)({},Z3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}n8o.isMDXComponent=!0;const t8o={toc:[]},o8o="wrapper";function p8o(e){let{components:n,...t}=e;return(0,s.yg)(o8o,(0,p.A)({},t8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}p8o.isMDXComponent=!0;const r8o={toc:[]},s8o="wrapper";function c8o(e){let{components:n,...t}=e;return(0,s.yg)(s8o,(0,p.A)({},r8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}c8o.isMDXComponent=!0;const a8o={toc:[]},i8o="wrapper";function l8o(e){let{components:n,...t}=e;return(0,s.yg)(i8o,(0,p.A)({},a8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}l8o.isMDXComponent=!0;const u8o={toc:[]},m8o="wrapper";function y8o(e){let{components:n,...t}=e;return(0,s.yg)(m8o,(0,p.A)({},u8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}y8o.isMDXComponent=!0;const d8o={toc:[]},h8o="wrapper";function g8o(e){let{components:n,...t}=e;return(0,s.yg)(h8o,(0,p.A)({},d8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}g8o.isMDXComponent=!0;const f8o={toc:[]},D8o="wrapper";function M8o(e){let{components:n,...t}=e;return(0,s.yg)(D8o,(0,p.A)({},f8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}M8o.isMDXComponent=!0;const X8o={toc:[]},_8o="wrapper";function w8o(e){let{components:n,...t}=e;return(0,s.yg)(_8o,(0,p.A)({},X8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}w8o.isMDXComponent=!0;const T8o={toc:[]},C8o="wrapper";function x8o(e){let{components:n,...t}=e;return(0,s.yg)(C8o,(0,p.A)({},T8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}x8o.isMDXComponent=!0;const A8o={toc:[]},v8o="wrapper";function L8o(e){let{components:n,...t}=e;return(0,s.yg)(v8o,(0,p.A)({},A8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}L8o.isMDXComponent=!0;const b8o={toc:[]},N8o="wrapper";function k8o(e){let{components:n,...t}=e;return(0,s.yg)(N8o,(0,p.A)({},b8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}k8o.isMDXComponent=!0;const z8o={toc:[]},P8o="wrapper";function I8o(e){let{components:n,...t}=e;return(0,s.yg)(P8o,(0,p.A)({},z8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}I8o.isMDXComponent=!0;const R8o={toc:[]},W8o="wrapper";function S8o(e){let{components:n,...t}=e;return(0,s.yg)(W8o,(0,p.A)({},R8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}S8o.isMDXComponent=!0;const B8o={toc:[]},G8o="wrapper";function E8o(e){let{components:n,...t}=e;return(0,s.yg)(G8o,(0,p.A)({},B8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}E8o.isMDXComponent=!0;const O8o={toc:[]},U8o="wrapper";function F8o(e){let{components:n,...t}=e;return(0,s.yg)(U8o,(0,p.A)({},O8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}F8o.isMDXComponent=!0;const V8o={toc:[]},q8o="wrapper";function j8o(e){let{components:n,...t}=e;return(0,s.yg)(q8o,(0,p.A)({},V8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}j8o.isMDXComponent=!0;const H8o={toc:[]},Y8o="wrapper";function Q8o(e){let{components:n,...t}=e;return(0,s.yg)(Y8o,(0,p.A)({},H8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Q8o.isMDXComponent=!0;const $8o={toc:[]},K8o="wrapper";function J8o(e){let{components:n,...t}=e;return(0,s.yg)(K8o,(0,p.A)({},$8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}J8o.isMDXComponent=!0;const Z8o={toc:[]},e2o="wrapper";function n2o(e){let{components:n,...t}=e;return(0,s.yg)(e2o,(0,p.A)({},Z8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}n2o.isMDXComponent=!0;const t2o={toc:[]},o2o="wrapper";function p2o(e){let{components:n,...t}=e;return(0,s.yg)(o2o,(0,p.A)({},t2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}p2o.isMDXComponent=!0;const r2o={toc:[]},s2o="wrapper";function c2o(e){let{components:n,...t}=e;return(0,s.yg)(s2o,(0,p.A)({},r2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}c2o.isMDXComponent=!0;const a2o={toc:[]},i2o="wrapper";function l2o(e){let{components:n,...t}=e;return(0,s.yg)(i2o,(0,p.A)({},a2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}l2o.isMDXComponent=!0;const u2o={toc:[]},m2o="wrapper";function y2o(e){let{components:n,...t}=e;return(0,s.yg)(m2o,(0,p.A)({},u2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}y2o.isMDXComponent=!0;const d2o={toc:[]},h2o="wrapper";function g2o(e){let{components:n,...t}=e;return(0,s.yg)(h2o,(0,p.A)({},d2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}g2o.isMDXComponent=!0;const f2o={toc:[]},D2o="wrapper";function M2o(e){let{components:n,...t}=e;return(0,s.yg)(D2o,(0,p.A)({},f2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}M2o.isMDXComponent=!0;const X2o={toc:[]},_2o="wrapper";function w2o(e){let{components:n,...t}=e;return(0,s.yg)(_2o,(0,p.A)({},X2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}w2o.isMDXComponent=!0;const T2o={toc:[]},C2o="wrapper";function x2o(e){let{components:n,...t}=e;return(0,s.yg)(C2o,(0,p.A)({},T2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}x2o.isMDXComponent=!0;const A2o={toc:[]},v2o="wrapper";function L2o(e){let{components:n,...t}=e;return(0,s.yg)(v2o,(0,p.A)({},A2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}L2o.isMDXComponent=!0;const b2o={toc:[]},N2o="wrapper";function k2o(e){let{components:n,...t}=e;return(0,s.yg)(N2o,(0,p.A)({},b2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}k2o.isMDXComponent=!0;const z2o={toc:[]},P2o="wrapper";function I2o(e){let{components:n,...t}=e;return(0,s.yg)(P2o,(0,p.A)({},z2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}I2o.isMDXComponent=!0;const R2o={toc:[]},W2o="wrapper";function S2o(e){let{components:n,...t}=e;return(0,s.yg)(W2o,(0,p.A)({},R2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}S2o.isMDXComponent=!0;const B2o={toc:[]},G2o="wrapper";function E2o(e){let{components:n,...t}=e;return(0,s.yg)(G2o,(0,p.A)({},B2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}E2o.isMDXComponent=!0;const O2o={toc:[]},U2o="wrapper";function F2o(e){let{components:n,...t}=e;return(0,s.yg)(U2o,(0,p.A)({},O2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}F2o.isMDXComponent=!0;const V2o={toc:[]},q2o="wrapper";function j2o(e){let{components:n,...t}=e;return(0,s.yg)(q2o,(0,p.A)({},V2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}j2o.isMDXComponent=!0;const H2o={toc:[]},Y2o="wrapper";function Q2o(e){let{components:n,...t}=e;return(0,s.yg)(Y2o,(0,p.A)({},H2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Q2o.isMDXComponent=!0;const $2o={toc:[]},K2o="wrapper";function J2o(e){let{components:n,...t}=e;return(0,s.yg)(K2o,(0,p.A)({},$2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}J2o.isMDXComponent=!0;const Z2o={toc:[]},e1o="wrapper";function n1o(e){let{components:n,...t}=e;return(0,s.yg)(e1o,(0,p.A)({},Z2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}n1o.isMDXComponent=!0;const t1o={toc:[]},o1o="wrapper";function p1o(e){let{components:n,...t}=e;return(0,s.yg)(o1o,(0,p.A)({},t1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}p1o.isMDXComponent=!0;const r1o={toc:[]},s1o="wrapper";function c1o(e){let{components:n,...t}=e;return(0,s.yg)(s1o,(0,p.A)({},r1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}c1o.isMDXComponent=!0;const a1o={toc:[]},i1o="wrapper";function l1o(e){let{components:n,...t}=e;return(0,s.yg)(i1o,(0,p.A)({},a1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}l1o.isMDXComponent=!0;const u1o={toc:[]},m1o="wrapper";function y1o(e){let{components:n,...t}=e;return(0,s.yg)(m1o,(0,p.A)({},u1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}y1o.isMDXComponent=!0;const d1o={toc:[]},h1o="wrapper";function g1o(e){let{components:n,...t}=e;return(0,s.yg)(h1o,(0,p.A)({},d1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}g1o.isMDXComponent=!0;const f1o={toc:[]},D1o="wrapper";function M1o(e){let{components:n,...t}=e;return(0,s.yg)(D1o,(0,p.A)({},f1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}M1o.isMDXComponent=!0;const X1o={toc:[]},_1o="wrapper";function w1o(e){let{components:n,...t}=e;return(0,s.yg)(_1o,(0,p.A)({},X1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}w1o.isMDXComponent=!0;const T1o={toc:[]},C1o="wrapper";function x1o(e){let{components:n,...t}=e;return(0,s.yg)(C1o,(0,p.A)({},T1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}x1o.isMDXComponent=!0;const A1o={toc:[]},v1o="wrapper";function L1o(e){let{components:n,...t}=e;return(0,s.yg)(v1o,(0,p.A)({},A1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}L1o.isMDXComponent=!0;const b1o={toc:[]},N1o="wrapper";function k1o(e){let{components:n,...t}=e;return(0,s.yg)(N1o,(0,p.A)({},b1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}k1o.isMDXComponent=!0;const z1o={toc:[]},P1o="wrapper";function I1o(e){let{components:n,...t}=e;return(0,s.yg)(P1o,(0,p.A)({},z1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}I1o.isMDXComponent=!0;const R1o={toc:[]},W1o="wrapper";function S1o(e){let{components:n,...t}=e;return(0,s.yg)(W1o,(0,p.A)({},R1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}S1o.isMDXComponent=!0;const B1o={toc:[]},G1o="wrapper";function E1o(e){let{components:n,...t}=e;return(0,s.yg)(G1o,(0,p.A)({},B1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}E1o.isMDXComponent=!0;const O1o={toc:[]},U1o="wrapper";function F1o(e){let{components:n,...t}=e;return(0,s.yg)(U1o,(0,p.A)({},O1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}F1o.isMDXComponent=!0;const V1o={toc:[]},q1o="wrapper";function j1o(e){let{components:n,...t}=e;return(0,s.yg)(q1o,(0,p.A)({},V1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}j1o.isMDXComponent=!0;const H1o={toc:[]},Y1o="wrapper";function Q1o(e){let{components:n,...t}=e;return(0,s.yg)(Y1o,(0,p.A)({},H1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Q1o.isMDXComponent=!0;const $1o={toc:[]},K1o="wrapper";function J1o(e){let{components:n,...t}=e;return(0,s.yg)(K1o,(0,p.A)({},$1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}J1o.isMDXComponent=!0;const Z1o={toc:[]},e4o="wrapper";function n4o(e){let{components:n,...t}=e;return(0,s.yg)(e4o,(0,p.A)({},Z1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}n4o.isMDXComponent=!0;const t4o={toc:[]},o4o="wrapper";function p4o(e){let{components:n,...t}=e;return(0,s.yg)(o4o,(0,p.A)({},t4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}p4o.isMDXComponent=!0;const r4o={toc:[]},s4o="wrapper";function c4o(e){let{components:n,...t}=e;return(0,s.yg)(s4o,(0,p.A)({},r4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}c4o.isMDXComponent=!0;const a4o={toc:[]},i4o="wrapper";function l4o(e){let{components:n,...t}=e;return(0,s.yg)(i4o,(0,p.A)({},a4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}l4o.isMDXComponent=!0;const u4o={toc:[]},m4o="wrapper";function y4o(e){let{components:n,...t}=e;return(0,s.yg)(m4o,(0,p.A)({},u4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}y4o.isMDXComponent=!0;const d4o={toc:[]},h4o="wrapper";function g4o(e){let{components:n,...t}=e;return(0,s.yg)(h4o,(0,p.A)({},d4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}g4o.isMDXComponent=!0;const f4o={toc:[]},D4o="wrapper";function M4o(e){let{components:n,...t}=e;return(0,s.yg)(D4o,(0,p.A)({},f4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}M4o.isMDXComponent=!0;const X4o={toc:[]},_4o="wrapper";function w4o(e){let{components:n,...t}=e;return(0,s.yg)(_4o,(0,p.A)({},X4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}w4o.isMDXComponent=!0;const T4o={toc:[]},C4o="wrapper";function x4o(e){let{components:n,...t}=e;return(0,s.yg)(C4o,(0,p.A)({},T4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}x4o.isMDXComponent=!0;const A4o={toc:[]},v4o="wrapper";function L4o(e){let{components:n,...t}=e;return(0,s.yg)(v4o,(0,p.A)({},A4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}L4o.isMDXComponent=!0;const b4o={toc:[]},N4o="wrapper";function k4o(e){let{components:n,...t}=e;return(0,s.yg)(N4o,(0,p.A)({},b4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}k4o.isMDXComponent=!0;const z4o={toc:[]},P4o="wrapper";function I4o(e){let{components:n,...t}=e;return(0,s.yg)(P4o,(0,p.A)({},z4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}I4o.isMDXComponent=!0;const R4o={toc:[]},W4o="wrapper";function S4o(e){let{components:n,...t}=e;return(0,s.yg)(W4o,(0,p.A)({},R4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}S4o.isMDXComponent=!0;const B4o={toc:[]},G4o="wrapper";function E4o(e){let{components:n,...t}=e;return(0,s.yg)(G4o,(0,p.A)({},B4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}E4o.isMDXComponent=!0;const O4o={toc:[]},U4o="wrapper";function F4o(e){let{components:n,...t}=e;return(0,s.yg)(U4o,(0,p.A)({},O4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}F4o.isMDXComponent=!0;const V4o={toc:[]},q4o="wrapper";function j4o(e){let{components:n,...t}=e;return(0,s.yg)(q4o,(0,p.A)({},V4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}j4o.isMDXComponent=!0;const H4o={toc:[]},Y4o="wrapper";function Q4o(e){let{components:n,...t}=e;return(0,s.yg)(Y4o,(0,p.A)({},H4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Q4o.isMDXComponent=!0;const $4o={toc:[]},K4o="wrapper";function J4o(e){let{components:n,...t}=e;return(0,s.yg)(K4o,(0,p.A)({},$4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}J4o.isMDXComponent=!0;const Z4o={toc:[]},e6o="wrapper";function n6o(e){let{components:n,...t}=e;return(0,s.yg)(e6o,(0,p.A)({},Z4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}n6o.isMDXComponent=!0;const t6o={toc:[]},o6o="wrapper";function p6o(e){let{components:n,...t}=e;return(0,s.yg)(o6o,(0,p.A)({},t6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}p6o.isMDXComponent=!0;const r6o={toc:[]},s6o="wrapper";function c6o(e){let{components:n,...t}=e;return(0,s.yg)(s6o,(0,p.A)({},r6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}c6o.isMDXComponent=!0;const a6o={toc:[]},i6o="wrapper";function l6o(e){let{components:n,...t}=e;return(0,s.yg)(i6o,(0,p.A)({},a6o,t,{components:n,mdxType:"MDXLayout"}))}l6o.isMDXComponent=!0;const u6o={toc:[]},m6o="wrapper";function y6o(e){let{components:n,...t}=e;return(0,s.yg)(m6o,(0,p.A)({},u6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}y6o.isMDXComponent=!0;const d6o={toc:[]},h6o="wrapper";function g6o(e){let{components:n,...t}=e;return(0,s.yg)(h6o,(0,p.A)({},d6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}g6o.isMDXComponent=!0;const f6o={toc:[]},D6o="wrapper";function M6o(e){let{components:n,...t}=e;return(0,s.yg)(D6o,(0,p.A)({},f6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}M6o.isMDXComponent=!0;const X6o={toc:[]},_6o="wrapper";function w6o(e){let{components:n,...t}=e;return(0,s.yg)(_6o,(0,p.A)({},X6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}w6o.isMDXComponent=!0;const T6o={toc:[]},C6o="wrapper";function x6o(e){let{components:n,...t}=e;return(0,s.yg)(C6o,(0,p.A)({},T6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}x6o.isMDXComponent=!0;const A6o={toc:[]},v6o="wrapper";function L6o(e){let{components:n,...t}=e;return(0,s.yg)(v6o,(0,p.A)({},A6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}L6o.isMDXComponent=!0;const b6o={toc:[]},N6o="wrapper";function k6o(e){let{components:n,...t}=e;return(0,s.yg)(N6o,(0,p.A)({},b6o,t,{components:n,mdxType:"MDXLayout"}))}k6o.isMDXComponent=!0;const z6o={toc:[]},P6o="wrapper";function I6o(e){let{components:n,...t}=e;return(0,s.yg)(P6o,(0,p.A)({},z6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}I6o.isMDXComponent=!0;const R6o={toc:[]},W6o="wrapper";function S6o(e){let{components:n,...t}=e;return(0,s.yg)(W6o,(0,p.A)({},R6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}S6o.isMDXComponent=!0;const B6o={toc:[]},G6o="wrapper";function E6o(e){let{components:n,...t}=e;return(0,s.yg)(G6o,(0,p.A)({},B6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}E6o.isMDXComponent=!0;const O6o={toc:[]},U6o="wrapper";function F6o(e){let{components:n,...t}=e;return(0,s.yg)(U6o,(0,p.A)({},O6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}F6o.isMDXComponent=!0;const V6o={toc:[]},q6o="wrapper";function j6o(e){let{components:n,...t}=e;return(0,s.yg)(q6o,(0,p.A)({},V6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}j6o.isMDXComponent=!0;const H6o={toc:[]},Y6o="wrapper";function Q6o(e){let{components:n,...t}=e;return(0,s.yg)(Y6o,(0,p.A)({},H6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Q6o.isMDXComponent=!0;const $6o={toc:[]},K6o="wrapper";function J6o(e){let{components:n,...t}=e;return(0,s.yg)(K6o,(0,p.A)({},$6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}J6o.isMDXComponent=!0;const Z6o={toc:[]},e5o="wrapper";function n5o(e){let{components:n,...t}=e;return(0,s.yg)(e5o,(0,p.A)({},Z6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}n5o.isMDXComponent=!0;const t5o={toc:[]},o5o="wrapper";function p5o(e){let{components:n,...t}=e;return(0,s.yg)(o5o,(0,p.A)({},t5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}p5o.isMDXComponent=!0;const r5o={toc:[]},s5o="wrapper";function c5o(e){let{components:n,...t}=e;return(0,s.yg)(s5o,(0,p.A)({},r5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}c5o.isMDXComponent=!0;const a5o={toc:[]},i5o="wrapper";function l5o(e){let{components:n,...t}=e;return(0,s.yg)(i5o,(0,p.A)({},a5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}l5o.isMDXComponent=!0;const u5o={toc:[]},m5o="wrapper";function y5o(e){let{components:n,...t}=e;return(0,s.yg)(m5o,(0,p.A)({},u5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}y5o.isMDXComponent=!0;const d5o={toc:[]},h5o="wrapper";function g5o(e){let{components:n,...t}=e;return(0,s.yg)(h5o,(0,p.A)({},d5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}g5o.isMDXComponent=!0;const f5o={toc:[]},D5o="wrapper";function M5o(e){let{components:n,...t}=e;return(0,s.yg)(D5o,(0,p.A)({},f5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}M5o.isMDXComponent=!0;const X5o={toc:[]},_5o="wrapper";function w5o(e){let{components:n,...t}=e;return(0,s.yg)(_5o,(0,p.A)({},X5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}w5o.isMDXComponent=!0;const T5o={toc:[]},C5o="wrapper";function x5o(e){let{components:n,...t}=e;return(0,s.yg)(C5o,(0,p.A)({},T5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}x5o.isMDXComponent=!0;const A5o={toc:[]},v5o="wrapper";function L5o(e){let{components:n,...t}=e;return(0,s.yg)(v5o,(0,p.A)({},A5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}L5o.isMDXComponent=!0;const b5o={toc:[]},N5o="wrapper";function k5o(e){let{components:n,...t}=e;return(0,s.yg)(N5o,(0,p.A)({},b5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}k5o.isMDXComponent=!0;const z5o={toc:[]},P5o="wrapper";function I5o(e){let{components:n,...t}=e;return(0,s.yg)(P5o,(0,p.A)({},z5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}I5o.isMDXComponent=!0;const R5o={toc:[]},W5o="wrapper";function S5o(e){let{components:n,...t}=e;return(0,s.yg)(W5o,(0,p.A)({},R5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}S5o.isMDXComponent=!0;const B5o={toc:[]},G5o="wrapper";function E5o(e){let{components:n,...t}=e;return(0,s.yg)(G5o,(0,p.A)({},B5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}E5o.isMDXComponent=!0;const O5o={toc:[]},U5o="wrapper";function F5o(e){let{components:n,...t}=e;return(0,s.yg)(U5o,(0,p.A)({},O5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}F5o.isMDXComponent=!0;const V5o={toc:[]},q5o="wrapper";function j5o(e){let{components:n,...t}=e;return(0,s.yg)(q5o,(0,p.A)({},V5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}j5o.isMDXComponent=!0;const H5o={toc:[]},Y5o="wrapper";function Q5o(e){let{components:n,...t}=e;return(0,s.yg)(Y5o,(0,p.A)({},H5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Q5o.isMDXComponent=!0;const $5o={toc:[]},K5o="wrapper";function J5o(e){let{components:n,...t}=e;return(0,s.yg)(K5o,(0,p.A)({},$5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}J5o.isMDXComponent=!0;const Z5o={toc:[]},e7o="wrapper";function n7o(e){let{components:n,...t}=e;return(0,s.yg)(e7o,(0,p.A)({},Z5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}n7o.isMDXComponent=!0;const t7o={toc:[]},o7o="wrapper";function p7o(e){let{components:n,...t}=e;return(0,s.yg)(o7o,(0,p.A)({},t7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}p7o.isMDXComponent=!0;const r7o={toc:[]},s7o="wrapper";function c7o(e){let{components:n,...t}=e;return(0,s.yg)(s7o,(0,p.A)({},r7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}c7o.isMDXComponent=!0;const a7o={toc:[]},i7o="wrapper";function l7o(e){let{components:n,...t}=e;return(0,s.yg)(i7o,(0,p.A)({},a7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}l7o.isMDXComponent=!0;const u7o={toc:[]},m7o="wrapper";function y7o(e){let{components:n,...t}=e;return(0,s.yg)(m7o,(0,p.A)({},u7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}y7o.isMDXComponent=!0;const d7o={toc:[]},h7o="wrapper";function g7o(e){let{components:n,...t}=e;return(0,s.yg)(h7o,(0,p.A)({},d7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}g7o.isMDXComponent=!0;const f7o={toc:[]},D7o="wrapper";function M7o(e){let{components:n,...t}=e;return(0,s.yg)(D7o,(0,p.A)({},f7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}M7o.isMDXComponent=!0;const X7o={toc:[]},_7o="wrapper";function w7o(e){let{components:n,...t}=e;return(0,s.yg)(_7o,(0,p.A)({},X7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}w7o.isMDXComponent=!0;const T7o={toc:[]},C7o="wrapper";function x7o(e){let{components:n,...t}=e;return(0,s.yg)(C7o,(0,p.A)({},T7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}x7o.isMDXComponent=!0;const A7o={toc:[]},v7o="wrapper";function L7o(e){let{components:n,...t}=e;return(0,s.yg)(v7o,(0,p.A)({},A7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}L7o.isMDXComponent=!0;const b7o={toc:[]},N7o="wrapper";function k7o(e){let{components:n,...t}=e;return(0,s.yg)(N7o,(0,p.A)({},b7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}k7o.isMDXComponent=!0;const z7o={toc:[]},P7o="wrapper";function I7o(e){let{components:n,...t}=e;return(0,s.yg)(P7o,(0,p.A)({},z7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}I7o.isMDXComponent=!0;const R7o={toc:[]},W7o="wrapper";function S7o(e){let{components:n,...t}=e;return(0,s.yg)(W7o,(0,p.A)({},R7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}S7o.isMDXComponent=!0;const B7o={toc:[]},G7o="wrapper";function E7o(e){let{components:n,...t}=e;return(0,s.yg)(G7o,(0,p.A)({},B7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}E7o.isMDXComponent=!0;const O7o={toc:[]},U7o="wrapper";function F7o(e){let{components:n,...t}=e;return(0,s.yg)(U7o,(0,p.A)({},O7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}F7o.isMDXComponent=!0;const V7o={toc:[]},q7o="wrapper";function j7o(e){let{components:n,...t}=e;return(0,s.yg)(q7o,(0,p.A)({},V7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}j7o.isMDXComponent=!0;const H7o={toc:[]},Y7o="wrapper";function Q7o(e){let{components:n,...t}=e;return(0,s.yg)(Y7o,(0,p.A)({},H7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Q7o.isMDXComponent=!0;const $7o={toc:[]},K7o="wrapper";function J7o(e){let{components:n,...t}=e;return(0,s.yg)(K7o,(0,p.A)({},$7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}J7o.isMDXComponent=!0;const Z7o={toc:[]},e9o="wrapper";function n9o(e){let{components:n,...t}=e;return(0,s.yg)(e9o,(0,p.A)({},Z7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}n9o.isMDXComponent=!0;const t9o={toc:[]},o9o="wrapper";function p9o(e){let{components:n,...t}=e;return(0,s.yg)(o9o,(0,p.A)({},t9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}p9o.isMDXComponent=!0;const r9o={toc:[]},s9o="wrapper";function c9o(e){let{components:n,...t}=e;return(0,s.yg)(s9o,(0,p.A)({},r9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}c9o.isMDXComponent=!0;const a9o={toc:[]},i9o="wrapper";function l9o(e){let{components:n,...t}=e;return(0,s.yg)(i9o,(0,p.A)({},a9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}l9o.isMDXComponent=!0;const u9o={toc:[]},m9o="wrapper";function y9o(e){let{components:n,...t}=e;return(0,s.yg)(m9o,(0,p.A)({},u9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}y9o.isMDXComponent=!0;const d9o={toc:[]},h9o="wrapper";function g9o(e){let{components:n,...t}=e;return(0,s.yg)(h9o,(0,p.A)({},d9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}g9o.isMDXComponent=!0;const f9o={toc:[]},D9o="wrapper";function M9o(e){let{components:n,...t}=e;return(0,s.yg)(D9o,(0,p.A)({},f9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}M9o.isMDXComponent=!0;const X9o={toc:[]},_9o="wrapper";function w9o(e){let{components:n,...t}=e;return(0,s.yg)(_9o,(0,p.A)({},X9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}w9o.isMDXComponent=!0;const T9o={toc:[]},C9o="wrapper";function x9o(e){let{components:n,...t}=e;return(0,s.yg)(C9o,(0,p.A)({},T9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}x9o.isMDXComponent=!0;const A9o={toc:[]},v9o="wrapper";function L9o(e){let{components:n,...t}=e;return(0,s.yg)(v9o,(0,p.A)({},A9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}L9o.isMDXComponent=!0;const b9o={toc:[]},N9o="wrapper";function k9o(e){let{components:n,...t}=e;return(0,s.yg)(N9o,(0,p.A)({},b9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}k9o.isMDXComponent=!0;const z9o={toc:[]},P9o="wrapper";function I9o(e){let{components:n,...t}=e;return(0,s.yg)(P9o,(0,p.A)({},z9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}I9o.isMDXComponent=!0;const R9o={toc:[]},W9o="wrapper";function S9o(e){let{components:n,...t}=e;return(0,s.yg)(W9o,(0,p.A)({},R9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}S9o.isMDXComponent=!0;const B9o={toc:[]},G9o="wrapper";function E9o(e){let{components:n,...t}=e;return(0,s.yg)(G9o,(0,p.A)({},B9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}E9o.isMDXComponent=!0;const O9o={toc:[]},U9o="wrapper";function F9o(e){let{components:n,...t}=e;return(0,s.yg)(U9o,(0,p.A)({},O9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}F9o.isMDXComponent=!0;const V9o={toc:[]},q9o="wrapper";function j9o(e){let{components:n,...t}=e;return(0,s.yg)(q9o,(0,p.A)({},V9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}j9o.isMDXComponent=!0;const H9o={toc:[]},Y9o="wrapper";function Q9o(e){let{components:n,...t}=e;return(0,s.yg)(Y9o,(0,p.A)({},H9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Q9o.isMDXComponent=!0;const $9o={toc:[]},K9o="wrapper";function J9o(e){let{components:n,...t}=e;return(0,s.yg)(K9o,(0,p.A)({},$9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}J9o.isMDXComponent=!0;const Z9o={toc:[]},eep="wrapper";function nep(e){let{components:n,...t}=e;return(0,s.yg)(eep,(0,p.A)({},Z9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}nep.isMDXComponent=!0;const tep={toc:[]},oep="wrapper";function pep(e){let{components:n,...t}=e;return(0,s.yg)(oep,(0,p.A)({},tep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}pep.isMDXComponent=!0;const rep={toc:[]},sep="wrapper";function cep(e){let{components:n,...t}=e;return(0,s.yg)(sep,(0,p.A)({},rep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}cep.isMDXComponent=!0;const aep={toc:[]},iep="wrapper";function lep(e){let{components:n,...t}=e;return(0,s.yg)(iep,(0,p.A)({},aep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}lep.isMDXComponent=!0;const uep={toc:[]},mep="wrapper";function yep(e){let{components:n,...t}=e;return(0,s.yg)(mep,(0,p.A)({},uep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}yep.isMDXComponent=!0;const dep={toc:[]},hep="wrapper";function gep(e){let{components:n,...t}=e;return(0,s.yg)(hep,(0,p.A)({},dep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}gep.isMDXComponent=!0;const fep={toc:[]},Dep="wrapper";function Mep(e){let{components:n,...t}=e;return(0,s.yg)(Dep,(0,p.A)({},fep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Mep.isMDXComponent=!0;const Xep={toc:[]},_ep="wrapper";function wep(e){let{components:n,...t}=e;return(0,s.yg)(_ep,(0,p.A)({},Xep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}wep.isMDXComponent=!0;const Tep={toc:[]},Cep="wrapper";function xep(e){let{components:n,...t}=e;return(0,s.yg)(Cep,(0,p.A)({},Tep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}xep.isMDXComponent=!0;const Aep={toc:[]},vep="wrapper";function Lep(e){let{components:n,...t}=e;return(0,s.yg)(vep,(0,p.A)({},Aep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Lep.isMDXComponent=!0;const bep={toc:[]},Nep="wrapper";function kep(e){let{components:n,...t}=e;return(0,s.yg)(Nep,(0,p.A)({},bep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}kep.isMDXComponent=!0;const zep={toc:[]},Pep="wrapper";function Iep(e){let{components:n,...t}=e;return(0,s.yg)(Pep,(0,p.A)({},zep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Iep.isMDXComponent=!0;const Rep={toc:[]},Wep="wrapper";function Sep(e){let{components:n,...t}=e;return(0,s.yg)(Wep,(0,p.A)({},Rep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Sep.isMDXComponent=!0;const Bep={toc:[]},Gep="wrapper";function Eep(e){let{components:n,...t}=e;return(0,s.yg)(Gep,(0,p.A)({},Bep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Eep.isMDXComponent=!0;const Oep={toc:[]},Uep="wrapper";function Fep(e){let{components:n,...t}=e;return(0,s.yg)(Uep,(0,p.A)({},Oep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Fep.isMDXComponent=!0;const Vep={toc:[]},qep="wrapper";function jep(e){let{components:n,...t}=e;return(0,s.yg)(qep,(0,p.A)({},Vep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}jep.isMDXComponent=!0;const Hep={toc:[]},Yep="wrapper";function Qep(e){let{components:n,...t}=e;return(0,s.yg)(Yep,(0,p.A)({},Hep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Qep.isMDXComponent=!0;const $ep={toc:[]},Kep="wrapper";function Jep(e){let{components:n,...t}=e;return(0,s.yg)(Kep,(0,p.A)({},$ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Jep.isMDXComponent=!0;const Zep={toc:[]},enp="wrapper";function nnp(e){let{components:n,...t}=e;return(0,s.yg)(enp,(0,p.A)({},Zep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}nnp.isMDXComponent=!0;const tnp={toc:[]},onp="wrapper";function pnp(e){let{components:n,...t}=e;return(0,s.yg)(onp,(0,p.A)({},tnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pnp.isMDXComponent=!0;const rnp={toc:[]},snp="wrapper";function cnp(e){let{components:n,...t}=e;return(0,s.yg)(snp,(0,p.A)({},rnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cnp.isMDXComponent=!0;const anp={toc:[]},inp="wrapper";function lnp(e){let{components:n,...t}=e;return(0,s.yg)(inp,(0,p.A)({},anp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}lnp.isMDXComponent=!0;const unp={toc:[]},mnp="wrapper";function ynp(e){let{components:n,...t}=e;return(0,s.yg)(mnp,(0,p.A)({},unp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}ynp.isMDXComponent=!0;const dnp={toc:[]},hnp="wrapper";function gnp(e){let{components:n,...t}=e;return(0,s.yg)(hnp,(0,p.A)({},dnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gnp.isMDXComponent=!0;const fnp={toc:[]},Dnp="wrapper";function Mnp(e){let{components:n,...t}=e;return(0,s.yg)(Dnp,(0,p.A)({},fnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Mnp.isMDXComponent=!0;const Xnp={toc:[]},_np="wrapper";function wnp(e){let{components:n,...t}=e;return(0,s.yg)(_np,(0,p.A)({},Xnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}wnp.isMDXComponent=!0;const Tnp={toc:[]},Cnp="wrapper";function xnp(e){let{components:n,...t}=e;return(0,s.yg)(Cnp,(0,p.A)({},Tnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xnp.isMDXComponent=!0;const Anp={toc:[]},vnp="wrapper";function Lnp(e){let{components:n,...t}=e;return(0,s.yg)(vnp,(0,p.A)({},Anp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Lnp.isMDXComponent=!0;const bnp={toc:[]},Nnp="wrapper";function knp(e){let{components:n,...t}=e;return(0,s.yg)(Nnp,(0,p.A)({},bnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}knp.isMDXComponent=!0;const znp={toc:[]},Pnp="wrapper";function Inp(e){let{components:n,...t}=e;return(0,s.yg)(Pnp,(0,p.A)({},znp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Inp.isMDXComponent=!0;const Rnp={toc:[]},Wnp="wrapper";function Snp(e){let{components:n,...t}=e;return(0,s.yg)(Wnp,(0,p.A)({},Rnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Snp.isMDXComponent=!0;const Bnp={toc:[]},Gnp="wrapper";function Enp(e){let{components:n,...t}=e;return(0,s.yg)(Gnp,(0,p.A)({},Bnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Enp.isMDXComponent=!0;const Onp={toc:[]},Unp="wrapper";function Fnp(e){let{components:n,...t}=e;return(0,s.yg)(Unp,(0,p.A)({},Onp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Fnp.isMDXComponent=!0;const Vnp={toc:[]},qnp="wrapper";function jnp(e){let{components:n,...t}=e;return(0,s.yg)(qnp,(0,p.A)({},Vnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}jnp.isMDXComponent=!0;const Hnp={toc:[]},Ynp="wrapper";function Qnp(e){let{components:n,...t}=e;return(0,s.yg)(Ynp,(0,p.A)({},Hnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Qnp.isMDXComponent=!0;const $np={toc:[]},Knp="wrapper";function Jnp(e){let{components:n,...t}=e;return(0,s.yg)(Knp,(0,p.A)({},$np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Jnp.isMDXComponent=!0;const Znp={toc:[]},etp="wrapper";function ntp(e){let{components:n,...t}=e;return(0,s.yg)(etp,(0,p.A)({},Znp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}ntp.isMDXComponent=!0;const ttp={toc:[]},otp="wrapper";function ptp(e){let{components:n,...t}=e;return(0,s.yg)(otp,(0,p.A)({},ttp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}ptp.isMDXComponent=!0;const rtp={toc:[]},stp="wrapper";function ctp(e){let{components:n,...t}=e;return(0,s.yg)(stp,(0,p.A)({},rtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}ctp.isMDXComponent=!0;const atp={toc:[]},itp="wrapper";function ltp(e){let{components:n,...t}=e;return(0,s.yg)(itp,(0,p.A)({},atp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}ltp.isMDXComponent=!0;const utp={toc:[]},mtp="wrapper";function ytp(e){let{components:n,...t}=e;return(0,s.yg)(mtp,(0,p.A)({},utp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}ytp.isMDXComponent=!0;const dtp={toc:[]},htp="wrapper";function gtp(e){let{components:n,...t}=e;return(0,s.yg)(htp,(0,p.A)({},dtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}gtp.isMDXComponent=!0;const ftp={toc:[]},Dtp="wrapper";function Mtp(e){let{components:n,...t}=e;return(0,s.yg)(Dtp,(0,p.A)({},ftp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Mtp.isMDXComponent=!0;const Xtp={toc:[]},_tp="wrapper";function wtp(e){let{components:n,...t}=e;return(0,s.yg)(_tp,(0,p.A)({},Xtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}wtp.isMDXComponent=!0;const Ttp={toc:[]},Ctp="wrapper";function xtp(e){let{components:n,...t}=e;return(0,s.yg)(Ctp,(0,p.A)({},Ttp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}xtp.isMDXComponent=!0;const Atp={toc:[]},vtp="wrapper";function Ltp(e){let{components:n,...t}=e;return(0,s.yg)(vtp,(0,p.A)({},Atp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Ltp.isMDXComponent=!0;const btp={toc:[]},Ntp="wrapper";function ktp(e){let{components:n,...t}=e;return(0,s.yg)(Ntp,(0,p.A)({},btp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}ktp.isMDXComponent=!0;const ztp={toc:[]},Ptp="wrapper";function Itp(e){let{components:n,...t}=e;return(0,s.yg)(Ptp,(0,p.A)({},ztp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Itp.isMDXComponent=!0;const Rtp={toc:[]},Wtp="wrapper";function Stp(e){let{components:n,...t}=e;return(0,s.yg)(Wtp,(0,p.A)({},Rtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Stp.isMDXComponent=!0;const Btp={toc:[]},Gtp="wrapper";function Etp(e){let{components:n,...t}=e;return(0,s.yg)(Gtp,(0,p.A)({},Btp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Etp.isMDXComponent=!0;const Otp={toc:[]},Utp="wrapper";function Ftp(e){let{components:n,...t}=e;return(0,s.yg)(Utp,(0,p.A)({},Otp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Ftp.isMDXComponent=!0;const Vtp={toc:[]},qtp="wrapper";function jtp(e){let{components:n,...t}=e;return(0,s.yg)(qtp,(0,p.A)({},Vtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}jtp.isMDXComponent=!0;const Htp={toc:[]},Ytp="wrapper";function Qtp(e){let{components:n,...t}=e;return(0,s.yg)(Ytp,(0,p.A)({},Htp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Qtp.isMDXComponent=!0;const $tp={toc:[]},Ktp="wrapper";function Jtp(e){let{components:n,...t}=e;return(0,s.yg)(Ktp,(0,p.A)({},$tp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Jtp.isMDXComponent=!0;const Ztp={toc:[]},eop="wrapper";function nop(e){let{components:n,...t}=e;return(0,s.yg)(eop,(0,p.A)({},Ztp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}nop.isMDXComponent=!0;const top={toc:[]},oop="wrapper";function pop(e){let{components:n,...t}=e;return(0,s.yg)(oop,(0,p.A)({},top,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}pop.isMDXComponent=!0;const rop={toc:[]},sop="wrapper";function cop(e){let{components:n,...t}=e;return(0,s.yg)(sop,(0,p.A)({},rop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}cop.isMDXComponent=!0;const aop={toc:[]},iop="wrapper";function lop(e){let{components:n,...t}=e;return(0,s.yg)(iop,(0,p.A)({},aop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}lop.isMDXComponent=!0;const uop={toc:[]},mop="wrapper";function yop(e){let{components:n,...t}=e;return(0,s.yg)(mop,(0,p.A)({},uop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}yop.isMDXComponent=!0;const dop={toc:[]},hop="wrapper";function gop(e){let{components:n,...t}=e;return(0,s.yg)(hop,(0,p.A)({},dop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gop.isMDXComponent=!0;const fop={toc:[]},Dop="wrapper";function Mop(e){let{components:n,...t}=e;return(0,s.yg)(Dop,(0,p.A)({},fop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Mop.isMDXComponent=!0;const Xop={toc:[]},_op="wrapper";function wop(e){let{components:n,...t}=e;return(0,s.yg)(_op,(0,p.A)({},Xop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}wop.isMDXComponent=!0;const Top={toc:[]},Cop="wrapper";function xop(e){let{components:n,...t}=e;return(0,s.yg)(Cop,(0,p.A)({},Top,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}xop.isMDXComponent=!0;const Aop={toc:[]},vop="wrapper";function Lop(e){let{components:n,...t}=e;return(0,s.yg)(vop,(0,p.A)({},Aop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Lop.isMDXComponent=!0;const bop={toc:[]},Nop="wrapper";function kop(e){let{components:n,...t}=e;return(0,s.yg)(Nop,(0,p.A)({},bop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kop.isMDXComponent=!0;const zop={toc:[]},Pop="wrapper";function Iop(e){let{components:n,...t}=e;return(0,s.yg)(Pop,(0,p.A)({},zop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Iop.isMDXComponent=!0;const Rop={toc:[]},Wop="wrapper";function Sop(e){let{components:n,...t}=e;return(0,s.yg)(Wop,(0,p.A)({},Rop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Sop.isMDXComponent=!0;const Bop={toc:[]},Gop="wrapper";function Eop(e){let{components:n,...t}=e;return(0,s.yg)(Gop,(0,p.A)({},Bop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Eop.isMDXComponent=!0;const Oop={toc:[]},Uop="wrapper";function Fop(e){let{components:n,...t}=e;return(0,s.yg)(Uop,(0,p.A)({},Oop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Fop.isMDXComponent=!0;const Vop={toc:[]},qop="wrapper";function jop(e){let{components:n,...t}=e;return(0,s.yg)(qop,(0,p.A)({},Vop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jop.isMDXComponent=!0;const Hop={toc:[]},Yop="wrapper";function Qop(e){let{components:n,...t}=e;return(0,s.yg)(Yop,(0,p.A)({},Hop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qop.isMDXComponent=!0;const $op={toc:[]},Kop="wrapper";function Jop(e){let{components:n,...t}=e;return(0,s.yg)(Kop,(0,p.A)({},$op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Jop.isMDXComponent=!0;const Zop={toc:[]},epp="wrapper";function npp(e){let{components:n,...t}=e;return(0,s.yg)(epp,(0,p.A)({},Zop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}npp.isMDXComponent=!0;const tpp={toc:[]},opp="wrapper";function ppp(e){let{components:n,...t}=e;return(0,s.yg)(opp,(0,p.A)({},tpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}ppp.isMDXComponent=!0;const rpp={toc:[]},spp="wrapper";function cpp(e){let{components:n,...t}=e;return(0,s.yg)(spp,(0,p.A)({},rpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}cpp.isMDXComponent=!0;const app={toc:[]},ipp="wrapper";function lpp(e){let{components:n,...t}=e;return(0,s.yg)(ipp,(0,p.A)({},app,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lpp.isMDXComponent=!0;const upp={toc:[]},mpp="wrapper";function ypp(e){let{components:n,...t}=e;return(0,s.yg)(mpp,(0,p.A)({},upp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ypp.isMDXComponent=!0;const dpp={toc:[]},hpp="wrapper";function gpp(e){let{components:n,...t}=e;return(0,s.yg)(hpp,(0,p.A)({},dpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}gpp.isMDXComponent=!0;const fpp={toc:[]},Dpp="wrapper";function Mpp(e){let{components:n,...t}=e;return(0,s.yg)(Dpp,(0,p.A)({},fpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Mpp.isMDXComponent=!0;const Xpp={toc:[]},_pp="wrapper";function wpp(e){let{components:n,...t}=e;return(0,s.yg)(_pp,(0,p.A)({},Xpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wpp.isMDXComponent=!0;const Tpp={toc:[]},Cpp="wrapper";function xpp(e){let{components:n,...t}=e;return(0,s.yg)(Cpp,(0,p.A)({},Tpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}xpp.isMDXComponent=!0;const App={toc:[]},vpp="wrapper";function Lpp(e){let{components:n,...t}=e;return(0,s.yg)(vpp,(0,p.A)({},App,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Lpp.isMDXComponent=!0;const bpp={toc:[]},Npp="wrapper";function kpp(e){let{components:n,...t}=e;return(0,s.yg)(Npp,(0,p.A)({},bpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}kpp.isMDXComponent=!0;const zpp={toc:[]},Ppp="wrapper";function Ipp(e){let{components:n,...t}=e;return(0,s.yg)(Ppp,(0,p.A)({},zpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ipp.isMDXComponent=!0;const Rpp={toc:[]},Wpp="wrapper";function Spp(e){let{components:n,...t}=e;return(0,s.yg)(Wpp,(0,p.A)({},Rpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Spp.isMDXComponent=!0;const Bpp={toc:[]},Gpp="wrapper";function Epp(e){let{components:n,...t}=e;return(0,s.yg)(Gpp,(0,p.A)({},Bpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut for"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontWeight={700} />\n")))}Epp.isMDXComponent=!0;const Opp={toc:[]},Upp="wrapper";function Fpp(e){let{components:n,...t}=e;return(0,s.yg)(Upp,(0,p.A)({},Opp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a bold text node."))}Fpp.isMDXComponent=!0;const Vpp={toc:[]},qpp="wrapper";function jpp(e){let{components:n,...t}=e;return(0,s.yg)(qpp,(0,p.A)({},Vpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional text properties."))}jpp.isMDXComponent=!0;const Hpp={toc:[]},Ypp="wrapper";function Qpp(e){let{components:n,...t}=e;return(0,s.yg)(Ypp,(0,p.A)({},Hpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut for"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontStyle={'italic'} />\n")))}Qpp.isMDXComponent=!0;const $pp={toc:[]},Kpp="wrapper";function Jpp(e){let{components:n,...t}=e;return(0,s.yg)(Kpp,(0,p.A)({},$pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an italic text node."))}Jpp.isMDXComponent=!0;const Zpp={toc:[]},erp="wrapper";function nrp(e){let{components:n,...t}=e;return(0,s.yg)(erp,(0,p.A)({},Zpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional text properties."))}nrp.isMDXComponent=!0;const trp={toc:[]},orp="wrapper";function prp(e){let{components:n,...t}=e;return(0,s.yg)(orp,(0,p.A)({},trp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}prp.isMDXComponent=!0;const rrp={toc:[]},srp="wrapper";function crp(e){let{components:n,...t}=e;return(0,s.yg)(srp,(0,p.A)({},rrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}crp.isMDXComponent=!0;const arp={toc:[]},irp="wrapper";function lrp(e){let{components:n,...t}=e;return(0,s.yg)(irp,(0,p.A)({},arp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lrp.isMDXComponent=!0;const urp={toc:[]},mrp="wrapper";function yrp(e){let{components:n,...t}=e;return(0,s.yg)(mrp,(0,p.A)({},urp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}yrp.isMDXComponent=!0;const drp={toc:[]},hrp="wrapper";function grp(e){let{components:n,...t}=e;return(0,s.yg)(hrp,(0,p.A)({},drp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}grp.isMDXComponent=!0;const frp={toc:[]},Drp="wrapper";function Mrp(e){let{components:n,...t}=e;return(0,s.yg)(Drp,(0,p.A)({},frp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Mrp.isMDXComponent=!0;const Xrp={toc:[]},_rp="wrapper";function wrp(e){let{components:n,...t}=e;return(0,s.yg)(_rp,(0,p.A)({},Xrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}wrp.isMDXComponent=!0;const Trp={toc:[]},Crp="wrapper";function xrp(e){let{components:n,...t}=e;return(0,s.yg)(Crp,(0,p.A)({},Trp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this video."))}xrp.isMDXComponent=!0;const Arp={toc:[]},vrp="wrapper";function Lrp(e){let{components:n,...t}=e;return(0,s.yg)(vrp,(0,p.A)({},Arp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Lrp.isMDXComponent=!0;const brp={toc:[]},Nrp="wrapper";function krp(e){let{components:n,...t}=e;return(0,s.yg)(Nrp,(0,p.A)({},brp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}krp.isMDXComponent=!0;const zrp={toc:[]},Prp="wrapper";function Irp(e){let{components:n,...t}=e;return(0,s.yg)(Prp,(0,p.A)({},zrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Irp.isMDXComponent=!0;const Rrp={toc:[]},Wrp="wrapper";function Srp(e){let{components:n,...t}=e;return(0,s.yg)(Wrp,(0,p.A)({},Rrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Srp.isMDXComponent=!0;const Brp={toc:[]},Grp="wrapper";function Erp(e){let{components:n,...t}=e;return(0,s.yg)(Grp,(0,p.A)({},Brp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Erp.isMDXComponent=!0;const Orp={toc:[]},Urp="wrapper";function Frp(e){let{components:n,...t}=e;return(0,s.yg)(Urp,(0,p.A)({},Orp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Frp.isMDXComponent=!0;const Vrp={toc:[]},qrp="wrapper";function jrp(e){let{components:n,...t}=e;return(0,s.yg)(qrp,(0,p.A)({},Vrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}jrp.isMDXComponent=!0;const Hrp={toc:[]},Yrp="wrapper";function Qrp(e){let{components:n,...t}=e;return(0,s.yg)(Yrp,(0,p.A)({},Hrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Qrp.isMDXComponent=!0;const $rp={toc:[]},Krp="wrapper";function Jrp(e){let{components:n,...t}=e;return(0,s.yg)(Krp,(0,p.A)({},$rp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Jrp.isMDXComponent=!0;const Zrp={toc:[]},esp="wrapper";function nsp(e){let{components:n,...t}=e;return(0,s.yg)(esp,(0,p.A)({},Zrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nsp.isMDXComponent=!0;const tsp={toc:[]},osp="wrapper";function psp(e){let{components:n,...t}=e;return(0,s.yg)(osp,(0,p.A)({},tsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}psp.isMDXComponent=!0;const rsp={toc:[]},ssp="wrapper";function csp(e){let{components:n,...t}=e;return(0,s.yg)(ssp,(0,p.A)({},rsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}csp.isMDXComponent=!0;const asp={toc:[]},isp="wrapper";function lsp(e){let{components:n,...t}=e;return(0,s.yg)(isp,(0,p.A)({},asp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lsp.isMDXComponent=!0;const usp={toc:[]},msp="wrapper";function ysp(e){let{components:n,...t}=e;return(0,s.yg)(msp,(0,p.A)({},usp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}ysp.isMDXComponent=!0;const dsp={toc:[]},hsp="wrapper";function gsp(e){let{components:n,...t}=e;return(0,s.yg)(hsp,(0,p.A)({},dsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}gsp.isMDXComponent=!0;const fsp={toc:[]},Dsp="wrapper";function Msp(e){let{components:n,...t}=e;return(0,s.yg)(Dsp,(0,p.A)({},fsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Msp.isMDXComponent=!0;const Xsp={toc:[]},_sp="wrapper";function wsp(e){let{components:n,...t}=e;return(0,s.yg)(_sp,(0,p.A)({},Xsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}wsp.isMDXComponent=!0;const Tsp={toc:[]},Csp="wrapper";function xsp(e){let{components:n,...t}=e;return(0,s.yg)(Csp,(0,p.A)({},Tsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xsp.isMDXComponent=!0;const Asp={toc:[]},vsp="wrapper";function Lsp(e){let{components:n,...t}=e;return(0,s.yg)(vsp,(0,p.A)({},Asp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Lsp.isMDXComponent=!0;const bsp={toc:[]},Nsp="wrapper";function ksp(e){let{components:n,...t}=e;return(0,s.yg)(Nsp,(0,p.A)({},bsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ksp.isMDXComponent=!0;const zsp={toc:[]},Psp="wrapper";function Isp(e){let{components:n,...t}=e;return(0,s.yg)(Psp,(0,p.A)({},zsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Isp.isMDXComponent=!0;const Rsp={toc:[]},Wsp="wrapper";function Ssp(e){let{components:n,...t}=e;return(0,s.yg)(Wsp,(0,p.A)({},Rsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Ssp.isMDXComponent=!0;const Bsp={toc:[]},Gsp="wrapper";function Esp(e){let{components:n,...t}=e;return(0,s.yg)(Gsp,(0,p.A)({},Bsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Esp.isMDXComponent=!0;const Osp={toc:[]},Usp="wrapper";function Fsp(e){let{components:n,...t}=e;return(0,s.yg)(Usp,(0,p.A)({},Osp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Fsp.isMDXComponent=!0;const Vsp={toc:[]},qsp="wrapper";function jsp(e){let{components:n,...t}=e;return(0,s.yg)(qsp,(0,p.A)({},Vsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}jsp.isMDXComponent=!0;const Hsp={toc:[]},Ysp="wrapper";function Qsp(e){let{components:n,...t}=e;return(0,s.yg)(Ysp,(0,p.A)({},Hsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Qsp.isMDXComponent=!0;const $sp={toc:[]},Ksp="wrapper";function Jsp(e){let{components:n,...t}=e;return(0,s.yg)(Ksp,(0,p.A)({},$sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Jsp.isMDXComponent=!0;const Zsp={toc:[]},ecp="wrapper";function ncp(e){let{components:n,...t}=e;return(0,s.yg)(ecp,(0,p.A)({},Zsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}ncp.isMDXComponent=!0;const tcp={toc:[]},ocp="wrapper";function pcp(e){let{components:n,...t}=e;return(0,s.yg)(ocp,(0,p.A)({},tcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}pcp.isMDXComponent=!0;const rcp={toc:[]},scp="wrapper";function ccp(e){let{components:n,...t}=e;return(0,s.yg)(scp,(0,p.A)({},rcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ccp.isMDXComponent=!0;const acp={toc:[]},icp="wrapper";function lcp(e){let{components:n,...t}=e;return(0,s.yg)(icp,(0,p.A)({},acp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}lcp.isMDXComponent=!0;const ucp={toc:[]},mcp="wrapper";function ycp(e){let{components:n,...t}=e;return(0,s.yg)(mcp,(0,p.A)({},ucp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}ycp.isMDXComponent=!0;const dcp={toc:[]},hcp="wrapper";function gcp(e){let{components:n,...t}=e;return(0,s.yg)(hcp,(0,p.A)({},dcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}gcp.isMDXComponent=!0;const fcp={toc:[]},Dcp="wrapper";function Mcp(e){let{components:n,...t}=e;return(0,s.yg)(Dcp,(0,p.A)({},fcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Mcp.isMDXComponent=!0;const Xcp={toc:[]},_cp="wrapper";function wcp(e){let{components:n,...t}=e;return(0,s.yg)(_cp,(0,p.A)({},Xcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}wcp.isMDXComponent=!0;const Tcp={toc:[]},Ccp="wrapper";function xcp(e){let{components:n,...t}=e;return(0,s.yg)(Ccp,(0,p.A)({},Tcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}xcp.isMDXComponent=!0;const Acp={toc:[]},vcp="wrapper";function Lcp(e){let{components:n,...t}=e;return(0,s.yg)(vcp,(0,p.A)({},Acp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Lcp.isMDXComponent=!0;const bcp={toc:[]},Ncp="wrapper";function kcp(e){let{components:n,...t}=e;return(0,s.yg)(Ncp,(0,p.A)({},bcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kcp.isMDXComponent=!0;const zcp={toc:[]},Pcp="wrapper";function Icp(e){let{components:n,...t}=e;return(0,s.yg)(Pcp,(0,p.A)({},zcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Icp.isMDXComponent=!0;const Rcp={toc:[]},Wcp="wrapper";function Scp(e){let{components:n,...t}=e;return(0,s.yg)(Wcp,(0,p.A)({},Rcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Scp.isMDXComponent=!0;const Bcp={toc:[]},Gcp="wrapper";function Ecp(e){let{components:n,...t}=e;return(0,s.yg)(Gcp,(0,p.A)({},Bcp,t,{components:n,mdxType:"MDXLayout"}))}Ecp.isMDXComponent=!0;const Ocp={toc:[]},Ucp="wrapper";function Fcp(e){let{components:n,...t}=e;return(0,s.yg)(Ucp,(0,p.A)({},Ocp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Fcp.isMDXComponent=!0;const Vcp={toc:[]},qcp="wrapper";function jcp(e){let{components:n,...t}=e;return(0,s.yg)(qcp,(0,p.A)({},Vcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}jcp.isMDXComponent=!0;const Hcp={toc:[]},Ycp="wrapper";function Qcp(e){let{components:n,...t}=e;return(0,s.yg)(Ycp,(0,p.A)({},Hcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Qcp.isMDXComponent=!0;const $cp={toc:[]},Kcp="wrapper";function Jcp(e){let{components:n,...t}=e;return(0,s.yg)(Kcp,(0,p.A)({},$cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Jcp.isMDXComponent=!0;const Zcp={toc:[]},eap="wrapper";function nap(e){let{components:n,...t}=e;return(0,s.yg)(eap,(0,p.A)({},Zcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}nap.isMDXComponent=!0;const tap={toc:[]},oap="wrapper";function pap(e){let{components:n,...t}=e;return(0,s.yg)(oap,(0,p.A)({},tap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}pap.isMDXComponent=!0;const rap={toc:[]},sap="wrapper";function cap(e){let{components:n,...t}=e;return(0,s.yg)(sap,(0,p.A)({},rap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}cap.isMDXComponent=!0;const aap={toc:[]},iap="wrapper";function lap(e){let{components:n,...t}=e;return(0,s.yg)(iap,(0,p.A)({},aap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}lap.isMDXComponent=!0;const uap={toc:[]},map="wrapper";function yap(e){let{components:n,...t}=e;return(0,s.yg)(map,(0,p.A)({},uap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}yap.isMDXComponent=!0;const dap={toc:[]},hap="wrapper";function gap(e){let{components:n,...t}=e;return(0,s.yg)(hap,(0,p.A)({},dap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}gap.isMDXComponent=!0;const fap={toc:[]},Dap="wrapper";function Map(e){let{components:n,...t}=e;return(0,s.yg)(Dap,(0,p.A)({},fap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video should be smoothed."))}Map.isMDXComponent=!0;const Xap={toc:[]},_ap="wrapper";function wap(e){let{components:n,...t}=e;return(0,s.yg)(_ap,(0,p.A)({},Xap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}wap.isMDXComponent=!0;const Tap={toc:[]},Cap="wrapper";function xap(e){let{components:n,...t}=e;return(0,s.yg)(Cap,(0,p.A)({},Tap,t,{components:n,mdxType:"MDXLayout"}))}xap.isMDXComponent=!0;const Aap={toc:[]},vap="wrapper";function Lap(e){let{components:n,...t}=e;return(0,s.yg)(vap,(0,p.A)({},Aap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Lap.isMDXComponent=!0;const bap={toc:[]},Nap="wrapper";function kap(e){let{components:n,...t}=e;return(0,s.yg)(Nap,(0,p.A)({},bap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}kap.isMDXComponent=!0;const zap={toc:[]},Pap="wrapper";function Iap(e){let{components:n,...t}=e;return(0,s.yg)(Pap,(0,p.A)({},zap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Iap.isMDXComponent=!0;const Rap={toc:[]},Wap="wrapper";function Sap(e){let{components:n,...t}=e;return(0,s.yg)(Wap,(0,p.A)({},Rap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Sap.isMDXComponent=!0;const Bap={toc:[]},Gap="wrapper";function Eap(e){let{components:n,...t}=e;return(0,s.yg)(Gap,(0,p.A)({},Bap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Eap.isMDXComponent=!0;const Oap={toc:[]},Uap="wrapper";function Fap(e){let{components:n,...t}=e;return(0,s.yg)(Uap,(0,p.A)({},Oap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Fap.isMDXComponent=!0;const Vap={toc:[]},qap="wrapper";function jap(e){let{components:n,...t}=e;return(0,s.yg)(qap,(0,p.A)({},Vap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}jap.isMDXComponent=!0;const Hap={toc:[]},Yap="wrapper";function Qap(e){let{components:n,...t}=e;return(0,s.yg)(Yap,(0,p.A)({},Hap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Qap.isMDXComponent=!0;const $ap={toc:[]},Kap="wrapper";function Jap(e){let{components:n,...t}=e;return(0,s.yg)(Kap,(0,p.A)({},$ap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Jap.isMDXComponent=!0;const Zap={toc:[]},eip="wrapper";function nip(e){let{components:n,...t}=e;return(0,s.yg)(eip,(0,p.A)({},Zap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}nip.isMDXComponent=!0;const tip={toc:[]},oip="wrapper";function pip(e){let{components:n,...t}=e;return(0,s.yg)(oip,(0,p.A)({},tip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}pip.isMDXComponent=!0;const rip={toc:[]},sip="wrapper";function cip(e){let{components:n,...t}=e;return(0,s.yg)(sip,(0,p.A)({},rip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}cip.isMDXComponent=!0;const aip={toc:[]},iip="wrapper";function lip(e){let{components:n,...t}=e;return(0,s.yg)(iip,(0,p.A)({},aip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}lip.isMDXComponent=!0;const uip={toc:[]},mip="wrapper";function yip(e){let{components:n,...t}=e;return(0,s.yg)(mip,(0,p.A)({},uip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yip.isMDXComponent=!0;const dip={toc:[]},hip="wrapper";function gip(e){let{components:n,...t}=e;return(0,s.yg)(hip,(0,p.A)({},dip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}gip.isMDXComponent=!0;const fip={toc:[]},Dip="wrapper";function Mip(e){let{components:n,...t}=e;return(0,s.yg)(Dip,(0,p.A)({},fip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Mip.isMDXComponent=!0;const Xip={toc:[]},_ip="wrapper";function wip(e){let{components:n,...t}=e;return(0,s.yg)(_ip,(0,p.A)({},Xip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wip.isMDXComponent=!0;const Tip={toc:[]},Cip="wrapper";function xip(e){let{components:n,...t}=e;return(0,s.yg)(Cip,(0,p.A)({},Tip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}xip.isMDXComponent=!0;const Aip={toc:[]},vip="wrapper";function Lip(e){let{components:n,...t}=e;return(0,s.yg)(vip,(0,p.A)({},Aip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Lip.isMDXComponent=!0;const bip={toc:[]},Nip="wrapper";function kip(e){let{components:n,...t}=e;return(0,s.yg)(Nip,(0,p.A)({},bip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}kip.isMDXComponent=!0;const zip={toc:[]},Pip="wrapper";function Iip(e){let{components:n,...t}=e;return(0,s.yg)(Pip,(0,p.A)({},zip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Iip.isMDXComponent=!0;const Rip={toc:[]},Wip="wrapper";function Sip(e){let{components:n,...t}=e;return(0,s.yg)(Wip,(0,p.A)({},Rip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Sip.isMDXComponent=!0;const Bip={toc:[]},Gip="wrapper";function Eip(e){let{components:n,...t}=e;return(0,s.yg)(Gip,(0,p.A)({},Bip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Eip.isMDXComponent=!0;const Oip={toc:[]},Uip="wrapper";function Fip(e){let{components:n,...t}=e;return(0,s.yg)(Uip,(0,p.A)({},Oip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Fip.isMDXComponent=!0;const Vip={toc:[]},qip="wrapper";function jip(e){let{components:n,...t}=e;return(0,s.yg)(qip,(0,p.A)({},Vip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}jip.isMDXComponent=!0;const Hip={toc:[]},Yip="wrapper";function Qip(e){let{components:n,...t}=e;return(0,s.yg)(Yip,(0,p.A)({},Hip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Qip.isMDXComponent=!0;const $ip={toc:[]},Kip="wrapper";function Jip(e){let{components:n,...t}=e;return(0,s.yg)(Kip,(0,p.A)({},$ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Jip.isMDXComponent=!0;const Zip={toc:[]},elp="wrapper";function nlp(e){let{components:n,...t}=e;return(0,s.yg)(elp,(0,p.A)({},Zip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nlp.isMDXComponent=!0;const tlp={toc:[]},olp="wrapper";function plp(e){let{components:n,...t}=e;return(0,s.yg)(olp,(0,p.A)({},tlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}plp.isMDXComponent=!0;const rlp={toc:[]},slp="wrapper";function clp(e){let{components:n,...t}=e;return(0,s.yg)(slp,(0,p.A)({},rlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}clp.isMDXComponent=!0;const alp={toc:[]},ilp="wrapper";function llp(e){let{components:n,...t}=e;return(0,s.yg)(ilp,(0,p.A)({},alp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}llp.isMDXComponent=!0;const ulp={toc:[]},mlp="wrapper";function ylp(e){let{components:n,...t}=e;return(0,s.yg)(mlp,(0,p.A)({},ulp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}ylp.isMDXComponent=!0;const dlp={toc:[]},hlp="wrapper";function glp(e){let{components:n,...t}=e;return(0,s.yg)(hlp,(0,p.A)({},dlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}glp.isMDXComponent=!0;const flp={toc:[]},Dlp="wrapper";function Mlp(e){let{components:n,...t}=e;return(0,s.yg)(Dlp,(0,p.A)({},flp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Mlp.isMDXComponent=!0;const Xlp={toc:[]},_lp="wrapper";function wlp(e){let{components:n,...t}=e;return(0,s.yg)(_lp,(0,p.A)({},Xlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}wlp.isMDXComponent=!0;const Tlp={toc:[]},Clp="wrapper";function xlp(e){let{components:n,...t}=e;return(0,s.yg)(Clp,(0,p.A)({},Tlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}xlp.isMDXComponent=!0;const Alp={toc:[]},vlp="wrapper";function Llp(e){let{components:n,...t}=e;return(0,s.yg)(vlp,(0,p.A)({},Alp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Llp.isMDXComponent=!0;const blp={toc:[]},Nlp="wrapper";function klp(e){let{components:n,...t}=e;return(0,s.yg)(Nlp,(0,p.A)({},blp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}klp.isMDXComponent=!0;const zlp={toc:[]},Plp="wrapper";function Ilp(e){let{components:n,...t}=e;return(0,s.yg)(Plp,(0,p.A)({},zlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Ilp.isMDXComponent=!0;const Rlp={toc:[]},Wlp="wrapper";function Slp(e){let{components:n,...t}=e;return(0,s.yg)(Wlp,(0,p.A)({},Rlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Slp.isMDXComponent=!0;const Blp={toc:[]},Glp="wrapper";function Elp(e){let{components:n,...t}=e;return(0,s.yg)(Glp,(0,p.A)({},Blp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Elp.isMDXComponent=!0;const Olp={toc:[]},Ulp="wrapper";function Flp(e){let{components:n,...t}=e;return(0,s.yg)(Ulp,(0,p.A)({},Olp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Flp.isMDXComponent=!0;const Vlp={toc:[]},qlp="wrapper";function jlp(e){let{components:n,...t}=e;return(0,s.yg)(qlp,(0,p.A)({},Vlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}jlp.isMDXComponent=!0;const Hlp={toc:[]},Ylp="wrapper";function Qlp(e){let{components:n,...t}=e;return(0,s.yg)(Ylp,(0,p.A)({},Hlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qlp.isMDXComponent=!0;const $lp={toc:[]},Klp="wrapper";function Jlp(e){let{components:n,...t}=e;return(0,s.yg)(Klp,(0,p.A)({},$lp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Jlp.isMDXComponent=!0;const Zlp={toc:[]},eup="wrapper";function nup(e){let{components:n,...t}=e;return(0,s.yg)(eup,(0,p.A)({},Zlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nup.isMDXComponent=!0;const tup={toc:[]},oup="wrapper";function pup(e){let{components:n,...t}=e;return(0,s.yg)(oup,(0,p.A)({},tup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}pup.isMDXComponent=!0;const rup={toc:[]},sup="wrapper";function cup(e){let{components:n,...t}=e;return(0,s.yg)(sup,(0,p.A)({},rup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cup.isMDXComponent=!0;const aup={toc:[]},iup="wrapper";function lup(e){let{components:n,...t}=e;return(0,s.yg)(iup,(0,p.A)({},aup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}lup.isMDXComponent=!0;const uup={toc:[]},mup="wrapper";function yup(e){let{components:n,...t}=e;return(0,s.yg)(mup,(0,p.A)({},uup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yup.isMDXComponent=!0;const dup={toc:[]},hup="wrapper";function gup(e){let{components:n,...t}=e;return(0,s.yg)(hup,(0,p.A)({},dup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}gup.isMDXComponent=!0;const fup={toc:[]},Dup="wrapper";function Mup(e){let{components:n,...t}=e;return(0,s.yg)(Dup,(0,p.A)({},fup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mup.isMDXComponent=!0;const Xup={toc:[]},_up="wrapper";function wup(e){let{components:n,...t}=e;return(0,s.yg)(_up,(0,p.A)({},Xup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}wup.isMDXComponent=!0;const Tup={toc:[]},Cup="wrapper";function xup(e){let{components:n,...t}=e;return(0,s.yg)(Cup,(0,p.A)({},Tup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xup.isMDXComponent=!0;const Aup={toc:[]},vup="wrapper";function Lup(e){let{components:n,...t}=e;return(0,s.yg)(vup,(0,p.A)({},Aup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Lup.isMDXComponent=!0;const bup={toc:[]},Nup="wrapper";function kup(e){let{components:n,...t}=e;return(0,s.yg)(Nup,(0,p.A)({},bup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kup.isMDXComponent=!0;const zup={toc:[]},Pup="wrapper";function Iup(e){let{components:n,...t}=e;return(0,s.yg)(Pup,(0,p.A)({},zup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Iup.isMDXComponent=!0;const Rup={toc:[]},Wup="wrapper";function Sup(e){let{components:n,...t}=e;return(0,s.yg)(Wup,(0,p.A)({},Rup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Sup.isMDXComponent=!0;const Bup={toc:[]},Gup="wrapper";function Eup(e){let{components:n,...t}=e;return(0,s.yg)(Gup,(0,p.A)({},Bup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Eup.isMDXComponent=!0;const Oup={toc:[]},Uup="wrapper";function Fup(e){let{components:n,...t}=e;return(0,s.yg)(Uup,(0,p.A)({},Oup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Fup.isMDXComponent=!0;const Vup={toc:[]},qup="wrapper";function jup(e){let{components:n,...t}=e;return(0,s.yg)(qup,(0,p.A)({},Vup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}jup.isMDXComponent=!0;const Hup={toc:[]},Yup="wrapper";function Qup(e){let{components:n,...t}=e;return(0,s.yg)(Yup,(0,p.A)({},Hup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Qup.isMDXComponent=!0;const $up={toc:[]},Kup="wrapper";function Jup(e){let{components:n,...t}=e;return(0,s.yg)(Kup,(0,p.A)({},$up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Jup.isMDXComponent=!0;const Zup={toc:[]},emp="wrapper";function nmp(e){let{components:n,...t}=e;return(0,s.yg)(emp,(0,p.A)({},Zup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}nmp.isMDXComponent=!0;const tmp={toc:[]},omp="wrapper";function pmp(e){let{components:n,...t}=e;return(0,s.yg)(omp,(0,p.A)({},tmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}pmp.isMDXComponent=!0;const rmp={toc:[]},smp="wrapper";function cmp(e){let{components:n,...t}=e;return(0,s.yg)(smp,(0,p.A)({},rmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}cmp.isMDXComponent=!0;const amp={toc:[]},imp="wrapper";function lmp(e){let{components:n,...t}=e;return(0,s.yg)(imp,(0,p.A)({},amp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}lmp.isMDXComponent=!0;const ump={toc:[]},mmp="wrapper";function ymp(e){let{components:n,...t}=e;return(0,s.yg)(mmp,(0,p.A)({},ump,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ymp.isMDXComponent=!0;const dmp={toc:[]},hmp="wrapper";function gmp(e){let{components:n,...t}=e;return(0,s.yg)(hmp,(0,p.A)({},dmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}gmp.isMDXComponent=!0;const fmp={toc:[]},Dmp="wrapper";function Mmp(e){let{components:n,...t}=e;return(0,s.yg)(Dmp,(0,p.A)({},fmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Mmp.isMDXComponent=!0;const Xmp={toc:[]},_mp="wrapper";function wmp(e){let{components:n,...t}=e;return(0,s.yg)(_mp,(0,p.A)({},Xmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}wmp.isMDXComponent=!0;const Tmp={toc:[]},Cmp="wrapper";function xmp(e){let{components:n,...t}=e;return(0,s.yg)(Cmp,(0,p.A)({},Tmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}xmp.isMDXComponent=!0;const Amp={toc:[]},vmp="wrapper";function Lmp(e){let{components:n,...t}=e;return(0,s.yg)(vmp,(0,p.A)({},Amp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Lmp.isMDXComponent=!0;const bmp={toc:[]},Nmp="wrapper";function kmp(e){let{components:n,...t}=e;return(0,s.yg)(Nmp,(0,p.A)({},bmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}kmp.isMDXComponent=!0;const zmp={toc:[]},Pmp="wrapper";function Imp(e){let{components:n,...t}=e;return(0,s.yg)(Pmp,(0,p.A)({},zmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Imp.isMDXComponent=!0;const Rmp={toc:[]},Wmp="wrapper";function Smp(e){let{components:n,...t}=e;return(0,s.yg)(Wmp,(0,p.A)({},Rmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Smp.isMDXComponent=!0;const Bmp={toc:[]},Gmp="wrapper";function Emp(e){let{components:n,...t}=e;return(0,s.yg)(Gmp,(0,p.A)({},Bmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Emp.isMDXComponent=!0;const Omp={toc:[]},Ump="wrapper";function Fmp(e){let{components:n,...t}=e;return(0,s.yg)(Ump,(0,p.A)({},Omp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Fmp.isMDXComponent=!0;const Vmp={toc:[]},qmp="wrapper";function jmp(e){let{components:n,...t}=e;return(0,s.yg)(qmp,(0,p.A)({},Vmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}jmp.isMDXComponent=!0;const Hmp={toc:[]},Ymp="wrapper";function Qmp(e){let{components:n,...t}=e;return(0,s.yg)(Ymp,(0,p.A)({},Hmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Qmp.isMDXComponent=!0;const $mp={toc:[]},Kmp="wrapper";function Jmp(e){let{components:n,...t}=e;return(0,s.yg)(Kmp,(0,p.A)({},$mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Jmp.isMDXComponent=!0;const Zmp={toc:[]},eyp="wrapper";function nyp(e){let{components:n,...t}=e;return(0,s.yg)(eyp,(0,p.A)({},Zmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}nyp.isMDXComponent=!0;const typ={toc:[]},oyp="wrapper";function pyp(e){let{components:n,...t}=e;return(0,s.yg)(oyp,(0,p.A)({},typ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pyp.isMDXComponent=!0;const ryp={toc:[]},syp="wrapper";function cyp(e){let{components:n,...t}=e;return(0,s.yg)(syp,(0,p.A)({},ryp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}cyp.isMDXComponent=!0;const ayp={toc:[]},iyp="wrapper";function lyp(e){let{components:n,...t}=e;return(0,s.yg)(iyp,(0,p.A)({},ayp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}lyp.isMDXComponent=!0;const uyp={toc:[]},myp="wrapper";function yyp(e){let{components:n,...t}=e;return(0,s.yg)(myp,(0,p.A)({},uyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}yyp.isMDXComponent=!0;const dyp={toc:[]},hyp="wrapper";function gyp(e){let{components:n,...t}=e;return(0,s.yg)(hyp,(0,p.A)({},dyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}gyp.isMDXComponent=!0;const fyp={toc:[]},Dyp="wrapper";function Myp(e){let{components:n,...t}=e;return(0,s.yg)(Dyp,(0,p.A)({},fyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Myp.isMDXComponent=!0;const Xyp={toc:[]},_yp="wrapper";function wyp(e){let{components:n,...t}=e;return(0,s.yg)(_yp,(0,p.A)({},Xyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}wyp.isMDXComponent=!0;const Typ={toc:[]},Cyp="wrapper";function xyp(e){let{components:n,...t}=e;return(0,s.yg)(Cyp,(0,p.A)({},Typ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}xyp.isMDXComponent=!0;const Ayp={toc:[]},vyp="wrapper";function Lyp(e){let{components:n,...t}=e;return(0,s.yg)(vyp,(0,p.A)({},Ayp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Lyp.isMDXComponent=!0;const byp={toc:[]},Nyp="wrapper";function kyp(e){let{components:n,...t}=e;return(0,s.yg)(Nyp,(0,p.A)({},byp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kyp.isMDXComponent=!0;const zyp={toc:[]},Pyp="wrapper";function Iyp(e){let{components:n,...t}=e;return(0,s.yg)(Pyp,(0,p.A)({},zyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Iyp.isMDXComponent=!0;const Ryp={toc:[]},Wyp="wrapper";function Syp(e){let{components:n,...t}=e;return(0,s.yg)(Wyp,(0,p.A)({},Ryp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Syp.isMDXComponent=!0;const Byp={toc:[]},Gyp="wrapper";function Eyp(e){let{components:n,...t}=e;return(0,s.yg)(Gyp,(0,p.A)({},Byp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Eyp.isMDXComponent=!0;const Oyp={toc:[]},Uyp="wrapper";function Fyp(e){let{components:n,...t}=e;return(0,s.yg)(Uyp,(0,p.A)({},Oyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Fyp.isMDXComponent=!0;const Vyp={toc:[]},qyp="wrapper";function jyp(e){let{components:n,...t}=e;return(0,s.yg)(qyp,(0,p.A)({},Vyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}jyp.isMDXComponent=!0;const Hyp={toc:[]},Yyp="wrapper";function Qyp(e){let{components:n,...t}=e;return(0,s.yg)(Yyp,(0,p.A)({},Hyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Qyp.isMDXComponent=!0;const $yp={toc:[]},Kyp="wrapper";function Jyp(e){let{components:n,...t}=e;return(0,s.yg)(Kyp,(0,p.A)({},$yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Jyp.isMDXComponent=!0;const Zyp={toc:[]},edp="wrapper";function ndp(e){let{components:n,...t}=e;return(0,s.yg)(edp,(0,p.A)({},Zyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}ndp.isMDXComponent=!0;const tdp={toc:[]},odp="wrapper";function pdp(e){let{components:n,...t}=e;return(0,s.yg)(odp,(0,p.A)({},tdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}pdp.isMDXComponent=!0;const rdp={toc:[]},sdp="wrapper";function cdp(e){let{components:n,...t}=e;return(0,s.yg)(sdp,(0,p.A)({},rdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}cdp.isMDXComponent=!0;const adp={toc:[]},idp="wrapper";function ldp(e){let{components:n,...t}=e;return(0,s.yg)(idp,(0,p.A)({},adp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}ldp.isMDXComponent=!0;const udp={toc:[]},mdp="wrapper";function ydp(e){let{components:n,...t}=e;return(0,s.yg)(mdp,(0,p.A)({},udp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ydp.isMDXComponent=!0;const ddp={toc:[]},hdp="wrapper";function gdp(e){let{components:n,...t}=e;return(0,s.yg)(hdp,(0,p.A)({},ddp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}gdp.isMDXComponent=!0;const fdp={toc:[]},Ddp="wrapper";function Mdp(e){let{components:n,...t}=e;return(0,s.yg)(Ddp,(0,p.A)({},fdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Mdp.isMDXComponent=!0;const Xdp={toc:[]},_dp="wrapper";function wdp(e){let{components:n,...t}=e;return(0,s.yg)(_dp,(0,p.A)({},Xdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}wdp.isMDXComponent=!0;const Tdp={toc:[]},Cdp="wrapper";function xdp(e){let{components:n,...t}=e;return(0,s.yg)(Cdp,(0,p.A)({},Tdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}xdp.isMDXComponent=!0;const Adp={toc:[]},vdp="wrapper";function Ldp(e){let{components:n,...t}=e;return(0,s.yg)(vdp,(0,p.A)({},Adp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Ldp.isMDXComponent=!0;const bdp={toc:[]},Ndp="wrapper";function kdp(e){let{components:n,...t}=e;return(0,s.yg)(Ndp,(0,p.A)({},bdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}kdp.isMDXComponent=!0;const zdp={toc:[]},Pdp="wrapper";function Idp(e){let{components:n,...t}=e;return(0,s.yg)(Pdp,(0,p.A)({},zdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Idp.isMDXComponent=!0;const Rdp={toc:[]},Wdp="wrapper";function Sdp(e){let{components:n,...t}=e;return(0,s.yg)(Wdp,(0,p.A)({},Rdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Sdp.isMDXComponent=!0;const Bdp={toc:[]},Gdp="wrapper";function Edp(e){let{components:n,...t}=e;return(0,s.yg)(Gdp,(0,p.A)({},Bdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Edp.isMDXComponent=!0;const Odp={toc:[]},Udp="wrapper";function Fdp(e){let{components:n,...t}=e;return(0,s.yg)(Udp,(0,p.A)({},Odp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Fdp.isMDXComponent=!0;const Vdp={toc:[]},qdp="wrapper";function jdp(e){let{components:n,...t}=e;return(0,s.yg)(qdp,(0,p.A)({},Vdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}jdp.isMDXComponent=!0;const Hdp={toc:[]},Ydp="wrapper";function Qdp(e){let{components:n,...t}=e;return(0,s.yg)(Ydp,(0,p.A)({},Hdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Qdp.isMDXComponent=!0;const $dp={toc:[]},Kdp="wrapper";function Jdp(e){let{components:n,...t}=e;return(0,s.yg)(Kdp,(0,p.A)({},$dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Jdp.isMDXComponent=!0;const Zdp={toc:[]},ehp="wrapper";function nhp(e){let{components:n,...t}=e;return(0,s.yg)(ehp,(0,p.A)({},Zdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}nhp.isMDXComponent=!0;const thp={toc:[]},ohp="wrapper";function php(e){let{components:n,...t}=e;return(0,s.yg)(ohp,(0,p.A)({},thp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}php.isMDXComponent=!0;const rhp={toc:[]},shp="wrapper";function chp(e){let{components:n,...t}=e;return(0,s.yg)(shp,(0,p.A)({},rhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}chp.isMDXComponent=!0;const ahp={toc:[]},ihp="wrapper";function lhp(e){let{components:n,...t}=e;return(0,s.yg)(ihp,(0,p.A)({},ahp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}lhp.isMDXComponent=!0;const uhp={toc:[]},mhp="wrapper";function yhp(e){let{components:n,...t}=e;return(0,s.yg)(mhp,(0,p.A)({},uhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}yhp.isMDXComponent=!0;const dhp={toc:[]},hhp="wrapper";function ghp(e){let{components:n,...t}=e;return(0,s.yg)(hhp,(0,p.A)({},dhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ghp.isMDXComponent=!0;const fhp={toc:[]},Dhp="wrapper";function Mhp(e){let{components:n,...t}=e;return(0,s.yg)(Dhp,(0,p.A)({},fhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Mhp.isMDXComponent=!0;const Xhp={toc:[]},_hp="wrapper";function whp(e){let{components:n,...t}=e;return(0,s.yg)(_hp,(0,p.A)({},Xhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}whp.isMDXComponent=!0;const Thp={toc:[]},Chp="wrapper";function xhp(e){let{components:n,...t}=e;return(0,s.yg)(Chp,(0,p.A)({},Thp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}xhp.isMDXComponent=!0;const Ahp={toc:[]},vhp="wrapper";function Lhp(e){let{components:n,...t}=e;return(0,s.yg)(vhp,(0,p.A)({},Ahp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Lhp.isMDXComponent=!0;const bhp={toc:[]},Nhp="wrapper";function khp(e){let{components:n,...t}=e;return(0,s.yg)(Nhp,(0,p.A)({},bhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}khp.isMDXComponent=!0;const zhp={toc:[]},Php="wrapper";function Ihp(e){let{components:n,...t}=e;return(0,s.yg)(Php,(0,p.A)({},zhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ihp.isMDXComponent=!0;const Rhp={toc:[]},Whp="wrapper";function Shp(e){let{components:n,...t}=e;return(0,s.yg)(Whp,(0,p.A)({},Rhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Shp.isMDXComponent=!0;const Bhp={toc:[]},Ghp="wrapper";function Ehp(e){let{components:n,...t}=e;return(0,s.yg)(Ghp,(0,p.A)({},Bhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Ehp.isMDXComponent=!0;const Ohp={toc:[]},Uhp="wrapper";function Fhp(e){let{components:n,...t}=e;return(0,s.yg)(Uhp,(0,p.A)({},Ohp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Fhp.isMDXComponent=!0;const Vhp={toc:[]},qhp="wrapper";function jhp(e){let{components:n,...t}=e;return(0,s.yg)(qhp,(0,p.A)({},Vhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jhp.isMDXComponent=!0;const Hhp={toc:[]},Yhp="wrapper";function Qhp(e){let{components:n,...t}=e;return(0,s.yg)(Yhp,(0,p.A)({},Hhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qhp.isMDXComponent=!0;const $hp={toc:[]},Khp="wrapper";function Jhp(e){let{components:n,...t}=e;return(0,s.yg)(Khp,(0,p.A)({},$hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Jhp.isMDXComponent=!0;const Zhp={toc:[]},egp="wrapper";function ngp(e){let{components:n,...t}=e;return(0,s.yg)(egp,(0,p.A)({},Zhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ngp.isMDXComponent=!0;const tgp={toc:[]},ogp="wrapper";function pgp(e){let{components:n,...t}=e;return(0,s.yg)(ogp,(0,p.A)({},tgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}pgp.isMDXComponent=!0;const rgp={toc:[]},sgp="wrapper";function cgp(e){let{components:n,...t}=e;return(0,s.yg)(sgp,(0,p.A)({},rgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}cgp.isMDXComponent=!0;const agp={toc:[]},igp="wrapper";function lgp(e){let{components:n,...t}=e;return(0,s.yg)(igp,(0,p.A)({},agp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lgp.isMDXComponent=!0;const ugp={toc:[]},mgp="wrapper";function ygp(e){let{components:n,...t}=e;return(0,s.yg)(mgp,(0,p.A)({},ugp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ygp.isMDXComponent=!0;const dgp={toc:[]},hgp="wrapper";function ggp(e){let{components:n,...t}=e;return(0,s.yg)(hgp,(0,p.A)({},dgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}ggp.isMDXComponent=!0;const fgp={toc:[]},Dgp="wrapper";function Mgp(e){let{components:n,...t}=e;return(0,s.yg)(Dgp,(0,p.A)({},fgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Mgp.isMDXComponent=!0;const Xgp={toc:[]},_gp="wrapper";function wgp(e){let{components:n,...t}=e;return(0,s.yg)(_gp,(0,p.A)({},Xgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wgp.isMDXComponent=!0;const Tgp={toc:[]},Cgp="wrapper";function xgp(e){let{components:n,...t}=e;return(0,s.yg)(Cgp,(0,p.A)({},Tgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}xgp.isMDXComponent=!0;const Agp={toc:[]},vgp="wrapper";function Lgp(e){let{components:n,...t}=e;return(0,s.yg)(vgp,(0,p.A)({},Agp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Lgp.isMDXComponent=!0;const bgp={toc:[]},Ngp="wrapper";function kgp(e){let{components:n,...t}=e;return(0,s.yg)(Ngp,(0,p.A)({},bgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}kgp.isMDXComponent=!0;const zgp={toc:[]},Pgp="wrapper";function Igp(e){let{components:n,...t}=e;return(0,s.yg)(Pgp,(0,p.A)({},zgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Igp.isMDXComponent=!0;const Rgp={toc:[]},Wgp="wrapper";function Sgp(e){let{components:n,...t}=e;return(0,s.yg)(Wgp,(0,p.A)({},Rgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Sgp.isMDXComponent=!0;const Bgp={toc:[]},Ggp="wrapper";function Egp(e){let{components:n,...t}=e;return(0,s.yg)(Ggp,(0,p.A)({},Bgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Egp.isMDXComponent=!0;const Ogp={toc:[]},Ugp="wrapper";function Fgp(e){let{components:n,...t}=e;return(0,s.yg)(Ugp,(0,p.A)({},Ogp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Fgp.isMDXComponent=!0;const Vgp={toc:[]},qgp="wrapper";function jgp(e){let{components:n,...t}=e;return(0,s.yg)(qgp,(0,p.A)({},Vgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}jgp.isMDXComponent=!0;const Hgp={toc:[]},Ygp="wrapper";function Qgp(e){let{components:n,...t}=e;return(0,s.yg)(Ygp,(0,p.A)({},Hgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Qgp.isMDXComponent=!0;const $gp={toc:[]},Kgp="wrapper";function Jgp(e){let{components:n,...t}=e;return(0,s.yg)(Kgp,(0,p.A)({},$gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Jgp.isMDXComponent=!0;const Zgp={toc:[]},efp="wrapper";function nfp(e){let{components:n,...t}=e;return(0,s.yg)(efp,(0,p.A)({},Zgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}nfp.isMDXComponent=!0;const tfp={toc:[]},ofp="wrapper";function pfp(e){let{components:n,...t}=e;return(0,s.yg)(ofp,(0,p.A)({},tfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}pfp.isMDXComponent=!0;const rfp={toc:[]},sfp="wrapper";function cfp(e){let{components:n,...t}=e;return(0,s.yg)(sfp,(0,p.A)({},rfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}cfp.isMDXComponent=!0;const afp={toc:[]},ifp="wrapper";function lfp(e){let{components:n,...t}=e;return(0,s.yg)(ifp,(0,p.A)({},afp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lfp.isMDXComponent=!0;const ufp={toc:[]},mfp="wrapper";function yfp(e){let{components:n,...t}=e;return(0,s.yg)(mfp,(0,p.A)({},ufp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}yfp.isMDXComponent=!0;const dfp={toc:[]},hfp="wrapper";function gfp(e){let{components:n,...t}=e;return(0,s.yg)(hfp,(0,p.A)({},dfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}gfp.isMDXComponent=!0;const ffp={toc:[]},Dfp="wrapper";function Mfp(e){let{components:n,...t}=e;return(0,s.yg)(Dfp,(0,p.A)({},ffp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Mfp.isMDXComponent=!0;const Xfp={toc:[]},_fp="wrapper";function wfp(e){let{components:n,...t}=e;return(0,s.yg)(_fp,(0,p.A)({},Xfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}wfp.isMDXComponent=!0;const Tfp={toc:[]},Cfp="wrapper";function xfp(e){let{components:n,...t}=e;return(0,s.yg)(Cfp,(0,p.A)({},Tfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}xfp.isMDXComponent=!0;const Afp={toc:[]},vfp="wrapper";function Lfp(e){let{components:n,...t}=e;return(0,s.yg)(vfp,(0,p.A)({},Afp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Lfp.isMDXComponent=!0;const bfp={toc:[]},Nfp="wrapper";function kfp(e){let{components:n,...t}=e;return(0,s.yg)(Nfp,(0,p.A)({},bfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kfp.isMDXComponent=!0;const zfp={toc:[]},Pfp="wrapper";function Ifp(e){let{components:n,...t}=e;return(0,s.yg)(Pfp,(0,p.A)({},zfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Ifp.isMDXComponent=!0;const Rfp={toc:[]},Wfp="wrapper";function Sfp(e){let{components:n,...t}=e;return(0,s.yg)(Wfp,(0,p.A)({},Rfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Sfp.isMDXComponent=!0;const Bfp={toc:[]},Gfp="wrapper";function Efp(e){let{components:n,...t}=e;return(0,s.yg)(Gfp,(0,p.A)({},Bfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Efp.isMDXComponent=!0;const Ofp={toc:[]},Ufp="wrapper";function Ffp(e){let{components:n,...t}=e;return(0,s.yg)(Ufp,(0,p.A)({},Ofp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Ffp.isMDXComponent=!0;const Vfp={toc:[]},qfp="wrapper";function jfp(e){let{components:n,...t}=e;return(0,s.yg)(qfp,(0,p.A)({},Vfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}jfp.isMDXComponent=!0;const Hfp={toc:[]},Yfp="wrapper";function Qfp(e){let{components:n,...t}=e;return(0,s.yg)(Yfp,(0,p.A)({},Hfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Qfp.isMDXComponent=!0;const $fp={toc:[]},Kfp="wrapper";function Jfp(e){let{components:n,...t}=e;return(0,s.yg)(Kfp,(0,p.A)({},$fp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Jfp.isMDXComponent=!0;const Zfp={toc:[]},eDp="wrapper";function nDp(e){let{components:n,...t}=e;return(0,s.yg)(eDp,(0,p.A)({},Zfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nDp.isMDXComponent=!0;const tDp={toc:[]},oDp="wrapper";function pDp(e){let{components:n,...t}=e;return(0,s.yg)(oDp,(0,p.A)({},tDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}pDp.isMDXComponent=!0;const rDp={toc:[]},sDp="wrapper";function cDp(e){let{components:n,...t}=e;return(0,s.yg)(sDp,(0,p.A)({},rDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}cDp.isMDXComponent=!0;const aDp={toc:[]},iDp="wrapper";function lDp(e){let{components:n,...t}=e;return(0,s.yg)(iDp,(0,p.A)({},aDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}lDp.isMDXComponent=!0;const uDp={toc:[]},mDp="wrapper";function yDp(e){let{components:n,...t}=e;return(0,s.yg)(mDp,(0,p.A)({},uDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}yDp.isMDXComponent=!0;const dDp={toc:[]},hDp="wrapper";function gDp(e){let{components:n,...t}=e;return(0,s.yg)(hDp,(0,p.A)({},dDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}gDp.isMDXComponent=!0;const fDp={toc:[]},DDp="wrapper";function MDp(e){let{components:n,...t}=e;return(0,s.yg)(DDp,(0,p.A)({},fDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}MDp.isMDXComponent=!0;const XDp={toc:[]},_Dp="wrapper";function wDp(e){let{components:n,...t}=e;return(0,s.yg)(_Dp,(0,p.A)({},XDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}wDp.isMDXComponent=!0;const TDp={toc:[]},CDp="wrapper";function xDp(e){let{components:n,...t}=e;return(0,s.yg)(CDp,(0,p.A)({},TDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}xDp.isMDXComponent=!0;const ADp={toc:[]},vDp="wrapper";function LDp(e){let{components:n,...t}=e;return(0,s.yg)(vDp,(0,p.A)({},ADp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}LDp.isMDXComponent=!0;const bDp={toc:[]},NDp="wrapper";function kDp(e){let{components:n,...t}=e;return(0,s.yg)(NDp,(0,p.A)({},bDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}kDp.isMDXComponent=!0;const zDp={toc:[]},PDp="wrapper";function IDp(e){let{components:n,...t}=e;return(0,s.yg)(PDp,(0,p.A)({},zDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}IDp.isMDXComponent=!0;const RDp={toc:[]},WDp="wrapper";function SDp(e){let{components:n,...t}=e;return(0,s.yg)(WDp,(0,p.A)({},RDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}SDp.isMDXComponent=!0;const BDp={toc:[]},GDp="wrapper";function EDp(e){let{components:n,...t}=e;return(0,s.yg)(GDp,(0,p.A)({},BDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}EDp.isMDXComponent=!0;const ODp={toc:[]},UDp="wrapper";function FDp(e){let{components:n,...t}=e;return(0,s.yg)(UDp,(0,p.A)({},ODp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}FDp.isMDXComponent=!0;const VDp={toc:[]},qDp="wrapper";function jDp(e){let{components:n,...t}=e;return(0,s.yg)(qDp,(0,p.A)({},VDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}jDp.isMDXComponent=!0;const HDp={toc:[]},YDp="wrapper";function QDp(e){let{components:n,...t}=e;return(0,s.yg)(YDp,(0,p.A)({},HDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}QDp.isMDXComponent=!0;const $Dp={toc:[]},KDp="wrapper";function JDp(e){let{components:n,...t}=e;return(0,s.yg)(KDp,(0,p.A)({},$Dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}JDp.isMDXComponent=!0;const ZDp={toc:[]},eMp="wrapper";function nMp(e){let{components:n,...t}=e;return(0,s.yg)(eMp,(0,p.A)({},ZDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}nMp.isMDXComponent=!0;const tMp={toc:[]},oMp="wrapper";function pMp(e){let{components:n,...t}=e;return(0,s.yg)(oMp,(0,p.A)({},tMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}pMp.isMDXComponent=!0;const rMp={toc:[]},sMp="wrapper";function cMp(e){let{components:n,...t}=e;return(0,s.yg)(sMp,(0,p.A)({},rMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cMp.isMDXComponent=!0;const aMp={toc:[]},iMp="wrapper";function lMp(e){let{components:n,...t}=e;return(0,s.yg)(iMp,(0,p.A)({},aMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lMp.isMDXComponent=!0;const uMp={toc:[]},mMp="wrapper";function yMp(e){let{components:n,...t}=e;return(0,s.yg)(mMp,(0,p.A)({},uMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}yMp.isMDXComponent=!0;const dMp={toc:[]},hMp="wrapper";function gMp(e){let{components:n,...t}=e;return(0,s.yg)(hMp,(0,p.A)({},dMp,t,{components:n,mdxType:"MDXLayout"}))}gMp.isMDXComponent=!0;const fMp={toc:[]},DMp="wrapper";function MMp(e){let{components:n,...t}=e;return(0,s.yg)(DMp,(0,p.A)({},fMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}MMp.isMDXComponent=!0;const XMp={toc:[]},_Mp="wrapper";function wMp(e){let{components:n,...t}=e;return(0,s.yg)(_Mp,(0,p.A)({},XMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wMp.isMDXComponent=!0;const TMp={toc:[]},CMp="wrapper";function xMp(e){let{components:n,...t}=e;return(0,s.yg)(CMp,(0,p.A)({},TMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}xMp.isMDXComponent=!0;const AMp={toc:[]},vMp="wrapper";function LMp(e){let{components:n,...t}=e;return(0,s.yg)(vMp,(0,p.A)({},AMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}LMp.isMDXComponent=!0;const bMp={toc:[]},NMp="wrapper";function kMp(e){let{components:n,...t}=e;return(0,s.yg)(NMp,(0,p.A)({},bMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}kMp.isMDXComponent=!0;const zMp={toc:[]},PMp="wrapper";function IMp(e){let{components:n,...t}=e;return(0,s.yg)(PMp,(0,p.A)({},zMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}IMp.isMDXComponent=!0;const RMp={toc:[]},WMp="wrapper";function SMp(e){let{components:n,...t}=e;return(0,s.yg)(WMp,(0,p.A)({},RMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}SMp.isMDXComponent=!0;const BMp={toc:[]},GMp="wrapper";function EMp(e){let{components:n,...t}=e;return(0,s.yg)(GMp,(0,p.A)({},BMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}EMp.isMDXComponent=!0;const OMp={toc:[]},UMp="wrapper";function FMp(e){let{components:n,...t}=e;return(0,s.yg)(UMp,(0,p.A)({},OMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}FMp.isMDXComponent=!0;const VMp={toc:[]},qMp="wrapper";function jMp(e){let{components:n,...t}=e;return(0,s.yg)(qMp,(0,p.A)({},VMp,t,{components:n,mdxType:"MDXLayout"}))}jMp.isMDXComponent=!0;const HMp={toc:[]},YMp="wrapper";function QMp(e){let{components:n,...t}=e;return(0,s.yg)(YMp,(0,p.A)({},HMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}QMp.isMDXComponent=!0;const $Mp={toc:[]},KMp="wrapper";function JMp(e){let{components:n,...t}=e;return(0,s.yg)(KMp,(0,p.A)({},$Mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}JMp.isMDXComponent=!0;const ZMp={toc:[]},eXp="wrapper";function nXp(e){let{components:n,...t}=e;return(0,s.yg)(eXp,(0,p.A)({},ZMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nXp.isMDXComponent=!0;const tXp={toc:[]},oXp="wrapper";function pXp(e){let{components:n,...t}=e;return(0,s.yg)(oXp,(0,p.A)({},tXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}pXp.isMDXComponent=!0;const rXp={toc:[]},sXp="wrapper";function cXp(e){let{components:n,...t}=e;return(0,s.yg)(sXp,(0,p.A)({},rXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}cXp.isMDXComponent=!0;const aXp={toc:[]},iXp="wrapper";function lXp(e){let{components:n,...t}=e;return(0,s.yg)(iXp,(0,p.A)({},aXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}lXp.isMDXComponent=!0;const uXp={toc:[]},mXp="wrapper";function yXp(e){let{components:n,...t}=e;return(0,s.yg)(mXp,(0,p.A)({},uXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}yXp.isMDXComponent=!0;const dXp={toc:[]},hXp="wrapper";function gXp(e){let{components:n,...t}=e;return(0,s.yg)(hXp,(0,p.A)({},dXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}gXp.isMDXComponent=!0;const fXp={toc:[]},DXp="wrapper";function MXp(e){let{components:n,...t}=e;return(0,s.yg)(DXp,(0,p.A)({},fXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}MXp.isMDXComponent=!0;const XXp={toc:[]},_Xp="wrapper";function wXp(e){let{components:n,...t}=e;return(0,s.yg)(_Xp,(0,p.A)({},XXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}wXp.isMDXComponent=!0;const TXp={toc:[]},CXp="wrapper";function xXp(e){let{components:n,...t}=e;return(0,s.yg)(CXp,(0,p.A)({},TXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}xXp.isMDXComponent=!0;const AXp={toc:[]},vXp="wrapper";function LXp(e){let{components:n,...t}=e;return(0,s.yg)(vXp,(0,p.A)({},AXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}LXp.isMDXComponent=!0;const bXp={toc:[]},NXp="wrapper";function kXp(e){let{components:n,...t}=e;return(0,s.yg)(NXp,(0,p.A)({},bXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}kXp.isMDXComponent=!0;const zXp={toc:[]},PXp="wrapper";function IXp(e){let{components:n,...t}=e;return(0,s.yg)(PXp,(0,p.A)({},zXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}IXp.isMDXComponent=!0;const RXp={toc:[]},WXp="wrapper";function SXp(e){let{components:n,...t}=e;return(0,s.yg)(WXp,(0,p.A)({},RXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}SXp.isMDXComponent=!0;const BXp={toc:[]},GXp="wrapper";function EXp(e){let{components:n,...t}=e;return(0,s.yg)(GXp,(0,p.A)({},BXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}EXp.isMDXComponent=!0;const OXp={toc:[]},UXp="wrapper";function FXp(e){let{components:n,...t}=e;return(0,s.yg)(UXp,(0,p.A)({},OXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}FXp.isMDXComponent=!0;const VXp={toc:[]},qXp="wrapper";function jXp(e){let{components:n,...t}=e;return(0,s.yg)(qXp,(0,p.A)({},VXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}jXp.isMDXComponent=!0;const HXp={toc:[]},YXp="wrapper";function QXp(e){let{components:n,...t}=e;return(0,s.yg)(YXp,(0,p.A)({},HXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}QXp.isMDXComponent=!0;const $Xp={toc:[]},KXp="wrapper";function JXp(e){let{components:n,...t}=e;return(0,s.yg)(KXp,(0,p.A)({},$Xp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}JXp.isMDXComponent=!0;const ZXp={toc:[]},e_p="wrapper";function n_p(e){let{components:n,...t}=e;return(0,s.yg)(e_p,(0,p.A)({},ZXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}n_p.isMDXComponent=!0;const t_p={toc:[]},o_p="wrapper";function p_p(e){let{components:n,...t}=e;return(0,s.yg)(o_p,(0,p.A)({},t_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}p_p.isMDXComponent=!0;const r_p={toc:[]},s_p="wrapper";function c_p(e){let{components:n,...t}=e;return(0,s.yg)(s_p,(0,p.A)({},r_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}c_p.isMDXComponent=!0;const a_p={toc:[]},i_p="wrapper";function l_p(e){let{components:n,...t}=e;return(0,s.yg)(i_p,(0,p.A)({},a_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}l_p.isMDXComponent=!0;const u_p={toc:[]},m_p="wrapper";function y_p(e){let{components:n,...t}=e;return(0,s.yg)(m_p,(0,p.A)({},u_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}y_p.isMDXComponent=!0;const d_p={toc:[]},h_p="wrapper";function g_p(e){let{components:n,...t}=e;return(0,s.yg)(h_p,(0,p.A)({},d_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}g_p.isMDXComponent=!0;const f_p={toc:[]},D_p="wrapper";function M_p(e){let{components:n,...t}=e;return(0,s.yg)(D_p,(0,p.A)({},f_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}M_p.isMDXComponent=!0;const X_p={toc:[]},__p="wrapper";function w_p(e){let{components:n,...t}=e;return(0,s.yg)(__p,(0,p.A)({},X_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}w_p.isMDXComponent=!0;const T_p={toc:[]},C_p="wrapper";function x_p(e){let{components:n,...t}=e;return(0,s.yg)(C_p,(0,p.A)({},T_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}x_p.isMDXComponent=!0;const A_p={toc:[]},v_p="wrapper";function L_p(e){let{components:n,...t}=e;return(0,s.yg)(v_p,(0,p.A)({},A_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}L_p.isMDXComponent=!0;const b_p={toc:[]},N_p="wrapper";function k_p(e){let{components:n,...t}=e;return(0,s.yg)(N_p,(0,p.A)({},b_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}k_p.isMDXComponent=!0;const z_p={toc:[]},P_p="wrapper";function I_p(e){let{components:n,...t}=e;return(0,s.yg)(P_p,(0,p.A)({},z_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}I_p.isMDXComponent=!0;const R_p={toc:[]},W_p="wrapper";function S_p(e){let{components:n,...t}=e;return(0,s.yg)(W_p,(0,p.A)({},R_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}S_p.isMDXComponent=!0;const B_p={toc:[]},G_p="wrapper";function E_p(e){let{components:n,...t}=e;return(0,s.yg)(G_p,(0,p.A)({},B_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}E_p.isMDXComponent=!0;const O_p={toc:[]},U_p="wrapper";function F_p(e){let{components:n,...t}=e;return(0,s.yg)(U_p,(0,p.A)({},O_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}F_p.isMDXComponent=!0;const V_p={toc:[]},q_p="wrapper";function j_p(e){let{components:n,...t}=e;return(0,s.yg)(q_p,(0,p.A)({},V_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}j_p.isMDXComponent=!0;const H_p={toc:[]},Y_p="wrapper";function Q_p(e){let{components:n,...t}=e;return(0,s.yg)(Y_p,(0,p.A)({},H_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Q_p.isMDXComponent=!0;const $_p={toc:[]},K_p="wrapper";function J_p(e){let{components:n,...t}=e;return(0,s.yg)(K_p,(0,p.A)({},$_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}J_p.isMDXComponent=!0;const Z_p={toc:[]},ewp="wrapper";function nwp(e){let{components:n,...t}=e;return(0,s.yg)(ewp,(0,p.A)({},Z_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}nwp.isMDXComponent=!0;const twp={toc:[]},owp="wrapper";function pwp(e){let{components:n,...t}=e;return(0,s.yg)(owp,(0,p.A)({},twp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}pwp.isMDXComponent=!0;const rwp={toc:[]},swp="wrapper";function cwp(e){let{components:n,...t}=e;return(0,s.yg)(swp,(0,p.A)({},rwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}cwp.isMDXComponent=!0;const awp={toc:[]},iwp="wrapper";function lwp(e){let{components:n,...t}=e;return(0,s.yg)(iwp,(0,p.A)({},awp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}lwp.isMDXComponent=!0;const uwp={toc:[]},mwp="wrapper";function ywp(e){let{components:n,...t}=e;return(0,s.yg)(mwp,(0,p.A)({},uwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}ywp.isMDXComponent=!0;const dwp={toc:[]},hwp="wrapper";function gwp(e){let{components:n,...t}=e;return(0,s.yg)(hwp,(0,p.A)({},dwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}gwp.isMDXComponent=!0;const fwp={toc:[]},Dwp="wrapper";function Mwp(e){let{components:n,...t}=e;return(0,s.yg)(Dwp,(0,p.A)({},fwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Mwp.isMDXComponent=!0;const Xwp={toc:[]},_wp="wrapper";function wwp(e){let{components:n,...t}=e;return(0,s.yg)(_wp,(0,p.A)({},Xwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wwp.isMDXComponent=!0;const Twp={toc:[]},Cwp="wrapper";function xwp(e){let{components:n,...t}=e;return(0,s.yg)(Cwp,(0,p.A)({},Twp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}xwp.isMDXComponent=!0;const Awp={toc:[]},vwp="wrapper";function Lwp(e){let{components:n,...t}=e;return(0,s.yg)(vwp,(0,p.A)({},Awp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Lwp.isMDXComponent=!0;const bwp={toc:[]},Nwp="wrapper";function kwp(e){let{components:n,...t}=e;return(0,s.yg)(Nwp,(0,p.A)({},bwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kwp.isMDXComponent=!0;const zwp={toc:[]},Pwp="wrapper";function Iwp(e){let{components:n,...t}=e;return(0,s.yg)(Pwp,(0,p.A)({},zwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Iwp.isMDXComponent=!0;const Rwp={toc:[]},Wwp="wrapper";function Swp(e){let{components:n,...t}=e;return(0,s.yg)(Wwp,(0,p.A)({},Rwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Swp.isMDXComponent=!0;const Bwp={toc:[]},Gwp="wrapper";function Ewp(e){let{components:n,...t}=e;return(0,s.yg)(Gwp,(0,p.A)({},Bwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Ewp.isMDXComponent=!0;const Owp={toc:[]},Uwp="wrapper";function Fwp(e){let{components:n,...t}=e;return(0,s.yg)(Uwp,(0,p.A)({},Owp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Fwp.isMDXComponent=!0;const Vwp={toc:[]},qwp="wrapper";function jwp(e){let{components:n,...t}=e;return(0,s.yg)(qwp,(0,p.A)({},Vwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jwp.isMDXComponent=!0;const Hwp={toc:[]},Ywp="wrapper";function Qwp(e){let{components:n,...t}=e;return(0,s.yg)(Ywp,(0,p.A)({},Hwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Qwp.isMDXComponent=!0;const $wp={toc:[]},Kwp="wrapper";function Jwp(e){let{components:n,...t}=e;return(0,s.yg)(Kwp,(0,p.A)({},$wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jwp.isMDXComponent=!0;const Zwp={toc:[]},eTp="wrapper";function nTp(e){let{components:n,...t}=e;return(0,s.yg)(eTp,(0,p.A)({},Zwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nTp.isMDXComponent=!0;const tTp={toc:[]},oTp="wrapper";function pTp(e){let{components:n,...t}=e;return(0,s.yg)(oTp,(0,p.A)({},tTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pTp.isMDXComponent=!0;const rTp={toc:[]},sTp="wrapper";function cTp(e){let{components:n,...t}=e;return(0,s.yg)(sTp,(0,p.A)({},rTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cTp.isMDXComponent=!0;const aTp={toc:[]},iTp="wrapper";function lTp(e){let{components:n,...t}=e;return(0,s.yg)(iTp,(0,p.A)({},aTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lTp.isMDXComponent=!0;const uTp={toc:[]},mTp="wrapper";function yTp(e){let{components:n,...t}=e;return(0,s.yg)(mTp,(0,p.A)({},uTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}yTp.isMDXComponent=!0;const dTp={toc:[]},hTp="wrapper";function gTp(e){let{components:n,...t}=e;return(0,s.yg)(hTp,(0,p.A)({},dTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gTp.isMDXComponent=!0;const fTp={toc:[]},DTp="wrapper";function MTp(e){let{components:n,...t}=e;return(0,s.yg)(DTp,(0,p.A)({},fTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}MTp.isMDXComponent=!0;const XTp={toc:[]},_Tp="wrapper";function wTp(e){let{components:n,...t}=e;return(0,s.yg)(_Tp,(0,p.A)({},XTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wTp.isMDXComponent=!0;const TTp={toc:[]},CTp="wrapper";function xTp(e){let{components:n,...t}=e;return(0,s.yg)(CTp,(0,p.A)({},TTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find a node by its key."))}xTp.isMDXComponent=!0;const ATp={toc:[]},vTp="wrapper";function LTp(e){let{components:n,...t}=e;return(0,s.yg)(vTp,(0,p.A)({},ATp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The key of the node."))}LTp.isMDXComponent=!0;const bTp={toc:[]},NTp="wrapper";function kTp(e){let{components:n,...t}=e;return(0,s.yg)(NTp,(0,p.A)({},bTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}kTp.isMDXComponent=!0;const zTp={toc:[]},PTp="wrapper";function ITp(e){let{components:n,...t}=e;return(0,s.yg)(PTp,(0,p.A)({},zTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ITp.isMDXComponent=!0;const RTp={toc:[]},WTp="wrapper";function STp(e){let{components:n,...t}=e;return(0,s.yg)(WTp,(0,p.A)({},RTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}STp.isMDXComponent=!0;const BTp={toc:[]},GTp="wrapper";function ETp(e){let{components:n,...t}=e;return(0,s.yg)(GTp,(0,p.A)({},BTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ETp.isMDXComponent=!0;const OTp={toc:[]},UTp="wrapper";function FTp(e){let{components:n,...t}=e;return(0,s.yg)(UTp,(0,p.A)({},OTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}FTp.isMDXComponent=!0;const VTp={toc:[]},qTp="wrapper";function jTp(e){let{components:n,...t}=e;return(0,s.yg)(qTp,(0,p.A)({},VTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}jTp.isMDXComponent=!0;const HTp={toc:[]},YTp="wrapper";function QTp(e){let{components:n,...t}=e;return(0,s.yg)(YTp,(0,p.A)({},HTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}QTp.isMDXComponent=!0;const $Tp={toc:[]},KTp="wrapper";function JTp(e){let{components:n,...t}=e;return(0,s.yg)(KTp,(0,p.A)({},$Tp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}JTp.isMDXComponent=!0;const ZTp={toc:[]},eCp="wrapper";function nCp(e){let{components:n,...t}=e;return(0,s.yg)(eCp,(0,p.A)({},ZTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}nCp.isMDXComponent=!0;const tCp={toc:[]},oCp="wrapper";function pCp(e){let{components:n,...t}=e;return(0,s.yg)(oCp,(0,p.A)({},tCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}pCp.isMDXComponent=!0;const rCp={toc:[]},sCp="wrapper";function cCp(e){let{components:n,...t}=e;return(0,s.yg)(sCp,(0,p.A)({},rCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}cCp.isMDXComponent=!0;const aCp={toc:[]},iCp="wrapper";function lCp(e){let{components:n,...t}=e;return(0,s.yg)(iCp,(0,p.A)({},aCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}lCp.isMDXComponent=!0;const uCp={toc:[]},mCp="wrapper";function yCp(e){let{components:n,...t}=e;return(0,s.yg)(mCp,(0,p.A)({},uCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}yCp.isMDXComponent=!0;const dCp={toc:[]},hCp="wrapper";function gCp(e){let{components:n,...t}=e;return(0,s.yg)(hCp,(0,p.A)({},dCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}gCp.isMDXComponent=!0;const fCp={toc:[]},DCp="wrapper";function MCp(e){let{components:n,...t}=e;return(0,s.yg)(DCp,(0,p.A)({},fCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}MCp.isMDXComponent=!0;const XCp={toc:[]},_Cp="wrapper";function wCp(e){let{components:n,...t}=e;return(0,s.yg)(_Cp,(0,p.A)({},XCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}wCp.isMDXComponent=!0;const TCp={toc:[]},CCp="wrapper";function xCp(e){let{components:n,...t}=e;return(0,s.yg)(CCp,(0,p.A)({},TCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}xCp.isMDXComponent=!0;const ACp={toc:[]},vCp="wrapper";function LCp(e){let{components:n,...t}=e;return(0,s.yg)(vCp,(0,p.A)({},ACp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}LCp.isMDXComponent=!0;const bCp={toc:[]},NCp="wrapper";function kCp(e){let{components:n,...t}=e;return(0,s.yg)(NCp,(0,p.A)({},bCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}kCp.isMDXComponent=!0;const zCp={toc:[]},PCp="wrapper";function ICp(e){let{components:n,...t}=e;return(0,s.yg)(PCp,(0,p.A)({},zCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}ICp.isMDXComponent=!0;const RCp={toc:[]},WCp="wrapper";function SCp(e){let{components:n,...t}=e;return(0,s.yg)(WCp,(0,p.A)({},RCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}SCp.isMDXComponent=!0;const BCp={toc:[]},GCp="wrapper";function ECp(e){let{components:n,...t}=e;return(0,s.yg)(GCp,(0,p.A)({},BCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}ECp.isMDXComponent=!0;const OCp={toc:[]},UCp="wrapper";function FCp(e){let{components:n,...t}=e;return(0,s.yg)(UCp,(0,p.A)({},OCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}FCp.isMDXComponent=!0;const VCp={toc:[]},qCp="wrapper";function jCp(e){let{components:n,...t}=e;return(0,s.yg)(qCp,(0,p.A)({},VCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}jCp.isMDXComponent=!0;const HCp={toc:[]},YCp="wrapper";function QCp(e){let{components:n,...t}=e;return(0,s.yg)(YCp,(0,p.A)({},HCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}QCp.isMDXComponent=!0;const $Cp={toc:[]},KCp="wrapper";function JCp(e){let{components:n,...t}=e;return(0,s.yg)(KCp,(0,p.A)({},$Cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}JCp.isMDXComponent=!0;const ZCp={toc:[]},exp="wrapper";function nxp(e){let{components:n,...t}=e;return(0,s.yg)(exp,(0,p.A)({},ZCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}nxp.isMDXComponent=!0;const txp={toc:[]},oxp="wrapper";function pxp(e){let{components:n,...t}=e;return(0,s.yg)(oxp,(0,p.A)({},txp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}pxp.isMDXComponent=!0;const rxp={toc:[]},sxp="wrapper";function cxp(e){let{components:n,...t}=e;return(0,s.yg)(sxp,(0,p.A)({},rxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}cxp.isMDXComponent=!0;const axp={toc:[]},ixp="wrapper";function lxp(e){let{components:n,...t}=e;return(0,s.yg)(ixp,(0,p.A)({},axp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}lxp.isMDXComponent=!0;const uxp={toc:[]},mxp="wrapper";function yxp(e){let{components:n,...t}=e;return(0,s.yg)(mxp,(0,p.A)({},uxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}yxp.isMDXComponent=!0;const dxp={toc:[]},hxp="wrapper";function gxp(e){let{components:n,...t}=e;return(0,s.yg)(hxp,(0,p.A)({},dxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}gxp.isMDXComponent=!0;const fxp={toc:[]},Dxp="wrapper";function Mxp(e){let{components:n,...t}=e;return(0,s.yg)(Dxp,(0,p.A)({},fxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Mxp.isMDXComponent=!0;const Xxp={toc:[]},_xp="wrapper";function wxp(e){let{components:n,...t}=e;return(0,s.yg)(_xp,(0,p.A)({},Xxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}wxp.isMDXComponent=!0;const Txp={toc:[]},Cxp="wrapper";function xxp(e){let{components:n,...t}=e;return(0,s.yg)(Cxp,(0,p.A)({},Txp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}xxp.isMDXComponent=!0;const Axp={toc:[]},vxp="wrapper";function Lxp(e){let{components:n,...t}=e;return(0,s.yg)(vxp,(0,p.A)({},Axp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Lxp.isMDXComponent=!0;const bxp={toc:[]},Nxp="wrapper";function kxp(e){let{components:n,...t}=e;return(0,s.yg)(Nxp,(0,p.A)({},bxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kxp.isMDXComponent=!0;const zxp={toc:[]},Pxp="wrapper";function Ixp(e){let{components:n,...t}=e;return(0,s.yg)(Pxp,(0,p.A)({},zxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Ixp.isMDXComponent=!0;const Rxp={toc:[]},Wxp="wrapper";function Sxp(e){let{components:n,...t}=e;return(0,s.yg)(Wxp,(0,p.A)({},Rxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Sxp.isMDXComponent=!0;const Bxp={toc:[]},Gxp="wrapper";function Exp(e){let{components:n,...t}=e;return(0,s.yg)(Gxp,(0,p.A)({},Bxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Exp.isMDXComponent=!0;const Oxp={toc:[]},Uxp="wrapper";function Fxp(e){let{components:n,...t}=e;return(0,s.yg)(Uxp,(0,p.A)({},Oxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Fxp.isMDXComponent=!0;const Vxp={toc:[]},qxp="wrapper";function jxp(e){let{components:n,...t}=e;return(0,s.yg)(qxp,(0,p.A)({},Vxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}jxp.isMDXComponent=!0;const Hxp={toc:[]},Yxp="wrapper";function Qxp(e){let{components:n,...t}=e;return(0,s.yg)(Yxp,(0,p.A)({},Hxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Qxp.isMDXComponent=!0;const $xp={toc:[]},Kxp="wrapper";function Jxp(e){let{components:n,...t}=e;return(0,s.yg)(Kxp,(0,p.A)({},$xp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Jxp.isMDXComponent=!0;const Zxp={toc:[]},eAp="wrapper";function nAp(e){let{components:n,...t}=e;return(0,s.yg)(eAp,(0,p.A)({},Zxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}nAp.isMDXComponent=!0;const tAp={toc:[]},oAp="wrapper";function pAp(e){let{components:n,...t}=e;return(0,s.yg)(oAp,(0,p.A)({},tAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}pAp.isMDXComponent=!0;const rAp={toc:[]},sAp="wrapper";function cAp(e){let{components:n,...t}=e;return(0,s.yg)(sAp,(0,p.A)({},rAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}cAp.isMDXComponent=!0;const aAp={toc:[]},iAp="wrapper";function lAp(e){let{components:n,...t}=e;return(0,s.yg)(iAp,(0,p.A)({},aAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lAp.isMDXComponent=!0;const uAp={toc:[]},mAp="wrapper";function yAp(e){let{components:n,...t}=e;return(0,s.yg)(mAp,(0,p.A)({},uAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}yAp.isMDXComponent=!0;const dAp={toc:[]},hAp="wrapper";function gAp(e){let{components:n,...t}=e;return(0,s.yg)(hAp,(0,p.A)({},dAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}gAp.isMDXComponent=!0;const fAp={toc:[]},DAp="wrapper";function MAp(e){let{components:n,...t}=e;return(0,s.yg)(DAp,(0,p.A)({},fAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}MAp.isMDXComponent=!0;const XAp={toc:[]},_Ap="wrapper";function wAp(e){let{components:n,...t}=e;return(0,s.yg)(_Ap,(0,p.A)({},XAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}wAp.isMDXComponent=!0;const TAp={toc:[]},CAp="wrapper";function xAp(e){let{components:n,...t}=e;return(0,s.yg)(CAp,(0,p.A)({},TAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}xAp.isMDXComponent=!0;const AAp={toc:[]},vAp="wrapper";function LAp(e){let{components:n,...t}=e;return(0,s.yg)(vAp,(0,p.A)({},AAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}LAp.isMDXComponent=!0;const bAp={toc:[]},NAp="wrapper";function kAp(e){let{components:n,...t}=e;return(0,s.yg)(NAp,(0,p.A)({},bAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}kAp.isMDXComponent=!0;const zAp={toc:[]},PAp="wrapper";function IAp(e){let{components:n,...t}=e;return(0,s.yg)(PAp,(0,p.A)({},zAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}IAp.isMDXComponent=!0;const RAp={toc:[]},WAp="wrapper";function SAp(e){let{components:n,...t}=e;return(0,s.yg)(WAp,(0,p.A)({},RAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}SAp.isMDXComponent=!0;const BAp={toc:[]},GAp="wrapper";function EAp(e){let{components:n,...t}=e;return(0,s.yg)(GAp,(0,p.A)({},BAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}EAp.isMDXComponent=!0;const OAp={toc:[]},UAp="wrapper";function FAp(e){let{components:n,...t}=e;return(0,s.yg)(UAp,(0,p.A)({},OAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}FAp.isMDXComponent=!0;const VAp={toc:[]},qAp="wrapper";function jAp(e){let{components:n,...t}=e;return(0,s.yg)(qAp,(0,p.A)({},VAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jAp.isMDXComponent=!0;const HAp={toc:[]},YAp="wrapper";function QAp(e){let{components:n,...t}=e;return(0,s.yg)(YAp,(0,p.A)({},HAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}QAp.isMDXComponent=!0;const $Ap={toc:[]},KAp="wrapper";function JAp(e){let{components:n,...t}=e;return(0,s.yg)(KAp,(0,p.A)({},$Ap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}JAp.isMDXComponent=!0;const ZAp={toc:[]},evp="wrapper";function nvp(e){let{components:n,...t}=e;return(0,s.yg)(evp,(0,p.A)({},ZAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}nvp.isMDXComponent=!0;const tvp={toc:[]},ovp="wrapper";function pvp(e){let{components:n,...t}=e;return(0,s.yg)(ovp,(0,p.A)({},tvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}pvp.isMDXComponent=!0;const rvp={toc:[]},svp="wrapper";function cvp(e){let{components:n,...t}=e;return(0,s.yg)(svp,(0,p.A)({},rvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}cvp.isMDXComponent=!0;const avp={toc:[]},ivp="wrapper";function lvp(e){let{components:n,...t}=e;return(0,s.yg)(ivp,(0,p.A)({},avp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}lvp.isMDXComponent=!0;const uvp={toc:[]},mvp="wrapper";function yvp(e){let{components:n,...t}=e;return(0,s.yg)(mvp,(0,p.A)({},uvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}yvp.isMDXComponent=!0;const dvp={toc:[]},hvp="wrapper";function gvp(e){let{components:n,...t}=e;return(0,s.yg)(hvp,(0,p.A)({},dvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gvp.isMDXComponent=!0;const fvp={toc:[]},Dvp="wrapper";function Mvp(e){let{components:n,...t}=e;return(0,s.yg)(Dvp,(0,p.A)({},fvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Mvp.isMDXComponent=!0;const Xvp={toc:[]},_vp="wrapper";function wvp(e){let{components:n,...t}=e;return(0,s.yg)(_vp,(0,p.A)({},Xvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}wvp.isMDXComponent=!0;const Tvp={toc:[]},Cvp="wrapper";function xvp(e){let{components:n,...t}=e;return(0,s.yg)(Cvp,(0,p.A)({},Tvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xvp.isMDXComponent=!0;const Avp={toc:[]},vvp="wrapper";function Lvp(e){let{components:n,...t}=e;return(0,s.yg)(vvp,(0,p.A)({},Avp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Lvp.isMDXComponent=!0;const bvp={toc:[]},Nvp="wrapper";function kvp(e){let{components:n,...t}=e;return(0,s.yg)(Nvp,(0,p.A)({},bvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}kvp.isMDXComponent=!0;const zvp={toc:[]},Pvp="wrapper";function Ivp(e){let{components:n,...t}=e;return(0,s.yg)(Pvp,(0,p.A)({},zvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Ivp.isMDXComponent=!0;const Rvp={toc:[]},Wvp="wrapper";function Svp(e){let{components:n,...t}=e;return(0,s.yg)(Wvp,(0,p.A)({},Rvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Svp.isMDXComponent=!0;const Bvp={toc:[]},Gvp="wrapper";function Evp(e){let{components:n,...t}=e;return(0,s.yg)(Gvp,(0,p.A)({},Bvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Evp.isMDXComponent=!0;const Ovp={toc:[]},Uvp="wrapper";function Fvp(e){let{components:n,...t}=e;return(0,s.yg)(Uvp,(0,p.A)({},Ovp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Fvp.isMDXComponent=!0;const Vvp={toc:[]},qvp="wrapper";function jvp(e){let{components:n,...t}=e;return(0,s.yg)(qvp,(0,p.A)({},Vvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}jvp.isMDXComponent=!0;const Hvp={toc:[]},Yvp="wrapper";function Qvp(e){let{components:n,...t}=e;return(0,s.yg)(Yvp,(0,p.A)({},Hvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qvp.isMDXComponent=!0;const $vp={toc:[]},Kvp="wrapper";function Jvp(e){let{components:n,...t}=e;return(0,s.yg)(Kvp,(0,p.A)({},$vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Jvp.isMDXComponent=!0;const Zvp={toc:[]},eLp="wrapper";function nLp(e){let{components:n,...t}=e;return(0,s.yg)(eLp,(0,p.A)({},Zvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}nLp.isMDXComponent=!0;const tLp={toc:[]},oLp="wrapper";function pLp(e){let{components:n,...t}=e;return(0,s.yg)(oLp,(0,p.A)({},tLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}pLp.isMDXComponent=!0;const rLp={toc:[]},sLp="wrapper";function cLp(e){let{components:n,...t}=e;return(0,s.yg)(sLp,(0,p.A)({},rLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}cLp.isMDXComponent=!0;const aLp={toc:[]},iLp="wrapper";function lLp(e){let{components:n,...t}=e;return(0,s.yg)(iLp,(0,p.A)({},aLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}lLp.isMDXComponent=!0;const uLp={toc:[]},mLp="wrapper";function yLp(e){let{components:n,...t}=e;return(0,s.yg)(mLp,(0,p.A)({},uLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}yLp.isMDXComponent=!0;const dLp={toc:[]},hLp="wrapper";function gLp(e){let{components:n,...t}=e;return(0,s.yg)(hLp,(0,p.A)({},dLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}gLp.isMDXComponent=!0;const fLp={toc:[]},DLp="wrapper";function MLp(e){let{components:n,...t}=e;return(0,s.yg)(DLp,(0,p.A)({},fLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}MLp.isMDXComponent=!0;const XLp={toc:[]},_Lp="wrapper";function wLp(e){let{components:n,...t}=e;return(0,s.yg)(_Lp,(0,p.A)({},XLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}wLp.isMDXComponent=!0;const TLp={toc:[]},CLp="wrapper";function xLp(e){let{components:n,...t}=e;return(0,s.yg)(CLp,(0,p.A)({},TLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}xLp.isMDXComponent=!0;const ALp={toc:[]},vLp="wrapper";function LLp(e){let{components:n,...t}=e;return(0,s.yg)(vLp,(0,p.A)({},ALp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}LLp.isMDXComponent=!0;const bLp={toc:[]},NLp="wrapper";function kLp(e){let{components:n,...t}=e;return(0,s.yg)(NLp,(0,p.A)({},bLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}kLp.isMDXComponent=!0;const zLp={toc:[]},PLp="wrapper";function ILp(e){let{components:n,...t}=e;return(0,s.yg)(PLp,(0,p.A)({},zLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ILp.isMDXComponent=!0;const RLp={toc:[]},WLp="wrapper";function SLp(e){let{components:n,...t}=e;return(0,s.yg)(WLp,(0,p.A)({},RLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}SLp.isMDXComponent=!0;const BLp={toc:[]},GLp="wrapper";function ELp(e){let{components:n,...t}=e;return(0,s.yg)(GLp,(0,p.A)({},BLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ELp.isMDXComponent=!0;const OLp={toc:[]},ULp="wrapper";function FLp(e){let{components:n,...t}=e;return(0,s.yg)(ULp,(0,p.A)({},OLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FLp.isMDXComponent=!0;const VLp={toc:[]},qLp="wrapper";function jLp(e){let{components:n,...t}=e;return(0,s.yg)(qLp,(0,p.A)({},VLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}jLp.isMDXComponent=!0;const HLp={toc:[]},YLp="wrapper";function QLp(e){let{components:n,...t}=e;return(0,s.yg)(YLp,(0,p.A)({},HLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}QLp.isMDXComponent=!0;const $Lp={toc:[]},KLp="wrapper";function JLp(e){let{components:n,...t}=e;return(0,s.yg)(KLp,(0,p.A)({},$Lp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}JLp.isMDXComponent=!0;const ZLp={toc:[]},ebp="wrapper";function nbp(e){let{components:n,...t}=e;return(0,s.yg)(ebp,(0,p.A)({},ZLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nbp.isMDXComponent=!0;const tbp={toc:[]},obp="wrapper";function pbp(e){let{components:n,...t}=e;return(0,s.yg)(obp,(0,p.A)({},tbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pbp.isMDXComponent=!0;const rbp={toc:[]},sbp="wrapper";function cbp(e){let{components:n,...t}=e;return(0,s.yg)(sbp,(0,p.A)({},rbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cbp.isMDXComponent=!0;const abp={toc:[]},ibp="wrapper";function lbp(e){let{components:n,...t}=e;return(0,s.yg)(ibp,(0,p.A)({},abp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}lbp.isMDXComponent=!0;const ubp={toc:[]},mbp="wrapper";function ybp(e){let{components:n,...t}=e;return(0,s.yg)(mbp,(0,p.A)({},ubp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ybp.isMDXComponent=!0;const dbp={toc:[]},hbp="wrapper";function gbp(e){let{components:n,...t}=e;return(0,s.yg)(hbp,(0,p.A)({},dbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}gbp.isMDXComponent=!0;const fbp={toc:[]},Dbp="wrapper";function Mbp(e){let{components:n,...t}=e;return(0,s.yg)(Dbp,(0,p.A)({},fbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Mbp.isMDXComponent=!0;const Xbp={toc:[]},_bp="wrapper";function wbp(e){let{components:n,...t}=e;return(0,s.yg)(_bp,(0,p.A)({},Xbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}wbp.isMDXComponent=!0;const Tbp={toc:[]},Cbp="wrapper";function xbp(e){let{components:n,...t}=e;return(0,s.yg)(Cbp,(0,p.A)({},Tbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xbp.isMDXComponent=!0;const Abp={toc:[]},vbp="wrapper";function Lbp(e){let{components:n,...t}=e;return(0,s.yg)(vbp,(0,p.A)({},Abp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Lbp.isMDXComponent=!0;const bbp={toc:[]},Nbp="wrapper";function kbp(e){let{components:n,...t}=e;return(0,s.yg)(Nbp,(0,p.A)({},bbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kbp.isMDXComponent=!0;const zbp={toc:[]},Pbp="wrapper";function Ibp(e){let{components:n,...t}=e;return(0,s.yg)(Pbp,(0,p.A)({},zbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Ibp.isMDXComponent=!0;const Rbp={toc:[]},Wbp="wrapper";function Sbp(e){let{components:n,...t}=e;return(0,s.yg)(Wbp,(0,p.A)({},Rbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Sbp.isMDXComponent=!0;const Bbp={toc:[]},Gbp="wrapper";function Ebp(e){let{components:n,...t}=e;return(0,s.yg)(Gbp,(0,p.A)({},Bbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Ebp.isMDXComponent=!0;const Obp={toc:[]},Ubp="wrapper";function Fbp(e){let{components:n,...t}=e;return(0,s.yg)(Ubp,(0,p.A)({},Obp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Fbp.isMDXComponent=!0;const Vbp={toc:[]},qbp="wrapper";function jbp(e){let{components:n,...t}=e;return(0,s.yg)(qbp,(0,p.A)({},Vbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jbp.isMDXComponent=!0;const Hbp={toc:[]},Ybp="wrapper";function Qbp(e){let{components:n,...t}=e;return(0,s.yg)(Ybp,(0,p.A)({},Hbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Qbp.isMDXComponent=!0;const $bp={toc:[]},Kbp="wrapper";function Jbp(e){let{components:n,...t}=e;return(0,s.yg)(Kbp,(0,p.A)({},$bp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Jbp.isMDXComponent=!0;const Zbp={toc:[]},eNp="wrapper";function nNp(e){let{components:n,...t}=e;return(0,s.yg)(eNp,(0,p.A)({},Zbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}nNp.isMDXComponent=!0;const tNp={toc:[]},oNp="wrapper";function pNp(e){let{components:n,...t}=e;return(0,s.yg)(oNp,(0,p.A)({},tNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}pNp.isMDXComponent=!0;const rNp={toc:[]},sNp="wrapper";function cNp(e){let{components:n,...t}=e;return(0,s.yg)(sNp,(0,p.A)({},rNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cNp.isMDXComponent=!0;const aNp={toc:[]},iNp="wrapper";function lNp(e){let{components:n,...t}=e;return(0,s.yg)(iNp,(0,p.A)({},aNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lNp.isMDXComponent=!0;const uNp={toc:[]},mNp="wrapper";function yNp(e){let{components:n,...t}=e;return(0,s.yg)(mNp,(0,p.A)({},uNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yNp.isMDXComponent=!0;const dNp={toc:[]},hNp="wrapper";function gNp(e){let{components:n,...t}=e;return(0,s.yg)(hNp,(0,p.A)({},dNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gNp.isMDXComponent=!0;const fNp={toc:[]},DNp="wrapper";function MNp(e){let{components:n,...t}=e;return(0,s.yg)(DNp,(0,p.A)({},fNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}MNp.isMDXComponent=!0;const XNp={toc:[]},_Np="wrapper";function wNp(e){let{components:n,...t}=e;return(0,s.yg)(_Np,(0,p.A)({},XNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the path of this circle should be closed."))}wNp.isMDXComponent=!0;const TNp={toc:[]},CNp="wrapper";function xNp(e){let{components:n,...t}=e;return(0,s.yg)(CNp,(0,p.A)({},TNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the circle begins at ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}xNp.isMDXComponent=!0;const ANp={toc:[]},vNp="wrapper";function LNp(e){let{components:n,...t}=e;return(0,s.yg)(vNp,(0,p.A)({},ANp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the circle sector should be drawn counterclockwise."))}LNp.isMDXComponent=!0;const bNp={toc:[]},NNp="wrapper";function kNp(e){let{components:n,...t}=e;return(0,s.yg)(NNp,(0,p.A)({},bNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}kNp.isMDXComponent=!0;const zNp={toc:[]},PNp="wrapper";function INp(e){let{components:n,...t}=e;return(0,s.yg)(PNp,(0,p.A)({},zNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}INp.isMDXComponent=!0;const RNp={toc:[]},WNp="wrapper";function SNp(e){let{components:n,...t}=e;return(0,s.yg)(WNp,(0,p.A)({},RNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}SNp.isMDXComponent=!0;const BNp={toc:[]},GNp="wrapper";function ENp(e){let{components:n,...t}=e;return(0,s.yg)(GNp,(0,p.A)({},BNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending angle in degrees for the circle sector."))}ENp.isMDXComponent=!0;const ONp={toc:[]},UNp="wrapper";function FNp(e){let{components:n,...t}=e;return(0,s.yg)(UNp,(0,p.A)({},ONp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}FNp.isMDXComponent=!0;const VNp={toc:[]},qNp="wrapper";function jNp(e){let{components:n,...t}=e;return(0,s.yg)(qNp,(0,p.A)({},VNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}jNp.isMDXComponent=!0;const HNp={toc:[]},YNp="wrapper";function QNp(e){let{components:n,...t}=e;return(0,s.yg)(YNp,(0,p.A)({},HNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}QNp.isMDXComponent=!0;const $Np={toc:[]},KNp="wrapper";function JNp(e){let{components:n,...t}=e;return(0,s.yg)(KNp,(0,p.A)({},$Np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}JNp.isMDXComponent=!0;const ZNp={toc:[]},ekp="wrapper";function nkp(e){let{components:n,...t}=e;return(0,s.yg)(ekp,(0,p.A)({},ZNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nkp.isMDXComponent=!0;const tkp={toc:[]},okp="wrapper";function pkp(e){let{components:n,...t}=e;return(0,s.yg)(okp,(0,p.A)({},tkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}pkp.isMDXComponent=!0;const rkp={toc:[]},skp="wrapper";function ckp(e){let{components:n,...t}=e;return(0,s.yg)(skp,(0,p.A)({},rkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}ckp.isMDXComponent=!0;const akp={toc:[]},ikp="wrapper";function lkp(e){let{components:n,...t}=e;return(0,s.yg)(ikp,(0,p.A)({},akp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}lkp.isMDXComponent=!0;const ukp={toc:[]},mkp="wrapper";function ykp(e){let{components:n,...t}=e;return(0,s.yg)(mkp,(0,p.A)({},ukp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ykp.isMDXComponent=!0;const dkp={toc:[]},hkp="wrapper";function gkp(e){let{components:n,...t}=e;return(0,s.yg)(hkp,(0,p.A)({},dkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}gkp.isMDXComponent=!0;const fkp={toc:[]},Dkp="wrapper";function Mkp(e){let{components:n,...t}=e;return(0,s.yg)(Dkp,(0,p.A)({},fkp,t,{components:n,mdxType:"MDXLayout"}))}Mkp.isMDXComponent=!0;const Xkp={toc:[]},_kp="wrapper";function wkp(e){let{components:n,...t}=e;return(0,s.yg)(_kp,(0,p.A)({},Xkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}wkp.isMDXComponent=!0;const Tkp={toc:[]},Ckp="wrapper";function xkp(e){let{components:n,...t}=e;return(0,s.yg)(Ckp,(0,p.A)({},Tkp,t,{components:n,mdxType:"MDXLayout"}))}xkp.isMDXComponent=!0;const Akp={toc:[]},vkp="wrapper";function Lkp(e){let{components:n,...t}=e;return(0,s.yg)(vkp,(0,p.A)({},Akp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Lkp.isMDXComponent=!0;const bkp={toc:[]},Nkp="wrapper";function kkp(e){let{components:n,...t}=e;return(0,s.yg)(Nkp,(0,p.A)({},bkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}kkp.isMDXComponent=!0;const zkp={toc:[]},Pkp="wrapper";function Ikp(e){let{components:n,...t}=e;return(0,s.yg)(Pkp,(0,p.A)({},zkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Ikp.isMDXComponent=!0;const Rkp={toc:[]},Wkp="wrapper";function Skp(e){let{components:n,...t}=e;return(0,s.yg)(Wkp,(0,p.A)({},Rkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting angle in degrees for the circle sector."))}Skp.isMDXComponent=!0;const Bkp={toc:[]},Gkp="wrapper";function Ekp(e){let{components:n,...t}=e;return(0,s.yg)(Gkp,(0,p.A)({},Bkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ekp.isMDXComponent=!0;const Okp={toc:[]},Ukp="wrapper";function Fkp(e){let{components:n,...t}=e;return(0,s.yg)(Ukp,(0,p.A)({},Okp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Fkp.isMDXComponent=!0;const Vkp={toc:[]},qkp="wrapper";function jkp(e){let{components:n,...t}=e;return(0,s.yg)(qkp,(0,p.A)({},Vkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jkp.isMDXComponent=!0;const Hkp={toc:[]},Ykp="wrapper";function Qkp(e){let{components:n,...t}=e;return(0,s.yg)(Ykp,(0,p.A)({},Hkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Qkp.isMDXComponent=!0;const $kp={toc:[]},Kkp="wrapper";function Jkp(e){let{components:n,...t}=e;return(0,s.yg)(Kkp,(0,p.A)({},$kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Jkp.isMDXComponent=!0;const Zkp={toc:[]},ezp="wrapper";function nzp(e){let{components:n,...t}=e;return(0,s.yg)(ezp,(0,p.A)({},Zkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}nzp.isMDXComponent=!0;const tzp={toc:[]},ozp="wrapper";function pzp(e){let{components:n,...t}=e;return(0,s.yg)(ozp,(0,p.A)({},tzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pzp.isMDXComponent=!0;const rzp={toc:[]},szp="wrapper";function czp(e){let{components:n,...t}=e;return(0,s.yg)(szp,(0,p.A)({},rzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}czp.isMDXComponent=!0;const azp={toc:[]},izp="wrapper";function lzp(e){let{components:n,...t}=e;return(0,s.yg)(izp,(0,p.A)({},azp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lzp.isMDXComponent=!0;const uzp={toc:[]},mzp="wrapper";function yzp(e){let{components:n,...t}=e;return(0,s.yg)(mzp,(0,p.A)({},uzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}yzp.isMDXComponent=!0;const dzp={toc:[]},hzp="wrapper";function gzp(e){let{components:n,...t}=e;return(0,s.yg)(hzp,(0,p.A)({},dzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gzp.isMDXComponent=!0;const fzp={toc:[]},Dzp="wrapper";function Mzp(e){let{components:n,...t}=e;return(0,s.yg)(Dzp,(0,p.A)({},fzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Mzp.isMDXComponent=!0;const Xzp={toc:[]},_zp="wrapper";function wzp(e){let{components:n,...t}=e;return(0,s.yg)(_zp,(0,p.A)({},Xzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wzp.isMDXComponent=!0;const Tzp={toc:[]},Czp="wrapper";function xzp(e){let{components:n,...t}=e;return(0,s.yg)(Czp,(0,p.A)({},Tzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}xzp.isMDXComponent=!0;const Azp={toc:[]},vzp="wrapper";function Lzp(e){let{components:n,...t}=e;return(0,s.yg)(vzp,(0,p.A)({},Azp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Lzp.isMDXComponent=!0;const bzp={toc:[]},Nzp="wrapper";function kzp(e){let{components:n,...t}=e;return(0,s.yg)(Nzp,(0,p.A)({},bzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}kzp.isMDXComponent=!0;const zzp={toc:[]},Pzp="wrapper";function Izp(e){let{components:n,...t}=e;return(0,s.yg)(Pzp,(0,p.A)({},zzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Izp.isMDXComponent=!0;const Rzp={toc:[]},Wzp="wrapper";function Szp(e){let{components:n,...t}=e;return(0,s.yg)(Wzp,(0,p.A)({},Rzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Szp.isMDXComponent=!0;const Bzp={toc:[]},Gzp="wrapper";function Ezp(e){let{components:n,...t}=e;return(0,s.yg)(Gzp,(0,p.A)({},Bzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ezp.isMDXComponent=!0;const Ozp={toc:[]},Uzp="wrapper";function Fzp(e){let{components:n,...t}=e;return(0,s.yg)(Uzp,(0,p.A)({},Ozp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Fzp.isMDXComponent=!0;const Vzp={toc:[]},qzp="wrapper";function jzp(e){let{components:n,...t}=e;return(0,s.yg)(qzp,(0,p.A)({},Vzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jzp.isMDXComponent=!0;const Hzp={toc:[]},Yzp="wrapper";function Qzp(e){let{components:n,...t}=e;return(0,s.yg)(Yzp,(0,p.A)({},Hzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Qzp.isMDXComponent=!0;const $zp={toc:[]},Kzp="wrapper";function Jzp(e){let{components:n,...t}=e;return(0,s.yg)(Kzp,(0,p.A)({},$zp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Jzp.isMDXComponent=!0;const Zzp={toc:[]},ePp="wrapper";function nPp(e){let{components:n,...t}=e;return(0,s.yg)(ePp,(0,p.A)({},Zzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nPp.isMDXComponent=!0;const tPp={toc:[]},oPp="wrapper";function pPp(e){let{components:n,...t}=e;return(0,s.yg)(oPp,(0,p.A)({},tPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pPp.isMDXComponent=!0;const rPp={toc:[]},sPp="wrapper";function cPp(e){let{components:n,...t}=e;return(0,s.yg)(sPp,(0,p.A)({},rPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cPp.isMDXComponent=!0;const aPp={toc:[]},iPp="wrapper";function lPp(e){let{components:n,...t}=e;return(0,s.yg)(iPp,(0,p.A)({},aPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to display."))}lPp.isMDXComponent=!0;const uPp={toc:[]},mPp="wrapper";function yPp(e){let{components:n,...t}=e;return(0,s.yg)(mPp,(0,p.A)({},uPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This value will be passed to the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeHighlighter")),"\ndefined by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#highlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"highlighter"))," property. Different highlighters may use\nit differently."),(0,s.yg)("p",null,"The default ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter"))," uses it to select\nthe language parser to use. The parser for the given dialect can be\nregistered as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// Import the lezer parser:\nimport {parser} from '@lezer/javascript';\n\n// Register it in the highlighter:\nLezerHighlighter.registerParser(parser, 'js');\n\n// Use the dialect in a code node:\n<Code dialect=\"js\" code=\"const a = 7;\" />\n")),(0,s.yg)("p",null,"When no dialect is provided, the highlighter will use the default\nparser:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'// Register the default parser by omitting the dialect:\nLezerHighlighter.registerParser(parser);\n\n// Code nodes with no dialect will now use the default parser:\n<Code code="const a = 7;" />\n')))}yPp.isMDXComponent=!0;const dPp={toc:[]},hPp="wrapper";function gPp(e){let{components:n,...t}=e;return(0,s.yg)(hPp,(0,p.A)({},dPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The dialect to use for highlighting the code."))}gPp.isMDXComponent=!0;const fPp={toc:[]},DPp="wrapper";function MPp(e){let{components:n,...t}=e;return(0,s.yg)(DPp,(0,p.A)({},fPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check out ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.yg)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}MPp.isMDXComponent=!0;const XPp={toc:[]},_Pp="wrapper";function wPp(e){let{components:n,...t}=e;return(0,s.yg)(_Pp,(0,p.A)({},XPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for the code."))}wPp.isMDXComponent=!0;const TPp={toc:[]},CPp="wrapper";function xPp(e){let{components:n,...t}=e;return(0,s.yg)(CPp,(0,p.A)({},TPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defaults to a shared ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}xPp.isMDXComponent=!0;const APp={toc:[]},vPp="wrapper";function LPp(e){let{components:n,...t}=e;return(0,s.yg)(vPp,(0,p.A)({},APp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code highlighter to use for this code node."))}LPp.isMDXComponent=!0;const bPp={toc:[]},NPp="wrapper";function kPp(e){let{components:n,...t}=e;return(0,s.yg)(NPp,(0,p.A)({},bPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kPp.isMDXComponent=!0;const zPp={toc:[]},PPp="wrapper";function IPp(e){let{components:n,...t}=e;return(0,s.yg)(PPp,(0,p.A)({},zPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}IPp.isMDXComponent=!0;const RPp={toc:[]},WPp="wrapper";function SPp(e){let{components:n,...t}=e;return(0,s.yg)(WPp,(0,p.A)({},RPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}SPp.isMDXComponent=!0;const BPp={toc:[]},GPp="wrapper";function EPp(e){let{components:n,...t}=e;return(0,s.yg)(GPp,(0,p.A)({},BPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}EPp.isMDXComponent=!0;const OPp={toc:[]},UPp="wrapper";function FPp(e){let{components:n,...t}=e;return(0,s.yg)(UPp,(0,p.A)({},OPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FPp.isMDXComponent=!0;const VPp={toc:[]},qPp="wrapper";function jPp(e){let{components:n,...t}=e;return(0,s.yg)(qPp,(0,p.A)({},VPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}jPp.isMDXComponent=!0;const HPp={toc:[]},YPp="wrapper";function QPp(e){let{components:n,...t}=e;return(0,s.yg)(YPp,(0,p.A)({},HPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a single ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.yg)("p",null,"You can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.yg)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.yg)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}QPp.isMDXComponent=!0;const $Pp={toc:[]},KPp="wrapper";function JPp(e){let{components:n,...t}=e;return(0,s.yg)(KPp,(0,p.A)({},$Pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The currently selected code range."))}JPp.isMDXComponent=!0;const ZPp={toc:[]},eIp="wrapper";function nIp(e){let{components:n,...t}=e;return(0,s.yg)(eIp,(0,p.A)({},ZPp,t,{components:n,mdxType:"MDXLayout"}))}nIp.isMDXComponent=!0;const tIp={toc:[]},oIp="wrapper";function pIp(e){let{components:n,...t}=e;return(0,s.yg)(oIp,(0,p.A)({},tIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}pIp.isMDXComponent=!0;const rIp={toc:[]},sIp="wrapper";function cIp(e){let{components:n,...t}=e;return(0,s.yg)(sIp,(0,p.A)({},rIp,t,{components:n,mdxType:"MDXLayout"}))}cIp.isMDXComponent=!0;const aIp={toc:[]},iIp="wrapper";function lIp(e){let{components:n,...t}=e;return(0,s.yg)(iIp,(0,p.A)({},aIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lIp.isMDXComponent=!0;const uIp={toc:[]},mIp="wrapper";function yIp(e){let{components:n,...t}=e;return(0,s.yg)(mIp,(0,p.A)({},uIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}yIp.isMDXComponent=!0;const dIp={toc:[]},hIp="wrapper";function gIp(e){let{components:n,...t}=e;return(0,s.yg)(hIp,(0,p.A)({},dIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gIp.isMDXComponent=!0;const fIp={toc:[]},DIp="wrapper";function MIp(e){let{components:n,...t}=e;return(0,s.yg)(DIp,(0,p.A)({},fIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}MIp.isMDXComponent=!0;const XIp={toc:[]},_Ip="wrapper";function wIp(e){let{components:n,...t}=e;return(0,s.yg)(_Ip,(0,p.A)({},XIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wIp.isMDXComponent=!0;const TIp={toc:[]},CIp="wrapper";function xIp(e){let{components:n,...t}=e;return(0,s.yg)(CIp,(0,p.A)({},TIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}xIp.isMDXComponent=!0;const AIp={toc:[]},vIp="wrapper";function LIp(e){let{components:n,...t}=e;return(0,s.yg)(vIp,(0,p.A)({},AIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}LIp.isMDXComponent=!0;const bIp={toc:[]},NIp="wrapper";function kIp(e){let{components:n,...t}=e;return(0,s.yg)(NIp,(0,p.A)({},bIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}kIp.isMDXComponent=!0;const zIp={toc:[]},PIp="wrapper";function IIp(e){let{components:n,...t}=e;return(0,s.yg)(PIp,(0,p.A)({},zIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}IIp.isMDXComponent=!0;const RIp={toc:[]},WIp="wrapper";function SIp(e){let{components:n,...t}=e;return(0,s.yg)(WIp,(0,p.A)({},RIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}SIp.isMDXComponent=!0;const BIp={toc:[]},GIp="wrapper";function EIp(e){let{components:n,...t}=e;return(0,s.yg)(GIp,(0,p.A)({},BIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EIp.isMDXComponent=!0;const OIp={toc:[]},UIp="wrapper";function FIp(e){let{components:n,...t}=e;return(0,s.yg)(UIp,(0,p.A)({},OIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}FIp.isMDXComponent=!0;const VIp={toc:[]},qIp="wrapper";function jIp(e){let{components:n,...t}=e;return(0,s.yg)(qIp,(0,p.A)({},VIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jIp.isMDXComponent=!0;const HIp={toc:[]},YIp="wrapper";function QIp(e){let{components:n,...t}=e;return(0,s.yg)(YIp,(0,p.A)({},HIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}QIp.isMDXComponent=!0;const $Ip={toc:[]},KIp="wrapper";function JIp(e){let{components:n,...t}=e;return(0,s.yg)(KIp,(0,p.A)({},$Ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}JIp.isMDXComponent=!0;const ZIp={toc:[]},eRp="wrapper";function nRp(e){let{components:n,...t}=e;return(0,s.yg)(eRp,(0,p.A)({},ZIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nRp.isMDXComponent=!0;const tRp={toc:[]},oRp="wrapper";function pRp(e){let{components:n,...t}=e;return(0,s.yg)(oRp,(0,p.A)({},tRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pRp.isMDXComponent=!0;const rRp={toc:[]},sRp="wrapper";function cRp(e){let{components:n,...t}=e;return(0,s.yg)(sRp,(0,p.A)({},rRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cRp.isMDXComponent=!0;const aRp={toc:[]},iRp="wrapper";function lRp(e){let{components:n,...t}=e;return(0,s.yg)(iRp,(0,p.A)({},aRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lRp.isMDXComponent=!0;const uRp={toc:[]},mRp="wrapper";function yRp(e){let{components:n,...t}=e;return(0,s.yg)(mRp,(0,p.A)({},uRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yRp.isMDXComponent=!0;const dRp={toc:[]},hRp="wrapper";function gRp(e){let{components:n,...t}=e;return(0,s.yg)(hRp,(0,p.A)({},dRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gRp.isMDXComponent=!0;const fRp={toc:[]},DRp="wrapper";function MRp(e){let{components:n,...t}=e;return(0,s.yg)(DRp,(0,p.A)({},fRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}MRp.isMDXComponent=!0;const XRp={toc:[]},_Rp="wrapper";function wRp(e){let{components:n,...t}=e;return(0,s.yg)(_Rp,(0,p.A)({},XRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wRp.isMDXComponent=!0;const TRp={toc:[]},CRp="wrapper";function xRp(e){let{components:n,...t}=e;return(0,s.yg)(CRp,(0,p.A)({},TRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xRp.isMDXComponent=!0;const ARp={toc:[]},vRp="wrapper";function LRp(e){let{components:n,...t}=e;return(0,s.yg)(vRp,(0,p.A)({},ARp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}LRp.isMDXComponent=!0;const bRp={toc:[]},NRp="wrapper";function kRp(e){let{components:n,...t}=e;return(0,s.yg)(NRp,(0,p.A)({},bRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}kRp.isMDXComponent=!0;const zRp={toc:[]},PRp="wrapper";function IRp(e){let{components:n,...t}=e;return(0,s.yg)(PRp,(0,p.A)({},zRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}IRp.isMDXComponent=!0;const RRp={toc:[]},WRp="wrapper";function SRp(e){let{components:n,...t}=e;return(0,s.yg)(WRp,(0,p.A)({},RRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}SRp.isMDXComponent=!0;const BRp={toc:[]},GRp="wrapper";function ERp(e){let{components:n,...t}=e;return(0,s.yg)(GRp,(0,p.A)({},BRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ERp.isMDXComponent=!0;const ORp={toc:[]},URp="wrapper";function FRp(e){let{components:n,...t}=e;return(0,s.yg)(URp,(0,p.A)({},ORp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}FRp.isMDXComponent=!0;const VRp={toc:[]},qRp="wrapper";function jRp(e){let{components:n,...t}=e;return(0,s.yg)(qRp,(0,p.A)({},VRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}jRp.isMDXComponent=!0;const HRp={toc:[]},YRp="wrapper";function QRp(e){let{components:n,...t}=e;return(0,s.yg)(YRp,(0,p.A)({},HRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}QRp.isMDXComponent=!0;const $Rp={toc:[]},KRp="wrapper";function JRp(e){let{components:n,...t}=e;return(0,s.yg)(KRp,(0,p.A)({},$Rp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JRp.isMDXComponent=!0;const ZRp={toc:[]},eWp="wrapper";function nWp(e){let{components:n,...t}=e;return(0,s.yg)(eWp,(0,p.A)({},ZRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}nWp.isMDXComponent=!0;const tWp={toc:[]},oWp="wrapper";function pWp(e){let{components:n,...t}=e;return(0,s.yg)(oWp,(0,p.A)({},tWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}pWp.isMDXComponent=!0;const rWp={toc:[]},sWp="wrapper";function cWp(e){let{components:n,...t}=e;return(0,s.yg)(sWp,(0,p.A)({},rWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}cWp.isMDXComponent=!0;const aWp={toc:[]},iWp="wrapper";function lWp(e){let{components:n,...t}=e;return(0,s.yg)(iWp,(0,p.A)({},aWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lWp.isMDXComponent=!0;const uWp={toc:[]},mWp="wrapper";function yWp(e){let{components:n,...t}=e;return(0,s.yg)(mWp,(0,p.A)({},uWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}yWp.isMDXComponent=!0;const dWp={toc:[]},hWp="wrapper";function gWp(e){let{components:n,...t}=e;return(0,s.yg)(hWp,(0,p.A)({},dWp,t,{components:n,mdxType:"MDXLayout"}))}gWp.isMDXComponent=!0;const fWp={toc:[]},DWp="wrapper";function MWp(e){let{components:n,...t}=e;return(0,s.yg)(DWp,(0,p.A)({},fWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}MWp.isMDXComponent=!0;const XWp={toc:[]},_Wp="wrapper";function wWp(e){let{components:n,...t}=e;return(0,s.yg)(_Wp,(0,p.A)({},XWp,t,{components:n,mdxType:"MDXLayout"}))}wWp.isMDXComponent=!0;const TWp={toc:[]},CWp="wrapper";function xWp(e){let{components:n,...t}=e;return(0,s.yg)(CWp,(0,p.A)({},TWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}xWp.isMDXComponent=!0;const AWp={toc:[]},vWp="wrapper";function LWp(e){let{components:n,...t}=e;return(0,s.yg)(vWp,(0,p.A)({},AWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}LWp.isMDXComponent=!0;const bWp={toc:[]},NWp="wrapper";function kWp(e){let{components:n,...t}=e;return(0,s.yg)(NWp,(0,p.A)({},bWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kWp.isMDXComponent=!0;const zWp={toc:[]},PWp="wrapper";function IWp(e){let{components:n,...t}=e;return(0,s.yg)(PWp,(0,p.A)({},zWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}IWp.isMDXComponent=!0;const RWp={toc:[]},WWp="wrapper";function SWp(e){let{components:n,...t}=e;return(0,s.yg)(WWp,(0,p.A)({},RWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}SWp.isMDXComponent=!0;const BWp={toc:[]},GWp="wrapper";function EWp(e){let{components:n,...t}=e;return(0,s.yg)(GWp,(0,p.A)({},BWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}EWp.isMDXComponent=!0;const OWp={toc:[]},UWp="wrapper";function FWp(e){let{components:n,...t}=e;return(0,s.yg)(UWp,(0,p.A)({},OWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FWp.isMDXComponent=!0;const VWp={toc:[]},qWp="wrapper";function jWp(e){let{components:n,...t}=e;return(0,s.yg)(qWp,(0,p.A)({},VWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}jWp.isMDXComponent=!0;const HWp={toc:[]},YWp="wrapper";function QWp(e){let{components:n,...t}=e;return(0,s.yg)(YWp,(0,p.A)({},HWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QWp.isMDXComponent=!0;const $Wp={toc:[]},KWp="wrapper";function JWp(e){let{components:n,...t}=e;return(0,s.yg)(KWp,(0,p.A)({},$Wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}JWp.isMDXComponent=!0;const ZWp={toc:[]},eSp="wrapper";function nSp(e){let{components:n,...t}=e;return(0,s.yg)(eSp,(0,p.A)({},ZWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nSp.isMDXComponent=!0;const tSp={toc:[]},oSp="wrapper";function pSp(e){let{components:n,...t}=e;return(0,s.yg)(oSp,(0,p.A)({},tSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}pSp.isMDXComponent=!0;const rSp={toc:[]},sSp="wrapper";function cSp(e){let{components:n,...t}=e;return(0,s.yg)(sSp,(0,p.A)({},rSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}cSp.isMDXComponent=!0;const aSp={toc:[]},iSp="wrapper";function lSp(e){let{components:n,...t}=e;return(0,s.yg)(iSp,(0,p.A)({},aSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}lSp.isMDXComponent=!0;const uSp={toc:[]},mSp="wrapper";function ySp(e){let{components:n,...t}=e;return(0,s.yg)(mSp,(0,p.A)({},uSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ySp.isMDXComponent=!0;const dSp={toc:[]},hSp="wrapper";function gSp(e){let{components:n,...t}=e;return(0,s.yg)(hSp,(0,p.A)({},dSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}gSp.isMDXComponent=!0;const fSp={toc:[]},DSp="wrapper";function MSp(e){let{components:n,...t}=e;return(0,s.yg)(DSp,(0,p.A)({},fSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MSp.isMDXComponent=!0;const XSp={toc:[]},_Sp="wrapper";function wSp(e){let{components:n,...t}=e;return(0,s.yg)(_Sp,(0,p.A)({},XSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}wSp.isMDXComponent=!0;const TSp={toc:[]},CSp="wrapper";function xSp(e){let{components:n,...t}=e;return(0,s.yg)(CSp,(0,p.A)({},TSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xSp.isMDXComponent=!0;const ASp={toc:[]},vSp="wrapper";function LSp(e){let{components:n,...t}=e;return(0,s.yg)(vSp,(0,p.A)({},ASp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}LSp.isMDXComponent=!0;const bSp={toc:[]},NSp="wrapper";function kSp(e){let{components:n,...t}=e;return(0,s.yg)(NSp,(0,p.A)({},bSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kSp.isMDXComponent=!0;const zSp={toc:[]},PSp="wrapper";function ISp(e){let{components:n,...t}=e;return(0,s.yg)(PSp,(0,p.A)({},zSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ISp.isMDXComponent=!0;const RSp={toc:[]},WSp="wrapper";function SSp(e){let{components:n,...t}=e;return(0,s.yg)(WSp,(0,p.A)({},RSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SSp.isMDXComponent=!0;const BSp={toc:[]},GSp="wrapper";function ESp(e){let{components:n,...t}=e;return(0,s.yg)(GSp,(0,p.A)({},BSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ESp.isMDXComponent=!0;const OSp={toc:[]},USp="wrapper";function FSp(e){let{components:n,...t}=e;return(0,s.yg)(USp,(0,p.A)({},OSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}FSp.isMDXComponent=!0;const VSp={toc:[]},qSp="wrapper";function jSp(e){let{components:n,...t}=e;return(0,s.yg)(qSp,(0,p.A)({},VSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jSp.isMDXComponent=!0;const HSp={toc:[]},YSp="wrapper";function QSp(e){let{components:n,...t}=e;return(0,s.yg)(YSp,(0,p.A)({},HSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}QSp.isMDXComponent=!0;const $Sp={toc:[]},KSp="wrapper";function JSp(e){let{components:n,...t}=e;return(0,s.yg)(KSp,(0,p.A)({},$Sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}JSp.isMDXComponent=!0;const ZSp={toc:[]},eBp="wrapper";function nBp(e){let{components:n,...t}=e;return(0,s.yg)(eBp,(0,p.A)({},ZSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}nBp.isMDXComponent=!0;const tBp={toc:[]},oBp="wrapper";function pBp(e){let{components:n,...t}=e;return(0,s.yg)(oBp,(0,p.A)({},tBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}pBp.isMDXComponent=!0;const rBp={toc:[]},sBp="wrapper";function cBp(e){let{components:n,...t}=e;return(0,s.yg)(sBp,(0,p.A)({},rBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}cBp.isMDXComponent=!0;const aBp={toc:[]},iBp="wrapper";function lBp(e){let{components:n,...t}=e;return(0,s.yg)(iBp,(0,p.A)({},aBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}lBp.isMDXComponent=!0;const uBp={toc:[]},mBp="wrapper";function yBp(e){let{components:n,...t}=e;return(0,s.yg)(mBp,(0,p.A)({},uBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}yBp.isMDXComponent=!0;const dBp={toc:[]},hBp="wrapper";function gBp(e){let{components:n,...t}=e;return(0,s.yg)(hBp,(0,p.A)({},dBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}gBp.isMDXComponent=!0;const fBp={toc:[]},DBp="wrapper";function MBp(e){let{components:n,...t}=e;return(0,s.yg)(DBp,(0,p.A)({},fBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MBp.isMDXComponent=!0;const XBp={toc:[]},_Bp="wrapper";function wBp(e){let{components:n,...t}=e;return(0,s.yg)(_Bp,(0,p.A)({},XBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}wBp.isMDXComponent=!0;const TBp={toc:[]},CBp="wrapper";function xBp(e){let{components:n,...t}=e;return(0,s.yg)(CBp,(0,p.A)({},TBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}xBp.isMDXComponent=!0;const ABp={toc:[]},vBp="wrapper";function LBp(e){let{components:n,...t}=e;return(0,s.yg)(vBp,(0,p.A)({},ABp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}LBp.isMDXComponent=!0;const bBp={toc:[]},NBp="wrapper";function kBp(e){let{components:n,...t}=e;return(0,s.yg)(NBp,(0,p.A)({},bBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kBp.isMDXComponent=!0;const zBp={toc:[]},PBp="wrapper";function IBp(e){let{components:n,...t}=e;return(0,s.yg)(PBp,(0,p.A)({},zBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}IBp.isMDXComponent=!0;const RBp={toc:[]},WBp="wrapper";function SBp(e){let{components:n,...t}=e;return(0,s.yg)(WBp,(0,p.A)({},RBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}SBp.isMDXComponent=!0;const BBp={toc:[]},GBp="wrapper";function EBp(e){let{components:n,...t}=e;return(0,s.yg)(GBp,(0,p.A)({},BBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}EBp.isMDXComponent=!0;const OBp={toc:[]},UBp="wrapper";function FBp(e){let{components:n,...t}=e;return(0,s.yg)(UBp,(0,p.A)({},OBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FBp.isMDXComponent=!0;const VBp={toc:[]},qBp="wrapper";function jBp(e){let{components:n,...t}=e;return(0,s.yg)(qBp,(0,p.A)({},VBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}jBp.isMDXComponent=!0;const HBp={toc:[]},YBp="wrapper";function QBp(e){let{components:n,...t}=e;return(0,s.yg)(YBp,(0,p.A)({},HBp,t,{components:n,mdxType:"MDXLayout"}))}QBp.isMDXComponent=!0;const $Bp={toc:[]},KBp="wrapper";function JBp(e){let{components:n,...t}=e;return(0,s.yg)(KBp,(0,p.A)({},$Bp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}JBp.isMDXComponent=!0;const ZBp={toc:[]},eGp="wrapper";function nGp(e){let{components:n,...t}=e;return(0,s.yg)(eGp,(0,p.A)({},ZBp,t,{components:n,mdxType:"MDXLayout"}))}nGp.isMDXComponent=!0;const tGp={toc:[]},oGp="wrapper";function pGp(e){let{components:n,...t}=e;return(0,s.yg)(oGp,(0,p.A)({},tGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}pGp.isMDXComponent=!0;const rGp={toc:[]},sGp="wrapper";function cGp(e){let{components:n,...t}=e;return(0,s.yg)(sGp,(0,p.A)({},rGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}cGp.isMDXComponent=!0;const aGp={toc:[]},iGp="wrapper";function lGp(e){let{components:n,...t}=e;return(0,s.yg)(iGp,(0,p.A)({},aGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lGp.isMDXComponent=!0;const uGp={toc:[]},mGp="wrapper";function yGp(e){let{components:n,...t}=e;return(0,s.yg)(mGp,(0,p.A)({},uGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}yGp.isMDXComponent=!0;const dGp={toc:[]},hGp="wrapper";function gGp(e){let{components:n,...t}=e;return(0,s.yg)(hGp,(0,p.A)({},dGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}gGp.isMDXComponent=!0;const fGp={toc:[]},DGp="wrapper";function MGp(e){let{components:n,...t}=e;return(0,s.yg)(DGp,(0,p.A)({},fGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}MGp.isMDXComponent=!0;const XGp={toc:[]},_Gp="wrapper";function wGp(e){let{components:n,...t}=e;return(0,s.yg)(_Gp,(0,p.A)({},XGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wGp.isMDXComponent=!0;const TGp={toc:[]},CGp="wrapper";function xGp(e){let{components:n,...t}=e;return(0,s.yg)(CGp,(0,p.A)({},TGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}xGp.isMDXComponent=!0;const AGp={toc:[]},vGp="wrapper";function LGp(e){let{components:n,...t}=e;return(0,s.yg)(vGp,(0,p.A)({},AGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LGp.isMDXComponent=!0;const bGp={toc:[]},NGp="wrapper";function kGp(e){let{components:n,...t}=e;return(0,s.yg)(NGp,(0,p.A)({},bGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}kGp.isMDXComponent=!0;const zGp={toc:[]},PGp="wrapper";function IGp(e){let{components:n,...t}=e;return(0,s.yg)(PGp,(0,p.A)({},zGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}IGp.isMDXComponent=!0;const RGp={toc:[]},WGp="wrapper";function SGp(e){let{components:n,...t}=e;return(0,s.yg)(WGp,(0,p.A)({},RGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}SGp.isMDXComponent=!0;const BGp={toc:[]},GGp="wrapper";function EGp(e){let{components:n,...t}=e;return(0,s.yg)(GGp,(0,p.A)({},BGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom drawing logic used by the Code node."))}EGp.isMDXComponent=!0;const OGp={toc:[]},UGp="wrapper";function FGp(e){let{components:n,...t}=e;return(0,s.yg)(UGp,(0,p.A)({},OGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"token(ctx, text, position, color, selection) {\n  const blur = map(3, 0, selection);\n  const alpha = map(0.5, 1, selection);\n  ctx.globalAlpha *= alpha;\n  ctx.filter = `blur(${blur}px)`;\n  ctx.fillStyle = color;\n  ctx.fillText(text, position.x, position.y);\n}\n")))}FGp.isMDXComponent=!0;const VGp={toc:[]},qGp="wrapper";function jGp(e){let{components:n,...t}=e;return(0,s.yg)(qGp,(0,p.A)({},VGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for individual code tokens."))}jGp.isMDXComponent=!0;const HGp={toc:[]},YGp="wrapper";function QGp(e){let{components:n,...t}=e;return(0,s.yg)(YGp,(0,p.A)({},HGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QGp.isMDXComponent=!0;const $Gp={toc:[]},KGp="wrapper";function JGp(e){let{components:n,...t}=e;return(0,s.yg)(KGp,(0,p.A)({},$Gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}JGp.isMDXComponent=!0;const ZGp={toc:[]},eEp="wrapper";function nEp(e){let{components:n,...t}=e;return(0,s.yg)(eEp,(0,p.A)({},ZGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nEp.isMDXComponent=!0;const tEp={toc:[]},oEp="wrapper";function pEp(e){let{components:n,...t}=e;return(0,s.yg)(oEp,(0,p.A)({},tEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}pEp.isMDXComponent=!0;const rEp={toc:[]},sEp="wrapper";function cEp(e){let{components:n,...t}=e;return(0,s.yg)(sEp,(0,p.A)({},rEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cEp.isMDXComponent=!0;const aEp={toc:[]},iEp="wrapper";function lEp(e){let{components:n,...t}=e;return(0,s.yg)(iEp,(0,p.A)({},aEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}lEp.isMDXComponent=!0;const uEp={toc:[]},mEp="wrapper";function yEp(e){let{components:n,...t}=e;return(0,s.yg)(mEp,(0,p.A)({},uEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yEp.isMDXComponent=!0;const dEp={toc:[]},hEp="wrapper";function gEp(e){let{components:n,...t}=e;return(0,s.yg)(hEp,(0,p.A)({},dEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gEp.isMDXComponent=!0;const fEp={toc:[]},DEp="wrapper";function MEp(e){let{components:n,...t}=e;return(0,s.yg)(DEp,(0,p.A)({},fEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}MEp.isMDXComponent=!0;const XEp={toc:[]},_Ep="wrapper";function wEp(e){let{components:n,...t}=e;return(0,s.yg)(_Ep,(0,p.A)({},XEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wEp.isMDXComponent=!0;const TEp={toc:[]},CEp="wrapper";function xEp(e){let{components:n,...t}=e;return(0,s.yg)(CEp,(0,p.A)({},TEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xEp.isMDXComponent=!0;const AEp={toc:[]},vEp="wrapper";function LEp(e){let{components:n,...t}=e;return(0,s.yg)(vEp,(0,p.A)({},AEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}LEp.isMDXComponent=!0;const bEp={toc:[]},NEp="wrapper";function kEp(e){let{components:n,...t}=e;return(0,s.yg)(NEp,(0,p.A)({},bEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kEp.isMDXComponent=!0;const zEp={toc:[]},PEp="wrapper";function IEp(e){let{components:n,...t}=e;return(0,s.yg)(PEp,(0,p.A)({},zEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IEp.isMDXComponent=!0;const REp={toc:[]},WEp="wrapper";function SEp(e){let{components:n,...t}=e;return(0,s.yg)(WEp,(0,p.A)({},REp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SEp.isMDXComponent=!0;const BEp={toc:[]},GEp="wrapper";function EEp(e){let{components:n,...t}=e;return(0,s.yg)(GEp,(0,p.A)({},BEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}EEp.isMDXComponent=!0;const OEp={toc:[]},UEp="wrapper";function FEp(e){let{components:n,...t}=e;return(0,s.yg)(UEp,(0,p.A)({},OEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}FEp.isMDXComponent=!0;const VEp={toc:[]},qEp="wrapper";function jEp(e){let{components:n,...t}=e;return(0,s.yg)(qEp,(0,p.A)({},VEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the end of each grid line."))}jEp.isMDXComponent=!0;const HEp={toc:[]},YEp="wrapper";function QEp(e){let{components:n,...t}=e;return(0,s.yg)(YEp,(0,p.A)({},HEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QEp.isMDXComponent=!0;const $Ep={toc:[]},KEp="wrapper";function JEp(e){let{components:n,...t}=e;return(0,s.yg)(KEp,(0,p.A)({},$Ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}JEp.isMDXComponent=!0;const ZEp={toc:[]},eOp="wrapper";function nOp(e){let{components:n,...t}=e;return(0,s.yg)(eOp,(0,p.A)({},ZEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}nOp.isMDXComponent=!0;const tOp={toc:[]},oOp="wrapper";function pOp(e){let{components:n,...t}=e;return(0,s.yg)(oOp,(0,p.A)({},tOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}pOp.isMDXComponent=!0;const rOp={toc:[]},sOp="wrapper";function cOp(e){let{components:n,...t}=e;return(0,s.yg)(sOp,(0,p.A)({},rOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cOp.isMDXComponent=!0;const aOp={toc:[]},iOp="wrapper";function lOp(e){let{components:n,...t}=e;return(0,s.yg)(iOp,(0,p.A)({},aOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}lOp.isMDXComponent=!0;const uOp={toc:[]},mOp="wrapper";function yOp(e){let{components:n,...t}=e;return(0,s.yg)(mOp,(0,p.A)({},uOp,t,{components:n,mdxType:"MDXLayout"}))}yOp.isMDXComponent=!0;const dOp={toc:[]},hOp="wrapper";function gOp(e){let{components:n,...t}=e;return(0,s.yg)(hOp,(0,p.A)({},dOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The spacing between the grid lines."))}gOp.isMDXComponent=!0;const fOp={toc:[]},DOp="wrapper";function MOp(e){let{components:n,...t}=e;return(0,s.yg)(DOp,(0,p.A)({},fOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}MOp.isMDXComponent=!0;const XOp={toc:[]},_Op="wrapper";function wOp(e){let{components:n,...t}=e;return(0,s.yg)(_Op,(0,p.A)({},XOp,t,{components:n,mdxType:"MDXLayout"}))}wOp.isMDXComponent=!0;const TOp={toc:[]},COp="wrapper";function xOp(e){let{components:n,...t}=e;return(0,s.yg)(COp,(0,p.A)({},TOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}xOp.isMDXComponent=!0;const AOp={toc:[]},vOp="wrapper";function LOp(e){let{components:n,...t}=e;return(0,s.yg)(vOp,(0,p.A)({},AOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}LOp.isMDXComponent=!0;const bOp={toc:[]},NOp="wrapper";function kOp(e){let{components:n,...t}=e;return(0,s.yg)(NOp,(0,p.A)({},bOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kOp.isMDXComponent=!0;const zOp={toc:[]},POp="wrapper";function IOp(e){let{components:n,...t}=e;return(0,s.yg)(POp,(0,p.A)({},zOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}IOp.isMDXComponent=!0;const ROp={toc:[]},WOp="wrapper";function SOp(e){let{components:n,...t}=e;return(0,s.yg)(WOp,(0,p.A)({},ROp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SOp.isMDXComponent=!0;const BOp={toc:[]},GOp="wrapper";function EOp(e){let{components:n,...t}=e;return(0,s.yg)(GOp,(0,p.A)({},BOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}EOp.isMDXComponent=!0;const OOp={toc:[]},UOp="wrapper";function FOp(e){let{components:n,...t}=e;return(0,s.yg)(UOp,(0,p.A)({},OOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FOp.isMDXComponent=!0;const VOp={toc:[]},qOp="wrapper";function jOp(e){let{components:n,...t}=e;return(0,s.yg)(qOp,(0,p.A)({},VOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}jOp.isMDXComponent=!0;const HOp={toc:[]},YOp="wrapper";function QOp(e){let{components:n,...t}=e;return(0,s.yg)(YOp,(0,p.A)({},HOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}QOp.isMDXComponent=!0;const $Op={toc:[]},KOp="wrapper";function JOp(e){let{components:n,...t}=e;return(0,s.yg)(KOp,(0,p.A)({},$Op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}JOp.isMDXComponent=!0;const ZOp={toc:[]},eUp="wrapper";function nUp(e){let{components:n,...t}=e;return(0,s.yg)(eUp,(0,p.A)({},ZOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}nUp.isMDXComponent=!0;const tUp={toc:[]},oUp="wrapper";function pUp(e){let{components:n,...t}=e;return(0,s.yg)(oUp,(0,p.A)({},tUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}pUp.isMDXComponent=!0;const rUp={toc:[]},sUp="wrapper";function cUp(e){let{components:n,...t}=e;return(0,s.yg)(sUp,(0,p.A)({},rUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cUp.isMDXComponent=!0;const aUp={toc:[]},iUp="wrapper";function lUp(e){let{components:n,...t}=e;return(0,s.yg)(iUp,(0,p.A)({},aUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}lUp.isMDXComponent=!0;const uUp={toc:[]},mUp="wrapper";function yUp(e){let{components:n,...t}=e;return(0,s.yg)(mUp,(0,p.A)({},uUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yUp.isMDXComponent=!0;const dUp={toc:[]},hUp="wrapper";function gUp(e){let{components:n,...t}=e;return(0,s.yg)(hUp,(0,p.A)({},dUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}gUp.isMDXComponent=!0;const fUp={toc:[]},DUp="wrapper";function MUp(e){let{components:n,...t}=e;return(0,s.yg)(DUp,(0,p.A)({},fUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MUp.isMDXComponent=!0;const XUp={toc:[]},_Up="wrapper";function wUp(e){let{components:n,...t}=e;return(0,s.yg)(_Up,(0,p.A)({},XUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}wUp.isMDXComponent=!0;const TUp={toc:[]},CUp="wrapper";function xUp(e){let{components:n,...t}=e;return(0,s.yg)(CUp,(0,p.A)({},TUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xUp.isMDXComponent=!0;const AUp={toc:[]},vUp="wrapper";function LUp(e){let{components:n,...t}=e;return(0,s.yg)(vUp,(0,p.A)({},AUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}LUp.isMDXComponent=!0;const bUp={toc:[]},NUp="wrapper";function kUp(e){let{components:n,...t}=e;return(0,s.yg)(NUp,(0,p.A)({},bUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kUp.isMDXComponent=!0;const zUp={toc:[]},PUp="wrapper";function IUp(e){let{components:n,...t}=e;return(0,s.yg)(PUp,(0,p.A)({},zUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IUp.isMDXComponent=!0;const RUp={toc:[]},WUp="wrapper";function SUp(e){let{components:n,...t}=e;return(0,s.yg)(WUp,(0,p.A)({},RUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SUp.isMDXComponent=!0;const BUp={toc:[]},GUp="wrapper";function EUp(e){let{components:n,...t}=e;return(0,s.yg)(GUp,(0,p.A)({},BUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}EUp.isMDXComponent=!0;const OUp={toc:[]},UUp="wrapper";function FUp(e){let{components:n,...t}=e;return(0,s.yg)(UUp,(0,p.A)({},OUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}FUp.isMDXComponent=!0;const VUp={toc:[]},qUp="wrapper";function jUp(e){let{components:n,...t}=e;return(0,s.yg)(qUp,(0,p.A)({},VUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jUp.isMDXComponent=!0;const HUp={toc:[]},YUp="wrapper";function QUp(e){let{components:n,...t}=e;return(0,s.yg)(YUp,(0,p.A)({},HUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}QUp.isMDXComponent=!0;const $Up={toc:[]},KUp="wrapper";function JUp(e){let{components:n,...t}=e;return(0,s.yg)(KUp,(0,p.A)({},$Up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}JUp.isMDXComponent=!0;const ZUp={toc:[]},eFp="wrapper";function nFp(e){let{components:n,...t}=e;return(0,s.yg)(eFp,(0,p.A)({},ZUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}nFp.isMDXComponent=!0;const tFp={toc:[]},oFp="wrapper";function pFp(e){let{components:n,...t}=e;return(0,s.yg)(oFp,(0,p.A)({},tFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}pFp.isMDXComponent=!0;const rFp={toc:[]},sFp="wrapper";function cFp(e){let{components:n,...t}=e;return(0,s.yg)(sFp,(0,p.A)({},rFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide the color in one of the following formats:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"named color like ",(0,s.yg)("inlineCode",{parentName:"li"},"red"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.yg)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.yg)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}cFp.isMDXComponent=!0;const aFp={toc:[]},iFp="wrapper";function lFp(e){let{components:n,...t}=e;return(0,s.yg)(iFp,(0,p.A)({},aFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the icon"))}lFp.isMDXComponent=!0;const uFp={toc:[]},mFp="wrapper";function yFp(e){let{components:n,...t}=e;return(0,s.yg)(mFp,(0,p.A)({},uFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}yFp.isMDXComponent=!0;const dFp={toc:[]},hFp="wrapper";function gFp(e){let{components:n,...t}=e;return(0,s.yg)(hFp,(0,p.A)({},dFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}gFp.isMDXComponent=!0;const fFp={toc:[]},DFp="wrapper";function MFp(e){let{components:n,...t}=e;return(0,s.yg)(DFp,(0,p.A)({},fFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}MFp.isMDXComponent=!0;const XFp={toc:[]},_Fp="wrapper";function wFp(e){let{components:n,...t}=e;return(0,s.yg)(_Fp,(0,p.A)({},XFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}wFp.isMDXComponent=!0;const TFp={toc:[]},CFp="wrapper";function xFp(e){let{components:n,...t}=e;return(0,s.yg)(CFp,(0,p.A)({},TFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xFp.isMDXComponent=!0;const AFp={toc:[]},vFp="wrapper";function LFp(e){let{components:n,...t}=e;return(0,s.yg)(vFp,(0,p.A)({},AFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}LFp.isMDXComponent=!0;const bFp={toc:[]},NFp="wrapper";function kFp(e){let{components:n,...t}=e;return(0,s.yg)(NFp,(0,p.A)({},bFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kFp.isMDXComponent=!0;const zFp={toc:[]},PFp="wrapper";function IFp(e){let{components:n,...t}=e;return(0,s.yg)(PFp,(0,p.A)({},zFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}IFp.isMDXComponent=!0;const RFp={toc:[]},WFp="wrapper";function SFp(e){let{components:n,...t}=e;return(0,s.yg)(WFp,(0,p.A)({},RFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can find identifiers on ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}SFp.isMDXComponent=!0;const BFp={toc:[]},GFp="wrapper";function EFp(e){let{components:n,...t}=e;return(0,s.yg)(GFp,(0,p.A)({},BFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The identifier of the icon."))}EFp.isMDXComponent=!0;const OFp={toc:[]},UFp="wrapper";function FFp(e){let{components:n,...t}=e;return(0,s.yg)(UFp,(0,p.A)({},OFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FFp.isMDXComponent=!0;const VFp={toc:[]},qFp="wrapper";function jFp(e){let{components:n,...t}=e;return(0,s.yg)(qFp,(0,p.A)({},VFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}jFp.isMDXComponent=!0;const HFp={toc:[]},YFp="wrapper";function QFp(e){let{components:n,...t}=e;return(0,s.yg)(YFp,(0,p.A)({},HFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}QFp.isMDXComponent=!0;const $Fp={toc:[]},KFp="wrapper";function JFp(e){let{components:n,...t}=e;return(0,s.yg)(KFp,(0,p.A)({},$Fp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}JFp.isMDXComponent=!0;const ZFp={toc:[]},eVp="wrapper";function nVp(e){let{components:n,...t}=e;return(0,s.yg)(eVp,(0,p.A)({},ZFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}nVp.isMDXComponent=!0;const tVp={toc:[]},oVp="wrapper";function pVp(e){let{components:n,...t}=e;return(0,s.yg)(oVp,(0,p.A)({},tVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}pVp.isMDXComponent=!0;const rVp={toc:[]},sVp="wrapper";function cVp(e){let{components:n,...t}=e;return(0,s.yg)(sVp,(0,p.A)({},rVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cVp.isMDXComponent=!0;const aVp={toc:[]},iVp="wrapper";function lVp(e){let{components:n,...t}=e;return(0,s.yg)(iVp,(0,p.A)({},aVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}lVp.isMDXComponent=!0;const uVp={toc:[]},mVp="wrapper";function yVp(e){let{components:n,...t}=e;return(0,s.yg)(mVp,(0,p.A)({},uVp,t,{components:n,mdxType:"MDXLayout"}))}yVp.isMDXComponent=!0;const dVp={toc:[]},hVp="wrapper";function gVp(e){let{components:n,...t}=e;return(0,s.yg)(hVp,(0,p.A)({},dVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}gVp.isMDXComponent=!0;const fVp={toc:[]},DVp="wrapper";function MVp(e){let{components:n,...t}=e;return(0,s.yg)(DVp,(0,p.A)({},fVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}MVp.isMDXComponent=!0;const XVp={toc:[]},_Vp="wrapper";function wVp(e){let{components:n,...t}=e;return(0,s.yg)(_Vp,(0,p.A)({},XVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}wVp.isMDXComponent=!0;const TVp={toc:[]},CVp="wrapper";function xVp(e){let{components:n,...t}=e;return(0,s.yg)(CVp,(0,p.A)({},TVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}xVp.isMDXComponent=!0;const AVp={toc:[]},vVp="wrapper";function LVp(e){let{components:n,...t}=e;return(0,s.yg)(vVp,(0,p.A)({},AVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}LVp.isMDXComponent=!0;const bVp={toc:[]},NVp="wrapper";function kVp(e){let{components:n,...t}=e;return(0,s.yg)(NVp,(0,p.A)({},bVp,t,{components:n,mdxType:"MDXLayout"}))}kVp.isMDXComponent=!0;const zVp={toc:[]},PVp="wrapper";function IVp(e){let{components:n,...t}=e;return(0,s.yg)(PVp,(0,p.A)({},zVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}IVp.isMDXComponent=!0;const RVp={toc:[]},WVp="wrapper";function SVp(e){let{components:n,...t}=e;return(0,s.yg)(WVp,(0,p.A)({},RVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}SVp.isMDXComponent=!0;const BVp={toc:[]},GVp="wrapper";function EVp(e){let{components:n,...t}=e;return(0,s.yg)(GVp,(0,p.A)({},BVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}EVp.isMDXComponent=!0;const OVp={toc:[]},UVp="wrapper";function FVp(e){let{components:n,...t}=e;return(0,s.yg)(UVp,(0,p.A)({},OVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}FVp.isMDXComponent=!0;const VVp={toc:[]},qVp="wrapper";function jVp(e){let{components:n,...t}=e;return(0,s.yg)(qVp,(0,p.A)({},VVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}jVp.isMDXComponent=!0;const HVp={toc:[]},YVp="wrapper";function QVp(e){let{components:n,...t}=e;return(0,s.yg)(YVp,(0,p.A)({},HVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}QVp.isMDXComponent=!0;const $Vp={toc:[]},KVp="wrapper";function JVp(e){let{components:n,...t}=e;return(0,s.yg)(KVp,(0,p.A)({},$Vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}JVp.isMDXComponent=!0;const ZVp={toc:[]},eqp="wrapper";function nqp(e){let{components:n,...t}=e;return(0,s.yg)(eqp,(0,p.A)({},ZVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nqp.isMDXComponent=!0;const tqp={toc:[]},oqp="wrapper";function pqp(e){let{components:n,...t}=e;return(0,s.yg)(oqp,(0,p.A)({},tqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}pqp.isMDXComponent=!0;const rqp={toc:[]},sqp="wrapper";function cqp(e){let{components:n,...t}=e;return(0,s.yg)(sqp,(0,p.A)({},rqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cqp.isMDXComponent=!0;const aqp={toc:[]},iqp="wrapper";function lqp(e){let{components:n,...t}=e;return(0,s.yg)(iqp,(0,p.A)({},aqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}lqp.isMDXComponent=!0;const uqp={toc:[]},mqp="wrapper";function yqp(e){let{components:n,...t}=e;return(0,s.yg)(mqp,(0,p.A)({},uqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yqp.isMDXComponent=!0;const dqp={toc:[]},hqp="wrapper";function gqp(e){let{components:n,...t}=e;return(0,s.yg)(hqp,(0,p.A)({},dqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}gqp.isMDXComponent=!0;const fqp={toc:[]},Dqp="wrapper";function Mqp(e){let{components:n,...t}=e;return(0,s.yg)(Dqp,(0,p.A)({},fqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Mqp.isMDXComponent=!0;const Xqp={toc:[]},_qp="wrapper";function wqp(e){let{components:n,...t}=e;return(0,s.yg)(_qp,(0,p.A)({},Xqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}wqp.isMDXComponent=!0;const Tqp={toc:[]},Cqp="wrapper";function xqp(e){let{components:n,...t}=e;return(0,s.yg)(Cqp,(0,p.A)({},Tqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}xqp.isMDXComponent=!0;const Aqp={toc:[]},vqp="wrapper";function Lqp(e){let{components:n,...t}=e;return(0,s.yg)(vqp,(0,p.A)({},Aqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Lqp.isMDXComponent=!0;const bqp={toc:[]},Nqp="wrapper";function kqp(e){let{components:n,...t}=e;return(0,s.yg)(Nqp,(0,p.A)({},bqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kqp.isMDXComponent=!0;const zqp={toc:[]},Pqp="wrapper";function Iqp(e){let{components:n,...t}=e;return(0,s.yg)(Pqp,(0,p.A)({},zqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Iqp.isMDXComponent=!0;const Rqp={toc:[]},Wqp="wrapper";function Sqp(e){let{components:n,...t}=e;return(0,s.yg)(Wqp,(0,p.A)({},Rqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Sqp.isMDXComponent=!0;const Bqp={toc:[]},Gqp="wrapper";function Eqp(e){let{components:n,...t}=e;return(0,s.yg)(Gqp,(0,p.A)({},Bqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Eqp.isMDXComponent=!0;const Oqp={toc:[]},Uqp="wrapper";function Fqp(e){let{components:n,...t}=e;return(0,s.yg)(Uqp,(0,p.A)({},Oqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Fqp.isMDXComponent=!0;const Vqp={toc:[]},qqp="wrapper";function jqp(e){let{components:n,...t}=e;return(0,s.yg)(qqp,(0,p.A)({},Vqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}jqp.isMDXComponent=!0;const Hqp={toc:[]},Yqp="wrapper";function Qqp(e){let{components:n,...t}=e;return(0,s.yg)(Yqp,(0,p.A)({},Hqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Qqp.isMDXComponent=!0;const $qp={toc:[]},Kqp="wrapper";function Jqp(e){let{components:n,...t}=e;return(0,s.yg)(Kqp,(0,p.A)({},$qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Jqp.isMDXComponent=!0;const Zqp={toc:[]},ejp="wrapper";function njp(e){let{components:n,...t}=e;return(0,s.yg)(ejp,(0,p.A)({},Zqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}njp.isMDXComponent=!0;const tjp={toc:[]},ojp="wrapper";function pjp(e){let{components:n,...t}=e;return(0,s.yg)(ojp,(0,p.A)({},tjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}pjp.isMDXComponent=!0;const rjp={toc:[]},sjp="wrapper";function cjp(e){let{components:n,...t}=e;return(0,s.yg)(sjp,(0,p.A)({},rjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cjp.isMDXComponent=!0;const ajp={toc:[]},ijp="wrapper";function ljp(e){let{components:n,...t}=e;return(0,s.yg)(ijp,(0,p.A)({},ajp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ljp.isMDXComponent=!0;const ujp={toc:[]},mjp="wrapper";function yjp(e){let{components:n,...t}=e;return(0,s.yg)(mjp,(0,p.A)({},ujp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yjp.isMDXComponent=!0;const djp={toc:[]},hjp="wrapper";function gjp(e){let{components:n,...t}=e;return(0,s.yg)(hjp,(0,p.A)({},djp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gjp.isMDXComponent=!0;const fjp={toc:[]},Djp="wrapper";function Mjp(e){let{components:n,...t}=e;return(0,s.yg)(Djp,(0,p.A)({},fjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Mjp.isMDXComponent=!0;const Xjp={toc:[]},_jp="wrapper";function wjp(e){let{components:n,...t}=e;return(0,s.yg)(_jp,(0,p.A)({},Xjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wjp.isMDXComponent=!0;const Tjp={toc:[]},Cjp="wrapper";function xjp(e){let{components:n,...t}=e;return(0,s.yg)(Cjp,(0,p.A)({},Tjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}xjp.isMDXComponent=!0;const Ajp={toc:[]},vjp="wrapper";function Ljp(e){let{components:n,...t}=e;return(0,s.yg)(vjp,(0,p.A)({},Ajp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Ljp.isMDXComponent=!0;const bjp={toc:[]},Njp="wrapper";function kjp(e){let{components:n,...t}=e;return(0,s.yg)(Njp,(0,p.A)({},bjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}kjp.isMDXComponent=!0;const zjp={toc:[]},Pjp="wrapper";function Ijp(e){let{components:n,...t}=e;return(0,s.yg)(Pjp,(0,p.A)({},zjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Ijp.isMDXComponent=!0;const Rjp={toc:[]},Wjp="wrapper";function Sjp(e){let{components:n,...t}=e;return(0,s.yg)(Wjp,(0,p.A)({},Rjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Sjp.isMDXComponent=!0;const Bjp={toc:[]},Gjp="wrapper";function Ejp(e){let{components:n,...t}=e;return(0,s.yg)(Gjp,(0,p.A)({},Bjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Ejp.isMDXComponent=!0;const Ojp={toc:[]},Ujp="wrapper";function Fjp(e){let{components:n,...t}=e;return(0,s.yg)(Ujp,(0,p.A)({},Ojp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Fjp.isMDXComponent=!0;const Vjp={toc:[]},qjp="wrapper";function jjp(e){let{components:n,...t}=e;return(0,s.yg)(qjp,(0,p.A)({},Vjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}jjp.isMDXComponent=!0;const Hjp={toc:[]},Yjp="wrapper";function Qjp(e){let{components:n,...t}=e;return(0,s.yg)(Yjp,(0,p.A)({},Hjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Qjp.isMDXComponent=!0;const $jp={toc:[]},Kjp="wrapper";function Jjp(e){let{components:n,...t}=e;return(0,s.yg)(Kjp,(0,p.A)({},$jp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Jjp.isMDXComponent=!0;const Zjp={toc:[]},eHp="wrapper";function nHp(e){let{components:n,...t}=e;return(0,s.yg)(eHp,(0,p.A)({},Zjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nHp.isMDXComponent=!0;const tHp={toc:[]},oHp="wrapper";function pHp(e){let{components:n,...t}=e;return(0,s.yg)(oHp,(0,p.A)({},tHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}pHp.isMDXComponent=!0;const rHp={toc:[]},sHp="wrapper";function cHp(e){let{components:n,...t}=e;return(0,s.yg)(sHp,(0,p.A)({},rHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}cHp.isMDXComponent=!0;const aHp={toc:[]},iHp="wrapper";function lHp(e){let{components:n,...t}=e;return(0,s.yg)(iHp,(0,p.A)({},aHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}lHp.isMDXComponent=!0;const uHp={toc:[]},mHp="wrapper";function yHp(e){let{components:n,...t}=e;return(0,s.yg)(mHp,(0,p.A)({},uHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}yHp.isMDXComponent=!0;const dHp={toc:[]},hHp="wrapper";function gHp(e){let{components:n,...t}=e;return(0,s.yg)(hHp,(0,p.A)({},dHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}gHp.isMDXComponent=!0;const fHp={toc:[]},DHp="wrapper";function MHp(e){let{components:n,...t}=e;return(0,s.yg)(DHp,(0,p.A)({},fHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MHp.isMDXComponent=!0;const XHp={toc:[]},_Hp="wrapper";function wHp(e){let{components:n,...t}=e;return(0,s.yg)(_Hp,(0,p.A)({},XHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}wHp.isMDXComponent=!0;const THp={toc:[]},CHp="wrapper";function xHp(e){let{components:n,...t}=e;return(0,s.yg)(CHp,(0,p.A)({},THp,t,{components:n,mdxType:"MDXLayout"}))}xHp.isMDXComponent=!0;const AHp={toc:[]},vHp="wrapper";function LHp(e){let{components:n,...t}=e;return(0,s.yg)(vHp,(0,p.A)({},AHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}LHp.isMDXComponent=!0;const bHp={toc:[]},NHp="wrapper";function kHp(e){let{components:n,...t}=e;return(0,s.yg)(NHp,(0,p.A)({},bHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}kHp.isMDXComponent=!0;const zHp={toc:[]},PHp="wrapper";function IHp(e){let{components:n,...t}=e;return(0,s.yg)(PHp,(0,p.A)({},zHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}IHp.isMDXComponent=!0;const RHp={toc:[]},WHp="wrapper";function SHp(e){let{components:n,...t}=e;return(0,s.yg)(WHp,(0,p.A)({},RHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}SHp.isMDXComponent=!0;const BHp={toc:[]},GHp="wrapper";function EHp(e){let{components:n,...t}=e;return(0,s.yg)(GHp,(0,p.A)({},BHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}EHp.isMDXComponent=!0;const OHp={toc:[]},UHp="wrapper";function FHp(e){let{components:n,...t}=e;return(0,s.yg)(UHp,(0,p.A)({},OHp,t,{components:n,mdxType:"MDXLayout"}))}FHp.isMDXComponent=!0;const VHp={toc:[]},qHp="wrapper";function jHp(e){let{components:n,...t}=e;return(0,s.yg)(qHp,(0,p.A)({},VHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}jHp.isMDXComponent=!0;const HHp={toc:[]},YHp="wrapper";function QHp(e){let{components:n,...t}=e;return(0,s.yg)(YHp,(0,p.A)({},HHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}QHp.isMDXComponent=!0;const $Hp={toc:[]},KHp="wrapper";function JHp(e){let{components:n,...t}=e;return(0,s.yg)(KHp,(0,p.A)({},$Hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}JHp.isMDXComponent=!0;const ZHp={toc:[]},eYp="wrapper";function nYp(e){let{components:n,...t}=e;return(0,s.yg)(eYp,(0,p.A)({},ZHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nYp.isMDXComponent=!0;const tYp={toc:[]},oYp="wrapper";function pYp(e){let{components:n,...t}=e;return(0,s.yg)(oYp,(0,p.A)({},tYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}pYp.isMDXComponent=!0;const rYp={toc:[]},sYp="wrapper";function cYp(e){let{components:n,...t}=e;return(0,s.yg)(sYp,(0,p.A)({},rYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}cYp.isMDXComponent=!0;const aYp={toc:[]},iYp="wrapper";function lYp(e){let{components:n,...t}=e;return(0,s.yg)(iYp,(0,p.A)({},aYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}lYp.isMDXComponent=!0;const uYp={toc:[]},mYp="wrapper";function yYp(e){let{components:n,...t}=e;return(0,s.yg)(mYp,(0,p.A)({},uYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yYp.isMDXComponent=!0;const dYp={toc:[]},hYp="wrapper";function gYp(e){let{components:n,...t}=e;return(0,s.yg)(hYp,(0,p.A)({},dYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}gYp.isMDXComponent=!0;const fYp={toc:[]},DYp="wrapper";function MYp(e){let{components:n,...t}=e;return(0,s.yg)(DYp,(0,p.A)({},fYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MYp.isMDXComponent=!0;const XYp={toc:[]},_Yp="wrapper";function wYp(e){let{components:n,...t}=e;return(0,s.yg)(_Yp,(0,p.A)({},XYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}wYp.isMDXComponent=!0;const TYp={toc:[]},CYp="wrapper";function xYp(e){let{components:n,...t}=e;return(0,s.yg)(CYp,(0,p.A)({},TYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xYp.isMDXComponent=!0;const AYp={toc:[]},vYp="wrapper";function LYp(e){let{components:n,...t}=e;return(0,s.yg)(vYp,(0,p.A)({},AYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}LYp.isMDXComponent=!0;const bYp={toc:[]},NYp="wrapper";function kYp(e){let{components:n,...t}=e;return(0,s.yg)(NYp,(0,p.A)({},bYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}kYp.isMDXComponent=!0;const zYp={toc:[]},PYp="wrapper";function IYp(e){let{components:n,...t}=e;return(0,s.yg)(PYp,(0,p.A)({},zYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}IYp.isMDXComponent=!0;const RYp={toc:[]},WYp="wrapper";function SYp(e){let{components:n,...t}=e;return(0,s.yg)(WYp,(0,p.A)({},RYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SYp.isMDXComponent=!0;const BYp={toc:[]},GYp="wrapper";function EYp(e){let{components:n,...t}=e;return(0,s.yg)(GYp,(0,p.A)({},BYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}EYp.isMDXComponent=!0;const OYp={toc:[]},UYp="wrapper";function FYp(e){let{components:n,...t}=e;return(0,s.yg)(UYp,(0,p.A)({},OYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}FYp.isMDXComponent=!0;const VYp={toc:[]},qYp="wrapper";function jYp(e){let{components:n,...t}=e;return(0,s.yg)(qYp,(0,p.A)({},VYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jYp.isMDXComponent=!0;const HYp={toc:[]},YYp="wrapper";function QYp(e){let{components:n,...t}=e;return(0,s.yg)(YYp,(0,p.A)({},HYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}QYp.isMDXComponent=!0;const $Yp={toc:[]},KYp="wrapper";function JYp(e){let{components:n,...t}=e;return(0,s.yg)(KYp,(0,p.A)({},$Yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}JYp.isMDXComponent=!0;const ZYp={toc:[]},eQp="wrapper";function nQp(e){let{components:n,...t}=e;return(0,s.yg)(eQp,(0,p.A)({},ZYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}nQp.isMDXComponent=!0;const tQp={toc:[]},oQp="wrapper";function pQp(e){let{components:n,...t}=e;return(0,s.yg)(oQp,(0,p.A)({},tQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}pQp.isMDXComponent=!0;const rQp={toc:[]},sQp="wrapper";function cQp(e){let{components:n,...t}=e;return(0,s.yg)(sQp,(0,p.A)({},rQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cQp.isMDXComponent=!0;const aQp={toc:[]},iQp="wrapper";function lQp(e){let{components:n,...t}=e;return(0,s.yg)(iQp,(0,p.A)({},aQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lQp.isMDXComponent=!0;const uQp={toc:[]},mQp="wrapper";function yQp(e){let{components:n,...t}=e;return(0,s.yg)(mQp,(0,p.A)({},uQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}yQp.isMDXComponent=!0;const dQp={toc:[]},hQp="wrapper";function gQp(e){let{components:n,...t}=e;return(0,s.yg)(hQp,(0,p.A)({},dQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}gQp.isMDXComponent=!0;const fQp={toc:[]},DQp="wrapper";function MQp(e){let{components:n,...t}=e;return(0,s.yg)(DQp,(0,p.A)({},fQp,t,{components:n,mdxType:"MDXLayout"}))}MQp.isMDXComponent=!0;const XQp={toc:[]},_Qp="wrapper";function wQp(e){let{components:n,...t}=e;return(0,s.yg)(_Qp,(0,p.A)({},XQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}wQp.isMDXComponent=!0;const TQp={toc:[]},CQp="wrapper";function xQp(e){let{components:n,...t}=e;return(0,s.yg)(CQp,(0,p.A)({},TQp,t,{components:n,mdxType:"MDXLayout"}))}xQp.isMDXComponent=!0;const AQp={toc:[]},vQp="wrapper";function LQp(e){let{components:n,...t}=e;return(0,s.yg)(vQp,(0,p.A)({},AQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}LQp.isMDXComponent=!0;const bQp={toc:[]},NQp="wrapper";function kQp(e){let{components:n,...t}=e;return(0,s.yg)(NQp,(0,p.A)({},bQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}kQp.isMDXComponent=!0;const zQp={toc:[]},PQp="wrapper";function IQp(e){let{components:n,...t}=e;return(0,s.yg)(PQp,(0,p.A)({},zQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}IQp.isMDXComponent=!0;const RQp={toc:[]},WQp="wrapper";function SQp(e){let{components:n,...t}=e;return(0,s.yg)(WQp,(0,p.A)({},RQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}SQp.isMDXComponent=!0;const BQp={toc:[]},GQp="wrapper";function EQp(e){let{components:n,...t}=e;return(0,s.yg)(GQp,(0,p.A)({},BQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}EQp.isMDXComponent=!0;const OQp={toc:[]},UQp="wrapper";function FQp(e){let{components:n,...t}=e;return(0,s.yg)(UQp,(0,p.A)({},OQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}FQp.isMDXComponent=!0;const VQp={toc:[]},qQp="wrapper";function jQp(e){let{components:n,...t}=e;return(0,s.yg)(qQp,(0,p.A)({},VQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jQp.isMDXComponent=!0;const HQp={toc:[]},YQp="wrapper";function QQp(e){let{components:n,...t}=e;return(0,s.yg)(YQp,(0,p.A)({},HQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}QQp.isMDXComponent=!0;const $Qp={toc:[]},KQp="wrapper";function JQp(e){let{components:n,...t}=e;return(0,s.yg)(KQp,(0,p.A)({},$Qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JQp.isMDXComponent=!0;const ZQp={toc:[]},e$p="wrapper";function n$p(e){let{components:n,...t}=e;return(0,s.yg)(e$p,(0,p.A)({},ZQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}n$p.isMDXComponent=!0;const t$p={toc:[]},o$p="wrapper";function p$p(e){let{components:n,...t}=e;return(0,s.yg)(o$p,(0,p.A)({},t$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}p$p.isMDXComponent=!0;const r$p={toc:[]},s$p="wrapper";function c$p(e){let{components:n,...t}=e;return(0,s.yg)(s$p,(0,p.A)({},r$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}c$p.isMDXComponent=!0;const a$p={toc:[]},i$p="wrapper";function l$p(e){let{components:n,...t}=e;return(0,s.yg)(i$p,(0,p.A)({},a$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}l$p.isMDXComponent=!0;const u$p={toc:[]},m$p="wrapper";function y$p(e){let{components:n,...t}=e;return(0,s.yg)(m$p,(0,p.A)({},u$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}y$p.isMDXComponent=!0;const d$p={toc:[]},h$p="wrapper";function g$p(e){let{components:n,...t}=e;return(0,s.yg)(h$p,(0,p.A)({},d$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}g$p.isMDXComponent=!0;const f$p={toc:[]},D$p="wrapper";function M$p(e){let{components:n,...t}=e;return(0,s.yg)(D$p,(0,p.A)({},f$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}M$p.isMDXComponent=!0;const X$p={toc:[]},_$p="wrapper";function w$p(e){let{components:n,...t}=e;return(0,s.yg)(_$p,(0,p.A)({},X$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}w$p.isMDXComponent=!0;const T$p={toc:[]},C$p="wrapper";function x$p(e){let{components:n,...t}=e;return(0,s.yg)(C$p,(0,p.A)({},T$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}x$p.isMDXComponent=!0;const A$p={toc:[]},v$p="wrapper";function L$p(e){let{components:n,...t}=e;return(0,s.yg)(v$p,(0,p.A)({},A$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}L$p.isMDXComponent=!0;const b$p={toc:[]},N$p="wrapper";function k$p(e){let{components:n,...t}=e;return(0,s.yg)(N$p,(0,p.A)({},b$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}k$p.isMDXComponent=!0;const z$p={toc:[]},P$p="wrapper";function I$p(e){let{components:n,...t}=e;return(0,s.yg)(P$p,(0,p.A)({},z$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}I$p.isMDXComponent=!0;const R$p={toc:[]},W$p="wrapper";function S$p(e){let{components:n,...t}=e;return(0,s.yg)(W$p,(0,p.A)({},R$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}S$p.isMDXComponent=!0;const B$p={toc:[]},G$p="wrapper";function E$p(e){let{components:n,...t}=e;return(0,s.yg)(G$p,(0,p.A)({},B$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}E$p.isMDXComponent=!0;const O$p={toc:[]},U$p="wrapper";function F$p(e){let{components:n,...t}=e;return(0,s.yg)(U$p,(0,p.A)({},O$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}F$p.isMDXComponent=!0;const V$p={toc:[]},q$p="wrapper";function j$p(e){let{components:n,...t}=e;return(0,s.yg)(q$p,(0,p.A)({},V$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}j$p.isMDXComponent=!0;const H$p={toc:[]},Y$p="wrapper";function Q$p(e){let{components:n,...t}=e;return(0,s.yg)(Y$p,(0,p.A)({},H$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Q$p.isMDXComponent=!0;const $$p={toc:[]},K$p="wrapper";function J$p(e){let{components:n,...t}=e;return(0,s.yg)(K$p,(0,p.A)({},$$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}J$p.isMDXComponent=!0;const Z$p={toc:[]},eKp="wrapper";function nKp(e){let{components:n,...t}=e;return(0,s.yg)(eKp,(0,p.A)({},Z$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}nKp.isMDXComponent=!0;const tKp={toc:[]},oKp="wrapper";function pKp(e){let{components:n,...t}=e;return(0,s.yg)(oKp,(0,p.A)({},tKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pKp.isMDXComponent=!0;const rKp={toc:[]},sKp="wrapper";function cKp(e){let{components:n,...t}=e;return(0,s.yg)(sKp,(0,p.A)({},rKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}cKp.isMDXComponent=!0;const aKp={toc:[]},iKp="wrapper";function lKp(e){let{components:n,...t}=e;return(0,s.yg)(iKp,(0,p.A)({},aKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}lKp.isMDXComponent=!0;const uKp={toc:[]},mKp="wrapper";function yKp(e){let{components:n,...t}=e;return(0,s.yg)(mKp,(0,p.A)({},uKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}yKp.isMDXComponent=!0;const dKp={toc:[]},hKp="wrapper";function gKp(e){let{components:n,...t}=e;return(0,s.yg)(hKp,(0,p.A)({},dKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gKp.isMDXComponent=!0;const fKp={toc:[]},DKp="wrapper";function MKp(e){let{components:n,...t}=e;return(0,s.yg)(DKp,(0,p.A)({},fKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}MKp.isMDXComponent=!0;const XKp={toc:[]},_Kp="wrapper";function wKp(e){let{components:n,...t}=e;return(0,s.yg)(_Kp,(0,p.A)({},XKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}wKp.isMDXComponent=!0;const TKp={toc:[]},CKp="wrapper";function xKp(e){let{components:n,...t}=e;return(0,s.yg)(CKp,(0,p.A)({},TKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}xKp.isMDXComponent=!0;const AKp={toc:[]},vKp="wrapper";function LKp(e){let{components:n,...t}=e;return(0,s.yg)(vKp,(0,p.A)({},AKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}LKp.isMDXComponent=!0;const bKp={toc:[]},NKp="wrapper";function kKp(e){let{components:n,...t}=e;return(0,s.yg)(NKp,(0,p.A)({},bKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}kKp.isMDXComponent=!0;const zKp={toc:[]},PKp="wrapper";function IKp(e){let{components:n,...t}=e;return(0,s.yg)(PKp,(0,p.A)({},zKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}IKp.isMDXComponent=!0;const RKp={toc:[]},WKp="wrapper";function SKp(e){let{components:n,...t}=e;return(0,s.yg)(WKp,(0,p.A)({},RKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}SKp.isMDXComponent=!0;const BKp={toc:[]},GKp="wrapper";function EKp(e){let{components:n,...t}=e;return(0,s.yg)(GKp,(0,p.A)({},BKp,t,{components:n,mdxType:"MDXLayout"}))}EKp.isMDXComponent=!0;const OKp={toc:[]},UKp="wrapper";function FKp(e){let{components:n,...t}=e;return(0,s.yg)(UKp,(0,p.A)({},OKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}FKp.isMDXComponent=!0;const VKp={toc:[]},qKp="wrapper";function jKp(e){let{components:n,...t}=e;return(0,s.yg)(qKp,(0,p.A)({},VKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}jKp.isMDXComponent=!0;const HKp={toc:[]},YKp="wrapper";function QKp(e){let{components:n,...t}=e;return(0,s.yg)(YKp,(0,p.A)({},HKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}QKp.isMDXComponent=!0;const $Kp={toc:[]},KKp="wrapper";function JKp(e){let{components:n,...t}=e;return(0,s.yg)(KKp,(0,p.A)({},$Kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}JKp.isMDXComponent=!0;const ZKp={toc:[]},eJp="wrapper";function nJp(e){let{components:n,...t}=e;return(0,s.yg)(eJp,(0,p.A)({},ZKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}nJp.isMDXComponent=!0;const tJp={toc:[]},oJp="wrapper";function pJp(e){let{components:n,...t}=e;return(0,s.yg)(oJp,(0,p.A)({},tJp,t,{components:n,mdxType:"MDXLayout"}))}pJp.isMDXComponent=!0;const rJp={toc:[]},sJp="wrapper";function cJp(e){let{components:n,...t}=e;return(0,s.yg)(sJp,(0,p.A)({},rJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}cJp.isMDXComponent=!0;const aJp={toc:[]},iJp="wrapper";function lJp(e){let{components:n,...t}=e;return(0,s.yg)(iJp,(0,p.A)({},aJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}lJp.isMDXComponent=!0;const uJp={toc:[]},mJp="wrapper";function yJp(e){let{components:n,...t}=e;return(0,s.yg)(mJp,(0,p.A)({},uJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}yJp.isMDXComponent=!0;const dJp={toc:[]},hJp="wrapper";function gJp(e){let{components:n,...t}=e;return(0,s.yg)(hJp,(0,p.A)({},dJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gJp.isMDXComponent=!0;const fJp={toc:[]},DJp="wrapper";function MJp(e){let{components:n,...t}=e;return(0,s.yg)(DJp,(0,p.A)({},fJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}MJp.isMDXComponent=!0;const XJp={toc:[]},_Jp="wrapper";function wJp(e){let{components:n,...t}=e;return(0,s.yg)(_Jp,(0,p.A)({},XJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wJp.isMDXComponent=!0;const TJp={toc:[]},CJp="wrapper";function xJp(e){let{components:n,...t}=e;return(0,s.yg)(CJp,(0,p.A)({},TJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}xJp.isMDXComponent=!0;const AJp={toc:[]},vJp="wrapper";function LJp(e){let{components:n,...t}=e;return(0,s.yg)(vJp,(0,p.A)({},AJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LJp.isMDXComponent=!0;const bJp={toc:[]},NJp="wrapper";function kJp(e){let{components:n,...t}=e;return(0,s.yg)(NJp,(0,p.A)({},bJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}kJp.isMDXComponent=!0;const zJp={toc:[]},PJp="wrapper";function IJp(e){let{components:n,...t}=e;return(0,s.yg)(PJp,(0,p.A)({},zJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}IJp.isMDXComponent=!0;const RJp={toc:[]},WJp="wrapper";function SJp(e){let{components:n,...t}=e;return(0,s.yg)(WJp,(0,p.A)({},RJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}SJp.isMDXComponent=!0;const BJp={toc:[]},GJp="wrapper";function EJp(e){let{components:n,...t}=e;return(0,s.yg)(GJp,(0,p.A)({},BJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EJp.isMDXComponent=!0;const OJp={toc:[]},UJp="wrapper";function FJp(e){let{components:n,...t}=e;return(0,s.yg)(UJp,(0,p.A)({},OJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}FJp.isMDXComponent=!0;const VJp={toc:[]},qJp="wrapper";function jJp(e){let{components:n,...t}=e;return(0,s.yg)(qJp,(0,p.A)({},VJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jJp.isMDXComponent=!0;const HJp={toc:[]},YJp="wrapper";function QJp(e){let{components:n,...t}=e;return(0,s.yg)(YJp,(0,p.A)({},HJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}QJp.isMDXComponent=!0;const $Jp={toc:[]},KJp="wrapper";function JJp(e){let{components:n,...t}=e;return(0,s.yg)(KJp,(0,p.A)({},$Jp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JJp.isMDXComponent=!0;const ZJp={toc:[]},eZp="wrapper";function nZp(e){let{components:n,...t}=e;return(0,s.yg)(eZp,(0,p.A)({},ZJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}nZp.isMDXComponent=!0;const tZp={toc:[]},oZp="wrapper";function pZp(e){let{components:n,...t}=e;return(0,s.yg)(oZp,(0,p.A)({},tZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pZp.isMDXComponent=!0;const rZp={toc:[]},sZp="wrapper";function cZp(e){let{components:n,...t}=e;return(0,s.yg)(sZp,(0,p.A)({},rZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}cZp.isMDXComponent=!0;const aZp={toc:[]},iZp="wrapper";function lZp(e){let{components:n,...t}=e;return(0,s.yg)(iZp,(0,p.A)({},aZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lZp.isMDXComponent=!0;const uZp={toc:[]},mZp="wrapper";function yZp(e){let{components:n,...t}=e;return(0,s.yg)(mZp,(0,p.A)({},uZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yZp.isMDXComponent=!0;const dZp={toc:[]},hZp="wrapper";function gZp(e){let{components:n,...t}=e;return(0,s.yg)(hZp,(0,p.A)({},dZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gZp.isMDXComponent=!0;const fZp={toc:[]},DZp="wrapper";function MZp(e){let{components:n,...t}=e;return(0,s.yg)(DZp,(0,p.A)({},fZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}MZp.isMDXComponent=!0;const XZp={toc:[]},_Zp="wrapper";function wZp(e){let{components:n,...t}=e;return(0,s.yg)(_Zp,(0,p.A)({},XZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wZp.isMDXComponent=!0;const TZp={toc:[]},CZp="wrapper";function xZp(e){let{components:n,...t}=e;return(0,s.yg)(CZp,(0,p.A)({},TZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xZp.isMDXComponent=!0;const AZp={toc:[]},vZp="wrapper";function LZp(e){let{components:n,...t}=e;return(0,s.yg)(vZp,(0,p.A)({},AZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}LZp.isMDXComponent=!0;const bZp={toc:[]},NZp="wrapper";function kZp(e){let{components:n,...t}=e;return(0,s.yg)(NZp,(0,p.A)({},bZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kZp.isMDXComponent=!0;const zZp={toc:[]},PZp="wrapper";function IZp(e){let{components:n,...t}=e;return(0,s.yg)(PZp,(0,p.A)({},zZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}IZp.isMDXComponent=!0;const RZp={toc:[]},WZp="wrapper";function SZp(e){let{components:n,...t}=e;return(0,s.yg)(WZp,(0,p.A)({},RZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SZp.isMDXComponent=!0;const BZp={toc:[]},GZp="wrapper";function EZp(e){let{components:n,...t}=e;return(0,s.yg)(GZp,(0,p.A)({},BZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EZp.isMDXComponent=!0;const OZp={toc:[]},UZp="wrapper";function FZp(e){let{components:n,...t}=e;return(0,s.yg)(UZp,(0,p.A)({},OZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}FZp.isMDXComponent=!0;const VZp={toc:[]},qZp="wrapper";function jZp(e){let{components:n,...t}=e;return(0,s.yg)(qZp,(0,p.A)({},VZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}jZp.isMDXComponent=!0;const HZp={toc:[]},YZp="wrapper";function QZp(e){let{components:n,...t}=e;return(0,s.yg)(YZp,(0,p.A)({},HZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}QZp.isMDXComponent=!0;const $Zp={toc:[]},KZp="wrapper";function JZp(e){let{components:n,...t}=e;return(0,s.yg)(KZp,(0,p.A)({},$Zp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JZp.isMDXComponent=!0;const ZZp={toc:[]},e0p="wrapper";function n0p(e){let{components:n,...t}=e;return(0,s.yg)(e0p,(0,p.A)({},ZZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}n0p.isMDXComponent=!0;const t0p={toc:[]},o0p="wrapper";function p0p(e){let{components:n,...t}=e;return(0,s.yg)(o0p,(0,p.A)({},t0p,t,{components:n,mdxType:"MDXLayout"}))}p0p.isMDXComponent=!0;const r0p={toc:[]},s0p="wrapper";function c0p(e){let{components:n,...t}=e;return(0,s.yg)(s0p,(0,p.A)({},r0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}c0p.isMDXComponent=!0;const a0p={toc:[]},i0p="wrapper";function l0p(e){let{components:n,...t}=e;return(0,s.yg)(i0p,(0,p.A)({},a0p,t,{components:n,mdxType:"MDXLayout"}))}l0p.isMDXComponent=!0;const u0p={toc:[]},m0p="wrapper";function y0p(e){let{components:n,...t}=e;return(0,s.yg)(m0p,(0,p.A)({},u0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}y0p.isMDXComponent=!0;const d0p={toc:[]},h0p="wrapper";function g0p(e){let{components:n,...t}=e;return(0,s.yg)(h0p,(0,p.A)({},d0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}g0p.isMDXComponent=!0;const f0p={toc:[]},D0p="wrapper";function M0p(e){let{components:n,...t}=e;return(0,s.yg)(D0p,(0,p.A)({},f0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}M0p.isMDXComponent=!0;const X0p={toc:[]},_0p="wrapper";function w0p(e){let{components:n,...t}=e;return(0,s.yg)(_0p,(0,p.A)({},X0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}w0p.isMDXComponent=!0;const T0p={toc:[]},C0p="wrapper";function x0p(e){let{components:n,...t}=e;return(0,s.yg)(C0p,(0,p.A)({},T0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}x0p.isMDXComponent=!0;const A0p={toc:[]},v0p="wrapper";function L0p(e){let{components:n,...t}=e;return(0,s.yg)(v0p,(0,p.A)({},A0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}L0p.isMDXComponent=!0;const b0p={toc:[]},N0p="wrapper";function k0p(e){let{components:n,...t}=e;return(0,s.yg)(N0p,(0,p.A)({},b0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}k0p.isMDXComponent=!0;const z0p={toc:[]},P0p="wrapper";function I0p(e){let{components:n,...t}=e;return(0,s.yg)(P0p,(0,p.A)({},z0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}I0p.isMDXComponent=!0;const R0p={toc:[]},W0p="wrapper";function S0p(e){let{components:n,...t}=e;return(0,s.yg)(W0p,(0,p.A)({},R0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}S0p.isMDXComponent=!0;const B0p={toc:[]},G0p="wrapper";function E0p(e){let{components:n,...t}=e;return(0,s.yg)(G0p,(0,p.A)({},B0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}E0p.isMDXComponent=!0;const O0p={toc:[]},U0p="wrapper";function F0p(e){let{components:n,...t}=e;return(0,s.yg)(U0p,(0,p.A)({},O0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}F0p.isMDXComponent=!0;const V0p={toc:[]},q0p="wrapper";function j0p(e){let{components:n,...t}=e;return(0,s.yg)(q0p,(0,p.A)({},V0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}j0p.isMDXComponent=!0;const H0p={toc:[]},Y0p="wrapper";function Q0p(e){let{components:n,...t}=e;return(0,s.yg)(Y0p,(0,p.A)({},H0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Q0p.isMDXComponent=!0;const $0p={toc:[]},K0p="wrapper";function J0p(e){let{components:n,...t}=e;return(0,s.yg)(K0p,(0,p.A)({},$0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}J0p.isMDXComponent=!0;const Z0p={toc:[]},e3p="wrapper";function n3p(e){let{components:n,...t}=e;return(0,s.yg)(e3p,(0,p.A)({},Z0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}n3p.isMDXComponent=!0;const t3p={toc:[]},o3p="wrapper";function p3p(e){let{components:n,...t}=e;return(0,s.yg)(o3p,(0,p.A)({},t3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}p3p.isMDXComponent=!0;const r3p={toc:[]},s3p="wrapper";function c3p(e){let{components:n,...t}=e;return(0,s.yg)(s3p,(0,p.A)({},r3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}c3p.isMDXComponent=!0;const a3p={toc:[]},i3p="wrapper";function l3p(e){let{components:n,...t}=e;return(0,s.yg)(i3p,(0,p.A)({},a3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}l3p.isMDXComponent=!0;const u3p={toc:[]},m3p="wrapper";function y3p(e){let{components:n,...t}=e;return(0,s.yg)(m3p,(0,p.A)({},u3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}y3p.isMDXComponent=!0;const d3p={toc:[]},h3p="wrapper";function g3p(e){let{components:n,...t}=e;return(0,s.yg)(h3p,(0,p.A)({},d3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}g3p.isMDXComponent=!0;const f3p={toc:[]},D3p="wrapper";function M3p(e){let{components:n,...t}=e;return(0,s.yg)(D3p,(0,p.A)({},f3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}M3p.isMDXComponent=!0;const X3p={toc:[]},_3p="wrapper";function w3p(e){let{components:n,...t}=e;return(0,s.yg)(_3p,(0,p.A)({},X3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}w3p.isMDXComponent=!0;const T3p={toc:[]},C3p="wrapper";function x3p(e){let{components:n,...t}=e;return(0,s.yg)(C3p,(0,p.A)({},T3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}x3p.isMDXComponent=!0;const A3p={toc:[]},v3p="wrapper";function L3p(e){let{components:n,...t}=e;return(0,s.yg)(v3p,(0,p.A)({},A3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}L3p.isMDXComponent=!0;const b3p={toc:[]},N3p="wrapper";function k3p(e){let{components:n,...t}=e;return(0,s.yg)(N3p,(0,p.A)({},b3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}k3p.isMDXComponent=!0;const z3p={toc:[]},P3p="wrapper";function I3p(e){let{components:n,...t}=e;return(0,s.yg)(P3p,(0,p.A)({},z3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}I3p.isMDXComponent=!0;const R3p={toc:[]},W3p="wrapper";function S3p(e){let{components:n,...t}=e;return(0,s.yg)(W3p,(0,p.A)({},R3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}S3p.isMDXComponent=!0;const B3p={toc:[]},G3p="wrapper";function E3p(e){let{components:n,...t}=e;return(0,s.yg)(G3p,(0,p.A)({},B3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}E3p.isMDXComponent=!0;const O3p={toc:[]},U3p="wrapper";function F3p(e){let{components:n,...t}=e;return(0,s.yg)(U3p,(0,p.A)({},O3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}F3p.isMDXComponent=!0;const V3p={toc:[]},q3p="wrapper";function j3p(e){let{components:n,...t}=e;return(0,s.yg)(q3p,(0,p.A)({},V3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}j3p.isMDXComponent=!0;const H3p={toc:[]},Y3p="wrapper";function Q3p(e){let{components:n,...t}=e;return(0,s.yg)(Y3p,(0,p.A)({},H3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Q3p.isMDXComponent=!0;const $3p={toc:[]},K3p="wrapper";function J3p(e){let{components:n,...t}=e;return(0,s.yg)(K3p,(0,p.A)({},$3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}J3p.isMDXComponent=!0;const Z3p={toc:[]},e8p="wrapper";function n8p(e){let{components:n,...t}=e;return(0,s.yg)(e8p,(0,p.A)({},Z3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}n8p.isMDXComponent=!0;const t8p={toc:[]},o8p="wrapper";function p8p(e){let{components:n,...t}=e;return(0,s.yg)(o8p,(0,p.A)({},t8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}p8p.isMDXComponent=!0;const r8p={toc:[]},s8p="wrapper";function c8p(e){let{components:n,...t}=e;return(0,s.yg)(s8p,(0,p.A)({},r8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}c8p.isMDXComponent=!0;const a8p={toc:[]},i8p="wrapper";function l8p(e){let{components:n,...t}=e;return(0,s.yg)(i8p,(0,p.A)({},a8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}l8p.isMDXComponent=!0;const u8p={toc:[]},m8p="wrapper";function y8p(e){let{components:n,...t}=e;return(0,s.yg)(m8p,(0,p.A)({},u8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}y8p.isMDXComponent=!0;const d8p={toc:[]},h8p="wrapper";function g8p(e){let{components:n,...t}=e;return(0,s.yg)(h8p,(0,p.A)({},d8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The points of the line."))}g8p.isMDXComponent=!0;const f8p={toc:[]},D8p="wrapper";function M8p(e){let{components:n,...t}=e;return(0,s.yg)(D8p,(0,p.A)({},f8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the line's corners."))}M8p.isMDXComponent=!0;const X8p={toc:[]},_8p="wrapper";function w8p(e){let{components:n,...t}=e;return(0,s.yg)(_8p,(0,p.A)({},X8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w8p.isMDXComponent=!0;const T8p={toc:[]},C8p="wrapper";function x8p(e){let{components:n,...t}=e;return(0,s.yg)(C8p,(0,p.A)({},T8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}x8p.isMDXComponent=!0;const A8p={toc:[]},v8p="wrapper";function L8p(e){let{components:n,...t}=e;return(0,s.yg)(v8p,(0,p.A)({},A8p,t,{components:n,mdxType:"MDXLayout"}))}L8p.isMDXComponent=!0;const b8p={toc:[]},N8p="wrapper";function k8p(e){let{components:n,...t}=e;return(0,s.yg)(N8p,(0,p.A)({},b8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}k8p.isMDXComponent=!0;const z8p={toc:[]},P8p="wrapper";function I8p(e){let{components:n,...t}=e;return(0,s.yg)(P8p,(0,p.A)({},z8p,t,{components:n,mdxType:"MDXLayout"}))}I8p.isMDXComponent=!0;const R8p={toc:[]},W8p="wrapper";function S8p(e){let{components:n,...t}=e;return(0,s.yg)(W8p,(0,p.A)({},R8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}S8p.isMDXComponent=!0;const B8p={toc:[]},G8p="wrapper";function E8p(e){let{components:n,...t}=e;return(0,s.yg)(G8p,(0,p.A)({},B8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}E8p.isMDXComponent=!0;const O8p={toc:[]},U8p="wrapper";function F8p(e){let{components:n,...t}=e;return(0,s.yg)(U8p,(0,p.A)({},O8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}F8p.isMDXComponent=!0;const V8p={toc:[]},q8p="wrapper";function j8p(e){let{components:n,...t}=e;return(0,s.yg)(q8p,(0,p.A)({},V8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}j8p.isMDXComponent=!0;const H8p={toc:[]},Y8p="wrapper";function Q8p(e){let{components:n,...t}=e;return(0,s.yg)(Y8p,(0,p.A)({},H8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Q8p.isMDXComponent=!0;const $8p={toc:[]},K8p="wrapper";function J8p(e){let{components:n,...t}=e;return(0,s.yg)(K8p,(0,p.A)({},$8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}J8p.isMDXComponent=!0;const Z8p={toc:[]},e2p="wrapper";function n2p(e){let{components:n,...t}=e;return(0,s.yg)(e2p,(0,p.A)({},Z8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}n2p.isMDXComponent=!0;const t2p={toc:[]},o2p="wrapper";function p2p(e){let{components:n,...t}=e;return(0,s.yg)(o2p,(0,p.A)({},t2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}p2p.isMDXComponent=!0;const r2p={toc:[]},s2p="wrapper";function c2p(e){let{components:n,...t}=e;return(0,s.yg)(s2p,(0,p.A)({},r2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}c2p.isMDXComponent=!0;const a2p={toc:[]},i2p="wrapper";function l2p(e){let{components:n,...t}=e;return(0,s.yg)(i2p,(0,p.A)({},a2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}l2p.isMDXComponent=!0;const u2p={toc:[]},m2p="wrapper";function y2p(e){let{components:n,...t}=e;return(0,s.yg)(m2p,(0,p.A)({},u2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}y2p.isMDXComponent=!0;const d2p={toc:[]},h2p="wrapper";function g2p(e){let{components:n,...t}=e;return(0,s.yg)(h2p,(0,p.A)({},d2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}g2p.isMDXComponent=!0;const f2p={toc:[]},D2p="wrapper";function M2p(e){let{components:n,...t}=e;return(0,s.yg)(D2p,(0,p.A)({},f2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}M2p.isMDXComponent=!0;const X2p={toc:[]},_2p="wrapper";function w2p(e){let{components:n,...t}=e;return(0,s.yg)(_2p,(0,p.A)({},X2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}w2p.isMDXComponent=!0;const T2p={toc:[]},C2p="wrapper";function x2p(e){let{components:n,...t}=e;return(0,s.yg)(C2p,(0,p.A)({},T2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}x2p.isMDXComponent=!0;const A2p={toc:[]},v2p="wrapper";function L2p(e){let{components:n,...t}=e;return(0,s.yg)(v2p,(0,p.A)({},A2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}L2p.isMDXComponent=!0;const b2p={toc:[]},N2p="wrapper";function k2p(e){let{components:n,...t}=e;return(0,s.yg)(N2p,(0,p.A)({},b2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}k2p.isMDXComponent=!0;const z2p={toc:[]},P2p="wrapper";function I2p(e){let{components:n,...t}=e;return(0,s.yg)(P2p,(0,p.A)({},z2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}I2p.isMDXComponent=!0;const R2p={toc:[]},W2p="wrapper";function S2p(e){let{components:n,...t}=e;return(0,s.yg)(W2p,(0,p.A)({},R2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}S2p.isMDXComponent=!0;const B2p={toc:[]},G2p="wrapper";function E2p(e){let{components:n,...t}=e;return(0,s.yg)(G2p,(0,p.A)({},B2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}E2p.isMDXComponent=!0;const O2p={toc:[]},U2p="wrapper";function F2p(e){let{components:n,...t}=e;return(0,s.yg)(U2p,(0,p.A)({},O2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}F2p.isMDXComponent=!0;const V2p={toc:[]},q2p="wrapper";function j2p(e){let{components:n,...t}=e;return(0,s.yg)(q2p,(0,p.A)({},V2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}j2p.isMDXComponent=!0;const H2p={toc:[]},Y2p="wrapper";function Q2p(e){let{components:n,...t}=e;return(0,s.yg)(Y2p,(0,p.A)({},H2p,t,{components:n,mdxType:"MDXLayout"}))}Q2p.isMDXComponent=!0;const $2p={toc:[]},K2p="wrapper";function J2p(e){let{components:n,...t}=e;return(0,s.yg)(K2p,(0,p.A)({},$2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}J2p.isMDXComponent=!0;const Z2p={toc:[]},e1p="wrapper";function n1p(e){let{components:n,...t}=e;return(0,s.yg)(e1p,(0,p.A)({},Z2p,t,{components:n,mdxType:"MDXLayout"}))}n1p.isMDXComponent=!0;const t1p={toc:[]},o1p="wrapper";function p1p(e){let{components:n,...t}=e;return(0,s.yg)(o1p,(0,p.A)({},t1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}p1p.isMDXComponent=!0;const r1p={toc:[]},s1p="wrapper";function c1p(e){let{components:n,...t}=e;return(0,s.yg)(s1p,(0,p.A)({},r1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}c1p.isMDXComponent=!0;const a1p={toc:[]},i1p="wrapper";function l1p(e){let{components:n,...t}=e;return(0,s.yg)(i1p,(0,p.A)({},a1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}l1p.isMDXComponent=!0;const u1p={toc:[]},m1p="wrapper";function y1p(e){let{components:n,...t}=e;return(0,s.yg)(m1p,(0,p.A)({},u1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}y1p.isMDXComponent=!0;const d1p={toc:[]},h1p="wrapper";function g1p(e){let{components:n,...t}=e;return(0,s.yg)(h1p,(0,p.A)({},d1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}g1p.isMDXComponent=!0;const f1p={toc:[]},D1p="wrapper";function M1p(e){let{components:n,...t}=e;return(0,s.yg)(D1p,(0,p.A)({},f1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}M1p.isMDXComponent=!0;const X1p={toc:[]},_1p="wrapper";function w1p(e){let{components:n,...t}=e;return(0,s.yg)(_1p,(0,p.A)({},X1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w1p.isMDXComponent=!0;const T1p={toc:[]},C1p="wrapper";function x1p(e){let{components:n,...t}=e;return(0,s.yg)(C1p,(0,p.A)({},T1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}x1p.isMDXComponent=!0;const A1p={toc:[]},v1p="wrapper";function L1p(e){let{components:n,...t}=e;return(0,s.yg)(v1p,(0,p.A)({},A1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}L1p.isMDXComponent=!0;const b1p={toc:[]},N1p="wrapper";function k1p(e){let{components:n,...t}=e;return(0,s.yg)(N1p,(0,p.A)({},b1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}k1p.isMDXComponent=!0;const z1p={toc:[]},P1p="wrapper";function I1p(e){let{components:n,...t}=e;return(0,s.yg)(P1p,(0,p.A)({},z1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}I1p.isMDXComponent=!0;const R1p={toc:[]},W1p="wrapper";function S1p(e){let{components:n,...t}=e;return(0,s.yg)(W1p,(0,p.A)({},R1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}S1p.isMDXComponent=!0;const B1p={toc:[]},G1p="wrapper";function E1p(e){let{components:n,...t}=e;return(0,s.yg)(G1p,(0,p.A)({},B1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}E1p.isMDXComponent=!0;const O1p={toc:[]},U1p="wrapper";function F1p(e){let{components:n,...t}=e;return(0,s.yg)(U1p,(0,p.A)({},O1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}F1p.isMDXComponent=!0;const V1p={toc:[]},q1p="wrapper";function j1p(e){let{components:n,...t}=e;return(0,s.yg)(q1p,(0,p.A)({},V1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}j1p.isMDXComponent=!0;const H1p={toc:[]},Y1p="wrapper";function Q1p(e){let{components:n,...t}=e;return(0,s.yg)(Y1p,(0,p.A)({},H1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Q1p.isMDXComponent=!0;const $1p={toc:[]},K1p="wrapper";function J1p(e){let{components:n,...t}=e;return(0,s.yg)(K1p,(0,p.A)({},$1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}J1p.isMDXComponent=!0;const Z1p={toc:[]},e4p="wrapper";function n4p(e){let{components:n,...t}=e;return(0,s.yg)(e4p,(0,p.A)({},Z1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}n4p.isMDXComponent=!0;const t4p={toc:[]},o4p="wrapper";function p4p(e){let{components:n,...t}=e;return(0,s.yg)(o4p,(0,p.A)({},t4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}p4p.isMDXComponent=!0;const r4p={toc:[]},s4p="wrapper";function c4p(e){let{components:n,...t}=e;return(0,s.yg)(s4p,(0,p.A)({},r4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}c4p.isMDXComponent=!0;const a4p={toc:[]},i4p="wrapper";function l4p(e){let{components:n,...t}=e;return(0,s.yg)(i4p,(0,p.A)({},a4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}l4p.isMDXComponent=!0;const u4p={toc:[]},m4p="wrapper";function y4p(e){let{components:n,...t}=e;return(0,s.yg)(m4p,(0,p.A)({},u4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}y4p.isMDXComponent=!0;const d4p={toc:[]},h4p="wrapper";function g4p(e){let{components:n,...t}=e;return(0,s.yg)(h4p,(0,p.A)({},d4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}g4p.isMDXComponent=!0;const f4p={toc:[]},D4p="wrapper";function M4p(e){let{components:n,...t}=e;return(0,s.yg)(D4p,(0,p.A)({},f4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}M4p.isMDXComponent=!0;const X4p={toc:[]},_4p="wrapper";function w4p(e){let{components:n,...t}=e;return(0,s.yg)(_4p,(0,p.A)({},X4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}w4p.isMDXComponent=!0;const T4p={toc:[]},C4p="wrapper";function x4p(e){let{components:n,...t}=e;return(0,s.yg)(C4p,(0,p.A)({},T4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}x4p.isMDXComponent=!0;const A4p={toc:[]},v4p="wrapper";function L4p(e){let{components:n,...t}=e;return(0,s.yg)(v4p,(0,p.A)({},A4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}L4p.isMDXComponent=!0;const b4p={toc:[]},N4p="wrapper";function k4p(e){let{components:n,...t}=e;return(0,s.yg)(N4p,(0,p.A)({},b4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}k4p.isMDXComponent=!0;const z4p={toc:[]},P4p="wrapper";function I4p(e){let{components:n,...t}=e;return(0,s.yg)(P4p,(0,p.A)({},z4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}I4p.isMDXComponent=!0;const R4p={toc:[]},W4p="wrapper";function S4p(e){let{components:n,...t}=e;return(0,s.yg)(W4p,(0,p.A)({},R4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}S4p.isMDXComponent=!0;const B4p={toc:[]},G4p="wrapper";function E4p(e){let{components:n,...t}=e;return(0,s.yg)(G4p,(0,p.A)({},B4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}E4p.isMDXComponent=!0;const O4p={toc:[]},U4p="wrapper";function F4p(e){let{components:n,...t}=e;return(0,s.yg)(U4p,(0,p.A)({},O4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}F4p.isMDXComponent=!0;const V4p={toc:[]},q4p="wrapper";function j4p(e){let{components:n,...t}=e;return(0,s.yg)(q4p,(0,p.A)({},V4p,t,{components:n,mdxType:"MDXLayout"}))}j4p.isMDXComponent=!0;const H4p={toc:[]},Y4p="wrapper";function Q4p(e){let{components:n,...t}=e;return(0,s.yg)(Y4p,(0,p.A)({},H4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Q4p.isMDXComponent=!0;const $4p={toc:[]},K4p="wrapper";function J4p(e){let{components:n,...t}=e;return(0,s.yg)(K4p,(0,p.A)({},$4p,t,{components:n,mdxType:"MDXLayout"}))}J4p.isMDXComponent=!0;const Z4p={toc:[]},e6p="wrapper";function n6p(e){let{components:n,...t}=e;return(0,s.yg)(e6p,(0,p.A)({},Z4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}n6p.isMDXComponent=!0;const t6p={toc:[]},o6p="wrapper";function p6p(e){let{components:n,...t}=e;return(0,s.yg)(o6p,(0,p.A)({},t6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}p6p.isMDXComponent=!0;const r6p={toc:[]},s6p="wrapper";function c6p(e){let{components:n,...t}=e;return(0,s.yg)(s6p,(0,p.A)({},r6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}c6p.isMDXComponent=!0;const a6p={toc:[]},i6p="wrapper";function l6p(e){let{components:n,...t}=e;return(0,s.yg)(i6p,(0,p.A)({},a6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}l6p.isMDXComponent=!0;const u6p={toc:[]},m6p="wrapper";function y6p(e){let{components:n,...t}=e;return(0,s.yg)(m6p,(0,p.A)({},u6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}y6p.isMDXComponent=!0;const d6p={toc:[]},h6p="wrapper";function g6p(e){let{components:n,...t}=e;return(0,s.yg)(h6p,(0,p.A)({},d6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}g6p.isMDXComponent=!0;const f6p={toc:[]},D6p="wrapper";function M6p(e){let{components:n,...t}=e;return(0,s.yg)(D6p,(0,p.A)({},f6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}M6p.isMDXComponent=!0;const X6p={toc:[]},_6p="wrapper";function w6p(e){let{components:n,...t}=e;return(0,s.yg)(_6p,(0,p.A)({},X6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}w6p.isMDXComponent=!0;const T6p={toc:[]},C6p="wrapper";function x6p(e){let{components:n,...t}=e;return(0,s.yg)(C6p,(0,p.A)({},T6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}x6p.isMDXComponent=!0;const A6p={toc:[]},v6p="wrapper";function L6p(e){let{components:n,...t}=e;return(0,s.yg)(v6p,(0,p.A)({},A6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}L6p.isMDXComponent=!0;const b6p={toc:[]},N6p="wrapper";function k6p(e){let{components:n,...t}=e;return(0,s.yg)(N6p,(0,p.A)({},b6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}k6p.isMDXComponent=!0;const z6p={toc:[]},P6p="wrapper";function I6p(e){let{components:n,...t}=e;return(0,s.yg)(P6p,(0,p.A)({},z6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}I6p.isMDXComponent=!0;const R6p={toc:[]},W6p="wrapper";function S6p(e){let{components:n,...t}=e;return(0,s.yg)(W6p,(0,p.A)({},R6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}S6p.isMDXComponent=!0;const B6p={toc:[]},G6p="wrapper";function E6p(e){let{components:n,...t}=e;return(0,s.yg)(G6p,(0,p.A)({},B6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}E6p.isMDXComponent=!0;const O6p={toc:[]},U6p="wrapper";function F6p(e){let{components:n,...t}=e;return(0,s.yg)(U6p,(0,p.A)({},O6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}F6p.isMDXComponent=!0;const V6p={toc:[]},q6p="wrapper";function j6p(e){let{components:n,...t}=e;return(0,s.yg)(q6p,(0,p.A)({},V6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}j6p.isMDXComponent=!0;const H6p={toc:[]},Y6p="wrapper";function Q6p(e){let{components:n,...t}=e;return(0,s.yg)(Y6p,(0,p.A)({},H6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Q6p.isMDXComponent=!0;const $6p={toc:[]},K6p="wrapper";function J6p(e){let{components:n,...t}=e;return(0,s.yg)(K6p,(0,p.A)({},$6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}J6p.isMDXComponent=!0;const Z6p={toc:[]},e5p="wrapper";function n5p(e){let{components:n,...t}=e;return(0,s.yg)(e5p,(0,p.A)({},Z6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}n5p.isMDXComponent=!0;const t5p={toc:[]},o5p="wrapper";function p5p(e){let{components:n,...t}=e;return(0,s.yg)(o5p,(0,p.A)({},t5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}p5p.isMDXComponent=!0;const r5p={toc:[]},s5p="wrapper";function c5p(e){let{components:n,...t}=e;return(0,s.yg)(s5p,(0,p.A)({},r5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}c5p.isMDXComponent=!0;const a5p={toc:[]},i5p="wrapper";function l5p(e){let{components:n,...t}=e;return(0,s.yg)(i5p,(0,p.A)({},a5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}l5p.isMDXComponent=!0;const u5p={toc:[]},m5p="wrapper";function y5p(e){let{components:n,...t}=e;return(0,s.yg)(m5p,(0,p.A)({},u5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}y5p.isMDXComponent=!0;const d5p={toc:[]},h5p="wrapper";function g5p(e){let{components:n,...t}=e;return(0,s.yg)(h5p,(0,p.A)({},d5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}g5p.isMDXComponent=!0;const f5p={toc:[]},D5p="wrapper";function M5p(e){let{components:n,...t}=e;return(0,s.yg)(D5p,(0,p.A)({},f5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}M5p.isMDXComponent=!0;const X5p={toc:[]},_5p="wrapper";function w5p(e){let{components:n,...t}=e;return(0,s.yg)(_5p,(0,p.A)({},X5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}w5p.isMDXComponent=!0;const T5p={toc:[]},C5p="wrapper";function x5p(e){let{components:n,...t}=e;return(0,s.yg)(C5p,(0,p.A)({},T5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}x5p.isMDXComponent=!0;const A5p={toc:[]},v5p="wrapper";function L5p(e){let{components:n,...t}=e;return(0,s.yg)(v5p,(0,p.A)({},A5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}L5p.isMDXComponent=!0;const b5p={toc:[]},N5p="wrapper";function k5p(e){let{components:n,...t}=e;return(0,s.yg)(N5p,(0,p.A)({},b5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}k5p.isMDXComponent=!0;const z5p={toc:[]},P5p="wrapper";function I5p(e){let{components:n,...t}=e;return(0,s.yg)(P5p,(0,p.A)({},z5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}I5p.isMDXComponent=!0;const R5p={toc:[]},W5p="wrapper";function S5p(e){let{components:n,...t}=e;return(0,s.yg)(W5p,(0,p.A)({},R5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}S5p.isMDXComponent=!0;const B5p={toc:[]},G5p="wrapper";function E5p(e){let{components:n,...t}=e;return(0,s.yg)(G5p,(0,p.A)({},B5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}E5p.isMDXComponent=!0;const O5p={toc:[]},U5p="wrapper";function F5p(e){let{components:n,...t}=e;return(0,s.yg)(U5p,(0,p.A)({},O5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}F5p.isMDXComponent=!0;const V5p={toc:[]},q5p="wrapper";function j5p(e){let{components:n,...t}=e;return(0,s.yg)(q5p,(0,p.A)({},V5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}j5p.isMDXComponent=!0;const H5p={toc:[]},Y5p="wrapper";function Q5p(e){let{components:n,...t}=e;return(0,s.yg)(Y5p,(0,p.A)({},H5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Q5p.isMDXComponent=!0;const $5p={toc:[]},K5p="wrapper";function J5p(e){let{components:n,...t}=e;return(0,s.yg)(K5p,(0,p.A)({},$5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}J5p.isMDXComponent=!0;const Z5p={toc:[]},e7p="wrapper";function n7p(e){let{components:n,...t}=e;return(0,s.yg)(e7p,(0,p.A)({},Z5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}n7p.isMDXComponent=!0;const t7p={toc:[]},o7p="wrapper";function p7p(e){let{components:n,...t}=e;return(0,s.yg)(o7p,(0,p.A)({},t7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}p7p.isMDXComponent=!0;const r7p={toc:[]},s7p="wrapper";function c7p(e){let{components:n,...t}=e;return(0,s.yg)(s7p,(0,p.A)({},r7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}c7p.isMDXComponent=!0;const a7p={toc:[]},i7p="wrapper";function l7p(e){let{components:n,...t}=e;return(0,s.yg)(i7p,(0,p.A)({},a7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}l7p.isMDXComponent=!0;const u7p={toc:[]},m7p="wrapper";function y7p(e){let{components:n,...t}=e;return(0,s.yg)(m7p,(0,p.A)({},u7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}y7p.isMDXComponent=!0;const d7p={toc:[]},h7p="wrapper";function g7p(e){let{components:n,...t}=e;return(0,s.yg)(h7p,(0,p.A)({},d7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}g7p.isMDXComponent=!0;const f7p={toc:[]},D7p="wrapper";function M7p(e){let{components:n,...t}=e;return(0,s.yg)(D7p,(0,p.A)({},f7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the polygon's corners."))}M7p.isMDXComponent=!0;const X7p={toc:[]},_7p="wrapper";function w7p(e){let{components:n,...t}=e;return(0,s.yg)(_7p,(0,p.A)({},X7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w7p.isMDXComponent=!0;const T7p={toc:[]},C7p="wrapper";function x7p(e){let{components:n,...t}=e;return(0,s.yg)(C7p,(0,p.A)({},T7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}x7p.isMDXComponent=!0;const A7p={toc:[]},v7p="wrapper";function L7p(e){let{components:n,...t}=e;return(0,s.yg)(v7p,(0,p.A)({},A7p,t,{components:n,mdxType:"MDXLayout"}))}L7p.isMDXComponent=!0;const b7p={toc:[]},N7p="wrapper";function k7p(e){let{components:n,...t}=e;return(0,s.yg)(N7p,(0,p.A)({},b7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"For example, a value of 6 creates a hexagon."))}k7p.isMDXComponent=!0;const z7p={toc:[]},P7p="wrapper";function I7p(e){let{components:n,...t}=e;return(0,s.yg)(P7p,(0,p.A)({},z7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of sides of the polygon."))}I7p.isMDXComponent=!0;const R7p={toc:[]},W7p="wrapper";function S7p(e){let{components:n,...t}=e;return(0,s.yg)(W7p,(0,p.A)({},R7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}S7p.isMDXComponent=!0;const B7p={toc:[]},G7p="wrapper";function E7p(e){let{components:n,...t}=e;return(0,s.yg)(G7p,(0,p.A)({},B7p,t,{components:n,mdxType:"MDXLayout"}))}E7p.isMDXComponent=!0;const O7p={toc:[]},U7p="wrapper";function F7p(e){let{components:n,...t}=e;return(0,s.yg)(U7p,(0,p.A)({},O7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}F7p.isMDXComponent=!0;const V7p={toc:[]},q7p="wrapper";function j7p(e){let{components:n,...t}=e;return(0,s.yg)(q7p,(0,p.A)({},V7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}j7p.isMDXComponent=!0;const H7p={toc:[]},Y7p="wrapper";function Q7p(e){let{components:n,...t}=e;return(0,s.yg)(Y7p,(0,p.A)({},H7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Q7p.isMDXComponent=!0;const $7p={toc:[]},K7p="wrapper";function J7p(e){let{components:n,...t}=e;return(0,s.yg)(K7p,(0,p.A)({},$7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}J7p.isMDXComponent=!0;const Z7p={toc:[]},e9p="wrapper";function n9p(e){let{components:n,...t}=e;return(0,s.yg)(e9p,(0,p.A)({},Z7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}n9p.isMDXComponent=!0;const t9p={toc:[]},o9p="wrapper";function p9p(e){let{components:n,...t}=e;return(0,s.yg)(o9p,(0,p.A)({},t9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}p9p.isMDXComponent=!0;const r9p={toc:[]},s9p="wrapper";function c9p(e){let{components:n,...t}=e;return(0,s.yg)(s9p,(0,p.A)({},r9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}c9p.isMDXComponent=!0;const a9p={toc:[]},i9p="wrapper";function l9p(e){let{components:n,...t}=e;return(0,s.yg)(i9p,(0,p.A)({},a9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}l9p.isMDXComponent=!0;const u9p={toc:[]},m9p="wrapper";function y9p(e){let{components:n,...t}=e;return(0,s.yg)(m9p,(0,p.A)({},u9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}y9p.isMDXComponent=!0;const d9p={toc:[]},h9p="wrapper";function g9p(e){let{components:n,...t}=e;return(0,s.yg)(h9p,(0,p.A)({},d9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}g9p.isMDXComponent=!0;const f9p={toc:[]},D9p="wrapper";function M9p(e){let{components:n,...t}=e;return(0,s.yg)(D9p,(0,p.A)({},f9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}M9p.isMDXComponent=!0;const X9p={toc:[]},_9p="wrapper";function w9p(e){let{components:n,...t}=e;return(0,s.yg)(_9p,(0,p.A)({},X9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}w9p.isMDXComponent=!0;const T9p={toc:[]},C9p="wrapper";function x9p(e){let{components:n,...t}=e;return(0,s.yg)(C9p,(0,p.A)({},T9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}x9p.isMDXComponent=!0;const A9p={toc:[]},v9p="wrapper";function L9p(e){let{components:n,...t}=e;return(0,s.yg)(v9p,(0,p.A)({},A9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}L9p.isMDXComponent=!0;const b9p={toc:[]},N9p="wrapper";function k9p(e){let{components:n,...t}=e;return(0,s.yg)(N9p,(0,p.A)({},b9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}k9p.isMDXComponent=!0;const z9p={toc:[]},P9p="wrapper";function I9p(e){let{components:n,...t}=e;return(0,s.yg)(P9p,(0,p.A)({},z9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}I9p.isMDXComponent=!0;const R9p={toc:[]},W9p="wrapper";function S9p(e){let{components:n,...t}=e;return(0,s.yg)(W9p,(0,p.A)({},R9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}S9p.isMDXComponent=!0;const B9p={toc:[]},G9p="wrapper";function E9p(e){let{components:n,...t}=e;return(0,s.yg)(G9p,(0,p.A)({},B9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}E9p.isMDXComponent=!0;const O9p={toc:[]},U9p="wrapper";function F9p(e){let{components:n,...t}=e;return(0,s.yg)(U9p,(0,p.A)({},O9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}F9p.isMDXComponent=!0;const V9p={toc:[]},q9p="wrapper";function j9p(e){let{components:n,...t}=e;return(0,s.yg)(q9p,(0,p.A)({},V9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}j9p.isMDXComponent=!0;const H9p={toc:[]},Y9p="wrapper";function Q9p(e){let{components:n,...t}=e;return(0,s.yg)(Y9p,(0,p.A)({},H9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Q9p.isMDXComponent=!0;const $9p={toc:[]},K9p="wrapper";function J9p(e){let{components:n,...t}=e;return(0,s.yg)(K9p,(0,p.A)({},$9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}J9p.isMDXComponent=!0;const Z9p={toc:[]},eer="wrapper";function ner(e){let{components:n,...t}=e;return(0,s.yg)(eer,(0,p.A)({},Z9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ner.isMDXComponent=!0;const ter={toc:[]},oer="wrapper";function per(e){let{components:n,...t}=e;return(0,s.yg)(oer,(0,p.A)({},ter,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}per.isMDXComponent=!0;const rer={toc:[]},ser="wrapper";function cer(e){let{components:n,...t}=e;return(0,s.yg)(ser,(0,p.A)({},rer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cer.isMDXComponent=!0;const aer={toc:[]},ier="wrapper";function ler(e){let{components:n,...t}=e;return(0,s.yg)(ier,(0,p.A)({},aer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ler.isMDXComponent=!0;const uer={toc:[]},mer="wrapper";function yer(e){let{components:n,...t}=e;return(0,s.yg)(mer,(0,p.A)({},uer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yer.isMDXComponent=!0;const der={toc:[]},her="wrapper";function ger(e){let{components:n,...t}=e;return(0,s.yg)(her,(0,p.A)({},der,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ger.isMDXComponent=!0;const fer={toc:[]},Der="wrapper";function Mer(e){let{components:n,...t}=e;return(0,s.yg)(Der,(0,p.A)({},fer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Mer.isMDXComponent=!0;const Xer={toc:[]},_er="wrapper";function wer(e){let{components:n,...t}=e;return(0,s.yg)(_er,(0,p.A)({},Xer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wer.isMDXComponent=!0;const Ter={toc:[]},Cer="wrapper";function xer(e){let{components:n,...t}=e;return(0,s.yg)(Cer,(0,p.A)({},Ter,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}xer.isMDXComponent=!0;const Aer={toc:[]},ver="wrapper";function Ler(e){let{components:n,...t}=e;return(0,s.yg)(ver,(0,p.A)({},Aer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Ler.isMDXComponent=!0;const ber={toc:[]},Ner="wrapper";function ker(e){let{components:n,...t}=e;return(0,s.yg)(Ner,(0,p.A)({},ber,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ker.isMDXComponent=!0;const zer={toc:[]},Per="wrapper";function Ier(e){let{components:n,...t}=e;return(0,s.yg)(Per,(0,p.A)({},zer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Ier.isMDXComponent=!0;const Rer={toc:[]},Wer="wrapper";function Ser(e){let{components:n,...t}=e;return(0,s.yg)(Wer,(0,p.A)({},Rer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ser.isMDXComponent=!0;const Ber={toc:[]},Ger="wrapper";function Eer(e){let{components:n,...t}=e;return(0,s.yg)(Ger,(0,p.A)({},Ber,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Eer.isMDXComponent=!0;const Oer={toc:[]},Uer="wrapper";function Fer(e){let{components:n,...t}=e;return(0,s.yg)(Uer,(0,p.A)({},Oer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Fer.isMDXComponent=!0;const Ver={toc:[]},qer="wrapper";function jer(e){let{components:n,...t}=e;return(0,s.yg)(qer,(0,p.A)({},Ver,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}jer.isMDXComponent=!0;const Her={toc:[]},Yer="wrapper";function Qer(e){let{components:n,...t}=e;return(0,s.yg)(Yer,(0,p.A)({},Her,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Qer.isMDXComponent=!0;const $er={toc:[]},Ker="wrapper";function Jer(e){let{components:n,...t}=e;return(0,s.yg)(Ker,(0,p.A)({},$er,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Jer.isMDXComponent=!0;const Zer={toc:[]},enr="wrapper";function nnr(e){let{components:n,...t}=e;return(0,s.yg)(enr,(0,p.A)({},Zer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}nnr.isMDXComponent=!0;const tnr={toc:[]},onr="wrapper";function pnr(e){let{components:n,...t}=e;return(0,s.yg)(onr,(0,p.A)({},tnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}pnr.isMDXComponent=!0;const rnr={toc:[]},snr="wrapper";function cnr(e){let{components:n,...t}=e;return(0,s.yg)(snr,(0,p.A)({},rnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cnr.isMDXComponent=!0;const anr={toc:[]},inr="wrapper";function lnr(e){let{components:n,...t}=e;return(0,s.yg)(inr,(0,p.A)({},anr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}lnr.isMDXComponent=!0;const unr={toc:[]},mnr="wrapper";function ynr(e){let{components:n,...t}=e;return(0,s.yg)(mnr,(0,p.A)({},unr,t,{components:n,mdxType:"MDXLayout"}))}ynr.isMDXComponent=!0;const dnr={toc:[]},hnr="wrapper";function gnr(e){let{components:n,...t}=e;return(0,s.yg)(hnr,(0,p.A)({},dnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}gnr.isMDXComponent=!0;const fnr={toc:[]},Dnr="wrapper";function Mnr(e){let{components:n,...t}=e;return(0,s.yg)(Dnr,(0,p.A)({},fnr,t,{components:n,mdxType:"MDXLayout"}))}Mnr.isMDXComponent=!0;const Xnr={toc:[]},_nr="wrapper";function wnr(e){let{components:n,...t}=e;return(0,s.yg)(_nr,(0,p.A)({},Xnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}wnr.isMDXComponent=!0;const Tnr={toc:[]},Cnr="wrapper";function xnr(e){let{components:n,...t}=e;return(0,s.yg)(Cnr,(0,p.A)({},Tnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}xnr.isMDXComponent=!0;const Anr={toc:[]},vnr="wrapper";function Lnr(e){let{components:n,...t}=e;return(0,s.yg)(vnr,(0,p.A)({},Anr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lnr.isMDXComponent=!0;const bnr={toc:[]},Nnr="wrapper";function knr(e){let{components:n,...t}=e;return(0,s.yg)(Nnr,(0,p.A)({},bnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}knr.isMDXComponent=!0;const znr={toc:[]},Pnr="wrapper";function Inr(e){let{components:n,...t}=e;return(0,s.yg)(Pnr,(0,p.A)({},znr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Inr.isMDXComponent=!0;const Rnr={toc:[]},Wnr="wrapper";function Snr(e){let{components:n,...t}=e;return(0,s.yg)(Wnr,(0,p.A)({},Rnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Snr.isMDXComponent=!0;const Bnr={toc:[]},Gnr="wrapper";function Enr(e){let{components:n,...t}=e;return(0,s.yg)(Gnr,(0,p.A)({},Bnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Enr.isMDXComponent=!0;const Onr={toc:[]},Unr="wrapper";function Fnr(e){let{components:n,...t}=e;return(0,s.yg)(Unr,(0,p.A)({},Onr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Fnr.isMDXComponent=!0;const Vnr={toc:[]},qnr="wrapper";function jnr(e){let{components:n,...t}=e;return(0,s.yg)(qnr,(0,p.A)({},Vnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jnr.isMDXComponent=!0;const Hnr={toc:[]},Ynr="wrapper";function Qnr(e){let{components:n,...t}=e;return(0,s.yg)(Ynr,(0,p.A)({},Hnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Qnr.isMDXComponent=!0;const $nr={toc:[]},Knr="wrapper";function Jnr(e){let{components:n,...t}=e;return(0,s.yg)(Knr,(0,p.A)({},$nr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Jnr.isMDXComponent=!0;const Znr={toc:[]},etr="wrapper";function ntr(e){let{components:n,...t}=e;return(0,s.yg)(etr,(0,p.A)({},Znr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ntr.isMDXComponent=!0;const ttr={toc:[]},otr="wrapper";function ptr(e){let{components:n,...t}=e;return(0,s.yg)(otr,(0,p.A)({},ttr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}ptr.isMDXComponent=!0;const rtr={toc:[]},str="wrapper";function ctr(e){let{components:n,...t}=e;return(0,s.yg)(str,(0,p.A)({},rtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ctr.isMDXComponent=!0;const atr={toc:[]},itr="wrapper";function ltr(e){let{components:n,...t}=e;return(0,s.yg)(itr,(0,p.A)({},atr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ltr.isMDXComponent=!0;const utr={toc:[]},mtr="wrapper";function ytr(e){let{components:n,...t}=e;return(0,s.yg)(mtr,(0,p.A)({},utr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}ytr.isMDXComponent=!0;const dtr={toc:[]},htr="wrapper";function gtr(e){let{components:n,...t}=e;return(0,s.yg)(htr,(0,p.A)({},dtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gtr.isMDXComponent=!0;const ftr={toc:[]},Dtr="wrapper";function Mtr(e){let{components:n,...t}=e;return(0,s.yg)(Dtr,(0,p.A)({},ftr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Mtr.isMDXComponent=!0;const Xtr={toc:[]},_tr="wrapper";function wtr(e){let{components:n,...t}=e;return(0,s.yg)(_tr,(0,p.A)({},Xtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wtr.isMDXComponent=!0;const Ttr={toc:[]},Ctr="wrapper";function xtr(e){let{components:n,...t}=e;return(0,s.yg)(Ctr,(0,p.A)({},Ttr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}xtr.isMDXComponent=!0;const Atr={toc:[]},vtr="wrapper";function Ltr(e){let{components:n,...t}=e;return(0,s.yg)(vtr,(0,p.A)({},Atr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ltr.isMDXComponent=!0;const btr={toc:[]},Ntr="wrapper";function ktr(e){let{components:n,...t}=e;return(0,s.yg)(Ntr,(0,p.A)({},btr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ktr.isMDXComponent=!0;const ztr={toc:[]},Ptr="wrapper";function Itr(e){let{components:n,...t}=e;return(0,s.yg)(Ptr,(0,p.A)({},ztr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Itr.isMDXComponent=!0;const Rtr={toc:[]},Wtr="wrapper";function Str(e){let{components:n,...t}=e;return(0,s.yg)(Wtr,(0,p.A)({},Rtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Str.isMDXComponent=!0;const Btr={toc:[]},Gtr="wrapper";function Etr(e){let{components:n,...t}=e;return(0,s.yg)(Gtr,(0,p.A)({},Btr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Etr.isMDXComponent=!0;const Otr={toc:[]},Utr="wrapper";function Ftr(e){let{components:n,...t}=e;return(0,s.yg)(Utr,(0,p.A)({},Otr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ftr.isMDXComponent=!0;const Vtr={toc:[]},qtr="wrapper";function jtr(e){let{components:n,...t}=e;return(0,s.yg)(qtr,(0,p.A)({},Vtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jtr.isMDXComponent=!0;const Htr={toc:[]},Ytr="wrapper";function Qtr(e){let{components:n,...t}=e;return(0,s.yg)(Ytr,(0,p.A)({},Htr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Qtr.isMDXComponent=!0;const $tr={toc:[]},Ktr="wrapper";function Jtr(e){let{components:n,...t}=e;return(0,s.yg)(Ktr,(0,p.A)({},$tr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Jtr.isMDXComponent=!0;const Ztr={toc:[]},eor="wrapper";function nor(e){let{components:n,...t}=e;return(0,s.yg)(eor,(0,p.A)({},Ztr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nor.isMDXComponent=!0;const tor={toc:[]},oor="wrapper";function por(e){let{components:n,...t}=e;return(0,s.yg)(oor,(0,p.A)({},tor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}por.isMDXComponent=!0;const ror={toc:[]},sor="wrapper";function cor(e){let{components:n,...t}=e;return(0,s.yg)(sor,(0,p.A)({},ror,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}cor.isMDXComponent=!0;const aor={toc:[]},ior="wrapper";function lor(e){let{components:n,...t}=e;return(0,s.yg)(ior,(0,p.A)({},aor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}lor.isMDXComponent=!0;const uor={toc:[]},mor="wrapper";function yor(e){let{components:n,...t}=e;return(0,s.yg)(mor,(0,p.A)({},uor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}yor.isMDXComponent=!0;const dor={toc:[]},hor="wrapper";function gor(e){let{components:n,...t}=e;return(0,s.yg)(hor,(0,p.A)({},dor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gor.isMDXComponent=!0;const Dor={toc:[]},Mor="wrapper";function Xor(e){let{components:n,...t}=e;return(0,s.yg)(Mor,(0,p.A)({},Dor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Xor.isMDXComponent=!0;const _or={toc:[]},wor="wrapper";function Tor(e){let{components:n,...t}=e;return(0,s.yg)(wor,(0,p.A)({},_or,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Tor.isMDXComponent=!0;const Cor={toc:[]},xor="wrapper";function Aor(e){let{components:n,...t}=e;return(0,s.yg)(xor,(0,p.A)({},Cor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Aor.isMDXComponent=!0;const vor={toc:[]},Lor="wrapper";function bor(e){let{components:n,...t}=e;return(0,s.yg)(Lor,(0,p.A)({},vor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting point of the ray."))}bor.isMDXComponent=!0;const Nor={toc:[]},kor="wrapper";function zor(e){let{components:n,...t}=e;return(0,s.yg)(kor,(0,p.A)({},Nor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}zor.isMDXComponent=!0;const Por={toc:[]},Ior="wrapper";function Ror(e){let{components:n,...t}=e;return(0,s.yg)(Ior,(0,p.A)({},Por,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ror.isMDXComponent=!0;const Wor={toc:[]},Sor="wrapper";function Bor(e){let{components:n,...t}=e;return(0,s.yg)(Sor,(0,p.A)({},Wor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Bor.isMDXComponent=!0;const Gor={toc:[]},Eor="wrapper";function Oor(e){let{components:n,...t}=e;return(0,s.yg)(Eor,(0,p.A)({},Gor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Oor.isMDXComponent=!0;const Uor={toc:[]},For="wrapper";function Vor(e){let{components:n,...t}=e;return(0,s.yg)(For,(0,p.A)({},Uor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Vor.isMDXComponent=!0;const qor={toc:[]},jor="wrapper";function Hor(e){let{components:n,...t}=e;return(0,s.yg)(jor,(0,p.A)({},qor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Hor.isMDXComponent=!0;const Yor={toc:[]},Qor="wrapper";function $or(e){let{components:n,...t}=e;return(0,s.yg)(Qor,(0,p.A)({},Yor,t,{components:n,mdxType:"MDXLayout"}))}$or.isMDXComponent=!0;const Kor={toc:[]},Jor="wrapper";function Zor(e){let{components:n,...t}=e;return(0,s.yg)(Jor,(0,p.A)({},Kor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Zor.isMDXComponent=!0;const epr={toc:[]},npr="wrapper";function tpr(e){let{components:n,...t}=e;return(0,s.yg)(npr,(0,p.A)({},epr,t,{components:n,mdxType:"MDXLayout"}))}tpr.isMDXComponent=!0;const opr={toc:[]},ppr="wrapper";function rpr(e){let{components:n,...t}=e;return(0,s.yg)(ppr,(0,p.A)({},opr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}rpr.isMDXComponent=!0;const spr={toc:[]},cpr="wrapper";function apr(e){let{components:n,...t}=e;return(0,s.yg)(cpr,(0,p.A)({},spr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}apr.isMDXComponent=!0;const ipr={toc:[]},lpr="wrapper";function upr(e){let{components:n,...t}=e;return(0,s.yg)(lpr,(0,p.A)({},ipr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}upr.isMDXComponent=!0;const mpr={toc:[]},ypr="wrapper";function dpr(e){let{components:n,...t}=e;return(0,s.yg)(ypr,(0,p.A)({},mpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}dpr.isMDXComponent=!0;const hpr={toc:[]},gpr="wrapper";function fpr(e){let{components:n,...t}=e;return(0,s.yg)(gpr,(0,p.A)({},hpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}fpr.isMDXComponent=!0;const Dpr={toc:[]},Mpr="wrapper";function Xpr(e){let{components:n,...t}=e;return(0,s.yg)(Mpr,(0,p.A)({},Dpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Xpr.isMDXComponent=!0;const _pr={toc:[]},wpr="wrapper";function Tpr(e){let{components:n,...t}=e;return(0,s.yg)(wpr,(0,p.A)({},_pr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending point of the ray."))}Tpr.isMDXComponent=!0;const Cpr={toc:[]},xpr="wrapper";function Apr(e){let{components:n,...t}=e;return(0,s.yg)(xpr,(0,p.A)({},Cpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Apr.isMDXComponent=!0;const vpr={toc:[]},Lpr="wrapper";function bpr(e){let{components:n,...t}=e;return(0,s.yg)(Lpr,(0,p.A)({},vpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}bpr.isMDXComponent=!0;const Npr={toc:[]},kpr="wrapper";function zpr(e){let{components:n,...t}=e;return(0,s.yg)(kpr,(0,p.A)({},Npr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}zpr.isMDXComponent=!0;const Ppr={toc:[]},Ipr="wrapper";function Rpr(e){let{components:n,...t}=e;return(0,s.yg)(Ipr,(0,p.A)({},Ppr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Rpr.isMDXComponent=!0;const Wpr={toc:[]},Spr="wrapper";function Bpr(e){let{components:n,...t}=e;return(0,s.yg)(Spr,(0,p.A)({},Wpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Bpr.isMDXComponent=!0;const Gpr={toc:[]},Epr="wrapper";function Opr(e){let{components:n,...t}=e;return(0,s.yg)(Epr,(0,p.A)({},Gpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Opr.isMDXComponent=!0;const Upr={toc:[]},Fpr="wrapper";function Vpr(e){let{components:n,...t}=e;return(0,s.yg)(Fpr,(0,p.A)({},Upr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Vpr.isMDXComponent=!0;const qpr={toc:[]},jpr="wrapper";function Hpr(e){let{components:n,...t}=e;return(0,s.yg)(jpr,(0,p.A)({},qpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Hpr.isMDXComponent=!0;const Ypr={toc:[]},Qpr="wrapper";function $pr(e){let{components:n,...t}=e;return(0,s.yg)(Qpr,(0,p.A)({},Ypr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}$pr.isMDXComponent=!0;const Kpr={toc:[]},Jpr="wrapper";function Zpr(e){let{components:n,...t}=e;return(0,s.yg)(Jpr,(0,p.A)({},Kpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Zpr.isMDXComponent=!0;const err={toc:[]},nrr="wrapper";function trr(e){let{components:n,...t}=e;return(0,s.yg)(nrr,(0,p.A)({},err,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}trr.isMDXComponent=!0;const orr={toc:[]},prr="wrapper";function rrr(e){let{components:n,...t}=e;return(0,s.yg)(prr,(0,p.A)({},orr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}rrr.isMDXComponent=!0;const srr={toc:[]},crr="wrapper";function arr(e){let{components:n,...t}=e;return(0,s.yg)(crr,(0,p.A)({},srr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}arr.isMDXComponent=!0;const irr={toc:[]},lrr="wrapper";function urr(e){let{components:n,...t}=e;return(0,s.yg)(lrr,(0,p.A)({},irr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}urr.isMDXComponent=!0;const mrr={toc:[]},yrr="wrapper";function drr(e){let{components:n,...t}=e;return(0,s.yg)(yrr,(0,p.A)({},mrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}drr.isMDXComponent=!0;const hrr={toc:[]},grr="wrapper";function frr(e){let{components:n,...t}=e;return(0,s.yg)(grr,(0,p.A)({},hrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}frr.isMDXComponent=!0;const Drr={toc:[]},Mrr="wrapper";function Xrr(e){let{components:n,...t}=e;return(0,s.yg)(Mrr,(0,p.A)({},Drr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Xrr.isMDXComponent=!0;const _rr={toc:[]},wrr="wrapper";function Trr(e){let{components:n,...t}=e;return(0,s.yg)(wrr,(0,p.A)({},_rr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Trr.isMDXComponent=!0;const Crr={toc:[]},xrr="wrapper";function Arr(e){let{components:n,...t}=e;return(0,s.yg)(xrr,(0,p.A)({},Crr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Arr.isMDXComponent=!0;const vrr={toc:[]},Lrr="wrapper";function brr(e){let{components:n,...t}=e;return(0,s.yg)(Lrr,(0,p.A)({},vrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}brr.isMDXComponent=!0;const Nrr={toc:[]},krr="wrapper";function zrr(e){let{components:n,...t}=e;return(0,s.yg)(krr,(0,p.A)({},Nrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}zrr.isMDXComponent=!0;const Prr={toc:[]},Irr="wrapper";function Rrr(e){let{components:n,...t}=e;return(0,s.yg)(Irr,(0,p.A)({},Prr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Rrr.isMDXComponent=!0;const Wrr={toc:[]},Srr="wrapper";function Brr(e){let{components:n,...t}=e;return(0,s.yg)(Srr,(0,p.A)({},Wrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Brr.isMDXComponent=!0;const Grr={toc:[]},Err="wrapper";function Orr(e){let{components:n,...t}=e;return(0,s.yg)(Err,(0,p.A)({},Grr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Orr.isMDXComponent=!0;const Urr={toc:[]},Frr="wrapper";function Vrr(e){let{components:n,...t}=e;return(0,s.yg)(Frr,(0,p.A)({},Urr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Vrr.isMDXComponent=!0;const qrr={toc:[]},jrr="wrapper";function Hrr(e){let{components:n,...t}=e;return(0,s.yg)(jrr,(0,p.A)({},qrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Hrr.isMDXComponent=!0;const Yrr={toc:[]},Qrr="wrapper";function $rr(e){let{components:n,...t}=e;return(0,s.yg)(Qrr,(0,p.A)({},Yrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}$rr.isMDXComponent=!0;const Krr={toc:[]},Jrr="wrapper";function Zrr(e){let{components:n,...t}=e;return(0,s.yg)(Jrr,(0,p.A)({},Krr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Zrr.isMDXComponent=!0;const esr={toc:[]},nsr="wrapper";function tsr(e){let{components:n,...t}=e;return(0,s.yg)(nsr,(0,p.A)({},esr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}tsr.isMDXComponent=!0;const osr={toc:[]},psr="wrapper";function rsr(e){let{components:n,...t}=e;return(0,s.yg)(psr,(0,p.A)({},osr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}rsr.isMDXComponent=!0;const ssr={toc:[]},csr="wrapper";function asr(e){let{components:n,...t}=e;return(0,s.yg)(csr,(0,p.A)({},ssr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}asr.isMDXComponent=!0;const isr={toc:[]},lsr="wrapper";function usr(e){let{components:n,...t}=e;return(0,s.yg)(lsr,(0,p.A)({},isr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}usr.isMDXComponent=!0;const msr={toc:[]},ysr="wrapper";function dsr(e){let{components:n,...t}=e;return(0,s.yg)(ysr,(0,p.A)({},msr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}dsr.isMDXComponent=!0;const hsr={toc:[]},gsr="wrapper";function fsr(e){let{components:n,...t}=e;return(0,s.yg)(gsr,(0,p.A)({},hsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}fsr.isMDXComponent=!0;const Dsr={toc:[]},Msr="wrapper";function Xsr(e){let{components:n,...t}=e;return(0,s.yg)(Msr,(0,p.A)({},Dsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Xsr.isMDXComponent=!0;const _sr={toc:[]},wsr="wrapper";function Tsr(e){let{components:n,...t}=e;return(0,s.yg)(wsr,(0,p.A)({},_sr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Tsr.isMDXComponent=!0;const Csr={toc:[]},xsr="wrapper";function Asr(e){let{components:n,...t}=e;return(0,s.yg)(xsr,(0,p.A)({},Csr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Asr.isMDXComponent=!0;const vsr={toc:[]},Lsr="wrapper";function bsr(e){let{components:n,...t}=e;return(0,s.yg)(Lsr,(0,p.A)({},vsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}bsr.isMDXComponent=!0;const Nsr={toc:[]},ksr="wrapper";function zsr(e){let{components:n,...t}=e;return(0,s.yg)(ksr,(0,p.A)({},Nsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}zsr.isMDXComponent=!0;const Psr={toc:[]},Isr="wrapper";function Rsr(e){let{components:n,...t}=e;return(0,s.yg)(Isr,(0,p.A)({},Psr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Rsr.isMDXComponent=!0;const Wsr={toc:[]},Ssr="wrapper";function Bsr(e){let{components:n,...t}=e;return(0,s.yg)(Ssr,(0,p.A)({},Wsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Bsr.isMDXComponent=!0;const Gsr={toc:[]},Esr="wrapper";function Osr(e){let{components:n,...t}=e;return(0,s.yg)(Esr,(0,p.A)({},Gsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Osr.isMDXComponent=!0;const Usr={toc:[]},Fsr="wrapper";function Vsr(e){let{components:n,...t}=e;return(0,s.yg)(Fsr,(0,p.A)({},Usr,t,{components:n,mdxType:"MDXLayout"}))}Vsr.isMDXComponent=!0;const qsr={toc:[]},jsr="wrapper";function Hsr(e){let{components:n,...t}=e;return(0,s.yg)(jsr,(0,p.A)({},qsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Hsr.isMDXComponent=!0;const Ysr={toc:[]},Qsr="wrapper";function $sr(e){let{components:n,...t}=e;return(0,s.yg)(Qsr,(0,p.A)({},Ysr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}$sr.isMDXComponent=!0;const Ksr={toc:[]},Jsr="wrapper";function Zsr(e){let{components:n,...t}=e;return(0,s.yg)(Jsr,(0,p.A)({},Ksr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Zsr.isMDXComponent=!0;const ecr={toc:[]},ncr="wrapper";function tcr(e){let{components:n,...t}=e;return(0,s.yg)(ncr,(0,p.A)({},ecr,t,{components:n,mdxType:"MDXLayout"}))}tcr.isMDXComponent=!0;const ocr={toc:[]},pcr="wrapper";function rcr(e){let{components:n,...t}=e;return(0,s.yg)(pcr,(0,p.A)({},ocr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}rcr.isMDXComponent=!0;const scr={toc:[]},ccr="wrapper";function acr(e){let{components:n,...t}=e;return(0,s.yg)(ccr,(0,p.A)({},scr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}acr.isMDXComponent=!0;const icr={toc:[]},lcr="wrapper";function ucr(e){let{components:n,...t}=e;return(0,s.yg)(lcr,(0,p.A)({},icr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ucr.isMDXComponent=!0;const mcr={toc:[]},ycr="wrapper";function dcr(e){let{components:n,...t}=e;return(0,s.yg)(ycr,(0,p.A)({},mcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}dcr.isMDXComponent=!0;const hcr={toc:[]},gcr="wrapper";function fcr(e){let{components:n,...t}=e;return(0,s.yg)(gcr,(0,p.A)({},hcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}fcr.isMDXComponent=!0;const Dcr={toc:[]},Mcr="wrapper";function Xcr(e){let{components:n,...t}=e;return(0,s.yg)(Mcr,(0,p.A)({},Dcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Xcr.isMDXComponent=!0;const _cr={toc:[]},wcr="wrapper";function Tcr(e){let{components:n,...t}=e;return(0,s.yg)(wcr,(0,p.A)({},_cr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Tcr.isMDXComponent=!0;const Ccr={toc:[]},xcr="wrapper";function Acr(e){let{components:n,...t}=e;return(0,s.yg)(xcr,(0,p.A)({},Ccr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Acr.isMDXComponent=!0;const vcr={toc:[]},Lcr="wrapper";function bcr(e){let{components:n,...t}=e;return(0,s.yg)(Lcr,(0,p.A)({},vcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}bcr.isMDXComponent=!0;const Ncr={toc:[]},kcr="wrapper";function zcr(e){let{components:n,...t}=e;return(0,s.yg)(kcr,(0,p.A)({},Ncr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}zcr.isMDXComponent=!0;const Pcr={toc:[]},Icr="wrapper";function Rcr(e){let{components:n,...t}=e;return(0,s.yg)(Icr,(0,p.A)({},Pcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Rcr.isMDXComponent=!0;const Wcr={toc:[]},Scr="wrapper";function Bcr(e){let{components:n,...t}=e;return(0,s.yg)(Scr,(0,p.A)({},Wcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Bcr.isMDXComponent=!0;const Gcr={toc:[]},Ecr="wrapper";function Ocr(e){let{components:n,...t}=e;return(0,s.yg)(Ecr,(0,p.A)({},Gcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represent SVG document that contains SVG shapes.\nThis only used single time because ",(0,s.yg)("inlineCode",{parentName:"p"},"nodes")," have reference to parent SVG renderer."))}Ocr.isMDXComponent=!0;const Ucr={toc:[]},Fcr="wrapper";function Vcr(e){let{components:n,...t}=e;return(0,s.yg)(Fcr,(0,p.A)({},Ucr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Data of SVGDocument.\nThis can used many times because it do not reference parent SVG.\nThis must build into SVGDocument"))}Vcr.isMDXComponent=!0;const qcr={toc:[]},jcr="wrapper";function Hcr(e){let{components:n,...t}=e;return(0,s.yg)(jcr,(0,p.A)({},qcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Hcr.isMDXComponent=!0;const Ycr={toc:[]},Qcr="wrapper";function $cr(e){let{components:n,...t}=e;return(0,s.yg)(Qcr,(0,p.A)({},Ycr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}$cr.isMDXComponent=!0;const Kcr={toc:[]},Jcr="wrapper";function Zcr(e){let{components:n,...t}=e;return(0,s.yg)(Jcr,(0,p.A)({},Kcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Zcr.isMDXComponent=!0;const ear={toc:[]},nar="wrapper";function tar(e){let{components:n,...t}=e;return(0,s.yg)(nar,(0,p.A)({},ear,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}tar.isMDXComponent=!0;const oar={toc:[]},par="wrapper";function rar(e){let{components:n,...t}=e;return(0,s.yg)(par,(0,p.A)({},oar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}rar.isMDXComponent=!0;const sar={toc:[]},car="wrapper";function aar(e){let{components:n,...t}=e;return(0,s.yg)(car,(0,p.A)({},sar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}aar.isMDXComponent=!0;const iar={toc:[]},lar="wrapper";function uar(e){let{components:n,...t}=e;return(0,s.yg)(lar,(0,p.A)({},iar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}uar.isMDXComponent=!0;const mar={toc:[]},yar="wrapper";function dar(e){let{components:n,...t}=e;return(0,s.yg)(yar,(0,p.A)({},mar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}dar.isMDXComponent=!0;const har={toc:[]},gar="wrapper";function far(e){let{components:n,...t}=e;return(0,s.yg)(gar,(0,p.A)({},har,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}far.isMDXComponent=!0;const Dar={toc:[]},Mar="wrapper";function Xar(e){let{components:n,...t}=e;return(0,s.yg)(Mar,(0,p.A)({},Dar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Xar.isMDXComponent=!0;const _ar={toc:[]},war="wrapper";function Tar(e){let{components:n,...t}=e;return(0,s.yg)(war,(0,p.A)({},_ar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Tar.isMDXComponent=!0;const Car={toc:[]},xar="wrapper";function Aar(e){let{components:n,...t}=e;return(0,s.yg)(xar,(0,p.A)({},Car,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Aar.isMDXComponent=!0;const Lar={toc:[]},bar="wrapper";function Nar(e){let{components:n,...t}=e;return(0,s.yg)(bar,(0,p.A)({},Lar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Nar.isMDXComponent=!0;const kar={toc:[]},zar="wrapper";function Par(e){let{components:n,...t}=e;return(0,s.yg)(zar,(0,p.A)({},kar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Par.isMDXComponent=!0;const Iar={toc:[]},Rar="wrapper";function War(e){let{components:n,...t}=e;return(0,s.yg)(Rar,(0,p.A)({},Iar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}War.isMDXComponent=!0;const Sar={toc:[]},Bar="wrapper";function Gar(e){let{components:n,...t}=e;return(0,s.yg)(Bar,(0,p.A)({},Sar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Gar.isMDXComponent=!0;const Ear={toc:[]},Oar="wrapper";function Uar(e){let{components:n,...t}=e;return(0,s.yg)(Oar,(0,p.A)({},Ear,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Uar.isMDXComponent=!0;const Far={toc:[]},Var="wrapper";function qar(e){let{components:n,...t}=e;return(0,s.yg)(Var,(0,p.A)({},Far,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}qar.isMDXComponent=!0;const jar={toc:[]},Har="wrapper";function Yar(e){let{components:n,...t}=e;return(0,s.yg)(Har,(0,p.A)({},jar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Yar.isMDXComponent=!0;const Qar={toc:[]},$ar="wrapper";function Kar(e){let{components:n,...t}=e;return(0,s.yg)($ar,(0,p.A)({},Qar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Kar.isMDXComponent=!0;const Jar={toc:[]},Zar="wrapper";function eir(e){let{components:n,...t}=e;return(0,s.yg)(Zar,(0,p.A)({},Jar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}eir.isMDXComponent=!0;const nir={toc:[]},tir="wrapper";function oir(e){let{components:n,...t}=e;return(0,s.yg)(tir,(0,p.A)({},nir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}oir.isMDXComponent=!0;const pir={toc:[]},rir="wrapper";function sir(e){let{components:n,...t}=e;return(0,s.yg)(rir,(0,p.A)({},pir,t,{components:n,mdxType:"MDXLayout"}))}sir.isMDXComponent=!0;const cir={toc:[]},air="wrapper";function iir(e){let{components:n,...t}=e;return(0,s.yg)(air,(0,p.A)({},cir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}iir.isMDXComponent=!0;const lir={toc:[]},uir="wrapper";function mir(e){let{components:n,...t}=e;return(0,s.yg)(uir,(0,p.A)({},lir,t,{components:n,mdxType:"MDXLayout"}))}mir.isMDXComponent=!0;const yir={toc:[]},dir="wrapper";function hir(e){let{components:n,...t}=e;return(0,s.yg)(dir,(0,p.A)({},yir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hir.isMDXComponent=!0;const gir={toc:[]},fir="wrapper";function Dir(e){let{components:n,...t}=e;return(0,s.yg)(fir,(0,p.A)({},gir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Dir.isMDXComponent=!0;const Mir={toc:[]},Xir="wrapper";function _ir(e){let{components:n,...t}=e;return(0,s.yg)(Xir,(0,p.A)({},Mir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_ir.isMDXComponent=!0;const wir={toc:[]},Tir="wrapper";function Cir(e){let{components:n,...t}=e;return(0,s.yg)(Tir,(0,p.A)({},wir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Cir.isMDXComponent=!0;const xir={toc:[]},Air="wrapper";function vir(e){let{components:n,...t}=e;return(0,s.yg)(Air,(0,p.A)({},xir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}vir.isMDXComponent=!0;const Lir={toc:[]},bir="wrapper";function Nir(e){let{components:n,...t}=e;return(0,s.yg)(bir,(0,p.A)({},Lir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Nir.isMDXComponent=!0;const kir={toc:[]},zir="wrapper";function Pir(e){let{components:n,...t}=e;return(0,s.yg)(zir,(0,p.A)({},kir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represent SVG shape.\nThis only used single time because ",(0,s.yg)("inlineCode",{parentName:"p"},"node")," may have reference to parent SVG renderer."))}Pir.isMDXComponent=!0;const Iir={toc:[]},Rir="wrapper";function Wir(e){let{components:n,...t}=e;return(0,s.yg)(Rir,(0,p.A)({},Iir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Data of SVGShape.\nThis can used many times  because it do not reference parent SVG.\nThis must build into SVGShape"))}Wir.isMDXComponent=!0;const Sir={toc:[]},Bir="wrapper";function Gir(e){let{components:n,...t}=e;return(0,s.yg)(Bir,(0,p.A)({},Sir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Gir.isMDXComponent=!0;const Eir={toc:[]},Oir="wrapper";function Uir(e){let{components:n,...t}=e;return(0,s.yg)(Oir,(0,p.A)({},Eir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Uir.isMDXComponent=!0;const Fir={toc:[]},Vir="wrapper";function qir(e){let{components:n,...t}=e;return(0,s.yg)(Vir,(0,p.A)({},Fir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qir.isMDXComponent=!0;const jir={toc:[]},Hir="wrapper";function Yir(e){let{components:n,...t}=e;return(0,s.yg)(Hir,(0,p.A)({},jir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Yir.isMDXComponent=!0;const Qir={toc:[]},$ir="wrapper";function Kir(e){let{components:n,...t}=e;return(0,s.yg)($ir,(0,p.A)({},Qir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Kir.isMDXComponent=!0;const Jir={toc:[]},Zir="wrapper";function elr(e){let{components:n,...t}=e;return(0,s.yg)(Zir,(0,p.A)({},Jir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}elr.isMDXComponent=!0;const nlr={toc:[]},tlr="wrapper";function olr(e){let{components:n,...t}=e;return(0,s.yg)(tlr,(0,p.A)({},nlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}olr.isMDXComponent=!0;const plr={toc:[]},rlr="wrapper";function slr(e){let{components:n,...t}=e;return(0,s.yg)(rlr,(0,p.A)({},plr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}slr.isMDXComponent=!0;const clr={toc:[]},alr="wrapper";function ilr(e){let{components:n,...t}=e;return(0,s.yg)(alr,(0,p.A)({},clr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ilr.isMDXComponent=!0;const llr={toc:[]},ulr="wrapper";function mlr(e){let{components:n,...t}=e;return(0,s.yg)(ulr,(0,p.A)({},llr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}mlr.isMDXComponent=!0;const ylr={toc:[]},dlr="wrapper";function hlr(e){let{components:n,...t}=e;return(0,s.yg)(dlr,(0,p.A)({},ylr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}hlr.isMDXComponent=!0;const glr={toc:[]},flr="wrapper";function Dlr(e){let{components:n,...t}=e;return(0,s.yg)(flr,(0,p.A)({},glr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Dlr.isMDXComponent=!0;const Mlr={toc:[]},Xlr="wrapper";function _lr(e){let{components:n,...t}=e;return(0,s.yg)(Xlr,(0,p.A)({},Mlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}_lr.isMDXComponent=!0;const wlr={toc:[]},Tlr="wrapper";function Clr(e){let{components:n,...t}=e;return(0,s.yg)(Tlr,(0,p.A)({},wlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Clr.isMDXComponent=!0;const xlr={toc:[]},Alr="wrapper";function vlr(e){let{components:n,...t}=e;return(0,s.yg)(Alr,(0,p.A)({},xlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}vlr.isMDXComponent=!0;const Llr={toc:[]},blr="wrapper";function Nlr(e){let{components:n,...t}=e;return(0,s.yg)(blr,(0,p.A)({},Llr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Nlr.isMDXComponent=!0;const klr={toc:[]},zlr="wrapper";function Plr(e){let{components:n,...t}=e;return(0,s.yg)(zlr,(0,p.A)({},klr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Plr.isMDXComponent=!0;const Ilr={toc:[]},Rlr="wrapper";function Wlr(e){let{components:n,...t}=e;return(0,s.yg)(Rlr,(0,p.A)({},Ilr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Wlr.isMDXComponent=!0;const Slr={toc:[]},Blr="wrapper";function Glr(e){let{components:n,...t}=e;return(0,s.yg)(Blr,(0,p.A)({},Slr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Glr.isMDXComponent=!0;const Elr={toc:[]},Olr="wrapper";function Ulr(e){let{components:n,...t}=e;return(0,s.yg)(Olr,(0,p.A)({},Elr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Ulr.isMDXComponent=!0;const Flr={toc:[]},Vlr="wrapper";function qlr(e){let{components:n,...t}=e;return(0,s.yg)(Vlr,(0,p.A)({},Flr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qlr.isMDXComponent=!0;const jlr={toc:[]},Hlr="wrapper";function Ylr(e){let{components:n,...t}=e;return(0,s.yg)(Hlr,(0,p.A)({},jlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Ylr.isMDXComponent=!0;const Qlr={toc:[]},$lr="wrapper";function Klr(e){let{components:n,...t}=e;return(0,s.yg)($lr,(0,p.A)({},Qlr,t,{components:n,mdxType:"MDXLayout"}))}Klr.isMDXComponent=!0;const Jlr={toc:[]},Zlr="wrapper";function eur(e){let{components:n,...t}=e;return(0,s.yg)(Zlr,(0,p.A)({},Jlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}eur.isMDXComponent=!0;const nur={toc:[]},tur="wrapper";function our(e){let{components:n,...t}=e;return(0,s.yg)(tur,(0,p.A)({},nur,t,{components:n,mdxType:"MDXLayout"}))}our.isMDXComponent=!0;const pur={toc:[]},rur="wrapper";function sur(e){let{components:n,...t}=e;return(0,s.yg)(rur,(0,p.A)({},pur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}sur.isMDXComponent=!0;const cur={toc:[]},aur="wrapper";function iur(e){let{components:n,...t}=e;return(0,s.yg)(aur,(0,p.A)({},cur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}iur.isMDXComponent=!0;const lur={toc:[]},uur="wrapper";function mur(e){let{components:n,...t}=e;return(0,s.yg)(uur,(0,p.A)({},lur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}mur.isMDXComponent=!0;const yur={toc:[]},dur="wrapper";function hur(e){let{components:n,...t}=e;return(0,s.yg)(dur,(0,p.A)({},yur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}hur.isMDXComponent=!0;const gur={toc:[]},fur="wrapper";function Dur(e){let{components:n,...t}=e;return(0,s.yg)(fur,(0,p.A)({},gur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dur.isMDXComponent=!0;const Mur={toc:[]},Xur="wrapper";function _ur(e){let{components:n,...t}=e;return(0,s.yg)(Xur,(0,p.A)({},Mur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}_ur.isMDXComponent=!0;const wur={toc:[]},Tur="wrapper";function Cur(e){let{components:n,...t}=e;return(0,s.yg)(Tur,(0,p.A)({},wur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Cur.isMDXComponent=!0;const xur={toc:[]},Aur="wrapper";function vur(e){let{components:n,...t}=e;return(0,s.yg)(Aur,(0,p.A)({},xur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}vur.isMDXComponent=!0;const Lur={toc:[]},bur="wrapper";function Nur(e){let{components:n,...t}=e;return(0,s.yg)(bur,(0,p.A)({},Lur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Nur.isMDXComponent=!0;const kur={toc:[]},zur="wrapper";function Pur(e){let{components:n,...t}=e;return(0,s.yg)(zur,(0,p.A)({},kur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Pur.isMDXComponent=!0;const Iur={toc:[]},Rur="wrapper";function Wur(e){let{components:n,...t}=e;return(0,s.yg)(Rur,(0,p.A)({},Iur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Wur.isMDXComponent=!0;const Sur={toc:[]},Bur="wrapper";function Gur(e){let{components:n,...t}=e;return(0,s.yg)(Bur,(0,p.A)({},Sur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Gur.isMDXComponent=!0;const Eur={toc:[]},Our="wrapper";function Uur(e){let{components:n,...t}=e;return(0,s.yg)(Our,(0,p.A)({},Eur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Uur.isMDXComponent=!0;const Fur={toc:[]},Vur="wrapper";function qur(e){let{components:n,...t}=e;return(0,s.yg)(Vur,(0,p.A)({},Fur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}qur.isMDXComponent=!0;const jur={toc:[]},Hur="wrapper";function Yur(e){let{components:n,...t}=e;return(0,s.yg)(Hur,(0,p.A)({},jur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Yur.isMDXComponent=!0;const Qur={toc:[]},$ur="wrapper";function Kur(e){let{components:n,...t}=e;return(0,s.yg)($ur,(0,p.A)({},Qur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Kur.isMDXComponent=!0;const Jur={toc:[]},Zur="wrapper";function emr(e){let{components:n,...t}=e;return(0,s.yg)(Zur,(0,p.A)({},Jur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}emr.isMDXComponent=!0;const nmr={toc:[]},tmr="wrapper";function omr(e){let{components:n,...t}=e;return(0,s.yg)(tmr,(0,p.A)({},nmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}omr.isMDXComponent=!0;const pmr={toc:[]},rmr="wrapper";function smr(e){let{components:n,...t}=e;return(0,s.yg)(rmr,(0,p.A)({},pmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}smr.isMDXComponent=!0;const cmr={toc:[]},amr="wrapper";function imr(e){let{components:n,...t}=e;return(0,s.yg)(amr,(0,p.A)({},cmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}imr.isMDXComponent=!0;const lmr={toc:[]},umr="wrapper";function mmr(e){let{components:n,...t}=e;return(0,s.yg)(umr,(0,p.A)({},lmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}mmr.isMDXComponent=!0;const ymr={toc:[]},dmr="wrapper";function hmr(e){let{components:n,...t}=e;return(0,s.yg)(dmr,(0,p.A)({},ymr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}hmr.isMDXComponent=!0;const gmr={toc:[]},fmr="wrapper";function Dmr(e){let{components:n,...t}=e;return(0,s.yg)(fmr,(0,p.A)({},gmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Dmr.isMDXComponent=!0;const Mmr={toc:[]},Xmr="wrapper";function _mr(e){let{components:n,...t}=e;return(0,s.yg)(Xmr,(0,p.A)({},Mmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}_mr.isMDXComponent=!0;const wmr={toc:[]},Tmr="wrapper";function Cmr(e){let{components:n,...t}=e;return(0,s.yg)(Tmr,(0,p.A)({},wmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Cmr.isMDXComponent=!0;const xmr={toc:[]},Amr="wrapper";function vmr(e){let{components:n,...t}=e;return(0,s.yg)(Amr,(0,p.A)({},xmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}vmr.isMDXComponent=!0;const Lmr={toc:[]},bmr="wrapper";function Nmr(e){let{components:n,...t}=e;return(0,s.yg)(bmr,(0,p.A)({},Lmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nmr.isMDXComponent=!0;const kmr={toc:[]},zmr="wrapper";function Pmr(e){let{components:n,...t}=e;return(0,s.yg)(zmr,(0,p.A)({},kmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Pmr.isMDXComponent=!0;const Imr={toc:[]},Rmr="wrapper";function Wmr(e){let{components:n,...t}=e;return(0,s.yg)(Rmr,(0,p.A)({},Imr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wmr.isMDXComponent=!0;const Smr={toc:[]},Bmr="wrapper";function Gmr(e){let{components:n,...t}=e;return(0,s.yg)(Bmr,(0,p.A)({},Smr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Gmr.isMDXComponent=!0;const Emr={toc:[]},Omr="wrapper";function Umr(e){let{components:n,...t}=e;return(0,s.yg)(Omr,(0,p.A)({},Emr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Umr.isMDXComponent=!0;const Fmr={toc:[]},Vmr="wrapper";function qmr(e){let{components:n,...t}=e;return(0,s.yg)(Vmr,(0,p.A)({},Fmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}qmr.isMDXComponent=!0;const jmr={toc:[]},Hmr="wrapper";function Ymr(e){let{components:n,...t}=e;return(0,s.yg)(Hmr,(0,p.A)({},jmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ymr.isMDXComponent=!0;const Qmr={toc:[]},$mr="wrapper";function Kmr(e){let{components:n,...t}=e;return(0,s.yg)($mr,(0,p.A)({},Qmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Kmr.isMDXComponent=!0;const Jmr={toc:[]},Zmr="wrapper";function eyr(e){let{components:n,...t}=e;return(0,s.yg)(Zmr,(0,p.A)({},Jmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}eyr.isMDXComponent=!0;const nyr={toc:[]},tyr="wrapper";function oyr(e){let{components:n,...t}=e;return(0,s.yg)(tyr,(0,p.A)({},nyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}oyr.isMDXComponent=!0;const pyr={toc:[]},ryr="wrapper";function syr(e){let{components:n,...t}=e;return(0,s.yg)(ryr,(0,p.A)({},pyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."))}syr.isMDXComponent=!0;const cyr={toc:[]},ayr="wrapper";function iyr(e){let{components:n,...t}=e;return(0,s.yg)(ayr,(0,p.A)({},cyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}iyr.isMDXComponent=!0;const lyr={toc:[]},uyr="wrapper";function myr(e){let{components:n,...t}=e;return(0,s.yg)(uyr,(0,p.A)({},lyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}myr.isMDXComponent=!0;const yyr={toc:[]},dyr="wrapper";function hyr(e){let{components:n,...t}=e;return(0,s.yg)(dyr,(0,p.A)({},yyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}hyr.isMDXComponent=!0;const gyr={toc:[]},fyr="wrapper";function Dyr(e){let{components:n,...t}=e;return(0,s.yg)(fyr,(0,p.A)({},gyr,t,{components:n,mdxType:"MDXLayout"}))}Dyr.isMDXComponent=!0;const Myr={toc:[]},Xyr="wrapper";function _yr(e){let{components:n,...t}=e;return(0,s.yg)(Xyr,(0,p.A)({},Myr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property is only applied to knots that don't use explicit handles."))}_yr.isMDXComponent=!0;const wyr={toc:[]},Tyr="wrapper";function Cyr(e){let{components:n,...t}=e;return(0,s.yg)(Tyr,(0,p.A)({},wyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The smoothness of the spline when using auto-calculated handles."))}Cyr.isMDXComponent=!0;const xyr={toc:[]},Ayr="wrapper";function vyr(e){let{components:n,...t}=e;return(0,s.yg)(Ayr,(0,p.A)({},xyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}vyr.isMDXComponent=!0;const Lyr={toc:[]},byr="wrapper";function Nyr(e){let{components:n,...t}=e;return(0,s.yg)(byr,(0,p.A)({},Lyr,t,{components:n,mdxType:"MDXLayout"}))}Nyr.isMDXComponent=!0;const kyr={toc:[]},zyr="wrapper";function Pyr(e){let{components:n,...t}=e;return(0,s.yg)(zyr,(0,p.A)({},kyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Pyr.isMDXComponent=!0;const Iyr={toc:[]},Ryr="wrapper";function Wyr(e){let{components:n,...t}=e;return(0,s.yg)(Ryr,(0,p.A)({},Iyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Wyr.isMDXComponent=!0;const Syr={toc:[]},Byr="wrapper";function Gyr(e){let{components:n,...t}=e;return(0,s.yg)(Byr,(0,p.A)({},Syr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Gyr.isMDXComponent=!0;const Eyr={toc:[]},Oyr="wrapper";function Uyr(e){let{components:n,...t}=e;return(0,s.yg)(Oyr,(0,p.A)({},Eyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Uyr.isMDXComponent=!0;const Fyr={toc:[]},Vyr="wrapper";function qyr(e){let{components:n,...t}=e;return(0,s.yg)(Vyr,(0,p.A)({},Fyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}qyr.isMDXComponent=!0;const jyr={toc:[]},Hyr="wrapper";function Yyr(e){let{components:n,...t}=e;return(0,s.yg)(Hyr,(0,p.A)({},jyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Yyr.isMDXComponent=!0;const Qyr={toc:[]},$yr="wrapper";function Kyr(e){let{components:n,...t}=e;return(0,s.yg)($yr,(0,p.A)({},Qyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Kyr.isMDXComponent=!0;const Jyr={toc:[]},Zyr="wrapper";function edr(e){let{components:n,...t}=e;return(0,s.yg)(Zyr,(0,p.A)({},Jyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}edr.isMDXComponent=!0;const ndr={toc:[]},tdr="wrapper";function odr(e){let{components:n,...t}=e;return(0,s.yg)(tdr,(0,p.A)({},ndr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}odr.isMDXComponent=!0;const pdr={toc:[]},rdr="wrapper";function sdr(e){let{components:n,...t}=e;return(0,s.yg)(rdr,(0,p.A)({},pdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}sdr.isMDXComponent=!0;const cdr={toc:[]},adr="wrapper";function idr(e){let{components:n,...t}=e;return(0,s.yg)(adr,(0,p.A)({},cdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}idr.isMDXComponent=!0;const ldr={toc:[]},udr="wrapper";function mdr(e){let{components:n,...t}=e;return(0,s.yg)(udr,(0,p.A)({},ldr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}mdr.isMDXComponent=!0;const ydr={toc:[]},ddr="wrapper";function hdr(e){let{components:n,...t}=e;return(0,s.yg)(ddr,(0,p.A)({},ydr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hdr.isMDXComponent=!0;const gdr={toc:[]},fdr="wrapper";function Ddr(e){let{components:n,...t}=e;return(0,s.yg)(fdr,(0,p.A)({},gdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Ddr.isMDXComponent=!0;const Mdr={toc:[]},Xdr="wrapper";function _dr(e){let{components:n,...t}=e;return(0,s.yg)(Xdr,(0,p.A)({},Mdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_dr.isMDXComponent=!0;const wdr={toc:[]},Tdr="wrapper";function Cdr(e){let{components:n,...t}=e;return(0,s.yg)(Tdr,(0,p.A)({},wdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Cdr.isMDXComponent=!0;const xdr={toc:[]},Adr="wrapper";function vdr(e){let{components:n,...t}=e;return(0,s.yg)(Adr,(0,p.A)({},xdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}vdr.isMDXComponent=!0;const Ldr={toc:[]},bdr="wrapper";function Ndr(e){let{components:n,...t}=e;return(0,s.yg)(bdr,(0,p.A)({},Ldr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Ndr.isMDXComponent=!0;const kdr={toc:[]},zdr="wrapper";function Pdr(e){let{components:n,...t}=e;return(0,s.yg)(zdr,(0,p.A)({},kdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Pdr.isMDXComponent=!0;const Idr={toc:[]},Rdr="wrapper";function Wdr(e){let{components:n,...t}=e;return(0,s.yg)(Rdr,(0,p.A)({},Idr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Wdr.isMDXComponent=!0;const Sdr={toc:[]},Bdr="wrapper";function Gdr(e){let{components:n,...t}=e;return(0,s.yg)(Bdr,(0,p.A)({},Sdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Gdr.isMDXComponent=!0;const Edr={toc:[]},Odr="wrapper";function Udr(e){let{components:n,...t}=e;return(0,s.yg)(Odr,(0,p.A)({},Edr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Udr.isMDXComponent=!0;const Fdr={toc:[]},Vdr="wrapper";function qdr(e){let{components:n,...t}=e;return(0,s.yg)(Vdr,(0,p.A)({},Fdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}qdr.isMDXComponent=!0;const jdr={toc:[]},Hdr="wrapper";function Ydr(e){let{components:n,...t}=e;return(0,s.yg)(Hdr,(0,p.A)({},jdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ydr.isMDXComponent=!0;const Qdr={toc:[]},$dr="wrapper";function Kdr(e){let{components:n,...t}=e;return(0,s.yg)($dr,(0,p.A)({},Qdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Kdr.isMDXComponent=!0;const Jdr={toc:[]},Zdr="wrapper";function ehr(e){let{components:n,...t}=e;return(0,s.yg)(Zdr,(0,p.A)({},Jdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ehr.isMDXComponent=!0;const nhr={toc:[]},thr="wrapper";function ohr(e){let{components:n,...t}=e;return(0,s.yg)(thr,(0,p.A)({},nhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ohr.isMDXComponent=!0;const phr={toc:[]},rhr="wrapper";function shr(e){let{components:n,...t}=e;return(0,s.yg)(rhr,(0,p.A)({},phr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}shr.isMDXComponent=!0;const chr={toc:[]},ahr="wrapper";function ihr(e){let{components:n,...t}=e;return(0,s.yg)(ahr,(0,p.A)({},chr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ihr.isMDXComponent=!0;const lhr={toc:[]},uhr="wrapper";function mhr(e){let{components:n,...t}=e;return(0,s.yg)(uhr,(0,p.A)({},lhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}mhr.isMDXComponent=!0;const yhr={toc:[]},dhr="wrapper";function hhr(e){let{components:n,...t}=e;return(0,s.yg)(dhr,(0,p.A)({},yhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}hhr.isMDXComponent=!0;const ghr={toc:[]},fhr="wrapper";function Dhr(e){let{components:n,...t}=e;return(0,s.yg)(fhr,(0,p.A)({},ghr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Dhr.isMDXComponent=!0;const Mhr={toc:[]},Xhr="wrapper";function _hr(e){let{components:n,...t}=e;return(0,s.yg)(Xhr,(0,p.A)({},Mhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_hr.isMDXComponent=!0;const whr={toc:[]},Thr="wrapper";function Chr(e){let{components:n,...t}=e;return(0,s.yg)(Thr,(0,p.A)({},whr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Chr.isMDXComponent=!0;const xhr={toc:[]},Ahr="wrapper";function vhr(e){let{components:n,...t}=e;return(0,s.yg)(Ahr,(0,p.A)({},xhr,t,{components:n,mdxType:"MDXLayout"}))}vhr.isMDXComponent=!0;const Lhr={toc:[]},bhr="wrapper";function Nhr(e){let{components:n,...t}=e;return(0,s.yg)(bhr,(0,p.A)({},Lhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Nhr.isMDXComponent=!0;const khr={toc:[]},zhr="wrapper";function Phr(e){let{components:n,...t}=e;return(0,s.yg)(zhr,(0,p.A)({},khr,t,{components:n,mdxType:"MDXLayout"}))}Phr.isMDXComponent=!0;const Ihr={toc:[]},Rhr="wrapper";function Whr(e){let{components:n,...t}=e;return(0,s.yg)(Rhr,(0,p.A)({},Ihr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Whr.isMDXComponent=!0;const Shr={toc:[]},Bhr="wrapper";function Ghr(e){let{components:n,...t}=e;return(0,s.yg)(Bhr,(0,p.A)({},Shr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Ghr.isMDXComponent=!0;const Ehr={toc:[]},Ohr="wrapper";function Uhr(e){let{components:n,...t}=e;return(0,s.yg)(Ohr,(0,p.A)({},Ehr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Uhr.isMDXComponent=!0;const Fhr={toc:[]},Vhr="wrapper";function qhr(e){let{components:n,...t}=e;return(0,s.yg)(Vhr,(0,p.A)({},Fhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}qhr.isMDXComponent=!0;const jhr={toc:[]},Hhr="wrapper";function Yhr(e){let{components:n,...t}=e;return(0,s.yg)(Hhr,(0,p.A)({},jhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Yhr.isMDXComponent=!0;const Qhr={toc:[]},$hr="wrapper";function Khr(e){let{components:n,...t}=e;return(0,s.yg)($hr,(0,p.A)({},Qhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Khr.isMDXComponent=!0;const Jhr={toc:[]},Zhr="wrapper";function egr(e){let{components:n,...t}=e;return(0,s.yg)(Zhr,(0,p.A)({},Jhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}egr.isMDXComponent=!0;const ngr={toc:[]},tgr="wrapper";function ogr(e){let{components:n,...t}=e;return(0,s.yg)(tgr,(0,p.A)({},ngr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this video."))}ogr.isMDXComponent=!0;const pgr={toc:[]},rgr="wrapper";function sgr(e){let{components:n,...t}=e;return(0,s.yg)(rgr,(0,p.A)({},pgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}sgr.isMDXComponent=!0;const cgr={toc:[]},agr="wrapper";function igr(e){let{components:n,...t}=e;return(0,s.yg)(agr,(0,p.A)({},cgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}igr.isMDXComponent=!0;const lgr={toc:[]},ugr="wrapper";function mgr(e){let{components:n,...t}=e;return(0,s.yg)(ugr,(0,p.A)({},lgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}mgr.isMDXComponent=!0;const ygr={toc:[]},dgr="wrapper";function hgr(e){let{components:n,...t}=e;return(0,s.yg)(dgr,(0,p.A)({},ygr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}hgr.isMDXComponent=!0;const ggr={toc:[]},fgr="wrapper";function Dgr(e){let{components:n,...t}=e;return(0,s.yg)(fgr,(0,p.A)({},ggr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dgr.isMDXComponent=!0;const Mgr={toc:[]},Xgr="wrapper";function _gr(e){let{components:n,...t}=e;return(0,s.yg)(Xgr,(0,p.A)({},Mgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}_gr.isMDXComponent=!0;const wgr={toc:[]},Tgr="wrapper";function Cgr(e){let{components:n,...t}=e;return(0,s.yg)(Tgr,(0,p.A)({},wgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Cgr.isMDXComponent=!0;const xgr={toc:[]},Agr="wrapper";function vgr(e){let{components:n,...t}=e;return(0,s.yg)(Agr,(0,p.A)({},xgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}vgr.isMDXComponent=!0;const Lgr={toc:[]},bgr="wrapper";function Ngr(e){let{components:n,...t}=e;return(0,s.yg)(bgr,(0,p.A)({},Lgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ngr.isMDXComponent=!0;const kgr={toc:[]},zgr="wrapper";function Pgr(e){let{components:n,...t}=e;return(0,s.yg)(zgr,(0,p.A)({},kgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Pgr.isMDXComponent=!0;const Igr={toc:[]},Rgr="wrapper";function Wgr(e){let{components:n,...t}=e;return(0,s.yg)(Rgr,(0,p.A)({},Igr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Wgr.isMDXComponent=!0;const Sgr={toc:[]},Bgr="wrapper";function Ggr(e){let{components:n,...t}=e;return(0,s.yg)(Bgr,(0,p.A)({},Sgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ggr.isMDXComponent=!0;const Egr={toc:[]},Ogr="wrapper";function Ugr(e){let{components:n,...t}=e;return(0,s.yg)(Ogr,(0,p.A)({},Egr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ugr.isMDXComponent=!0;const Fgr={toc:[]},Vgr="wrapper";function qgr(e){let{components:n,...t}=e;return(0,s.yg)(Vgr,(0,p.A)({},Fgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}qgr.isMDXComponent=!0;const jgr={toc:[]},Hgr="wrapper";function Ygr(e){let{components:n,...t}=e;return(0,s.yg)(Hgr,(0,p.A)({},jgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ygr.isMDXComponent=!0;const Qgr={toc:[]},$gr="wrapper";function Kgr(e){let{components:n,...t}=e;return(0,s.yg)($gr,(0,p.A)({},Qgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Kgr.isMDXComponent=!0;const Jgr={toc:[]},Zgr="wrapper";function efr(e){let{components:n,...t}=e;return(0,s.yg)(Zgr,(0,p.A)({},Jgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}efr.isMDXComponent=!0;const nfr={toc:[]},tfr="wrapper";function ofr(e){let{components:n,...t}=e;return(0,s.yg)(tfr,(0,p.A)({},nfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ofr.isMDXComponent=!0;const pfr={toc:[]},rfr="wrapper";function sfr(e){let{components:n,...t}=e;return(0,s.yg)(rfr,(0,p.A)({},pfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}sfr.isMDXComponent=!0;const cfr={toc:[]},afr="wrapper";function ifr(e){let{components:n,...t}=e;return(0,s.yg)(afr,(0,p.A)({},cfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}ifr.isMDXComponent=!0;const lfr={toc:[]},ufr="wrapper";function mfr(e){let{components:n,...t}=e;return(0,s.yg)(ufr,(0,p.A)({},lfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}mfr.isMDXComponent=!0;const yfr={toc:[]},dfr="wrapper";function hfr(e){let{components:n,...t}=e;return(0,s.yg)(dfr,(0,p.A)({},yfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}hfr.isMDXComponent=!0;const gfr={toc:[]},ffr="wrapper";function Dfr(e){let{components:n,...t}=e;return(0,s.yg)(ffr,(0,p.A)({},gfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Dfr.isMDXComponent=!0;const Mfr={toc:[]},Xfr="wrapper";function _fr(e){let{components:n,...t}=e;return(0,s.yg)(Xfr,(0,p.A)({},Mfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}_fr.isMDXComponent=!0;const wfr={toc:[]},Tfr="wrapper";function Cfr(e){let{components:n,...t}=e;return(0,s.yg)(Tfr,(0,p.A)({},wfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Cfr.isMDXComponent=!0;const xfr={toc:[]},Afr="wrapper";function vfr(e){let{components:n,...t}=e;return(0,s.yg)(Afr,(0,p.A)({},xfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}vfr.isMDXComponent=!0;const Lfr={toc:[]},bfr="wrapper";function Nfr(e){let{components:n,...t}=e;return(0,s.yg)(bfr,(0,p.A)({},Lfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Nfr.isMDXComponent=!0;const kfr={toc:[]},zfr="wrapper";function Pfr(e){let{components:n,...t}=e;return(0,s.yg)(zfr,(0,p.A)({},kfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Pfr.isMDXComponent=!0;const Ifr={toc:[]},Rfr="wrapper";function Wfr(e){let{components:n,...t}=e;return(0,s.yg)(Rfr,(0,p.A)({},Ifr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Wfr.isMDXComponent=!0;const Sfr={toc:[]},Bfr="wrapper";function Gfr(e){let{components:n,...t}=e;return(0,s.yg)(Bfr,(0,p.A)({},Sfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Gfr.isMDXComponent=!0;const Efr={toc:[]},Ofr="wrapper";function Ufr(e){let{components:n,...t}=e;return(0,s.yg)(Ofr,(0,p.A)({},Efr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Ufr.isMDXComponent=!0;const Ffr={toc:[]},Vfr="wrapper";function qfr(e){let{components:n,...t}=e;return(0,s.yg)(Vfr,(0,p.A)({},Ffr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}qfr.isMDXComponent=!0;const jfr={toc:[]},Hfr="wrapper";function Yfr(e){let{components:n,...t}=e;return(0,s.yg)(Hfr,(0,p.A)({},jfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Yfr.isMDXComponent=!0;const Qfr={toc:[]},$fr="wrapper";function Kfr(e){let{components:n,...t}=e;return(0,s.yg)($fr,(0,p.A)({},Qfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Kfr.isMDXComponent=!0;const Jfr={toc:[]},Zfr="wrapper";function eDr(e){let{components:n,...t}=e;return(0,s.yg)(Zfr,(0,p.A)({},Jfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}eDr.isMDXComponent=!0;const nDr={toc:[]},tDr="wrapper";function oDr(e){let{components:n,...t}=e;return(0,s.yg)(tDr,(0,p.A)({},nDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}oDr.isMDXComponent=!0;const pDr={toc:[]},rDr="wrapper";function sDr(e){let{components:n,...t}=e;return(0,s.yg)(rDr,(0,p.A)({},pDr,t,{components:n,mdxType:"MDXLayout"}))}sDr.isMDXComponent=!0;const cDr={toc:[]},aDr="wrapper";function iDr(e){let{components:n,...t}=e;return(0,s.yg)(aDr,(0,p.A)({},cDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}iDr.isMDXComponent=!0;const lDr={toc:[]},uDr="wrapper";function mDr(e){let{components:n,...t}=e;return(0,s.yg)(uDr,(0,p.A)({},lDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}mDr.isMDXComponent=!0;const yDr={toc:[]},dDr="wrapper";function hDr(e){let{components:n,...t}=e;return(0,s.yg)(dDr,(0,p.A)({},yDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}hDr.isMDXComponent=!0;const gDr={toc:[]},fDr="wrapper";function DDr(e){let{components:n,...t}=e;return(0,s.yg)(fDr,(0,p.A)({},gDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video should be smoothed."))}DDr.isMDXComponent=!0;const MDr={toc:[]},XDr="wrapper";function _Dr(e){let{components:n,...t}=e;return(0,s.yg)(XDr,(0,p.A)({},MDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}_Dr.isMDXComponent=!0;const wDr={toc:[]},TDr="wrapper";function CDr(e){let{components:n,...t}=e;return(0,s.yg)(TDr,(0,p.A)({},wDr,t,{components:n,mdxType:"MDXLayout"}))}CDr.isMDXComponent=!0;const xDr={toc:[]},ADr="wrapper";function vDr(e){let{components:n,...t}=e;return(0,s.yg)(ADr,(0,p.A)({},xDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}vDr.isMDXComponent=!0;const LDr={toc:[]},bDr="wrapper";function NDr(e){let{components:n,...t}=e;return(0,s.yg)(bDr,(0,p.A)({},LDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}NDr.isMDXComponent=!0;const kDr={toc:[]},zDr="wrapper";function PDr(e){let{components:n,...t}=e;return(0,s.yg)(zDr,(0,p.A)({},kDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}PDr.isMDXComponent=!0;const IDr={toc:[]},RDr="wrapper";function WDr(e){let{components:n,...t}=e;return(0,s.yg)(RDr,(0,p.A)({},IDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}WDr.isMDXComponent=!0;const SDr={toc:[]},BDr="wrapper";function GDr(e){let{components:n,...t}=e;return(0,s.yg)(BDr,(0,p.A)({},SDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}GDr.isMDXComponent=!0;const EDr={toc:[]},ODr="wrapper";function UDr(e){let{components:n,...t}=e;return(0,s.yg)(ODr,(0,p.A)({},EDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}UDr.isMDXComponent=!0;const FDr={toc:[]},VDr="wrapper";function qDr(e){let{components:n,...t}=e;return(0,s.yg)(VDr,(0,p.A)({},FDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qDr.isMDXComponent=!0;const jDr={toc:[]},HDr="wrapper";function YDr(e){let{components:n,...t}=e;return(0,s.yg)(HDr,(0,p.A)({},jDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}YDr.isMDXComponent=!0;const QDr={toc:[]},$Dr="wrapper";function KDr(e){let{components:n,...t}=e;return(0,s.yg)($Dr,(0,p.A)({},QDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}KDr.isMDXComponent=!0;const JDr={toc:[]},ZDr="wrapper";function eMr(e){let{components:n,...t}=e;return(0,s.yg)(ZDr,(0,p.A)({},JDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}eMr.isMDXComponent=!0;const nMr={toc:[]},tMr="wrapper";function oMr(e){let{components:n,...t}=e;return(0,s.yg)(tMr,(0,p.A)({},nMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}oMr.isMDXComponent=!0;const pMr={toc:[]},rMr="wrapper";function sMr(e){let{components:n,...t}=e;return(0,s.yg)(rMr,(0,p.A)({},pMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}sMr.isMDXComponent=!0;const cMr={toc:[]},aMr="wrapper";function iMr(e){let{components:n,...t}=e;return(0,s.yg)(aMr,(0,p.A)({},cMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}iMr.isMDXComponent=!0;const lMr={toc:[]},uMr="wrapper";function mMr(e){let{components:n,...t}=e;return(0,s.yg)(uMr,(0,p.A)({},lMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}mMr.isMDXComponent=!0;const yMr={toc:[]},dMr="wrapper";function hMr(e){let{components:n,...t}=e;return(0,s.yg)(dMr,(0,p.A)({},yMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hMr.isMDXComponent=!0;const gMr={toc:[]},fMr="wrapper";function DMr(e){let{components:n,...t}=e;return(0,s.yg)(fMr,(0,p.A)({},gMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}DMr.isMDXComponent=!0;const MMr={toc:[]},XMr="wrapper";function _Mr(e){let{components:n,...t}=e;return(0,s.yg)(XMr,(0,p.A)({},MMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_Mr.isMDXComponent=!0;const wMr={toc:[]},TMr="wrapper";function CMr(e){let{components:n,...t}=e;return(0,s.yg)(TMr,(0,p.A)({},wMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}CMr.isMDXComponent=!0;const xMr={toc:[]},AMr="wrapper";function vMr(e){let{components:n,...t}=e;return(0,s.yg)(AMr,(0,p.A)({},xMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}vMr.isMDXComponent=!0;const LMr={toc:[]},bMr="wrapper";function NMr(e){let{components:n,...t}=e;return(0,s.yg)(bMr,(0,p.A)({},LMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}NMr.isMDXComponent=!0;const kMr={toc:[]},zMr="wrapper";function PMr(e){let{components:n,...t}=e;return(0,s.yg)(zMr,(0,p.A)({},kMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}PMr.isMDXComponent=!0;const IMr={toc:[]},RMr="wrapper";function WMr(e){let{components:n,...t}=e;return(0,s.yg)(RMr,(0,p.A)({},IMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}WMr.isMDXComponent=!0;const SMr={toc:[]},BMr="wrapper";function GMr(e){let{components:n,...t}=e;return(0,s.yg)(BMr,(0,p.A)({},SMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}GMr.isMDXComponent=!0;const EMr={toc:[]},OMr="wrapper";function UMr(e){let{components:n,...t}=e;return(0,s.yg)(OMr,(0,p.A)({},EMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}UMr.isMDXComponent=!0;const FMr={toc:[]},VMr="wrapper";function qMr(e){let{components:n,...t}=e;return(0,s.yg)(VMr,(0,p.A)({},FMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}qMr.isMDXComponent=!0;const jMr={toc:[]},HMr="wrapper";function YMr(e){let{components:n,...t}=e;return(0,s.yg)(HMr,(0,p.A)({},jMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}YMr.isMDXComponent=!0;const QMr={toc:[]},$Mr="wrapper";function KMr(e){let{components:n,...t}=e;return(0,s.yg)($Mr,(0,p.A)({},QMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}KMr.isMDXComponent=!0;const JMr={toc:[]},ZMr="wrapper";function eXr(e){let{components:n,...t}=e;return(0,s.yg)(ZMr,(0,p.A)({},JMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}eXr.isMDXComponent=!0;const nXr={toc:[]},tXr="wrapper";function oXr(e){let{components:n,...t}=e;return(0,s.yg)(tXr,(0,p.A)({},nXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}oXr.isMDXComponent=!0;const pXr={toc:[]},rXr="wrapper";function sXr(e){let{components:n,...t}=e;return(0,s.yg)(rXr,(0,p.A)({},pXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}sXr.isMDXComponent=!0;const cXr={toc:[]},aXr="wrapper";function iXr(e){let{components:n,...t}=e;return(0,s.yg)(aXr,(0,p.A)({},cXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}iXr.isMDXComponent=!0;const lXr={toc:[]},uXr="wrapper";function mXr(e){let{components:n,...t}=e;return(0,s.yg)(uXr,(0,p.A)({},lXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}mXr.isMDXComponent=!0;const yXr={toc:[]},dXr="wrapper";function hXr(e){let{components:n,...t}=e;return(0,s.yg)(dXr,(0,p.A)({},yXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}hXr.isMDXComponent=!0;const gXr={toc:[]},fXr="wrapper";function DXr(e){let{components:n,...t}=e;return(0,s.yg)(fXr,(0,p.A)({},gXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}DXr.isMDXComponent=!0;const MXr={toc:[]},XXr="wrapper";function _Xr(e){let{components:n,...t}=e;return(0,s.yg)(XXr,(0,p.A)({},MXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}_Xr.isMDXComponent=!0;const wXr={toc:[]},TXr="wrapper";function CXr(e){let{components:n,...t}=e;return(0,s.yg)(TXr,(0,p.A)({},wXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}CXr.isMDXComponent=!0;const xXr={toc:[]},AXr="wrapper";function vXr(e){let{components:n,...t}=e;return(0,s.yg)(AXr,(0,p.A)({},xXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}vXr.isMDXComponent=!0;const LXr={toc:[]},bXr="wrapper";function NXr(e){let{components:n,...t}=e;return(0,s.yg)(bXr,(0,p.A)({},LXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}NXr.isMDXComponent=!0;const kXr={toc:[]},zXr="wrapper";function PXr(e){let{components:n,...t}=e;return(0,s.yg)(zXr,(0,p.A)({},kXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}PXr.isMDXComponent=!0;const IXr={toc:[]},RXr="wrapper";function WXr(e){let{components:n,...t}=e;return(0,s.yg)(RXr,(0,p.A)({},IXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}WXr.isMDXComponent=!0;const SXr={toc:[]},BXr="wrapper";function GXr(e){let{components:n,...t}=e;return(0,s.yg)(BXr,(0,p.A)({},SXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}GXr.isMDXComponent=!0;const EXr={toc:[]},OXr="wrapper";function UXr(e){let{components:n,...t}=e;return(0,s.yg)(OXr,(0,p.A)({},EXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}UXr.isMDXComponent=!0;const FXr={toc:[]},VXr="wrapper";function qXr(e){let{components:n,...t}=e;return(0,s.yg)(VXr,(0,p.A)({},FXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}qXr.isMDXComponent=!0;const jXr={toc:[]},HXr="wrapper";function YXr(e){let{components:n,...t}=e;return(0,s.yg)(HXr,(0,p.A)({},jXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}YXr.isMDXComponent=!0;const QXr={toc:[]},$Xr="wrapper";function KXr(e){let{components:n,...t}=e;return(0,s.yg)($Xr,(0,p.A)({},QXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}KXr.isMDXComponent=!0;const JXr={toc:[]},ZXr="wrapper";function e_r(e){let{components:n,...t}=e;return(0,s.yg)(ZXr,(0,p.A)({},JXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}e_r.isMDXComponent=!0;const n_r={toc:[]},t_r="wrapper";function o_r(e){let{components:n,...t}=e;return(0,s.yg)(t_r,(0,p.A)({},n_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}o_r.isMDXComponent=!0;const p_r={toc:[]},r_r="wrapper";function s_r(e){let{components:n,...t}=e;return(0,s.yg)(r_r,(0,p.A)({},p_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}s_r.isMDXComponent=!0;const c_r={toc:[]},a_r="wrapper";function i_r(e){let{components:n,...t}=e;return(0,s.yg)(a_r,(0,p.A)({},c_r,t,{components:n,mdxType:"MDXLayout"}))}i_r.isMDXComponent=!0;const l_r={toc:[]},u_r="wrapper";function m_r(e){let{components:n,...t}=e;return(0,s.yg)(u_r,(0,p.A)({},l_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}m_r.isMDXComponent=!0;const y_r={toc:[]},d_r="wrapper";function h_r(e){let{components:n,...t}=e;return(0,s.yg)(d_r,(0,p.A)({},y_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}h_r.isMDXComponent=!0;const g_r={toc:[]},f_r="wrapper";function D_r(e){let{components:n,...t}=e;return(0,s.yg)(f_r,(0,p.A)({},g_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}D_r.isMDXComponent=!0;const M_r={toc:[]},X_r="wrapper";function __r(e){let{components:n,...t}=e;return(0,s.yg)(X_r,(0,p.A)({},M_r,t,{components:n,mdxType:"MDXLayout"}))}__r.isMDXComponent=!0;const w_r={toc:[]},T_r="wrapper";function C_r(e){let{components:n,...t}=e;return(0,s.yg)(T_r,(0,p.A)({},w_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}C_r.isMDXComponent=!0;const x_r={toc:[]},A_r="wrapper";function v_r(e){let{components:n,...t}=e;return(0,s.yg)(A_r,(0,p.A)({},x_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}v_r.isMDXComponent=!0;const L_r={toc:[]},b_r="wrapper";function N_r(e){let{components:n,...t}=e;return(0,s.yg)(b_r,(0,p.A)({},L_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}N_r.isMDXComponent=!0;const k_r={toc:[]},z_r="wrapper";function P_r(e){let{components:n,...t}=e;return(0,s.yg)(z_r,(0,p.A)({},k_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}P_r.isMDXComponent=!0;const I_r={toc:[]},R_r="wrapper";function W_r(e){let{components:n,...t}=e;return(0,s.yg)(R_r,(0,p.A)({},I_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}W_r.isMDXComponent=!0;const S_r={toc:[]},B_r="wrapper";function G_r(e){let{components:n,...t}=e;return(0,s.yg)(B_r,(0,p.A)({},S_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}G_r.isMDXComponent=!0;const E_r={toc:[]},O_r="wrapper";function U_r(e){let{components:n,...t}=e;return(0,s.yg)(O_r,(0,p.A)({},E_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}U_r.isMDXComponent=!0;const F_r={toc:[]},V_r="wrapper";function q_r(e){let{components:n,...t}=e;return(0,s.yg)(V_r,(0,p.A)({},F_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}q_r.isMDXComponent=!0;const j_r={toc:[]},H_r="wrapper";function Y_r(e){let{components:n,...t}=e;return(0,s.yg)(H_r,(0,p.A)({},j_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Y_r.isMDXComponent=!0;const Q_r={toc:[]},$_r="wrapper";function K_r(e){let{components:n,...t}=e;return(0,s.yg)($_r,(0,p.A)({},Q_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}K_r.isMDXComponent=!0;const J_r={toc:[]},Z_r="wrapper";function ewr(e){let{components:n,...t}=e;return(0,s.yg)(Z_r,(0,p.A)({},J_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ewr.isMDXComponent=!0;const nwr={toc:[]},twr="wrapper";function owr(e){let{components:n,...t}=e;return(0,s.yg)(twr,(0,p.A)({},nwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}owr.isMDXComponent=!0;const pwr={toc:[]},rwr="wrapper";function swr(e){let{components:n,...t}=e;return(0,s.yg)(rwr,(0,p.A)({},pwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}swr.isMDXComponent=!0;const cwr={toc:[]},awr="wrapper";function iwr(e){let{components:n,...t}=e;return(0,s.yg)(awr,(0,p.A)({},cwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given t value."))}iwr.isMDXComponent=!0;const lwr={toc:[]},uwr="wrapper";function mwr(e){let{components:n,...t}=e;return(0,s.yg)(uwr,(0,p.A)({},lwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}mwr.isMDXComponent=!0;const ywr={toc:[]},dwr="wrapper";function hwr(e){let{components:n,...t}=e;return(0,s.yg)(dwr,(0,p.A)({},ywr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}hwr.isMDXComponent=!0;const gwr={toc:[]},fwr="wrapper";function Dwr(e){let{components:n,...t}=e;return(0,s.yg)(fwr,(0,p.A)({},gwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}Dwr.isMDXComponent=!0;const Mwr={toc:[]},Xwr="wrapper";function _wr(e){let{components:n,...t}=e;return(0,s.yg)(Xwr,(0,p.A)({},Mwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.yg)("p",null,"Source code liberally taken from:\n",(0,s.yg)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}_wr.isMDXComponent=!0;const wwr={toc:[]},Twr="wrapper";function Cwr(e){let{components:n,...t}=e;return(0,s.yg)(Twr,(0,p.A)({},wwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Cwr.isMDXComponent=!0;const xwr={toc:[]},Awr="wrapper";function vwr(e){let{components:n,...t}=e;return(0,s.yg)(Awr,(0,p.A)({},xwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}vwr.isMDXComponent=!0;const Lwr={toc:[]},bwr="wrapper";function Nwr(e){let{components:n,...t}=e;return(0,s.yg)(bwr,(0,p.A)({},Lwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}Nwr.isMDXComponent=!0;const kwr={toc:[]},zwr="wrapper";function Pwr(e){let{components:n,...t}=e;return(0,s.yg)(zwr,(0,p.A)({},kwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Pwr.isMDXComponent=!0;const Iwr={toc:[]},Rwr="wrapper";function Wwr(e){let{components:n,...t}=e;return(0,s.yg)(Rwr,(0,p.A)({},Iwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}Wwr.isMDXComponent=!0;const Swr={toc:[]},Bwr="wrapper";function Gwr(e){let{components:n,...t}=e;return(0,s.yg)(Bwr,(0,p.A)({},Swr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}Gwr.isMDXComponent=!0;const Ewr={toc:[]},Owr="wrapper";function Uwr(e){let{components:n,...t}=e;return(0,s.yg)(Owr,(0,p.A)({},Ewr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Uwr.isMDXComponent=!0;const Fwr={toc:[]},Vwr="wrapper";function qwr(e){let{components:n,...t}=e;return(0,s.yg)(Vwr,(0,p.A)({},Fwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}qwr.isMDXComponent=!0;const jwr={toc:[]},Hwr="wrapper";function Ywr(e){let{components:n,...t}=e;return(0,s.yg)(Hwr,(0,p.A)({},jwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}Ywr.isMDXComponent=!0;const Qwr={toc:[]},$wr="wrapper";function Kwr(e){let{components:n,...t}=e;return(0,s.yg)($wr,(0,p.A)({},Qwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The cubic coefficient"))}Kwr.isMDXComponent=!0;const Jwr={toc:[]},Zwr="wrapper";function eTr(e){let{components:n,...t}=e;return(0,s.yg)(Zwr,(0,p.A)({},Jwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The degree of the polynomial"))}eTr.isMDXComponent=!0;const nTr={toc:[]},tTr="wrapper";function oTr(e){let{components:n,...t}=e;return(0,s.yg)(tTr,(0,p.A)({},nTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the nth derivative of the polynomial."))}oTr.isMDXComponent=!0;const pTr={toc:[]},rTr="wrapper";function sTr(e){let{components:n,...t}=e;return(0,s.yg)(rTr,(0,p.A)({},pTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of times to differentiate the polynomial."))}sTr.isMDXComponent=!0;const cTr={toc:[]},aTr="wrapper";function iTr(e){let{components:n,...t}=e;return(0,s.yg)(aTr,(0,p.A)({},cTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given value t."))}iTr.isMDXComponent=!0;const lTr={toc:[]},uTr="wrapper";function mTr(e){let{components:n,...t}=e;return(0,s.yg)(uTr,(0,p.A)({},lTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to sample at"))}mTr.isMDXComponent=!0;const yTr={toc:[]},dTr="wrapper";function hTr(e){let{components:n,...t}=e;return(0,s.yg)(dTr,(0,p.A)({},yTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}hTr.isMDXComponent=!0;const gTr={toc:[]},fTr="wrapper";function DTr(e){let{components:n,...t}=e;return(0,s.yg)(fTr,(0,p.A)({},gTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to sample at"))}DTr.isMDXComponent=!0;const MTr={toc:[]},XTr="wrapper";function _Tr(e){let{components:n,...t}=e;return(0,s.yg)(XTr,(0,p.A)({},MTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The derivative of the polynomial to sample from"))}_Tr.isMDXComponent=!0;const wTr={toc:[]},TTr="wrapper";function CTr(e){let{components:n,...t}=e;return(0,s.yg)(TTr,(0,p.A)({},wTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the local extrema of the polynomial."))}CTr.isMDXComponent=!0;const xTr={toc:[]},ATr="wrapper";function vTr(e){let{components:n,...t}=e;return(0,s.yg)(ATr,(0,p.A)({},xTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}vTr.isMDXComponent=!0;const LTr={toc:[]},bTr="wrapper";function NTr(e){let{components:n,...t}=e;return(0,s.yg)(bTr,(0,p.A)({},LTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the output value range within the unit interval."))}NTr.isMDXComponent=!0;const kTr={toc:[]},zTr="wrapper";function PTr(e){let{components:n,...t}=e;return(0,s.yg)(zTr,(0,p.A)({},kTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}PTr.isMDXComponent=!0;const ITr={toc:[]},RTr="wrapper";function WTr(e){let{components:n,...t}=e;return(0,s.yg)(RTr,(0,p.A)({},ITr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the roots (values where this polynomial = 0)."))}WTr.isMDXComponent=!0;const STr={toc:[]},BTr="wrapper";function GTr(e){let{components:n,...t}=e;return(0,s.yg)(BTr,(0,p.A)({},STr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}GTr.isMDXComponent=!0;const ETr={toc:[]},OTr="wrapper";function UTr(e){let{components:n,...t}=e;return(0,s.yg)(OTr,(0,p.A)({},ETr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The point at which to split the polynomial."))}UTr.isMDXComponent=!0;const FTr={toc:[]},VTr="wrapper";function qTr(e){let{components:n,...t}=e;return(0,s.yg)(VTr,(0,p.A)({},FTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a constant polynomial"))}qTr.isMDXComponent=!0;const jTr={toc:[]},HTr="wrapper";function YTr(e){let{components:n,...t}=e;return(0,s.yg)(HTr,(0,p.A)({},jTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}YTr.isMDXComponent=!0;const QTr={toc:[]},$Tr="wrapper";function KTr(e){let{components:n,...t}=e;return(0,s.yg)($Tr,(0,p.A)({},QTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a cubic polynomial"))}KTr.isMDXComponent=!0;const JTr={toc:[]},ZTr="wrapper";function eCr(e){let{components:n,...t}=e;return(0,s.yg)(ZTr,(0,p.A)({},JTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}eCr.isMDXComponent=!0;const nCr={toc:[]},tCr="wrapper";function oCr(e){let{components:n,...t}=e;return(0,s.yg)(tCr,(0,p.A)({},nCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}oCr.isMDXComponent=!0;const pCr={toc:[]},rCr="wrapper";function sCr(e){let{components:n,...t}=e;return(0,s.yg)(rCr,(0,p.A)({},pCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}sCr.isMDXComponent=!0;const cCr={toc:[]},aCr="wrapper";function iCr(e){let{components:n,...t}=e;return(0,s.yg)(aCr,(0,p.A)({},cCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The cubic coefficient"))}iCr.isMDXComponent=!0;const lCr={toc:[]},uCr="wrapper";function mCr(e){let{components:n,...t}=e;return(0,s.yg)(uCr,(0,p.A)({},lCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a linear polynomial"))}mCr.isMDXComponent=!0;const yCr={toc:[]},dCr="wrapper";function hCr(e){let{components:n,...t}=e;return(0,s.yg)(dCr,(0,p.A)({},yCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}hCr.isMDXComponent=!0;const gCr={toc:[]},fCr="wrapper";function DCr(e){let{components:n,...t}=e;return(0,s.yg)(fCr,(0,p.A)({},gCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}DCr.isMDXComponent=!0;const MCr={toc:[]},XCr="wrapper";function _Cr(e){let{components:n,...t}=e;return(0,s.yg)(XCr,(0,p.A)({},MCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a quadratic polynomial"))}_Cr.isMDXComponent=!0;const wCr={toc:[]},TCr="wrapper";function CCr(e){let{components:n,...t}=e;return(0,s.yg)(TCr,(0,p.A)({},wCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}CCr.isMDXComponent=!0;const xCr={toc:[]},ACr="wrapper";function vCr(e){let{components:n,...t}=e;return(0,s.yg)(ACr,(0,p.A)({},xCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}vCr.isMDXComponent=!0;const LCr={toc:[]},bCr="wrapper";function NCr(e){let{components:n,...t}=e;return(0,s.yg)(bCr,(0,p.A)({},LCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}NCr.isMDXComponent=!0;const kCr={toc:[]},zCr="wrapper";function PCr(e){let{components:n,...t}=e;return(0,s.yg)(zCr,(0,p.A)({},kCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}PCr.isMDXComponent=!0;const ICr={toc:[]},RCr="wrapper";function WCr(e){let{components:n,...t}=e;return(0,s.yg)(RCr,(0,p.A)({},ICr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}WCr.isMDXComponent=!0;const SCr={toc:[]},BCr="wrapper";function GCr(e){let{components:n,...t}=e;return(0,s.yg)(BCr,(0,p.A)({},SCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given t value."))}GCr.isMDXComponent=!0;const ECr={toc:[]},OCr="wrapper";function UCr(e){let{components:n,...t}=e;return(0,s.yg)(OCr,(0,p.A)({},ECr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}UCr.isMDXComponent=!0;const FCr={toc:[]},VCr="wrapper";function qCr(e){let{components:n,...t}=e;return(0,s.yg)(VCr,(0,p.A)({},FCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}qCr.isMDXComponent=!0;const jCr={toc:[]},HCr="wrapper";function YCr(e){let{components:n,...t}=e;return(0,s.yg)(HCr,(0,p.A)({},jCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}YCr.isMDXComponent=!0;const QCr={toc:[]},$Cr="wrapper";function KCr(e){let{components:n,...t}=e;return(0,s.yg)($Cr,(0,p.A)({},QCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.yg)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}KCr.isMDXComponent=!0;const JCr={toc:[]},ZCr="wrapper";function exr(e){let{components:n,...t}=e;return(0,s.yg)(ZCr,(0,p.A)({},JCr,t,{components:n,mdxType:"MDXLayout"}))}exr.isMDXComponent=!0;const nxr={toc:[]},txr="wrapper";function oxr(e){let{components:n,...t}=e;return(0,s.yg)(txr,(0,p.A)({},nxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}oxr.isMDXComponent=!0;const pxr={toc:[]},rxr="wrapper";function sxr(e){let{components:n,...t}=e;return(0,s.yg)(rxr,(0,p.A)({},pxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots defining the spline"))}sxr.isMDXComponent=!0;const cxr={toc:[]},axr="wrapper";function ixr(e){let{components:n,...t}=e;return(0,s.yg)(axr,(0,p.A)({},cxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the spline should be closed or not"))}ixr.isMDXComponent=!0;const lxr={toc:[]},uxr="wrapper";function mxr(e){let{components:n,...t}=e;return(0,s.yg)(uxr,(0,p.A)({},lxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}mxr.isMDXComponent=!0;const yxr={toc:[]},dxr="wrapper";function hxr(e){let{components:n,...t}=e;return(0,s.yg)(dxr,(0,p.A)({},yxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}hxr.isMDXComponent=!0;const gxr={toc:[]},fxr="wrapper";function Dxr(e){let{components:n,...t}=e;return(0,s.yg)(fxr,(0,p.A)({},gxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}Dxr.isMDXComponent=!0;const Mxr={toc:[]},Xxr="wrapper";function _xr(e){let{components:n,...t}=e;return(0,s.yg)(Xxr,(0,p.A)({},Mxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}_xr.isMDXComponent=!0;const wxr={toc:[]},Txr="wrapper";function Cxr(e){let{components:n,...t}=e;return(0,s.yg)(Txr,(0,p.A)({},wxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}Cxr.isMDXComponent=!0;const xxr={toc:[]},Axr="wrapper";function vxr(e){let{components:n,...t}=e;return(0,s.yg)(Axr,(0,p.A)({},xxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}vxr.isMDXComponent=!0;const Lxr={toc:[]},bxr="wrapper";function Nxr(e){let{components:n,...t}=e;return(0,s.yg)(bxr,(0,p.A)({},Lxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Nxr.isMDXComponent=!0;const kxr={toc:[]},zxr="wrapper";function Pxr(e){let{components:n,...t}=e;return(0,s.yg)(zxr,(0,p.A)({},kxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}Pxr.isMDXComponent=!0;const Ixr={toc:[]},Rxr="wrapper";function Wxr(e){let{components:n,...t}=e;return(0,s.yg)(Rxr,(0,p.A)({},Ixr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Wxr.isMDXComponent=!0;const Sxr={toc:[]},Bxr="wrapper";function Gxr(e){let{components:n,...t}=e;return(0,s.yg)(Bxr,(0,p.A)({},Sxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}Gxr.isMDXComponent=!0;const Exr={toc:[]},Oxr="wrapper";function Uxr(e){let{components:n,...t}=e;return(0,s.yg)(Oxr,(0,p.A)({},Exr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Uxr.isMDXComponent=!0;const Fxr={toc:[]},Vxr="wrapper";function qxr(e){let{components:n,...t}=e;return(0,s.yg)(Vxr,(0,p.A)({},Fxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}qxr.isMDXComponent=!0;const jxr={toc:[]},Hxr="wrapper";function Yxr(e){let{components:n,...t}=e;return(0,s.yg)(Hxr,(0,p.A)({},jxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}Yxr.isMDXComponent=!0;const Qxr={toc:[]},$xr="wrapper";function Kxr(e){let{components:n,...t}=e;return(0,s.yg)($xr,(0,p.A)({},Qxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.yg)("p",null,"By default, any property is cloneable."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Kxr.isMDXComponent=!0;const Jxr={toc:[]},Zxr="wrapper";function eAr(e){let{components:n,...t}=e;return(0,s.yg)(Zxr,(0,p.A)({},Jxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}eAr.isMDXComponent=!0;const nAr={toc:[]},tAr="wrapper";function oAr(e){let{components:n,...t}=e;return(0,s.yg)(tAr,(0,p.A)({},nAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a cloneable property decorator."))}oAr.isMDXComponent=!0;const pAr={toc:[]},rAr="wrapper";function sAr(e){let{components:n,...t}=e;return(0,s.yg)(rAr,(0,p.A)({},pAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the property should be cloneable."))}sAr.isMDXComponent=!0;const cAr={toc:[]},aAr="wrapper";function iAr(e){let{components:n,...t}=e;return(0,s.yg)(aAr,(0,p.A)({},cAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}iAr.isMDXComponent=!0;const lAr={toc:[]},uAr="wrapper";function mAr(e){let{components:n,...t}=e;return(0,s.yg)(uAr,(0,p.A)({},lAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}mAr.isMDXComponent=!0;const yAr={toc:[]},dAr="wrapper";function hAr(e){let{components:n,...t}=e;return(0,s.yg)(dAr,(0,p.A)({},yAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a compound property decorator."))}hAr.isMDXComponent=!0;const gAr={toc:[]},fAr="wrapper";function DAr(e){let{components:n,...t}=e;return(0,s.yg)(fAr,(0,p.A)({},gAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}DAr.isMDXComponent=!0;const MAr={toc:[]},XAr="wrapper";function _Ar(e){let{components:n,...t}=e;return(0,s.yg)(XAr,(0,p.A)({},MAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.yg)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}_Ar.isMDXComponent=!0;const wAr={toc:[]},TAr="wrapper";function CAr(e){let{components:n,...t}=e;return(0,s.yg)(TAr,(0,p.A)({},wAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a computed method decorator."))}CAr.isMDXComponent=!0;const xAr={toc:[]},AAr="wrapper";function vAr(e){let{components:n,...t}=e;return(0,s.yg)(AAr,(0,p.A)({},xAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the initial value of a property."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}vAr.isMDXComponent=!0;const LAr={toc:[]},bAr="wrapper";function NAr(e){let{components:n,...t}=e;return(0,s.yg)(bAr,(0,p.A)({},LAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}NAr.isMDXComponent=!0;const kAr={toc:[]},zAr="wrapper";function PAr(e){let{components:n,...t}=e;return(0,s.yg)(zAr,(0,p.A)({},kAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an initial signal value decorator."))}PAr.isMDXComponent=!0;const IAr={toc:[]},RAr="wrapper";function WAr(e){let{components:n,...t}=e;return(0,s.yg)(RAr,(0,p.A)({},IAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of the property."))}WAr.isMDXComponent=!0;const SAr={toc:[]},BAr="wrapper";function GAr(e){let{components:n,...t}=e;return(0,s.yg)(BAr,(0,p.A)({},SAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.yg)("p",null,"By default, any property is inspectable."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}GAr.isMDXComponent=!0;const EAr={toc:[]},OAr="wrapper";function UAr(e){let{components:n,...t}=e;return(0,s.yg)(OAr,(0,p.A)({},EAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}UAr.isMDXComponent=!0;const FAr={toc:[]},VAr="wrapper";function qAr(e){let{components:n,...t}=e;return(0,s.yg)(VAr,(0,p.A)({},FAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an inspectable property decorator."))}qAr.isMDXComponent=!0;const jAr={toc:[]},HAr="wrapper";function YAr(e){let{components:n,...t}=e;return(0,s.yg)(HAr,(0,p.A)({},jAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the property should be inspectable."))}YAr.isMDXComponent=!0;const QAr={toc:[]},$Ar="wrapper";function KAr(e){let{components:n,...t}=e;return(0,s.yg)($Ar,(0,p.A)({},QAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}KAr.isMDXComponent=!0;const JAr={toc:[]},ZAr="wrapper";function evr(e){let{components:n,...t}=e;return(0,s.yg)(ZAr,(0,p.A)({},JAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}evr.isMDXComponent=!0;const nvr={toc:[]},tvr="wrapper";function ovr(e){let{components:n,...t}=e;return(0,s.yg)(tvr,(0,p.A)({},nvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal interpolation function decorator."))}ovr.isMDXComponent=!0;const pvr={toc:[]},rvr="wrapper";function svr(e){let{components:n,...t}=e;return(0,s.yg)(rvr,(0,p.A)({},pvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interpolation function for the property."))}svr.isMDXComponent=!0;const cvr={toc:[]},avr="wrapper";function ivr(e){let{components:n,...t}=e;return(0,s.yg)(avr,(0,p.A)({},cvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.yg)("p",null,"If the wrapper class has a method called ",(0,s.yg)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}ivr.isMDXComponent=!0;const lvr={toc:[]},uvr="wrapper";function mvr(e){let{components:n,...t}=e;return(0,s.yg)(uvr,(0,p.A)({},lvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}mvr.isMDXComponent=!0;const yvr={toc:[]},dvr="wrapper";function hvr(e){let{components:n,...t}=e;return(0,s.yg)(dvr,(0,p.A)({},yvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal parser decorator."))}hvr.isMDXComponent=!0;const gvr={toc:[]},fvr="wrapper";function Dvr(e){let{components:n,...t}=e;return(0,s.yg)(fvr,(0,p.A)({},gvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The wrapper class for the property."))}Dvr.isMDXComponent=!0;const Mvr={toc:[]},Xvr="wrapper";function _vr(e){let{components:n,...t}=e;return(0,s.yg)(Xvr,(0,p.A)({},Mvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns the given property into a signal."),(0,s.yg)("p",null,"The class using this decorator can implement the following methods:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}_vr.isMDXComponent=!0;const wvr={toc:[]},Tvr="wrapper";function Cvr(e){let{components:n,...t}=e;return(0,s.yg)(Tvr,(0,p.A)({},wvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Cvr.isMDXComponent=!0;const xvr={toc:[]},Avr="wrapper";function vvr(e){let{components:n,...t}=e;return(0,s.yg)(Avr,(0,p.A)({},xvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal decorator."))}vvr.isMDXComponent=!0;const Lvr={toc:[]},bvr="wrapper";function Nvr(e){let{components:n,...t}=e;return(0,s.yg)(bvr,(0,p.A)({},Lvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut decorator for setting both the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.yg)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.yg)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.yg)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.yg)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Nvr.isMDXComponent=!0;const kvr={toc:[]},zvr="wrapper";function Pvr(e){let{components:n,...t}=e;return(0,s.yg)(zvr,(0,p.A)({},kvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Pvr.isMDXComponent=!0;const Ivr={toc:[]},Rvr="wrapper";function Wvr(e){let{components:n,...t}=e;return(0,s.yg)(Rvr,(0,p.A)({},Ivr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal wrapper decorator."))}Wvr.isMDXComponent=!0;const Svr={toc:[]},Bvr="wrapper";function Gvr(e){let{components:n,...t}=e;return(0,s.yg)(Bvr,(0,p.A)({},Svr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The wrapper class for the property."))}Gvr.isMDXComponent=!0;const Evr={toc:[]},Ovr="wrapper";function Uvr(e){let{components:n,...t}=e;return(0,s.yg)(Ovr,(0,p.A)({},Evr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A unified abstraction for all CSS filters."))}Uvr.isMDXComponent=!0;const Fvr={toc:[]},Vvr="wrapper";function qvr(e){let{components:n,...t}=e;return(0,s.yg)(Vvr,(0,p.A)({},Fvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the desired length is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}qvr.isMDXComponent=!0;const jvr={toc:[]},Hvr="wrapper";function Yvr(e){let{components:n,...t}=e;return(0,s.yg)(Hvr,(0,p.A)({},jvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a desired length used internally by layout Nodes."))}Yvr.isMDXComponent=!0;const Qvr={toc:[]},$vr="wrapper";function Kvr(e){let{components:n,...t}=e;return(0,s.yg)($vr,(0,p.A)({},Qvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value can be either:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'"))))}Kvr.isMDXComponent=!0;const Jvr={toc:[]},Zvr="wrapper";function eLr(e){let{components:n,...t}=e;return(0,s.yg)(Zvr,(0,p.A)({},Jvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a length used by most layout properties."))}eLr.isMDXComponent=!0;const nLr={toc:[]},tLr="wrapper";function oLr(e){let{components:n,...t}=e;return(0,s.yg)(tLr,(0,p.A)({},nLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a length limit used by layout properties such as ",(0,s.yg)("inlineCode",{parentName:"p"},"max-width"),"."))}oLr.isMDXComponent=!0;const pLr={toc:[]},rLr="wrapper";function sLr(e){let{components:n,...t}=e;return(0,s.yg)(rLr,(0,p.A)({},pLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.yg)("inlineCode",{parentName:"a"},"blur"))," filter."))}sLr.isMDXComponent=!0;const cLr={toc:[]},aLr="wrapper";function iLr(e){let{components:n,...t}=e;return(0,s.yg)(aLr,(0,p.A)({},cLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter in pixels."))}iLr.isMDXComponent=!0;const lLr={toc:[]},uLr="wrapper";function mLr(e){let{components:n,...t}=e;return(0,s.yg)(uLr,(0,p.A)({},lLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.yg)("inlineCode",{parentName:"a"},"brightness"))," filter."))}mLr.isMDXComponent=!0;const yLr={toc:[]},dLr="wrapper";function hLr(e){let{components:n,...t}=e;return(0,s.yg)(dLr,(0,p.A)({},yLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}hLr.isMDXComponent=!0;const gLr={toc:[]},fLr="wrapper";function DLr(e){let{components:n,...t}=e;return(0,s.yg)(fLr,(0,p.A)({},gLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.yg)("inlineCode",{parentName:"a"},"contrast"))," filter."))}DLr.isMDXComponent=!0;const MLr={toc:[]},XLr="wrapper";function _Lr(e){let{components:n,...t}=e;return(0,s.yg)(XLr,(0,p.A)({},MLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}_Lr.isMDXComponent=!0;const wLr={toc:[]},TLr="wrapper";function CLr(e){let{components:n,...t}=e;return(0,s.yg)(TLr,(0,p.A)({},wLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.yg)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}CLr.isMDXComponent=!0;const xLr={toc:[]},ALr="wrapper";function vLr(e){let{components:n,...t}=e;return(0,s.yg)(ALr,(0,p.A)({},xLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}vLr.isMDXComponent=!0;const LLr={toc:[]},bLr="wrapper";function NLr(e){let{components:n,...t}=e;return(0,s.yg)(bLr,(0,p.A)({},LLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.yg)("inlineCode",{parentName:"a"},"hue"))," filter."))}NLr.isMDXComponent=!0;const kLr={toc:[]},zLr="wrapper";function PLr(e){let{components:n,...t}=e;return(0,s.yg)(zLr,(0,p.A)({},kLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter in degrees."))}PLr.isMDXComponent=!0;const ILr={toc:[]},RLr="wrapper";function WLr(e){let{components:n,...t}=e;return(0,s.yg)(RLr,(0,p.A)({},ILr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.yg)("inlineCode",{parentName:"a"},"invert"))," filter."))}WLr.isMDXComponent=!0;const SLr={toc:[]},BLr="wrapper";function GLr(e){let{components:n,...t}=e;return(0,s.yg)(BLr,(0,p.A)({},SLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}GLr.isMDXComponent=!0;const ELr={toc:[]},OLr="wrapper";function ULr(e){let{components:n,...t}=e;return(0,s.yg)(OLr,(0,p.A)({},ELr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.yg)("inlineCode",{parentName:"a"},"saturate"))," filter."))}ULr.isMDXComponent=!0;const FLr={toc:[]},VLr="wrapper";function qLr(e){let{components:n,...t}=e;return(0,s.yg)(VLr,(0,p.A)({},FLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}qLr.isMDXComponent=!0;const jLr={toc:[]},HLr="wrapper";function YLr(e){let{components:n,...t}=e;return(0,s.yg)(HLr,(0,p.A)({},jLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.yg)("inlineCode",{parentName:"a"},"sepia"))," filter."))}YLr.isMDXComponent=!0;const QLr={toc:[]},$Lr="wrapper";function KLr(e){let{components:n,...t}=e;return(0,s.yg)($Lr,(0,p.A)({},QLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}KLr.isMDXComponent=!0;const JLr={toc:[]},ZLr="wrapper";function ebr(e){let{components:n,...t}=e;return(0,s.yg)(ZLr,(0,p.A)({},JLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}ebr.isMDXComponent=!0;const nbr={toc:[]},tbr="wrapper";function obr(e){let{components:n,...t}=e;return(0,s.yg)(tbr,(0,p.A)({},nbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback in the context of this scene."))}obr.isMDXComponent=!0;const pbr={toc:[]},rbr="wrapper";function sbr(e){let{components:n,...t}=e;return(0,s.yg)(rbr,(0,p.A)({},pbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}sbr.isMDXComponent=!0;const cbr={toc:[]},abr="wrapper";function ibr(e){let{components:n,...t}=e;return(0,s.yg)(abr,(0,p.A)({},cbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the view."),(0,s.yg)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.yg)("p",null,"Can modify the state of the view."))}ibr.isMDXComponent=!0;const lbr={toc:[]},ubr="wrapper";function mbr(e){let{components:n,...t}=e;return(0,s.yg)(ubr,(0,p.A)({},lbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a predicate that checks if the given object is an instance of the\ngiven class."))}mbr.isMDXComponent=!0;const ybr={toc:[]},dbr="wrapper";function hbr(e){let{components:n,...t}=e;return(0,s.yg)(dbr,(0,p.A)({},ybr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class to check against."))}function gbr(e){let{id:n}=e;const t=o[n]??r.Fragment;return r.createElement(t,null)}hbr.isMDXComponent=!0},5063:(e,n,t)=>{t.d(n,{A:()=>i});var o=t(6476),p=t(6048),r=t(7576),s=t(53),c=t(4041);const a={toggle:"toggle_S_IX",collapsed:"collapsed_wdUB",collapse:"collapse_TjTN",inverse:"inverse_g6vW",clearFix:"clearFix_HQ1T"};function i(e){let{comment:n,full:t=!0}=e;const o=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@remarks"===n}))),[n]);return c.createElement(c.Fragment,null,t&&c.createElement(l,{comment:n}),c.createElement(p.A,{id:n?.summaryId}),c.createElement(p.A,{id:o?.contentId}),t&&c.createElement(u,{comment:n}))}function l(e){let{comment:n}=e;return(0,c.useMemo)((()=>n?.modifierTags?.includes("@experimental")),[n])?c.createElement(r.A,null):null}function u(e){let{comment:n}=e;const[t,r]=(0,c.useState)(!0),i=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@preview"===n}))),[n]),l=(0,c.useMemo)((()=>n?.blockTags?.filter((e=>{let{tag:n}=e;return"@example"===n}))??[]),[n]),u=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@defaultValue"===n}))),[n]),m=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@deprecated"===n}))),[n]),y=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@see"===n}))),[n]);return c.createElement(c.Fragment,null,c.createElement(p.A,{id:i?.contentId}),l.length>0&&c.createElement(c.Fragment,null,c.createElement("h4",null,c.createElement("a",{className:(0,s.A)(a.toggle,t&&a.collapsed),onClick:e=>{e.preventDefault(),r(!t)},href:"#"},"Examples")),c.createElement(o.N,{lazy:!0,as:"div",collapsed:t},c.createElement("div",{className:a.collapse},l.map((e=>c.createElement(p.A,{key:e.contentId,id:e.contentId})))),c.createElement("div",{className:a.clearFix})),c.createElement("div",{className:(0,s.A)(a.clearFix,a.inverse)})),u&&c.createElement(c.Fragment,null,"Default Value:"," ",c.createElement("code",null,u.content.map((e=>e.text)).join(""))),m&&c.createElement(c.Fragment,null,c.createElement("h4",null,"Deprecated"),c.createElement(p.A,{id:m.contentId})),y&&c.createElement(c.Fragment,null,c.createElement("h4",null,"See also"),c.createElement(p.A,{id:y.contentId})))}},1125:(e,n,t)=>{t.d(n,{A:()=>Be});var o=t(1282),p=t(4905),r=t(9575),s=t(4041);function c(e){let{width:n=24,height:t=24,...o}=e;return s.createElement("svg",(0,r.A)({width:n,height:t,"aria-hidden":"true",viewBox:"0 0 24 24"},o),s.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=t(4593),l=t(53);function u(e){let{children:n,highlight:t,onClick:r,link:u}=e;const m=(0,p.f)(),y=(0,i.o0)();return s.createElement("div",{className:(0,l.A)(o.A.codeBlockContent,a.codeBlock,t&&a.highlight,r&&a.pointer)},s.createElement("pre",{onClick:r,onKeyDown:e=>{"Enter"===e.key&&r?.()},tabIndex:0,ref:m.codeBlockRef,className:(0,l.A)(o.A.codeBlock,"thin-scrollbar")},s.createElement("code",{className:o.A.codeBlockLines,style:y},n)),u&&s.createElement("div",{className:o.A.buttonGroup},s.createElement("button",{title:"Go to source",className:"clean-btn",onClick:e=>{e.preventDefault(),window.open(u,"_blank")}},s.createElement(c,{width:18,height:18}))))}var m=t(6333);function y(e){let{children:n}=e;return s.createElement(m.A,{as:"div",className:(0,l.A)(a.codeBlockContainer,"language-typescript")},n)}function d(e){let{children:n}=e;const t=(0,s.useRef)();return(0,s.useLayoutEffect)((()=>{if(!t.current)return;const e=t.current.closest("pre");if(e.scrollWidth>e.clientWidth){const n=Array.from(t.current.querySelectorAll(`.${a.elements}`)).sort(((e,n)=>function(e,n){return e>n?1:e<n?-1:0}(n.innerText.length,e.innerText.length)));for(;e.scrollWidth>e.clientWidth&&n.length>0;)n.shift().classList.add(a.wrap)}})),s.createElement(s.Fragment,null,n&&s.createElement("span",{ref:t,className:(0,l.A)(a.line,"token-line")},n),s.createElement("br",null))}var h=t(5063),g=t(9659);function f(e){let{width:n=24,height:t=24,...o}=e;return s.createElement("svg",(0,r.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0},o),s.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}var D=t(6382);const M={header:"header_nSmr",filters:"filters_z1iC",icon:"icon_ROIU"};function X(){const e=(0,s.useRef)(null),[n,t]=(0,s.useState)(!1),[o,p]=(0,D.R7)();return(0,s.useEffect)((()=>{const n=n=>{e.current&&!e.current.contains(n.target)&&t(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[e]),s.createElement(s.Fragment,null,s.createElement("div",{ref:e,className:(0,l.A)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},s.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:e=>{e.preventDefault(),t(!n)},onKeyDown:e=>{"Enter"===e.key&&(e.preventDefault(),t(!n))}},"Filters",s.createElement(f,{className:M.icon})),s.createElement("ul",{className:"dropdown__menu"},s.createElement("li",null,s.createElement("label",{htmlFor:"private",className:(0,l.A)("dropdown__link",o.private&&"dropdown__link--active")},s.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:o.private,onChange:e=>{p({...o,private:e.target.checked})}}),"Protected members")),s.createElement("li",{onKeyDown:e=>{"Tab"===e.key&&t(!1)}},s.createElement("label",{htmlFor:"inherited",className:(0,l.A)("dropdown__link",o.inherited&&"dropdown__link--active")},s.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:o.inherited,onChange:e=>{p({...o,inherited:e.target.checked})}}),"Inherited members")))))}function _(e){let{children:n,kind:t}=e;return t===g.k.Class||t===g.k.Interface?s.createElement("div",{className:(0,l.A)("row",M.header)},s.createElement("div",{className:(0,l.A)("col",M.filters)},s.createElement(X,null)),s.createElement("div",{className:"col"},n)):s.createElement(s.Fragment,null,n)}var w=t(6090),T=t(9631);function C(e){let{children:n,type:t,to:o,id:p,tooltip:c}=e;const a=(0,i.J2)(t);return o?s.createElement(T.A,(0,r.A)({id:p,to:o,"data-tooltip":c},a),n):s.createElement("span",(0,r.A)({id:p},a),n)}let x=function(e){return e[e.None=0]="None",e[e.Angle=1]="Angle",e[e.Curly=2]="Curly",e[e.Square=3]="Square",e[e.Parentheses=4]="Parentheses",e}({}),A=function(e){return e.Comma=", ",e.Pipe=" | ",e.Ampersand=" & ",e}({});const v={[x.None]:a.none,[x.Angle]:a.angle,[x.Curly]:a.curly,[x.Square]:a.square,[x.Parentheses]:a.parentheses};function L(e){let{children:n,type:t,separator:o=A.Comma}=e;return s.createElement("span",{className:(0,l.A)(a.list,v[t??x.None])},s.createElement("span",{className:(0,l.A)(a.elements,o!==A.Comma&&a.left)},(Array.isArray(n)?n:[n]).flatMap(((e,n)=>s.createElement("span",{"data-separator":o,key:n,className:a.element},e)))))}function b(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.elementType}),"[]")}function N(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.checkType}),s.createElement(C,{type:"keyword"}," extends "),s.createElement(oe,{type:n.extendsType})," ? ",s.createElement(oe,{type:n.trueType})," : ",s.createElement(oe,{type:n.falseType}))}function k(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.objectType}),"[",s.createElement(oe,{type:n.indexType}),"]")}function z(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"infer "),s.createElement(C,{type:"constant"},n.name))}function P(e){let{type:n}=e;return s.createElement(L,{type:x.Parentheses,separator:A.Ampersand},n.types.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))}function I(e){let{type:n}=e;return s.createElement(C,{type:"keyword"},n.name)}function R(e){let{type:n}=e;const[t,o]=(0,s.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return s.createElement(C,{type:o},t)}function W(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(L,{type:x.Curly},s.createElement(s.Fragment,null,"[",s.createElement(C,{type:"class"},n.parameter),s.createElement(C,{type:"keyword"}," in "),s.createElement(oe,{type:n.parameterType}),"]: ",s.createElement(oe,{type:n.templateType}))))}function S(e){let{type:n}=e;return s.createElement(s.Fragment,null,n.name,": ",s.createElement(oe,{type:n.element}))}function B(e){let{type:n}=e;return n.asserts?s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"asserts "),s.createElement(C,null,n.name," ")):s.createElement(s.Fragment,null,s.createElement(C,null,n.name," "),s.createElement(C,{type:"keyword"},"is "),s.createElement(oe,{type:n.targetType}))}function G(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"typeof "),s.createElement(oe,{type:n.queryType}))}function E(e){let{flags:n,explicitAccessModifier:t}=e;const o=[];return n?.isAbstract&&o.push("abstract"),n?.isStatic&&o.push("static"),n?.isConst&&o.push("const"),n?.isReadonly&&o.push("readonly"),n?.isPrivate&&o.push("private"),n?.isProtected&&o.push("protected"),(n?.isPublic||t&&!n?.isProtected&&!n?.isPrivate)&&o.push("public"),s.createElement(s.Fragment,null,o.map((e=>s.createElement(C,{key:e,type:"keyword"},e," "))))}function O(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),n.varianceModifier&&s.createElement(C,{type:"keyword"},n.varianceModifier," "),s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&s.createElement(s.Fragment,null," extends ",s.createElement(oe,{type:n.type})),n.default&&s.createElement(s.Fragment,null," = ",s.createElement(oe,{type:n.default})))}var U=t(8675);const F={[g.k.Namespace]:"namespace",[g.k.Enum]:"enum",[g.k.Class]:"class",[g.k.Interface]:"interface"};function V(e){let{reflection:n}=e;const t=(0,U.as)();return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),s.createElement(C,{type:"keyword"},F[n.kind]," "),s.createElement(C,{type:"class-name"},n.name),!!n.typeParameters?.length&&s.createElement(L,{type:x.Angle},n.typeParameters.map((e=>s.createElement(O,{key:e.id,reflection:t(e)}))))," ",!!n.extendedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"extends "),s.createElement(L,null,n.extendedTypes.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))),!!n.implementedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"implements "),s.createElement(L,null,n.implementedTypes.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))))}function q(e){let{reflection:n}=e;const t="__namedParameters"===n.name?"{...}":n.name;return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),n.flags.isRest&&"...",s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},t),n.flags.isOptional&&"?",": ",n.type&&s.createElement(oe,{type:n.type}),n.defaultValue&&s.createElement(s.Fragment,null," = ",s.createElement(C,{type:"plain"},n.defaultValue)))}function j(e){let{reflection:n,flags:t}=e;const o=(0,U.as)(),p="__type"===n.name;return s.createElement(s.Fragment,null,s.createElement(E,{flags:t??n.flags,explicitAccessModifier:!p}),n.kind===g.k.GetSignature&&s.createElement(C,{type:"keyword"},"get "),n.kind===g.k.SetSignature&&s.createElement(C,{type:"keyword"},"set "),n.overwrites&&s.createElement(s.Fragment,null,s.createElement(C,{to:n.overwrites.externalUrl??(0,U.ID)(o(n.overwrites.id)),type:"keyword"},"override")," "),n.kind===g.k.ConstructorSignature?s.createElement(s.Fragment,null,s.createElement(C,{to:"#",type:"keyword"},"new")," ",s.createElement(C,{type:"plain"},n.type.name)):p?"":s.createElement(C,{type:"function"},n.name),!!n.typeParameter?.length&&s.createElement(L,{type:x.Angle},n.typeParameter.map((e=>s.createElement(O,{key:e.id,reflection:o(e)})))),n.parameters?.length?s.createElement(L,{type:x.Parentheses},n.parameters.map((e=>s.createElement(q,{key:e,reflection:o(e)})))):"()",n.type&&s.createElement(s.Fragment,null,p?" => ":": ",s.createElement(oe,{type:n.type})))}function H(e){let{reflection:n}=e;const t=n.signatures?.[0]??n.getSignature??n.setSignature??n.indexSignature;return s.createElement(j,{reflection:t})}function Y(e){let{reflection:n}=e;return s.createElement(q,{reflection:n})}function Q(e){let{reflection:n}=e;const t=(0,U.as)();return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),s.createElement(C,{type:"keyword"},"type "),s.createElement(C,{type:"class-name"},n.name),n.typeParameters&&s.createElement(L,{type:x.Angle},n.typeParameters.map((e=>s.createElement(O,{key:e.id,reflection:t(e)}))))," = ",s.createElement(oe,{type:n.type}))}function $(e){let{reflection:n}=e;const t=(0,U.as)();if(n.signatures){let e=n.signatures[0];if(e?.kind||(e=t(e)),e)return s.createElement(j,{reflection:e})}return n.children?s.createElement(L,{type:x.Curly},n.children.map((e=>s.createElement(K,{key:e.id,reflection:t(e)})))):s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"unknown"))}function K(e){let{reflection:n}=e;const t=(0,s.useMemo)((()=>{switch(n.kind){case g.k.Project:case g.k.Module:case g.k.EnumMember:case g.k.Variable:case g.k.Function:break;case g.k.Namespace:case g.k.Enum:case g.k.Class:case g.k.Interface:return V;case g.k.Constructor:return j;case g.k.Property:return Y;case g.k.Method:return H;case g.k.CallSignature:case g.k.IndexSignature:case g.k.ConstructorSignature:case g.k.Parameter:break;case g.k.TypeLiteral:return $;case g.k.TypeParameter:return O;case g.k.Accessor:case g.k.GetSignature:case g.k.SetSignature:case g.k.ObjectLiteral:break;case g.k.TypeAlias:return Q;case g.k.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return s.createElement(t,{reflection:n})}function J(e){let{type:n}=e;const t=(0,U.as)();return s.createElement(K,{reflection:t(n.declaration)})}function Z(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"string"},"`",n.head),n.tail.map(((e,n)=>{let[t,o]=e;return s.createElement(s.Fragment,null,"${",s.createElement(oe,{key:n,type:t}),"}",s.createElement(C,{type:"string"},o))})),s.createElement(C,{type:"string"},"`"))}function ee(e){let{type:n}=e;return n.elements?s.createElement(L,{type:x.Square},n.elements.map(((e,n)=>s.createElement(oe,{key:n,type:e})))):s.createElement(s.Fragment,null,"[]")}function ne(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},n.operator," "),s.createElement(oe,{type:n.target}))}function te(e){let{type:n}=e;return s.createElement(L,{type:x.Parentheses,separator:A.Pipe},n.types.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))}function oe(e){const n=(0,s.useMemo)((()=>{switch(e.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return ne;case"conditional":return N;case"reflection":return J;case"query":return G;case"named-tuple-member":return S;case"union":return te;case"intrinsic":return I;case"literal":return R;case"reference":return pe;case"predicate":return B;case"tuple":return ee;case"array":return b;case"intersection":return P;case"inferred":return z;case"mapped":return W;case"template-literal":return Z;case"indexedAccess":return k}throw new Error(`Missing component for type: ${e.type.type}`)}),[e.type]);return s.createElement(n,e)}function pe(e){let{type:n}=e;const t=(0,U.gG)(n.project),o=t?.[n.id],p=n.externalUrl??(0,U.ID)(o);return s.createElement(s.Fragment,null,s.createElement(C,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!!n.typeArguments?.length&&s.createElement(L,{type:x.Angle},n.typeArguments.map(((e,n)=>s.createElement(oe,{key:n,type:e})))))}function re(e){let{group:n}=e;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?s.createElement(Be,{reflection:n.nested[0]}):s.createElement(s.Fragment,null,n.external.length>0&&s.createElement("ul",null,n.external.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e})))))),n.nested.length>0&&n.nested.map(((e,n)=>s.createElement(s.Fragment,{key:e.id},n>0&&s.createElement("hr",null),s.createElement(Be,{reflection:e})))))}var se=t(4441),ce=t(2663);const ae={tabItem:"tabItem_OMyP"};function ie(e){let{children:n,hidden:t,className:o}=e;return s.createElement("div",{role:"tabpanel",className:(0,ce.A)(ae.tabItem,o),hidden:t},n)}var le=t(1034),ue=t(6703),me=t(6004),ye=t(2096);function de(e){return function(e){return s.Children.map(e,(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:o,default:p}}=e;return{value:n,label:t,attributes:o,default:p}}))}function he(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??de(t);return function(e){const n=(0,me.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function ge(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function fe(e){let{queryString:n=!1,groupId:t}=e;const o=(0,w.W6)(),p=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,ue.aZ)(p),(0,s.useCallback)((e=>{if(!p)return;const n=new URLSearchParams(o.location.search);n.set(p,e),o.replace({...o.location,search:n.toString()})}),[p,o])]}function De(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,p=he(e),[r,c]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!ge({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=t.find((e=>e.default))??t[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:p}))),[a,i]=fe({queryString:t,groupId:o}),[l,u]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[o,p]=(0,ye.Dv)(t);return[o,(0,s.useCallback)((e=>{t&&p.set(e)}),[t,p])]}({groupId:o}),m=(()=>{const e=a??l;return ge({value:e,tabValues:p})?e:null})();(0,s.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!ge({value:e,tabValues:p}))throw new Error(`Can't select invalid tab value=${e}`);c(e),i(e),u(e)}),[i,u,p]),tabValues:p}}var Me=t(213);const Xe={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};function _e(e){let{className:n,block:t,selectedValue:o,selectValue:p,tabValues:c}=e;const a=[],{blockElementScrollPositionUntilNextRender:i}=(0,le.a_)(),l=e=>{const n=e.currentTarget,t=a.indexOf(n),r=c[t].value;r!==o&&(i(n),p(r))},u=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;n=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;n=a[t]??a[a.length-1];break}}n?.focus()};return s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,ce.A)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:p}=e;return s.createElement("li",(0,r.A)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:e=>a.push(e),onKeyDown:u,onClick:l},p,{className:(0,ce.A)("tabs__item",Xe.tabItem,p?.className,{"tabs__item--active":o===n})}),t??n)})))}function we(e){let{lazy:n,children:t,selectedValue:o}=e;const p=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=p.find((e=>e.props.value===o));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return s.createElement("div",{className:"margin-top--md"},p.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==o}))))}function Te(e){const n=De(e);return s.createElement("div",{className:(0,ce.A)("tabs-container",Xe.tabList)},s.createElement(_e,(0,r.A)({},e,n)),s.createElement(we,(0,r.A)({},e,n)))}function Ce(e){const n=(0,Me.A)();return s.createElement(Te,(0,r.A)({key:String(n)},e))}function xe(e){let{group:n,project:t}=e;const o=(0,w.zy)(),p=(0,U.gG)(t),r=o.hash.split("-")[0].slice(1),[c]=(0,D.R7)(),a=(0,s.useMemo)((()=>(n.categories??[n]).map((e=>function(e,n,t){const o=[],p=[],r=[];for(const s of e.children){const e=n[s];e&&(0,D.XN)(t,e)&&(r.push(e.anchor),e.hasOwnPage?o.push(e):p.push(e))}if(o.length>0||p.length>0)return{title:e.title,external:o,nested:p,anchors:r}}(e,p,c))).filter((e=>!!e))),[n,p,c]);return(0,s.useEffect)((()=>{if(1===a.length)return;const e=o.hash.split("-")[0].slice(1);for(const n of a)if(n.anchors.includes(e))return}),[o.hash,a]),0===a.length?s.createElement(s.Fragment,null):s.createElement(s.Fragment,null,s.createElement(se.A,{as:"h2",id:n.title},n.title),a.length>1?s.createElement(Ce,{groupId:n.title},a.map((e=>s.createElement(ie,{default:e.anchors.includes(r),value:e.title,label:e.title,className:"margin-top--lg"},s.createElement(re,{group:e}))))):s.createElement(re,{group:a[0]}))}var Ae=t(6048);function ve(e){let{parameters:n}=e;const t=(0,U.as)(),o=(0,s.useMemo)((()=>n?.map(t)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Parameters"),s.createElement("ul",null,o.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(q,{reflection:e})),s.createElement(Ae.A,{id:e.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function Le(e){let{parameters:n}=e;const t=(0,U.as)(),o=(0,s.useMemo)((()=>n?.map(t)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Type Parameters"),s.createElement("ul",null,o.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(O,{reflection:e})),s.createElement(Ae.A,{id:e.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function be(e){let{signatures:n,flags:t,source:o}=e;const p=(0,U.as)(),r=(0,s.useMemo)((()=>n.map(p)),[n]),[c,a]=(0,s.useState)(r[0]);return s.createElement(s.Fragment,null,s.createElement(y,null,r.map((e=>s.createElement(u,{link:o?.url,key:e.id,highlight:n.length>1&&e.id===c.id,onClick:n.length>1?()=>a(e):void 0},s.createElement(d,null,s.createElement(j,{reflection:e,flags:t})))))),s.createElement(h.A,{comment:c.comment}),s.createElement(Le,{parameters:c.typeParameter}),s.createElement(ve,{parameters:c.parameters}))}function Ne(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(K,{reflection:n})))),s.createElement(_,{kind:n.kind},s.createElement(h.A,{comment:n.comment})),s.createElement(Le,{parameters:n.typeParameters}),n.implementedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Implemented by"),s.createElement("ul",null,n.implementedBy.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e}))))))),n.extendedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Extended by"),s.createElement("ul",null,n.extendedBy.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e}))))))),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(be,{signatures:n.signatures})),n.groups?.map((e=>s.createElement(xe,{group:e,key:e.title,project:n.project}))))}function ke(e){let{reflection:n,headless:t}=e;const o=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((e=>!!e));return s.createElement(s.Fragment,null,!t&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(be,{signatures:o,flags:n.flags,source:n.sources?.[0]}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pe,{type:n.inheritedFrom}))),n.overwrites&&s.createElement("small",null,"Overwrites"," ",s.createElement("code",null,s.createElement(pe,{type:n.overwrites}))))}var ze=t(154);function Pe(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(ze.A,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),s.createElement(_,{kind:n.kind},s.createElement(h.A,{comment:n.comment})),n.groups?.map((e=>s.createElement(xe,{group:e,key:e.title,project:n.project}))))}const Ie={cardContainer:"cardContainer_ybwo",cardTitle:"cardTitle_Ehd1",cardDescription:"cardDescription_b6wr"};function Re(e){let{reflection:n}=e;const t=(0,U.gG)(n.project),o=n.groups[0].children.map((e=>t[e])).filter((e=>!!e));return s.createElement("article",{className:"margin-top--lg"},s.createElement("section",{className:(0,l.A)("row")},o.map((e=>s.createElement("article",{key:e.id,className:"col col--6 margin-bottom--lg"},s.createElement(T.A,{href:e.href,className:(0,l.A)("card padding--lg",Ie.cardContainer)},s.createElement("h2",{className:(0,l.A)("text--truncate",Ie.cardTitle)},s.createElement("code",null,e.name)),s.createElement("div",{className:(0,l.A)("text--truncate",Ie.cardDescription)},e.comment?.summaryText??"\xa0")))))))}function We(e){let{reflection:n,headless:t}=e;return s.createElement(s.Fragment,null,!t&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(Y,{reflection:n})))),s.createElement(h.A,{comment:n.comment}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pe,{type:n.inheritedFrom}))))}function Se(e){let{reflection:n}=e;const t=(0,U.gG)(n.project);return s.createElement(s.Fragment,null,s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name)),s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(K,{reflection:n})))),s.createElement(h.A,{comment:n.comment}),s.createElement(Le,{parameters:n.typeParameters}),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(be,{signatures:n.signatures})),n.groups?.map((e=>s.createElement(s.Fragment,{key:e.title},s.createElement("h2",null,e.title),e.children.map((e=>t[e])).filter((e=>e&&(e.flags.isPublic||!e.flags.isProtected&&!e.flags.isPrivate))).map((e=>s.createElement(Be,{key:e.id,reflection:e})))))))}function Be(e){let{reflection:n,headless:t=!1}=e;const o=(0,s.useMemo)((()=>{switch(n.kind){case g.k.Project:return Re;case g.k.Module:return Pe;case g.k.Namespace:case g.k.Enum:case g.k.Class:case g.k.Interface:return Ne;case g.k.Function:case g.k.Accessor:case g.k.Constructor:case g.k.Method:return ke;case g.k.Variable:case g.k.Property:case g.k.EnumMember:return We;case g.k.CallSignature:case g.k.IndexSignature:case g.k.ConstructorSignature:case g.k.Parameter:case g.k.TypeLiteral:case g.k.TypeParameter:case g.k.GetSignature:case g.k.SetSignature:case g.k.ObjectLiteral:break;case g.k.TypeAlias:return Se;case g.k.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return s.createElement(o,{reflection:n,headless:t})}},9659:(e,n,t)=>{t.d(n,{k:()=>o});let o=function(e){return e[e.Project=1]="Project",e[e.Module=2]="Module",e[e.Namespace=4]="Namespace",e[e.Enum=8]="Enum",e[e.EnumMember=16]="EnumMember",e[e.Variable=32]="Variable",e[e.Function=64]="Function",e[e.Class=128]="Class",e[e.Interface=256]="Interface",e[e.Constructor=512]="Constructor",e[e.Property=1024]="Property",e[e.Method=2048]="Method",e[e.CallSignature=4096]="CallSignature",e[e.IndexSignature=8192]="IndexSignature",e[e.ConstructorSignature=16384]="ConstructorSignature",e[e.Parameter=32768]="Parameter",e[e.TypeLiteral=65536]="TypeLiteral",e[e.TypeParameter=131072]="TypeParameter",e[e.Accessor=262144]="Accessor",e[e.GetSignature=524288]="GetSignature",e[e.SetSignature=1048576]="SetSignature",e[e.ObjectLiteral=2097152]="ObjectLiteral",e[e.TypeAlias=4194304]="TypeAlias",e[e.Reference=8388608]="Reference",e}({})},7576:(e,n,t)=>{t.d(n,{A:()=>s});var o=t(9631),p=t(9996),r=t(4041);function s(){return r.createElement(p.A,{type:"experimental"},"This is an ",r.createElement(o.A,{to:"/experimental"},"experimental feature"),". The behavior and API may change drastically between minor releases.")}},8675:(e,n,t)=>{t.d(n,{Fx:()=>a,ID:()=>i,Kv:()=>r,as:()=>c,gG:()=>s});var o=t(4041);const p=o.createContext({lookup:{},urlLookup:{}});function r(e){let{children:n,lookup:t,urlLookup:r}=e;return o.createElement(p.Provider,{value:{lookup:t,urlLookup:r}},n)}function s(e){const{lookup:n}=(0,o.useContext)(p);return n[e]}function c(){const{lookup:e}=(0,o.useContext)(p);return n=>{if("number"==typeof n?.project)return e[n.project][n.id]}}function a(){const{urlLookup:e,lookup:n}=(0,o.useContext)(p);return t=>{const o=e[t];return o?n[o.projectId]?.[o.id]??null:null}}function i(e){if(e)return e.href}},4593:(e,n,t)=>{t.d(n,{J2:()=>c,d5:()=>s,o0:()=>a});var o=t(8408),p=t(4041);const r=p.createContext(null);function s(e){let{children:n}=e;const t=(0,o.A)(),s=(0,p.useMemo)((()=>function(e,n){const{plain:t}=e,o=Object.create(null),p=e.styles.reduce(((e,t)=>{const{languages:o,style:p}=t;return o&&!o.includes(n)||t.types.forEach((n=>{e[n]={...e[n],...p}})),e}),o);return p.root=t,p.plain={...t,backgroundColor:null},p}(t,"typescript")),[t]);return p.createElement(r.Provider,{value:s},n)}function c(e){void 0===e&&(e="plain");const n=(0,p.useContext)(r);return{className:`token ${e}`,style:n[e]??n.plain}}function a(e){void 0===e&&(e="plain");const n=(0,p.useContext)(r);return n[e]??n.plain}},6382:(e,n,t)=>{t.d(n,{B4:()=>l,R7:()=>u,XN:()=>m});var o=t(9531),p=t(213),r=t(4041);const s="api-filters",c=o.A.canUseDOM?localStorage.getItem(s):null,a=c?JSON.parse(c):{inherited:!0,private:!1},i=r.createContext([a,()=>{}]);function l(e){let{children:n}=e;const[t,o]=(0,r.useState)(a),c=(0,p.A)();return r.createElement(i.Provider,{value:[t,e=>{c&&localStorage.setItem(s,JSON.stringify(e)),o(e)}]},n)}function u(){return(0,r.useContext)(i)}function m(e,n){const t=n.flags?.isPrivate||n.flags?.isProtected;if(!e.private&&t)return!1;const o=!!n.inheritedFrom;return!(!e.inherited&&o)}},9996:(e,n,t)=>{t.d(n,{A:()=>m});var o=t(9575),p=t(4041);function r(e){let{width:n=24,height:t=24,...r}=e;return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0,fill:"currentColor"},r),p.createElement("path",{d:"M19.8,18.4L14,10.67V6.5l1.35-1.69C15.61,4.48,15.38,4,14.96,4H9.04C8.62,4,8.39,4.48,8.65,4.81L10,6.5v4.17L4.2,18.4 C3.71,19.06,4.18,20,5,20h14C19.82,20,20.29,19.06,19.8,18.4z"}))}function s(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function c(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function i(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}var l=t(8621);const u={icon:"icon_Fw4I"};function m(e){let{title:n,type:t,...m}=e;const y=(0,p.useMemo)((()=>{switch(t){case"tip":return a;case"caution":return i;case"danger":return s;case"experimental":return r;default:return c}}),[t]);return"experimental"===t&&(n??="Experimental",t="caution"),p.createElement(p.Fragment,null,p.createElement(l.A,(0,o.A)({icon:p.createElement(y,{className:u.icon}),title:n,type:t},m)))}},7072:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>c,metadata:()=>i,toc:()=>u});var o=t(9575),p=(t(4041),t(2247)),r=t(9987),s=t(5906);const c={sidebar_position:10,slug:"/transitions"},a="Transitions",i={unversionedId:"guide/transitions",id:"guide/transitions",title:"Transitions",description:"_Note: These docs were adopted from the original",source:"@site/docs/guide/transitions.mdx",sourceDirName:"guide",slug:"/transitions",permalink:"/transitions",draft:!1,editUrl:"https://github.com/havenhq/revideo/blob/main/packages/docs/docs/guide/transitions.mdx",tags:[],version:"current",lastUpdatedBy:"Justus Mattern",sidebarPosition:10,frontMatter:{sidebar_position:10,slug:"/transitions"},sidebar:"docs",previous:{title:"Time Events",permalink:"/time-events"},next:{title:"Logging",permalink:"/logging"}},l={},u=[{value:"Before we start",id:"before-we-start",level:2},{value:"Pre-made transitions",id:"pre-made-transitions",level:2},{value:"<code>slideTransition</code>",id:"slidetransition",level:3},{value:"<code>zoomInTransition</code>",id:"zoomintransition",level:3},{value:"<code>zoomOutTransition</code>",id:"zoomouttransition",level:3},{value:"<code>fadeTransition</code>",id:"fadetransition",level:3},{value:"Custom transitions",id:"custom-transitions",level:2},{value:"Animate when transitioning",id:"animate-when-transitioning",level:2}],m={toc:u},y="wrapper";function d(e){let{components:n,...t}=e;return(0,p.yg)(y,(0,o.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,p.yg)("h1",{id:"transitions"},"Transitions"),(0,p.yg)("p",null,(0,p.yg)("em",{parentName:"p"},"Note: These docs were adopted from the original\n",(0,p.yg)("a",{parentName:"em",href:"https://motioncanvas.io/docs/"},"Motion Canvas")," docs")),(0,p.yg)("p",null,"Transitions allow you to customize the way scenes transition from one into\nanother. A transition is an animation performed at the beginning of the scene.\nIt can modify the context of both the current and the previous scene."),(0,p.yg)("h2",{id:"before-we-start"},"Before we start"),(0,p.yg)("div",{className:"row"},(0,p.yg)("div",{className:"col"},(0,p.yg)("p",null,"Make sure your project contains at least two scenes. In this example, we've\nprepared ",(0,p.yg)("inlineCode",{parentName:"p"},"firstScene.tsx")," and ",(0,p.yg)("inlineCode",{parentName:"p"},"secondScene.tsx"),", and configured our project to\ndisplay one after the other. We'll be setting up our transitions in the second\nscene."),(0,p.yg)("p",null,"Make sure to put something different in both scenes to easier see the\ntransitions.")),(0,p.yg)("div",{className:"col"},(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre"},"my-animation/\n\u2514\u2500 src/\n   \u251c\u2500 scenes/\n   \u2502  \u251c\u2500 firstScene.tsx\n   \u2502  \u2514\u2500 secondScene.tsx\n   \u2514\u2500 project.ts\n")))),(0,p.yg)("h2",{id:"pre-made-transitions"},"Pre-made transitions"),(0,p.yg)("p",null,"Motion Canvas comes with a set of common transitions in a form of easy-to-use\ngenerators. To use them, ",(0,p.yg)("inlineCode",{parentName:"p"},"yield*")," the transition generator at the beginning of\nthe new scene:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/scenes/secondScene.tsx"',title:'"src/scenes/secondScene.tsx"'},"export default makeScene2D(function* (view) {\n  // set up the scene:\n  view.add(/* your nodes here */);\n\n  // perform a slide transition to the left:\n  yield* slideTransition(Direction.Left);\n\n  // proceed with the animation\n  yield* waitFor(3);\n});\n")),(0,p.yg)(s.A,{small:!0,name:"transitions",link:"transitions-second",mdxType:"AnimationPlayer"}),(0,p.yg)("admonition",{type:"caution"},(0,p.yg)("p",{parentName:"admonition"},"Make sure to add nodes to the view before yielding the transition generator.\nOtherwise, your scene will remain empty until the transition ends.")),(0,p.yg)("p",null,"All available transitions are listed below:"),(0,p.yg)("h3",{id:"slidetransition"},(0,p.yg)("inlineCode",{parentName:"h3"},"slideTransition")),(0,p.yg)(r.A,{url:"/api/core/transitions#slideTransition",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"zoomintransition"},(0,p.yg)("inlineCode",{parentName:"h3"},"zoomInTransition")),(0,p.yg)(r.A,{url:"/api/core/transitions#zoomInTransition",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"zoomouttransition"},(0,p.yg)("inlineCode",{parentName:"h3"},"zoomOutTransition")),(0,p.yg)(r.A,{url:"/api/core/transitions#zoomOutTransition",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"fadetransition"},(0,p.yg)("inlineCode",{parentName:"h3"},"fadeTransition")),(0,p.yg)(r.A,{url:"/api/core/transitions#fadeTransition",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h2",{id:"custom-transitions"},"Custom transitions"),(0,p.yg)("p",null,"You can use the ",(0,p.yg)("a",{parentName:"p",href:"/api/core/transitions#useTransition"},(0,p.yg)("inlineCode",{parentName:"a"},"useTransition"))," function\nto implement custom transitions. It allows you to specify two callbacks that\nwill modify the contexts of the current and previous scene respectively. The\nvalue it returns is a callback that you need to call once you finish the\ntransition."),(0,p.yg)("p",null,"The transition template looks as follows:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-ts"},"// set up the transition\nconst endTransition = useTransition(\n  currentContext => {\n    // modify the context of the current scene\n  },\n  previousContext => {\n    // modify the context of the previous scene\n  },\n);\n\n// perform animations\n\n// finish the transition\nendTransition();\n")),(0,p.yg)("p",null,"Here's how you could implement a simple slide transition:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-ts"},"export function* slideTransition(\n  direction: Direction = Direction.Top,\n  duration = 0.6,\n): ThreadGenerator {\n  const size = useScene().getSize();\n  const position = size.getOriginOffset(direction).scale(2);\n  const previousPosition = Vector2.createSignal();\n  const currentPosition = Vector2.createSignal(position);\n\n  // set up the transition\n  const endTransition = useTransition(\n    // modify the context of the current scene\n    ctx => ctx.translate(currentPosition.x(), currentPosition.y()),\n    // modify the context of the previous scene\n    ctx => ctx.translate(previousPosition.x(), previousPosition.y()),\n  );\n\n  // perform animations\n  yield* all(\n    previousPosition(position.scale(-1), duration),\n    currentPosition(Vector2.zero, duration),\n  );\n\n  // finish the transition\n  endTransition();\n}\n")),(0,p.yg)("h2",{id:"animate-when-transitioning"},"Animate when transitioning"),(0,p.yg)("p",null,"By default, Motion Canvas will transition to the next scene once the generator\nof the current scene has reached the end. In this case, the scene will freeze\nfor the duration of the transition. You can use the\n",(0,p.yg)("a",{parentName:"p",href:"/api/core/utils#finishScene"},(0,p.yg)("inlineCode",{parentName:"a"},"finishScene"))," function to trigger the transition\nearly, allowing the animation to continue while transitioning:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  yield* animationOne();\n  // trigger the transition early:\n  finishScene();\n  // continue animating:\n  yield* animationTwo();\n});\n")))}d.isMDXComponent=!0}}]);
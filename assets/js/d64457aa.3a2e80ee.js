"use strict";(self.webpackChunk_revideo_docs=self.webpackChunk_revideo_docs||[]).push([[4231],{8621:(e,n,t)=>{t.d(n,{A:()=>u});var o=t(4041),p=t(2663),r=t(7473),s=t(9082);const c={admonition:"admonition_qNG0",admonitionHeading:"admonitionHeading_l909",admonitionIcon:"admonitionIcon_UNbs",admonitionContent:"admonitionContent_oUmQ"};const a={note:{infimaClassName:"secondary",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 14 16"},o.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))},label:o.createElement(s.A,{id:"theme.admonition.note",description:"The default label used for the Note admonition (:::note)"},"note")},tip:{infimaClassName:"success",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 12 16"},o.createElement("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))},label:o.createElement(s.A,{id:"theme.admonition.tip",description:"The default label used for the Tip admonition (:::tip)"},"tip")},danger:{infimaClassName:"danger",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 12 16"},o.createElement("path",{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))},label:o.createElement(s.A,{id:"theme.admonition.danger",description:"The default label used for the Danger admonition (:::danger)"},"danger")},info:{infimaClassName:"info",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 14 16"},o.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))},label:o.createElement(s.A,{id:"theme.admonition.info",description:"The default label used for the Info admonition (:::info)"},"info")},caution:{infimaClassName:"warning",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 16 16"},o.createElement("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))},label:o.createElement(s.A,{id:"theme.admonition.caution",description:"The default label used for the Caution admonition (:::caution)"},"caution")}},i={secondary:"note",important:"info",success:"tip",warning:"danger"};function l(e){const{mdxAdmonitionTitle:n,rest:t}=function(e){const n=o.Children.toArray(e),t=n.find((e=>o.isValidElement(e)&&"mdxAdmonitionTitle"===e.props?.mdxType)),p=o.createElement(o.Fragment,null,n.filter((e=>e!==t)));return{mdxAdmonitionTitle:t,rest:p}}(e.children);return{...e,title:e.title??n,children:t}}function u(e){const{children:n,type:t,title:s,icon:u}=l(e),m=function(e){const n=i[e]??e,t=a[n];return t||(console.warn(`No admonition config found for admonition type "${n}". Using Info as fallback.`),a.info)}(t),y=s??m.label,{iconComponent:d}=m,h=u??o.createElement(d,null);return o.createElement("div",{className:(0,p.A)(r.G.common.admonition,r.G.common.admonitionType(e.type),"alert",`alert--${m.infimaClassName}`,c.admonition)},o.createElement("div",{className:c.admonitionHeading},o.createElement("span",{className:c.admonitionIcon},h),y),o.createElement("div",{className:c.admonitionContent},n))}},4441:(e,n,t)=>{t.d(n,{A:()=>l});var o=t(9575),p=t(4041),r=t(2663),s=t(9082),c=t(2520),a=t(9631);const i={anchorWithStickyNavbar:"anchorWithStickyNavbar_fF9Z",anchorWithHideOnScrollNavbar:"anchorWithHideOnScrollNavbar_Yh18"};function l(e){let{as:n,id:t,...l}=e;const{navbar:{hideOnScroll:u}}=(0,c.p)();if("h1"===n||!t)return p.createElement(n,(0,o.A)({},l,{id:void 0}));const m=(0,s.T)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof l.children?l.children:t});return p.createElement(n,(0,o.A)({},l,{className:(0,r.A)("anchor",u?i.anchorWithHideOnScrollNavbar:i.anchorWithStickyNavbar,l.className),id:t}),l.children,p.createElement(a.A,{className:"hash-link",to:`#${t}`,"aria-label":m,title:m},"\u200b"))}},9987:(e,n,t)=>{t.d(n,{A:()=>s});var o=t(1125),p=t(8675),r=t(4041);function s(e){let{url:n}=e;const t=(0,p.Fx)()(n);return r.createElement(o.A,{reflection:t,headless:!0})}},3443:(e,n,t)=>{t.d(n,{A:()=>ybr});var o={};t.r(o),t.d(o,{content_0_0:()=>i,content_0_10:()=>C,content_0_100:()=>Jn,content_0_1000:()=>ev,content_0_1002:()=>ov,content_0_1004:()=>sv,content_0_1006:()=>iv,content_0_1008:()=>mv,content_0_1010:()=>hv,content_0_1012:()=>Dv,content_0_1014:()=>_v,content_0_1016:()=>Cv,content_0_1018:()=>vv,content_0_102:()=>nt,content_0_1020:()=>Nv,content_0_1022:()=>Pv,content_0_1024:()=>Wv,content_0_1026:()=>Gv,content_0_1028:()=>Uv,content_0_1030:()=>qv,content_0_1032:()=>Yv,content_0_1034:()=>Kv,content_0_1036:()=>eL,content_0_1038:()=>oL,content_0_104:()=>pt,content_0_1040:()=>sL,content_0_1042:()=>iL,content_0_1044:()=>mL,content_0_1046:()=>hL,content_0_1048:()=>DL,content_0_1050:()=>_L,content_0_1052:()=>CL,content_0_1054:()=>vL,content_0_1056:()=>NL,content_0_1058:()=>PL,content_0_106:()=>ct,content_0_1060:()=>WL,content_0_1062:()=>GL,content_0_1064:()=>UL,content_0_1066:()=>qL,content_0_1068:()=>YL,content_0_1070:()=>KL,content_0_1072:()=>eb,content_0_1074:()=>ob,content_0_1076:()=>sb,content_0_1078:()=>ib,content_0_108:()=>lt,content_0_1080:()=>mb,content_0_1082:()=>hb,content_0_1084:()=>Db,content_0_1086:()=>_b,content_0_1088:()=>Cb,content_0_1090:()=>vb,content_0_1092:()=>Nb,content_0_1094:()=>Pb,content_0_1096:()=>Wb,content_0_1098:()=>Gb,content_0_110:()=>yt,content_0_1100:()=>Ub,content_0_1102:()=>qb,content_0_1104:()=>Yb,content_0_1106:()=>Kb,content_0_1108:()=>eN,content_0_1110:()=>oN,content_0_1112:()=>sN,content_0_1114:()=>iN,content_0_1116:()=>mN,content_0_1118:()=>hN,content_0_112:()=>gt,content_0_1120:()=>DN,content_0_1122:()=>_N,content_0_1124:()=>CN,content_0_1126:()=>vN,content_0_1128:()=>NN,content_0_1130:()=>PN,content_0_1132:()=>WN,content_0_1134:()=>GN,content_0_1136:()=>UN,content_0_1138:()=>qN,content_0_114:()=>Mt,content_0_1140:()=>YN,content_0_1142:()=>KN,content_0_1144:()=>ek,content_0_1146:()=>ok,content_0_1148:()=>sk,content_0_1150:()=>ik,content_0_1152:()=>mk,content_0_1154:()=>hk,content_0_1156:()=>Dk,content_0_1158:()=>_k,content_0_116:()=>wt,content_0_1160:()=>Ck,content_0_1162:()=>vk,content_0_1164:()=>Nk,content_0_1166:()=>Pk,content_0_1168:()=>Wk,content_0_1170:()=>Gk,content_0_1172:()=>Uk,content_0_1174:()=>qk,content_0_1176:()=>Yk,content_0_1178:()=>Kk,content_0_118:()=>xt,content_0_1180:()=>ez,content_0_1182:()=>oz,content_0_1184:()=>sz,content_0_1186:()=>iz,content_0_1188:()=>mz,content_0_1190:()=>hz,content_0_1192:()=>Dz,content_0_1194:()=>_z,content_0_1196:()=>Cz,content_0_1198:()=>vz,content_0_12:()=>v,content_0_120:()=>Lt,content_0_1200:()=>Nz,content_0_1202:()=>Pz,content_0_1204:()=>Wz,content_0_1206:()=>Gz,content_0_1208:()=>Uz,content_0_1210:()=>qz,content_0_1212:()=>Yz,content_0_1214:()=>Kz,content_0_1216:()=>eP,content_0_1218:()=>oP,content_0_122:()=>kt,content_0_1220:()=>sP,content_0_1222:()=>iP,content_0_1224:()=>mP,content_0_1226:()=>hP,content_0_1228:()=>DP,content_0_1230:()=>_P,content_0_1232:()=>CP,content_0_1234:()=>vP,content_0_1236:()=>NP,content_0_1238:()=>PP,content_0_124:()=>It,content_0_1240:()=>WP,content_0_1242:()=>GP,content_0_1244:()=>UP,content_0_1246:()=>qP,content_0_1248:()=>YP,content_0_1250:()=>KP,content_0_1252:()=>eI,content_0_1254:()=>oI,content_0_1256:()=>sI,content_0_1258:()=>iI,content_0_126:()=>St,content_0_1260:()=>mI,content_0_1262:()=>hI,content_0_1264:()=>DI,content_0_1266:()=>_I,content_0_1268:()=>CI,content_0_1270:()=>vI,content_0_1272:()=>NI,content_0_1274:()=>PI,content_0_1276:()=>WI,content_0_1278:()=>GI,content_0_128:()=>Et,content_0_1280:()=>UI,content_0_1282:()=>qI,content_0_1284:()=>YI,content_0_1286:()=>KI,content_0_1288:()=>eR,content_0_1290:()=>oR,content_0_1292:()=>sR,content_0_1294:()=>iR,content_0_1296:()=>mR,content_0_1298:()=>hR,content_0_130:()=>Ft,content_0_1300:()=>DR,content_0_1302:()=>_R,content_0_1304:()=>CR,content_0_1306:()=>vR,content_0_1308:()=>NR,content_0_1310:()=>PR,content_0_1312:()=>WR,content_0_1314:()=>GR,content_0_1316:()=>UR,content_0_1318:()=>qR,content_0_132:()=>jt,content_0_1320:()=>YR,content_0_1322:()=>KR,content_0_1324:()=>eW,content_0_1326:()=>oW,content_0_1328:()=>sW,content_0_1330:()=>iW,content_0_1332:()=>mW,content_0_1334:()=>hW,content_0_1336:()=>DW,content_0_1338:()=>_W,content_0_134:()=>Qt,content_0_1340:()=>CW,content_0_1342:()=>vW,content_0_1344:()=>NW,content_0_1346:()=>PW,content_0_1348:()=>WW,content_0_1350:()=>GW,content_0_1352:()=>UW,content_0_1354:()=>qW,content_0_1356:()=>YW,content_0_1358:()=>KW,content_0_136:()=>Jt,content_0_1360:()=>eS,content_0_1362:()=>oS,content_0_1364:()=>sS,content_0_1366:()=>iS,content_0_1368:()=>mS,content_0_1370:()=>hS,content_0_1372:()=>DS,content_0_1374:()=>_S,content_0_1376:()=>CS,content_0_1378:()=>vS,content_0_138:()=>no,content_0_1380:()=>NS,content_0_1382:()=>PS,content_0_1384:()=>WS,content_0_1386:()=>GS,content_0_1388:()=>US,content_0_1390:()=>qS,content_0_1392:()=>YS,content_0_1394:()=>KS,content_0_1396:()=>eB,content_0_1398:()=>oB,content_0_14:()=>N,content_0_140:()=>po,content_0_1400:()=>sB,content_0_1402:()=>iB,content_0_1404:()=>mB,content_0_1406:()=>hB,content_0_1408:()=>DB,content_0_1410:()=>_B,content_0_1412:()=>CB,content_0_1414:()=>vB,content_0_1416:()=>NB,content_0_1418:()=>PB,content_0_142:()=>co,content_0_1420:()=>WB,content_0_1422:()=>GB,content_0_1424:()=>UB,content_0_1426:()=>qB,content_0_1428:()=>YB,content_0_1430:()=>KB,content_0_1432:()=>eG,content_0_1434:()=>oG,content_0_1436:()=>sG,content_0_1438:()=>iG,content_0_144:()=>lo,content_0_1440:()=>mG,content_0_1442:()=>hG,content_0_1444:()=>DG,content_0_1446:()=>_G,content_0_1448:()=>CG,content_0_1450:()=>vG,content_0_1452:()=>NG,content_0_1454:()=>PG,content_0_1456:()=>WG,content_0_1458:()=>GG,content_0_146:()=>yo,content_0_1460:()=>UG,content_0_1462:()=>qG,content_0_1464:()=>YG,content_0_1466:()=>KG,content_0_1468:()=>eE,content_0_1470:()=>oE,content_0_1472:()=>sE,content_0_1474:()=>iE,content_0_1476:()=>mE,content_0_1478:()=>hE,content_0_148:()=>fo,content_0_1480:()=>DE,content_0_1482:()=>_E,content_0_1484:()=>CE,content_0_1486:()=>vE,content_0_1488:()=>NE,content_0_1490:()=>PE,content_0_1492:()=>WE,content_0_1494:()=>GE,content_0_1496:()=>UE,content_0_1498:()=>qE,content_0_150:()=>Xo,content_0_1500:()=>YE,content_0_1502:()=>KE,content_0_1504:()=>eO,content_0_1506:()=>oO,content_0_1508:()=>sO,content_0_1510:()=>iO,content_0_1512:()=>mO,content_0_1514:()=>hO,content_0_1516:()=>DO,content_0_1518:()=>_O,content_0_152:()=>To,content_0_1520:()=>CO,content_0_1522:()=>vO,content_0_1524:()=>NO,content_0_1526:()=>PO,content_0_1528:()=>WO,content_0_1530:()=>GO,content_0_1532:()=>UO,content_0_1534:()=>qO,content_0_1536:()=>YO,content_0_1538:()=>KO,content_0_154:()=>Ao,content_0_1540:()=>eU,content_0_1542:()=>oU,content_0_1544:()=>sU,content_0_1546:()=>iU,content_0_1548:()=>mU,content_0_1550:()=>hU,content_0_1552:()=>DU,content_0_1554:()=>_U,content_0_1556:()=>CU,content_0_1558:()=>vU,content_0_156:()=>bo,content_0_1560:()=>NU,content_0_1562:()=>PU,content_0_1564:()=>WU,content_0_1566:()=>GU,content_0_1568:()=>UU,content_0_1570:()=>qU,content_0_1572:()=>YU,content_0_1574:()=>KU,content_0_1576:()=>eF,content_0_1578:()=>oF,content_0_158:()=>zo,content_0_1580:()=>sF,content_0_1582:()=>iF,content_0_1584:()=>mF,content_0_1586:()=>hF,content_0_1588:()=>DF,content_0_1590:()=>_F,content_0_1592:()=>CF,content_0_1594:()=>vF,content_0_1596:()=>NF,content_0_1598:()=>PF,content_0_16:()=>P,content_0_160:()=>Ro,content_0_1600:()=>WF,content_0_1602:()=>GF,content_0_1604:()=>UF,content_0_1606:()=>qF,content_0_1608:()=>YF,content_0_1610:()=>KF,content_0_1612:()=>eV,content_0_1614:()=>oV,content_0_1616:()=>sV,content_0_1618:()=>iV,content_0_162:()=>Bo,content_0_1620:()=>mV,content_0_1622:()=>hV,content_0_1624:()=>DV,content_0_1626:()=>_V,content_0_1628:()=>CV,content_0_1630:()=>vV,content_0_1632:()=>NV,content_0_1634:()=>PV,content_0_1636:()=>WV,content_0_1638:()=>GV,content_0_164:()=>Oo,content_0_1640:()=>UV,content_0_1642:()=>qV,content_0_1644:()=>YV,content_0_1646:()=>KV,content_0_1648:()=>eq,content_0_1650:()=>oq,content_0_1652:()=>sq,content_0_1654:()=>iq,content_0_1656:()=>mq,content_0_1658:()=>hq,content_0_166:()=>Vo,content_0_1660:()=>Dq,content_0_1662:()=>_q,content_0_1664:()=>Cq,content_0_1666:()=>vq,content_0_1668:()=>Nq,content_0_1670:()=>Pq,content_0_1672:()=>Wq,content_0_1674:()=>Gq,content_0_1676:()=>Uq,content_0_1678:()=>qq,content_0_168:()=>Ho,content_0_1680:()=>Yq,content_0_1682:()=>Kq,content_0_1684:()=>ej,content_0_1686:()=>oj,content_0_1688:()=>sj,content_0_1690:()=>ij,content_0_1692:()=>mj,content_0_1694:()=>hj,content_0_1696:()=>Dj,content_0_1698:()=>_j,content_0_170:()=>$o,content_0_1700:()=>Cj,content_0_1702:()=>vj,content_0_1704:()=>Nj,content_0_1706:()=>Pj,content_0_1708:()=>Wj,content_0_1710:()=>Gj,content_0_1712:()=>Uj,content_0_1714:()=>qj,content_0_1716:()=>Yj,content_0_1718:()=>Kj,content_0_172:()=>Zo,content_0_1720:()=>eH,content_0_1722:()=>oH,content_0_1724:()=>sH,content_0_1726:()=>iH,content_0_1728:()=>mH,content_0_1730:()=>hH,content_0_1732:()=>DH,content_0_1734:()=>_H,content_0_1736:()=>CH,content_0_1738:()=>vH,content_0_174:()=>tp,content_0_1740:()=>NH,content_0_1742:()=>PH,content_0_1744:()=>WH,content_0_1746:()=>GH,content_0_1748:()=>UH,content_0_1750:()=>qH,content_0_1752:()=>YH,content_0_1754:()=>KH,content_0_1756:()=>eY,content_0_1758:()=>oY,content_0_176:()=>rp,content_0_1760:()=>sY,content_0_1762:()=>iY,content_0_1764:()=>mY,content_0_1766:()=>hY,content_0_1768:()=>DY,content_0_1770:()=>_Y,content_0_1772:()=>CY,content_0_1774:()=>vY,content_0_1776:()=>NY,content_0_1778:()=>PY,content_0_178:()=>ap,content_0_1780:()=>WY,content_0_1782:()=>GY,content_0_1784:()=>UY,content_0_1786:()=>qY,content_0_1788:()=>YY,content_0_1790:()=>KY,content_0_1792:()=>eQ,content_0_1794:()=>oQ,content_0_1796:()=>sQ,content_0_1798:()=>iQ,content_0_18:()=>W,content_0_180:()=>up,content_0_1800:()=>mQ,content_0_1802:()=>hQ,content_0_1804:()=>DQ,content_0_1806:()=>_Q,content_0_1808:()=>CQ,content_0_1810:()=>vQ,content_0_1812:()=>NQ,content_0_1814:()=>PQ,content_0_1816:()=>WQ,content_0_1818:()=>GQ,content_0_182:()=>dp,content_0_1820:()=>UQ,content_0_1822:()=>qQ,content_0_1824:()=>YQ,content_0_1826:()=>KQ,content_0_1828:()=>e$,content_0_1830:()=>o$,content_0_1832:()=>s$,content_0_1834:()=>i$,content_0_1836:()=>m$,content_0_1838:()=>h$,content_0_184:()=>fp,content_0_1840:()=>D$,content_0_1842:()=>_$,content_0_1844:()=>C$,content_0_1846:()=>v$,content_0_1848:()=>N$,content_0_1850:()=>P$,content_0_1852:()=>W$,content_0_1854:()=>G$,content_0_1856:()=>U$,content_0_1858:()=>q$,content_0_186:()=>Xp,content_0_1860:()=>Y$,content_0_1862:()=>K$,content_0_1864:()=>eK,content_0_1866:()=>oK,content_0_1868:()=>sK,content_0_1870:()=>iK,content_0_1872:()=>mK,content_0_1874:()=>hK,content_0_1876:()=>DK,content_0_1878:()=>_K,content_0_188:()=>Tp,content_0_1880:()=>CK,content_0_1882:()=>vK,content_0_1884:()=>NK,content_0_1886:()=>PK,content_0_190:()=>Ap,content_0_192:()=>bp,content_0_194:()=>zp,content_0_196:()=>Rp,content_0_198:()=>Bp,content_0_2:()=>m,content_0_20:()=>G,content_0_200:()=>Op,content_0_202:()=>Vp,content_0_204:()=>Hp,content_0_206:()=>$p,content_0_208:()=>Zp,content_0_210:()=>tr,content_0_212:()=>rr,content_0_214:()=>ar,content_0_216:()=>ur,content_0_218:()=>dr,content_0_22:()=>U,content_0_220:()=>fr,content_0_222:()=>Xr,content_0_224:()=>Tr,content_0_226:()=>Ar,content_0_228:()=>br,content_0_230:()=>zr,content_0_232:()=>Rr,content_0_234:()=>Br,content_0_236:()=>Or,content_0_238:()=>Vr,content_0_24:()=>q,content_0_240:()=>Hr,content_0_242:()=>$r,content_0_244:()=>Zr,content_0_246:()=>ts,content_0_248:()=>rs,content_0_250:()=>as,content_0_252:()=>us,content_0_254:()=>ds,content_0_256:()=>fs,content_0_258:()=>Xs,content_0_26:()=>Y,content_0_260:()=>Ts,content_0_262:()=>As,content_0_264:()=>bs,content_0_266:()=>zs,content_0_268:()=>Rs,content_0_270:()=>Bs,content_0_272:()=>Os,content_0_274:()=>Vs,content_0_276:()=>Hs,content_0_278:()=>$s,content_0_28:()=>K,content_0_280:()=>Zs,content_0_282:()=>tc,content_0_284:()=>rc,content_0_286:()=>ac,content_0_288:()=>uc,content_0_290:()=>dc,content_0_292:()=>fc,content_0_294:()=>Xc,content_0_296:()=>Tc,content_0_298:()=>Ac,content_0_30:()=>ee,content_0_300:()=>bc,content_0_302:()=>zc,content_0_304:()=>Rc,content_0_306:()=>Bc,content_0_308:()=>Oc,content_0_310:()=>Vc,content_0_312:()=>Hc,content_0_314:()=>$c,content_0_316:()=>Zc,content_0_318:()=>ta,content_0_32:()=>oe,content_0_320:()=>ra,content_0_322:()=>aa,content_0_324:()=>ua,content_0_326:()=>da,content_0_328:()=>fa,content_0_330:()=>Xa,content_0_332:()=>Ta,content_0_334:()=>Aa,content_0_336:()=>ba,content_0_338:()=>za,content_0_34:()=>se,content_0_340:()=>Ra,content_0_342:()=>Ba,content_0_344:()=>Oa,content_0_346:()=>Va,content_0_348:()=>Ha,content_0_350:()=>$a,content_0_352:()=>Za,content_0_354:()=>ti,content_0_356:()=>ri,content_0_358:()=>ai,content_0_36:()=>ie,content_0_360:()=>ui,content_0_362:()=>di,content_0_364:()=>fi,content_0_366:()=>Xi,content_0_368:()=>Ti,content_0_370:()=>Ai,content_0_372:()=>bi,content_0_374:()=>zi,content_0_376:()=>Ri,content_0_378:()=>Bi,content_0_38:()=>me,content_0_380:()=>Oi,content_0_382:()=>Vi,content_0_384:()=>Hi,content_0_386:()=>$i,content_0_388:()=>Zi,content_0_390:()=>tl,content_0_392:()=>rl,content_0_394:()=>al,content_0_396:()=>ul,content_0_398:()=>dl,content_0_4:()=>h,content_0_40:()=>he,content_0_400:()=>fl,content_0_402:()=>Xl,content_0_404:()=>Tl,content_0_406:()=>Al,content_0_408:()=>bl,content_0_410:()=>zl,content_0_412:()=>Rl,content_0_414:()=>Bl,content_0_416:()=>Ol,content_0_418:()=>Vl,content_0_42:()=>De,content_0_420:()=>Hl,content_0_422:()=>$l,content_0_424:()=>Zl,content_0_426:()=>tu,content_0_428:()=>ru,content_0_430:()=>au,content_0_432:()=>uu,content_0_434:()=>du,content_0_436:()=>fu,content_0_438:()=>Xu,content_0_44:()=>_e,content_0_440:()=>Tu,content_0_442:()=>Au,content_0_444:()=>bu,content_0_446:()=>zu,content_0_448:()=>Ru,content_0_450:()=>Bu,content_0_452:()=>Ou,content_0_454:()=>Vu,content_0_456:()=>Hu,content_0_458:()=>$u,content_0_46:()=>Ce,content_0_460:()=>Zu,content_0_462:()=>tm,content_0_464:()=>rm,content_0_466:()=>am,content_0_468:()=>um,content_0_470:()=>dm,content_0_472:()=>fm,content_0_474:()=>Xm,content_0_476:()=>Tm,content_0_478:()=>Am,content_0_48:()=>ve,content_0_480:()=>bm,content_0_482:()=>zm,content_0_484:()=>Rm,content_0_486:()=>Bm,content_0_488:()=>Om,content_0_490:()=>Vm,content_0_492:()=>Hm,content_0_494:()=>$m,content_0_496:()=>Zm,content_0_498:()=>ty,content_0_50:()=>Ne,content_0_500:()=>ry,content_0_502:()=>ay,content_0_504:()=>uy,content_0_506:()=>dy,content_0_508:()=>fy,content_0_510:()=>Xy,content_0_512:()=>Ty,content_0_514:()=>Ay,content_0_516:()=>by,content_0_518:()=>zy,content_0_52:()=>Pe,content_0_520:()=>Ry,content_0_522:()=>By,content_0_524:()=>Oy,content_0_526:()=>Vy,content_0_528:()=>Hy,content_0_530:()=>$y,content_0_532:()=>Zy,content_0_534:()=>td,content_0_536:()=>rd,content_0_538:()=>ad,content_0_54:()=>We,content_0_540:()=>ud,content_0_542:()=>dd,content_0_544:()=>fd,content_0_546:()=>Xd,content_0_548:()=>Td,content_0_550:()=>Ad,content_0_552:()=>bd,content_0_554:()=>zd,content_0_556:()=>Rd,content_0_558:()=>Bd,content_0_56:()=>Ge,content_0_560:()=>Od,content_0_562:()=>Vd,content_0_564:()=>Hd,content_0_566:()=>$d,content_0_568:()=>Zd,content_0_570:()=>th,content_0_572:()=>rh,content_0_574:()=>ah,content_0_576:()=>uh,content_0_578:()=>dh,content_0_58:()=>Ue,content_0_580:()=>fh,content_0_582:()=>Xh,content_0_584:()=>Th,content_0_586:()=>Ah,content_0_588:()=>bh,content_0_590:()=>zh,content_0_592:()=>Rh,content_0_594:()=>Bh,content_0_596:()=>Oh,content_0_598:()=>Vh,content_0_6:()=>D,content_0_60:()=>qe,content_0_600:()=>Hh,content_0_602:()=>$h,content_0_604:()=>Zh,content_0_606:()=>tg,content_0_608:()=>rg,content_0_610:()=>ag,content_0_612:()=>ug,content_0_614:()=>dg,content_0_616:()=>fg,content_0_618:()=>Xg,content_0_62:()=>Ye,content_0_620:()=>Tg,content_0_622:()=>Ag,content_0_624:()=>bg,content_0_626:()=>zg,content_0_628:()=>Rg,content_0_630:()=>Bg,content_0_632:()=>Og,content_0_634:()=>Vg,content_0_636:()=>Hg,content_0_638:()=>$g,content_0_64:()=>Ke,content_0_640:()=>Zg,content_0_642:()=>tf,content_0_644:()=>rf,content_0_646:()=>af,content_0_648:()=>mf,content_0_650:()=>hf,content_0_652:()=>Df,content_0_654:()=>_f,content_0_656:()=>Cf,content_0_658:()=>vf,content_0_66:()=>en,content_0_660:()=>Nf,content_0_662:()=>Pf,content_0_664:()=>Wf,content_0_666:()=>Gf,content_0_668:()=>Uf,content_0_670:()=>qf,content_0_672:()=>Yf,content_0_674:()=>Kf,content_0_676:()=>eD,content_0_678:()=>oD,content_0_68:()=>on,content_0_680:()=>sD,content_0_682:()=>iD,content_0_684:()=>mD,content_0_686:()=>hD,content_0_688:()=>DD,content_0_690:()=>_D,content_0_692:()=>CD,content_0_694:()=>vD,content_0_696:()=>ND,content_0_698:()=>PD,content_0_70:()=>sn,content_0_700:()=>WD,content_0_702:()=>GD,content_0_704:()=>UD,content_0_706:()=>qD,content_0_708:()=>YD,content_0_710:()=>KD,content_0_712:()=>eM,content_0_714:()=>oM,content_0_716:()=>sM,content_0_718:()=>iM,content_0_72:()=>ln,content_0_720:()=>mM,content_0_722:()=>hM,content_0_724:()=>DM,content_0_726:()=>_M,content_0_728:()=>CM,content_0_730:()=>vM,content_0_732:()=>NM,content_0_734:()=>PM,content_0_736:()=>WM,content_0_738:()=>GM,content_0_74:()=>yn,content_0_740:()=>UM,content_0_742:()=>qM,content_0_744:()=>YM,content_0_746:()=>KM,content_0_748:()=>eX,content_0_750:()=>oX,content_0_752:()=>sX,content_0_754:()=>iX,content_0_756:()=>mX,content_0_758:()=>hX,content_0_76:()=>gn,content_0_760:()=>DX,content_0_762:()=>_X,content_0_764:()=>CX,content_0_766:()=>vX,content_0_768:()=>NX,content_0_770:()=>PX,content_0_772:()=>WX,content_0_774:()=>GX,content_0_776:()=>UX,content_0_778:()=>qX,content_0_78:()=>Mn,content_0_780:()=>YX,content_0_782:()=>KX,content_0_784:()=>e_,content_0_786:()=>o_,content_0_788:()=>s_,content_0_790:()=>i_,content_0_792:()=>m_,content_0_794:()=>h_,content_0_796:()=>D_,content_0_798:()=>__,content_0_8:()=>_,content_0_80:()=>wn,content_0_800:()=>C_,content_0_802:()=>v_,content_0_804:()=>N_,content_0_806:()=>P_,content_0_808:()=>W_,content_0_810:()=>G_,content_0_812:()=>U_,content_0_814:()=>q_,content_0_816:()=>Y_,content_0_818:()=>K_,content_0_82:()=>xn,content_0_820:()=>ew,content_0_822:()=>ow,content_0_824:()=>sw,content_0_826:()=>iw,content_0_828:()=>mw,content_0_830:()=>hw,content_0_832:()=>Dw,content_0_834:()=>_w,content_0_836:()=>Cw,content_0_838:()=>vw,content_0_84:()=>Ln,content_0_840:()=>Nw,content_0_842:()=>Pw,content_0_844:()=>Ww,content_0_846:()=>Gw,content_0_848:()=>Uw,content_0_850:()=>qw,content_0_852:()=>Yw,content_0_854:()=>Kw,content_0_856:()=>eT,content_0_858:()=>oT,content_0_86:()=>kn,content_0_860:()=>sT,content_0_862:()=>iT,content_0_864:()=>mT,content_0_866:()=>hT,content_0_868:()=>DT,content_0_870:()=>_T,content_0_872:()=>CT,content_0_874:()=>vT,content_0_876:()=>NT,content_0_878:()=>PT,content_0_88:()=>In,content_0_880:()=>WT,content_0_882:()=>GT,content_0_884:()=>UT,content_0_886:()=>qT,content_0_888:()=>YT,content_0_890:()=>KT,content_0_892:()=>eC,content_0_894:()=>oC,content_0_896:()=>sC,content_0_898:()=>iC,content_0_90:()=>Sn,content_0_900:()=>mC,content_0_902:()=>hC,content_0_904:()=>DC,content_0_906:()=>_C,content_0_908:()=>CC,content_0_910:()=>vC,content_0_912:()=>NC,content_0_914:()=>PC,content_0_916:()=>WC,content_0_918:()=>GC,content_0_92:()=>En,content_0_920:()=>UC,content_0_922:()=>qC,content_0_924:()=>YC,content_0_926:()=>KC,content_0_928:()=>ex,content_0_930:()=>ox,content_0_932:()=>sx,content_0_934:()=>ix,content_0_936:()=>mx,content_0_938:()=>hx,content_0_94:()=>Fn,content_0_940:()=>Dx,content_0_942:()=>_x,content_0_944:()=>Cx,content_0_946:()=>vx,content_0_948:()=>Nx,content_0_950:()=>Px,content_0_952:()=>Wx,content_0_954:()=>Gx,content_0_956:()=>Ux,content_0_958:()=>qx,content_0_96:()=>jn,content_0_960:()=>Yx,content_0_962:()=>Kx,content_0_964:()=>eA,content_0_966:()=>oA,content_0_968:()=>sA,content_0_970:()=>iA,content_0_972:()=>mA,content_0_974:()=>hA,content_0_976:()=>DA,content_0_978:()=>_A,content_0_98:()=>Qn,content_0_980:()=>CA,content_0_982:()=>vA,content_0_984:()=>NA,content_0_986:()=>PA,content_0_988:()=>WA,content_0_990:()=>GA,content_0_992:()=>UA,content_0_994:()=>qA,content_0_996:()=>YA,content_0_998:()=>KA,content_3824_0:()=>WK,content_3824_10:()=>KK,content_3824_100:()=>C0,content_3824_1000:()=>Che,content_3824_10000:()=>xip,content_3824_10002:()=>Lip,content_3824_10004:()=>kip,content_3824_10006:()=>Iip,content_3824_10008:()=>Sip,content_3824_10010:()=>Eip,content_3824_10012:()=>Fip,content_3824_10014:()=>jip,content_3824_10016:()=>Qip,content_3824_10018:()=>Jip,content_3824_1002:()=>vhe,content_3824_10020:()=>nlp,content_3824_10022:()=>plp,content_3824_10024:()=>clp,content_3824_10026:()=>llp,content_3824_10028:()=>ylp,content_3824_10030:()=>glp,content_3824_10032:()=>Mlp,content_3824_10034:()=>wlp,content_3824_10036:()=>xlp,content_3824_10038:()=>Llp,content_3824_1004:()=>Nhe,content_3824_10040:()=>klp,content_3824_10042:()=>Ilp,content_3824_10044:()=>Slp,content_3824_10046:()=>Elp,content_3824_10048:()=>Flp,content_3824_10050:()=>jlp,content_3824_10052:()=>Qlp,content_3824_10054:()=>Jlp,content_3824_10056:()=>nup,content_3824_10058:()=>pup,content_3824_1006:()=>Phe,content_3824_10060:()=>cup,content_3824_10062:()=>lup,content_3824_10064:()=>yup,content_3824_10066:()=>gup,content_3824_10068:()=>Mup,content_3824_10070:()=>wup,content_3824_10072:()=>xup,content_3824_10074:()=>Lup,content_3824_10076:()=>kup,content_3824_10078:()=>Iup,content_3824_1008:()=>Whe,content_3824_10080:()=>Sup,content_3824_10082:()=>Eup,content_3824_10084:()=>Fup,content_3824_10086:()=>jup,content_3824_10088:()=>Qup,content_3824_10090:()=>Jup,content_3824_10092:()=>nmp,content_3824_10094:()=>pmp,content_3824_10096:()=>cmp,content_3824_10098:()=>lmp,content_3824_1010:()=>Ghe,content_3824_10100:()=>ymp,content_3824_10102:()=>gmp,content_3824_10104:()=>Mmp,content_3824_10106:()=>wmp,content_3824_10108:()=>xmp,content_3824_10110:()=>Lmp,content_3824_10112:()=>kmp,content_3824_10114:()=>Imp,content_3824_10116:()=>Smp,content_3824_10118:()=>Emp,content_3824_1012:()=>Uhe,content_3824_10120:()=>Fmp,content_3824_10122:()=>jmp,content_3824_10124:()=>Qmp,content_3824_10126:()=>Jmp,content_3824_10128:()=>nyp,content_3824_10130:()=>pyp,content_3824_10132:()=>cyp,content_3824_10134:()=>lyp,content_3824_10136:()=>yyp,content_3824_10138:()=>gyp,content_3824_1014:()=>qhe,content_3824_10140:()=>Myp,content_3824_10142:()=>wyp,content_3824_10144:()=>xyp,content_3824_10146:()=>Lyp,content_3824_10148:()=>kyp,content_3824_10150:()=>Iyp,content_3824_10152:()=>Syp,content_3824_10154:()=>Eyp,content_3824_10156:()=>Fyp,content_3824_10158:()=>jyp,content_3824_1016:()=>Yhe,content_3824_10160:()=>Qyp,content_3824_10162:()=>Jyp,content_3824_10164:()=>ndp,content_3824_10166:()=>pdp,content_3824_10168:()=>cdp,content_3824_10170:()=>ldp,content_3824_10172:()=>ydp,content_3824_10174:()=>gdp,content_3824_10176:()=>Mdp,content_3824_10178:()=>wdp,content_3824_1018:()=>Khe,content_3824_10180:()=>xdp,content_3824_10182:()=>Ldp,content_3824_10184:()=>kdp,content_3824_10186:()=>Idp,content_3824_10188:()=>Sdp,content_3824_10190:()=>Edp,content_3824_10192:()=>Fdp,content_3824_10194:()=>jdp,content_3824_10196:()=>Qdp,content_3824_10198:()=>Jdp,content_3824_102:()=>v0,content_3824_1020:()=>ege,content_3824_10200:()=>nhp,content_3824_10202:()=>php,content_3824_10204:()=>chp,content_3824_10206:()=>lhp,content_3824_10208:()=>yhp,content_3824_10210:()=>ghp,content_3824_10212:()=>Mhp,content_3824_10214:()=>whp,content_3824_10216:()=>xhp,content_3824_10218:()=>Lhp,content_3824_1022:()=>oge,content_3824_10220:()=>khp,content_3824_10222:()=>Ihp,content_3824_10224:()=>Shp,content_3824_10226:()=>Ehp,content_3824_10228:()=>Fhp,content_3824_10230:()=>jhp,content_3824_10232:()=>Qhp,content_3824_10234:()=>Jhp,content_3824_10236:()=>ngp,content_3824_10238:()=>pgp,content_3824_1024:()=>sge,content_3824_10240:()=>cgp,content_3824_10242:()=>lgp,content_3824_10244:()=>ygp,content_3824_10246:()=>ggp,content_3824_10248:()=>Mgp,content_3824_10250:()=>wgp,content_3824_10252:()=>xgp,content_3824_10254:()=>Lgp,content_3824_10256:()=>kgp,content_3824_10258:()=>Igp,content_3824_1026:()=>ige,content_3824_10260:()=>Sgp,content_3824_10262:()=>Egp,content_3824_10264:()=>Fgp,content_3824_10266:()=>jgp,content_3824_10268:()=>Qgp,content_3824_10270:()=>Jgp,content_3824_10272:()=>nfp,content_3824_10274:()=>pfp,content_3824_10276:()=>cfp,content_3824_10278:()=>lfp,content_3824_1028:()=>mge,content_3824_10280:()=>yfp,content_3824_10282:()=>gfp,content_3824_10284:()=>Mfp,content_3824_10286:()=>wfp,content_3824_10288:()=>xfp,content_3824_10290:()=>Lfp,content_3824_10292:()=>kfp,content_3824_10294:()=>Ifp,content_3824_10296:()=>Sfp,content_3824_10298:()=>Efp,content_3824_1030:()=>hge,content_3824_10300:()=>Ffp,content_3824_10302:()=>jfp,content_3824_10304:()=>Qfp,content_3824_10306:()=>Jfp,content_3824_10308:()=>nDp,content_3824_10310:()=>pDp,content_3824_10312:()=>cDp,content_3824_10314:()=>lDp,content_3824_10316:()=>yDp,content_3824_10318:()=>gDp,content_3824_1032:()=>Dge,content_3824_10320:()=>MDp,content_3824_10322:()=>wDp,content_3824_10324:()=>xDp,content_3824_10326:()=>LDp,content_3824_10328:()=>kDp,content_3824_10330:()=>IDp,content_3824_10332:()=>SDp,content_3824_10334:()=>EDp,content_3824_10336:()=>FDp,content_3824_10338:()=>jDp,content_3824_1034:()=>_ge,content_3824_10340:()=>QDp,content_3824_10342:()=>JDp,content_3824_10344:()=>nMp,content_3824_10346:()=>pMp,content_3824_10348:()=>cMp,content_3824_10350:()=>lMp,content_3824_10352:()=>yMp,content_3824_10354:()=>gMp,content_3824_10356:()=>MMp,content_3824_10358:()=>wMp,content_3824_1036:()=>Cge,content_3824_10360:()=>xMp,content_3824_10362:()=>LMp,content_3824_10364:()=>kMp,content_3824_10366:()=>IMp,content_3824_10368:()=>SMp,content_3824_10370:()=>EMp,content_3824_10372:()=>FMp,content_3824_10374:()=>jMp,content_3824_10376:()=>QMp,content_3824_10378:()=>JMp,content_3824_1038:()=>vge,content_3824_10380:()=>nXp,content_3824_10382:()=>pXp,content_3824_10384:()=>cXp,content_3824_10386:()=>lXp,content_3824_10388:()=>yXp,content_3824_10390:()=>gXp,content_3824_10392:()=>MXp,content_3824_10394:()=>wXp,content_3824_10396:()=>xXp,content_3824_10398:()=>LXp,content_3824_104:()=>N0,content_3824_1040:()=>Nge,content_3824_10400:()=>kXp,content_3824_10402:()=>IXp,content_3824_10404:()=>SXp,content_3824_10406:()=>EXp,content_3824_10408:()=>FXp,content_3824_10410:()=>jXp,content_3824_10412:()=>QXp,content_3824_10414:()=>JXp,content_3824_10416:()=>n_p,content_3824_10418:()=>p_p,content_3824_1042:()=>Pge,content_3824_10420:()=>c_p,content_3824_10422:()=>l_p,content_3824_10424:()=>y_p,content_3824_10426:()=>g_p,content_3824_10428:()=>M_p,content_3824_10430:()=>w_p,content_3824_10432:()=>x_p,content_3824_10434:()=>L_p,content_3824_10436:()=>k_p,content_3824_10438:()=>I_p,content_3824_1044:()=>Wge,content_3824_10440:()=>S_p,content_3824_10442:()=>E_p,content_3824_10444:()=>F_p,content_3824_10446:()=>j_p,content_3824_10448:()=>Q_p,content_3824_10450:()=>J_p,content_3824_10452:()=>nwp,content_3824_10454:()=>pwp,content_3824_10456:()=>cwp,content_3824_10458:()=>lwp,content_3824_1046:()=>Gge,content_3824_10460:()=>ywp,content_3824_10462:()=>gwp,content_3824_10464:()=>Mwp,content_3824_10466:()=>wwp,content_3824_10468:()=>xwp,content_3824_10470:()=>Lwp,content_3824_10472:()=>kwp,content_3824_10474:()=>Iwp,content_3824_10476:()=>Swp,content_3824_10478:()=>Ewp,content_3824_1048:()=>Uge,content_3824_10480:()=>Fwp,content_3824_10482:()=>jwp,content_3824_10484:()=>Qwp,content_3824_10486:()=>Jwp,content_3824_10488:()=>nTp,content_3824_10490:()=>pTp,content_3824_10492:()=>cTp,content_3824_10494:()=>lTp,content_3824_10496:()=>yTp,content_3824_10498:()=>gTp,content_3824_1050:()=>qge,content_3824_10500:()=>MTp,content_3824_10502:()=>wTp,content_3824_10504:()=>xTp,content_3824_10506:()=>LTp,content_3824_10508:()=>kTp,content_3824_10510:()=>ITp,content_3824_10512:()=>STp,content_3824_10514:()=>ETp,content_3824_10516:()=>FTp,content_3824_10518:()=>jTp,content_3824_1052:()=>Yge,content_3824_10520:()=>QTp,content_3824_10522:()=>JTp,content_3824_10524:()=>nCp,content_3824_10526:()=>pCp,content_3824_10528:()=>cCp,content_3824_10530:()=>lCp,content_3824_10532:()=>yCp,content_3824_10534:()=>gCp,content_3824_10536:()=>MCp,content_3824_10538:()=>wCp,content_3824_1054:()=>Kge,content_3824_10540:()=>xCp,content_3824_10542:()=>LCp,content_3824_10544:()=>kCp,content_3824_10546:()=>ICp,content_3824_10548:()=>SCp,content_3824_10550:()=>ECp,content_3824_10552:()=>FCp,content_3824_10554:()=>jCp,content_3824_10556:()=>QCp,content_3824_10558:()=>JCp,content_3824_1056:()=>efe,content_3824_10560:()=>nxp,content_3824_10562:()=>pxp,content_3824_10564:()=>cxp,content_3824_10566:()=>lxp,content_3824_10568:()=>yxp,content_3824_10570:()=>gxp,content_3824_10572:()=>Mxp,content_3824_10574:()=>wxp,content_3824_10576:()=>xxp,content_3824_10578:()=>Lxp,content_3824_1058:()=>ofe,content_3824_10580:()=>kxp,content_3824_10582:()=>Ixp,content_3824_10584:()=>Sxp,content_3824_10586:()=>Exp,content_3824_10588:()=>Fxp,content_3824_10590:()=>jxp,content_3824_10592:()=>Qxp,content_3824_10594:()=>Jxp,content_3824_10596:()=>nAp,content_3824_10598:()=>pAp,content_3824_106:()=>P0,content_3824_1060:()=>sfe,content_3824_10600:()=>cAp,content_3824_10602:()=>lAp,content_3824_10604:()=>yAp,content_3824_10606:()=>gAp,content_3824_10608:()=>MAp,content_3824_10610:()=>wAp,content_3824_10612:()=>xAp,content_3824_10614:()=>LAp,content_3824_10616:()=>kAp,content_3824_10618:()=>IAp,content_3824_1062:()=>ife,content_3824_10620:()=>SAp,content_3824_10622:()=>EAp,content_3824_10624:()=>FAp,content_3824_10626:()=>jAp,content_3824_10628:()=>QAp,content_3824_10630:()=>JAp,content_3824_10632:()=>nvp,content_3824_10634:()=>pvp,content_3824_10636:()=>cvp,content_3824_10638:()=>lvp,content_3824_1064:()=>mfe,content_3824_10640:()=>yvp,content_3824_10642:()=>gvp,content_3824_10644:()=>Mvp,content_3824_10646:()=>wvp,content_3824_10648:()=>xvp,content_3824_10650:()=>Lvp,content_3824_10652:()=>kvp,content_3824_10654:()=>Ivp,content_3824_10656:()=>Svp,content_3824_10658:()=>Evp,content_3824_1066:()=>hfe,content_3824_10660:()=>Fvp,content_3824_10662:()=>jvp,content_3824_10664:()=>Qvp,content_3824_10666:()=>Jvp,content_3824_10668:()=>nLp,content_3824_10670:()=>pLp,content_3824_10672:()=>cLp,content_3824_10674:()=>lLp,content_3824_10676:()=>yLp,content_3824_10678:()=>gLp,content_3824_1068:()=>Dfe,content_3824_10680:()=>MLp,content_3824_10682:()=>wLp,content_3824_10684:()=>xLp,content_3824_10686:()=>LLp,content_3824_10688:()=>kLp,content_3824_10690:()=>ILp,content_3824_10692:()=>SLp,content_3824_10694:()=>ELp,content_3824_10696:()=>FLp,content_3824_10698:()=>jLp,content_3824_1070:()=>_fe,content_3824_10700:()=>QLp,content_3824_10702:()=>JLp,content_3824_10704:()=>nbp,content_3824_10706:()=>pbp,content_3824_10708:()=>cbp,content_3824_10710:()=>lbp,content_3824_10712:()=>ybp,content_3824_10714:()=>gbp,content_3824_10716:()=>Mbp,content_3824_10718:()=>wbp,content_3824_1072:()=>Cfe,content_3824_10720:()=>xbp,content_3824_10722:()=>Lbp,content_3824_10724:()=>kbp,content_3824_10726:()=>Ibp,content_3824_10728:()=>Sbp,content_3824_10730:()=>Ebp,content_3824_10732:()=>Fbp,content_3824_10734:()=>jbp,content_3824_10736:()=>Qbp,content_3824_10738:()=>Jbp,content_3824_1074:()=>vfe,content_3824_10740:()=>nNp,content_3824_10742:()=>pNp,content_3824_10744:()=>cNp,content_3824_10746:()=>lNp,content_3824_10748:()=>yNp,content_3824_10750:()=>gNp,content_3824_10752:()=>MNp,content_3824_10754:()=>wNp,content_3824_10756:()=>xNp,content_3824_10758:()=>LNp,content_3824_1076:()=>Nfe,content_3824_10760:()=>kNp,content_3824_10762:()=>INp,content_3824_10764:()=>SNp,content_3824_10766:()=>ENp,content_3824_10768:()=>FNp,content_3824_10770:()=>jNp,content_3824_10772:()=>QNp,content_3824_10774:()=>JNp,content_3824_10776:()=>nkp,content_3824_10778:()=>pkp,content_3824_1078:()=>Pfe,content_3824_10780:()=>ckp,content_3824_10782:()=>lkp,content_3824_10784:()=>ykp,content_3824_10786:()=>gkp,content_3824_10788:()=>Mkp,content_3824_10790:()=>wkp,content_3824_10792:()=>xkp,content_3824_10794:()=>Lkp,content_3824_10796:()=>kkp,content_3824_10798:()=>Ikp,content_3824_108:()=>W0,content_3824_1080:()=>Wfe,content_3824_10800:()=>Skp,content_3824_10802:()=>Ekp,content_3824_10804:()=>Fkp,content_3824_10806:()=>jkp,content_3824_10808:()=>Qkp,content_3824_10810:()=>Jkp,content_3824_10812:()=>nzp,content_3824_10814:()=>pzp,content_3824_10816:()=>czp,content_3824_10818:()=>lzp,content_3824_1082:()=>Gfe,content_3824_10820:()=>yzp,content_3824_10822:()=>gzp,content_3824_10824:()=>Mzp,content_3824_10826:()=>wzp,content_3824_10828:()=>xzp,content_3824_10830:()=>Lzp,content_3824_10832:()=>kzp,content_3824_10834:()=>Izp,content_3824_10836:()=>Szp,content_3824_10838:()=>Ezp,content_3824_1084:()=>Ufe,content_3824_10840:()=>Fzp,content_3824_10842:()=>jzp,content_3824_10844:()=>Qzp,content_3824_10846:()=>Jzp,content_3824_10848:()=>nPp,content_3824_10850:()=>pPp,content_3824_10852:()=>cPp,content_3824_10854:()=>lPp,content_3824_10856:()=>yPp,content_3824_10858:()=>gPp,content_3824_1086:()=>qfe,content_3824_10860:()=>MPp,content_3824_10862:()=>wPp,content_3824_10864:()=>xPp,content_3824_10866:()=>LPp,content_3824_10868:()=>kPp,content_3824_10870:()=>IPp,content_3824_10872:()=>SPp,content_3824_10874:()=>EPp,content_3824_10876:()=>FPp,content_3824_10878:()=>jPp,content_3824_1088:()=>Yfe,content_3824_10880:()=>QPp,content_3824_10882:()=>JPp,content_3824_10884:()=>nIp,content_3824_10886:()=>pIp,content_3824_10888:()=>cIp,content_3824_10890:()=>lIp,content_3824_10892:()=>yIp,content_3824_10894:()=>gIp,content_3824_10896:()=>MIp,content_3824_10898:()=>wIp,content_3824_1090:()=>Kfe,content_3824_10900:()=>xIp,content_3824_10902:()=>LIp,content_3824_10904:()=>kIp,content_3824_10906:()=>IIp,content_3824_10908:()=>SIp,content_3824_10910:()=>EIp,content_3824_10912:()=>FIp,content_3824_10914:()=>jIp,content_3824_10916:()=>QIp,content_3824_10918:()=>JIp,content_3824_1092:()=>eDe,content_3824_10920:()=>nRp,content_3824_10922:()=>pRp,content_3824_10924:()=>cRp,content_3824_10926:()=>lRp,content_3824_10928:()=>yRp,content_3824_10930:()=>gRp,content_3824_10932:()=>MRp,content_3824_10934:()=>wRp,content_3824_10936:()=>xRp,content_3824_10938:()=>LRp,content_3824_1094:()=>oDe,content_3824_10940:()=>kRp,content_3824_10942:()=>IRp,content_3824_10944:()=>SRp,content_3824_10946:()=>ERp,content_3824_10948:()=>FRp,content_3824_10950:()=>jRp,content_3824_10952:()=>QRp,content_3824_10954:()=>JRp,content_3824_10956:()=>nWp,content_3824_10958:()=>pWp,content_3824_1096:()=>sDe,content_3824_10960:()=>cWp,content_3824_10962:()=>lWp,content_3824_10964:()=>yWp,content_3824_10966:()=>gWp,content_3824_10968:()=>MWp,content_3824_10970:()=>wWp,content_3824_10972:()=>xWp,content_3824_10974:()=>LWp,content_3824_10976:()=>kWp,content_3824_10978:()=>IWp,content_3824_1098:()=>iDe,content_3824_10980:()=>SWp,content_3824_10982:()=>EWp,content_3824_10984:()=>FWp,content_3824_10986:()=>jWp,content_3824_10988:()=>QWp,content_3824_10990:()=>JWp,content_3824_10992:()=>nSp,content_3824_10994:()=>pSp,content_3824_10996:()=>cSp,content_3824_10998:()=>lSp,content_3824_110:()=>G0,content_3824_1100:()=>mDe,content_3824_11000:()=>ySp,content_3824_11002:()=>gSp,content_3824_11004:()=>MSp,content_3824_11006:()=>wSp,content_3824_11008:()=>xSp,content_3824_11010:()=>LSp,content_3824_11012:()=>kSp,content_3824_11014:()=>ISp,content_3824_11016:()=>SSp,content_3824_11018:()=>ESp,content_3824_1102:()=>hDe,content_3824_11020:()=>FSp,content_3824_11022:()=>jSp,content_3824_11024:()=>QSp,content_3824_11026:()=>JSp,content_3824_11028:()=>nBp,content_3824_11030:()=>pBp,content_3824_11032:()=>cBp,content_3824_11034:()=>lBp,content_3824_11036:()=>yBp,content_3824_11038:()=>gBp,content_3824_1104:()=>DDe,content_3824_11040:()=>MBp,content_3824_11042:()=>wBp,content_3824_11044:()=>xBp,content_3824_11046:()=>LBp,content_3824_11048:()=>kBp,content_3824_11050:()=>IBp,content_3824_11052:()=>SBp,content_3824_11054:()=>EBp,content_3824_11056:()=>FBp,content_3824_11058:()=>jBp,content_3824_1106:()=>_De,content_3824_11060:()=>QBp,content_3824_11062:()=>JBp,content_3824_11064:()=>nGp,content_3824_11066:()=>pGp,content_3824_11068:()=>cGp,content_3824_11070:()=>lGp,content_3824_11072:()=>yGp,content_3824_11074:()=>gGp,content_3824_11076:()=>MGp,content_3824_11078:()=>wGp,content_3824_1108:()=>CDe,content_3824_11080:()=>xGp,content_3824_11082:()=>LGp,content_3824_11084:()=>kGp,content_3824_11086:()=>IGp,content_3824_11088:()=>SGp,content_3824_11090:()=>EGp,content_3824_11092:()=>FGp,content_3824_11094:()=>jGp,content_3824_11096:()=>QGp,content_3824_11098:()=>JGp,content_3824_1110:()=>vDe,content_3824_11100:()=>nEp,content_3824_11102:()=>pEp,content_3824_11104:()=>cEp,content_3824_11106:()=>lEp,content_3824_11108:()=>yEp,content_3824_11110:()=>gEp,content_3824_11112:()=>MEp,content_3824_11114:()=>wEp,content_3824_11116:()=>xEp,content_3824_11118:()=>LEp,content_3824_1112:()=>NDe,content_3824_11120:()=>kEp,content_3824_11122:()=>IEp,content_3824_11124:()=>SEp,content_3824_11126:()=>EEp,content_3824_11128:()=>FEp,content_3824_11130:()=>jEp,content_3824_11132:()=>QEp,content_3824_11134:()=>JEp,content_3824_11136:()=>nOp,content_3824_11138:()=>pOp,content_3824_1114:()=>PDe,content_3824_11140:()=>cOp,content_3824_11142:()=>lOp,content_3824_11144:()=>yOp,content_3824_11146:()=>gOp,content_3824_11148:()=>MOp,content_3824_11150:()=>wOp,content_3824_11152:()=>xOp,content_3824_11154:()=>LOp,content_3824_11156:()=>kOp,content_3824_11158:()=>IOp,content_3824_1116:()=>WDe,content_3824_11160:()=>SOp,content_3824_11162:()=>EOp,content_3824_11164:()=>FOp,content_3824_11166:()=>jOp,content_3824_11168:()=>QOp,content_3824_11170:()=>JOp,content_3824_11172:()=>nUp,content_3824_11174:()=>pUp,content_3824_11176:()=>cUp,content_3824_11178:()=>lUp,content_3824_1118:()=>GDe,content_3824_11180:()=>yUp,content_3824_11182:()=>gUp,content_3824_11184:()=>MUp,content_3824_11186:()=>wUp,content_3824_11188:()=>xUp,content_3824_11190:()=>LUp,content_3824_11192:()=>kUp,content_3824_11194:()=>IUp,content_3824_11196:()=>SUp,content_3824_11198:()=>EUp,content_3824_112:()=>U0,content_3824_1120:()=>UDe,content_3824_11200:()=>FUp,content_3824_11202:()=>jUp,content_3824_11204:()=>QUp,content_3824_11206:()=>JUp,content_3824_11208:()=>nFp,content_3824_11210:()=>pFp,content_3824_11212:()=>cFp,content_3824_11214:()=>lFp,content_3824_11216:()=>yFp,content_3824_11218:()=>gFp,content_3824_1122:()=>qDe,content_3824_11220:()=>MFp,content_3824_11222:()=>wFp,content_3824_11224:()=>xFp,content_3824_11226:()=>LFp,content_3824_11228:()=>kFp,content_3824_11230:()=>IFp,content_3824_11232:()=>SFp,content_3824_11234:()=>EFp,content_3824_11236:()=>FFp,content_3824_11238:()=>jFp,content_3824_1124:()=>YDe,content_3824_11240:()=>QFp,content_3824_11242:()=>JFp,content_3824_11244:()=>nVp,content_3824_11246:()=>pVp,content_3824_11248:()=>cVp,content_3824_11250:()=>lVp,content_3824_11252:()=>yVp,content_3824_11254:()=>gVp,content_3824_11256:()=>MVp,content_3824_11258:()=>wVp,content_3824_1126:()=>KDe,content_3824_11260:()=>xVp,content_3824_11262:()=>LVp,content_3824_11264:()=>kVp,content_3824_11266:()=>IVp,content_3824_11268:()=>SVp,content_3824_11270:()=>EVp,content_3824_11272:()=>FVp,content_3824_11274:()=>jVp,content_3824_11276:()=>QVp,content_3824_11278:()=>JVp,content_3824_1128:()=>eMe,content_3824_11280:()=>nqp,content_3824_11282:()=>pqp,content_3824_11284:()=>cqp,content_3824_11286:()=>lqp,content_3824_11288:()=>yqp,content_3824_11290:()=>gqp,content_3824_11292:()=>Mqp,content_3824_11294:()=>wqp,content_3824_11296:()=>xqp,content_3824_11298:()=>Lqp,content_3824_1130:()=>oMe,content_3824_11300:()=>kqp,content_3824_11302:()=>Iqp,content_3824_11304:()=>Sqp,content_3824_11306:()=>Eqp,content_3824_11308:()=>Fqp,content_3824_11310:()=>jqp,content_3824_11312:()=>Qqp,content_3824_11314:()=>Jqp,content_3824_11316:()=>njp,content_3824_11318:()=>pjp,content_3824_1132:()=>sMe,content_3824_11320:()=>cjp,content_3824_11322:()=>ljp,content_3824_11324:()=>yjp,content_3824_11326:()=>gjp,content_3824_11328:()=>Mjp,content_3824_11330:()=>wjp,content_3824_11332:()=>xjp,content_3824_11334:()=>Ljp,content_3824_11336:()=>kjp,content_3824_11338:()=>Ijp,content_3824_1134:()=>iMe,content_3824_11340:()=>Sjp,content_3824_11342:()=>Ejp,content_3824_11344:()=>Fjp,content_3824_11346:()=>jjp,content_3824_11348:()=>Qjp,content_3824_11350:()=>Jjp,content_3824_11352:()=>nHp,content_3824_11354:()=>pHp,content_3824_11356:()=>cHp,content_3824_11358:()=>lHp,content_3824_1136:()=>mMe,content_3824_11360:()=>yHp,content_3824_11362:()=>gHp,content_3824_11364:()=>MHp,content_3824_11366:()=>wHp,content_3824_11368:()=>xHp,content_3824_11370:()=>LHp,content_3824_11372:()=>kHp,content_3824_11374:()=>IHp,content_3824_11376:()=>SHp,content_3824_11378:()=>EHp,content_3824_1138:()=>hMe,content_3824_11380:()=>FHp,content_3824_11382:()=>jHp,content_3824_11384:()=>QHp,content_3824_11386:()=>JHp,content_3824_11388:()=>nYp,content_3824_11390:()=>pYp,content_3824_11392:()=>cYp,content_3824_11394:()=>lYp,content_3824_11396:()=>yYp,content_3824_11398:()=>gYp,content_3824_114:()=>q0,content_3824_1140:()=>DMe,content_3824_11400:()=>MYp,content_3824_11402:()=>wYp,content_3824_11404:()=>xYp,content_3824_11406:()=>LYp,content_3824_11408:()=>kYp,content_3824_11410:()=>IYp,content_3824_11412:()=>SYp,content_3824_11414:()=>EYp,content_3824_11416:()=>FYp,content_3824_11418:()=>jYp,content_3824_1142:()=>_Me,content_3824_11420:()=>QYp,content_3824_11422:()=>JYp,content_3824_11424:()=>nQp,content_3824_11426:()=>pQp,content_3824_11428:()=>cQp,content_3824_11430:()=>lQp,content_3824_11432:()=>yQp,content_3824_11434:()=>gQp,content_3824_11436:()=>MQp,content_3824_11438:()=>wQp,content_3824_1144:()=>CMe,content_3824_11440:()=>xQp,content_3824_11442:()=>LQp,content_3824_11444:()=>kQp,content_3824_11446:()=>IQp,content_3824_11448:()=>SQp,content_3824_11450:()=>EQp,content_3824_11452:()=>FQp,content_3824_11454:()=>jQp,content_3824_11456:()=>QQp,content_3824_11458:()=>JQp,content_3824_1146:()=>vMe,content_3824_11460:()=>n$p,content_3824_11462:()=>p$p,content_3824_11464:()=>c$p,content_3824_11466:()=>l$p,content_3824_11468:()=>y$p,content_3824_11470:()=>g$p,content_3824_11472:()=>M$p,content_3824_11474:()=>w$p,content_3824_11476:()=>x$p,content_3824_11478:()=>L$p,content_3824_1148:()=>NMe,content_3824_11480:()=>k$p,content_3824_11482:()=>I$p,content_3824_11484:()=>S$p,content_3824_11486:()=>E$p,content_3824_11488:()=>F$p,content_3824_11490:()=>j$p,content_3824_11492:()=>Q$p,content_3824_11494:()=>J$p,content_3824_11496:()=>nKp,content_3824_11498:()=>pKp,content_3824_1150:()=>PMe,content_3824_11500:()=>cKp,content_3824_11502:()=>lKp,content_3824_11504:()=>yKp,content_3824_11506:()=>gKp,content_3824_11508:()=>MKp,content_3824_11510:()=>wKp,content_3824_11512:()=>xKp,content_3824_11514:()=>LKp,content_3824_11516:()=>kKp,content_3824_11518:()=>IKp,content_3824_1152:()=>WMe,content_3824_11520:()=>SKp,content_3824_11522:()=>EKp,content_3824_11524:()=>FKp,content_3824_11526:()=>jKp,content_3824_11528:()=>QKp,content_3824_11530:()=>JKp,content_3824_11532:()=>nJp,content_3824_11534:()=>pJp,content_3824_11536:()=>cJp,content_3824_11538:()=>lJp,content_3824_1154:()=>GMe,content_3824_11540:()=>yJp,content_3824_11542:()=>gJp,content_3824_11544:()=>MJp,content_3824_11546:()=>wJp,content_3824_11548:()=>xJp,content_3824_11550:()=>LJp,content_3824_11552:()=>kJp,content_3824_11554:()=>IJp,content_3824_11556:()=>SJp,content_3824_11558:()=>EJp,content_3824_1156:()=>UMe,content_3824_11560:()=>FJp,content_3824_11562:()=>jJp,content_3824_11564:()=>QJp,content_3824_11566:()=>JJp,content_3824_11568:()=>nZp,content_3824_11570:()=>pZp,content_3824_11572:()=>cZp,content_3824_11574:()=>lZp,content_3824_11576:()=>yZp,content_3824_11578:()=>gZp,content_3824_1158:()=>qMe,content_3824_11580:()=>MZp,content_3824_11582:()=>wZp,content_3824_11584:()=>xZp,content_3824_11586:()=>LZp,content_3824_11588:()=>kZp,content_3824_11590:()=>IZp,content_3824_11592:()=>SZp,content_3824_11594:()=>EZp,content_3824_11596:()=>FZp,content_3824_11598:()=>jZp,content_3824_116:()=>Y0,content_3824_1160:()=>YMe,content_3824_11600:()=>QZp,content_3824_11602:()=>JZp,content_3824_11604:()=>n0p,content_3824_11606:()=>p0p,content_3824_11608:()=>c0p,content_3824_11610:()=>l0p,content_3824_11612:()=>y0p,content_3824_11614:()=>g0p,content_3824_11616:()=>M0p,content_3824_11618:()=>w0p,content_3824_1162:()=>KMe,content_3824_11620:()=>x0p,content_3824_11622:()=>L0p,content_3824_11624:()=>k0p,content_3824_11626:()=>I0p,content_3824_11628:()=>S0p,content_3824_11630:()=>E0p,content_3824_11632:()=>F0p,content_3824_11634:()=>j0p,content_3824_11636:()=>Q0p,content_3824_11638:()=>J0p,content_3824_1164:()=>eXe,content_3824_11640:()=>n2p,content_3824_11642:()=>p2p,content_3824_11644:()=>c2p,content_3824_11646:()=>l2p,content_3824_11648:()=>y2p,content_3824_11650:()=>g2p,content_3824_11652:()=>M2p,content_3824_11654:()=>w2p,content_3824_11656:()=>x2p,content_3824_11658:()=>L2p,content_3824_1166:()=>oXe,content_3824_11660:()=>k2p,content_3824_11662:()=>I2p,content_3824_11664:()=>S2p,content_3824_11666:()=>E2p,content_3824_11668:()=>F2p,content_3824_11670:()=>j2p,content_3824_11672:()=>Q2p,content_3824_11674:()=>J2p,content_3824_11676:()=>n4p,content_3824_11678:()=>p4p,content_3824_1168:()=>sXe,content_3824_11680:()=>c4p,content_3824_11682:()=>l4p,content_3824_11684:()=>y4p,content_3824_11686:()=>g4p,content_3824_11688:()=>M4p,content_3824_11690:()=>w4p,content_3824_11692:()=>x4p,content_3824_11694:()=>L4p,content_3824_11696:()=>k4p,content_3824_11698:()=>I4p,content_3824_1170:()=>iXe,content_3824_11700:()=>S4p,content_3824_11702:()=>E4p,content_3824_11704:()=>F4p,content_3824_11706:()=>j4p,content_3824_11708:()=>Q4p,content_3824_11710:()=>J4p,content_3824_11712:()=>n8p,content_3824_11714:()=>p8p,content_3824_11716:()=>c8p,content_3824_11718:()=>l8p,content_3824_1172:()=>mXe,content_3824_11720:()=>y8p,content_3824_11722:()=>g8p,content_3824_11724:()=>M8p,content_3824_11726:()=>w8p,content_3824_11728:()=>x8p,content_3824_11730:()=>L8p,content_3824_11732:()=>k8p,content_3824_11734:()=>I8p,content_3824_11736:()=>S8p,content_3824_11738:()=>E8p,content_3824_1174:()=>hXe,content_3824_11740:()=>F8p,content_3824_11742:()=>j8p,content_3824_11744:()=>Q8p,content_3824_11746:()=>J8p,content_3824_11748:()=>n3p,content_3824_11750:()=>p3p,content_3824_11752:()=>c3p,content_3824_11754:()=>l3p,content_3824_11756:()=>y3p,content_3824_11758:()=>g3p,content_3824_1176:()=>DXe,content_3824_11760:()=>M3p,content_3824_11762:()=>w3p,content_3824_11764:()=>x3p,content_3824_11766:()=>L3p,content_3824_11768:()=>k3p,content_3824_11770:()=>I3p,content_3824_11772:()=>S3p,content_3824_11774:()=>E3p,content_3824_11776:()=>F3p,content_3824_11778:()=>j3p,content_3824_1178:()=>_Xe,content_3824_11780:()=>Q3p,content_3824_11782:()=>J3p,content_3824_11784:()=>n1p,content_3824_11786:()=>p1p,content_3824_11788:()=>c1p,content_3824_11790:()=>l1p,content_3824_11792:()=>y1p,content_3824_11794:()=>g1p,content_3824_11796:()=>M1p,content_3824_11798:()=>w1p,content_3824_118:()=>K0,content_3824_1180:()=>CXe,content_3824_11800:()=>x1p,content_3824_11802:()=>L1p,content_3824_11804:()=>k1p,content_3824_11806:()=>I1p,content_3824_11808:()=>S1p,content_3824_11810:()=>E1p,content_3824_11812:()=>F1p,content_3824_11814:()=>j1p,content_3824_11816:()=>Q1p,content_3824_11818:()=>J1p,content_3824_1182:()=>vXe,content_3824_11820:()=>n6p,content_3824_11822:()=>p6p,content_3824_11824:()=>c6p,content_3824_11826:()=>l6p,content_3824_11828:()=>y6p,content_3824_11830:()=>g6p,content_3824_11832:()=>M6p,content_3824_11834:()=>w6p,content_3824_11836:()=>x6p,content_3824_11838:()=>L6p,content_3824_1184:()=>NXe,content_3824_11840:()=>k6p,content_3824_11842:()=>I6p,content_3824_11844:()=>S6p,content_3824_11846:()=>E6p,content_3824_11848:()=>F6p,content_3824_11850:()=>j6p,content_3824_11852:()=>Q6p,content_3824_11854:()=>J6p,content_3824_11856:()=>n5p,content_3824_11858:()=>p5p,content_3824_1186:()=>PXe,content_3824_11860:()=>c5p,content_3824_11862:()=>l5p,content_3824_11864:()=>y5p,content_3824_11866:()=>g5p,content_3824_11868:()=>M5p,content_3824_11870:()=>w5p,content_3824_11872:()=>x5p,content_3824_11874:()=>L5p,content_3824_11876:()=>k5p,content_3824_11878:()=>I5p,content_3824_1188:()=>WXe,content_3824_11880:()=>S5p,content_3824_11882:()=>E5p,content_3824_11884:()=>F5p,content_3824_11886:()=>j5p,content_3824_11888:()=>Q5p,content_3824_11890:()=>J5p,content_3824_11892:()=>n7p,content_3824_11894:()=>p7p,content_3824_11896:()=>c7p,content_3824_11898:()=>l7p,content_3824_1190:()=>GXe,content_3824_11900:()=>y7p,content_3824_11902:()=>g7p,content_3824_11904:()=>M7p,content_3824_11906:()=>w7p,content_3824_11908:()=>x7p,content_3824_11910:()=>L7p,content_3824_11912:()=>k7p,content_3824_11914:()=>I7p,content_3824_11916:()=>S7p,content_3824_11918:()=>E7p,content_3824_1192:()=>UXe,content_3824_11920:()=>F7p,content_3824_11922:()=>j7p,content_3824_11924:()=>Q7p,content_3824_11926:()=>J7p,content_3824_11928:()=>n9p,content_3824_11930:()=>p9p,content_3824_11932:()=>c9p,content_3824_11934:()=>l9p,content_3824_11936:()=>y9p,content_3824_11938:()=>g9p,content_3824_1194:()=>qXe,content_3824_11940:()=>M9p,content_3824_11942:()=>w9p,content_3824_11944:()=>x9p,content_3824_11946:()=>L9p,content_3824_11948:()=>k9p,content_3824_11950:()=>I9p,content_3824_11952:()=>S9p,content_3824_11954:()=>E9p,content_3824_11956:()=>F9p,content_3824_11958:()=>j9p,content_3824_1196:()=>YXe,content_3824_11960:()=>Q9p,content_3824_11962:()=>J9p,content_3824_11964:()=>ner,content_3824_11966:()=>per,content_3824_11968:()=>cer,content_3824_11970:()=>ler,content_3824_11972:()=>yer,content_3824_11974:()=>ger,content_3824_11976:()=>Mer,content_3824_11978:()=>wer,content_3824_1198:()=>KXe,content_3824_11980:()=>xer,content_3824_11982:()=>Ler,content_3824_11984:()=>ker,content_3824_11986:()=>Ier,content_3824_11988:()=>Ser,content_3824_11990:()=>Eer,content_3824_11992:()=>Fer,content_3824_11994:()=>jer,content_3824_11996:()=>Qer,content_3824_11998:()=>Jer,content_3824_12:()=>eJ,content_3824_120:()=>e2,content_3824_1200:()=>e_e,content_3824_12000:()=>nnr,content_3824_12002:()=>pnr,content_3824_12004:()=>cnr,content_3824_12006:()=>lnr,content_3824_12008:()=>ynr,content_3824_12010:()=>gnr,content_3824_12012:()=>Mnr,content_3824_12014:()=>wnr,content_3824_12016:()=>xnr,content_3824_12018:()=>Lnr,content_3824_1202:()=>o_e,content_3824_12020:()=>knr,content_3824_12022:()=>Inr,content_3824_12024:()=>Snr,content_3824_12026:()=>Enr,content_3824_12028:()=>Fnr,content_3824_12030:()=>jnr,content_3824_12032:()=>Qnr,content_3824_12034:()=>Jnr,content_3824_12036:()=>ntr,content_3824_12038:()=>ptr,content_3824_1204:()=>s_e,content_3824_12040:()=>ctr,content_3824_12042:()=>ltr,content_3824_12044:()=>ytr,content_3824_12046:()=>gtr,content_3824_12048:()=>Mtr,content_3824_12050:()=>wtr,content_3824_12052:()=>xtr,content_3824_12054:()=>Ltr,content_3824_12056:()=>ktr,content_3824_12058:()=>Itr,content_3824_1206:()=>i_e,content_3824_12060:()=>Str,content_3824_12062:()=>Etr,content_3824_12064:()=>Ftr,content_3824_12066:()=>jtr,content_3824_12068:()=>Qtr,content_3824_12070:()=>Jtr,content_3824_12072:()=>nor,content_3824_12074:()=>por,content_3824_12076:()=>cor,content_3824_12078:()=>lor,content_3824_1208:()=>m_e,content_3824_12080:()=>yor,content_3824_12082:()=>gor,content_3824_12084:()=>Xor,content_3824_12086:()=>Tor,content_3824_12088:()=>Aor,content_3824_12090:()=>bor,content_3824_12092:()=>zor,content_3824_12094:()=>Ror,content_3824_12096:()=>Bor,content_3824_12098:()=>Oor,content_3824_1210:()=>h_e,content_3824_12100:()=>Vor,content_3824_12102:()=>Hor,content_3824_12104:()=>$or,content_3824_12106:()=>Zor,content_3824_12108:()=>tpr,content_3824_12110:()=>rpr,content_3824_12112:()=>apr,content_3824_12114:()=>upr,content_3824_12116:()=>dpr,content_3824_12118:()=>fpr,content_3824_1212:()=>D_e,content_3824_12120:()=>Xpr,content_3824_12122:()=>Tpr,content_3824_12124:()=>Apr,content_3824_12126:()=>bpr,content_3824_12128:()=>zpr,content_3824_12130:()=>Rpr,content_3824_12132:()=>Bpr,content_3824_12134:()=>Opr,content_3824_12136:()=>Vpr,content_3824_12138:()=>Hpr,content_3824_1214:()=>__e,content_3824_12140:()=>$pr,content_3824_12142:()=>Zpr,content_3824_12144:()=>trr,content_3824_12146:()=>rrr,content_3824_12148:()=>arr,content_3824_12150:()=>urr,content_3824_12152:()=>drr,content_3824_12154:()=>frr,content_3824_12156:()=>Xrr,content_3824_12158:()=>Trr,content_3824_1216:()=>C_e,content_3824_12160:()=>Arr,content_3824_12162:()=>brr,content_3824_12164:()=>zrr,content_3824_12166:()=>Rrr,content_3824_12168:()=>Brr,content_3824_12170:()=>Orr,content_3824_12172:()=>Vrr,content_3824_12174:()=>Hrr,content_3824_12176:()=>$rr,content_3824_12178:()=>Zrr,content_3824_1218:()=>v_e,content_3824_12180:()=>tsr,content_3824_12182:()=>rsr,content_3824_12184:()=>asr,content_3824_12186:()=>usr,content_3824_12188:()=>dsr,content_3824_12190:()=>fsr,content_3824_12192:()=>Xsr,content_3824_12194:()=>Tsr,content_3824_12196:()=>Asr,content_3824_12198:()=>bsr,content_3824_122:()=>o2,content_3824_1220:()=>N_e,content_3824_12200:()=>zsr,content_3824_12202:()=>Rsr,content_3824_12204:()=>Bsr,content_3824_12206:()=>Osr,content_3824_12208:()=>Vsr,content_3824_12210:()=>Hsr,content_3824_12212:()=>$sr,content_3824_12214:()=>Zsr,content_3824_12216:()=>tcr,content_3824_12218:()=>rcr,content_3824_1222:()=>P_e,content_3824_12220:()=>acr,content_3824_12222:()=>ucr,content_3824_12224:()=>dcr,content_3824_12226:()=>fcr,content_3824_12228:()=>Xcr,content_3824_12230:()=>Tcr,content_3824_12232:()=>Acr,content_3824_12234:()=>bcr,content_3824_12236:()=>zcr,content_3824_12238:()=>Rcr,content_3824_1224:()=>W_e,content_3824_12240:()=>Bcr,content_3824_12242:()=>Ocr,content_3824_12244:()=>Vcr,content_3824_12246:()=>Hcr,content_3824_12248:()=>$cr,content_3824_12250:()=>Zcr,content_3824_12252:()=>tar,content_3824_12254:()=>rar,content_3824_12256:()=>aar,content_3824_12258:()=>uar,content_3824_1226:()=>G_e,content_3824_12260:()=>dar,content_3824_12262:()=>far,content_3824_12264:()=>Xar,content_3824_12266:()=>Tar,content_3824_12268:()=>Aar,content_3824_12270:()=>Nar,content_3824_12272:()=>Par,content_3824_12274:()=>War,content_3824_12276:()=>Gar,content_3824_12278:()=>Uar,content_3824_1228:()=>U_e,content_3824_12280:()=>qar,content_3824_12282:()=>Yar,content_3824_12284:()=>Kar,content_3824_12286:()=>eir,content_3824_12288:()=>oir,content_3824_12290:()=>sir,content_3824_12292:()=>iir,content_3824_12294:()=>mir,content_3824_12296:()=>hir,content_3824_12298:()=>Dir,content_3824_1230:()=>q_e,content_3824_12300:()=>_ir,content_3824_12302:()=>Cir,content_3824_12304:()=>vir,content_3824_12306:()=>Nir,content_3824_12308:()=>Pir,content_3824_12310:()=>Wir,content_3824_12312:()=>Gir,content_3824_12314:()=>Uir,content_3824_12316:()=>qir,content_3824_12318:()=>Yir,content_3824_1232:()=>Y_e,content_3824_12320:()=>Kir,content_3824_12322:()=>elr,content_3824_12324:()=>olr,content_3824_12326:()=>slr,content_3824_12328:()=>ilr,content_3824_12330:()=>mlr,content_3824_12332:()=>hlr,content_3824_12334:()=>Dlr,content_3824_12336:()=>_lr,content_3824_12338:()=>Clr,content_3824_1234:()=>K_e,content_3824_12340:()=>vlr,content_3824_12342:()=>Nlr,content_3824_12344:()=>Plr,content_3824_12346:()=>Wlr,content_3824_12348:()=>Glr,content_3824_12350:()=>Ulr,content_3824_12352:()=>qlr,content_3824_12354:()=>Ylr,content_3824_12356:()=>Klr,content_3824_12358:()=>eur,content_3824_1236:()=>ewe,content_3824_12360:()=>our,content_3824_12362:()=>sur,content_3824_12364:()=>iur,content_3824_12366:()=>mur,content_3824_12368:()=>hur,content_3824_12370:()=>Dur,content_3824_12372:()=>_ur,content_3824_12374:()=>Cur,content_3824_12376:()=>vur,content_3824_12378:()=>Nur,content_3824_1238:()=>owe,content_3824_12380:()=>Pur,content_3824_12382:()=>Wur,content_3824_12384:()=>Gur,content_3824_12386:()=>Uur,content_3824_12388:()=>qur,content_3824_12390:()=>Yur,content_3824_12392:()=>Kur,content_3824_12394:()=>emr,content_3824_12396:()=>omr,content_3824_12398:()=>smr,content_3824_124:()=>s2,content_3824_1240:()=>swe,content_3824_12400:()=>imr,content_3824_12402:()=>mmr,content_3824_12404:()=>hmr,content_3824_12406:()=>Dmr,content_3824_12408:()=>_mr,content_3824_12410:()=>Cmr,content_3824_12412:()=>vmr,content_3824_12414:()=>Nmr,content_3824_12416:()=>Pmr,content_3824_12418:()=>Wmr,content_3824_1242:()=>iwe,content_3824_12420:()=>Gmr,content_3824_12422:()=>Umr,content_3824_12424:()=>qmr,content_3824_12426:()=>Ymr,content_3824_12428:()=>Kmr,content_3824_12430:()=>eyr,content_3824_12432:()=>oyr,content_3824_12434:()=>syr,content_3824_12436:()=>iyr,content_3824_12438:()=>myr,content_3824_1244:()=>mwe,content_3824_12440:()=>hyr,content_3824_12442:()=>Dyr,content_3824_12444:()=>_yr,content_3824_12446:()=>Cyr,content_3824_12448:()=>vyr,content_3824_12450:()=>Nyr,content_3824_12452:()=>Pyr,content_3824_12454:()=>Wyr,content_3824_12456:()=>Gyr,content_3824_12458:()=>Uyr,content_3824_1246:()=>hwe,content_3824_12460:()=>qyr,content_3824_12462:()=>Yyr,content_3824_12464:()=>Kyr,content_3824_12466:()=>edr,content_3824_12468:()=>odr,content_3824_12470:()=>sdr,content_3824_12472:()=>idr,content_3824_12474:()=>mdr,content_3824_12476:()=>hdr,content_3824_12478:()=>Ddr,content_3824_1248:()=>Dwe,content_3824_12480:()=>_dr,content_3824_12482:()=>Cdr,content_3824_12484:()=>vdr,content_3824_12486:()=>Ndr,content_3824_12488:()=>Pdr,content_3824_12490:()=>Wdr,content_3824_12492:()=>Gdr,content_3824_12494:()=>Udr,content_3824_12496:()=>qdr,content_3824_12498:()=>Ydr,content_3824_1250:()=>_we,content_3824_12500:()=>Kdr,content_3824_12502:()=>ehr,content_3824_12504:()=>ohr,content_3824_12506:()=>shr,content_3824_12508:()=>ihr,content_3824_12510:()=>mhr,content_3824_12512:()=>hhr,content_3824_12514:()=>Dhr,content_3824_12516:()=>_hr,content_3824_12518:()=>Chr,content_3824_1252:()=>Cwe,content_3824_12520:()=>vhr,content_3824_12522:()=>Nhr,content_3824_12524:()=>Phr,content_3824_12526:()=>Whr,content_3824_12528:()=>Ghr,content_3824_12530:()=>Uhr,content_3824_12532:()=>qhr,content_3824_12534:()=>Yhr,content_3824_12536:()=>Khr,content_3824_12538:()=>egr,content_3824_1254:()=>vwe,content_3824_12540:()=>ogr,content_3824_12542:()=>sgr,content_3824_12544:()=>igr,content_3824_12546:()=>mgr,content_3824_12548:()=>hgr,content_3824_12550:()=>Dgr,content_3824_12552:()=>_gr,content_3824_12554:()=>Cgr,content_3824_12556:()=>vgr,content_3824_12558:()=>Ngr,content_3824_1256:()=>Nwe,content_3824_12560:()=>Pgr,content_3824_12562:()=>Wgr,content_3824_12564:()=>Ggr,content_3824_12566:()=>Ugr,content_3824_12568:()=>qgr,content_3824_12570:()=>Ygr,content_3824_12572:()=>Kgr,content_3824_12574:()=>efr,content_3824_12576:()=>ofr,content_3824_12578:()=>sfr,content_3824_1258:()=>Pwe,content_3824_12580:()=>ifr,content_3824_12582:()=>mfr,content_3824_12584:()=>hfr,content_3824_12586:()=>Dfr,content_3824_12588:()=>_fr,content_3824_12590:()=>Cfr,content_3824_12592:()=>vfr,content_3824_12594:()=>Nfr,content_3824_12596:()=>Pfr,content_3824_12598:()=>Wfr,content_3824_126:()=>i2,content_3824_1260:()=>Wwe,content_3824_12600:()=>Gfr,content_3824_12602:()=>Ufr,content_3824_12604:()=>qfr,content_3824_12606:()=>Yfr,content_3824_12608:()=>Kfr,content_3824_12610:()=>eDr,content_3824_12612:()=>oDr,content_3824_12614:()=>sDr,content_3824_12616:()=>iDr,content_3824_12618:()=>mDr,content_3824_1262:()=>Gwe,content_3824_12620:()=>hDr,content_3824_12622:()=>DDr,content_3824_12624:()=>_Dr,content_3824_12626:()=>CDr,content_3824_12628:()=>vDr,content_3824_12630:()=>NDr,content_3824_12632:()=>PDr,content_3824_12634:()=>WDr,content_3824_12636:()=>GDr,content_3824_12638:()=>UDr,content_3824_1264:()=>Uwe,content_3824_12640:()=>qDr,content_3824_12642:()=>YDr,content_3824_12644:()=>KDr,content_3824_12646:()=>eMr,content_3824_12648:()=>oMr,content_3824_12650:()=>sMr,content_3824_12652:()=>iMr,content_3824_12654:()=>mMr,content_3824_12656:()=>hMr,content_3824_12658:()=>DMr,content_3824_1266:()=>qwe,content_3824_12660:()=>_Mr,content_3824_12662:()=>CMr,content_3824_12664:()=>vMr,content_3824_12666:()=>NMr,content_3824_12668:()=>PMr,content_3824_12670:()=>WMr,content_3824_12672:()=>GMr,content_3824_12674:()=>UMr,content_3824_12676:()=>qMr,content_3824_12678:()=>YMr,content_3824_1268:()=>Ywe,content_3824_12680:()=>KMr,content_3824_12682:()=>eXr,content_3824_12684:()=>oXr,content_3824_12686:()=>sXr,content_3824_12688:()=>iXr,content_3824_12690:()=>mXr,content_3824_12692:()=>hXr,content_3824_12694:()=>DXr,content_3824_12696:()=>_Xr,content_3824_12698:()=>CXr,content_3824_1270:()=>Kwe,content_3824_12700:()=>vXr,content_3824_12702:()=>NXr,content_3824_12704:()=>PXr,content_3824_12706:()=>WXr,content_3824_12708:()=>GXr,content_3824_12710:()=>UXr,content_3824_12712:()=>qXr,content_3824_12714:()=>YXr,content_3824_12716:()=>KXr,content_3824_12718:()=>e_r,content_3824_1272:()=>eTe,content_3824_12720:()=>o_r,content_3824_12722:()=>s_r,content_3824_12724:()=>i_r,content_3824_12726:()=>m_r,content_3824_12728:()=>h_r,content_3824_12730:()=>D_r,content_3824_12732:()=>__r,content_3824_12734:()=>C_r,content_3824_12736:()=>v_r,content_3824_12738:()=>N_r,content_3824_1274:()=>oTe,content_3824_12740:()=>P_r,content_3824_12742:()=>W_r,content_3824_12744:()=>G_r,content_3824_12746:()=>U_r,content_3824_12748:()=>q_r,content_3824_12750:()=>Y_r,content_3824_12752:()=>K_r,content_3824_12754:()=>ewr,content_3824_12756:()=>owr,content_3824_12758:()=>swr,content_3824_1276:()=>sTe,content_3824_12760:()=>iwr,content_3824_12762:()=>mwr,content_3824_12764:()=>hwr,content_3824_12766:()=>Dwr,content_3824_12768:()=>_wr,content_3824_12770:()=>Cwr,content_3824_12772:()=>vwr,content_3824_12774:()=>Nwr,content_3824_12776:()=>Pwr,content_3824_12778:()=>Wwr,content_3824_1278:()=>iTe,content_3824_12780:()=>Gwr,content_3824_12782:()=>Uwr,content_3824_12784:()=>qwr,content_3824_12786:()=>Ywr,content_3824_12788:()=>Kwr,content_3824_12790:()=>eTr,content_3824_12792:()=>oTr,content_3824_12794:()=>sTr,content_3824_12796:()=>iTr,content_3824_12798:()=>mTr,content_3824_128:()=>m2,content_3824_1280:()=>mTe,content_3824_12800:()=>hTr,content_3824_12802:()=>DTr,content_3824_12804:()=>_Tr,content_3824_12806:()=>CTr,content_3824_12808:()=>vTr,content_3824_12810:()=>NTr,content_3824_12812:()=>PTr,content_3824_12814:()=>WTr,content_3824_12816:()=>GTr,content_3824_12818:()=>UTr,content_3824_1282:()=>hTe,content_3824_12820:()=>qTr,content_3824_12822:()=>YTr,content_3824_12824:()=>KTr,content_3824_12826:()=>eCr,content_3824_12828:()=>oCr,content_3824_12830:()=>sCr,content_3824_12832:()=>iCr,content_3824_12834:()=>mCr,content_3824_12836:()=>hCr,content_3824_12838:()=>DCr,content_3824_1284:()=>DTe,content_3824_12840:()=>_Cr,content_3824_12842:()=>CCr,content_3824_12844:()=>vCr,content_3824_12846:()=>NCr,content_3824_12848:()=>PCr,content_3824_12850:()=>WCr,content_3824_12852:()=>GCr,content_3824_12854:()=>UCr,content_3824_12856:()=>qCr,content_3824_12858:()=>YCr,content_3824_1286:()=>_Te,content_3824_12860:()=>KCr,content_3824_12862:()=>exr,content_3824_12864:()=>oxr,content_3824_12866:()=>sxr,content_3824_12868:()=>ixr,content_3824_12870:()=>mxr,content_3824_12872:()=>hxr,content_3824_12874:()=>Dxr,content_3824_12876:()=>_xr,content_3824_12878:()=>Cxr,content_3824_1288:()=>CTe,content_3824_12880:()=>vxr,content_3824_12882:()=>Nxr,content_3824_12884:()=>Pxr,content_3824_12886:()=>Wxr,content_3824_12888:()=>Gxr,content_3824_12890:()=>Uxr,content_3824_12892:()=>qxr,content_3824_12894:()=>Yxr,content_3824_12896:()=>Kxr,content_3824_12898:()=>eAr,content_3824_1290:()=>vTe,content_3824_12900:()=>oAr,content_3824_12902:()=>sAr,content_3824_12904:()=>iAr,content_3824_12906:()=>mAr,content_3824_12908:()=>hAr,content_3824_12910:()=>DAr,content_3824_12912:()=>_Ar,content_3824_12914:()=>CAr,content_3824_12916:()=>vAr,content_3824_12918:()=>NAr,content_3824_1292:()=>NTe,content_3824_12920:()=>PAr,content_3824_12922:()=>WAr,content_3824_12924:()=>GAr,content_3824_12926:()=>UAr,content_3824_12928:()=>qAr,content_3824_12930:()=>YAr,content_3824_12932:()=>KAr,content_3824_12934:()=>evr,content_3824_12936:()=>ovr,content_3824_12938:()=>svr,content_3824_1294:()=>PTe,content_3824_12940:()=>ivr,content_3824_12942:()=>mvr,content_3824_12944:()=>hvr,content_3824_12946:()=>Dvr,content_3824_12948:()=>_vr,content_3824_12950:()=>Cvr,content_3824_12952:()=>vvr,content_3824_12954:()=>Nvr,content_3824_12956:()=>Pvr,content_3824_12958:()=>Wvr,content_3824_1296:()=>WTe,content_3824_12960:()=>Gvr,content_3824_12962:()=>Uvr,content_3824_12964:()=>qvr,content_3824_12966:()=>Yvr,content_3824_12968:()=>Kvr,content_3824_12970:()=>eLr,content_3824_12972:()=>oLr,content_3824_12974:()=>sLr,content_3824_12976:()=>iLr,content_3824_12978:()=>mLr,content_3824_1298:()=>GTe,content_3824_12980:()=>hLr,content_3824_12982:()=>DLr,content_3824_12984:()=>_Lr,content_3824_12986:()=>CLr,content_3824_12988:()=>vLr,content_3824_12990:()=>NLr,content_3824_12992:()=>PLr,content_3824_12994:()=>WLr,content_3824_12996:()=>GLr,content_3824_12998:()=>ULr,content_3824_130:()=>h2,content_3824_1300:()=>UTe,content_3824_13000:()=>qLr,content_3824_13002:()=>YLr,content_3824_13004:()=>KLr,content_3824_13006:()=>ebr,content_3824_13008:()=>obr,content_3824_13010:()=>sbr,content_3824_13012:()=>ibr,content_3824_13014:()=>mbr,content_3824_1302:()=>qTe,content_3824_1304:()=>YTe,content_3824_1306:()=>KTe,content_3824_1308:()=>eCe,content_3824_1310:()=>oCe,content_3824_1312:()=>sCe,content_3824_1314:()=>iCe,content_3824_1316:()=>mCe,content_3824_1318:()=>hCe,content_3824_132:()=>D2,content_3824_1320:()=>DCe,content_3824_1322:()=>_Ce,content_3824_1324:()=>CCe,content_3824_1326:()=>vCe,content_3824_1328:()=>NCe,content_3824_1330:()=>PCe,content_3824_1332:()=>WCe,content_3824_1334:()=>GCe,content_3824_1336:()=>UCe,content_3824_1338:()=>qCe,content_3824_134:()=>_2,content_3824_1340:()=>YCe,content_3824_1342:()=>KCe,content_3824_1344:()=>exe,content_3824_1346:()=>oxe,content_3824_1348:()=>sxe,content_3824_1350:()=>ixe,content_3824_1352:()=>mxe,content_3824_1354:()=>hxe,content_3824_1356:()=>Dxe,content_3824_1358:()=>_xe,content_3824_136:()=>C2,content_3824_1360:()=>Cxe,content_3824_1362:()=>vxe,content_3824_1364:()=>Nxe,content_3824_1366:()=>Pxe,content_3824_1368:()=>Wxe,content_3824_1370:()=>Gxe,content_3824_1372:()=>Uxe,content_3824_1374:()=>qxe,content_3824_1376:()=>Yxe,content_3824_1378:()=>Kxe,content_3824_138:()=>v2,content_3824_1380:()=>eAe,content_3824_1382:()=>oAe,content_3824_1384:()=>sAe,content_3824_1386:()=>iAe,content_3824_1388:()=>mAe,content_3824_1390:()=>hAe,content_3824_1392:()=>DAe,content_3824_1394:()=>_Ae,content_3824_1396:()=>CAe,content_3824_1398:()=>vAe,content_3824_14:()=>oJ,content_3824_140:()=>N2,content_3824_1400:()=>NAe,content_3824_1402:()=>PAe,content_3824_1404:()=>WAe,content_3824_1406:()=>GAe,content_3824_1408:()=>UAe,content_3824_1410:()=>qAe,content_3824_1412:()=>YAe,content_3824_1414:()=>KAe,content_3824_1416:()=>eve,content_3824_1418:()=>ove,content_3824_142:()=>P2,content_3824_1420:()=>sve,content_3824_1422:()=>ive,content_3824_1424:()=>mve,content_3824_1426:()=>hve,content_3824_1428:()=>Dve,content_3824_1430:()=>_ve,content_3824_1432:()=>Cve,content_3824_1434:()=>vve,content_3824_1436:()=>Nve,content_3824_1438:()=>Pve,content_3824_144:()=>W2,content_3824_1440:()=>Wve,content_3824_1442:()=>Gve,content_3824_1444:()=>Uve,content_3824_1446:()=>qve,content_3824_1448:()=>Yve,content_3824_1450:()=>Kve,content_3824_1452:()=>eLe,content_3824_1454:()=>oLe,content_3824_1456:()=>sLe,content_3824_1458:()=>iLe,content_3824_146:()=>G2,content_3824_1460:()=>mLe,content_3824_1462:()=>hLe,content_3824_1464:()=>DLe,content_3824_1466:()=>_Le,content_3824_1468:()=>CLe,content_3824_1470:()=>vLe,content_3824_1472:()=>NLe,content_3824_1474:()=>PLe,content_3824_1476:()=>WLe,content_3824_1478:()=>GLe,content_3824_148:()=>U2,content_3824_1480:()=>ULe,content_3824_1482:()=>qLe,content_3824_1484:()=>YLe,content_3824_1486:()=>KLe,content_3824_1488:()=>ebe,content_3824_1490:()=>obe,content_3824_1492:()=>sbe,content_3824_1494:()=>ibe,content_3824_1496:()=>mbe,content_3824_1498:()=>hbe,content_3824_150:()=>q2,content_3824_1500:()=>Dbe,content_3824_1502:()=>_be,content_3824_1504:()=>Cbe,content_3824_1506:()=>vbe,content_3824_1508:()=>Nbe,content_3824_1510:()=>Pbe,content_3824_1512:()=>Wbe,content_3824_1514:()=>Gbe,content_3824_1516:()=>Ube,content_3824_1518:()=>qbe,content_3824_152:()=>Y2,content_3824_1520:()=>Ybe,content_3824_1522:()=>Kbe,content_3824_1524:()=>eNe,content_3824_1526:()=>oNe,content_3824_1528:()=>sNe,content_3824_1530:()=>iNe,content_3824_1532:()=>mNe,content_3824_1534:()=>hNe,content_3824_1536:()=>DNe,content_3824_1538:()=>_Ne,content_3824_154:()=>K2,content_3824_1540:()=>CNe,content_3824_1542:()=>vNe,content_3824_1544:()=>NNe,content_3824_1546:()=>PNe,content_3824_1548:()=>WNe,content_3824_1550:()=>GNe,content_3824_1552:()=>UNe,content_3824_1554:()=>qNe,content_3824_1556:()=>YNe,content_3824_1558:()=>KNe,content_3824_156:()=>e4,content_3824_1560:()=>eke,content_3824_1562:()=>oke,content_3824_1564:()=>ske,content_3824_1566:()=>ike,content_3824_1568:()=>mke,content_3824_1570:()=>hke,content_3824_1572:()=>Dke,content_3824_1574:()=>_ke,content_3824_1576:()=>Cke,content_3824_1578:()=>vke,content_3824_158:()=>o4,content_3824_1580:()=>Nke,content_3824_1582:()=>Pke,content_3824_1584:()=>Wke,content_3824_1586:()=>Gke,content_3824_1588:()=>Uke,content_3824_1590:()=>qke,content_3824_1592:()=>Yke,content_3824_1594:()=>Kke,content_3824_1596:()=>eze,content_3824_1598:()=>oze,content_3824_16:()=>sJ,content_3824_160:()=>s4,content_3824_1600:()=>sze,content_3824_1602:()=>ize,content_3824_1604:()=>mze,content_3824_1606:()=>hze,content_3824_1608:()=>Dze,content_3824_1610:()=>_ze,content_3824_1612:()=>Cze,content_3824_1614:()=>vze,content_3824_1616:()=>Nze,content_3824_1618:()=>Pze,content_3824_162:()=>i4,content_3824_1620:()=>Wze,content_3824_1622:()=>Gze,content_3824_1624:()=>Uze,content_3824_1626:()=>qze,content_3824_1628:()=>Yze,content_3824_1630:()=>Kze,content_3824_1632:()=>ePe,content_3824_1634:()=>oPe,content_3824_1636:()=>sPe,content_3824_1638:()=>iPe,content_3824_164:()=>m4,content_3824_1640:()=>mPe,content_3824_1642:()=>hPe,content_3824_1644:()=>DPe,content_3824_1646:()=>_Pe,content_3824_1648:()=>CPe,content_3824_1650:()=>vPe,content_3824_1652:()=>NPe,content_3824_1654:()=>PPe,content_3824_1656:()=>WPe,content_3824_1658:()=>GPe,content_3824_166:()=>h4,content_3824_1660:()=>UPe,content_3824_1662:()=>qPe,content_3824_1664:()=>YPe,content_3824_1666:()=>KPe,content_3824_1668:()=>eIe,content_3824_1670:()=>oIe,content_3824_1672:()=>sIe,content_3824_1674:()=>iIe,content_3824_1676:()=>mIe,content_3824_1678:()=>hIe,content_3824_168:()=>D4,content_3824_1680:()=>DIe,content_3824_1682:()=>_Ie,content_3824_1684:()=>CIe,content_3824_1686:()=>vIe,content_3824_1688:()=>NIe,content_3824_1690:()=>PIe,content_3824_1692:()=>WIe,content_3824_1694:()=>GIe,content_3824_1696:()=>UIe,content_3824_1698:()=>qIe,content_3824_170:()=>_4,content_3824_1700:()=>YIe,content_3824_1702:()=>KIe,content_3824_1704:()=>eRe,content_3824_1706:()=>oRe,content_3824_1708:()=>sRe,content_3824_1710:()=>iRe,content_3824_1712:()=>mRe,content_3824_1714:()=>hRe,content_3824_1716:()=>DRe,content_3824_1718:()=>_Re,content_3824_172:()=>C4,content_3824_1720:()=>CRe,content_3824_1722:()=>vRe,content_3824_1724:()=>NRe,content_3824_1726:()=>PRe,content_3824_1728:()=>WRe,content_3824_1730:()=>GRe,content_3824_1732:()=>URe,content_3824_1734:()=>qRe,content_3824_1736:()=>YRe,content_3824_1738:()=>KRe,content_3824_174:()=>v4,content_3824_1740:()=>eWe,content_3824_1742:()=>oWe,content_3824_1744:()=>sWe,content_3824_1746:()=>iWe,content_3824_1748:()=>mWe,content_3824_1750:()=>hWe,content_3824_1752:()=>DWe,content_3824_1754:()=>_We,content_3824_1756:()=>CWe,content_3824_1758:()=>vWe,content_3824_176:()=>N4,content_3824_1760:()=>NWe,content_3824_1762:()=>PWe,content_3824_1764:()=>WWe,content_3824_1766:()=>GWe,content_3824_1768:()=>UWe,content_3824_1770:()=>qWe,content_3824_1772:()=>YWe,content_3824_1774:()=>KWe,content_3824_1776:()=>eSe,content_3824_1778:()=>oSe,content_3824_178:()=>P4,content_3824_1780:()=>sSe,content_3824_1782:()=>iSe,content_3824_1784:()=>mSe,content_3824_1786:()=>hSe,content_3824_1788:()=>DSe,content_3824_1790:()=>_Se,content_3824_1792:()=>CSe,content_3824_1794:()=>vSe,content_3824_1796:()=>NSe,content_3824_1798:()=>PSe,content_3824_18:()=>iJ,content_3824_180:()=>W4,content_3824_1800:()=>WSe,content_3824_1802:()=>GSe,content_3824_1804:()=>USe,content_3824_1806:()=>qSe,content_3824_1808:()=>YSe,content_3824_1810:()=>KSe,content_3824_1812:()=>eBe,content_3824_1814:()=>oBe,content_3824_1816:()=>sBe,content_3824_1818:()=>iBe,content_3824_182:()=>G4,content_3824_1820:()=>mBe,content_3824_1822:()=>hBe,content_3824_1824:()=>DBe,content_3824_1826:()=>_Be,content_3824_1828:()=>CBe,content_3824_1830:()=>vBe,content_3824_1832:()=>NBe,content_3824_1834:()=>PBe,content_3824_1836:()=>WBe,content_3824_1838:()=>GBe,content_3824_184:()=>U4,content_3824_1840:()=>UBe,content_3824_1842:()=>qBe,content_3824_1844:()=>YBe,content_3824_1846:()=>KBe,content_3824_1848:()=>eGe,content_3824_1850:()=>oGe,content_3824_1852:()=>sGe,content_3824_1854:()=>iGe,content_3824_1856:()=>mGe,content_3824_1858:()=>hGe,content_3824_186:()=>q4,content_3824_1860:()=>DGe,content_3824_1862:()=>_Ge,content_3824_1864:()=>CGe,content_3824_1866:()=>vGe,content_3824_1868:()=>NGe,content_3824_1870:()=>PGe,content_3824_1872:()=>WGe,content_3824_1874:()=>GGe,content_3824_1876:()=>UGe,content_3824_1878:()=>qGe,content_3824_188:()=>Y4,content_3824_1880:()=>YGe,content_3824_1882:()=>KGe,content_3824_1884:()=>eEe,content_3824_1886:()=>oEe,content_3824_1888:()=>sEe,content_3824_1890:()=>iEe,content_3824_1892:()=>mEe,content_3824_1894:()=>hEe,content_3824_1896:()=>DEe,content_3824_1898:()=>_Ee,content_3824_190:()=>K4,content_3824_1900:()=>CEe,content_3824_1902:()=>vEe,content_3824_1904:()=>NEe,content_3824_1906:()=>PEe,content_3824_1908:()=>WEe,content_3824_1910:()=>GEe,content_3824_1912:()=>UEe,content_3824_1914:()=>qEe,content_3824_1916:()=>YEe,content_3824_1918:()=>KEe,content_3824_192:()=>e8,content_3824_1920:()=>eOe,content_3824_1922:()=>oOe,content_3824_1924:()=>sOe,content_3824_1926:()=>iOe,content_3824_1928:()=>mOe,content_3824_1930:()=>hOe,content_3824_1932:()=>DOe,content_3824_1934:()=>_Oe,content_3824_1936:()=>COe,content_3824_1938:()=>vOe,content_3824_194:()=>o8,content_3824_1940:()=>NOe,content_3824_1942:()=>POe,content_3824_1944:()=>WOe,content_3824_1946:()=>GOe,content_3824_1948:()=>UOe,content_3824_1950:()=>qOe,content_3824_1952:()=>YOe,content_3824_1954:()=>KOe,content_3824_1956:()=>eUe,content_3824_1958:()=>oUe,content_3824_196:()=>s8,content_3824_1960:()=>sUe,content_3824_1962:()=>iUe,content_3824_1964:()=>mUe,content_3824_1966:()=>hUe,content_3824_1968:()=>DUe,content_3824_1970:()=>_Ue,content_3824_1972:()=>CUe,content_3824_1974:()=>vUe,content_3824_1976:()=>NUe,content_3824_1978:()=>PUe,content_3824_198:()=>i8,content_3824_1980:()=>WUe,content_3824_1982:()=>GUe,content_3824_1984:()=>UUe,content_3824_1986:()=>qUe,content_3824_1988:()=>YUe,content_3824_1990:()=>KUe,content_3824_1992:()=>eFe,content_3824_1994:()=>oFe,content_3824_1996:()=>sFe,content_3824_1998:()=>iFe,content_3824_2:()=>GK,content_3824_20:()=>mJ,content_3824_200:()=>m8,content_3824_2000:()=>mFe,content_3824_2002:()=>hFe,content_3824_2004:()=>DFe,content_3824_2006:()=>_Fe,content_3824_2008:()=>CFe,content_3824_2010:()=>vFe,content_3824_2012:()=>NFe,content_3824_2014:()=>PFe,content_3824_2016:()=>WFe,content_3824_2018:()=>GFe,content_3824_202:()=>h8,content_3824_2020:()=>UFe,content_3824_2022:()=>qFe,content_3824_2024:()=>YFe,content_3824_2026:()=>KFe,content_3824_2028:()=>eVe,content_3824_2030:()=>oVe,content_3824_2032:()=>sVe,content_3824_2034:()=>iVe,content_3824_2036:()=>mVe,content_3824_2038:()=>hVe,content_3824_204:()=>D8,content_3824_2040:()=>DVe,content_3824_2042:()=>_Ve,content_3824_2044:()=>CVe,content_3824_2046:()=>vVe,content_3824_2048:()=>NVe,content_3824_2050:()=>PVe,content_3824_2052:()=>WVe,content_3824_2054:()=>GVe,content_3824_2056:()=>UVe,content_3824_2058:()=>qVe,content_3824_206:()=>_8,content_3824_2060:()=>YVe,content_3824_2062:()=>KVe,content_3824_2064:()=>eqe,content_3824_2066:()=>oqe,content_3824_2068:()=>sqe,content_3824_2070:()=>iqe,content_3824_2072:()=>mqe,content_3824_2074:()=>hqe,content_3824_2076:()=>Dqe,content_3824_2078:()=>_qe,content_3824_208:()=>C8,content_3824_2080:()=>Cqe,content_3824_2082:()=>vqe,content_3824_2084:()=>Nqe,content_3824_2086:()=>Pqe,content_3824_2088:()=>Wqe,content_3824_2090:()=>Gqe,content_3824_2092:()=>Uqe,content_3824_2094:()=>qqe,content_3824_2096:()=>Yqe,content_3824_2098:()=>Kqe,content_3824_210:()=>v8,content_3824_2100:()=>eje,content_3824_2102:()=>oje,content_3824_2104:()=>sje,content_3824_2106:()=>ije,content_3824_2108:()=>mje,content_3824_2110:()=>hje,content_3824_2112:()=>Dje,content_3824_2114:()=>_je,content_3824_2116:()=>Cje,content_3824_2118:()=>vje,content_3824_212:()=>N8,content_3824_2120:()=>Nje,content_3824_2122:()=>Pje,content_3824_2124:()=>Wje,content_3824_2126:()=>Gje,content_3824_2128:()=>Uje,content_3824_2130:()=>qje,content_3824_2132:()=>Yje,content_3824_2134:()=>Kje,content_3824_2136:()=>eHe,content_3824_2138:()=>oHe,content_3824_214:()=>P8,content_3824_2140:()=>sHe,content_3824_2142:()=>iHe,content_3824_2144:()=>mHe,content_3824_2146:()=>hHe,content_3824_2148:()=>DHe,content_3824_2150:()=>_He,content_3824_2152:()=>CHe,content_3824_2154:()=>vHe,content_3824_2156:()=>NHe,content_3824_2158:()=>PHe,content_3824_216:()=>W8,content_3824_2160:()=>WHe,content_3824_2162:()=>GHe,content_3824_2164:()=>UHe,content_3824_2166:()=>qHe,content_3824_2168:()=>YHe,content_3824_2170:()=>KHe,content_3824_2172:()=>eYe,content_3824_2174:()=>oYe,content_3824_2176:()=>sYe,content_3824_2178:()=>iYe,content_3824_218:()=>G8,content_3824_2180:()=>mYe,content_3824_2182:()=>hYe,content_3824_2184:()=>DYe,content_3824_2186:()=>_Ye,content_3824_2188:()=>CYe,content_3824_2190:()=>vYe,content_3824_2192:()=>NYe,content_3824_2194:()=>PYe,content_3824_2196:()=>WYe,content_3824_2198:()=>GYe,content_3824_22:()=>hJ,content_3824_220:()=>U8,content_3824_2200:()=>UYe,content_3824_2202:()=>qYe,content_3824_2204:()=>YYe,content_3824_2206:()=>KYe,content_3824_2208:()=>eQe,content_3824_2210:()=>oQe,content_3824_2212:()=>sQe,content_3824_2214:()=>iQe,content_3824_2216:()=>mQe,content_3824_2218:()=>hQe,content_3824_222:()=>q8,content_3824_2220:()=>DQe,content_3824_2222:()=>_Qe,content_3824_2224:()=>CQe,content_3824_2226:()=>vQe,content_3824_2228:()=>NQe,content_3824_2230:()=>PQe,content_3824_2232:()=>WQe,content_3824_2234:()=>GQe,content_3824_2236:()=>UQe,content_3824_2238:()=>qQe,content_3824_224:()=>Y8,content_3824_2240:()=>YQe,content_3824_2242:()=>KQe,content_3824_2244:()=>e$e,content_3824_2246:()=>o$e,content_3824_2248:()=>s$e,content_3824_2250:()=>i$e,content_3824_2252:()=>m$e,content_3824_2254:()=>h$e,content_3824_2256:()=>D$e,content_3824_2258:()=>_$e,content_3824_226:()=>K8,content_3824_2260:()=>C$e,content_3824_2262:()=>v$e,content_3824_2264:()=>N$e,content_3824_2266:()=>P$e,content_3824_2268:()=>W$e,content_3824_2270:()=>G$e,content_3824_2272:()=>U$e,content_3824_2274:()=>q$e,content_3824_2276:()=>Y$e,content_3824_2278:()=>K$e,content_3824_228:()=>e3,content_3824_2280:()=>eKe,content_3824_2282:()=>oKe,content_3824_2284:()=>sKe,content_3824_2286:()=>iKe,content_3824_2288:()=>mKe,content_3824_2290:()=>hKe,content_3824_2292:()=>DKe,content_3824_2294:()=>_Ke,content_3824_2296:()=>CKe,content_3824_2298:()=>vKe,content_3824_230:()=>o3,content_3824_2300:()=>NKe,content_3824_2302:()=>PKe,content_3824_2304:()=>WKe,content_3824_2306:()=>GKe,content_3824_2308:()=>UKe,content_3824_2310:()=>qKe,content_3824_2312:()=>YKe,content_3824_2314:()=>KKe,content_3824_2316:()=>eJe,content_3824_2318:()=>oJe,content_3824_232:()=>s3,content_3824_2320:()=>sJe,content_3824_2322:()=>iJe,content_3824_2324:()=>mJe,content_3824_2326:()=>hJe,content_3824_2328:()=>DJe,content_3824_2330:()=>_Je,content_3824_2332:()=>CJe,content_3824_2334:()=>vJe,content_3824_2336:()=>NJe,content_3824_2338:()=>PJe,content_3824_234:()=>i3,content_3824_2340:()=>WJe,content_3824_2342:()=>GJe,content_3824_2344:()=>UJe,content_3824_2346:()=>qJe,content_3824_2348:()=>YJe,content_3824_2350:()=>KJe,content_3824_2352:()=>eZe,content_3824_2354:()=>oZe,content_3824_2356:()=>sZe,content_3824_2358:()=>iZe,content_3824_236:()=>m3,content_3824_2360:()=>mZe,content_3824_2362:()=>hZe,content_3824_2364:()=>DZe,content_3824_2366:()=>_Ze,content_3824_2368:()=>CZe,content_3824_2370:()=>vZe,content_3824_2372:()=>NZe,content_3824_2374:()=>PZe,content_3824_2376:()=>WZe,content_3824_2378:()=>GZe,content_3824_238:()=>h3,content_3824_2380:()=>UZe,content_3824_2382:()=>qZe,content_3824_2384:()=>YZe,content_3824_2386:()=>KZe,content_3824_2388:()=>e0e,content_3824_2390:()=>o0e,content_3824_2392:()=>s0e,content_3824_2394:()=>i0e,content_3824_2396:()=>m0e,content_3824_2398:()=>h0e,content_3824_24:()=>DJ,content_3824_240:()=>D3,content_3824_2400:()=>D0e,content_3824_2402:()=>_0e,content_3824_2404:()=>C0e,content_3824_2406:()=>v0e,content_3824_2408:()=>N0e,content_3824_2410:()=>P0e,content_3824_2412:()=>W0e,content_3824_2414:()=>G0e,content_3824_2416:()=>U0e,content_3824_2418:()=>q0e,content_3824_242:()=>_3,content_3824_2420:()=>Y0e,content_3824_2422:()=>K0e,content_3824_2424:()=>e2e,content_3824_2426:()=>o2e,content_3824_2428:()=>s2e,content_3824_2430:()=>i2e,content_3824_2432:()=>m2e,content_3824_2434:()=>h2e,content_3824_2436:()=>D2e,content_3824_2438:()=>_2e,content_3824_244:()=>C3,content_3824_2440:()=>C2e,content_3824_2442:()=>v2e,content_3824_2444:()=>N2e,content_3824_2446:()=>P2e,content_3824_2448:()=>W2e,content_3824_2450:()=>G2e,content_3824_2452:()=>U2e,content_3824_2454:()=>q2e,content_3824_2456:()=>Y2e,content_3824_2458:()=>K2e,content_3824_246:()=>v3,content_3824_2460:()=>e4e,content_3824_2462:()=>o4e,content_3824_2464:()=>s4e,content_3824_2466:()=>i4e,content_3824_2468:()=>m4e,content_3824_2470:()=>h4e,content_3824_2472:()=>D4e,content_3824_2474:()=>_4e,content_3824_2476:()=>C4e,content_3824_2478:()=>v4e,content_3824_248:()=>N3,content_3824_2480:()=>N4e,content_3824_2482:()=>P4e,content_3824_2484:()=>W4e,content_3824_2486:()=>G4e,content_3824_2488:()=>U4e,content_3824_2490:()=>q4e,content_3824_2492:()=>Y4e,content_3824_2494:()=>K4e,content_3824_2496:()=>e8e,content_3824_2498:()=>o8e,content_3824_250:()=>P3,content_3824_2500:()=>s8e,content_3824_2502:()=>i8e,content_3824_2504:()=>m8e,content_3824_2506:()=>h8e,content_3824_2508:()=>D8e,content_3824_2510:()=>_8e,content_3824_2512:()=>C8e,content_3824_2514:()=>v8e,content_3824_2516:()=>N8e,content_3824_2518:()=>P8e,content_3824_252:()=>W3,content_3824_2520:()=>W8e,content_3824_2522:()=>G8e,content_3824_2524:()=>U8e,content_3824_2526:()=>q8e,content_3824_2528:()=>Y8e,content_3824_2530:()=>K8e,content_3824_2532:()=>e3e,content_3824_2534:()=>o3e,content_3824_2536:()=>s3e,content_3824_2538:()=>i3e,content_3824_254:()=>G3,content_3824_2540:()=>m3e,content_3824_2542:()=>h3e,content_3824_2544:()=>D3e,content_3824_2546:()=>_3e,content_3824_2548:()=>C3e,content_3824_2550:()=>v3e,content_3824_2552:()=>N3e,content_3824_2554:()=>P3e,content_3824_2556:()=>W3e,content_3824_2558:()=>G3e,content_3824_256:()=>U3,content_3824_2560:()=>U3e,content_3824_2562:()=>q3e,content_3824_2564:()=>Y3e,content_3824_2566:()=>K3e,content_3824_2568:()=>e1e,content_3824_2570:()=>o1e,content_3824_2572:()=>s1e,content_3824_2574:()=>i1e,content_3824_2576:()=>m1e,content_3824_2578:()=>h1e,content_3824_258:()=>q3,content_3824_2580:()=>D1e,content_3824_2582:()=>_1e,content_3824_2584:()=>C1e,content_3824_2586:()=>v1e,content_3824_2588:()=>N1e,content_3824_2590:()=>P1e,content_3824_2592:()=>W1e,content_3824_2594:()=>G1e,content_3824_2596:()=>U1e,content_3824_2598:()=>q1e,content_3824_26:()=>_J,content_3824_260:()=>Y3,content_3824_2600:()=>Y1e,content_3824_2602:()=>K1e,content_3824_2604:()=>e6e,content_3824_2606:()=>o6e,content_3824_2608:()=>s6e,content_3824_2610:()=>i6e,content_3824_2612:()=>m6e,content_3824_2614:()=>h6e,content_3824_2616:()=>D6e,content_3824_2618:()=>_6e,content_3824_262:()=>K3,content_3824_2620:()=>C6e,content_3824_2622:()=>v6e,content_3824_2624:()=>N6e,content_3824_2626:()=>P6e,content_3824_2628:()=>W6e,content_3824_2630:()=>G6e,content_3824_2632:()=>U6e,content_3824_2634:()=>q6e,content_3824_2636:()=>Y6e,content_3824_2638:()=>K6e,content_3824_264:()=>e1,content_3824_2640:()=>e5e,content_3824_2642:()=>o5e,content_3824_2644:()=>s5e,content_3824_2646:()=>i5e,content_3824_2648:()=>m5e,content_3824_2650:()=>h5e,content_3824_2652:()=>D5e,content_3824_2654:()=>_5e,content_3824_2656:()=>C5e,content_3824_2658:()=>v5e,content_3824_266:()=>o1,content_3824_2660:()=>N5e,content_3824_2662:()=>P5e,content_3824_2664:()=>W5e,content_3824_2666:()=>G5e,content_3824_2668:()=>U5e,content_3824_2670:()=>q5e,content_3824_2672:()=>Y5e,content_3824_2674:()=>K5e,content_3824_2676:()=>e7e,content_3824_2678:()=>o7e,content_3824_268:()=>s1,content_3824_2680:()=>s7e,content_3824_2682:()=>i7e,content_3824_2684:()=>m7e,content_3824_2686:()=>h7e,content_3824_2688:()=>D7e,content_3824_2690:()=>_7e,content_3824_2692:()=>C7e,content_3824_2694:()=>v7e,content_3824_2696:()=>N7e,content_3824_2698:()=>P7e,content_3824_270:()=>i1,content_3824_2700:()=>W7e,content_3824_2702:()=>G7e,content_3824_2704:()=>U7e,content_3824_2706:()=>q7e,content_3824_2708:()=>Y7e,content_3824_2710:()=>K7e,content_3824_2712:()=>e9e,content_3824_2714:()=>o9e,content_3824_2716:()=>s9e,content_3824_2718:()=>i9e,content_3824_272:()=>m1,content_3824_2720:()=>m9e,content_3824_2722:()=>h9e,content_3824_2724:()=>D9e,content_3824_2726:()=>_9e,content_3824_2728:()=>C9e,content_3824_2730:()=>v9e,content_3824_2732:()=>N9e,content_3824_2734:()=>P9e,content_3824_2736:()=>W9e,content_3824_2738:()=>G9e,content_3824_274:()=>h1,content_3824_2740:()=>U9e,content_3824_2742:()=>q9e,content_3824_2744:()=>Y9e,content_3824_2746:()=>K9e,content_3824_2748:()=>een,content_3824_2750:()=>oen,content_3824_2752:()=>sen,content_3824_2754:()=>ien,content_3824_2756:()=>men,content_3824_2758:()=>hen,content_3824_276:()=>D1,content_3824_2760:()=>Den,content_3824_2762:()=>_en,content_3824_2764:()=>Cen,content_3824_2766:()=>ven,content_3824_2768:()=>Nen,content_3824_2770:()=>Pen,content_3824_2772:()=>Wen,content_3824_2774:()=>Gen,content_3824_2776:()=>Uen,content_3824_2778:()=>qen,content_3824_278:()=>_1,content_3824_2780:()=>Yen,content_3824_2782:()=>Ken,content_3824_2784:()=>enn,content_3824_2786:()=>onn,content_3824_2788:()=>snn,content_3824_2790:()=>inn,content_3824_2792:()=>mnn,content_3824_2794:()=>hnn,content_3824_2796:()=>Dnn,content_3824_2798:()=>_nn,content_3824_28:()=>CJ,content_3824_280:()=>C1,content_3824_2800:()=>Cnn,content_3824_2802:()=>vnn,content_3824_2804:()=>Nnn,content_3824_2806:()=>Pnn,content_3824_2808:()=>Wnn,content_3824_2810:()=>Gnn,content_3824_2812:()=>Unn,content_3824_2814:()=>qnn,content_3824_2816:()=>Ynn,content_3824_2818:()=>Knn,content_3824_282:()=>v1,content_3824_2820:()=>etn,content_3824_2822:()=>otn,content_3824_2824:()=>stn,content_3824_2826:()=>itn,content_3824_2828:()=>mtn,content_3824_2830:()=>htn,content_3824_2832:()=>Dtn,content_3824_2834:()=>_tn,content_3824_2836:()=>Ctn,content_3824_2838:()=>vtn,content_3824_284:()=>N1,content_3824_2840:()=>Ntn,content_3824_2842:()=>Ptn,content_3824_2844:()=>Wtn,content_3824_2846:()=>Gtn,content_3824_2848:()=>Utn,content_3824_2850:()=>qtn,content_3824_2852:()=>Ytn,content_3824_2854:()=>Ktn,content_3824_2856:()=>eon,content_3824_2858:()=>oon,content_3824_286:()=>P1,content_3824_2860:()=>son,content_3824_2862:()=>ion,content_3824_2864:()=>mon,content_3824_2866:()=>hon,content_3824_2868:()=>Don,content_3824_2870:()=>_on,content_3824_2872:()=>Con,content_3824_2874:()=>von,content_3824_2876:()=>Non,content_3824_2878:()=>Pon,content_3824_288:()=>W1,content_3824_2880:()=>Won,content_3824_2882:()=>Gon,content_3824_2884:()=>Uon,content_3824_2886:()=>qon,content_3824_2888:()=>Yon,content_3824_2890:()=>Kon,content_3824_2892:()=>epn,content_3824_2894:()=>opn,content_3824_2896:()=>spn,content_3824_2898:()=>ipn,content_3824_290:()=>G1,content_3824_2900:()=>mpn,content_3824_2902:()=>hpn,content_3824_2904:()=>Dpn,content_3824_2906:()=>_pn,content_3824_2908:()=>Cpn,content_3824_2910:()=>vpn,content_3824_2912:()=>Npn,content_3824_2914:()=>Ppn,content_3824_2916:()=>Wpn,content_3824_2918:()=>Gpn,content_3824_292:()=>U1,content_3824_2920:()=>Upn,content_3824_2922:()=>qpn,content_3824_2924:()=>Ypn,content_3824_2926:()=>Kpn,content_3824_2928:()=>ern,content_3824_2930:()=>orn,content_3824_2932:()=>srn,content_3824_2934:()=>irn,content_3824_2936:()=>mrn,content_3824_2938:()=>hrn,content_3824_294:()=>q1,content_3824_2940:()=>Drn,content_3824_2942:()=>_rn,content_3824_2944:()=>Crn,content_3824_2946:()=>vrn,content_3824_2948:()=>Nrn,content_3824_2950:()=>Prn,content_3824_2952:()=>Wrn,content_3824_2954:()=>Grn,content_3824_2956:()=>Urn,content_3824_2958:()=>qrn,content_3824_296:()=>Y1,content_3824_2960:()=>Yrn,content_3824_2962:()=>Krn,content_3824_2964:()=>esn,content_3824_2966:()=>osn,content_3824_2968:()=>ssn,content_3824_2970:()=>isn,content_3824_2972:()=>msn,content_3824_2974:()=>hsn,content_3824_2976:()=>Dsn,content_3824_2978:()=>_sn,content_3824_298:()=>K1,content_3824_2980:()=>Csn,content_3824_2982:()=>vsn,content_3824_2984:()=>Nsn,content_3824_2986:()=>Psn,content_3824_2988:()=>Wsn,content_3824_2990:()=>Gsn,content_3824_2992:()=>Usn,content_3824_2994:()=>qsn,content_3824_2996:()=>Ysn,content_3824_2998:()=>Ksn,content_3824_30:()=>vJ,content_3824_300:()=>e6,content_3824_3000:()=>ecn,content_3824_3002:()=>ocn,content_3824_3004:()=>scn,content_3824_3006:()=>icn,content_3824_3008:()=>mcn,content_3824_3010:()=>hcn,content_3824_3012:()=>Dcn,content_3824_3014:()=>_cn,content_3824_3016:()=>Ccn,content_3824_3018:()=>vcn,content_3824_302:()=>o6,content_3824_3020:()=>Ncn,content_3824_3022:()=>Pcn,content_3824_3024:()=>Wcn,content_3824_3026:()=>Gcn,content_3824_3028:()=>Ucn,content_3824_3030:()=>qcn,content_3824_3032:()=>Ycn,content_3824_3034:()=>Kcn,content_3824_3036:()=>ean,content_3824_3038:()=>oan,content_3824_304:()=>s6,content_3824_3040:()=>san,content_3824_3042:()=>ian,content_3824_3044:()=>man,content_3824_3046:()=>han,content_3824_3048:()=>Dan,content_3824_3050:()=>_an,content_3824_3052:()=>Can,content_3824_3054:()=>van,content_3824_3056:()=>Nan,content_3824_3058:()=>Pan,content_3824_306:()=>i6,content_3824_3060:()=>Wan,content_3824_3062:()=>Gan,content_3824_3064:()=>Uan,content_3824_3066:()=>qan,content_3824_3068:()=>Yan,content_3824_3070:()=>Kan,content_3824_3072:()=>ein,content_3824_3074:()=>oin,content_3824_3076:()=>sin,content_3824_3078:()=>iin,content_3824_308:()=>m6,content_3824_3080:()=>min,content_3824_3082:()=>hin,content_3824_3084:()=>Din,content_3824_3086:()=>_in,content_3824_3088:()=>Cin,content_3824_3090:()=>vin,content_3824_3092:()=>Nin,content_3824_3094:()=>Pin,content_3824_3096:()=>Win,content_3824_3098:()=>Gin,content_3824_310:()=>h6,content_3824_3100:()=>Uin,content_3824_3102:()=>qin,content_3824_3104:()=>Yin,content_3824_3106:()=>Kin,content_3824_3108:()=>eln,content_3824_3110:()=>oln,content_3824_3112:()=>sln,content_3824_3114:()=>iln,content_3824_3116:()=>mln,content_3824_3118:()=>hln,content_3824_312:()=>D6,content_3824_3120:()=>Dln,content_3824_3122:()=>_ln,content_3824_3124:()=>Cln,content_3824_3126:()=>vln,content_3824_3128:()=>Nln,content_3824_3130:()=>Pln,content_3824_3132:()=>Wln,content_3824_3134:()=>Gln,content_3824_3136:()=>Uln,content_3824_3138:()=>qln,content_3824_314:()=>_6,content_3824_3140:()=>Yln,content_3824_3142:()=>Kln,content_3824_3144:()=>eun,content_3824_3146:()=>oun,content_3824_3148:()=>sun,content_3824_3150:()=>iun,content_3824_3152:()=>mun,content_3824_3154:()=>hun,content_3824_3156:()=>Dun,content_3824_3158:()=>_un,content_3824_316:()=>C6,content_3824_3160:()=>Cun,content_3824_3162:()=>vun,content_3824_3164:()=>Nun,content_3824_3166:()=>Pun,content_3824_3168:()=>Wun,content_3824_3170:()=>Gun,content_3824_3172:()=>Uun,content_3824_3174:()=>qun,content_3824_3176:()=>Yun,content_3824_3178:()=>Kun,content_3824_318:()=>v6,content_3824_3180:()=>emn,content_3824_3182:()=>omn,content_3824_3184:()=>smn,content_3824_3186:()=>imn,content_3824_3188:()=>mmn,content_3824_3190:()=>hmn,content_3824_3192:()=>Dmn,content_3824_3194:()=>_mn,content_3824_3196:()=>Cmn,content_3824_3198:()=>vmn,content_3824_32:()=>NJ,content_3824_320:()=>N6,content_3824_3200:()=>Nmn,content_3824_3202:()=>Pmn,content_3824_3204:()=>Wmn,content_3824_3206:()=>Gmn,content_3824_3208:()=>Umn,content_3824_3210:()=>qmn,content_3824_3212:()=>Ymn,content_3824_3214:()=>Kmn,content_3824_3216:()=>eyn,content_3824_3218:()=>oyn,content_3824_322:()=>P6,content_3824_3220:()=>syn,content_3824_3222:()=>iyn,content_3824_3224:()=>myn,content_3824_3226:()=>hyn,content_3824_3228:()=>Dyn,content_3824_3230:()=>_yn,content_3824_3232:()=>Cyn,content_3824_3234:()=>vyn,content_3824_3236:()=>Nyn,content_3824_3238:()=>Pyn,content_3824_324:()=>W6,content_3824_3240:()=>Wyn,content_3824_3242:()=>Gyn,content_3824_3244:()=>Uyn,content_3824_3246:()=>qyn,content_3824_3248:()=>Yyn,content_3824_3250:()=>Kyn,content_3824_3252:()=>edn,content_3824_3254:()=>odn,content_3824_3256:()=>sdn,content_3824_3258:()=>idn,content_3824_326:()=>G6,content_3824_3260:()=>mdn,content_3824_3262:()=>hdn,content_3824_3264:()=>Ddn,content_3824_3266:()=>_dn,content_3824_3268:()=>Cdn,content_3824_3270:()=>vdn,content_3824_3272:()=>Ndn,content_3824_3274:()=>Pdn,content_3824_3276:()=>Wdn,content_3824_3278:()=>Gdn,content_3824_328:()=>U6,content_3824_3280:()=>Udn,content_3824_3282:()=>qdn,content_3824_3284:()=>Ydn,content_3824_3286:()=>Kdn,content_3824_3288:()=>ehn,content_3824_3290:()=>ohn,content_3824_3292:()=>shn,content_3824_3294:()=>ihn,content_3824_3296:()=>mhn,content_3824_3298:()=>hhn,content_3824_330:()=>q6,content_3824_3300:()=>Dhn,content_3824_3302:()=>_hn,content_3824_3304:()=>Chn,content_3824_3306:()=>vhn,content_3824_3308:()=>Nhn,content_3824_3310:()=>Phn,content_3824_3312:()=>Whn,content_3824_3314:()=>Ghn,content_3824_3316:()=>Uhn,content_3824_3318:()=>qhn,content_3824_332:()=>Y6,content_3824_3320:()=>Yhn,content_3824_3322:()=>Khn,content_3824_3324:()=>egn,content_3824_3326:()=>ogn,content_3824_3328:()=>sgn,content_3824_3330:()=>ign,content_3824_3332:()=>mgn,content_3824_3334:()=>hgn,content_3824_3336:()=>Dgn,content_3824_3338:()=>_gn,content_3824_334:()=>K6,content_3824_3340:()=>Cgn,content_3824_3342:()=>vgn,content_3824_3344:()=>Ngn,content_3824_3346:()=>Pgn,content_3824_3348:()=>Wgn,content_3824_3350:()=>Ggn,content_3824_3352:()=>Ugn,content_3824_3354:()=>qgn,content_3824_3356:()=>Ygn,content_3824_3358:()=>Kgn,content_3824_336:()=>e5,content_3824_3360:()=>efn,content_3824_3362:()=>ofn,content_3824_3364:()=>sfn,content_3824_3366:()=>ifn,content_3824_3368:()=>mfn,content_3824_3370:()=>hfn,content_3824_3372:()=>Dfn,content_3824_3374:()=>_fn,content_3824_3376:()=>Cfn,content_3824_3378:()=>vfn,content_3824_338:()=>o5,content_3824_3380:()=>Nfn,content_3824_3382:()=>Pfn,content_3824_3384:()=>Wfn,content_3824_3386:()=>Gfn,content_3824_3388:()=>Ufn,content_3824_3390:()=>qfn,content_3824_3392:()=>Yfn,content_3824_3394:()=>Kfn,content_3824_3396:()=>eDn,content_3824_3398:()=>oDn,content_3824_34:()=>PJ,content_3824_340:()=>s5,content_3824_3400:()=>sDn,content_3824_3402:()=>iDn,content_3824_3404:()=>mDn,content_3824_3406:()=>hDn,content_3824_3408:()=>DDn,content_3824_3410:()=>_Dn,content_3824_3412:()=>CDn,content_3824_3414:()=>vDn,content_3824_3416:()=>NDn,content_3824_3418:()=>PDn,content_3824_342:()=>i5,content_3824_3420:()=>WDn,content_3824_3422:()=>GDn,content_3824_3424:()=>UDn,content_3824_3426:()=>qDn,content_3824_3428:()=>YDn,content_3824_3430:()=>KDn,content_3824_3432:()=>eMn,content_3824_3434:()=>oMn,content_3824_3436:()=>sMn,content_3824_3438:()=>iMn,content_3824_344:()=>m5,content_3824_3440:()=>mMn,content_3824_3442:()=>hMn,content_3824_3444:()=>DMn,content_3824_3446:()=>_Mn,content_3824_3448:()=>CMn,content_3824_3450:()=>vMn,content_3824_3452:()=>NMn,content_3824_3454:()=>PMn,content_3824_3456:()=>WMn,content_3824_3458:()=>GMn,content_3824_346:()=>h5,content_3824_3460:()=>UMn,content_3824_3462:()=>qMn,content_3824_3464:()=>YMn,content_3824_3466:()=>KMn,content_3824_3468:()=>eXn,content_3824_3470:()=>oXn,content_3824_3472:()=>sXn,content_3824_3474:()=>iXn,content_3824_3476:()=>mXn,content_3824_3478:()=>hXn,content_3824_348:()=>D5,content_3824_3480:()=>DXn,content_3824_3482:()=>_Xn,content_3824_3484:()=>CXn,content_3824_3486:()=>vXn,content_3824_3488:()=>NXn,content_3824_3490:()=>PXn,content_3824_3492:()=>WXn,content_3824_3494:()=>GXn,content_3824_3496:()=>UXn,content_3824_3498:()=>qXn,content_3824_350:()=>_5,content_3824_3500:()=>YXn,content_3824_3502:()=>KXn,content_3824_3504:()=>e_n,content_3824_3506:()=>o_n,content_3824_3508:()=>s_n,content_3824_3510:()=>i_n,content_3824_3512:()=>m_n,content_3824_3514:()=>h_n,content_3824_3516:()=>D_n,content_3824_3518:()=>__n,content_3824_352:()=>C5,content_3824_3520:()=>C_n,content_3824_3522:()=>v_n,content_3824_3524:()=>N_n,content_3824_3526:()=>P_n,content_3824_3528:()=>W_n,content_3824_3530:()=>G_n,content_3824_3532:()=>U_n,content_3824_3534:()=>q_n,content_3824_3536:()=>Y_n,content_3824_3538:()=>K_n,content_3824_354:()=>v5,content_3824_3540:()=>ewn,content_3824_3542:()=>own,content_3824_3544:()=>swn,content_3824_3546:()=>iwn,content_3824_3548:()=>mwn,content_3824_3550:()=>hwn,content_3824_3552:()=>Dwn,content_3824_3554:()=>_wn,content_3824_3556:()=>Cwn,content_3824_3558:()=>vwn,content_3824_356:()=>N5,content_3824_3560:()=>Nwn,content_3824_3562:()=>Pwn,content_3824_3564:()=>Wwn,content_3824_3566:()=>Gwn,content_3824_3568:()=>Uwn,content_3824_3570:()=>qwn,content_3824_3572:()=>Ywn,content_3824_3574:()=>Kwn,content_3824_3576:()=>eTn,content_3824_3578:()=>oTn,content_3824_358:()=>P5,content_3824_3580:()=>sTn,content_3824_3582:()=>iTn,content_3824_3584:()=>mTn,content_3824_3586:()=>hTn,content_3824_3588:()=>DTn,content_3824_3590:()=>_Tn,content_3824_3592:()=>CTn,content_3824_3594:()=>vTn,content_3824_3596:()=>NTn,content_3824_3598:()=>PTn,content_3824_36:()=>WJ,content_3824_360:()=>W5,content_3824_3600:()=>WTn,content_3824_3602:()=>GTn,content_3824_3604:()=>UTn,content_3824_3606:()=>qTn,content_3824_3608:()=>YTn,content_3824_3610:()=>KTn,content_3824_3612:()=>eCn,content_3824_3614:()=>oCn,content_3824_3616:()=>sCn,content_3824_3618:()=>iCn,content_3824_362:()=>G5,content_3824_3620:()=>mCn,content_3824_3622:()=>hCn,content_3824_3624:()=>DCn,content_3824_3626:()=>_Cn,content_3824_3628:()=>CCn,content_3824_3630:()=>vCn,content_3824_3632:()=>NCn,content_3824_3634:()=>PCn,content_3824_3636:()=>WCn,content_3824_3638:()=>GCn,content_3824_364:()=>U5,content_3824_3640:()=>UCn,content_3824_3642:()=>qCn,content_3824_3644:()=>YCn,content_3824_3646:()=>KCn,content_3824_3648:()=>exn,content_3824_3650:()=>oxn,content_3824_3652:()=>sxn,content_3824_3654:()=>ixn,content_3824_3656:()=>mxn,content_3824_3658:()=>hxn,content_3824_366:()=>q5,content_3824_3660:()=>Dxn,content_3824_3662:()=>_xn,content_3824_3664:()=>Cxn,content_3824_3666:()=>vxn,content_3824_3668:()=>Nxn,content_3824_3670:()=>Pxn,content_3824_3672:()=>Wxn,content_3824_3674:()=>Gxn,content_3824_3676:()=>Uxn,content_3824_3678:()=>qxn,content_3824_368:()=>Y5,content_3824_3680:()=>Yxn,content_3824_3682:()=>Kxn,content_3824_3684:()=>eAn,content_3824_3686:()=>oAn,content_3824_3688:()=>sAn,content_3824_3690:()=>iAn,content_3824_3692:()=>mAn,content_3824_3694:()=>hAn,content_3824_3696:()=>DAn,content_3824_3698:()=>_An,content_3824_370:()=>K5,content_3824_3700:()=>CAn,content_3824_3702:()=>vAn,content_3824_3704:()=>NAn,content_3824_3706:()=>PAn,content_3824_3708:()=>WAn,content_3824_3710:()=>GAn,content_3824_3712:()=>UAn,content_3824_3714:()=>qAn,content_3824_3716:()=>YAn,content_3824_3718:()=>KAn,content_3824_372:()=>e7,content_3824_3720:()=>evn,content_3824_3722:()=>ovn,content_3824_3724:()=>svn,content_3824_3726:()=>ivn,content_3824_3728:()=>mvn,content_3824_3730:()=>hvn,content_3824_3732:()=>Dvn,content_3824_3734:()=>_vn,content_3824_3736:()=>Cvn,content_3824_3738:()=>vvn,content_3824_374:()=>o7,content_3824_3740:()=>Nvn,content_3824_3742:()=>Pvn,content_3824_3744:()=>Wvn,content_3824_3746:()=>Gvn,content_3824_3748:()=>Uvn,content_3824_3750:()=>qvn,content_3824_3752:()=>Yvn,content_3824_3754:()=>Kvn,content_3824_3756:()=>eLn,content_3824_3758:()=>oLn,content_3824_376:()=>s7,content_3824_3760:()=>sLn,content_3824_3762:()=>iLn,content_3824_3764:()=>mLn,content_3824_3766:()=>hLn,content_3824_3768:()=>DLn,content_3824_3770:()=>_Ln,content_3824_3772:()=>CLn,content_3824_3774:()=>vLn,content_3824_3776:()=>NLn,content_3824_3778:()=>PLn,content_3824_378:()=>i7,content_3824_3780:()=>WLn,content_3824_3782:()=>GLn,content_3824_3784:()=>ULn,content_3824_3786:()=>qLn,content_3824_3788:()=>YLn,content_3824_3790:()=>KLn,content_3824_3792:()=>ebn,content_3824_3794:()=>obn,content_3824_3796:()=>sbn,content_3824_3798:()=>ibn,content_3824_38:()=>GJ,content_3824_380:()=>m7,content_3824_3800:()=>mbn,content_3824_3802:()=>hbn,content_3824_3804:()=>Dbn,content_3824_3806:()=>_bn,content_3824_3808:()=>Cbn,content_3824_3810:()=>vbn,content_3824_3812:()=>Nbn,content_3824_3814:()=>Pbn,content_3824_3816:()=>Wbn,content_3824_3818:()=>Gbn,content_3824_382:()=>h7,content_3824_3820:()=>Ubn,content_3824_3822:()=>qbn,content_3824_3824:()=>Ybn,content_3824_3826:()=>Kbn,content_3824_3828:()=>eNn,content_3824_3830:()=>oNn,content_3824_3832:()=>sNn,content_3824_3834:()=>iNn,content_3824_3836:()=>mNn,content_3824_3838:()=>hNn,content_3824_384:()=>D7,content_3824_3840:()=>DNn,content_3824_3842:()=>_Nn,content_3824_3844:()=>CNn,content_3824_3846:()=>vNn,content_3824_3848:()=>NNn,content_3824_3850:()=>PNn,content_3824_3852:()=>WNn,content_3824_3854:()=>GNn,content_3824_3856:()=>UNn,content_3824_3858:()=>qNn,content_3824_386:()=>_7,content_3824_3860:()=>YNn,content_3824_3862:()=>KNn,content_3824_3864:()=>ekn,content_3824_3866:()=>okn,content_3824_3868:()=>skn,content_3824_3870:()=>ikn,content_3824_3872:()=>mkn,content_3824_3874:()=>hkn,content_3824_3876:()=>Dkn,content_3824_3878:()=>_kn,content_3824_388:()=>C7,content_3824_3880:()=>Ckn,content_3824_3882:()=>vkn,content_3824_3884:()=>Nkn,content_3824_3886:()=>Pkn,content_3824_3888:()=>Wkn,content_3824_3890:()=>Gkn,content_3824_3892:()=>Ukn,content_3824_3894:()=>qkn,content_3824_3896:()=>Ykn,content_3824_3898:()=>Kkn,content_3824_390:()=>v7,content_3824_3900:()=>ezn,content_3824_3902:()=>ozn,content_3824_3904:()=>szn,content_3824_3906:()=>izn,content_3824_3908:()=>mzn,content_3824_3910:()=>hzn,content_3824_3912:()=>Dzn,content_3824_3914:()=>_zn,content_3824_3916:()=>Czn,content_3824_3918:()=>vzn,content_3824_392:()=>N7,content_3824_3920:()=>Nzn,content_3824_3922:()=>Pzn,content_3824_3924:()=>Wzn,content_3824_3926:()=>Gzn,content_3824_3928:()=>Uzn,content_3824_3930:()=>qzn,content_3824_3932:()=>Yzn,content_3824_3934:()=>Kzn,content_3824_3936:()=>ePn,content_3824_3938:()=>oPn,content_3824_394:()=>P7,content_3824_3940:()=>sPn,content_3824_3942:()=>iPn,content_3824_3944:()=>mPn,content_3824_3946:()=>hPn,content_3824_3948:()=>DPn,content_3824_3950:()=>_Pn,content_3824_3952:()=>CPn,content_3824_3954:()=>vPn,content_3824_3956:()=>NPn,content_3824_3958:()=>PPn,content_3824_396:()=>W7,content_3824_3960:()=>WPn,content_3824_3962:()=>GPn,content_3824_3964:()=>UPn,content_3824_3966:()=>qPn,content_3824_3968:()=>YPn,content_3824_3970:()=>KPn,content_3824_3972:()=>eIn,content_3824_3974:()=>oIn,content_3824_3976:()=>sIn,content_3824_3978:()=>iIn,content_3824_398:()=>G7,content_3824_3980:()=>mIn,content_3824_3982:()=>hIn,content_3824_3984:()=>DIn,content_3824_3986:()=>_In,content_3824_3988:()=>CIn,content_3824_3990:()=>vIn,content_3824_3992:()=>NIn,content_3824_3994:()=>PIn,content_3824_3996:()=>WIn,content_3824_3998:()=>GIn,content_3824_4:()=>UK,content_3824_40:()=>UJ,content_3824_400:()=>U7,content_3824_4000:()=>UIn,content_3824_4002:()=>qIn,content_3824_4004:()=>YIn,content_3824_4006:()=>KIn,content_3824_4008:()=>eRn,content_3824_4010:()=>oRn,content_3824_4012:()=>sRn,content_3824_4014:()=>iRn,content_3824_4016:()=>mRn,content_3824_4018:()=>hRn,content_3824_402:()=>q7,content_3824_4020:()=>DRn,content_3824_4022:()=>_Rn,content_3824_4024:()=>CRn,content_3824_4026:()=>vRn,content_3824_4028:()=>NRn,content_3824_4030:()=>PRn,content_3824_4032:()=>WRn,content_3824_4034:()=>GRn,content_3824_4036:()=>URn,content_3824_4038:()=>qRn,content_3824_404:()=>Y7,content_3824_4040:()=>YRn,content_3824_4042:()=>KRn,content_3824_4044:()=>eWn,content_3824_4046:()=>oWn,content_3824_4048:()=>sWn,content_3824_4050:()=>iWn,content_3824_4052:()=>mWn,content_3824_4054:()=>hWn,content_3824_4056:()=>DWn,content_3824_4058:()=>_Wn,content_3824_406:()=>K7,content_3824_4060:()=>CWn,content_3824_4062:()=>vWn,content_3824_4064:()=>NWn,content_3824_4066:()=>PWn,content_3824_4068:()=>WWn,content_3824_4070:()=>GWn,content_3824_4072:()=>UWn,content_3824_4074:()=>qWn,content_3824_4076:()=>YWn,content_3824_4078:()=>KWn,content_3824_408:()=>e9,content_3824_4080:()=>eSn,content_3824_4082:()=>oSn,content_3824_4084:()=>sSn,content_3824_4086:()=>iSn,content_3824_4088:()=>mSn,content_3824_4090:()=>hSn,content_3824_4092:()=>DSn,content_3824_4094:()=>_Sn,content_3824_4096:()=>CSn,content_3824_4098:()=>vSn,content_3824_410:()=>o9,content_3824_4100:()=>NSn,content_3824_4102:()=>PSn,content_3824_4104:()=>WSn,content_3824_4106:()=>GSn,content_3824_4108:()=>USn,content_3824_4110:()=>qSn,content_3824_4112:()=>YSn,content_3824_4114:()=>KSn,content_3824_4116:()=>eBn,content_3824_4118:()=>oBn,content_3824_412:()=>s9,content_3824_4120:()=>sBn,content_3824_4122:()=>iBn,content_3824_4124:()=>mBn,content_3824_4126:()=>hBn,content_3824_4128:()=>DBn,content_3824_4130:()=>_Bn,content_3824_4132:()=>CBn,content_3824_4134:()=>vBn,content_3824_4136:()=>NBn,content_3824_4138:()=>PBn,content_3824_414:()=>i9,content_3824_4140:()=>WBn,content_3824_4142:()=>GBn,content_3824_4144:()=>UBn,content_3824_4146:()=>qBn,content_3824_4148:()=>YBn,content_3824_4150:()=>KBn,content_3824_4152:()=>eGn,content_3824_4154:()=>oGn,content_3824_4156:()=>sGn,content_3824_4158:()=>iGn,content_3824_416:()=>m9,content_3824_4160:()=>mGn,content_3824_4162:()=>hGn,content_3824_4164:()=>DGn,content_3824_4166:()=>_Gn,content_3824_4168:()=>CGn,content_3824_4170:()=>vGn,content_3824_4172:()=>NGn,content_3824_4174:()=>PGn,content_3824_4176:()=>WGn,content_3824_4178:()=>GGn,content_3824_418:()=>h9,content_3824_4180:()=>UGn,content_3824_4182:()=>qGn,content_3824_4184:()=>YGn,content_3824_4186:()=>KGn,content_3824_4188:()=>eEn,content_3824_4190:()=>oEn,content_3824_4192:()=>sEn,content_3824_4194:()=>iEn,content_3824_4196:()=>mEn,content_3824_4198:()=>hEn,content_3824_42:()=>qJ,content_3824_420:()=>D9,content_3824_4200:()=>DEn,content_3824_4202:()=>_En,content_3824_4204:()=>CEn,content_3824_4206:()=>vEn,content_3824_4208:()=>NEn,content_3824_4210:()=>PEn,content_3824_4212:()=>WEn,content_3824_4214:()=>GEn,content_3824_4216:()=>UEn,content_3824_4218:()=>qEn,content_3824_422:()=>_9,content_3824_4220:()=>YEn,content_3824_4222:()=>KEn,content_3824_4224:()=>eOn,content_3824_4226:()=>oOn,content_3824_4228:()=>sOn,content_3824_4230:()=>iOn,content_3824_4232:()=>mOn,content_3824_4234:()=>hOn,content_3824_4236:()=>DOn,content_3824_4238:()=>_On,content_3824_424:()=>C9,content_3824_4240:()=>COn,content_3824_4242:()=>vOn,content_3824_4244:()=>NOn,content_3824_4246:()=>POn,content_3824_4248:()=>WOn,content_3824_4250:()=>GOn,content_3824_4252:()=>UOn,content_3824_4254:()=>qOn,content_3824_4256:()=>YOn,content_3824_4258:()=>KOn,content_3824_426:()=>v9,content_3824_4260:()=>eUn,content_3824_4262:()=>oUn,content_3824_4264:()=>sUn,content_3824_4266:()=>iUn,content_3824_4268:()=>mUn,content_3824_4270:()=>hUn,content_3824_4272:()=>DUn,content_3824_4274:()=>_Un,content_3824_4276:()=>CUn,content_3824_4278:()=>vUn,content_3824_428:()=>N9,content_3824_4280:()=>NUn,content_3824_4282:()=>PUn,content_3824_4284:()=>WUn,content_3824_4286:()=>GUn,content_3824_4288:()=>UUn,content_3824_4290:()=>qUn,content_3824_4292:()=>YUn,content_3824_4294:()=>KUn,content_3824_4296:()=>eFn,content_3824_4298:()=>oFn,content_3824_430:()=>P9,content_3824_4300:()=>sFn,content_3824_4302:()=>iFn,content_3824_4304:()=>mFn,content_3824_4306:()=>hFn,content_3824_4308:()=>DFn,content_3824_4310:()=>_Fn,content_3824_4312:()=>CFn,content_3824_4314:()=>vFn,content_3824_4316:()=>NFn,content_3824_4318:()=>PFn,content_3824_432:()=>W9,content_3824_4320:()=>WFn,content_3824_4322:()=>GFn,content_3824_4324:()=>UFn,content_3824_4326:()=>qFn,content_3824_4328:()=>YFn,content_3824_4330:()=>KFn,content_3824_4332:()=>eVn,content_3824_4334:()=>oVn,content_3824_4336:()=>sVn,content_3824_4338:()=>iVn,content_3824_434:()=>G9,content_3824_4340:()=>mVn,content_3824_4342:()=>hVn,content_3824_4344:()=>DVn,content_3824_4346:()=>_Vn,content_3824_4348:()=>CVn,content_3824_4350:()=>vVn,content_3824_4352:()=>NVn,content_3824_4354:()=>PVn,content_3824_4356:()=>WVn,content_3824_4358:()=>GVn,content_3824_436:()=>U9,content_3824_4360:()=>UVn,content_3824_4362:()=>qVn,content_3824_4364:()=>YVn,content_3824_4366:()=>KVn,content_3824_4368:()=>eqn,content_3824_4370:()=>oqn,content_3824_4372:()=>sqn,content_3824_4374:()=>iqn,content_3824_4376:()=>mqn,content_3824_4378:()=>hqn,content_3824_438:()=>q9,content_3824_4380:()=>Dqn,content_3824_4382:()=>_qn,content_3824_4384:()=>Cqn,content_3824_4386:()=>vqn,content_3824_4388:()=>Nqn,content_3824_4390:()=>Pqn,content_3824_4392:()=>Wqn,content_3824_4394:()=>Gqn,content_3824_4396:()=>Uqn,content_3824_4398:()=>qqn,content_3824_44:()=>YJ,content_3824_440:()=>Y9,content_3824_4400:()=>Yqn,content_3824_4402:()=>Kqn,content_3824_4404:()=>ejn,content_3824_4406:()=>ojn,content_3824_4408:()=>sjn,content_3824_4410:()=>ijn,content_3824_4412:()=>mjn,content_3824_4414:()=>hjn,content_3824_4416:()=>Djn,content_3824_4418:()=>_jn,content_3824_442:()=>K9,content_3824_4420:()=>Cjn,content_3824_4422:()=>vjn,content_3824_4424:()=>Njn,content_3824_4426:()=>Pjn,content_3824_4428:()=>Wjn,content_3824_4430:()=>Gjn,content_3824_4432:()=>Ujn,content_3824_4434:()=>qjn,content_3824_4436:()=>Yjn,content_3824_4438:()=>Kjn,content_3824_444:()=>eee,content_3824_4440:()=>eHn,content_3824_4442:()=>oHn,content_3824_4444:()=>sHn,content_3824_4446:()=>iHn,content_3824_4448:()=>mHn,content_3824_4450:()=>hHn,content_3824_4452:()=>DHn,content_3824_4454:()=>_Hn,content_3824_4456:()=>CHn,content_3824_4458:()=>vHn,content_3824_446:()=>oee,content_3824_4460:()=>NHn,content_3824_4462:()=>PHn,content_3824_4464:()=>WHn,content_3824_4466:()=>GHn,content_3824_4468:()=>UHn,content_3824_4470:()=>qHn,content_3824_4472:()=>YHn,content_3824_4474:()=>KHn,content_3824_4476:()=>eYn,content_3824_4478:()=>oYn,content_3824_448:()=>see,content_3824_4480:()=>sYn,content_3824_4482:()=>iYn,content_3824_4484:()=>mYn,content_3824_4486:()=>hYn,content_3824_4488:()=>DYn,content_3824_4490:()=>_Yn,content_3824_4492:()=>CYn,content_3824_4494:()=>vYn,content_3824_4496:()=>NYn,content_3824_4498:()=>PYn,content_3824_450:()=>iee,content_3824_4500:()=>WYn,content_3824_4502:()=>GYn,content_3824_4504:()=>UYn,content_3824_4506:()=>qYn,content_3824_4508:()=>YYn,content_3824_4510:()=>KYn,content_3824_4512:()=>eQn,content_3824_4514:()=>oQn,content_3824_4516:()=>sQn,content_3824_4518:()=>iQn,content_3824_452:()=>mee,content_3824_4520:()=>mQn,content_3824_4522:()=>hQn,content_3824_4524:()=>DQn,content_3824_4526:()=>_Qn,content_3824_4528:()=>CQn,content_3824_4530:()=>vQn,content_3824_4532:()=>NQn,content_3824_4534:()=>PQn,content_3824_4536:()=>WQn,content_3824_4538:()=>GQn,content_3824_454:()=>hee,content_3824_4540:()=>UQn,content_3824_4542:()=>qQn,content_3824_4544:()=>YQn,content_3824_4546:()=>KQn,content_3824_4548:()=>e$n,content_3824_4550:()=>o$n,content_3824_4552:()=>s$n,content_3824_4554:()=>i$n,content_3824_4556:()=>m$n,content_3824_4558:()=>h$n,content_3824_456:()=>Dee,content_3824_4560:()=>D$n,content_3824_4562:()=>_$n,content_3824_4564:()=>C$n,content_3824_4566:()=>v$n,content_3824_4568:()=>N$n,content_3824_4570:()=>P$n,content_3824_4572:()=>W$n,content_3824_4574:()=>G$n,content_3824_4576:()=>U$n,content_3824_4578:()=>q$n,content_3824_458:()=>_ee,content_3824_4580:()=>Y$n,content_3824_4582:()=>K$n,content_3824_4584:()=>eKn,content_3824_4586:()=>oKn,content_3824_4588:()=>sKn,content_3824_4590:()=>iKn,content_3824_4592:()=>mKn,content_3824_4594:()=>hKn,content_3824_4596:()=>DKn,content_3824_4598:()=>_Kn,content_3824_46:()=>KJ,content_3824_460:()=>Cee,content_3824_4600:()=>CKn,content_3824_4602:()=>vKn,content_3824_4604:()=>NKn,content_3824_4606:()=>PKn,content_3824_4608:()=>WKn,content_3824_4610:()=>GKn,content_3824_4612:()=>UKn,content_3824_4614:()=>qKn,content_3824_4616:()=>YKn,content_3824_4618:()=>KKn,content_3824_462:()=>vee,content_3824_4620:()=>eJn,content_3824_4622:()=>oJn,content_3824_4624:()=>sJn,content_3824_4626:()=>iJn,content_3824_4628:()=>mJn,content_3824_4630:()=>hJn,content_3824_4632:()=>DJn,content_3824_4634:()=>_Jn,content_3824_4636:()=>CJn,content_3824_4638:()=>vJn,content_3824_464:()=>Nee,content_3824_4640:()=>NJn,content_3824_4642:()=>PJn,content_3824_4644:()=>WJn,content_3824_4646:()=>GJn,content_3824_4648:()=>UJn,content_3824_4650:()=>qJn,content_3824_4652:()=>YJn,content_3824_4654:()=>KJn,content_3824_4656:()=>eZn,content_3824_4658:()=>oZn,content_3824_466:()=>Pee,content_3824_4660:()=>sZn,content_3824_4662:()=>iZn,content_3824_4664:()=>mZn,content_3824_4666:()=>hZn,content_3824_4668:()=>DZn,content_3824_4670:()=>_Zn,content_3824_4672:()=>CZn,content_3824_4674:()=>vZn,content_3824_4676:()=>NZn,content_3824_4678:()=>PZn,content_3824_468:()=>Wee,content_3824_4680:()=>WZn,content_3824_4682:()=>GZn,content_3824_4684:()=>UZn,content_3824_4686:()=>qZn,content_3824_4688:()=>YZn,content_3824_4690:()=>KZn,content_3824_4692:()=>e0n,content_3824_4694:()=>o0n,content_3824_4696:()=>s0n,content_3824_4698:()=>i0n,content_3824_470:()=>Gee,content_3824_4700:()=>m0n,content_3824_4702:()=>h0n,content_3824_4704:()=>D0n,content_3824_4706:()=>_0n,content_3824_4708:()=>C0n,content_3824_4710:()=>v0n,content_3824_4712:()=>N0n,content_3824_4714:()=>P0n,content_3824_4716:()=>W0n,content_3824_4718:()=>G0n,content_3824_472:()=>Uee,content_3824_4720:()=>U0n,content_3824_4722:()=>q0n,content_3824_4724:()=>Y0n,content_3824_4726:()=>K0n,content_3824_4728:()=>e2n,content_3824_4730:()=>o2n,content_3824_4732:()=>s2n,content_3824_4734:()=>i2n,content_3824_4736:()=>m2n,content_3824_4738:()=>h2n,content_3824_474:()=>qee,content_3824_4740:()=>D2n,content_3824_4742:()=>_2n,content_3824_4744:()=>C2n,content_3824_4746:()=>v2n,content_3824_4748:()=>N2n,content_3824_4750:()=>P2n,content_3824_4752:()=>W2n,content_3824_4754:()=>G2n,content_3824_4756:()=>U2n,content_3824_4758:()=>q2n,content_3824_476:()=>Yee,content_3824_4760:()=>Y2n,content_3824_4762:()=>K2n,content_3824_4764:()=>e4n,content_3824_4766:()=>o4n,content_3824_4768:()=>s4n,content_3824_4770:()=>i4n,content_3824_4772:()=>m4n,content_3824_4774:()=>h4n,content_3824_4776:()=>D4n,content_3824_4778:()=>_4n,content_3824_478:()=>Kee,content_3824_4780:()=>C4n,content_3824_4782:()=>v4n,content_3824_4784:()=>N4n,content_3824_4786:()=>P4n,content_3824_4788:()=>W4n,content_3824_4790:()=>G4n,content_3824_4792:()=>U4n,content_3824_4794:()=>q4n,content_3824_4796:()=>Y4n,content_3824_4798:()=>K4n,content_3824_48:()=>eZ,content_3824_480:()=>ene,content_3824_4800:()=>e8n,content_3824_4802:()=>o8n,content_3824_4804:()=>s8n,content_3824_4806:()=>i8n,content_3824_4808:()=>m8n,content_3824_4810:()=>h8n,content_3824_4812:()=>D8n,content_3824_4814:()=>_8n,content_3824_4816:()=>C8n,content_3824_4818:()=>v8n,content_3824_482:()=>one,content_3824_4820:()=>N8n,content_3824_4822:()=>P8n,content_3824_4824:()=>W8n,content_3824_4826:()=>G8n,content_3824_4828:()=>U8n,content_3824_4830:()=>q8n,content_3824_4832:()=>Y8n,content_3824_4834:()=>K8n,content_3824_4836:()=>e3n,content_3824_4838:()=>o3n,content_3824_484:()=>sne,content_3824_4840:()=>s3n,content_3824_4842:()=>i3n,content_3824_4844:()=>m3n,content_3824_4846:()=>h3n,content_3824_4848:()=>D3n,content_3824_4850:()=>_3n,content_3824_4852:()=>C3n,content_3824_4854:()=>v3n,content_3824_4856:()=>N3n,content_3824_4858:()=>P3n,content_3824_486:()=>ine,content_3824_4860:()=>W3n,content_3824_4862:()=>G3n,content_3824_4864:()=>U3n,content_3824_4866:()=>q3n,content_3824_4868:()=>Y3n,content_3824_4870:()=>K3n,content_3824_4872:()=>e1n,content_3824_4874:()=>o1n,content_3824_4876:()=>s1n,content_3824_4878:()=>i1n,content_3824_488:()=>mne,content_3824_4880:()=>m1n,content_3824_4882:()=>h1n,content_3824_4884:()=>D1n,content_3824_4886:()=>_1n,content_3824_4888:()=>C1n,content_3824_4890:()=>v1n,content_3824_4892:()=>N1n,content_3824_4894:()=>P1n,content_3824_4896:()=>W1n,content_3824_4898:()=>G1n,content_3824_490:()=>hne,content_3824_4900:()=>U1n,content_3824_4902:()=>q1n,content_3824_4904:()=>Y1n,content_3824_4906:()=>K1n,content_3824_4908:()=>e6n,content_3824_4910:()=>o6n,content_3824_4912:()=>s6n,content_3824_4914:()=>i6n,content_3824_4916:()=>m6n,content_3824_4918:()=>h6n,content_3824_492:()=>Dne,content_3824_4920:()=>D6n,content_3824_4922:()=>_6n,content_3824_4924:()=>C6n,content_3824_4926:()=>v6n,content_3824_4928:()=>N6n,content_3824_4930:()=>P6n,content_3824_4932:()=>W6n,content_3824_4934:()=>G6n,content_3824_4936:()=>U6n,content_3824_4938:()=>q6n,content_3824_494:()=>_ne,content_3824_4940:()=>Y6n,content_3824_4942:()=>K6n,content_3824_4944:()=>e5n,content_3824_4946:()=>o5n,content_3824_4948:()=>s5n,content_3824_4950:()=>i5n,content_3824_4952:()=>m5n,content_3824_4954:()=>h5n,content_3824_4956:()=>D5n,content_3824_4958:()=>_5n,content_3824_496:()=>Cne,content_3824_4960:()=>C5n,content_3824_4962:()=>v5n,content_3824_4964:()=>N5n,content_3824_4966:()=>P5n,content_3824_4968:()=>W5n,content_3824_4970:()=>G5n,content_3824_4972:()=>U5n,content_3824_4974:()=>q5n,content_3824_4976:()=>Y5n,content_3824_4978:()=>K5n,content_3824_498:()=>vne,content_3824_4980:()=>e7n,content_3824_4982:()=>o7n,content_3824_4984:()=>s7n,content_3824_4986:()=>i7n,content_3824_4988:()=>m7n,content_3824_4990:()=>h7n,content_3824_4992:()=>D7n,content_3824_4994:()=>_7n,content_3824_4996:()=>C7n,content_3824_4998:()=>v7n,content_3824_50:()=>oZ,content_3824_500:()=>Nne,content_3824_5000:()=>N7n,content_3824_5002:()=>P7n,content_3824_5004:()=>W7n,content_3824_5006:()=>G7n,content_3824_5008:()=>U7n,content_3824_5010:()=>q7n,content_3824_5012:()=>Y7n,content_3824_5014:()=>K7n,content_3824_5016:()=>e9n,content_3824_5018:()=>o9n,content_3824_502:()=>Pne,content_3824_5020:()=>s9n,content_3824_5022:()=>i9n,content_3824_5024:()=>m9n,content_3824_5026:()=>h9n,content_3824_5028:()=>D9n,content_3824_5030:()=>_9n,content_3824_5032:()=>C9n,content_3824_5034:()=>v9n,content_3824_5036:()=>N9n,content_3824_5038:()=>P9n,content_3824_504:()=>Wne,content_3824_5040:()=>W9n,content_3824_5042:()=>G9n,content_3824_5044:()=>U9n,content_3824_5046:()=>q9n,content_3824_5048:()=>Y9n,content_3824_5050:()=>K9n,content_3824_5052:()=>eet,content_3824_5054:()=>oet,content_3824_5056:()=>set,content_3824_5058:()=>iet,content_3824_506:()=>Gne,content_3824_5060:()=>yet,content_3824_5062:()=>get,content_3824_5064:()=>Met,content_3824_5066:()=>wet,content_3824_5068:()=>xet,content_3824_5070:()=>Let,content_3824_5072:()=>ket,content_3824_5074:()=>Iet,content_3824_5076:()=>Set,content_3824_5078:()=>Eet,content_3824_508:()=>Une,content_3824_5080:()=>Fet,content_3824_5082:()=>jet,content_3824_5084:()=>Qet,content_3824_5086:()=>Jet,content_3824_5088:()=>nnt,content_3824_5090:()=>pnt,content_3824_5092:()=>cnt,content_3824_5094:()=>lnt,content_3824_5096:()=>ynt,content_3824_5098:()=>gnt,content_3824_510:()=>qne,content_3824_5100:()=>Mnt,content_3824_5102:()=>wnt,content_3824_5104:()=>xnt,content_3824_5106:()=>Lnt,content_3824_5108:()=>knt,content_3824_5110:()=>Int,content_3824_5112:()=>Snt,content_3824_5114:()=>Ent,content_3824_5116:()=>Fnt,content_3824_5118:()=>jnt,content_3824_512:()=>Yne,content_3824_5120:()=>Qnt,content_3824_5122:()=>Jnt,content_3824_5124:()=>ntt,content_3824_5126:()=>ptt,content_3824_5128:()=>ctt,content_3824_5130:()=>ltt,content_3824_5132:()=>ytt,content_3824_5134:()=>gtt,content_3824_5136:()=>Mtt,content_3824_5138:()=>wtt,content_3824_514:()=>Kne,content_3824_5140:()=>xtt,content_3824_5142:()=>Ltt,content_3824_5144:()=>ktt,content_3824_5146:()=>Itt,content_3824_5148:()=>Stt,content_3824_5150:()=>Ett,content_3824_5152:()=>Ftt,content_3824_5154:()=>jtt,content_3824_5156:()=>Qtt,content_3824_5158:()=>Jtt,content_3824_516:()=>ete,content_3824_5160:()=>not,content_3824_5162:()=>pot,content_3824_5164:()=>cot,content_3824_5166:()=>lot,content_3824_5168:()=>yot,content_3824_5170:()=>got,content_3824_5172:()=>Mot,content_3824_5174:()=>wot,content_3824_5176:()=>xot,content_3824_5178:()=>Lot,content_3824_518:()=>ote,content_3824_5180:()=>kot,content_3824_5182:()=>Iot,content_3824_5184:()=>Sot,content_3824_5186:()=>Eot,content_3824_5188:()=>Fot,content_3824_5190:()=>jot,content_3824_5192:()=>Qot,content_3824_5194:()=>Jot,content_3824_5196:()=>npt,content_3824_5198:()=>ppt,content_3824_52:()=>sZ,content_3824_520:()=>ste,content_3824_5200:()=>cpt,content_3824_5202:()=>lpt,content_3824_5204:()=>ypt,content_3824_5206:()=>gpt,content_3824_5208:()=>Mpt,content_3824_5210:()=>wpt,content_3824_5212:()=>xpt,content_3824_5214:()=>Lpt,content_3824_5216:()=>kpt,content_3824_5218:()=>Ipt,content_3824_522:()=>ite,content_3824_5220:()=>Spt,content_3824_5222:()=>Ept,content_3824_5224:()=>Fpt,content_3824_5226:()=>jpt,content_3824_5228:()=>Qpt,content_3824_5230:()=>Jpt,content_3824_5232:()=>nrt,content_3824_5234:()=>prt,content_3824_5236:()=>crt,content_3824_5238:()=>lrt,content_3824_524:()=>mte,content_3824_5240:()=>yrt,content_3824_5242:()=>grt,content_3824_5244:()=>Mrt,content_3824_5246:()=>wrt,content_3824_5248:()=>xrt,content_3824_5250:()=>Lrt,content_3824_5252:()=>krt,content_3824_5254:()=>Irt,content_3824_5256:()=>Srt,content_3824_5258:()=>Ert,content_3824_526:()=>hte,content_3824_5260:()=>Frt,content_3824_5262:()=>jrt,content_3824_5264:()=>Qrt,content_3824_5266:()=>Jrt,content_3824_5268:()=>nst,content_3824_5270:()=>pst,content_3824_5272:()=>cst,content_3824_5274:()=>lst,content_3824_5276:()=>yst,content_3824_5278:()=>gst,content_3824_528:()=>Dte,content_3824_5280:()=>Mst,content_3824_5282:()=>wst,content_3824_5284:()=>xst,content_3824_5286:()=>Lst,content_3824_5288:()=>kst,content_3824_5290:()=>Ist,content_3824_5292:()=>Sst,content_3824_5294:()=>Est,content_3824_5296:()=>Fst,content_3824_5298:()=>jst,content_3824_530:()=>_te,content_3824_5300:()=>Qst,content_3824_5302:()=>Jst,content_3824_5304:()=>nct,content_3824_5306:()=>pct,content_3824_5308:()=>cct,content_3824_5310:()=>lct,content_3824_5312:()=>yct,content_3824_5314:()=>gct,content_3824_5316:()=>Mct,content_3824_5318:()=>wct,content_3824_532:()=>Cte,content_3824_5320:()=>xct,content_3824_5322:()=>Lct,content_3824_5324:()=>kct,content_3824_5326:()=>Ict,content_3824_5328:()=>Sct,content_3824_5330:()=>Ect,content_3824_5332:()=>Fct,content_3824_5334:()=>jct,content_3824_5336:()=>Qct,content_3824_5338:()=>Jct,content_3824_534:()=>vte,content_3824_5340:()=>nat,content_3824_5342:()=>pat,content_3824_5344:()=>cat,content_3824_5346:()=>lat,content_3824_5348:()=>yat,content_3824_5350:()=>gat,content_3824_5352:()=>Mat,content_3824_5354:()=>wat,content_3824_5356:()=>xat,content_3824_5358:()=>Lat,content_3824_536:()=>Nte,content_3824_5360:()=>kat,content_3824_5362:()=>Iat,content_3824_5364:()=>Sat,content_3824_5366:()=>Eat,content_3824_5368:()=>Fat,content_3824_5370:()=>jat,content_3824_5372:()=>Qat,content_3824_5374:()=>Jat,content_3824_5376:()=>nit,content_3824_5378:()=>pit,content_3824_538:()=>Pte,content_3824_5380:()=>cit,content_3824_5382:()=>lit,content_3824_5384:()=>yit,content_3824_5386:()=>git,content_3824_5388:()=>Mit,content_3824_5390:()=>wit,content_3824_5392:()=>xit,content_3824_5394:()=>Lit,content_3824_5396:()=>kit,content_3824_5398:()=>Iit,content_3824_54:()=>iZ,content_3824_540:()=>Wte,content_3824_5400:()=>Sit,content_3824_5402:()=>Eit,content_3824_5404:()=>Fit,content_3824_5406:()=>jit,content_3824_5408:()=>Qit,content_3824_5410:()=>Jit,content_3824_5412:()=>nlt,content_3824_5414:()=>plt,content_3824_5416:()=>clt,content_3824_5418:()=>llt,content_3824_542:()=>Gte,content_3824_5420:()=>ylt,content_3824_5422:()=>glt,content_3824_5424:()=>Mlt,content_3824_5426:()=>wlt,content_3824_5428:()=>xlt,content_3824_5430:()=>Llt,content_3824_5432:()=>klt,content_3824_5434:()=>Ilt,content_3824_5436:()=>Slt,content_3824_5438:()=>Elt,content_3824_544:()=>Ute,content_3824_5440:()=>Flt,content_3824_5442:()=>jlt,content_3824_5444:()=>Qlt,content_3824_5446:()=>Jlt,content_3824_5448:()=>nut,content_3824_5450:()=>put,content_3824_5452:()=>cut,content_3824_5454:()=>lut,content_3824_5456:()=>yut,content_3824_5458:()=>gut,content_3824_546:()=>qte,content_3824_5460:()=>Mut,content_3824_5462:()=>wut,content_3824_5464:()=>xut,content_3824_5466:()=>Lut,content_3824_5468:()=>kut,content_3824_5470:()=>Iut,content_3824_5472:()=>Sut,content_3824_5474:()=>Eut,content_3824_5476:()=>Fut,content_3824_5478:()=>jut,content_3824_548:()=>Yte,content_3824_5480:()=>Qut,content_3824_5482:()=>Jut,content_3824_5484:()=>nmt,content_3824_5486:()=>pmt,content_3824_5488:()=>cmt,content_3824_5490:()=>lmt,content_3824_5492:()=>ymt,content_3824_5494:()=>gmt,content_3824_5496:()=>Mmt,content_3824_5498:()=>wmt,content_3824_550:()=>Kte,content_3824_5500:()=>xmt,content_3824_5502:()=>Lmt,content_3824_5504:()=>kmt,content_3824_5506:()=>Imt,content_3824_5508:()=>Smt,content_3824_5510:()=>Emt,content_3824_5512:()=>Fmt,content_3824_5514:()=>jmt,content_3824_5516:()=>Qmt,content_3824_5518:()=>Jmt,content_3824_552:()=>eoe,content_3824_5520:()=>nyt,content_3824_5522:()=>pyt,content_3824_5524:()=>cyt,content_3824_5526:()=>lyt,content_3824_5528:()=>yyt,content_3824_5530:()=>gyt,content_3824_5532:()=>Myt,content_3824_5534:()=>wyt,content_3824_5536:()=>xyt,content_3824_5538:()=>Lyt,content_3824_554:()=>ooe,content_3824_5540:()=>kyt,content_3824_5542:()=>Iyt,content_3824_5544:()=>Syt,content_3824_5546:()=>Eyt,content_3824_5548:()=>Fyt,content_3824_5550:()=>jyt,content_3824_5552:()=>Qyt,content_3824_5554:()=>Jyt,content_3824_5556:()=>ndt,content_3824_5558:()=>pdt,content_3824_556:()=>soe,content_3824_5560:()=>cdt,content_3824_5562:()=>ldt,content_3824_5564:()=>ydt,content_3824_5566:()=>gdt,content_3824_5568:()=>Mdt,content_3824_5570:()=>wdt,content_3824_5572:()=>xdt,content_3824_5574:()=>Ldt,content_3824_5576:()=>kdt,content_3824_5578:()=>Idt,content_3824_558:()=>ioe,content_3824_5580:()=>Sdt,content_3824_5582:()=>Edt,content_3824_5584:()=>Fdt,content_3824_5586:()=>jdt,content_3824_5588:()=>Qdt,content_3824_5590:()=>Jdt,content_3824_5592:()=>nht,content_3824_5594:()=>pht,content_3824_5596:()=>cht,content_3824_5598:()=>lht,content_3824_56:()=>mZ,content_3824_560:()=>moe,content_3824_5600:()=>yht,content_3824_5602:()=>ght,content_3824_5604:()=>Mht,content_3824_5606:()=>wht,content_3824_5608:()=>xht,content_3824_5610:()=>Lht,content_3824_5612:()=>kht,content_3824_5614:()=>Iht,content_3824_5616:()=>Sht,content_3824_5618:()=>Eht,content_3824_562:()=>hoe,content_3824_5620:()=>Fht,content_3824_5622:()=>jht,content_3824_5624:()=>Qht,content_3824_5626:()=>Jht,content_3824_5628:()=>ngt,content_3824_5630:()=>pgt,content_3824_5632:()=>cgt,content_3824_5634:()=>lgt,content_3824_5636:()=>ygt,content_3824_5638:()=>ggt,content_3824_564:()=>Doe,content_3824_5640:()=>Mgt,content_3824_5642:()=>wgt,content_3824_5644:()=>xgt,content_3824_5646:()=>Lgt,content_3824_5648:()=>kgt,content_3824_5650:()=>Igt,content_3824_5652:()=>Sgt,content_3824_5654:()=>Egt,content_3824_5656:()=>Fgt,content_3824_5658:()=>jgt,content_3824_566:()=>_oe,content_3824_5660:()=>Qgt,content_3824_5662:()=>Jgt,content_3824_5664:()=>nft,content_3824_5666:()=>pft,content_3824_5668:()=>cft,content_3824_5670:()=>lft,content_3824_5672:()=>yft,content_3824_5674:()=>gft,content_3824_5676:()=>Mft,content_3824_5678:()=>wft,content_3824_568:()=>Coe,content_3824_5680:()=>xft,content_3824_5682:()=>Lft,content_3824_5684:()=>kft,content_3824_5686:()=>Ift,content_3824_5688:()=>Sft,content_3824_5690:()=>Eft,content_3824_5692:()=>Fft,content_3824_5694:()=>jft,content_3824_5696:()=>Qft,content_3824_5698:()=>Jft,content_3824_570:()=>voe,content_3824_5700:()=>nDt,content_3824_5702:()=>pDt,content_3824_5704:()=>cDt,content_3824_5706:()=>lDt,content_3824_5708:()=>yDt,content_3824_5710:()=>gDt,content_3824_5712:()=>MDt,content_3824_5714:()=>wDt,content_3824_5716:()=>xDt,content_3824_5718:()=>LDt,content_3824_572:()=>Noe,content_3824_5720:()=>kDt,content_3824_5722:()=>IDt,content_3824_5724:()=>SDt,content_3824_5726:()=>EDt,content_3824_5728:()=>FDt,content_3824_5730:()=>jDt,content_3824_5732:()=>QDt,content_3824_5734:()=>JDt,content_3824_5736:()=>nMt,content_3824_5738:()=>pMt,content_3824_574:()=>Poe,content_3824_5740:()=>cMt,content_3824_5742:()=>lMt,content_3824_5744:()=>yMt,content_3824_5746:()=>gMt,content_3824_5748:()=>MMt,content_3824_5750:()=>wMt,content_3824_5752:()=>xMt,content_3824_5754:()=>LMt,content_3824_5756:()=>kMt,content_3824_5758:()=>IMt,content_3824_576:()=>Woe,content_3824_5760:()=>SMt,content_3824_5762:()=>EMt,content_3824_5764:()=>FMt,content_3824_5766:()=>jMt,content_3824_5768:()=>QMt,content_3824_5770:()=>JMt,content_3824_5772:()=>nXt,content_3824_5774:()=>pXt,content_3824_5776:()=>cXt,content_3824_5778:()=>lXt,content_3824_578:()=>Goe,content_3824_5780:()=>yXt,content_3824_5782:()=>gXt,content_3824_5784:()=>MXt,content_3824_5786:()=>wXt,content_3824_5788:()=>xXt,content_3824_5790:()=>LXt,content_3824_5792:()=>kXt,content_3824_5794:()=>IXt,content_3824_5796:()=>SXt,content_3824_5798:()=>EXt,content_3824_58:()=>hZ,content_3824_580:()=>Uoe,content_3824_5800:()=>FXt,content_3824_5802:()=>jXt,content_3824_5804:()=>QXt,content_3824_5806:()=>JXt,content_3824_5808:()=>n_t,content_3824_5810:()=>p_t,content_3824_5812:()=>c_t,content_3824_5814:()=>l_t,content_3824_5816:()=>y_t,content_3824_5818:()=>g_t,content_3824_582:()=>qoe,content_3824_5820:()=>M_t,content_3824_5822:()=>w_t,content_3824_5824:()=>x_t,content_3824_5826:()=>L_t,content_3824_5828:()=>k_t,content_3824_5830:()=>I_t,content_3824_5832:()=>S_t,content_3824_5834:()=>E_t,content_3824_5836:()=>F_t,content_3824_5838:()=>j_t,content_3824_584:()=>Yoe,content_3824_5840:()=>Q_t,content_3824_5842:()=>J_t,content_3824_5844:()=>nwt,content_3824_5846:()=>pwt,content_3824_5848:()=>cwt,content_3824_5850:()=>lwt,content_3824_5852:()=>ywt,content_3824_5854:()=>gwt,content_3824_5856:()=>Mwt,content_3824_5858:()=>wwt,content_3824_586:()=>Koe,content_3824_5860:()=>xwt,content_3824_5862:()=>Lwt,content_3824_5864:()=>kwt,content_3824_5866:()=>Iwt,content_3824_5868:()=>Swt,content_3824_5870:()=>Ewt,content_3824_5872:()=>Fwt,content_3824_5874:()=>jwt,content_3824_5876:()=>Qwt,content_3824_5878:()=>Jwt,content_3824_588:()=>epe,content_3824_5880:()=>nTt,content_3824_5882:()=>pTt,content_3824_5884:()=>cTt,content_3824_5886:()=>lTt,content_3824_5888:()=>yTt,content_3824_5890:()=>gTt,content_3824_5892:()=>MTt,content_3824_5894:()=>wTt,content_3824_5896:()=>xTt,content_3824_5898:()=>LTt,content_3824_590:()=>ope,content_3824_5900:()=>kTt,content_3824_5902:()=>ITt,content_3824_5904:()=>STt,content_3824_5906:()=>ETt,content_3824_5908:()=>FTt,content_3824_5910:()=>jTt,content_3824_5912:()=>QTt,content_3824_5914:()=>JTt,content_3824_5916:()=>nCt,content_3824_5918:()=>pCt,content_3824_592:()=>spe,content_3824_5920:()=>cCt,content_3824_5922:()=>lCt,content_3824_5924:()=>yCt,content_3824_5926:()=>gCt,content_3824_5928:()=>MCt,content_3824_5930:()=>wCt,content_3824_5932:()=>xCt,content_3824_5934:()=>LCt,content_3824_5936:()=>kCt,content_3824_5938:()=>ICt,content_3824_594:()=>ipe,content_3824_5940:()=>SCt,content_3824_5942:()=>ECt,content_3824_5944:()=>FCt,content_3824_5946:()=>jCt,content_3824_5948:()=>QCt,content_3824_5950:()=>JCt,content_3824_5952:()=>nxt,content_3824_5954:()=>pxt,content_3824_5956:()=>cxt,content_3824_5958:()=>lxt,content_3824_596:()=>mpe,content_3824_5960:()=>yxt,content_3824_5962:()=>gxt,content_3824_5964:()=>Mxt,content_3824_5966:()=>wxt,content_3824_5968:()=>xxt,content_3824_5970:()=>Lxt,content_3824_5972:()=>kxt,content_3824_5974:()=>Ixt,content_3824_5976:()=>Sxt,content_3824_5978:()=>Ext,content_3824_598:()=>hpe,content_3824_5980:()=>Fxt,content_3824_5982:()=>jxt,content_3824_5984:()=>Qxt,content_3824_5986:()=>Jxt,content_3824_5988:()=>nAt,content_3824_5990:()=>pAt,content_3824_5992:()=>cAt,content_3824_5994:()=>lAt,content_3824_5996:()=>yAt,content_3824_5998:()=>gAt,content_3824_6:()=>qK,content_3824_60:()=>DZ,content_3824_600:()=>Dpe,content_3824_6000:()=>MAt,content_3824_6002:()=>wAt,content_3824_6004:()=>xAt,content_3824_6006:()=>LAt,content_3824_6008:()=>kAt,content_3824_6010:()=>IAt,content_3824_6012:()=>SAt,content_3824_6014:()=>EAt,content_3824_6016:()=>FAt,content_3824_6018:()=>jAt,content_3824_602:()=>_pe,content_3824_6020:()=>QAt,content_3824_6022:()=>JAt,content_3824_6024:()=>nvt,content_3824_6026:()=>pvt,content_3824_6028:()=>cvt,content_3824_6030:()=>lvt,content_3824_6032:()=>yvt,content_3824_6034:()=>gvt,content_3824_6036:()=>Mvt,content_3824_6038:()=>wvt,content_3824_604:()=>Cpe,content_3824_6040:()=>xvt,content_3824_6042:()=>Lvt,content_3824_6044:()=>kvt,content_3824_6046:()=>Ivt,content_3824_6048:()=>Svt,content_3824_6050:()=>Evt,content_3824_6052:()=>Fvt,content_3824_6054:()=>jvt,content_3824_6056:()=>Qvt,content_3824_6058:()=>Jvt,content_3824_606:()=>vpe,content_3824_6060:()=>nLt,content_3824_6062:()=>pLt,content_3824_6064:()=>cLt,content_3824_6066:()=>lLt,content_3824_6068:()=>yLt,content_3824_6070:()=>gLt,content_3824_6072:()=>MLt,content_3824_6074:()=>wLt,content_3824_6076:()=>xLt,content_3824_6078:()=>LLt,content_3824_608:()=>Npe,content_3824_6080:()=>kLt,content_3824_6082:()=>ILt,content_3824_6084:()=>SLt,content_3824_6086:()=>ELt,content_3824_6088:()=>FLt,content_3824_6090:()=>jLt,content_3824_6092:()=>QLt,content_3824_6094:()=>JLt,content_3824_6096:()=>nbt,content_3824_6098:()=>pbt,content_3824_610:()=>Ppe,content_3824_6100:()=>cbt,content_3824_6102:()=>lbt,content_3824_6104:()=>ybt,content_3824_6106:()=>gbt,content_3824_6108:()=>Mbt,content_3824_6110:()=>wbt,content_3824_6112:()=>xbt,content_3824_6114:()=>Lbt,content_3824_6116:()=>kbt,content_3824_6118:()=>Ibt,content_3824_612:()=>Wpe,content_3824_6120:()=>Sbt,content_3824_6122:()=>Ebt,content_3824_6124:()=>Fbt,content_3824_6126:()=>jbt,content_3824_6128:()=>Qbt,content_3824_6130:()=>Jbt,content_3824_6132:()=>nNt,content_3824_6134:()=>pNt,content_3824_6136:()=>cNt,content_3824_6138:()=>lNt,content_3824_614:()=>Gpe,content_3824_6140:()=>yNt,content_3824_6142:()=>gNt,content_3824_6144:()=>MNt,content_3824_6146:()=>wNt,content_3824_6148:()=>xNt,content_3824_6150:()=>LNt,content_3824_6152:()=>kNt,content_3824_6154:()=>INt,content_3824_6156:()=>SNt,content_3824_6158:()=>ENt,content_3824_616:()=>Upe,content_3824_6160:()=>FNt,content_3824_6162:()=>jNt,content_3824_6164:()=>QNt,content_3824_6166:()=>JNt,content_3824_6168:()=>nkt,content_3824_6170:()=>pkt,content_3824_6172:()=>ckt,content_3824_6174:()=>lkt,content_3824_6176:()=>ykt,content_3824_6178:()=>gkt,content_3824_618:()=>qpe,content_3824_6180:()=>Mkt,content_3824_6182:()=>wkt,content_3824_6184:()=>xkt,content_3824_6186:()=>Lkt,content_3824_6188:()=>kkt,content_3824_6190:()=>Ikt,content_3824_6192:()=>Skt,content_3824_6194:()=>Ekt,content_3824_6196:()=>Fkt,content_3824_6198:()=>jkt,content_3824_62:()=>_Z,content_3824_620:()=>Ype,content_3824_6200:()=>Qkt,content_3824_6202:()=>Jkt,content_3824_6204:()=>nzt,content_3824_6206:()=>pzt,content_3824_6208:()=>czt,content_3824_6210:()=>lzt,content_3824_6212:()=>yzt,content_3824_6214:()=>gzt,content_3824_6216:()=>Mzt,content_3824_6218:()=>wzt,content_3824_622:()=>Kpe,content_3824_6220:()=>xzt,content_3824_6222:()=>Lzt,content_3824_6224:()=>kzt,content_3824_6226:()=>Izt,content_3824_6228:()=>Szt,content_3824_6230:()=>Ezt,content_3824_6232:()=>Fzt,content_3824_6234:()=>jzt,content_3824_6236:()=>Qzt,content_3824_6238:()=>Jzt,content_3824_624:()=>ere,content_3824_6240:()=>nPt,content_3824_6242:()=>pPt,content_3824_6244:()=>cPt,content_3824_6246:()=>lPt,content_3824_6248:()=>yPt,content_3824_6250:()=>gPt,content_3824_6252:()=>MPt,content_3824_6254:()=>wPt,content_3824_6256:()=>xPt,content_3824_6258:()=>LPt,content_3824_626:()=>ore,content_3824_6260:()=>kPt,content_3824_6262:()=>IPt,content_3824_6264:()=>SPt,content_3824_6266:()=>EPt,content_3824_6268:()=>FPt,content_3824_6270:()=>jPt,content_3824_6272:()=>QPt,content_3824_6274:()=>JPt,content_3824_6276:()=>nIt,content_3824_6278:()=>pIt,content_3824_628:()=>sre,content_3824_6280:()=>cIt,content_3824_6282:()=>lIt,content_3824_6284:()=>yIt,content_3824_6286:()=>gIt,content_3824_6288:()=>MIt,content_3824_6290:()=>wIt,content_3824_6292:()=>xIt,content_3824_6294:()=>LIt,content_3824_6296:()=>kIt,content_3824_6298:()=>IIt,content_3824_630:()=>ire,content_3824_6300:()=>SIt,content_3824_6302:()=>EIt,content_3824_6304:()=>FIt,content_3824_6306:()=>jIt,content_3824_6308:()=>QIt,content_3824_6310:()=>JIt,content_3824_6312:()=>nRt,content_3824_6314:()=>pRt,content_3824_6316:()=>cRt,content_3824_6318:()=>lRt,content_3824_632:()=>mre,content_3824_6320:()=>yRt,content_3824_6322:()=>gRt,content_3824_6324:()=>MRt,content_3824_6326:()=>wRt,content_3824_6328:()=>xRt,content_3824_6330:()=>LRt,content_3824_6332:()=>kRt,content_3824_6334:()=>IRt,content_3824_6336:()=>SRt,content_3824_6338:()=>ERt,content_3824_634:()=>hre,content_3824_6340:()=>FRt,content_3824_6342:()=>jRt,content_3824_6344:()=>QRt,content_3824_6346:()=>JRt,content_3824_6348:()=>nWt,content_3824_6350:()=>pWt,content_3824_6352:()=>cWt,content_3824_6354:()=>lWt,content_3824_6356:()=>yWt,content_3824_6358:()=>gWt,content_3824_636:()=>Dre,content_3824_6360:()=>MWt,content_3824_6362:()=>wWt,content_3824_6364:()=>xWt,content_3824_6366:()=>LWt,content_3824_6368:()=>kWt,content_3824_6370:()=>IWt,content_3824_6372:()=>SWt,content_3824_6374:()=>EWt,content_3824_6376:()=>FWt,content_3824_6378:()=>jWt,content_3824_638:()=>_re,content_3824_6380:()=>QWt,content_3824_6382:()=>JWt,content_3824_6384:()=>nSt,content_3824_6386:()=>pSt,content_3824_6388:()=>cSt,content_3824_6390:()=>lSt,content_3824_6392:()=>ySt,content_3824_6394:()=>gSt,content_3824_6396:()=>MSt,content_3824_6398:()=>wSt,content_3824_64:()=>CZ,content_3824_640:()=>Cre,content_3824_6400:()=>xSt,content_3824_6402:()=>LSt,content_3824_6404:()=>kSt,content_3824_6406:()=>ISt,content_3824_6408:()=>SSt,content_3824_6410:()=>ESt,content_3824_6412:()=>FSt,content_3824_6414:()=>jSt,content_3824_6416:()=>QSt,content_3824_6418:()=>JSt,content_3824_642:()=>vre,content_3824_6420:()=>nBt,content_3824_6422:()=>pBt,content_3824_6424:()=>cBt,content_3824_6426:()=>lBt,content_3824_6428:()=>yBt,content_3824_6430:()=>gBt,content_3824_6432:()=>MBt,content_3824_6434:()=>wBt,content_3824_6436:()=>xBt,content_3824_6438:()=>LBt,content_3824_644:()=>Nre,content_3824_6440:()=>kBt,content_3824_6442:()=>IBt,content_3824_6444:()=>SBt,content_3824_6446:()=>EBt,content_3824_6448:()=>FBt,content_3824_6450:()=>jBt,content_3824_6452:()=>QBt,content_3824_6454:()=>JBt,content_3824_6456:()=>nGt,content_3824_6458:()=>pGt,content_3824_646:()=>Pre,content_3824_6460:()=>cGt,content_3824_6462:()=>lGt,content_3824_6464:()=>yGt,content_3824_6466:()=>gGt,content_3824_6468:()=>MGt,content_3824_6470:()=>wGt,content_3824_6472:()=>xGt,content_3824_6474:()=>LGt,content_3824_6476:()=>kGt,content_3824_6478:()=>IGt,content_3824_648:()=>Wre,content_3824_6480:()=>SGt,content_3824_6482:()=>EGt,content_3824_6484:()=>FGt,content_3824_6486:()=>jGt,content_3824_6488:()=>QGt,content_3824_6490:()=>JGt,content_3824_6492:()=>nEt,content_3824_6494:()=>pEt,content_3824_6496:()=>cEt,content_3824_6498:()=>lEt,content_3824_650:()=>Gre,content_3824_6500:()=>yEt,content_3824_6502:()=>gEt,content_3824_6504:()=>MEt,content_3824_6506:()=>wEt,content_3824_6508:()=>xEt,content_3824_6510:()=>LEt,content_3824_6512:()=>kEt,content_3824_6514:()=>IEt,content_3824_6516:()=>SEt,content_3824_6518:()=>EEt,content_3824_652:()=>Ure,content_3824_6520:()=>FEt,content_3824_6522:()=>jEt,content_3824_6524:()=>QEt,content_3824_6526:()=>JEt,content_3824_6528:()=>nOt,content_3824_6530:()=>pOt,content_3824_6532:()=>cOt,content_3824_6534:()=>lOt,content_3824_6536:()=>yOt,content_3824_6538:()=>gOt,content_3824_654:()=>qre,content_3824_6540:()=>MOt,content_3824_6542:()=>wOt,content_3824_6544:()=>xOt,content_3824_6546:()=>LOt,content_3824_6548:()=>kOt,content_3824_6550:()=>IOt,content_3824_6552:()=>SOt,content_3824_6554:()=>EOt,content_3824_6556:()=>FOt,content_3824_6558:()=>jOt,content_3824_656:()=>Yre,content_3824_6560:()=>QOt,content_3824_6562:()=>JOt,content_3824_6564:()=>nUt,content_3824_6566:()=>pUt,content_3824_6568:()=>cUt,content_3824_6570:()=>lUt,content_3824_6572:()=>yUt,content_3824_6574:()=>gUt,content_3824_6576:()=>MUt,content_3824_6578:()=>wUt,content_3824_658:()=>Kre,content_3824_6580:()=>xUt,content_3824_6582:()=>LUt,content_3824_6584:()=>kUt,content_3824_6586:()=>IUt,content_3824_6588:()=>SUt,content_3824_6590:()=>EUt,content_3824_6592:()=>FUt,content_3824_6594:()=>jUt,content_3824_6596:()=>QUt,content_3824_6598:()=>JUt,content_3824_66:()=>vZ,content_3824_660:()=>ese,content_3824_6600:()=>nFt,content_3824_6602:()=>pFt,content_3824_6604:()=>cFt,content_3824_6606:()=>lFt,content_3824_6608:()=>yFt,content_3824_6610:()=>gFt,content_3824_6612:()=>MFt,content_3824_6614:()=>wFt,content_3824_6616:()=>xFt,content_3824_6618:()=>LFt,content_3824_662:()=>ose,content_3824_6620:()=>kFt,content_3824_6622:()=>IFt,content_3824_6624:()=>SFt,content_3824_6626:()=>EFt,content_3824_6628:()=>FFt,content_3824_6630:()=>jFt,content_3824_6632:()=>QFt,content_3824_6634:()=>JFt,content_3824_6636:()=>nVt,content_3824_6638:()=>pVt,content_3824_664:()=>sse,content_3824_6640:()=>cVt,content_3824_6642:()=>lVt,content_3824_6644:()=>yVt,content_3824_6646:()=>gVt,content_3824_6648:()=>MVt,content_3824_6650:()=>wVt,content_3824_6652:()=>xVt,content_3824_6654:()=>LVt,content_3824_6656:()=>kVt,content_3824_6658:()=>IVt,content_3824_666:()=>ise,content_3824_6660:()=>SVt,content_3824_6662:()=>EVt,content_3824_6664:()=>FVt,content_3824_6666:()=>jVt,content_3824_6668:()=>QVt,content_3824_6670:()=>JVt,content_3824_6672:()=>nqt,content_3824_6674:()=>pqt,content_3824_6676:()=>cqt,content_3824_6678:()=>lqt,content_3824_668:()=>mse,content_3824_6680:()=>yqt,content_3824_6682:()=>gqt,content_3824_6684:()=>Mqt,content_3824_6686:()=>wqt,content_3824_6688:()=>xqt,content_3824_6690:()=>Lqt,content_3824_6692:()=>kqt,content_3824_6694:()=>Iqt,content_3824_6696:()=>Sqt,content_3824_6698:()=>Eqt,content_3824_670:()=>hse,content_3824_6700:()=>Fqt,content_3824_6702:()=>jqt,content_3824_6704:()=>Qqt,content_3824_6706:()=>Jqt,content_3824_6708:()=>njt,content_3824_6710:()=>pjt,content_3824_6712:()=>cjt,content_3824_6714:()=>ljt,content_3824_6716:()=>yjt,content_3824_6718:()=>gjt,content_3824_672:()=>Dse,content_3824_6720:()=>Mjt,content_3824_6722:()=>wjt,content_3824_6724:()=>xjt,content_3824_6726:()=>Ljt,content_3824_6728:()=>kjt,content_3824_6730:()=>Ijt,content_3824_6732:()=>Sjt,content_3824_6734:()=>Ejt,content_3824_6736:()=>Fjt,content_3824_6738:()=>jjt,content_3824_674:()=>_se,content_3824_6740:()=>Qjt,content_3824_6742:()=>Jjt,content_3824_6744:()=>nHt,content_3824_6746:()=>pHt,content_3824_6748:()=>cHt,content_3824_6750:()=>lHt,content_3824_6752:()=>yHt,content_3824_6754:()=>gHt,content_3824_6756:()=>MHt,content_3824_6758:()=>wHt,content_3824_676:()=>Cse,content_3824_6760:()=>xHt,content_3824_6762:()=>LHt,content_3824_6764:()=>kHt,content_3824_6766:()=>IHt,content_3824_6768:()=>SHt,content_3824_6770:()=>EHt,content_3824_6772:()=>FHt,content_3824_6774:()=>jHt,content_3824_6776:()=>QHt,content_3824_6778:()=>JHt,content_3824_678:()=>vse,content_3824_6780:()=>nYt,content_3824_6782:()=>pYt,content_3824_6784:()=>cYt,content_3824_6786:()=>lYt,content_3824_6788:()=>yYt,content_3824_6790:()=>gYt,content_3824_6792:()=>MYt,content_3824_6794:()=>wYt,content_3824_6796:()=>xYt,content_3824_6798:()=>LYt,content_3824_68:()=>NZ,content_3824_680:()=>Nse,content_3824_6800:()=>kYt,content_3824_6802:()=>IYt,content_3824_6804:()=>SYt,content_3824_6806:()=>EYt,content_3824_6808:()=>FYt,content_3824_6810:()=>jYt,content_3824_6812:()=>QYt,content_3824_6814:()=>JYt,content_3824_6816:()=>nQt,content_3824_6818:()=>pQt,content_3824_682:()=>Pse,content_3824_6820:()=>cQt,content_3824_6822:()=>lQt,content_3824_6824:()=>yQt,content_3824_6826:()=>gQt,content_3824_6828:()=>MQt,content_3824_6830:()=>wQt,content_3824_6832:()=>xQt,content_3824_6834:()=>LQt,content_3824_6836:()=>kQt,content_3824_6838:()=>IQt,content_3824_684:()=>Wse,content_3824_6840:()=>SQt,content_3824_6842:()=>EQt,content_3824_6844:()=>FQt,content_3824_6846:()=>jQt,content_3824_6848:()=>QQt,content_3824_6850:()=>JQt,content_3824_6852:()=>n$t,content_3824_6854:()=>p$t,content_3824_6856:()=>c$t,content_3824_6858:()=>l$t,content_3824_686:()=>Gse,content_3824_6860:()=>y$t,content_3824_6862:()=>g$t,content_3824_6864:()=>M$t,content_3824_6866:()=>w$t,content_3824_6868:()=>x$t,content_3824_6870:()=>L$t,content_3824_6872:()=>k$t,content_3824_6874:()=>I$t,content_3824_6876:()=>S$t,content_3824_6878:()=>E$t,content_3824_688:()=>Use,content_3824_6880:()=>F$t,content_3824_6882:()=>j$t,content_3824_6884:()=>Q$t,content_3824_6886:()=>J$t,content_3824_6888:()=>nKt,content_3824_6890:()=>pKt,content_3824_6892:()=>cKt,content_3824_6894:()=>lKt,content_3824_6896:()=>yKt,content_3824_6898:()=>gKt,content_3824_690:()=>qse,content_3824_6900:()=>MKt,content_3824_6902:()=>wKt,content_3824_6904:()=>xKt,content_3824_6906:()=>LKt,content_3824_6908:()=>kKt,content_3824_6910:()=>IKt,content_3824_6912:()=>SKt,content_3824_6914:()=>EKt,content_3824_6916:()=>FKt,content_3824_6918:()=>jKt,content_3824_692:()=>Yse,content_3824_6920:()=>QKt,content_3824_6922:()=>JKt,content_3824_6924:()=>nJt,content_3824_6926:()=>pJt,content_3824_6928:()=>cJt,content_3824_6930:()=>lJt,content_3824_6932:()=>yJt,content_3824_6934:()=>gJt,content_3824_6936:()=>MJt,content_3824_6938:()=>wJt,content_3824_694:()=>Kse,content_3824_6940:()=>xJt,content_3824_6942:()=>LJt,content_3824_6944:()=>kJt,content_3824_6946:()=>IJt,content_3824_6948:()=>SJt,content_3824_6950:()=>EJt,content_3824_6952:()=>FJt,content_3824_6954:()=>jJt,content_3824_6956:()=>QJt,content_3824_6958:()=>JJt,content_3824_696:()=>ece,content_3824_6960:()=>nZt,content_3824_6962:()=>pZt,content_3824_6964:()=>cZt,content_3824_6966:()=>lZt,content_3824_6968:()=>yZt,content_3824_6970:()=>gZt,content_3824_6972:()=>MZt,content_3824_6974:()=>wZt,content_3824_6976:()=>xZt,content_3824_6978:()=>LZt,content_3824_698:()=>oce,content_3824_6980:()=>kZt,content_3824_6982:()=>IZt,content_3824_6984:()=>SZt,content_3824_6986:()=>EZt,content_3824_6988:()=>FZt,content_3824_6990:()=>jZt,content_3824_6992:()=>QZt,content_3824_6994:()=>JZt,content_3824_6996:()=>n0t,content_3824_6998:()=>p0t,content_3824_70:()=>PZ,content_3824_700:()=>sce,content_3824_7000:()=>c0t,content_3824_7002:()=>l0t,content_3824_7004:()=>y0t,content_3824_7006:()=>g0t,content_3824_7008:()=>M0t,content_3824_7010:()=>w0t,content_3824_7012:()=>x0t,content_3824_7014:()=>L0t,content_3824_7016:()=>k0t,content_3824_7018:()=>I0t,content_3824_702:()=>ice,content_3824_7020:()=>S0t,content_3824_7022:()=>E0t,content_3824_7024:()=>F0t,content_3824_7026:()=>j0t,content_3824_7028:()=>Q0t,content_3824_7030:()=>J0t,content_3824_7032:()=>n2t,content_3824_7034:()=>p2t,content_3824_7036:()=>c2t,content_3824_7038:()=>l2t,content_3824_704:()=>mce,content_3824_7040:()=>y2t,content_3824_7042:()=>g2t,content_3824_7044:()=>M2t,content_3824_7046:()=>w2t,content_3824_7048:()=>x2t,content_3824_7050:()=>L2t,content_3824_7052:()=>k2t,content_3824_7054:()=>I2t,content_3824_7056:()=>S2t,content_3824_7058:()=>E2t,content_3824_706:()=>hce,content_3824_7060:()=>F2t,content_3824_7062:()=>j2t,content_3824_7064:()=>Q2t,content_3824_7066:()=>J2t,content_3824_7068:()=>n4t,content_3824_7070:()=>p4t,content_3824_7072:()=>c4t,content_3824_7074:()=>l4t,content_3824_7076:()=>y4t,content_3824_7078:()=>g4t,content_3824_708:()=>Dce,content_3824_7080:()=>M4t,content_3824_7082:()=>w4t,content_3824_7084:()=>x4t,content_3824_7086:()=>L4t,content_3824_7088:()=>k4t,content_3824_7090:()=>I4t,content_3824_7092:()=>S4t,content_3824_7094:()=>E4t,content_3824_7096:()=>F4t,content_3824_7098:()=>j4t,content_3824_710:()=>_ce,content_3824_7100:()=>Q4t,content_3824_7102:()=>J4t,content_3824_7104:()=>n8t,content_3824_7106:()=>p8t,content_3824_7108:()=>c8t,content_3824_7110:()=>l8t,content_3824_7112:()=>y8t,content_3824_7114:()=>g8t,content_3824_7116:()=>M8t,content_3824_7118:()=>w8t,content_3824_712:()=>Cce,content_3824_7120:()=>x8t,content_3824_7122:()=>L8t,content_3824_7124:()=>k8t,content_3824_7126:()=>I8t,content_3824_7128:()=>S8t,content_3824_7130:()=>E8t,content_3824_7132:()=>F8t,content_3824_7134:()=>j8t,content_3824_7136:()=>Q8t,content_3824_7138:()=>J8t,content_3824_714:()=>vce,content_3824_7140:()=>n3t,content_3824_7142:()=>p3t,content_3824_7144:()=>c3t,content_3824_7146:()=>l3t,content_3824_7148:()=>y3t,content_3824_7150:()=>g3t,content_3824_7152:()=>M3t,content_3824_7154:()=>w3t,content_3824_7156:()=>x3t,content_3824_7158:()=>L3t,content_3824_716:()=>Nce,content_3824_7160:()=>k3t,content_3824_7162:()=>I3t,content_3824_7164:()=>S3t,content_3824_7166:()=>E3t,content_3824_7168:()=>F3t,content_3824_7170:()=>j3t,content_3824_7172:()=>Q3t,content_3824_7174:()=>J3t,content_3824_7176:()=>n1t,content_3824_7178:()=>p1t,content_3824_718:()=>Pce,content_3824_7180:()=>c1t,content_3824_7182:()=>l1t,content_3824_7184:()=>y1t,content_3824_7186:()=>g1t,content_3824_7188:()=>M1t,content_3824_7190:()=>w1t,content_3824_7192:()=>x1t,content_3824_7194:()=>L1t,content_3824_7196:()=>k1t,content_3824_7198:()=>I1t,content_3824_72:()=>WZ,content_3824_720:()=>Wce,content_3824_7200:()=>S1t,content_3824_7202:()=>E1t,content_3824_7204:()=>F1t,content_3824_7206:()=>j1t,content_3824_7208:()=>Q1t,content_3824_7210:()=>J1t,content_3824_7212:()=>n6t,content_3824_7214:()=>p6t,content_3824_7216:()=>c6t,content_3824_7218:()=>l6t,content_3824_722:()=>Gce,content_3824_7220:()=>y6t,content_3824_7222:()=>g6t,content_3824_7224:()=>M6t,content_3824_7226:()=>w6t,content_3824_7228:()=>x6t,content_3824_7230:()=>L6t,content_3824_7232:()=>k6t,content_3824_7234:()=>I6t,content_3824_7236:()=>S6t,content_3824_7238:()=>E6t,content_3824_724:()=>Uce,content_3824_7240:()=>F6t,content_3824_7242:()=>j6t,content_3824_7244:()=>Q6t,content_3824_7246:()=>J6t,content_3824_7248:()=>n5t,content_3824_7250:()=>p5t,content_3824_7252:()=>c5t,content_3824_7254:()=>l5t,content_3824_7256:()=>y5t,content_3824_7258:()=>g5t,content_3824_726:()=>qce,content_3824_7260:()=>M5t,content_3824_7262:()=>w5t,content_3824_7264:()=>x5t,content_3824_7266:()=>L5t,content_3824_7268:()=>k5t,content_3824_7270:()=>I5t,content_3824_7272:()=>S5t,content_3824_7274:()=>E5t,content_3824_7276:()=>F5t,content_3824_7278:()=>j5t,content_3824_728:()=>Yce,content_3824_7280:()=>Q5t,content_3824_7282:()=>J5t,content_3824_7284:()=>n7t,content_3824_7286:()=>p7t,content_3824_7288:()=>c7t,content_3824_7290:()=>l7t,content_3824_7292:()=>y7t,content_3824_7294:()=>g7t,content_3824_7296:()=>M7t,content_3824_7298:()=>w7t,content_3824_730:()=>Kce,content_3824_7300:()=>x7t,content_3824_7302:()=>L7t,content_3824_7304:()=>k7t,content_3824_7306:()=>I7t,content_3824_7308:()=>S7t,content_3824_7310:()=>E7t,content_3824_7312:()=>F7t,content_3824_7314:()=>j7t,content_3824_7316:()=>Q7t,content_3824_7318:()=>J7t,content_3824_732:()=>eae,content_3824_7320:()=>n9t,content_3824_7322:()=>p9t,content_3824_7324:()=>c9t,content_3824_7326:()=>l9t,content_3824_7328:()=>y9t,content_3824_7330:()=>g9t,content_3824_7332:()=>M9t,content_3824_7334:()=>w9t,content_3824_7336:()=>x9t,content_3824_7338:()=>L9t,content_3824_734:()=>oae,content_3824_7340:()=>k9t,content_3824_7342:()=>I9t,content_3824_7344:()=>S9t,content_3824_7346:()=>E9t,content_3824_7348:()=>F9t,content_3824_7350:()=>j9t,content_3824_7352:()=>Q9t,content_3824_7354:()=>J9t,content_3824_7356:()=>neo,content_3824_7358:()=>peo,content_3824_736:()=>sae,content_3824_7360:()=>ceo,content_3824_7362:()=>leo,content_3824_7364:()=>yeo,content_3824_7366:()=>geo,content_3824_7368:()=>Meo,content_3824_7370:()=>weo,content_3824_7372:()=>xeo,content_3824_7374:()=>Leo,content_3824_7376:()=>keo,content_3824_7378:()=>Ieo,content_3824_738:()=>iae,content_3824_7380:()=>Seo,content_3824_7382:()=>Eeo,content_3824_7384:()=>Feo,content_3824_7386:()=>jeo,content_3824_7388:()=>Qeo,content_3824_7390:()=>Jeo,content_3824_7392:()=>nno,content_3824_7394:()=>pno,content_3824_7396:()=>cno,content_3824_7398:()=>lno,content_3824_74:()=>GZ,content_3824_740:()=>mae,content_3824_7400:()=>yno,content_3824_7402:()=>gno,content_3824_7404:()=>Mno,content_3824_7406:()=>wno,content_3824_7408:()=>xno,content_3824_7410:()=>Lno,content_3824_7412:()=>kno,content_3824_7414:()=>Ino,content_3824_7416:()=>Sno,content_3824_7418:()=>Eno,content_3824_742:()=>hae,content_3824_7420:()=>Fno,content_3824_7422:()=>jno,content_3824_7424:()=>Qno,content_3824_7426:()=>Jno,content_3824_7428:()=>nto,content_3824_7430:()=>pto,content_3824_7432:()=>cto,content_3824_7434:()=>lto,content_3824_7436:()=>yto,content_3824_7438:()=>gto,content_3824_744:()=>Dae,content_3824_7440:()=>Mto,content_3824_7442:()=>wto,content_3824_7444:()=>xto,content_3824_7446:()=>Lto,content_3824_7448:()=>kto,content_3824_7450:()=>Ito,content_3824_7452:()=>Sto,content_3824_7454:()=>Eto,content_3824_7456:()=>Fto,content_3824_7458:()=>jto,content_3824_746:()=>_ae,content_3824_7460:()=>Qto,content_3824_7462:()=>Jto,content_3824_7464:()=>noo,content_3824_7466:()=>poo,content_3824_7468:()=>coo,content_3824_7470:()=>loo,content_3824_7472:()=>yoo,content_3824_7474:()=>goo,content_3824_7476:()=>Moo,content_3824_7478:()=>woo,content_3824_748:()=>Cae,content_3824_7480:()=>xoo,content_3824_7482:()=>Loo,content_3824_7484:()=>koo,content_3824_7486:()=>Ioo,content_3824_7488:()=>Soo,content_3824_7490:()=>Eoo,content_3824_7492:()=>Foo,content_3824_7494:()=>joo,content_3824_7496:()=>Qoo,content_3824_7498:()=>Joo,content_3824_750:()=>vae,content_3824_7500:()=>npo,content_3824_7502:()=>ppo,content_3824_7504:()=>cpo,content_3824_7506:()=>lpo,content_3824_7508:()=>ypo,content_3824_7510:()=>gpo,content_3824_7512:()=>Mpo,content_3824_7514:()=>wpo,content_3824_7516:()=>xpo,content_3824_7518:()=>Lpo,content_3824_752:()=>Nae,content_3824_7520:()=>kpo,content_3824_7522:()=>Ipo,content_3824_7524:()=>Spo,content_3824_7526:()=>Epo,content_3824_7528:()=>Fpo,content_3824_7530:()=>jpo,content_3824_7532:()=>Qpo,content_3824_7534:()=>Jpo,content_3824_7536:()=>nro,content_3824_7538:()=>pro,content_3824_754:()=>Pae,content_3824_7540:()=>cro,content_3824_7542:()=>lro,content_3824_7544:()=>yro,content_3824_7546:()=>gro,content_3824_7548:()=>Mro,content_3824_7550:()=>wro,content_3824_7552:()=>xro,content_3824_7554:()=>Lro,content_3824_7556:()=>kro,content_3824_7558:()=>Iro,content_3824_756:()=>Wae,content_3824_7560:()=>Sro,content_3824_7562:()=>Ero,content_3824_7564:()=>Fro,content_3824_7566:()=>jro,content_3824_7568:()=>Qro,content_3824_7570:()=>Jro,content_3824_7572:()=>nso,content_3824_7574:()=>pso,content_3824_7576:()=>cso,content_3824_7578:()=>lso,content_3824_758:()=>Gae,content_3824_7580:()=>yso,content_3824_7582:()=>gso,content_3824_7584:()=>Mso,content_3824_7586:()=>wso,content_3824_7588:()=>xso,content_3824_7590:()=>Lso,content_3824_7592:()=>kso,content_3824_7594:()=>Iso,content_3824_7596:()=>Sso,content_3824_7598:()=>Eso,content_3824_76:()=>UZ,content_3824_760:()=>Uae,content_3824_7600:()=>Fso,content_3824_7602:()=>jso,content_3824_7604:()=>Qso,content_3824_7606:()=>Jso,content_3824_7608:()=>nco,content_3824_7610:()=>pco,content_3824_7612:()=>cco,content_3824_7614:()=>lco,content_3824_7616:()=>yco,content_3824_7618:()=>gco,content_3824_762:()=>qae,content_3824_7620:()=>Mco,content_3824_7622:()=>wco,content_3824_7624:()=>xco,content_3824_7626:()=>Lco,content_3824_7628:()=>kco,content_3824_7630:()=>Ico,content_3824_7632:()=>Sco,content_3824_7634:()=>Eco,content_3824_7636:()=>Fco,content_3824_7638:()=>jco,content_3824_764:()=>Yae,content_3824_7640:()=>Qco,content_3824_7642:()=>Jco,content_3824_7644:()=>nao,content_3824_7646:()=>pao,content_3824_7648:()=>cao,content_3824_7650:()=>lao,content_3824_7652:()=>yao,content_3824_7654:()=>gao,content_3824_7656:()=>Mao,content_3824_7658:()=>wao,content_3824_766:()=>Kae,content_3824_7660:()=>xao,content_3824_7662:()=>Lao,content_3824_7664:()=>kao,content_3824_7666:()=>Iao,content_3824_7668:()=>Sao,content_3824_7670:()=>Eao,content_3824_7672:()=>Fao,content_3824_7674:()=>jao,content_3824_7676:()=>Qao,content_3824_7678:()=>Jao,content_3824_768:()=>eie,content_3824_7680:()=>nio,content_3824_7682:()=>pio,content_3824_7684:()=>cio,content_3824_7686:()=>lio,content_3824_7688:()=>yio,content_3824_7690:()=>gio,content_3824_7692:()=>Mio,content_3824_7694:()=>wio,content_3824_7696:()=>xio,content_3824_7698:()=>Lio,content_3824_770:()=>oie,content_3824_7700:()=>kio,content_3824_7702:()=>Iio,content_3824_7704:()=>Sio,content_3824_7706:()=>Eio,content_3824_7708:()=>Fio,content_3824_7710:()=>jio,content_3824_7712:()=>Qio,content_3824_7714:()=>Jio,content_3824_7716:()=>nlo,content_3824_7718:()=>plo,content_3824_772:()=>sie,content_3824_7720:()=>clo,content_3824_7722:()=>llo,content_3824_7724:()=>ylo,content_3824_7726:()=>glo,content_3824_7728:()=>Mlo,content_3824_7730:()=>wlo,content_3824_7732:()=>xlo,content_3824_7734:()=>Llo,content_3824_7736:()=>klo,content_3824_7738:()=>Ilo,content_3824_774:()=>iie,content_3824_7740:()=>Slo,content_3824_7742:()=>Elo,content_3824_7744:()=>Flo,content_3824_7746:()=>jlo,content_3824_7748:()=>Qlo,content_3824_7750:()=>Jlo,content_3824_7752:()=>nuo,content_3824_7754:()=>puo,content_3824_7756:()=>cuo,content_3824_7758:()=>luo,content_3824_776:()=>mie,content_3824_7760:()=>yuo,content_3824_7762:()=>guo,content_3824_7764:()=>Muo,content_3824_7766:()=>wuo,content_3824_7768:()=>xuo,content_3824_7770:()=>Luo,content_3824_7772:()=>kuo,content_3824_7774:()=>Iuo,content_3824_7776:()=>Suo,content_3824_7778:()=>Euo,content_3824_778:()=>hie,content_3824_7780:()=>Fuo,content_3824_7782:()=>juo,content_3824_7784:()=>Quo,content_3824_7786:()=>Juo,content_3824_7788:()=>nmo,content_3824_7790:()=>pmo,content_3824_7792:()=>cmo,content_3824_7794:()=>lmo,content_3824_7796:()=>ymo,content_3824_7798:()=>gmo,content_3824_78:()=>qZ,content_3824_780:()=>Die,content_3824_7800:()=>Mmo,content_3824_7802:()=>wmo,content_3824_7804:()=>xmo,content_3824_7806:()=>Lmo,content_3824_7808:()=>kmo,content_3824_7810:()=>Imo,content_3824_7812:()=>Smo,content_3824_7814:()=>Emo,content_3824_7816:()=>Fmo,content_3824_7818:()=>jmo,content_3824_782:()=>_ie,content_3824_7820:()=>Qmo,content_3824_7822:()=>Jmo,content_3824_7824:()=>nyo,content_3824_7826:()=>pyo,content_3824_7828:()=>cyo,content_3824_7830:()=>lyo,content_3824_7832:()=>yyo,content_3824_7834:()=>gyo,content_3824_7836:()=>Myo,content_3824_7838:()=>wyo,content_3824_784:()=>Cie,content_3824_7840:()=>xyo,content_3824_7842:()=>Lyo,content_3824_7844:()=>kyo,content_3824_7846:()=>Iyo,content_3824_7848:()=>Syo,content_3824_7850:()=>Eyo,content_3824_7852:()=>Fyo,content_3824_7854:()=>jyo,content_3824_7856:()=>Qyo,content_3824_7858:()=>Jyo,content_3824_786:()=>vie,content_3824_7860:()=>ndo,content_3824_7862:()=>pdo,content_3824_7864:()=>cdo,content_3824_7866:()=>ldo,content_3824_7868:()=>ydo,content_3824_7870:()=>gdo,content_3824_7872:()=>Mdo,content_3824_7874:()=>wdo,content_3824_7876:()=>xdo,content_3824_7878:()=>Ldo,content_3824_788:()=>Nie,content_3824_7880:()=>kdo,content_3824_7882:()=>Ido,content_3824_7884:()=>Sdo,content_3824_7886:()=>Edo,content_3824_7888:()=>Fdo,content_3824_7890:()=>jdo,content_3824_7892:()=>Qdo,content_3824_7894:()=>Jdo,content_3824_7896:()=>nho,content_3824_7898:()=>pho,content_3824_790:()=>Pie,content_3824_7900:()=>cho,content_3824_7902:()=>lho,content_3824_7904:()=>yho,content_3824_7906:()=>gho,content_3824_7908:()=>Mho,content_3824_7910:()=>who,content_3824_7912:()=>xho,content_3824_7914:()=>Lho,content_3824_7916:()=>kho,content_3824_7918:()=>Iho,content_3824_792:()=>Wie,content_3824_7920:()=>Sho,content_3824_7922:()=>Eho,content_3824_7924:()=>Fho,content_3824_7926:()=>jho,content_3824_7928:()=>Qho,content_3824_7930:()=>Jho,content_3824_7932:()=>ngo,content_3824_7934:()=>pgo,content_3824_7936:()=>cgo,content_3824_7938:()=>lgo,content_3824_794:()=>Gie,content_3824_7940:()=>ygo,content_3824_7942:()=>ggo,content_3824_7944:()=>Mgo,content_3824_7946:()=>wgo,content_3824_7948:()=>xgo,content_3824_7950:()=>Lgo,content_3824_7952:()=>kgo,content_3824_7954:()=>Igo,content_3824_7956:()=>Sgo,content_3824_7958:()=>Ego,content_3824_796:()=>Uie,content_3824_7960:()=>Fgo,content_3824_7962:()=>jgo,content_3824_7964:()=>Qgo,content_3824_7966:()=>Jgo,content_3824_7968:()=>nfo,content_3824_7970:()=>pfo,content_3824_7972:()=>cfo,content_3824_7974:()=>lfo,content_3824_7976:()=>yfo,content_3824_7978:()=>gfo,content_3824_798:()=>qie,content_3824_7980:()=>Mfo,content_3824_7982:()=>wfo,content_3824_7984:()=>xfo,content_3824_7986:()=>Lfo,content_3824_7988:()=>kfo,content_3824_7990:()=>Ifo,content_3824_7992:()=>Sfo,content_3824_7994:()=>Efo,content_3824_7996:()=>Ffo,content_3824_7998:()=>jfo,content_3824_8:()=>YK,content_3824_80:()=>YZ,content_3824_800:()=>Yie,content_3824_8000:()=>Qfo,content_3824_8002:()=>Jfo,content_3824_8004:()=>nDo,content_3824_8006:()=>pDo,content_3824_8008:()=>cDo,content_3824_8010:()=>lDo,content_3824_8012:()=>yDo,content_3824_8014:()=>gDo,content_3824_8016:()=>MDo,content_3824_8018:()=>wDo,content_3824_802:()=>Kie,content_3824_8020:()=>xDo,content_3824_8022:()=>LDo,content_3824_8024:()=>kDo,content_3824_8026:()=>IDo,content_3824_8028:()=>SDo,content_3824_8030:()=>EDo,content_3824_8032:()=>FDo,content_3824_8034:()=>jDo,content_3824_8036:()=>QDo,content_3824_8038:()=>JDo,content_3824_804:()=>ele,content_3824_8040:()=>nMo,content_3824_8042:()=>pMo,content_3824_8044:()=>cMo,content_3824_8046:()=>lMo,content_3824_8048:()=>yMo,content_3824_8050:()=>gMo,content_3824_8052:()=>MMo,content_3824_8054:()=>wMo,content_3824_8056:()=>xMo,content_3824_8058:()=>LMo,content_3824_806:()=>ole,content_3824_8060:()=>kMo,content_3824_8062:()=>IMo,content_3824_8064:()=>SMo,content_3824_8066:()=>EMo,content_3824_8068:()=>FMo,content_3824_8070:()=>jMo,content_3824_8072:()=>QMo,content_3824_8074:()=>JMo,content_3824_8076:()=>nXo,content_3824_8078:()=>pXo,content_3824_808:()=>sle,content_3824_8080:()=>cXo,content_3824_8082:()=>lXo,content_3824_8084:()=>yXo,content_3824_8086:()=>gXo,content_3824_8088:()=>MXo,content_3824_8090:()=>wXo,content_3824_8092:()=>xXo,content_3824_8094:()=>LXo,content_3824_8096:()=>kXo,content_3824_8098:()=>IXo,content_3824_810:()=>ile,content_3824_8100:()=>SXo,content_3824_8102:()=>EXo,content_3824_8104:()=>FXo,content_3824_8106:()=>jXo,content_3824_8108:()=>QXo,content_3824_8110:()=>JXo,content_3824_8112:()=>n_o,content_3824_8114:()=>p_o,content_3824_8116:()=>c_o,content_3824_8118:()=>l_o,content_3824_812:()=>mle,content_3824_8120:()=>y_o,content_3824_8122:()=>g_o,content_3824_8124:()=>M_o,content_3824_8126:()=>w_o,content_3824_8128:()=>x_o,content_3824_8130:()=>L_o,content_3824_8132:()=>k_o,content_3824_8134:()=>I_o,content_3824_8136:()=>S_o,content_3824_8138:()=>E_o,content_3824_814:()=>hle,content_3824_8140:()=>F_o,content_3824_8142:()=>j_o,content_3824_8144:()=>Q_o,content_3824_8146:()=>J_o,content_3824_8148:()=>nwo,content_3824_8150:()=>pwo,content_3824_8152:()=>cwo,content_3824_8154:()=>lwo,content_3824_8156:()=>ywo,content_3824_8158:()=>gwo,content_3824_816:()=>Dle,content_3824_8160:()=>Mwo,content_3824_8162:()=>wwo,content_3824_8164:()=>xwo,content_3824_8166:()=>Lwo,content_3824_8168:()=>kwo,content_3824_8170:()=>Iwo,content_3824_8172:()=>Swo,content_3824_8174:()=>Ewo,content_3824_8176:()=>Fwo,content_3824_8178:()=>jwo,content_3824_818:()=>_le,content_3824_8180:()=>Qwo,content_3824_8182:()=>Jwo,content_3824_8184:()=>nTo,content_3824_8186:()=>pTo,content_3824_8188:()=>cTo,content_3824_8190:()=>lTo,content_3824_8192:()=>yTo,content_3824_8194:()=>gTo,content_3824_8196:()=>MTo,content_3824_8198:()=>wTo,content_3824_82:()=>KZ,content_3824_820:()=>Cle,content_3824_8200:()=>xTo,content_3824_8202:()=>LTo,content_3824_8204:()=>kTo,content_3824_8206:()=>ITo,content_3824_8208:()=>STo,content_3824_8210:()=>ETo,content_3824_8212:()=>FTo,content_3824_8214:()=>jTo,content_3824_8216:()=>QTo,content_3824_8218:()=>JTo,content_3824_822:()=>vle,content_3824_8220:()=>nCo,content_3824_8222:()=>pCo,content_3824_8224:()=>cCo,content_3824_8226:()=>lCo,content_3824_8228:()=>yCo,content_3824_8230:()=>gCo,content_3824_8232:()=>MCo,content_3824_8234:()=>wCo,content_3824_8236:()=>xCo,content_3824_8238:()=>LCo,content_3824_824:()=>Nle,content_3824_8240:()=>kCo,content_3824_8242:()=>ICo,content_3824_8244:()=>SCo,content_3824_8246:()=>ECo,content_3824_8248:()=>FCo,content_3824_8250:()=>jCo,content_3824_8252:()=>QCo,content_3824_8254:()=>JCo,content_3824_8256:()=>nxo,content_3824_8258:()=>pxo,content_3824_826:()=>Ple,content_3824_8260:()=>cxo,content_3824_8262:()=>lxo,content_3824_8264:()=>yxo,content_3824_8266:()=>gxo,content_3824_8268:()=>Mxo,content_3824_8270:()=>wxo,content_3824_8272:()=>xxo,content_3824_8274:()=>Lxo,content_3824_8276:()=>kxo,content_3824_8278:()=>Ixo,content_3824_828:()=>Wle,content_3824_8280:()=>Sxo,content_3824_8282:()=>Exo,content_3824_8284:()=>Fxo,content_3824_8286:()=>jxo,content_3824_8288:()=>Qxo,content_3824_8290:()=>Jxo,content_3824_8292:()=>nAo,content_3824_8294:()=>pAo,content_3824_8296:()=>cAo,content_3824_8298:()=>lAo,content_3824_830:()=>Gle,content_3824_8300:()=>yAo,content_3824_8302:()=>gAo,content_3824_8304:()=>MAo,content_3824_8306:()=>wAo,content_3824_8308:()=>xAo,content_3824_8310:()=>LAo,content_3824_8312:()=>kAo,content_3824_8314:()=>IAo,content_3824_8316:()=>SAo,content_3824_8318:()=>EAo,content_3824_832:()=>Ule,content_3824_8320:()=>FAo,content_3824_8322:()=>jAo,content_3824_8324:()=>QAo,content_3824_8326:()=>JAo,content_3824_8328:()=>nvo,content_3824_8330:()=>pvo,content_3824_8332:()=>cvo,content_3824_8334:()=>lvo,content_3824_8336:()=>yvo,content_3824_8338:()=>gvo,content_3824_834:()=>qle,content_3824_8340:()=>Mvo,content_3824_8342:()=>wvo,content_3824_8344:()=>xvo,content_3824_8346:()=>Lvo,content_3824_8348:()=>kvo,content_3824_8350:()=>Ivo,content_3824_8352:()=>Svo,content_3824_8354:()=>Evo,content_3824_8356:()=>Fvo,content_3824_8358:()=>jvo,content_3824_836:()=>Yle,content_3824_8360:()=>Qvo,content_3824_8362:()=>Jvo,content_3824_8364:()=>nLo,content_3824_8366:()=>pLo,content_3824_8368:()=>cLo,content_3824_8370:()=>lLo,content_3824_8372:()=>yLo,content_3824_8374:()=>gLo,content_3824_8376:()=>MLo,content_3824_8378:()=>wLo,content_3824_838:()=>Kle,content_3824_8380:()=>xLo,content_3824_8382:()=>LLo,content_3824_8384:()=>kLo,content_3824_8386:()=>ILo,content_3824_8388:()=>SLo,content_3824_8390:()=>ELo,content_3824_8392:()=>FLo,content_3824_8394:()=>jLo,content_3824_8396:()=>QLo,content_3824_8398:()=>JLo,content_3824_84:()=>e0,content_3824_840:()=>eue,content_3824_8400:()=>nbo,content_3824_8402:()=>pbo,content_3824_8404:()=>cbo,content_3824_8406:()=>lbo,content_3824_8408:()=>ybo,content_3824_8410:()=>gbo,content_3824_8412:()=>Mbo,content_3824_8414:()=>wbo,content_3824_8416:()=>xbo,content_3824_8418:()=>Lbo,content_3824_842:()=>oue,content_3824_8420:()=>kbo,content_3824_8422:()=>Ibo,content_3824_8424:()=>Sbo,content_3824_8426:()=>Ebo,content_3824_8428:()=>Fbo,content_3824_8430:()=>jbo,content_3824_8432:()=>Qbo,content_3824_8434:()=>Jbo,content_3824_8436:()=>nNo,content_3824_8438:()=>pNo,content_3824_844:()=>sue,content_3824_8440:()=>cNo,content_3824_8442:()=>lNo,content_3824_8444:()=>yNo,content_3824_8446:()=>gNo,content_3824_8448:()=>MNo,content_3824_8450:()=>wNo,content_3824_8452:()=>xNo,content_3824_8454:()=>LNo,content_3824_8456:()=>kNo,content_3824_8458:()=>INo,content_3824_846:()=>iue,content_3824_8460:()=>SNo,content_3824_8462:()=>ENo,content_3824_8464:()=>FNo,content_3824_8466:()=>jNo,content_3824_8468:()=>QNo,content_3824_8470:()=>JNo,content_3824_8472:()=>nko,content_3824_8474:()=>pko,content_3824_8476:()=>cko,content_3824_8478:()=>lko,content_3824_848:()=>mue,content_3824_8480:()=>yko,content_3824_8482:()=>gko,content_3824_8484:()=>Mko,content_3824_8486:()=>wko,content_3824_8488:()=>xko,content_3824_8490:()=>Lko,content_3824_8492:()=>kko,content_3824_8494:()=>Iko,content_3824_8496:()=>Sko,content_3824_8498:()=>Eko,content_3824_850:()=>hue,content_3824_8500:()=>Fko,content_3824_8502:()=>jko,content_3824_8504:()=>Qko,content_3824_8506:()=>Jko,content_3824_8508:()=>nzo,content_3824_8510:()=>pzo,content_3824_8512:()=>czo,content_3824_8514:()=>lzo,content_3824_8516:()=>yzo,content_3824_8518:()=>gzo,content_3824_852:()=>Due,content_3824_8520:()=>Mzo,content_3824_8522:()=>wzo,content_3824_8524:()=>xzo,content_3824_8526:()=>Lzo,content_3824_8528:()=>kzo,content_3824_8530:()=>Izo,content_3824_8532:()=>Szo,content_3824_8534:()=>Ezo,content_3824_8536:()=>Fzo,content_3824_8538:()=>jzo,content_3824_854:()=>_ue,content_3824_8540:()=>Qzo,content_3824_8542:()=>Jzo,content_3824_8544:()=>nPo,content_3824_8546:()=>pPo,content_3824_8548:()=>cPo,content_3824_8550:()=>lPo,content_3824_8552:()=>yPo,content_3824_8554:()=>gPo,content_3824_8556:()=>MPo,content_3824_8558:()=>wPo,content_3824_856:()=>Cue,content_3824_8560:()=>xPo,content_3824_8562:()=>LPo,content_3824_8564:()=>kPo,content_3824_8566:()=>IPo,content_3824_8568:()=>SPo,content_3824_8570:()=>EPo,content_3824_8572:()=>FPo,content_3824_8574:()=>jPo,content_3824_8576:()=>QPo,content_3824_8578:()=>JPo,content_3824_858:()=>vue,content_3824_8580:()=>nIo,content_3824_8582:()=>pIo,content_3824_8584:()=>cIo,content_3824_8586:()=>lIo,content_3824_8588:()=>yIo,content_3824_8590:()=>gIo,content_3824_8592:()=>MIo,content_3824_8594:()=>wIo,content_3824_8596:()=>xIo,content_3824_8598:()=>LIo,content_3824_86:()=>o0,content_3824_860:()=>Nue,content_3824_8600:()=>kIo,content_3824_8602:()=>IIo,content_3824_8604:()=>SIo,content_3824_8606:()=>EIo,content_3824_8608:()=>FIo,content_3824_8610:()=>jIo,content_3824_8612:()=>QIo,content_3824_8614:()=>JIo,content_3824_8616:()=>nRo,content_3824_8618:()=>pRo,content_3824_862:()=>Pue,content_3824_8620:()=>cRo,content_3824_8622:()=>lRo,content_3824_8624:()=>yRo,content_3824_8626:()=>gRo,content_3824_8628:()=>MRo,content_3824_8630:()=>wRo,content_3824_8632:()=>xRo,content_3824_8634:()=>LRo,content_3824_8636:()=>kRo,content_3824_8638:()=>IRo,content_3824_864:()=>Wue,content_3824_8640:()=>SRo,content_3824_8642:()=>ERo,content_3824_8644:()=>FRo,content_3824_8646:()=>jRo,content_3824_8648:()=>QRo,content_3824_8650:()=>JRo,content_3824_8652:()=>nWo,content_3824_8654:()=>pWo,content_3824_8656:()=>cWo,content_3824_8658:()=>lWo,content_3824_866:()=>Gue,content_3824_8660:()=>yWo,content_3824_8662:()=>gWo,content_3824_8664:()=>MWo,content_3824_8666:()=>wWo,content_3824_8668:()=>xWo,content_3824_8670:()=>LWo,content_3824_8672:()=>kWo,content_3824_8674:()=>IWo,content_3824_8676:()=>SWo,content_3824_8678:()=>EWo,content_3824_868:()=>Uue,content_3824_8680:()=>FWo,content_3824_8682:()=>jWo,content_3824_8684:()=>QWo,content_3824_8686:()=>JWo,content_3824_8688:()=>nSo,content_3824_8690:()=>pSo,content_3824_8692:()=>cSo,content_3824_8694:()=>lSo,content_3824_8696:()=>ySo,content_3824_8698:()=>gSo,content_3824_870:()=>que,content_3824_8700:()=>MSo,content_3824_8702:()=>wSo,content_3824_8704:()=>xSo,content_3824_8706:()=>LSo,content_3824_8708:()=>kSo,content_3824_8710:()=>ISo,content_3824_8712:()=>SSo,content_3824_8714:()=>ESo,content_3824_8716:()=>FSo,content_3824_8718:()=>jSo,content_3824_872:()=>Yue,content_3824_8720:()=>QSo,content_3824_8722:()=>JSo,content_3824_8724:()=>nBo,content_3824_8726:()=>pBo,content_3824_8728:()=>cBo,content_3824_8730:()=>lBo,content_3824_8732:()=>yBo,content_3824_8734:()=>gBo,content_3824_8736:()=>MBo,content_3824_8738:()=>wBo,content_3824_874:()=>Kue,content_3824_8740:()=>xBo,content_3824_8742:()=>LBo,content_3824_8744:()=>kBo,content_3824_8746:()=>IBo,content_3824_8748:()=>SBo,content_3824_8750:()=>EBo,content_3824_8752:()=>FBo,content_3824_8754:()=>jBo,content_3824_8756:()=>QBo,content_3824_8758:()=>JBo,content_3824_876:()=>eme,content_3824_8760:()=>nGo,content_3824_8762:()=>pGo,content_3824_8764:()=>cGo,content_3824_8766:()=>lGo,content_3824_8768:()=>yGo,content_3824_8770:()=>gGo,content_3824_8772:()=>MGo,content_3824_8774:()=>wGo,content_3824_8776:()=>xGo,content_3824_8778:()=>LGo,content_3824_878:()=>ome,content_3824_8780:()=>kGo,content_3824_8782:()=>IGo,content_3824_8784:()=>SGo,content_3824_8786:()=>EGo,content_3824_8788:()=>FGo,content_3824_8790:()=>jGo,content_3824_8792:()=>QGo,content_3824_8794:()=>JGo,content_3824_8796:()=>nEo,content_3824_8798:()=>pEo,content_3824_88:()=>s0,content_3824_880:()=>sme,content_3824_8800:()=>cEo,content_3824_8802:()=>lEo,content_3824_8804:()=>yEo,content_3824_8806:()=>gEo,content_3824_8808:()=>MEo,content_3824_8810:()=>wEo,content_3824_8812:()=>xEo,content_3824_8814:()=>LEo,content_3824_8816:()=>kEo,content_3824_8818:()=>IEo,content_3824_882:()=>ime,content_3824_8820:()=>SEo,content_3824_8822:()=>EEo,content_3824_8824:()=>FEo,content_3824_8826:()=>jEo,content_3824_8828:()=>QEo,content_3824_8830:()=>JEo,content_3824_8832:()=>nOo,content_3824_8834:()=>pOo,content_3824_8836:()=>cOo,content_3824_8838:()=>lOo,content_3824_884:()=>mme,content_3824_8840:()=>yOo,content_3824_8842:()=>gOo,content_3824_8844:()=>MOo,content_3824_8846:()=>wOo,content_3824_8848:()=>xOo,content_3824_8850:()=>LOo,content_3824_8852:()=>kOo,content_3824_8854:()=>IOo,content_3824_8856:()=>SOo,content_3824_8858:()=>EOo,content_3824_886:()=>hme,content_3824_8860:()=>FOo,content_3824_8862:()=>jOo,content_3824_8864:()=>QOo,content_3824_8866:()=>JOo,content_3824_8868:()=>nUo,content_3824_8870:()=>pUo,content_3824_8872:()=>cUo,content_3824_8874:()=>lUo,content_3824_8876:()=>yUo,content_3824_8878:()=>gUo,content_3824_888:()=>Dme,content_3824_8880:()=>MUo,content_3824_8882:()=>wUo,content_3824_8884:()=>xUo,content_3824_8886:()=>LUo,content_3824_8888:()=>kUo,content_3824_8890:()=>IUo,content_3824_8892:()=>SUo,content_3824_8894:()=>EUo,content_3824_8896:()=>FUo,content_3824_8898:()=>jUo,content_3824_890:()=>_me,content_3824_8900:()=>QUo,content_3824_8902:()=>JUo,content_3824_8904:()=>nFo,content_3824_8906:()=>pFo,content_3824_8908:()=>cFo,content_3824_8910:()=>lFo,content_3824_8912:()=>yFo,content_3824_8914:()=>gFo,content_3824_8916:()=>MFo,content_3824_8918:()=>wFo,content_3824_892:()=>Cme,content_3824_8920:()=>xFo,content_3824_8922:()=>LFo,content_3824_8924:()=>kFo,content_3824_8926:()=>IFo,content_3824_8928:()=>SFo,content_3824_8930:()=>EFo,content_3824_8932:()=>FFo,content_3824_8934:()=>jFo,content_3824_8936:()=>QFo,content_3824_8938:()=>JFo,content_3824_894:()=>vme,content_3824_8940:()=>nVo,content_3824_8942:()=>pVo,content_3824_8944:()=>cVo,content_3824_8946:()=>lVo,content_3824_8948:()=>yVo,content_3824_8950:()=>gVo,content_3824_8952:()=>MVo,content_3824_8954:()=>wVo,content_3824_8956:()=>xVo,content_3824_8958:()=>LVo,content_3824_896:()=>Nme,content_3824_8960:()=>kVo,content_3824_8962:()=>IVo,content_3824_8964:()=>SVo,content_3824_8966:()=>EVo,content_3824_8968:()=>FVo,content_3824_8970:()=>jVo,content_3824_8972:()=>QVo,content_3824_8974:()=>JVo,content_3824_8976:()=>nqo,content_3824_8978:()=>pqo,content_3824_898:()=>Pme,content_3824_8980:()=>cqo,content_3824_8982:()=>lqo,content_3824_8984:()=>yqo,content_3824_8986:()=>gqo,content_3824_8988:()=>Mqo,content_3824_8990:()=>wqo,content_3824_8992:()=>xqo,content_3824_8994:()=>Lqo,content_3824_8996:()=>kqo,content_3824_8998:()=>Iqo,content_3824_90:()=>i0,content_3824_900:()=>Wme,content_3824_9000:()=>Sqo,content_3824_9002:()=>Eqo,content_3824_9004:()=>Fqo,content_3824_9006:()=>jqo,content_3824_9008:()=>Qqo,content_3824_9010:()=>Jqo,content_3824_9012:()=>njo,content_3824_9014:()=>pjo,content_3824_9016:()=>cjo,content_3824_9018:()=>ljo,content_3824_902:()=>Gme,content_3824_9020:()=>yjo,content_3824_9022:()=>gjo,content_3824_9024:()=>Mjo,content_3824_9026:()=>wjo,content_3824_9028:()=>xjo,content_3824_9030:()=>Ljo,content_3824_9032:()=>kjo,content_3824_9034:()=>Ijo,content_3824_9036:()=>Sjo,content_3824_9038:()=>Ejo,content_3824_904:()=>Ume,content_3824_9040:()=>Fjo,content_3824_9042:()=>jjo,content_3824_9044:()=>Qjo,content_3824_9046:()=>Jjo,content_3824_9048:()=>nHo,content_3824_9050:()=>pHo,content_3824_9052:()=>cHo,content_3824_9054:()=>lHo,content_3824_9056:()=>yHo,content_3824_9058:()=>gHo,content_3824_906:()=>qme,content_3824_9060:()=>MHo,content_3824_9062:()=>wHo,content_3824_9064:()=>xHo,content_3824_9066:()=>LHo,content_3824_9068:()=>kHo,content_3824_9070:()=>IHo,content_3824_9072:()=>SHo,content_3824_9074:()=>EHo,content_3824_9076:()=>FHo,content_3824_9078:()=>jHo,content_3824_908:()=>Yme,content_3824_9080:()=>QHo,content_3824_9082:()=>JHo,content_3824_9084:()=>nYo,content_3824_9086:()=>pYo,content_3824_9088:()=>cYo,content_3824_9090:()=>lYo,content_3824_9092:()=>yYo,content_3824_9094:()=>gYo,content_3824_9096:()=>MYo,content_3824_9098:()=>wYo,content_3824_910:()=>Kme,content_3824_9100:()=>xYo,content_3824_9102:()=>LYo,content_3824_9104:()=>kYo,content_3824_9106:()=>IYo,content_3824_9108:()=>SYo,content_3824_9110:()=>EYo,content_3824_9112:()=>FYo,content_3824_9114:()=>jYo,content_3824_9116:()=>QYo,content_3824_9118:()=>JYo,content_3824_912:()=>eye,content_3824_9120:()=>nQo,content_3824_9122:()=>pQo,content_3824_9124:()=>cQo,content_3824_9126:()=>lQo,content_3824_9128:()=>yQo,content_3824_9130:()=>gQo,content_3824_9132:()=>MQo,content_3824_9134:()=>wQo,content_3824_9136:()=>xQo,content_3824_9138:()=>LQo,content_3824_914:()=>oye,content_3824_9140:()=>kQo,content_3824_9142:()=>IQo,content_3824_9144:()=>SQo,content_3824_9146:()=>EQo,content_3824_9148:()=>FQo,content_3824_9150:()=>jQo,content_3824_9152:()=>QQo,content_3824_9154:()=>JQo,content_3824_9156:()=>n$o,content_3824_9158:()=>p$o,content_3824_916:()=>sye,content_3824_9160:()=>c$o,content_3824_9162:()=>l$o,content_3824_9164:()=>y$o,content_3824_9166:()=>g$o,content_3824_9168:()=>M$o,content_3824_9170:()=>w$o,content_3824_9172:()=>x$o,content_3824_9174:()=>L$o,content_3824_9176:()=>k$o,content_3824_9178:()=>I$o,content_3824_918:()=>iye,content_3824_9180:()=>S$o,content_3824_9182:()=>E$o,content_3824_9184:()=>F$o,content_3824_9186:()=>j$o,content_3824_9188:()=>Q$o,content_3824_9190:()=>J$o,content_3824_9192:()=>nKo,content_3824_9194:()=>pKo,content_3824_9196:()=>cKo,content_3824_9198:()=>lKo,content_3824_92:()=>m0,content_3824_920:()=>mye,content_3824_9200:()=>yKo,content_3824_9202:()=>gKo,content_3824_9204:()=>MKo,content_3824_9206:()=>wKo,content_3824_9208:()=>xKo,content_3824_9210:()=>LKo,content_3824_9212:()=>kKo,content_3824_9214:()=>IKo,content_3824_9216:()=>SKo,content_3824_9218:()=>EKo,content_3824_922:()=>hye,content_3824_9220:()=>FKo,content_3824_9222:()=>jKo,content_3824_9224:()=>QKo,content_3824_9226:()=>JKo,content_3824_9228:()=>nJo,content_3824_9230:()=>pJo,content_3824_9232:()=>cJo,content_3824_9234:()=>lJo,content_3824_9236:()=>yJo,content_3824_9238:()=>gJo,content_3824_924:()=>Dye,content_3824_9240:()=>MJo,content_3824_9242:()=>wJo,content_3824_9244:()=>xJo,content_3824_9246:()=>LJo,content_3824_9248:()=>kJo,content_3824_9250:()=>IJo,content_3824_9252:()=>SJo,content_3824_9254:()=>EJo,content_3824_9256:()=>FJo,content_3824_9258:()=>jJo,content_3824_926:()=>_ye,content_3824_9260:()=>QJo,content_3824_9262:()=>JJo,content_3824_9264:()=>nZo,content_3824_9266:()=>pZo,content_3824_9268:()=>cZo,content_3824_9270:()=>lZo,content_3824_9272:()=>yZo,content_3824_9274:()=>gZo,content_3824_9276:()=>MZo,content_3824_9278:()=>wZo,content_3824_928:()=>Cye,content_3824_9280:()=>xZo,content_3824_9282:()=>LZo,content_3824_9284:()=>kZo,content_3824_9286:()=>IZo,content_3824_9288:()=>SZo,content_3824_9290:()=>EZo,content_3824_9292:()=>FZo,content_3824_9294:()=>jZo,content_3824_9296:()=>QZo,content_3824_9298:()=>JZo,content_3824_930:()=>vye,content_3824_9300:()=>n0o,content_3824_9302:()=>p0o,content_3824_9304:()=>c0o,content_3824_9306:()=>l0o,content_3824_9308:()=>y0o,content_3824_9310:()=>g0o,content_3824_9312:()=>M0o,content_3824_9314:()=>w0o,content_3824_9316:()=>x0o,content_3824_9318:()=>L0o,content_3824_932:()=>Nye,content_3824_9320:()=>k0o,content_3824_9322:()=>I0o,content_3824_9324:()=>S0o,content_3824_9326:()=>E0o,content_3824_9328:()=>F0o,content_3824_9330:()=>j0o,content_3824_9332:()=>Q0o,content_3824_9334:()=>J0o,content_3824_9336:()=>n2o,content_3824_9338:()=>p2o,content_3824_934:()=>Pye,content_3824_9340:()=>c2o,content_3824_9342:()=>l2o,content_3824_9344:()=>y2o,content_3824_9346:()=>g2o,content_3824_9348:()=>M2o,content_3824_9350:()=>w2o,content_3824_9352:()=>x2o,content_3824_9354:()=>L2o,content_3824_9356:()=>k2o,content_3824_9358:()=>I2o,content_3824_936:()=>Wye,content_3824_9360:()=>S2o,content_3824_9362:()=>E2o,content_3824_9364:()=>F2o,content_3824_9366:()=>j2o,content_3824_9368:()=>Q2o,content_3824_9370:()=>J2o,content_3824_9372:()=>n4o,content_3824_9374:()=>p4o,content_3824_9376:()=>c4o,content_3824_9378:()=>l4o,content_3824_938:()=>Gye,content_3824_9380:()=>y4o,content_3824_9382:()=>g4o,content_3824_9384:()=>M4o,content_3824_9386:()=>w4o,content_3824_9388:()=>x4o,content_3824_9390:()=>L4o,content_3824_9392:()=>k4o,content_3824_9394:()=>I4o,content_3824_9396:()=>S4o,content_3824_9398:()=>E4o,content_3824_94:()=>h0,content_3824_940:()=>Uye,content_3824_9400:()=>F4o,content_3824_9402:()=>j4o,content_3824_9404:()=>Q4o,content_3824_9406:()=>J4o,content_3824_9408:()=>n8o,content_3824_9410:()=>p8o,content_3824_9412:()=>c8o,content_3824_9414:()=>l8o,content_3824_9416:()=>y8o,content_3824_9418:()=>g8o,content_3824_942:()=>qye,content_3824_9420:()=>M8o,content_3824_9422:()=>w8o,content_3824_9424:()=>x8o,content_3824_9426:()=>L8o,content_3824_9428:()=>k8o,content_3824_9430:()=>I8o,content_3824_9432:()=>S8o,content_3824_9434:()=>E8o,content_3824_9436:()=>F8o,content_3824_9438:()=>j8o,content_3824_944:()=>Yye,content_3824_9440:()=>Q8o,content_3824_9442:()=>J8o,content_3824_9444:()=>n3o,content_3824_9446:()=>p3o,content_3824_9448:()=>c3o,content_3824_9450:()=>l3o,content_3824_9452:()=>y3o,content_3824_9454:()=>g3o,content_3824_9456:()=>M3o,content_3824_9458:()=>w3o,content_3824_946:()=>Kye,content_3824_9460:()=>x3o,content_3824_9462:()=>L3o,content_3824_9464:()=>k3o,content_3824_9466:()=>I3o,content_3824_9468:()=>S3o,content_3824_9470:()=>E3o,content_3824_9472:()=>F3o,content_3824_9474:()=>j3o,content_3824_9476:()=>Q3o,content_3824_9478:()=>J3o,content_3824_948:()=>ede,content_3824_9480:()=>n1o,content_3824_9482:()=>p1o,content_3824_9484:()=>c1o,content_3824_9486:()=>l1o,content_3824_9488:()=>y1o,content_3824_9490:()=>g1o,content_3824_9492:()=>M1o,content_3824_9494:()=>w1o,content_3824_9496:()=>x1o,content_3824_9498:()=>L1o,content_3824_950:()=>ode,content_3824_9500:()=>k1o,content_3824_9502:()=>I1o,content_3824_9504:()=>S1o,content_3824_9506:()=>E1o,content_3824_9508:()=>F1o,content_3824_9510:()=>j1o,content_3824_9512:()=>Q1o,content_3824_9514:()=>J1o,content_3824_9516:()=>n6o,content_3824_9518:()=>p6o,content_3824_952:()=>sde,content_3824_9520:()=>c6o,content_3824_9522:()=>l6o,content_3824_9524:()=>y6o,content_3824_9526:()=>g6o,content_3824_9528:()=>M6o,content_3824_9530:()=>w6o,content_3824_9532:()=>x6o,content_3824_9534:()=>L6o,content_3824_9536:()=>k6o,content_3824_9538:()=>I6o,content_3824_954:()=>ide,content_3824_9540:()=>S6o,content_3824_9542:()=>E6o,content_3824_9544:()=>F6o,content_3824_9546:()=>j6o,content_3824_9548:()=>Q6o,content_3824_9550:()=>J6o,content_3824_9552:()=>n5o,content_3824_9554:()=>p5o,content_3824_9556:()=>c5o,content_3824_9558:()=>l5o,content_3824_956:()=>mde,content_3824_9560:()=>y5o,content_3824_9562:()=>g5o,content_3824_9564:()=>M5o,content_3824_9566:()=>w5o,content_3824_9568:()=>x5o,content_3824_9570:()=>L5o,content_3824_9572:()=>k5o,content_3824_9574:()=>I5o,content_3824_9576:()=>S5o,content_3824_9578:()=>E5o,content_3824_958:()=>hde,content_3824_9580:()=>F5o,content_3824_9582:()=>j5o,content_3824_9584:()=>Q5o,content_3824_9586:()=>J5o,content_3824_9588:()=>n7o,content_3824_9590:()=>p7o,content_3824_9592:()=>c7o,content_3824_9594:()=>l7o,content_3824_9596:()=>y7o,content_3824_9598:()=>g7o,content_3824_96:()=>D0,content_3824_960:()=>Dde,content_3824_9600:()=>M7o,content_3824_9602:()=>w7o,content_3824_9604:()=>x7o,content_3824_9606:()=>L7o,content_3824_9608:()=>k7o,content_3824_9610:()=>I7o,content_3824_9612:()=>S7o,content_3824_9614:()=>E7o,content_3824_9616:()=>F7o,content_3824_9618:()=>j7o,content_3824_962:()=>_de,content_3824_9620:()=>Q7o,content_3824_9622:()=>J7o,content_3824_9624:()=>n9o,content_3824_9626:()=>p9o,content_3824_9628:()=>c9o,content_3824_9630:()=>l9o,content_3824_9632:()=>y9o,content_3824_9634:()=>g9o,content_3824_9636:()=>M9o,content_3824_9638:()=>w9o,content_3824_964:()=>Cde,content_3824_9640:()=>x9o,content_3824_9642:()=>L9o,content_3824_9644:()=>k9o,content_3824_9646:()=>I9o,content_3824_9648:()=>S9o,content_3824_9650:()=>E9o,content_3824_9652:()=>F9o,content_3824_9654:()=>j9o,content_3824_9656:()=>Q9o,content_3824_9658:()=>J9o,content_3824_966:()=>vde,content_3824_9660:()=>nep,content_3824_9662:()=>pep,content_3824_9664:()=>cep,content_3824_9666:()=>lep,content_3824_9668:()=>yep,content_3824_9670:()=>gep,content_3824_9672:()=>Mep,content_3824_9674:()=>wep,content_3824_9676:()=>xep,content_3824_9678:()=>Lep,content_3824_968:()=>Nde,content_3824_9680:()=>kep,content_3824_9682:()=>Iep,content_3824_9684:()=>Sep,content_3824_9686:()=>Eep,content_3824_9688:()=>Fep,content_3824_9690:()=>jep,content_3824_9692:()=>Qep,content_3824_9694:()=>Jep,content_3824_9696:()=>nnp,content_3824_9698:()=>pnp,content_3824_970:()=>Pde,content_3824_9700:()=>cnp,content_3824_9702:()=>lnp,content_3824_9704:()=>ynp,content_3824_9706:()=>gnp,content_3824_9708:()=>Mnp,content_3824_9710:()=>wnp,content_3824_9712:()=>xnp,content_3824_9714:()=>Lnp,content_3824_9716:()=>knp,content_3824_9718:()=>Inp,content_3824_972:()=>Wde,content_3824_9720:()=>Snp,content_3824_9722:()=>Enp,content_3824_9724:()=>Fnp,content_3824_9726:()=>jnp,content_3824_9728:()=>Qnp,content_3824_9730:()=>Jnp,content_3824_9732:()=>ntp,content_3824_9734:()=>ptp,content_3824_9736:()=>ctp,content_3824_9738:()=>ltp,content_3824_974:()=>Gde,content_3824_9740:()=>ytp,content_3824_9742:()=>gtp,content_3824_9744:()=>Mtp,content_3824_9746:()=>wtp,content_3824_9748:()=>xtp,content_3824_9750:()=>Ltp,content_3824_9752:()=>ktp,content_3824_9754:()=>Itp,content_3824_9756:()=>Stp,content_3824_9758:()=>Etp,content_3824_976:()=>Ude,content_3824_9760:()=>Ftp,content_3824_9762:()=>jtp,content_3824_9764:()=>Qtp,content_3824_9766:()=>Jtp,content_3824_9768:()=>nop,content_3824_9770:()=>pop,content_3824_9772:()=>cop,content_3824_9774:()=>lop,content_3824_9776:()=>yop,content_3824_9778:()=>gop,content_3824_978:()=>qde,content_3824_9780:()=>Mop,content_3824_9782:()=>wop,content_3824_9784:()=>xop,content_3824_9786:()=>Lop,content_3824_9788:()=>kop,content_3824_9790:()=>Iop,content_3824_9792:()=>Sop,content_3824_9794:()=>Eop,content_3824_9796:()=>Fop,content_3824_9798:()=>jop,content_3824_98:()=>_0,content_3824_980:()=>Yde,content_3824_9800:()=>Qop,content_3824_9802:()=>Jop,content_3824_9804:()=>npp,content_3824_9806:()=>ppp,content_3824_9808:()=>cpp,content_3824_9810:()=>lpp,content_3824_9812:()=>ypp,content_3824_9814:()=>gpp,content_3824_9816:()=>Mpp,content_3824_9818:()=>wpp,content_3824_982:()=>Kde,content_3824_9820:()=>xpp,content_3824_9822:()=>Lpp,content_3824_9824:()=>kpp,content_3824_9826:()=>Ipp,content_3824_9828:()=>Spp,content_3824_9830:()=>Epp,content_3824_9832:()=>Fpp,content_3824_9834:()=>jpp,content_3824_9836:()=>Qpp,content_3824_9838:()=>Jpp,content_3824_984:()=>ehe,content_3824_9840:()=>nrp,content_3824_9842:()=>prp,content_3824_9844:()=>crp,content_3824_9846:()=>lrp,content_3824_9848:()=>yrp,content_3824_9850:()=>grp,content_3824_9852:()=>Mrp,content_3824_9854:()=>wrp,content_3824_9856:()=>xrp,content_3824_9858:()=>Lrp,content_3824_986:()=>ohe,content_3824_9860:()=>krp,content_3824_9862:()=>Irp,content_3824_9864:()=>Srp,content_3824_9866:()=>Erp,content_3824_9868:()=>Frp,content_3824_9870:()=>jrp,content_3824_9872:()=>Qrp,content_3824_9874:()=>Jrp,content_3824_9876:()=>nsp,content_3824_9878:()=>psp,content_3824_988:()=>she,content_3824_9880:()=>csp,content_3824_9882:()=>lsp,content_3824_9884:()=>ysp,content_3824_9886:()=>gsp,content_3824_9888:()=>Msp,content_3824_9890:()=>wsp,content_3824_9892:()=>xsp,content_3824_9894:()=>Lsp,content_3824_9896:()=>ksp,content_3824_9898:()=>Isp,content_3824_990:()=>ihe,content_3824_9900:()=>Ssp,content_3824_9902:()=>Esp,content_3824_9904:()=>Fsp,content_3824_9906:()=>jsp,content_3824_9908:()=>Qsp,content_3824_9910:()=>Jsp,content_3824_9912:()=>ncp,content_3824_9914:()=>pcp,content_3824_9916:()=>ccp,content_3824_9918:()=>lcp,content_3824_992:()=>mhe,content_3824_9920:()=>ycp,content_3824_9922:()=>gcp,content_3824_9924:()=>Mcp,content_3824_9926:()=>wcp,content_3824_9928:()=>xcp,content_3824_9930:()=>Lcp,content_3824_9932:()=>kcp,content_3824_9934:()=>Icp,content_3824_9936:()=>Scp,content_3824_9938:()=>Ecp,content_3824_994:()=>hhe,content_3824_9940:()=>Fcp,content_3824_9942:()=>jcp,content_3824_9944:()=>Qcp,content_3824_9946:()=>Jcp,content_3824_9948:()=>nap,content_3824_9950:()=>pap,content_3824_9952:()=>cap,content_3824_9954:()=>lap,content_3824_9956:()=>yap,content_3824_9958:()=>gap,content_3824_996:()=>Dhe,content_3824_9960:()=>Map,content_3824_9962:()=>wap,content_3824_9964:()=>xap,content_3824_9966:()=>Lap,content_3824_9968:()=>kap,content_3824_9970:()=>Iap,content_3824_9972:()=>Sap,content_3824_9974:()=>Eap,content_3824_9976:()=>Fap,content_3824_9978:()=>jap,content_3824_998:()=>_he,content_3824_9980:()=>Qap,content_3824_9982:()=>Jap,content_3824_9984:()=>nip,content_3824_9986:()=>pip,content_3824_9988:()=>cip,content_3824_9990:()=>lip,content_3824_9992:()=>yip,content_3824_9994:()=>gip,content_3824_9996:()=>Mip,content_3824_9998:()=>wip});var p=t(9575),r=t(4041),s=t(2247);const c={toc:[]},a="wrapper";function i(e){let{components:n,...t}=e;return(0,s.yg)(a,(0,p.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const l={toc:[]},u="wrapper";function m(e){let{components:n,...t}=e;return(0,s.yg)(u,(0,p.A)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when a new message is logged."))}m.isMDXComponent=!0;const y={toc:[]},d="wrapper";function h(e){let{components:n,...t}=e;return(0,s.yg)(d,(0,p.A)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A read-only representation of the playback."))}h.isMDXComponent=!0;const g={toc:[]},f="wrapper";function D(e){let{components:n,...t}=e;return(0,s.yg)(f,(0,p.A)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The time passed since the last frame in seconds."))}D.isMDXComponent=!0;const M={toc:[]},X="wrapper";function _(e){let{components:n,...t}=e;return(0,s.yg)(X,(0,p.A)({},M,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert frames to seconds using the current framerate."))}_.isMDXComponent=!0;const w={toc:[]},T="wrapper";function C(e){let{components:n,...t}=e;return(0,s.yg)(T,(0,p.A)({},w,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frames to convert."))}C.isMDXComponent=!0;const x={toc:[]},A="wrapper";function v(e){let{components:n,...t}=e;return(0,s.yg)(A,(0,p.A)({},x,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert seconds to frames using the current framerate."))}v.isMDXComponent=!0;const L={toc:[]},b="wrapper";function N(e){let{components:n,...t}=e;return(0,s.yg)(b,(0,p.A)({},L,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The seconds to convert."))}N.isMDXComponent=!0;const k={toc:[]},z="wrapper";function P(e){let{components:n,...t}=e;return(0,s.yg)(z,(0,p.A)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This class builds on top of the ",(0,s.yg)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}P.isMDXComponent=!0;const I={toc:[]},R="wrapper";function W(e){let{components:n,...t}=e;return(0,s.yg)(R,(0,p.A)({},I,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The player logic used by the editor and embeddable player."))}W.isMDXComponent=!0;const S={toc:[]},B="wrapper";function G(e){let{components:n,...t}=e;return(0,s.yg)(B,(0,p.A)({},S,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to provide visual feedback."))}G.isMDXComponent=!0;const E={toc:[]},O="wrapper";function U(e){let{components:n,...t}=e;return(0,s.yg)(O,(0,p.A)({},E,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered right after recalculation finishes."))}U.isMDXComponent=!0;const F={toc:[]},V="wrapper";function q(e){let{components:n,...t}=e;return(0,s.yg)(V,(0,p.A)({},F,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.yg)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.yg)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}q.isMDXComponent=!0;const j={toc:[]},H="wrapper";function Y(e){let{components:n,...t}=e;return(0,s.yg)(H,(0,p.A)({},j,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}Y.isMDXComponent=!0;const Q={toc:[]},$="wrapper";function K(e){let{components:n,...t}=e;return(0,s.yg)($,(0,p.A)({},Q,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}K.isMDXComponent=!0;const J={toc:[]},Z="wrapper";function ee(e){let{components:n,...t}=e;return(0,s.yg)(Z,(0,p.A)({},J,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Activate the player."))}ee.isMDXComponent=!0;const ne={toc:[]},te="wrapper";function oe(e){let{components:n,...t}=e;return(0,s.yg)(te,(0,p.A)({},ne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.yg)("p",null,"Just pausing the player does not stop the loop."))}oe.isMDXComponent=!0;const pe={toc:[]},re="wrapper";function se(e){let{components:n,...t}=e;return(0,s.yg)(re,(0,p.A)({},pe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Deactivate the player."))}se.isMDXComponent=!0;const ce={toc:[]},ae="wrapper";function ie(e){let{components:n,...t}=e;return(0,s.yg)(ae,(0,p.A)({},ce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the given frame is inside the animation range."))}ie.isMDXComponent=!0;const le={toc:[]},ue="wrapper";function me(e){let{components:n,...t}=e;return(0,s.yg)(ue,(0,p.A)({},le,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame to check."))}me.isMDXComponent=!0;const ye={toc:[]},de="wrapper";function he(e){let{components:n,...t}=e;return(0,s.yg)(de,(0,p.A)({},ye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the given frame is inside the user-defined range."))}he.isMDXComponent=!0;const ge={toc:[]},fe="wrapper";function De(e){let{components:n,...t}=e;return(0,s.yg)(fe,(0,p.A)({},ge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame to check."))}De.isMDXComponent=!0;const Me={toc:[]},Xe="wrapper";function _e(e){let{components:n,...t}=e;return(0,s.yg)(Xe,(0,p.A)({},Me,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abort the ongoing presentation process."))}_e.isMDXComponent=!0;const we={toc:[]},Te="wrapper";function Ce(e){let{components:n,...t}=e;return(0,s.yg)(Te,(0,p.A)({},we,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Present the animation."))}Ce.isMDXComponent=!0;const xe={toc:[]},Ae="wrapper";function ve(e){let{components:n,...t}=e;return(0,s.yg)(Ae,(0,p.A)({},xe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The presentation settings."))}ve.isMDXComponent=!0;const Le={toc:[]},be="wrapper";function Ne(e){let{components:n,...t}=e;return(0,s.yg)(be,(0,p.A)({},Le,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Resume the presentation if waiting for the next slide."))}Ne.isMDXComponent=!0;const ke={toc:[]},ze="wrapper";function Pe(e){let{components:n,...t}=e;return(0,s.yg)(ze,(0,p.A)({},ke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Pe.isMDXComponent=!0;const Ie={toc:[]},Re="wrapper";function We(e){let{components:n,...t}=e;return(0,s.yg)(Re,(0,p.A)({},Ie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}We.isMDXComponent=!0;const Se={toc:[]},Be="wrapper";function Ge(e){let{components:n,...t}=e;return(0,s.yg)(Be,(0,p.A)({},Se,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}Ge.isMDXComponent=!0;const Ee={toc:[]},Oe="wrapper";function Ue(e){let{components:n,...t}=e;return(0,s.yg)(Oe,(0,p.A)({},Ee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}Ue.isMDXComponent=!0;const Fe={toc:[]},Ve="wrapper";function qe(e){let{components:n,...t}=e;return(0,s.yg)(Ve,(0,p.A)({},Fe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the nested fields change."))}qe.isMDXComponent=!0;const je={toc:[]},He="wrapper";function Ye(e){let{components:n,...t}=e;return(0,s.yg)(He,(0,p.A)({},je,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}Ye.isMDXComponent=!0;const Qe={toc:[]},$e="wrapper";function Ke(e){let{components:n,...t}=e;return(0,s.yg)($e,(0,p.A)({},Qe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}Ke.isMDXComponent=!0;const Je={toc:[]},Ze="wrapper";function en(e){let{components:n,...t}=e;return(0,s.yg)(Ze,(0,p.A)({},Je,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}en.isMDXComponent=!0;const nn={toc:[]},tn="wrapper";function on(e){let{components:n,...t}=e;return(0,s.yg)(tn,(0,p.A)({},nn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}on.isMDXComponent=!0;const pn={toc:[]},rn="wrapper";function sn(e){let{components:n,...t}=e;return(0,s.yg)(rn,(0,p.A)({},pn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}sn.isMDXComponent=!0;const cn={toc:[]},an="wrapper";function ln(e){let{components:n,...t}=e;return(0,s.yg)(an,(0,p.A)({},cn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}ln.isMDXComponent=!0;const un={toc:[]},mn="wrapper";function yn(e){let{components:n,...t}=e;return(0,s.yg)(mn,(0,p.A)({},un,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}yn.isMDXComponent=!0;const dn={toc:[]},hn="wrapper";function gn(e){let{components:n,...t}=e;return(0,s.yg)(hn,(0,p.A)({},dn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}gn.isMDXComponent=!0;const fn={toc:[]},Dn="wrapper";function Mn(e){let{components:n,...t}=e;return(0,s.yg)(Dn,(0,p.A)({},fn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Mn.isMDXComponent=!0;const Xn={toc:[]},_n="wrapper";function wn(e){let{components:n,...t}=e;return(0,s.yg)(_n,(0,p.A)({},Xn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This class uses the ",(0,s.yg)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.yg)("p",null,"The actual exporting is outsourced to an ",(0,s.yg)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.yg)("inlineCode",{parentName:"a"},"Exporter")),"."))}wn.isMDXComponent=!0;const Tn={toc:[]},Cn="wrapper";function xn(e){let{components:n,...t}=e;return(0,s.yg)(Cn,(0,p.A)({},Tn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering logic used by the editor to export animations."))}xn.isMDXComponent=!0;const An={toc:[]},vn="wrapper";function Ln(e){let{components:n,...t}=e;return(0,s.yg)(vn,(0,p.A)({},An,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abort the ongoing render process."))}Ln.isMDXComponent=!0;const bn={toc:[]},Nn="wrapper";function kn(e){let{components:n,...t}=e;return(0,s.yg)(Nn,(0,p.A)({},bn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns number of frames that a project will have."))}kn.isMDXComponent=!0;const zn={toc:[]},Pn="wrapper";function In(e){let{components:n,...t}=e;return(0,s.yg)(Pn,(0,p.A)({},zn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the animation using the provided settings."))}In.isMDXComponent=!0;const Rn={toc:[]},Wn="wrapper";function Sn(e){let{components:n,...t}=e;return(0,s.yg)(Wn,(0,p.A)({},Rn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}Sn.isMDXComponent=!0;const Bn={toc:[]},Gn="wrapper";function En(e){let{components:n,...t}=e;return(0,s.yg)(Gn,(0,p.A)({},Bn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method always uses the default ",(0,s.yg)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}En.isMDXComponent=!0;const On={toc:[]},Un="wrapper";function Fn(e){let{components:n,...t}=e;return(0,s.yg)(Un,(0,p.A)({},On,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export an individual frame."))}Fn.isMDXComponent=!0;const Vn={toc:[]},qn="wrapper";function jn(e){let{components:n,...t}=e;return(0,s.yg)(qn,(0,p.A)({},Vn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}jn.isMDXComponent=!0;const Hn={toc:[]},Yn="wrapper";function Qn(e){let{components:n,...t}=e;return(0,s.yg)(Yn,(0,p.A)({},Hn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timestamp to export."))}Qn.isMDXComponent=!0;const $n={toc:[]},Kn="wrapper";function Jn(e){let{components:n,...t}=e;return(0,s.yg)(Kn,(0,p.A)({},$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispose the WebGL context to free up resources."))}Jn.isMDXComponent=!0;const Zn={toc:[]},et="wrapper";function nt(e){let{components:n,...t}=e;return(0,s.yg)(et,(0,p.A)({},Zn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Manages canvases on which an animation can be displayed."))}nt.isMDXComponent=!0;const tt={toc:[]},ot="wrapper";function pt(e){let{components:n,...t}=e;return(0,s.yg)(ot,(0,p.A)({},tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main interface for implementing custom exporters."))}pt.isMDXComponent=!0;const rt={toc:[]},st="wrapper";function ct(e){let{components:n,...t}=e;return(0,s.yg)(st,(0,p.A)({},rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}ct.isMDXComponent=!0;const at={toc:[]},it="wrapper";function lt(e){let{components:n,...t}=e;return(0,s.yg)(it,(0,p.A)({},at,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the rendering configuration."))}lt.isMDXComponent=!0;const ut={toc:[]},mt="wrapper";function yt(e){let{components:n,...t}=e;return(0,s.yg)(mt,(0,p.A)({},ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Take in media assets per frame and generate audio track for the video."))}yt.isMDXComponent=!0;const dt={toc:[]},ht="wrapper";function gt(e){let{components:n,...t}=e;return(0,s.yg)(ht,(0,p.A)({},dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called each time after a frame is rendered."))}gt.isMDXComponent=!0;const ft={toc:[]},Dt="wrapper";function Mt(e){let{components:n,...t}=e;return(0,s.yg)(Dt,(0,p.A)({},ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export a frame."))}Mt.isMDXComponent=!0;const Xt={toc:[]},_t="wrapper";function wt(e){let{components:n,...t}=e;return(0,s.yg)(_t,(0,p.A)({},Xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A canvas containing the rendered frame."))}wt.isMDXComponent=!0;const Tt={toc:[]},Ct="wrapper";function xt(e){let{components:n,...t}=e;return(0,s.yg)(Ct,(0,p.A)({},Tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame number."))}xt.isMDXComponent=!0;const At={toc:[]},vt="wrapper";function Lt(e){let{components:n,...t}=e;return(0,s.yg)(vt,(0,p.A)({},At,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame number within the scene."))}Lt.isMDXComponent=!0;const bt={toc:[]},Nt="wrapper";function kt(e){let{components:n,...t}=e;return(0,s.yg)(Nt,(0,p.A)({},bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the scene with which the frame is associated."))}kt.isMDXComponent=!0;const zt={toc:[]},Pt="wrapper";function It(e){let{components:n,...t}=e;return(0,s.yg)(Pt,(0,p.A)({},zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An abort signal triggered if the user aborts the rendering."))}It.isMDXComponent=!0;const Rt={toc:[]},Wt="wrapper";function St(e){let{components:n,...t}=e;return(0,s.yg)(Wt,(0,p.A)({},Rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Performs clean-up."))}St.isMDXComponent=!0;const Bt={toc:[]},Gt="wrapper";function Et(e){let{components:n,...t}=e;return(0,s.yg)(Gt,(0,p.A)({},Bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}Et.isMDXComponent=!0;const Ot={toc:[]},Ut="wrapper";function Ft(e){let{components:n,...t}=e;return(0,s.yg)(Ut,(0,p.A)({},Ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.yg)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.yg)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}Ft.isMDXComponent=!0;const Vt={toc:[]},qt="wrapper";function jt(e){let{components:n,...t}=e;return(0,s.yg)(qt,(0,p.A)({},Vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Begin the rendering process."))}jt.isMDXComponent=!0;const Ht={toc:[]},Yt="wrapper";function Qt(e){let{components:n,...t}=e;return(0,s.yg)(Yt,(0,p.A)({},Ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after rendering the visual elements has finished and audio so that audio track can be merged."))}Qt.isMDXComponent=!0;const $t={toc:[]},Kt="wrapper";function Jt(e){let{components:n,...t}=e;return(0,s.yg)(Kt,(0,p.A)({},$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}Jt.isMDXComponent=!0;const Zt={toc:[]},eo="wrapper";function no(e){let{components:n,...t}=e;return(0,s.yg)(eo,(0,p.A)({},Zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of the rendering."))}no.isMDXComponent=!0;const to={toc:[]},oo="wrapper";function po(e){let{components:n,...t}=e;return(0,s.yg)(oo,(0,p.A)({},to,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The static interface for exporters."))}po.isMDXComponent=!0;const ro={toc:[]},so="wrapper";function co(e){let{components:n,...t}=e;return(0,s.yg)(so,(0,p.A)({},ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This name will be displayed in the editor."))}co.isMDXComponent=!0;const ao={toc:[]},io="wrapper";function lo(e){let{components:n,...t}=e;return(0,s.yg)(io,(0,p.A)({},ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this exporter."))}lo.isMDXComponent=!0;const uo={toc:[]},mo="wrapper";function yo(e){let{components:n,...t}=e;return(0,s.yg)(mo,(0,p.A)({},uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}yo.isMDXComponent=!0;const ho={toc:[]},go="wrapper";function fo(e){let{components:n,...t}=e;return(0,s.yg)(go,(0,p.A)({},ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The unique identifier of this exporter."))}fo.isMDXComponent=!0;const Do={toc:[]},Mo="wrapper";function Xo(e){let{components:n,...t}=e;return(0,s.yg)(Mo,(0,p.A)({},Do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}Xo.isMDXComponent=!0;const _o={toc:[]},wo="wrapper";function To(e){let{components:n,...t}=e;return(0,s.yg)(wo,(0,p.A)({},_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this exporter."))}To.isMDXComponent=!0;const Co={toc:[]},xo="wrapper";function Ao(e){let{components:n,...t}=e;return(0,s.yg)(xo,(0,p.A)({},Co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current project."))}Ao.isMDXComponent=!0;const vo={toc:[]},Lo="wrapper";function bo(e){let{components:n,...t}=e;return(0,s.yg)(Lo,(0,p.A)({},vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}bo.isMDXComponent=!0;const No={toc:[]},ko="wrapper";function zo(e){let{components:n,...t}=e;return(0,s.yg)(ko,(0,p.A)({},No,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a meta field representing the options of this exporter."))}zo.isMDXComponent=!0;const Po={toc:[]},Io="wrapper";function Ro(e){let{components:n,...t}=e;return(0,s.yg)(Io,(0,p.A)({},Po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When displayed in the editor, the log entry will have the following format:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},"                             inspect node \u2510\n  \u250c expand more          duration \u2510       \u2502\n  \u25bc                               \u25bc       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u25b6 message                       300 ms (+) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 remarks                                    \u2502\n\u2502 object                                     \u2502\n\u2502 stacktrace                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))}Ro.isMDXComponent=!0;const Wo={toc:[]},So="wrapper";function Bo(e){let{components:n,...t}=e;return(0,s.yg)(So,(0,p.A)({},Wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an individual log entry."))}Bo.isMDXComponent=!0;const Go={toc:[]},Eo="wrapper";function Oo(e){let{components:n,...t}=e;return(0,s.yg)(Eo,(0,p.A)({},Go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}Oo.isMDXComponent=!0;const Uo={toc:[]},Fo="wrapper";function Vo(e){let{components:n,...t}=e;return(0,s.yg)(Fo,(0,p.A)({},Uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}Vo.isMDXComponent=!0;const qo={toc:[]},jo="wrapper";function Ho(e){let{components:n,...t}=e;return(0,s.yg)(jo,(0,p.A)({},qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}Ho.isMDXComponent=!0;const Yo={toc:[]},Qo="wrapper";function $o(e){let{components:n,...t}=e;return(0,s.yg)(Qo,(0,p.A)({},Yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}$o.isMDXComponent=!0;const Ko={toc:[]},Jo="wrapper";function Zo(e){let{components:n,...t}=e;return(0,s.yg)(Jo,(0,p.A)({},Ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The log level."))}Zo.isMDXComponent=!0;const ep={toc:[]},np="wrapper";function tp(e){let{components:n,...t}=e;return(0,s.yg)(np,(0,p.A)({},ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}tp.isMDXComponent=!0;const op={toc:[]},pp="wrapper";function rp(e){let{components:n,...t}=e;return(0,s.yg)(pp,(0,p.A)({},op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}rp.isMDXComponent=!0;const sp={toc:[]},cp="wrapper";function ap(e){let{components:n,...t}=e;return(0,s.yg)(cp,(0,p.A)({},sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}ap.isMDXComponent=!0;const ip={toc:[]},lp="wrapper";function up(e){let{components:n,...t}=e;return(0,s.yg)(lp,(0,p.A)({},ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}up.isMDXComponent=!0;const mp={toc:[]},yp="wrapper";function dp(e){let{components:n,...t}=e;return(0,s.yg)(yp,(0,p.A)({},mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}dp.isMDXComponent=!0;const hp={toc:[]},gp="wrapper";function fp(e){let{components:n,...t}=e;return(0,s.yg)(gp,(0,p.A)({},hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional information about the log."))}fp.isMDXComponent=!0;const Dp={toc:[]},Mp="wrapper";function Xp(e){let{components:n,...t}=e;return(0,s.yg)(Mp,(0,p.A)({},Dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded.\nThe current stack trace can be obtained using ",(0,s.yg)("inlineCode",{parentName:"p"},"new Error().stack"),".\nBoth Chromium and Firefox stack traces are supported."))}Xp.isMDXComponent=!0;const _p={toc:[]},wp="wrapper";function Tp(e){let{components:n,...t}=e;return(0,s.yg)(wp,(0,p.A)({},_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace of the log."))}Tp.isMDXComponent=!0;const Cp={toc:[]},xp="wrapper";function Ap(e){let{components:n,...t}=e;return(0,s.yg)(xp,(0,p.A)({},Cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/media#audio"},"https://motioncanvas.io/docs/media#audio")))}Ap.isMDXComponent=!0;const vp={toc:[]},Lp="wrapper";function bp(e){let{components:n,...t}=e;return(0,s.yg)(Lp,(0,p.A)({},vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An url for the audio track to play alongside the animation."))}bp.isMDXComponent=!0;const Np={toc:[]},kp="wrapper";function zp(e){let{components:n,...t}=e;return(0,s.yg)(kp,(0,p.A)({},Np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configure the offset in the Video Settings tab of th editor."))}zp.isMDXComponent=!0;const Pp={toc:[]},Ip="wrapper";function Rp(e){let{components:n,...t}=e;return(0,s.yg)(Ip,(0,p.A)({},Pp,t,{components:n,mdxType:"MDXLayout"}))}Rp.isMDXComponent=!0;const Wp={toc:[]},Sp="wrapper";function Bp(e){let{components:n,...t}=e;return(0,s.yg)(Sp,(0,p.A)({},Wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/experimental"},"https://motioncanvas.io/docs/experimental")))}Bp.isMDXComponent=!0;const Gp={toc:[]},Ep="wrapper";function Op(e){let{components:n,...t}=e;return(0,s.yg)(Ep,(0,p.A)({},Gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enable experimental features."))}Op.isMDXComponent=!0;const Up={toc:[]},Fp="wrapper";function Vp(e){let{components:n,...t}=e;return(0,s.yg)(Fp,(0,p.A)({},Up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A custom logger instance to use."))}Vp.isMDXComponent=!0;const qp={toc:[]},jp="wrapper";function Hp(e){let{components:n,...t}=e;return(0,s.yg)(jp,(0,p.A)({},qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the project."))}Hp.isMDXComponent=!0;const Yp={toc:[]},Qp="wrapper";function $p(e){let{components:n,...t}=e;return(0,s.yg)(Qp,(0,p.A)({},Yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When a string is provided, the plugin will be imported dynamically using\nthe string as the module specifier. This is the preferred way to include\neditor plugins because it makes sure that the plugin's source code gets\nexcluded from the production build."))}$p.isMDXComponent=!0;const Kp={toc:[]},Jp="wrapper";function Zp(e){let{components:n,...t}=e;return(0,s.yg)(Jp,(0,p.A)({},Kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}Zp.isMDXComponent=!0;const er={toc:[]},nr="wrapper";function tr(e){let{components:n,...t}=e;return(0,s.yg)(nr,(0,p.A)({},er,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A full scene description can be obtained by loading a scene module with a\n",(0,s.yg)("inlineCode",{parentName:"p"},"?scene")," query parameter."))}tr.isMDXComponent=!0;const or={toc:[]},pr="wrapper";function rr(e){let{components:n,...t}=e;return(0,s.yg)(pr,(0,p.A)({},or,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"import exampleScene from './example?scene';\n\nexport default makeProject({\n  scenes: [exampleScene],\n});\n")))}rr.isMDXComponent=!0;const sr={toc:[]},cr="wrapper";function ar(e){let{components:n,...t}=e;return(0,s.yg)(cr,(0,p.A)({},sr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of scene descriptions that make up the project."))}ar.isMDXComponent=!0;const ir={toc:[]},lr="wrapper";function ur(e){let{components:n,...t}=e;return(0,s.yg)(lr,(0,p.A)({},ir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/project-variables"},"https://motioncanvas.io/docs/project-variables")))}ur.isMDXComponent=!0;const mr={toc:[]},yr="wrapper";function dr(e){let{components:n,...t}=e;return(0,s.yg)(yr,(0,p.A)({},mr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default values for project variables."))}dr.isMDXComponent=!0;const hr={toc:[]},gr="wrapper";function fr(e){let{components:n,...t}=e;return(0,s.yg)(gr,(0,p.A)({},hr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A runtime representation of the settings metadata."))}fr.isMDXComponent=!0;const Dr={toc:[]},Mr="wrapper";function Xr(e){let{components:n,...t}=e;return(0,s.yg)(Mr,(0,p.A)({},Dr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a runtime representation of the settings metadata."))}Xr.isMDXComponent=!0;const _r={toc:[]},wr="wrapper";function Tr(e){let{components:n,...t}=e;return(0,s.yg)(wr,(0,p.A)({},_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Property decorators."))}Tr.isMDXComponent=!0;const Cr={toc:[]},xr="wrapper";function Ar(e){let{components:n,...t}=e;return(0,s.yg)(xr,(0,p.A)({},Cr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.yg)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}Ar.isMDXComponent=!0;const vr={toc:[]},Lr="wrapper";function br(e){let{components:n,...t}=e;return(0,s.yg)(Lr,(0,p.A)({},vr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a lazy decorator."))}br.isMDXComponent=!0;const Nr={toc:[]},kr="wrapper";function zr(e){let{components:n,...t}=e;return(0,s.yg)(kr,(0,p.A)({},Nr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns the value of this property."))}zr.isMDXComponent=!0;const Pr={toc:[]},Ir="wrapper";function Rr(e){let{components:n,...t}=e;return(0,s.yg)(Ir,(0,p.A)({},Pr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscriptions and triggering of events."))}Rr.isMDXComponent=!0;const Wr={toc:[]},Sr="wrapper";function Br(e){let{components:n,...t}=e;return(0,s.yg)(Sr,(0,p.A)({},Wr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.yg)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}Br.isMDXComponent=!0;const Gr={toc:[]},Er="wrapper";function Or(e){let{components:n,...t}=e;return(0,s.yg)(Er,(0,p.A)({},Gr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}Or.isMDXComponent=!0;const Ur={toc:[]},Fr="wrapper";function Vr(e){let{components:n,...t}=e;return(0,s.yg)(Fr,(0,p.A)({},Ur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches an asynchronous ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Vr.isMDXComponent=!0;const qr={toc:[]},jr="wrapper";function Hr(e){let{components:n,...t}=e;return(0,s.yg)(jr,(0,p.A)({},qr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Hr.isMDXComponent=!0;const Yr={toc:[]},Qr="wrapper";function $r(e){let{components:n,...t}=e;return(0,s.yg)(Qr,(0,p.A)({},Yr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}$r.isMDXComponent=!0;const Kr={toc:[]},Jr="wrapper";function Zr(e){let{components:n,...t}=e;return(0,s.yg)(Jr,(0,p.A)({},Kr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}Zr.isMDXComponent=!0;const es={toc:[]},ns="wrapper";function ts(e){let{components:n,...t}=e;return(0,s.yg)(ns,(0,p.A)({},es,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}ts.isMDXComponent=!0;const os={toc:[]},ps="wrapper";function rs(e){let{components:n,...t}=e;return(0,s.yg)(ps,(0,p.A)({},os,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}rs.isMDXComponent=!0;const ss={toc:[]},cs="wrapper";function as(e){let{components:n,...t}=e;return(0,s.yg)(cs,(0,p.A)({},ss,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}as.isMDXComponent=!0;const is={toc:[]},ls="wrapper";function us(e){let{components:n,...t}=e;return(0,s.yg)(ls,(0,p.A)({},is,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}us.isMDXComponent=!0;const ms={toc:[]},ys="wrapper";function ds(e){let{components:n,...t}=e;return(0,s.yg)(ys,(0,p.A)({},ms,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}ds.isMDXComponent=!0;const hs={toc:[]},gs="wrapper";function fs(e){let{components:n,...t}=e;return(0,s.yg)(gs,(0,p.A)({},hs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}fs.isMDXComponent=!0;const Ds={toc:[]},Ms="wrapper";function Xs(e){let{components:n,...t}=e;return(0,s.yg)(Ms,(0,p.A)({},Ds,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Xs.isMDXComponent=!0;const _s={toc:[]},ws="wrapper";function Ts(e){let{components:n,...t}=e;return(0,s.yg)(ws,(0,p.A)({},_s,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Ts.isMDXComponent=!0;const Cs={toc:[]},xs="wrapper";function As(e){let{components:n,...t}=e;return(0,s.yg)(xs,(0,p.A)({},Cs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}As.isMDXComponent=!0;const vs={toc:[]},Ls="wrapper";function bs(e){let{components:n,...t}=e;return(0,s.yg)(Ls,(0,p.A)({},vs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}bs.isMDXComponent=!0;const Ns={toc:[]},ks="wrapper";function zs(e){let{components:n,...t}=e;return(0,s.yg)(ks,(0,p.A)({},Ns,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}zs.isMDXComponent=!0;const Ps={toc:[]},Is="wrapper";function Rs(e){let{components:n,...t}=e;return(0,s.yg)(Is,(0,p.A)({},Ps,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Rs.isMDXComponent=!0;const Ws={toc:[]},Ss="wrapper";function Bs(e){let{components:n,...t}=e;return(0,s.yg)(Ss,(0,p.A)({},Ws,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value argument to subscribers."))}Bs.isMDXComponent=!0;const Gs={toc:[]},Es="wrapper";function Os(e){let{components:n,...t}=e;return(0,s.yg)(Es,(0,p.A)({},Gs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A base for dispatching ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.yg)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Os.isMDXComponent=!0;const Us={toc:[]},Fs="wrapper";function Vs(e){let{components:n,...t}=e;return(0,s.yg)(Fs,(0,p.A)({},Us,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Vs.isMDXComponent=!0;const qs={toc:[]},js="wrapper";function Hs(e){let{components:n,...t}=e;return(0,s.yg)(js,(0,p.A)({},qs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Hs.isMDXComponent=!0;const Ys={toc:[]},Qs="wrapper";function $s(e){let{components:n,...t}=e;return(0,s.yg)(Qs,(0,p.A)({},Ys,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}$s.isMDXComponent=!0;const Ks={toc:[]},Js="wrapper";function Zs(e){let{components:n,...t}=e;return(0,s.yg)(Js,(0,p.A)({},Ks,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Zs.isMDXComponent=!0;const ec={toc:[]},nc="wrapper";function tc(e){let{components:n,...t}=e;return(0,s.yg)(nc,(0,p.A)({},ec,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}tc.isMDXComponent=!0;const oc={toc:[]},pc="wrapper";function rc(e){let{components:n,...t}=e;return(0,s.yg)(pc,(0,p.A)({},oc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}rc.isMDXComponent=!0;const sc={toc:[]},cc="wrapper";function ac(e){let{components:n,...t}=e;return(0,s.yg)(cc,(0,p.A)({},sc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}ac.isMDXComponent=!0;const ic={toc:[]},lc="wrapper";function uc(e){let{components:n,...t}=e;return(0,s.yg)(lc,(0,p.A)({},ic,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the callback function."))}uc.isMDXComponent=!0;const mc={toc:[]},yc="wrapper";function dc(e){let{components:n,...t}=e;return(0,s.yg)(yc,(0,p.A)({},mc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.yg)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.yg)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}dc.isMDXComponent=!0;const hc={toc:[]},gc="wrapper";function fc(e){let{components:n,...t}=e;return(0,s.yg)(gc,(0,p.A)({},hc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}fc.isMDXComponent=!0;const Dc={toc:[]},Mc="wrapper";function Xc(e){let{components:n,...t}=e;return(0,s.yg)(Mc,(0,p.A)({},Dc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}Xc.isMDXComponent=!0;const _c={toc:[]},wc="wrapper";function Tc(e){let{components:n,...t}=e;return(0,s.yg)(wc,(0,p.A)({},_c,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Tc.isMDXComponent=!0;const Cc={toc:[]},xc="wrapper";function Ac(e){let{components:n,...t}=e;return(0,s.yg)(xc,(0,p.A)({},Cc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Are subscribers being notified?"))}Ac.isMDXComponent=!0;const vc={toc:[]},Lc="wrapper";function bc(e){let{components:n,...t}=e;return(0,s.yg)(Lc,(0,p.A)({},vc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Notify all current and future subscribers."))}bc.isMDXComponent=!0;const Nc={toc:[]},kc="wrapper";function zc(e){let{components:n,...t}=e;return(0,s.yg)(kc,(0,p.A)({},Nc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Stop notifying future subscribers."))}zc.isMDXComponent=!0;const Pc={toc:[]},Ic="wrapper";function Rc(e){let{components:n,...t}=e;return(0,s.yg)(Ic,(0,p.A)({},Pc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Rc.isMDXComponent=!0;const Wc={toc:[]},Sc="wrapper";function Bc(e){let{components:n,...t}=e;return(0,s.yg)(Sc,(0,p.A)({},Wc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}Bc.isMDXComponent=!0;const Gc={toc:[]},Ec="wrapper";function Oc(e){let{components:n,...t}=e;return(0,s.yg)(Ec,(0,p.A)({},Gc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Oc.isMDXComponent=!0;const Uc={toc:[]},Fc="wrapper";function Vc(e){let{components:n,...t}=e;return(0,s.yg)(Fc,(0,p.A)({},Uc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Vc.isMDXComponent=!0;const qc={toc:[]},jc="wrapper";function Hc(e){let{components:n,...t}=e;return(0,s.yg)(jc,(0,p.A)({},qc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Hc.isMDXComponent=!0;const Yc={toc:[]},Qc="wrapper";function $c(e){let{components:n,...t}=e;return(0,s.yg)(Qc,(0,p.A)({},Yc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}$c.isMDXComponent=!0;const Kc={toc:[]},Jc="wrapper";function Zc(e){let{components:n,...t}=e;return(0,s.yg)(Jc,(0,p.A)({},Kc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.yg)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Zc.isMDXComponent=!0;const ea={toc:[]},na="wrapper";function ta(e){let{components:n,...t}=e;return(0,s.yg)(na,(0,p.A)({},ea,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}ta.isMDXComponent=!0;const oa={toc:[]},pa="wrapper";function ra(e){let{components:n,...t}=e;return(0,s.yg)(pa,(0,p.A)({},oa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}ra.isMDXComponent=!0;const sa={toc:[]},ca="wrapper";function aa(e){let{components:n,...t}=e;return(0,s.yg)(ca,(0,p.A)({},sa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}aa.isMDXComponent=!0;const ia={toc:[]},la="wrapper";function ua(e){let{components:n,...t}=e;return(0,s.yg)(la,(0,p.A)({},ia,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}ua.isMDXComponent=!0;const ma={toc:[]},ya="wrapper";function da(e){let{components:n,...t}=e;return(0,s.yg)(ya,(0,p.A)({},ma,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}da.isMDXComponent=!0;const ha={toc:[]},ga="wrapper";function fa(e){let{components:n,...t}=e;return(0,s.yg)(ga,(0,p.A)({},ha,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}fa.isMDXComponent=!0;const Da={toc:[]},Ma="wrapper";function Xa(e){let{components:n,...t}=e;return(0,s.yg)(Ma,(0,p.A)({},Da,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the callback function."))}Xa.isMDXComponent=!0;const _a={toc:[]},wa="wrapper";function Ta(e){let{components:n,...t}=e;return(0,s.yg)(wa,(0,p.A)({},_a,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ta.isMDXComponent=!0;const Ca={toc:[]},xa="wrapper";function Aa(e){let{components:n,...t}=e;return(0,s.yg)(xa,(0,p.A)({},Ca,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Aa.isMDXComponent=!0;const va={toc:[]},La="wrapper";function ba(e){let{components:n,...t}=e;return(0,s.yg)(La,(0,p.A)({},va,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the most recent value of this dispatcher."))}ba.isMDXComponent=!0;const Na={toc:[]},ka="wrapper";function za(e){let{components:n,...t}=e;return(0,s.yg)(ka,(0,p.A)({},Na,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}za.isMDXComponent=!0;const Pa={toc:[]},Ia="wrapper";function Ra(e){let{components:n,...t}=e;return(0,s.yg)(Ia,(0,p.A)({},Pa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ra.isMDXComponent=!0;const Wa={toc:[]},Sa="wrapper";function Ba(e){let{components:n,...t}=e;return(0,s.yg)(Sa,(0,p.A)({},Wa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Ba.isMDXComponent=!0;const Ga={toc:[]},Ea="wrapper";function Oa(e){let{components:n,...t}=e;return(0,s.yg)(Ea,(0,p.A)({},Ga,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Oa.isMDXComponent=!0;const Ua={toc:[]},Fa="wrapper";function Va(e){let{components:n,...t}=e;return(0,s.yg)(Fa,(0,p.A)({},Ua,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}Va.isMDXComponent=!0;const qa={toc:[]},ja="wrapper";function Ha(e){let{components:n,...t}=e;return(0,s.yg)(ja,(0,p.A)({},qa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ha.isMDXComponent=!0;const Ya={toc:[]},Qa="wrapper";function $a(e){let{components:n,...t}=e;return(0,s.yg)(Qa,(0,p.A)({},Ya,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}$a.isMDXComponent=!0;const Ka={toc:[]},Ja="wrapper";function Za(e){let{components:n,...t}=e;return(0,s.yg)(Ja,(0,p.A)({},Ka,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Za.isMDXComponent=!0;const ei={toc:[]},ni="wrapper";function ti(e){let{components:n,...t}=e;return(0,s.yg)(ni,(0,p.A)({},ei,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value passed to subscribers."))}ti.isMDXComponent=!0;const oi={toc:[]},pi="wrapper";function ri(e){let{components:n,...t}=e;return(0,s.yg)(pi,(0,p.A)({},oi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}ri.isMDXComponent=!0;const si={toc:[]},ci="wrapper";function ai(e){let{components:n,...t}=e;return(0,s.yg)(ci,(0,p.A)({},si,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}ai.isMDXComponent=!0;const ii={toc:[]},li="wrapper";function ui(e){let{components:n,...t}=e;return(0,s.yg)(li,(0,p.A)({},ii,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}ui.isMDXComponent=!0;const mi={toc:[]},yi="wrapper";function di(e){let{components:n,...t}=e;return(0,s.yg)(yi,(0,p.A)({},mi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value."))}di.isMDXComponent=!0;const hi={toc:[]},gi="wrapper";function fi(e){let{components:n,...t}=e;return(0,s.yg)(gi,(0,p.A)({},hi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the most recent value of this dispatcher."))}fi.isMDXComponent=!0;const Di={toc:[]},Mi="wrapper";function Xi(e){let{components:n,...t}=e;return(0,s.yg)(Mi,(0,p.A)({},Di,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Setting the value will immediately notify all subscribers."))}Xi.isMDXComponent=!0;const _i={toc:[]},wi="wrapper";function Ti(e){let{components:n,...t}=e;return(0,s.yg)(wi,(0,p.A)({},_i,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value of this dispatcher."))}Ti.isMDXComponent=!0;const Ci={toc:[]},xi="wrapper";function Ai(e){let{components:n,...t}=e;return(0,s.yg)(xi,(0,p.A)({},Ci,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Ai.isMDXComponent=!0;const vi={toc:[]},Li="wrapper";function bi(e){let{components:n,...t}=e;return(0,s.yg)(Li,(0,p.A)({},vi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}bi.isMDXComponent=!0;const Ni={toc:[]},ki="wrapper";function zi(e){let{components:n,...t}=e;return(0,s.yg)(ki,(0,p.A)({},Ni,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}zi.isMDXComponent=!0;const Pi={toc:[]},Ii="wrapper";function Ri(e){let{components:n,...t}=e;return(0,s.yg)(Ii,(0,p.A)({},Pi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ri.isMDXComponent=!0;const Wi={toc:[]},Si="wrapper";function Bi(e){let{components:n,...t}=e;return(0,s.yg)(Si,(0,p.A)({},Wi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Bi.isMDXComponent=!0;const Gi={toc:[]},Ei="wrapper";function Oi(e){let{components:n,...t}=e;return(0,s.yg)(Ei,(0,p.A)({},Gi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Oi.isMDXComponent=!0;const Ui={toc:[]},Fi="wrapper";function Vi(e){let{components:n,...t}=e;return(0,s.yg)(Fi,(0,p.A)({},Ui,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Vi.isMDXComponent=!0;const qi={toc:[]},ji="wrapper";function Hi(e){let{components:n,...t}=e;return(0,s.yg)(ji,(0,p.A)({},qi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Hi.isMDXComponent=!0;const Yi={toc:[]},Qi="wrapper";function $i(e){let{components:n,...t}=e;return(0,s.yg)(Qi,(0,p.A)({},Yi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value passed to subscribers."))}$i.isMDXComponent=!0;const Ki={toc:[]},Ji="wrapper";function Zi(e){let{components:n,...t}=e;return(0,s.yg)(Ji,(0,p.A)({},Ki,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Zi.isMDXComponent=!0;const el={toc:[]},nl="wrapper";function tl(e){let{components:n,...t}=e;return(0,s.yg)(nl,(0,p.A)({},el,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}tl.isMDXComponent=!0;const ol={toc:[]},pl="wrapper";function rl(e){let{components:n,...t}=e;return(0,s.yg)(pl,(0,p.A)({},ol,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}rl.isMDXComponent=!0;const sl={toc:[]},cl="wrapper";function al(e){let{components:n,...t}=e;return(0,s.yg)(cl,(0,p.A)({},sl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}al.isMDXComponent=!0;const il={toc:[]},ll="wrapper";function ul(e){let{components:n,...t}=e;return(0,s.yg)(ll,(0,p.A)({},il,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}ul.isMDXComponent=!0;const ml={toc:[]},yl="wrapper";function dl(e){let{components:n,...t}=e;return(0,s.yg)(yl,(0,p.A)({},ml,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}dl.isMDXComponent=!0;const hl={toc:[]},gl="wrapper";function fl(e){let{components:n,...t}=e;return(0,s.yg)(gl,(0,p.A)({},hl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fl.isMDXComponent=!0;const Dl={toc:[]},Ml="wrapper";function Xl(e){let{components:n,...t}=e;return(0,s.yg)(Ml,(0,p.A)({},Dl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}Xl.isMDXComponent=!0;const _l={toc:[]},wl="wrapper";function Tl(e){let{components:n,...t}=e;return(0,s.yg)(wl,(0,p.A)({},_l,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Utilities for controlling the flow and timing of an animation."))}Tl.isMDXComponent=!0;const Cl={toc:[]},xl="wrapper";function Al(e){let{components:n,...t}=e;return(0,s.yg)(xl,(0,p.A)({},Cl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback called by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow/EveryTimer"},(0,s.yg)("inlineCode",{parentName:"a"},"EveryTimer"))," every N seconds."))}Al.isMDXComponent=!0;const vl={toc:[]},Ll="wrapper";function bl(e){let{components:n,...t}=e;return(0,s.yg)(Ll,(0,p.A)({},vl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The amount of times the timer has ticked."))}bl.isMDXComponent=!0;const Nl={toc:[]},kl="wrapper";function zl(e){let{components:n,...t}=e;return(0,s.yg)(kl,(0,p.A)({},Nl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator responsible for running this timer."))}zl.isMDXComponent=!0;const Pl={toc:[]},Il="wrapper";function Rl(e){let{components:n,...t}=e;return(0,s.yg)(Il,(0,p.A)({},Pl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait until the timer ticks."))}Rl.isMDXComponent=!0;const Wl={toc:[]},Sl="wrapper";function Bl(e){let{components:n,...t}=e;return(0,s.yg)(Sl,(0,p.A)({},Wl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback called by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#loop"},(0,s.yg)("inlineCode",{parentName:"a"},"loop"))," during each iteration."))}Bl.isMDXComponent=!0;const Gl={toc:[]},El="wrapper";function Ol(e){let{components:n,...t}=e;return(0,s.yg)(El,(0,p.A)({},Gl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current iteration index."))}Ol.isMDXComponent=!0;const Ul={toc:[]},Fl="wrapper";function Vl(e){let{components:n,...t}=e;return(0,s.yg)(Fl,(0,p.A)({},Ul,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Vl.isMDXComponent=!0;const ql={toc:[]},jl="wrapper";function Hl(e){let{components:n,...t}=e;return(0,s.yg)(jl,(0,p.A)({},ql,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Hl.isMDXComponent=!0;const Yl={toc:[]},Ql="wrapper";function $l(e){let{components:n,...t}=e;return(0,s.yg)(Ql,(0,p.A)({},Yl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}$l.isMDXComponent=!0;const Kl={toc:[]},Jl="wrapper";function Zl(e){let{components:n,...t}=e;return(0,s.yg)(Jl,(0,p.A)({},Kl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Zl.isMDXComponent=!0;const eu={toc:[]},nu="wrapper";function tu(e){let{components:n,...t}=e;return(0,s.yg)(nu,(0,p.A)({},eu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}tu.isMDXComponent=!0;const ou={toc:[]},pu="wrapper";function ru(e){let{components:n,...t}=e;return(0,s.yg)(pu,(0,p.A)({},ou,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}ru.isMDXComponent=!0;const su={toc:[]},cu="wrapper";function au(e){let{components:n,...t}=e;return(0,s.yg)(cu,(0,p.A)({},su,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.yg)("p",null,"Note that the same animation can be written as:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.yg)("p",null,"The reason ",(0,s.yg)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}au.isMDXComponent=!0;const iu={toc:[]},lu="wrapper";function uu(e){let{components:n,...t}=e;return(0,s.yg)(lu,(0,p.A)({},iu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run tasks one after another."))}uu.isMDXComponent=!0;const mu={toc:[]},yu="wrapper";function du(e){let{components:n,...t}=e;return(0,s.yg)(yu,(0,p.A)({},mu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}du.isMDXComponent=!0;const hu={toc:[]},gu="wrapper";function fu(e){let{components:n,...t}=e;return(0,s.yg)(gu,(0,p.A)({},hu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.yg)("p",null,"Note that the same animation can be written as:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.yg)("p",null,"The reason ",(0,s.yg)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}fu.isMDXComponent=!0;const Du={toc:[]},Mu="wrapper";function Xu(e){let{components:n,...t}=e;return(0,s.yg)(Mu,(0,p.A)({},Du,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator or callback after a specific amount of time."))}Xu.isMDXComponent=!0;const _u={toc:[]},wu="wrapper";function Tu(e){let{components:n,...t}=e;return(0,s.yg)(wu,(0,p.A)({},_u,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delay in seconds"))}Tu.isMDXComponent=!0;const Cu={toc:[]},xu="wrapper";function Au(e){let{components:n,...t}=e;return(0,s.yg)(xu,(0,p.A)({},Cu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task or callback to run after the delay."))}Au.isMDXComponent=!0;const vu={toc:[]},Lu="wrapper";function bu(e){let{components:n,...t}=e;return(0,s.yg)(Lu,(0,p.A)({},vu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}bu.isMDXComponent=!0;const Nu={toc:[]},ku="wrapper";function zu(e){let{components:n,...t}=e;return(0,s.yg)(ku,(0,p.A)({},Nu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Call the given callback every N seconds."))}zu.isMDXComponent=!0;const Pu={toc:[]},Iu="wrapper";function Ru(e){let{components:n,...t}=e;return(0,s.yg)(Iu,(0,p.A)({},Pu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interval between subsequent calls."))}Ru.isMDXComponent=!0;const Wu={toc:[]},Su="wrapper";function Bu(e){let{components:n,...t}=e;return(0,s.yg)(Su,(0,p.A)({},Wu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to be called."))}Bu.isMDXComponent=!0;const Gu={toc:[]},Eu="wrapper";function Ou(e){let{components:n,...t}=e;return(0,s.yg)(Eu,(0,p.A)({},Gu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each iteration waits until the previous one is completed.\nBecause this loop never finishes it cannot be used in the main thread.\nInstead, use ",(0,s.yg)("inlineCode",{parentName:"p"},"yield")," or ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," to run the loop concurrently."))}Ou.isMDXComponent=!0;const Uu={toc:[]},Fu="wrapper";function Vu(e){let{components:n,...t}=e;return(0,s.yg)(Fu,(0,p.A)({},Uu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotate the ",(0,s.yg)("inlineCode",{parentName:"p"},"rect")," indefinitely:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield loop(\n  () => rect.rotation(0).rotation(360, 2, linear),\n);\n")))}Vu.isMDXComponent=!0;const qu={toc:[]},ju="wrapper";function Hu(e){let{components:n,...t}=e;return(0,s.yg)(ju,(0,p.A)({},qu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator in a loop."))}Hu.isMDXComponent=!0;const Yu={toc:[]},Qu="wrapper";function $u(e){let{components:n,...t}=e;return(0,s.yg)(Qu,(0,p.A)({},Yu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}$u.isMDXComponent=!0;const Ku={toc:[]},Ju="wrapper";function Zu(e){let{components:n,...t}=e;return(0,s.yg)(Ju,(0,p.A)({},Ku,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each iteration waits until the previous one is completed."))}Zu.isMDXComponent=!0;const em={toc:[]},nm="wrapper";function tm(e){let{components:n,...t}=e;return(0,s.yg)(nm,(0,p.A)({},em,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}tm.isMDXComponent=!0;const om={toc:[]},pm="wrapper";function rm(e){let{components:n,...t}=e;return(0,s.yg)(pm,(0,p.A)({},om,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator N times."))}rm.isMDXComponent=!0;const sm={toc:[]},cm="wrapper";function am(e){let{components:n,...t}=e;return(0,s.yg)(cm,(0,p.A)({},sm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of iterations."))}am.isMDXComponent=!0;const im={toc:[]},lm="wrapper";function um(e){let{components:n,...t}=e;return(0,s.yg)(lm,(0,p.A)({},im,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}um.isMDXComponent=!0;const mm={toc:[]},ym="wrapper";function dm(e){let{components:n,...t}=e;return(0,s.yg)(ym,(0,p.A)({},mm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}dm.isMDXComponent=!0;const hm={toc:[]},gm="wrapper";function fm(e){let{components:n,...t}=e;return(0,s.yg)(gm,(0,p.A)({},hm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}fm.isMDXComponent=!0;const Dm={toc:[]},Mm="wrapper";function Xm(e){let{components:n,...t}=e;return(0,s.yg)(Mm,(0,p.A)({},Dm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run a generator in a loop for the given amount of time."))}Xm.isMDXComponent=!0;const _m={toc:[]},wm="wrapper";function Tm(e){let{components:n,...t}=e;return(0,s.yg)(wm,(0,p.A)({},_m,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration in seconds."))}Tm.isMDXComponent=!0;const Cm={toc:[]},xm="wrapper";function Am(e){let{components:n,...t}=e;return(0,s.yg)(xm,(0,p.A)({},Cm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Am.isMDXComponent=!0;const vm={toc:[]},Lm="wrapper";function bm(e){let{components:n,...t}=e;return(0,s.yg)(Lm,(0,p.A)({},vm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}bm.isMDXComponent=!0;const Nm={toc:[]},km="wrapper";function zm(e){let{components:n,...t}=e;return(0,s.yg)(km,(0,p.A)({},Nm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}zm.isMDXComponent=!0;const Pm={toc:[]},Im="wrapper";function Rm(e){let{components:n,...t}=e;return(0,s.yg)(Im,(0,p.A)({},Pm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run a generator in a loop until the given time event."))}Rm.isMDXComponent=!0;const Wm={toc:[]},Sm="wrapper";function Bm(e){let{components:n,...t}=e;return(0,s.yg)(Sm,(0,p.A)({},Wm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The event."))}Bm.isMDXComponent=!0;const Gm={toc:[]},Em="wrapper";function Om(e){let{components:n,...t}=e;return(0,s.yg)(Em,(0,p.A)({},Gm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Om.isMDXComponent=!0;const Um={toc:[]},Fm="wrapper";function Vm(e){let{components:n,...t}=e;return(0,s.yg)(Fm,(0,p.A)({},Um,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Do nothing."))}Vm.isMDXComponent=!0;const qm={toc:[]},jm="wrapper";function Hm(e){let{components:n,...t}=e;return(0,s.yg)(jm,(0,p.A)({},qm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}Hm.isMDXComponent=!0;const Ym={toc:[]},Qm="wrapper";function $m(e){let{components:n,...t}=e;return(0,s.yg)(Qm,(0,p.A)({},Ym,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}$m.isMDXComponent=!0;const Km={toc:[]},Jm="wrapper";function Zm(e){let{components:n,...t}=e;return(0,s.yg)(Jm,(0,p.A)({},Km,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Turn the given generator function into a task."))}Zm.isMDXComponent=!0;const ey={toc:[]},ny="wrapper";function ty(e){let{components:n,...t}=e;return(0,s.yg)(ny,(0,p.A)({},ey,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a factory that creates the generator."))}ty.isMDXComponent=!0;const oy={toc:[]},py="wrapper";function ry(e){let{components:n,...t}=e;return(0,s.yg)(py,(0,p.A)({},oy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}ry.isMDXComponent=!0;const sy={toc:[]},cy="wrapper";function ay(e){let{components:n,...t}=e;return(0,s.yg)(cy,(0,p.A)({},sy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}ay.isMDXComponent=!0;const iy={toc:[]},ly="wrapper";function uy(e){let{components:n,...t}=e;return(0,s.yg)(ly,(0,p.A)({},iy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Turn the given generator function into a task."))}uy.isMDXComponent=!0;const my={toc:[]},yy="wrapper";function dy(e){let{components:n,...t}=e;return(0,s.yg)(yy,(0,p.A)({},my,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional name used when displaying this generator in the UI."))}dy.isMDXComponent=!0;const hy={toc:[]},gy="wrapper";function fy(e){let{components:n,...t}=e;return(0,s.yg)(gy,(0,p.A)({},hy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a factory that creates the generator."))}fy.isMDXComponent=!0;const Dy={toc:[]},My="wrapper";function Xy(e){let{components:n,...t}=e;return(0,s.yg)(My,(0,p.A)({},Dy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Xy.isMDXComponent=!0;const _y={toc:[]},wy="wrapper";function Ty(e){let{components:n,...t}=e;return(0,s.yg)(wy,(0,p.A)({},_y,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ty.isMDXComponent=!0;const Cy={toc:[]},xy="wrapper";function Ay(e){let{components:n,...t}=e;return(0,s.yg)(xy,(0,p.A)({},Cy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Start all tasks one after another with a constant delay between."))}Ay.isMDXComponent=!0;const vy={toc:[]},Ly="wrapper";function by(e){let{components:n,...t}=e;return(0,s.yg)(Ly,(0,p.A)({},vy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delay between each of the tasks."))}by.isMDXComponent=!0;const Ny={toc:[]},ky="wrapper";function zy(e){let{components:n,...t}=e;return(0,s.yg)(ky,(0,p.A)({},Ny,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to be run in a sequence."))}zy.isMDXComponent=!0;const Py={toc:[]},Iy="wrapper";function Ry(e){let{components:n,...t}=e;return(0,s.yg)(Iy,(0,p.A)({},Py,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Ry.isMDXComponent=!0;const Wy={toc:[]},Sy="wrapper";function By(e){let{components:n,...t}=e;return(0,s.yg)(Sy,(0,p.A)({},Wy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for the given amount of time."))}By.isMDXComponent=!0;const Gy={toc:[]},Ey="wrapper";function Oy(e){let{components:n,...t}=e;return(0,s.yg)(Ey,(0,p.A)({},Gy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The relative time in seconds."))}Oy.isMDXComponent=!0;const Uy={toc:[]},Fy="wrapper";function Vy(e){let{components:n,...t}=e;return(0,s.yg)(Fy,(0,p.A)({},Uy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional task to be run after the function completes."))}Vy.isMDXComponent=!0;const qy={toc:[]},jy="wrapper";function Hy(e){let{components:n,...t}=e;return(0,s.yg)(jy,(0,p.A)({},qy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}Hy.isMDXComponent=!0;const Yy={toc:[]},Qy="wrapper";function $y(e){let{components:n,...t}=e;return(0,s.yg)(Qy,(0,p.A)({},Yy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}$y.isMDXComponent=!0;const Ky={toc:[]},Jy="wrapper";function Zy(e){let{components:n,...t}=e;return(0,s.yg)(Jy,(0,p.A)({},Ky,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait until the given time event."))}Zy.isMDXComponent=!0;const ed={toc:[]},nd="wrapper";function td(e){let{components:n,...t}=e;return(0,s.yg)(nd,(0,p.A)({},ed,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the time event."))}td.isMDXComponent=!0;const od={toc:[]},pd="wrapper";function rd(e){let{components:n,...t}=e;return(0,s.yg)(pd,(0,p.A)({},od,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional task to be run after the function completes."))}rd.isMDXComponent=!0;const sd={toc:[]},cd="wrapper";function ad(e){let{components:n,...t}=e;return(0,s.yg)(cd,(0,p.A)({},sd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Multi-media management."))}ad.isMDXComponent=!0;const id={toc:[]},ld="wrapper";function ud(e){let{components:n,...t}=e;return(0,s.yg)(ld,(0,p.A)({},id,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}ud.isMDXComponent=!0;const md={toc:[]},yd="wrapper";function dd(e){let{components:n,...t}=e;return(0,s.yg)(yd,(0,p.A)({},md,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause/resume the audio."))}dd.isMDXComponent=!0;const hd={toc:[]},gd="wrapper";function fd(e){let{components:n,...t}=e;return(0,s.yg)(gd,(0,p.A)({},hd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the audio should be paused or resumed."))}fd.isMDXComponent=!0;const Dd={toc:[]},Md="wrapper";function Xd(e){let{components:n,...t}=e;return(0,s.yg)(Md,(0,p.A)({},Dd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The absolute biggest value from the peaks array."))}Xd.isMDXComponent=!0;const _d={toc:[]},wd="wrapper";function Td(e){let{components:n,...t}=e;return(0,s.yg)(wd,(0,p.A)({},_d,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The amount of samples taken."))}Td.isMDXComponent=!0;const Cd={toc:[]},xd="wrapper";function Ad(e){let{components:n,...t}=e;return(0,s.yg)(xd,(0,p.A)({},Cd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Ad.isMDXComponent=!0;const vd={toc:[]},Ld="wrapper";function bd(e){let{components:n,...t}=e;return(0,s.yg)(Ld,(0,p.A)({},vd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Samples per seconds."))}bd.isMDXComponent=!0;const Nd={toc:[]},kd="wrapper";function zd(e){let{components:n,...t}=e;return(0,s.yg)(kd,(0,p.A)({},Nd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The runtime representation of meta files."))}zd.isMDXComponent=!0;const Pd={toc:[]},Id="wrapper";function Rd(e){let{components:n,...t}=e;return(0,s.yg)(Id,(0,p.A)({},Pd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a boolean value stored in a meta file."))}Rd.isMDXComponent=!0;const Wd={toc:[]},Sd="wrapper";function Bd(e){let{components:n,...t}=e;return(0,s.yg)(Sd,(0,p.A)({},Wd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Bd.isMDXComponent=!0;const Gd={toc:[]},Ed="wrapper";function Od(e){let{components:n,...t}=e;return(0,s.yg)(Ed,(0,p.A)({},Gd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Od.isMDXComponent=!0;const Ud={toc:[]},Fd="wrapper";function Vd(e){let{components:n,...t}=e;return(0,s.yg)(Fd,(0,p.A)({},Ud,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Vd.isMDXComponent=!0;const qd={toc:[]},jd="wrapper";function Hd(e){let{components:n,...t}=e;return(0,s.yg)(jd,(0,p.A)({},qd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Hd.isMDXComponent=!0;const Yd={toc:[]},Qd="wrapper";function $d(e){let{components:n,...t}=e;return(0,s.yg)(Qd,(0,p.A)({},Yd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}$d.isMDXComponent=!0;const Kd={toc:[]},Jd="wrapper";function Zd(e){let{components:n,...t}=e;return(0,s.yg)(Jd,(0,p.A)({},Kd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}Zd.isMDXComponent=!0;const eh={toc:[]},nh="wrapper";function th(e){let{components:n,...t}=e;return(0,s.yg)(nh,(0,p.A)({},eh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}th.isMDXComponent=!0;const oh={toc:[]},ph="wrapper";function rh(e){let{components:n,...t}=e;return(0,s.yg)(ph,(0,p.A)({},oh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}rh.isMDXComponent=!0;const sh={toc:[]},ch="wrapper";function ah(e){let{components:n,...t}=e;return(0,s.yg)(ch,(0,p.A)({},sh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}ah.isMDXComponent=!0;const ih={toc:[]},lh="wrapper";function uh(e){let{components:n,...t}=e;return(0,s.yg)(lh,(0,p.A)({},ih,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}uh.isMDXComponent=!0;const mh={toc:[]},yh="wrapper";function dh(e){let{components:n,...t}=e;return(0,s.yg)(yh,(0,p.A)({},mh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}dh.isMDXComponent=!0;const hh={toc:[]},gh="wrapper";function fh(e){let{components:n,...t}=e;return(0,s.yg)(gh,(0,p.A)({},hh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}fh.isMDXComponent=!0;const Dh={toc:[]},Mh="wrapper";function Xh(e){let{components:n,...t}=e;return(0,s.yg)(Mh,(0,p.A)({},Dh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}Xh.isMDXComponent=!0;const _h={toc:[]},wh="wrapper";function Th(e){let{components:n,...t}=e;return(0,s.yg)(wh,(0,p.A)({},_h,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Th.isMDXComponent=!0;const Ch={toc:[]},xh="wrapper";function Ah(e){let{components:n,...t}=e;return(0,s.yg)(xh,(0,p.A)({},Ch,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Ah.isMDXComponent=!0;const vh={toc:[]},Lh="wrapper";function bh(e){let{components:n,...t}=e;return(0,s.yg)(Lh,(0,p.A)({},vh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}bh.isMDXComponent=!0;const Nh={toc:[]},kh="wrapper";function zh(e){let{components:n,...t}=e;return(0,s.yg)(kh,(0,p.A)({},Nh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}zh.isMDXComponent=!0;const Ph={toc:[]},Ih="wrapper";function Rh(e){let{components:n,...t}=e;return(0,s.yg)(Ih,(0,p.A)({},Ph,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Rh.isMDXComponent=!0;const Wh={toc:[]},Sh="wrapper";function Bh(e){let{components:n,...t}=e;return(0,s.yg)(Sh,(0,p.A)({},Wh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Bh.isMDXComponent=!0;const Gh={toc:[]},Eh="wrapper";function Oh(e){let{components:n,...t}=e;return(0,s.yg)(Eh,(0,p.A)({},Gh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Oh.isMDXComponent=!0;const Uh={toc:[]},Fh="wrapper";function Vh(e){let{components:n,...t}=e;return(0,s.yg)(Fh,(0,p.A)({},Uh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a color stored in a meta file."))}Vh.isMDXComponent=!0;const qh={toc:[]},jh="wrapper";function Hh(e){let{components:n,...t}=e;return(0,s.yg)(jh,(0,p.A)({},qh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Hh.isMDXComponent=!0;const Yh={toc:[]},Qh="wrapper";function $h(e){let{components:n,...t}=e;return(0,s.yg)(Qh,(0,p.A)({},Yh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}$h.isMDXComponent=!0;const Kh={toc:[]},Jh="wrapper";function Zh(e){let{components:n,...t}=e;return(0,s.yg)(Jh,(0,p.A)({},Kh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Zh.isMDXComponent=!0;const eg={toc:[]},ng="wrapper";function tg(e){let{components:n,...t}=e;return(0,s.yg)(ng,(0,p.A)({},eg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}tg.isMDXComponent=!0;const og={toc:[]},pg="wrapper";function rg(e){let{components:n,...t}=e;return(0,s.yg)(pg,(0,p.A)({},og,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}rg.isMDXComponent=!0;const sg={toc:[]},cg="wrapper";function ag(e){let{components:n,...t}=e;return(0,s.yg)(cg,(0,p.A)({},sg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}ag.isMDXComponent=!0;const ig={toc:[]},lg="wrapper";function ug(e){let{components:n,...t}=e;return(0,s.yg)(lg,(0,p.A)({},ig,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}ug.isMDXComponent=!0;const mg={toc:[]},yg="wrapper";function dg(e){let{components:n,...t}=e;return(0,s.yg)(yg,(0,p.A)({},mg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}dg.isMDXComponent=!0;const hg={toc:[]},gg="wrapper";function fg(e){let{components:n,...t}=e;return(0,s.yg)(gg,(0,p.A)({},hg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}fg.isMDXComponent=!0;const Dg={toc:[]},Mg="wrapper";function Xg(e){let{components:n,...t}=e;return(0,s.yg)(Mg,(0,p.A)({},Dg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}Xg.isMDXComponent=!0;const _g={toc:[]},wg="wrapper";function Tg(e){let{components:n,...t}=e;return(0,s.yg)(wg,(0,p.A)({},_g,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}Tg.isMDXComponent=!0;const Cg={toc:[]},xg="wrapper";function Ag(e){let{components:n,...t}=e;return(0,s.yg)(xg,(0,p.A)({},Cg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Ag.isMDXComponent=!0;const vg={toc:[]},Lg="wrapper";function bg(e){let{components:n,...t}=e;return(0,s.yg)(Lg,(0,p.A)({},vg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}bg.isMDXComponent=!0;const Ng={toc:[]},kg="wrapper";function zg(e){let{components:n,...t}=e;return(0,s.yg)(kg,(0,p.A)({},Ng,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}zg.isMDXComponent=!0;const Pg={toc:[]},Ig="wrapper";function Rg(e){let{components:n,...t}=e;return(0,s.yg)(Ig,(0,p.A)({},Pg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Rg.isMDXComponent=!0;const Wg={toc:[]},Sg="wrapper";function Bg(e){let{components:n,...t}=e;return(0,s.yg)(Sg,(0,p.A)({},Wg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}Bg.isMDXComponent=!0;const Gg={toc:[]},Eg="wrapper";function Og(e){let{components:n,...t}=e;return(0,s.yg)(Eg,(0,p.A)({},Gg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Og.isMDXComponent=!0;const Ug={toc:[]},Fg="wrapper";function Vg(e){let{components:n,...t}=e;return(0,s.yg)(Fg,(0,p.A)({},Ug,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Vg.isMDXComponent=!0;const qg={toc:[]},jg="wrapper";function Hg(e){let{components:n,...t}=e;return(0,s.yg)(jg,(0,p.A)({},qg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Hg.isMDXComponent=!0;const Yg={toc:[]},Qg="wrapper";function $g(e){let{components:n,...t}=e;return(0,s.yg)(Qg,(0,p.A)({},Yg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}$g.isMDXComponent=!0;const Kg={toc:[]},Jg="wrapper";function Zg(e){let{components:n,...t}=e;return(0,s.yg)(Jg,(0,p.A)({},Kg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an enum value stored in a meta file."))}Zg.isMDXComponent=!0;const ef={toc:[]},nf="wrapper";function tf(e){let{components:n,...t}=e;return(0,s.yg)(nf,(0,p.A)({},ef,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}tf.isMDXComponent=!0;const of={toc:[]},pf="wrapper";function rf(e){let{components:n,...t}=e;return(0,s.yg)(pf,(0,p.A)({},of,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}rf.isMDXComponent=!0;const sf={toc:[]},cf="wrapper";function af(e){let{components:n,...t}=e;return(0,s.yg)(cf,(0,p.A)({},sf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}af.isMDXComponent=!0;const lf={toc:[]},uf="wrapper";function mf(e){let{components:n,...t}=e;return(0,s.yg)(uf,(0,p.A)({},lf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}mf.isMDXComponent=!0;const yf={toc:[]},df="wrapper";function hf(e){let{components:n,...t}=e;return(0,s.yg)(df,(0,p.A)({},yf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}hf.isMDXComponent=!0;const gf={toc:[]},ff="wrapper";function Df(e){let{components:n,...t}=e;return(0,s.yg)(ff,(0,p.A)({},gf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}Df.isMDXComponent=!0;const Mf={toc:[]},Xf="wrapper";function _f(e){let{components:n,...t}=e;return(0,s.yg)(Xf,(0,p.A)({},Mf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}_f.isMDXComponent=!0;const wf={toc:[]},Tf="wrapper";function Cf(e){let{components:n,...t}=e;return(0,s.yg)(Tf,(0,p.A)({},wf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}Cf.isMDXComponent=!0;const xf={toc:[]},Af="wrapper";function vf(e){let{components:n,...t}=e;return(0,s.yg)(Af,(0,p.A)({},xf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}vf.isMDXComponent=!0;const Lf={toc:[]},bf="wrapper";function Nf(e){let{components:n,...t}=e;return(0,s.yg)(bf,(0,p.A)({},Lf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Nf.isMDXComponent=!0;const kf={toc:[]},zf="wrapper";function Pf(e){let{components:n,...t}=e;return(0,s.yg)(zf,(0,p.A)({},kf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}Pf.isMDXComponent=!0;const If={toc:[]},Rf="wrapper";function Wf(e){let{components:n,...t}=e;return(0,s.yg)(Rf,(0,p.A)({},If,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Wf.isMDXComponent=!0;const Sf={toc:[]},Bf="wrapper";function Gf(e){let{components:n,...t}=e;return(0,s.yg)(Bf,(0,p.A)({},Sf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Gf.isMDXComponent=!0;const Ef={toc:[]},Of="wrapper";function Uf(e){let{components:n,...t}=e;return(0,s.yg)(Of,(0,p.A)({},Ef,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}Uf.isMDXComponent=!0;const Ff={toc:[]},Vf="wrapper";function qf(e){let{components:n,...t}=e;return(0,s.yg)(Vf,(0,p.A)({},Ff,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}qf.isMDXComponent=!0;const jf={toc:[]},Hf="wrapper";function Yf(e){let{components:n,...t}=e;return(0,s.yg)(Hf,(0,p.A)({},jf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Yf.isMDXComponent=!0;const Qf={toc:[]},$f="wrapper";function Kf(e){let{components:n,...t}=e;return(0,s.yg)($f,(0,p.A)({},Qf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Kf.isMDXComponent=!0;const Jf={toc:[]},Zf="wrapper";function eD(e){let{components:n,...t}=e;return(0,s.yg)(Zf,(0,p.A)({},Jf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}eD.isMDXComponent=!0;const nD={toc:[]},tD="wrapper";function oD(e){let{components:n,...t}=e;return(0,s.yg)(tD,(0,p.A)({},nD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the exporter configuration."))}oD.isMDXComponent=!0;const pD={toc:[]},rD="wrapper";function sD(e){let{components:n,...t}=e;return(0,s.yg)(rD,(0,p.A)({},pD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}sD.isMDXComponent=!0;const cD={toc:[]},aD="wrapper";function iD(e){let{components:n,...t}=e;return(0,s.yg)(aD,(0,p.A)({},cD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}iD.isMDXComponent=!0;const lD={toc:[]},uD="wrapper";function mD(e){let{components:n,...t}=e;return(0,s.yg)(uD,(0,p.A)({},lD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}mD.isMDXComponent=!0;const yD={toc:[]},dD="wrapper";function hD(e){let{components:n,...t}=e;return(0,s.yg)(dD,(0,p.A)({},yD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}hD.isMDXComponent=!0;const gD={toc:[]},fD="wrapper";function DD(e){let{components:n,...t}=e;return(0,s.yg)(fD,(0,p.A)({},gD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}DD.isMDXComponent=!0;const MD={toc:[]},XD="wrapper";function _D(e){let{components:n,...t}=e;return(0,s.yg)(XD,(0,p.A)({},MD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the nested fields change."))}_D.isMDXComponent=!0;const wD={toc:[]},TD="wrapper";function CD(e){let{components:n,...t}=e;return(0,s.yg)(TD,(0,p.A)({},wD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}CD.isMDXComponent=!0;const xD={toc:[]},AD="wrapper";function vD(e){let{components:n,...t}=e;return(0,s.yg)(AD,(0,p.A)({},xD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}vD.isMDXComponent=!0;const LD={toc:[]},bD="wrapper";function ND(e){let{components:n,...t}=e;return(0,s.yg)(bD,(0,p.A)({},LD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}ND.isMDXComponent=!0;const kD={toc:[]},zD="wrapper";function PD(e){let{components:n,...t}=e;return(0,s.yg)(zD,(0,p.A)({},kD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}PD.isMDXComponent=!0;const ID={toc:[]},RD="wrapper";function WD(e){let{components:n,...t}=e;return(0,s.yg)(RD,(0,p.A)({},ID,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}WD.isMDXComponent=!0;const SD={toc:[]},BD="wrapper";function GD(e){let{components:n,...t}=e;return(0,s.yg)(BD,(0,p.A)({},SD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}GD.isMDXComponent=!0;const ED={toc:[]},OD="wrapper";function UD(e){let{components:n,...t}=e;return(0,s.yg)(OD,(0,p.A)({},ED,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}UD.isMDXComponent=!0;const FD={toc:[]},VD="wrapper";function qD(e){let{components:n,...t}=e;return(0,s.yg)(VD,(0,p.A)({},FD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}qD.isMDXComponent=!0;const jD={toc:[]},HD="wrapper";function YD(e){let{components:n,...t}=e;return(0,s.yg)(HD,(0,p.A)({},jD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}YD.isMDXComponent=!0;const QD={toc:[]},$D="wrapper";function KD(e){let{components:n,...t}=e;return(0,s.yg)($D,(0,p.A)({},QD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}KD.isMDXComponent=!0;const JD={toc:[]},ZD="wrapper";function eM(e){let{components:n,...t}=e;return(0,s.yg)(ZD,(0,p.A)({},JD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}eM.isMDXComponent=!0;const nM={toc:[]},tM="wrapper";function oM(e){let{components:n,...t}=e;return(0,s.yg)(tM,(0,p.A)({},nM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}oM.isMDXComponent=!0;const pM={toc:[]},rM="wrapper";function sM(e){let{components:n,...t}=e;return(0,s.yg)(rM,(0,p.A)({},pM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}sM.isMDXComponent=!0;const cM={toc:[]},aM="wrapper";function iM(e){let{components:n,...t}=e;return(0,s.yg)(aM,(0,p.A)({},cM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an entry in the meta file."))}iM.isMDXComponent=!0;const lM={toc:[]},uM="wrapper";function mM(e){let{components:n,...t}=e;return(0,s.yg)(uM,(0,p.A)({},lM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}mM.isMDXComponent=!0;const yM={toc:[]},dM="wrapper";function hM(e){let{components:n,...t}=e;return(0,s.yg)(dM,(0,p.A)({},yM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}hM.isMDXComponent=!0;const gM={toc:[]},fM="wrapper";function DM(e){let{components:n,...t}=e;return(0,s.yg)(fM,(0,p.A)({},gM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}DM.isMDXComponent=!0;const MM={toc:[]},XM="wrapper";function _M(e){let{components:n,...t}=e;return(0,s.yg)(XM,(0,p.A)({},MM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}_M.isMDXComponent=!0;const wM={toc:[]},TM="wrapper";function CM(e){let{components:n,...t}=e;return(0,s.yg)(TM,(0,p.A)({},wM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}CM.isMDXComponent=!0;const xM={toc:[]},AM="wrapper";function vM(e){let{components:n,...t}=e;return(0,s.yg)(AM,(0,p.A)({},xM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}vM.isMDXComponent=!0;const LM={toc:[]},bM="wrapper";function NM(e){let{components:n,...t}=e;return(0,s.yg)(bM,(0,p.A)({},LM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}NM.isMDXComponent=!0;const kM={toc:[]},zM="wrapper";function PM(e){let{components:n,...t}=e;return(0,s.yg)(zM,(0,p.A)({},kM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}PM.isMDXComponent=!0;const IM={toc:[]},RM="wrapper";function WM(e){let{components:n,...t}=e;return(0,s.yg)(RM,(0,p.A)({},IM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}WM.isMDXComponent=!0;const SM={toc:[]},BM="wrapper";function GM(e){let{components:n,...t}=e;return(0,s.yg)(BM,(0,p.A)({},SM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}GM.isMDXComponent=!0;const EM={toc:[]},OM="wrapper";function UM(e){let{components:n,...t}=e;return(0,s.yg)(OM,(0,p.A)({},EM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}UM.isMDXComponent=!0;const FM={toc:[]},VM="wrapper";function qM(e){let{components:n,...t}=e;return(0,s.yg)(VM,(0,p.A)({},FM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}qM.isMDXComponent=!0;const jM={toc:[]},HM="wrapper";function YM(e){let{components:n,...t}=e;return(0,s.yg)(HM,(0,p.A)({},jM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}YM.isMDXComponent=!0;const QM={toc:[]},$M="wrapper";function KM(e){let{components:n,...t}=e;return(0,s.yg)($M,(0,p.A)({},QM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}KM.isMDXComponent=!0;const JM={toc:[]},ZM="wrapper";function eX(e){let{components:n,...t}=e;return(0,s.yg)(ZM,(0,p.A)({},JM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}eX.isMDXComponent=!0;const nX={toc:[]},tX="wrapper";function oX(e){let{components:n,...t}=e;return(0,s.yg)(tX,(0,p.A)({},nX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}oX.isMDXComponent=!0;const pX={toc:[]},rX="wrapper";function sX(e){let{components:n,...t}=e;return(0,s.yg)(rX,(0,p.A)({},pX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}sX.isMDXComponent=!0;const cX={toc:[]},aX="wrapper";function iX(e){let{components:n,...t}=e;return(0,s.yg)(aX,(0,p.A)({},cX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}iX.isMDXComponent=!0;const lX={toc:[]},uX="wrapper";function mX(e){let{components:n,...t}=e;return(0,s.yg)(uX,(0,p.A)({},lX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}mX.isMDXComponent=!0;const yX={toc:[]},dX="wrapper";function hX(e){let{components:n,...t}=e;return(0,s.yg)(dX,(0,p.A)({},yX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}hX.isMDXComponent=!0;const gX={toc:[]},fX="wrapper";function DX(e){let{components:n,...t}=e;return(0,s.yg)(fX,(0,p.A)({},gX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type used to store this field in the meta\nfile."))}DX.isMDXComponent=!0;const MX={toc:[]},XX="wrapper";function _X(e){let{components:n,...t}=e;return(0,s.yg)(XX,(0,p.A)({},MX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The runtime type of this field."))}_X.isMDXComponent=!0;const wX={toc:[]},TX="wrapper";function CX(e){let{components:n,...t}=e;return(0,s.yg)(TX,(0,p.A)({},wX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a number stored in a meta file."))}CX.isMDXComponent=!0;const xX={toc:[]},AX="wrapper";function vX(e){let{components:n,...t}=e;return(0,s.yg)(AX,(0,p.A)({},xX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}vX.isMDXComponent=!0;const LX={toc:[]},bX="wrapper";function NX(e){let{components:n,...t}=e;return(0,s.yg)(bX,(0,p.A)({},LX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}NX.isMDXComponent=!0;const kX={toc:[]},zX="wrapper";function PX(e){let{components:n,...t}=e;return(0,s.yg)(zX,(0,p.A)({},kX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}PX.isMDXComponent=!0;const IX={toc:[]},RX="wrapper";function WX(e){let{components:n,...t}=e;return(0,s.yg)(RX,(0,p.A)({},IX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}WX.isMDXComponent=!0;const SX={toc:[]},BX="wrapper";function GX(e){let{components:n,...t}=e;return(0,s.yg)(BX,(0,p.A)({},SX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}GX.isMDXComponent=!0;const EX={toc:[]},OX="wrapper";function UX(e){let{components:n,...t}=e;return(0,s.yg)(OX,(0,p.A)({},EX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}UX.isMDXComponent=!0;const FX={toc:[]},VX="wrapper";function qX(e){let{components:n,...t}=e;return(0,s.yg)(VX,(0,p.A)({},FX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}qX.isMDXComponent=!0;const jX={toc:[]},HX="wrapper";function YX(e){let{components:n,...t}=e;return(0,s.yg)(HX,(0,p.A)({},jX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}YX.isMDXComponent=!0;const QX={toc:[]},$X="wrapper";function KX(e){let{components:n,...t}=e;return(0,s.yg)($X,(0,p.A)({},QX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}KX.isMDXComponent=!0;const JX={toc:[]},ZX="wrapper";function e_(e){let{components:n,...t}=e;return(0,s.yg)(ZX,(0,p.A)({},JX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}e_.isMDXComponent=!0;const n_={toc:[]},t_="wrapper";function o_(e){let{components:n,...t}=e;return(0,s.yg)(t_,(0,p.A)({},n_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}o_.isMDXComponent=!0;const p_={toc:[]},r_="wrapper";function s_(e){let{components:n,...t}=e;return(0,s.yg)(r_,(0,p.A)({},p_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}s_.isMDXComponent=!0;const c_={toc:[]},a_="wrapper";function i_(e){let{components:n,...t}=e;return(0,s.yg)(a_,(0,p.A)({},c_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}i_.isMDXComponent=!0;const l_={toc:[]},u_="wrapper";function m_(e){let{components:n,...t}=e;return(0,s.yg)(u_,(0,p.A)({},l_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}m_.isMDXComponent=!0;const y_={toc:[]},d_="wrapper";function h_(e){let{components:n,...t}=e;return(0,s.yg)(d_,(0,p.A)({},y_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}h_.isMDXComponent=!0;const g_={toc:[]},f_="wrapper";function D_(e){let{components:n,...t}=e;return(0,s.yg)(f_,(0,p.A)({},g_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}D_.isMDXComponent=!0;const M_={toc:[]},X_="wrapper";function __(e){let{components:n,...t}=e;return(0,s.yg)(X_,(0,p.A)({},M_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}__.isMDXComponent=!0;const w_={toc:[]},T_="wrapper";function C_(e){let{components:n,...t}=e;return(0,s.yg)(T_,(0,p.A)({},w_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}C_.isMDXComponent=!0;const x_={toc:[]},A_="wrapper";function v_(e){let{components:n,...t}=e;return(0,s.yg)(A_,(0,p.A)({},x_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}v_.isMDXComponent=!0;const L_={toc:[]},b_="wrapper";function N_(e){let{components:n,...t}=e;return(0,s.yg)(b_,(0,p.A)({},L_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}N_.isMDXComponent=!0;const k_={toc:[]},z_="wrapper";function P_(e){let{components:n,...t}=e;return(0,s.yg)(z_,(0,p.A)({},k_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}P_.isMDXComponent=!0;const I_={toc:[]},R_="wrapper";function W_(e){let{components:n,...t}=e;return(0,s.yg)(R_,(0,p.A)({},I_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a range stored in a meta file."))}W_.isMDXComponent=!0;const S_={toc:[]},B_="wrapper";function G_(e){let{components:n,...t}=e;return(0,s.yg)(B_,(0,p.A)({},S_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}G_.isMDXComponent=!0;const E_={toc:[]},O_="wrapper";function U_(e){let{components:n,...t}=e;return(0,s.yg)(O_,(0,p.A)({},E_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}U_.isMDXComponent=!0;const F_={toc:[]},V_="wrapper";function q_(e){let{components:n,...t}=e;return(0,s.yg)(V_,(0,p.A)({},F_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}q_.isMDXComponent=!0;const j_={toc:[]},H_="wrapper";function Y_(e){let{components:n,...t}=e;return(0,s.yg)(H_,(0,p.A)({},j_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Y_.isMDXComponent=!0;const Q_={toc:[]},$_="wrapper";function K_(e){let{components:n,...t}=e;return(0,s.yg)($_,(0,p.A)({},Q_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}K_.isMDXComponent=!0;const J_={toc:[]},Z_="wrapper";function ew(e){let{components:n,...t}=e;return(0,s.yg)(Z_,(0,p.A)({},J_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}ew.isMDXComponent=!0;const nw={toc:[]},tw="wrapper";function ow(e){let{components:n,...t}=e;return(0,s.yg)(tw,(0,p.A)({},nw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}ow.isMDXComponent=!0;const pw={toc:[]},rw="wrapper";function sw(e){let{components:n,...t}=e;return(0,s.yg)(rw,(0,p.A)({},pw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}sw.isMDXComponent=!0;const cw={toc:[]},aw="wrapper";function iw(e){let{components:n,...t}=e;return(0,s.yg)(aw,(0,p.A)({},cw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}iw.isMDXComponent=!0;const lw={toc:[]},uw="wrapper";function mw(e){let{components:n,...t}=e;return(0,s.yg)(uw,(0,p.A)({},lw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}mw.isMDXComponent=!0;const yw={toc:[]},dw="wrapper";function hw(e){let{components:n,...t}=e;return(0,s.yg)(dw,(0,p.A)({},yw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}hw.isMDXComponent=!0;const gw={toc:[]},fw="wrapper";function Dw(e){let{components:n,...t}=e;return(0,s.yg)(fw,(0,p.A)({},gw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Dw.isMDXComponent=!0;const Mw={toc:[]},Xw="wrapper";function _w(e){let{components:n,...t}=e;return(0,s.yg)(Xw,(0,p.A)({},Mw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}_w.isMDXComponent=!0;const ww={toc:[]},Tw="wrapper";function Cw(e){let{components:n,...t}=e;return(0,s.yg)(Tw,(0,p.A)({},ww,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Cw.isMDXComponent=!0;const xw={toc:[]},Aw="wrapper";function vw(e){let{components:n,...t}=e;return(0,s.yg)(Aw,(0,p.A)({},xw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}vw.isMDXComponent=!0;const Lw={toc:[]},bw="wrapper";function Nw(e){let{components:n,...t}=e;return(0,s.yg)(bw,(0,p.A)({},Lw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}Nw.isMDXComponent=!0;const kw={toc:[]},zw="wrapper";function Pw(e){let{components:n,...t}=e;return(0,s.yg)(zw,(0,p.A)({},kw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Pw.isMDXComponent=!0;const Iw={toc:[]},Rw="wrapper";function Ww(e){let{components:n,...t}=e;return(0,s.yg)(Rw,(0,p.A)({},Iw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Ww.isMDXComponent=!0;const Sw={toc:[]},Bw="wrapper";function Gw(e){let{components:n,...t}=e;return(0,s.yg)(Bw,(0,p.A)({},Sw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Gw.isMDXComponent=!0;const Ew={toc:[]},Ow="wrapper";function Uw(e){let{components:n,...t}=e;return(0,s.yg)(Ow,(0,p.A)({},Ew,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Uw.isMDXComponent=!0;const Fw={toc:[]},Vw="wrapper";function qw(e){let{components:n,...t}=e;return(0,s.yg)(Vw,(0,p.A)({},Fw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}qw.isMDXComponent=!0;const jw={toc:[]},Hw="wrapper";function Yw(e){let{components:n,...t}=e;return(0,s.yg)(Hw,(0,p.A)({},jw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert the given range from frames to seconds and update this field."))}Yw.isMDXComponent=!0;const Qw={toc:[]},$w="wrapper";function Kw(e){let{components:n,...t}=e;return(0,s.yg)($w,(0,p.A)({},Qw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The beginning of the range."))}Kw.isMDXComponent=!0;const Jw={toc:[]},Zw="wrapper";function eT(e){let{components:n,...t}=e;return(0,s.yg)(Zw,(0,p.A)({},Jw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}eT.isMDXComponent=!0;const nT={toc:[]},tT="wrapper";function oT(e){let{components:n,...t}=e;return(0,s.yg)(tT,(0,p.A)({},nT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current duration in frames."))}oT.isMDXComponent=!0;const pT={toc:[]},rT="wrapper";function sT(e){let{components:n,...t}=e;return(0,s.yg)(rT,(0,p.A)({},pT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current framerate."))}sT.isMDXComponent=!0;const cT={toc:[]},aT="wrapper";function iT(e){let{components:n,...t}=e;return(0,s.yg)(aT,(0,p.A)({},cT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a string stored in a meta file."))}iT.isMDXComponent=!0;const lT={toc:[]},uT="wrapper";function mT(e){let{components:n,...t}=e;return(0,s.yg)(uT,(0,p.A)({},lT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}mT.isMDXComponent=!0;const yT={toc:[]},dT="wrapper";function hT(e){let{components:n,...t}=e;return(0,s.yg)(dT,(0,p.A)({},yT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}hT.isMDXComponent=!0;const gT={toc:[]},fT="wrapper";function DT(e){let{components:n,...t}=e;return(0,s.yg)(fT,(0,p.A)({},gT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}DT.isMDXComponent=!0;const MT={toc:[]},XT="wrapper";function _T(e){let{components:n,...t}=e;return(0,s.yg)(XT,(0,p.A)({},MT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}_T.isMDXComponent=!0;const wT={toc:[]},TT="wrapper";function CT(e){let{components:n,...t}=e;return(0,s.yg)(TT,(0,p.A)({},wT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}CT.isMDXComponent=!0;const xT={toc:[]},AT="wrapper";function vT(e){let{components:n,...t}=e;return(0,s.yg)(AT,(0,p.A)({},xT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}vT.isMDXComponent=!0;const LT={toc:[]},bT="wrapper";function NT(e){let{components:n,...t}=e;return(0,s.yg)(bT,(0,p.A)({},LT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}NT.isMDXComponent=!0;const kT={toc:[]},zT="wrapper";function PT(e){let{components:n,...t}=e;return(0,s.yg)(zT,(0,p.A)({},kT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}PT.isMDXComponent=!0;const IT={toc:[]},RT="wrapper";function WT(e){let{components:n,...t}=e;return(0,s.yg)(RT,(0,p.A)({},IT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}WT.isMDXComponent=!0;const ST={toc:[]},BT="wrapper";function GT(e){let{components:n,...t}=e;return(0,s.yg)(BT,(0,p.A)({},ST,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}GT.isMDXComponent=!0;const ET={toc:[]},OT="wrapper";function UT(e){let{components:n,...t}=e;return(0,s.yg)(OT,(0,p.A)({},ET,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}UT.isMDXComponent=!0;const FT={toc:[]},VT="wrapper";function qT(e){let{components:n,...t}=e;return(0,s.yg)(VT,(0,p.A)({},FT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}qT.isMDXComponent=!0;const jT={toc:[]},HT="wrapper";function YT(e){let{components:n,...t}=e;return(0,s.yg)(HT,(0,p.A)({},jT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}YT.isMDXComponent=!0;const QT={toc:[]},$T="wrapper";function KT(e){let{components:n,...t}=e;return(0,s.yg)($T,(0,p.A)({},QT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}KT.isMDXComponent=!0;const JT={toc:[]},ZT="wrapper";function eC(e){let{components:n,...t}=e;return(0,s.yg)(ZT,(0,p.A)({},JT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}eC.isMDXComponent=!0;const nC={toc:[]},tC="wrapper";function oC(e){let{components:n,...t}=e;return(0,s.yg)(tC,(0,p.A)({},nC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}oC.isMDXComponent=!0;const pC={toc:[]},rC="wrapper";function sC(e){let{components:n,...t}=e;return(0,s.yg)(rC,(0,p.A)({},pC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}sC.isMDXComponent=!0;const cC={toc:[]},aC="wrapper";function iC(e){let{components:n,...t}=e;return(0,s.yg)(aC,(0,p.A)({},cC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}iC.isMDXComponent=!0;const lC={toc:[]},uC="wrapper";function mC(e){let{components:n,...t}=e;return(0,s.yg)(uC,(0,p.A)({},lC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}mC.isMDXComponent=!0;const yC={toc:[]},dC="wrapper";function hC(e){let{components:n,...t}=e;return(0,s.yg)(dC,(0,p.A)({},yC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}hC.isMDXComponent=!0;const gC={toc:[]},fC="wrapper";function DC(e){let{components:n,...t}=e;return(0,s.yg)(fC,(0,p.A)({},gC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a two-dimensional vector stored in a meta file."))}DC.isMDXComponent=!0;const MC={toc:[]},XC="wrapper";function _C(e){let{components:n,...t}=e;return(0,s.yg)(XC,(0,p.A)({},MC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}_C.isMDXComponent=!0;const wC={toc:[]},TC="wrapper";function CC(e){let{components:n,...t}=e;return(0,s.yg)(TC,(0,p.A)({},wC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}CC.isMDXComponent=!0;const xC={toc:[]},AC="wrapper";function vC(e){let{components:n,...t}=e;return(0,s.yg)(AC,(0,p.A)({},xC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}vC.isMDXComponent=!0;const LC={toc:[]},bC="wrapper";function NC(e){let{components:n,...t}=e;return(0,s.yg)(bC,(0,p.A)({},LC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}NC.isMDXComponent=!0;const kC={toc:[]},zC="wrapper";function PC(e){let{components:n,...t}=e;return(0,s.yg)(zC,(0,p.A)({},kC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}PC.isMDXComponent=!0;const IC={toc:[]},RC="wrapper";function WC(e){let{components:n,...t}=e;return(0,s.yg)(RC,(0,p.A)({},IC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}WC.isMDXComponent=!0;const SC={toc:[]},BC="wrapper";function GC(e){let{components:n,...t}=e;return(0,s.yg)(BC,(0,p.A)({},SC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}GC.isMDXComponent=!0;const EC={toc:[]},OC="wrapper";function UC(e){let{components:n,...t}=e;return(0,s.yg)(OC,(0,p.A)({},EC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}UC.isMDXComponent=!0;const FC={toc:[]},VC="wrapper";function qC(e){let{components:n,...t}=e;return(0,s.yg)(VC,(0,p.A)({},FC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}qC.isMDXComponent=!0;const jC={toc:[]},HC="wrapper";function YC(e){let{components:n,...t}=e;return(0,s.yg)(HC,(0,p.A)({},jC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}YC.isMDXComponent=!0;const QC={toc:[]},$C="wrapper";function KC(e){let{components:n,...t}=e;return(0,s.yg)($C,(0,p.A)({},QC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}KC.isMDXComponent=!0;const JC={toc:[]},ZC="wrapper";function ex(e){let{components:n,...t}=e;return(0,s.yg)(ZC,(0,p.A)({},JC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}ex.isMDXComponent=!0;const nx={toc:[]},tx="wrapper";function ox(e){let{components:n,...t}=e;return(0,s.yg)(tx,(0,p.A)({},nx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}ox.isMDXComponent=!0;const px={toc:[]},rx="wrapper";function sx(e){let{components:n,...t}=e;return(0,s.yg)(rx,(0,p.A)({},px,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}sx.isMDXComponent=!0;const cx={toc:[]},ax="wrapper";function ix(e){let{components:n,...t}=e;return(0,s.yg)(ax,(0,p.A)({},cx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}ix.isMDXComponent=!0;const lx={toc:[]},ux="wrapper";function mx(e){let{components:n,...t}=e;return(0,s.yg)(ux,(0,p.A)({},lx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}mx.isMDXComponent=!0;const yx={toc:[]},dx="wrapper";function hx(e){let{components:n,...t}=e;return(0,s.yg)(dx,(0,p.A)({},yx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}hx.isMDXComponent=!0;const gx={toc:[]},fx="wrapper";function Dx(e){let{components:n,...t}=e;return(0,s.yg)(fx,(0,p.A)({},gx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Dx.isMDXComponent=!0;const Mx={toc:[]},Xx="wrapper";function _x(e){let{components:n,...t}=e;return(0,s.yg)(Xx,(0,p.A)({},Mx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}_x.isMDXComponent=!0;const wx={toc:[]},Tx="wrapper";function Cx(e){let{components:n,...t}=e;return(0,s.yg)(Tx,(0,p.A)({},wx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Cx.isMDXComponent=!0;const xx={toc:[]},Ax="wrapper";function vx(e){let{components:n,...t}=e;return(0,s.yg)(Ax,(0,p.A)({},xx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an object with nested meta-fields."))}vx.isMDXComponent=!0;const Lx={toc:[]},bx="wrapper";function Nx(e){let{components:n,...t}=e;return(0,s.yg)(bx,(0,p.A)({},Lx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an object with nested meta-fields."))}Nx.isMDXComponent=!0;const kx={toc:[]},zx="wrapper";function Px(e){let{components:n,...t}=e;return(0,s.yg)(zx,(0,p.A)({},kx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a runtime Motion Canvas plugin."))}Px.isMDXComponent=!0;const Ix={toc:[]},Rx="wrapper";function Wx(e){let{components:n,...t}=e;return(0,s.yg)(Rx,(0,p.A)({},Ix,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name should be unique across the entire ecosystem of Motion Canvas.\nIf a plugin with the same name has already been registered, this plugin\nwill be ignored."),(0,s.yg)("p",null,"If you intend to publish your plugin to npm, it is recommended to prefix\nthis name with the name of your npm package."),(0,s.yg)("p",null,"Other identifiers defined by the plugin, such as a tab id, will be\nautomatically prefixed with this name and as such don't have to be unique."))}Wx.isMDXComponent=!0;const Sx={toc:[]},Bx="wrapper";function Gx(e){let{components:n,...t}=e;return(0,s.yg)(Bx,(0,p.A)({},Sx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A unique name of the plugin."))}Gx.isMDXComponent=!0;const Ex={toc:[]},Ox="wrapper";function Ux(e){let{components:n,...t}=e;return(0,s.yg)(Ox,(0,p.A)({},Ex,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide custom exporters for the project."))}Ux.isMDXComponent=!0;const Fx={toc:[]},Vx="wrapper";function qx(e){let{components:n,...t}=e;return(0,s.yg)(Vx,(0,p.A)({},Fx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project instance."))}qx.isMDXComponent=!0;const jx={toc:[]},Hx="wrapper";function Yx(e){let{components:n,...t}=e;return(0,s.yg)(Hx,(0,p.A)({},jx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the player instance right after it is initialized."))}Yx.isMDXComponent=!0;const Qx={toc:[]},$x="wrapper";function Kx(e){let{components:n,...t}=e;return(0,s.yg)($x,(0,p.A)({},Qx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The player instance."))}Kx.isMDXComponent=!0;const Jx={toc:[]},Zx="wrapper";function eA(e){let{components:n,...t}=e;return(0,s.yg)(Zx,(0,p.A)({},Jx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the presenter instance right after it is initialized."))}eA.isMDXComponent=!0;const nA={toc:[]},tA="wrapper";function oA(e){let{components:n,...t}=e;return(0,s.yg)(tA,(0,p.A)({},nA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The presenter instance."))}oA.isMDXComponent=!0;const pA={toc:[]},rA="wrapper";function sA(e){let{components:n,...t}=e;return(0,s.yg)(rA,(0,p.A)({},pA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the project instance right after it is initialized."))}sA.isMDXComponent=!0;const cA={toc:[]},aA="wrapper";function iA(e){let{components:n,...t}=e;return(0,s.yg)(aA,(0,p.A)({},cA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project instance."))}iA.isMDXComponent=!0;const lA={toc:[]},uA="wrapper";function mA(e){let{components:n,...t}=e;return(0,s.yg)(uA,(0,p.A)({},lA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the renderer instance right after it is initialized."))}mA.isMDXComponent=!0;const yA={toc:[]},dA="wrapper";function hA(e){let{components:n,...t}=e;return(0,s.yg)(dA,(0,p.A)({},yA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The renderer instance."))}hA.isMDXComponent=!0;const gA={toc:[]},fA="wrapper";function DA(e){let{components:n,...t}=e;return(0,s.yg)(fA,(0,p.A)({},gA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Modify the project settings before the project is initialized."))}DA.isMDXComponent=!0;const MA={toc:[]},XA="wrapper";function _A(e){let{components:n,...t}=e;return(0,s.yg)(XA,(0,p.A)({},MA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project settings."))}_A.isMDXComponent=!0;const wA={toc:[]},TA="wrapper";function CA(e){let{components:n,...t}=e;return(0,s.yg)(TA,(0,p.A)({},wA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}CA.isMDXComponent=!0;const xA={toc:[]},AA="wrapper";function vA(e){let{components:n,...t}=e;return(0,s.yg)(AA,(0,p.A)({},xA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper function for exporting Motion Canvas plugins."))}vA.isMDXComponent=!0;const LA={toc:[]},bA="wrapper";function NA(e){let{components:n,...t}=e;return(0,s.yg)(bA,(0,p.A)({},LA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The plugin configuration."))}NA.isMDXComponent=!0;const kA={toc:[]},zA="wrapper";function PA(e){let{components:n,...t}=e;return(0,s.yg)(zA,(0,p.A)({},kA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abstract scene representations and related utilities."))}PA.isMDXComponent=!0;const IA={toc:[]},RA="wrapper";function WA(e){let{components:n,...t}=e;return(0,s.yg)(RA,(0,p.A)({},IA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Signifies the various stages of a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}WA.isMDXComponent=!0;const SA={toc:[]},BA="wrapper";function GA(e){let{components:n,...t}=e;return(0,s.yg)(BA,(0,p.A)({},SA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs after a render ends."))}GA.isMDXComponent=!0;const EA={toc:[]},OA="wrapper";function UA(e){let{components:n,...t}=e;return(0,s.yg)(OA,(0,p.A)({},EA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}UA.isMDXComponent=!0;const FA={toc:[]},VA="wrapper";function qA(e){let{components:n,...t}=e;return(0,s.yg)(VA,(0,p.A)({},FA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.yg)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}qA.isMDXComponent=!0;const jA={toc:[]},HA="wrapper";function YA(e){let{components:n,...t}=e;return(0,s.yg)(HA,(0,p.A)({},jA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.yg)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}YA.isMDXComponent=!0;const QA={toc:[]},$A="wrapper";function KA(e){let{components:n,...t}=e;return(0,s.yg)($A,(0,p.A)({},QA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes the state of a scene."))}KA.isMDXComponent=!0;const JA={toc:[]},ZA="wrapper";function ev(e){let{components:n,...t}=e;return(0,s.yg)(ZA,(0,p.A)({},JA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}ev.isMDXComponent=!0;const nv={toc:[]},tv="wrapper";function ov(e){let{components:n,...t}=e;return(0,s.yg)(tv,(0,p.A)({},nv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has finished transitioning in."))}ov.isMDXComponent=!0;const pv={toc:[]},rv="wrapper";function sv(e){let{components:n,...t}=e;return(0,s.yg)(rv,(0,p.A)({},pv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.yg)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}sv.isMDXComponent=!0;const cv={toc:[]},av="wrapper";function iv(e){let{components:n,...t}=e;return(0,s.yg)(av,(0,p.A)({},cv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene is ready to transition out."))}iv.isMDXComponent=!0;const lv={toc:[]},uv="wrapper";function mv(e){let{components:n,...t}=e;return(0,s.yg)(uv,(0,p.A)({},lv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoking ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.yg)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}mv.isMDXComponent=!0;const yv={toc:[]},dv="wrapper";function hv(e){let{components:n,...t}=e;return(0,s.yg)(dv,(0,p.A)({},yv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has finished."))}hv.isMDXComponent=!0;const gv={toc:[]},fv="wrapper";function Dv(e){let{components:n,...t}=e;return(0,s.yg)(fv,(0,p.A)({},gv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has just been created/reset."))}Dv.isMDXComponent=!0;const Mv={toc:[]},Xv="wrapper";function _v(e){let{components:n,...t}=e;return(0,s.yg)(Xv,(0,p.A)({},Mv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The default implementation of the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.yg)("p",null,"Uses generators to control the animation."))}_v.isMDXComponent=!0;const wv={toc:[]},Tv="wrapper";function Cv(e){let{components:n,...t}=e;return(0,s.yg)(Tv,(0,p.A)({},wv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Will be passed as the second argument to the constructor."))}Cv.isMDXComponent=!0;const xv={toc:[]},Av="wrapper";function vv(e){let{components:n,...t}=e;return(0,s.yg)(Av,(0,p.A)({},xv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Name of the scene."))}vv.isMDXComponent=!0;const Lv={toc:[]},bv="wrapper";function Nv(e){let{components:n,...t}=e;return(0,s.yg)(bv,(0,p.A)({},Lv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reference to the project."))}Nv.isMDXComponent=!0;const kv={toc:[]},zv="wrapper";function Pv(e){let{components:n,...t}=e;return(0,s.yg)(zv,(0,p.A)({},kv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}Pv.isMDXComponent=!0;const Iv={toc:[]},Rv="wrapper";function Wv(e){let{components:n,...t}=e;return(0,s.yg)(Rv,(0,p.A)({},Iv,t,{components:n,mdxType:"MDXLayout"}))}Wv.isMDXComponent=!0;const Sv={toc:[]},Bv="wrapper";function Gv(e){let{components:n,...t}=e;return(0,s.yg)(Bv,(0,p.A)({},Sv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Gv.isMDXComponent=!0;const Ev={toc:[]},Ov="wrapper";function Uv(e){let{components:n,...t}=e;return(0,s.yg)(Ov,(0,p.A)({},Ev,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Uv.isMDXComponent=!0;const Fv={toc:[]},Vv="wrapper";function qv(e){let{components:n,...t}=e;return(0,s.yg)(Vv,(0,p.A)({},Fv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene starts."))}qv.isMDXComponent=!0;const jv={toc:[]},Hv="wrapper";function Yv(e){let{components:n,...t}=e;return(0,s.yg)(Hv,(0,p.A)({},jv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene ends."))}Yv.isMDXComponent=!0;const Qv={toc:[]},$v="wrapper";function Kv(e){let{components:n,...t}=e;return(0,s.yg)($v,(0,p.A)({},Qv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the cached data changes."))}Kv.isMDXComponent=!0;const Jv={toc:[]},Zv="wrapper";function eL(e){let{components:n,...t}=e;return(0,s.yg)(Zv,(0,p.A)({},Jv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered after scene is recalculated."))}eL.isMDXComponent=!0;const nL={toc:[]},tL="wrapper";function oL(e){let{components:n,...t}=e;return(0,s.yg)(tL,(0,p.A)({},nL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reloaded."))}oL.isMDXComponent=!0;const pL={toc:[]},rL="wrapper";function sL(e){let{components:n,...t}=e;return(0,s.yg)(rL,(0,p.A)({},pL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}sL.isMDXComponent=!0;const cL={toc:[]},aL="wrapper";function iL(e){let{components:n,...t}=e;return(0,s.yg)(aL,(0,p.A)({},cL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reset."))}iL.isMDXComponent=!0;const lL={toc:[]},uL="wrapper";function mL(e){let{components:n,...t}=e;return(0,s.yg)(uL,(0,p.A)({},lL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the main thread changes."))}mL.isMDXComponent=!0;const yL={toc:[]},dL="wrapper";function hL(e){let{components:n,...t}=e;return(0,s.yg)(dL,(0,p.A)({},yL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene directly before this scene, or null if omitted for performance."))}hL.isMDXComponent=!0;const gL={toc:[]},fL="wrapper";function DL(e){let{components:n,...t}=e;return(0,s.yg)(fL,(0,p.A)({},gL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}DL.isMDXComponent=!0;const ML={toc:[]},XL="wrapper";function _L(e){let{components:n,...t}=e;return(0,s.yg)(XL,(0,p.A)({},ML,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}_L.isMDXComponent=!0;const wL={toc:[]},TL="wrapper";function CL(e){let{components:n,...t}=e;return(0,s.yg)(TL,(0,p.A)({},wL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}CL.isMDXComponent=!0;const xL={toc:[]},AL="wrapper";function vL(e){let{components:n,...t}=e;return(0,s.yg)(AL,(0,p.A)({},xL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.yg)("inlineCode",{parentName:"a"},"Initial"))," state."))}vL.isMDXComponent=!0;const LL={toc:[]},bL="wrapper";function NL(e){let{components:n,...t}=e;return(0,s.yg)(bL,(0,p.A)({},LL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}NL.isMDXComponent=!0;const kL={toc:[]},zL="wrapper";function PL(e){let{components:n,...t}=e;return(0,s.yg)(zL,(0,p.A)({},kL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback in the context of this scene."))}PL.isMDXComponent=!0;const IL={toc:[]},RL="wrapper";function WL(e){let{components:n,...t}=e;return(0,s.yg)(RL,(0,p.A)({},IL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}WL.isMDXComponent=!0;const SL={toc:[]},BL="wrapper";function GL(e){let{components:n,...t}=e;return(0,s.yg)(BL,(0,p.A)({},SL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all media assets"))}GL.isMDXComponent=!0;const EL={toc:[]},OL="wrapper";function UL(e){let{components:n,...t}=e;return(0,s.yg)(OL,(0,p.A)({},EL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}UL.isMDXComponent=!0;const FL={toc:[]},VL="wrapper";function qL(e){let{components:n,...t}=e;return(0,s.yg)(VL,(0,p.A)({},FL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real size of this scene."))}qL.isMDXComponent=!0;const jL={toc:[]},HL="wrapper";function YL(e){let{components:n,...t}=e;return(0,s.yg)(HL,(0,p.A)({},jL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually returns ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}YL.isMDXComponent=!0;const QL={toc:[]},$L="wrapper";function KL(e){let{components:n,...t}=e;return(0,s.yg)($L,(0,p.A)({},QL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the size of this scene."))}KL.isMDXComponent=!0;const JL={toc:[]},ZL="wrapper";function eb(e){let{components:n,...t}=e;return(0,s.yg)(ZL,(0,p.A)({},JL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}eb.isMDXComponent=!0;const nb={toc:[]},tb="wrapper";function ob(e){let{components:n,...t}=e;return(0,s.yg)(tb,(0,p.A)({},nb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used only by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.yg)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.yg)("p",null,"Should always return ",(0,s.yg)("inlineCode",{parentName:"p"},"true"),"."))}ob.isMDXComponent=!0;const pb={toc:[]},rb="wrapper";function sb(e){let{components:n,...t}=e;return(0,s.yg)(rb,(0,p.A)({},pb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene cached?"))}sb.isMDXComponent=!0;const cb={toc:[]},ab="wrapper";function ib(e){let{components:n,...t}=e;return(0,s.yg)(ab,(0,p.A)({},cb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.yg)("inlineCode",{parentName:"a"},"Finished"))," state?"))}ib.isMDXComponent=!0;const lb={toc:[]},ub="wrapper";function mb(e){let{components:n,...t}=e;return(0,s.yg)(ub,(0,p.A)({},lb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress this scene one frame forward."))}mb.isMDXComponent=!0;const yb={toc:[]},db="wrapper";function hb(e){let{components:n,...t}=e;return(0,s.yg)(db,(0,p.A)({},yb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.yg)("p",null,"At the end of execution, this method should set ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.yg)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}hb.isMDXComponent=!0;const gb={toc:[]},fb="wrapper";function Db(e){let{components:n,...t}=e;return(0,s.yg)(fb,(0,p.A)({},gb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Recalculate the scene."))}Db.isMDXComponent=!0;const Mb={toc:[]},Xb="wrapper";function _b(e){let{components:n,...t}=e;return(0,s.yg)(Xb,(0,p.A)({},Mb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.yg)("inlineCode",{parentName:"a"},"onReloaded")),"."))}_b.isMDXComponent=!0;const wb={toc:[]},Tb="wrapper";function Cb(e){let{components:n,...t}=e;return(0,s.yg)(Tb,(0,p.A)({},wb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reload the scene."))}Cb.isMDXComponent=!0;const xb={toc:[]},Ab="wrapper";function vb(e){let{components:n,...t}=e;return(0,s.yg)(Ab,(0,p.A)({},xb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, an updated version of the description."))}vb.isMDXComponent=!0;const Lb={toc:[]},bb="wrapper";function Nb(e){let{components:n,...t}=e;return(0,s.yg)(bb,(0,p.A)({},Lb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the scene onto a canvas."))}Nb.isMDXComponent=!0;const kb={toc:[]},zb="wrapper";function Pb(e){let{components:n,...t}=e;return(0,s.yg)(zb,(0,p.A)({},kb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to used when rendering."))}Pb.isMDXComponent=!0;const Ib={toc:[]},Rb="wrapper";function Wb(e){let{components:n,...t}=e;return(0,s.yg)(Rb,(0,p.A)({},Ib,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset this scene to its initial state."))}Wb.isMDXComponent=!0;const Sb={toc:[]},Bb="wrapper";function Gb(e){let{components:n,...t}=e;return(0,s.yg)(Bb,(0,p.A)({},Sb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, the previous scene."))}Gb.isMDXComponent=!0;const Eb={toc:[]},Ob="wrapper";function Ub(e){let{components:n,...t}=e;return(0,s.yg)(Ob,(0,p.A)({},Eb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the view."),(0,s.yg)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.yg)("p",null,"Can modify the state of the view."))}Ub.isMDXComponent=!0;const Fb={toc:[]},Vb="wrapper";function qb(e){let{components:n,...t}=e;return(0,s.yg)(Vb,(0,p.A)({},Fb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Lifecycle events for ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}qb.isMDXComponent=!0;const jb={toc:[]},Hb="wrapper";function Yb(e){let{components:n,...t}=e;return(0,s.yg)(Hb,(0,p.A)({},jb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A random number generator based on\n",(0,s.yg)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.yg)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Yb.isMDXComponent=!0;const Qb={toc:[]},$b="wrapper";function Kb(e){let{components:n,...t}=e;return(0,s.yg)($b,(0,p.A)({},Qb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get an array filled with random floats in the given range."))}Kb.isMDXComponent=!0;const Jb={toc:[]},Zb="wrapper";function eN(e){let{components:n,...t}=e;return(0,s.yg)(Zb,(0,p.A)({},Jb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The size of the array."))}eN.isMDXComponent=!0;const nN={toc:[]},tN="wrapper";function oN(e){let{components:n,...t}=e;return(0,s.yg)(tN,(0,p.A)({},nN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}oN.isMDXComponent=!0;const pN={toc:[]},rN="wrapper";function sN(e){let{components:n,...t}=e;return(0,s.yg)(rN,(0,p.A)({},pN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}sN.isMDXComponent=!0;const cN={toc:[]},aN="wrapper";function iN(e){let{components:n,...t}=e;return(0,s.yg)(aN,(0,p.A)({},cN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a random float from a gaussian distribution."))}iN.isMDXComponent=!0;const lN={toc:[]},uN="wrapper";function mN(e){let{components:n,...t}=e;return(0,s.yg)(uN,(0,p.A)({},lN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The mean of the distribution."))}mN.isMDXComponent=!0;const yN={toc:[]},dN="wrapper";function hN(e){let{components:n,...t}=e;return(0,s.yg)(dN,(0,p.A)({},yN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The standard deviation of the distribution."))}hN.isMDXComponent=!0;const gN={toc:[]},fN="wrapper";function DN(e){let{components:n,...t}=e;return(0,s.yg)(fN,(0,p.A)({},gN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get an array filled with random integers in the given range."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"}),(0,s.yg)("li",{parentName:"ul"})))}DN.isMDXComponent=!0;const MN={toc:[]},XN="wrapper";function _N(e){let{components:n,...t}=e;return(0,s.yg)(XN,(0,p.A)({},MN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The size of the array."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}_N.isMDXComponent=!0;const wN={toc:[]},TN="wrapper";function CN(e){let{components:n,...t}=e;return(0,s.yg)(TN,(0,p.A)({},wN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}CN.isMDXComponent=!0;const xN={toc:[]},AN="wrapper";function vN(e){let{components:n,...t}=e;return(0,s.yg)(AN,(0,p.A)({},xN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. Exclusive."))}vN.isMDXComponent=!0;const LN={toc:[]},bN="wrapper";function NN(e){let{components:n,...t}=e;return(0,s.yg)(bN,(0,p.A)({},LN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the next random float in the given range."))}NN.isMDXComponent=!0;const kN={toc:[]},zN="wrapper";function PN(e){let{components:n,...t}=e;return(0,s.yg)(zN,(0,p.A)({},kN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}PN.isMDXComponent=!0;const IN={toc:[]},RN="wrapper";function WN(e){let{components:n,...t}=e;return(0,s.yg)(RN,(0,p.A)({},IN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}WN.isMDXComponent=!0;const SN={toc:[]},BN="wrapper";function GN(e){let{components:n,...t}=e;return(0,s.yg)(BN,(0,p.A)({},SN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the next random integer in the given range."))}GN.isMDXComponent=!0;const EN={toc:[]},ON="wrapper";function UN(e){let{components:n,...t}=e;return(0,s.yg)(ON,(0,p.A)({},EN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}UN.isMDXComponent=!0;const FN={toc:[]},VN="wrapper";function qN(e){let{components:n,...t}=e;return(0,s.yg)(VN,(0,p.A)({},FN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. Exclusive."))}qN.isMDXComponent=!0;const jN={toc:[]},HN="wrapper";function YN(e){let{components:n,...t}=e;return(0,s.yg)(HN,(0,p.A)({},jN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a new independent generator."))}YN.isMDXComponent=!0;const QN={toc:[]},$N="wrapper";function KN(e){let{components:n,...t}=e;return(0,s.yg)($N,(0,p.A)({},QN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get variable signal if exists or create signal if not"))}KN.isMDXComponent=!0;const JN={toc:[]},ZN="wrapper";function ek(e){let{components:n,...t}=e;return(0,s.yg)(ZN,(0,p.A)({},JN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the variable."))}ek.isMDXComponent=!0;const nk={toc:[]},tk="wrapper";function ok(e){let{components:n,...t}=e;return(0,s.yg)(tk,(0,p.A)({},nk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}ok.isMDXComponent=!0;const pk={toc:[]},rk="wrapper";function sk(e){let{components:n,...t}=e;return(0,s.yg)(rk,(0,p.A)({},pk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get variable signal if exists or create signal if not"))}sk.isMDXComponent=!0;const ck={toc:[]},ak="wrapper";function ik(e){let{components:n,...t}=e;return(0,s.yg)(ak,(0,p.A)({},ck,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset all stored signals."))}ik.isMDXComponent=!0;const lk={toc:[]},uk="wrapper";function mk(e){let{components:n,...t}=e;return(0,s.yg)(uk,(0,p.A)({},lk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update all signals with new project variable values."))}mk.isMDXComponent=!0;const yk={toc:[]},dk="wrapper";function hk(e){let{components:n,...t}=e;return(0,s.yg)(dk,(0,p.A)({},yk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes cached information about the timing of a scene."))}hk.isMDXComponent=!0;const gk={toc:[]},fk="wrapper";function Dk(e){let{components:n,...t}=e;return(0,s.yg)(fk,(0,p.A)({},gk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes a complete scene together with the meta file."))}Dk.isMDXComponent=!0;const Mk={toc:[]},Xk="wrapper";function _k(e){let{components:n,...t}=e;return(0,s.yg)(Xk,(0,p.A)({},Mk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configuration object."))}_k.isMDXComponent=!0;const wk={toc:[]},Tk="wrapper";function Ck(e){let{components:n,...t}=e;return(0,s.yg)(Tk,(0,p.A)({},wk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class used to instantiate the scene."))}Ck.isMDXComponent=!0;const xk={toc:[]},Ak="wrapper";function vk(e){let{components:n,...t}=e;return(0,s.yg)(Ak,(0,p.A)({},xk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}vk.isMDXComponent=!0;const Lk={toc:[]},bk="wrapper";function Nk(e){let{components:n,...t}=e;return(0,s.yg)(bk,(0,p.A)({},Lk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace at the moment of creation."))}Nk.isMDXComponent=!0;const kk={toc:[]},zk="wrapper";function Pk(e){let{components:n,...t}=e;return(0,s.yg)(zk,(0,p.A)({},kk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}Pk.isMDXComponent=!0;const Ik={toc:[]},Rk="wrapper";function Wk(e){let{components:n,...t}=e;return(0,s.yg)(Rk,(0,p.A)({},Ik,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Wk.isMDXComponent=!0;const Sk={toc:[]},Bk="wrapper";function Gk(e){let{components:n,...t}=e;return(0,s.yg)(Bk,(0,p.A)({},Sk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Gk.isMDXComponent=!0;const Ek={toc:[]},Ok="wrapper";function Uk(e){let{components:n,...t}=e;return(0,s.yg)(Ok,(0,p.A)({},Ek,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for the inspected element."))}Uk.isMDXComponent=!0;const Fk={toc:[]},Vk="wrapper";function qk(e){let{components:n,...t}=e;return(0,s.yg)(Vk,(0,p.A)({},Fk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element for which to draw an overlay."))}qk.isMDXComponent=!0;const jk={toc:[]},Hk="wrapper";function Yk(e){let{components:n,...t}=e;return(0,s.yg)(Hk,(0,p.A)({},jk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Yk.isMDXComponent=!0;const Qk={toc:[]},$k="wrapper";function Kk(e){let{components:n,...t}=e;return(0,s.yg)($k,(0,p.A)({},Qk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Kk.isMDXComponent=!0;const Jk={toc:[]},Zk="wrapper";function ez(e){let{components:n,...t}=e;return(0,s.yg)(Zk,(0,p.A)({},Jk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,'This information will be displayed in the "Properties" panel.'))}ez.isMDXComponent=!0;const nz={toc:[]},tz="wrapper";function oz(e){let{components:n,...t}=e;return(0,s.yg)(tz,(0,p.A)({},nz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the attributes of the inspected element."))}oz.isMDXComponent=!0;const pz={toc:[]},rz="wrapper";function sz(e){let{components:n,...t}=e;return(0,s.yg)(rz,(0,p.A)({},pz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element to inspect."))}sz.isMDXComponent=!0;const cz={toc:[]},az="wrapper";function iz(e){let{components:n,...t}=e;return(0,s.yg)(az,(0,p.A)({},cz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a possible element to inspect at a given position."))}iz.isMDXComponent=!0;const lz={toc:[]},uz="wrapper";function mz(e){let{components:n,...t}=e;return(0,s.yg)(uz,(0,p.A)({},lz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x coordinate."))}mz.isMDXComponent=!0;const yz={toc:[]},dz="wrapper";function hz(e){let{components:n,...t}=e;return(0,s.yg)(dz,(0,p.A)({},yz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y coordinate."))}hz.isMDXComponent=!0;const gz={toc:[]},fz="wrapper";function Dz(e){let{components:n,...t}=e;return(0,s.yg)(fz,(0,p.A)({},gz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}Dz.isMDXComponent=!0;const Mz={toc:[]},Xz="wrapper";function _z(e){let{components:n,...t}=e;return(0,s.yg)(Xz,(0,p.A)({},Mz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x coordinate."))}_z.isMDXComponent=!0;const wz={toc:[]},Tz="wrapper";function Cz(e){let{components:n,...t}=e;return(0,s.yg)(Tz,(0,p.A)({},wz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y coordinate."))}Cz.isMDXComponent=!0;const xz={toc:[]},Az="wrapper";function vz(e){let{components:n,...t}=e;return(0,s.yg)(Az,(0,p.A)({},xz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}vz.isMDXComponent=!0;const Lz={toc:[]},bz="wrapper";function Nz(e){let{components:n,...t}=e;return(0,s.yg)(bz,(0,p.A)({},Lz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the inspected element is still valid."))}Nz.isMDXComponent=!0;const kz={toc:[]},zz="wrapper";function Pz(e){let{components:n,...t}=e;return(0,s.yg)(zz,(0,p.A)({},kz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element to validate."))}Pz.isMDXComponent=!0;const Iz={toc:[]},Rz="wrapper";function Wz(e){let{components:n,...t}=e;return(0,s.yg)(Rz,(0,p.A)({},Iz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.yg)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Wz.isMDXComponent=!0;const Sz={toc:[]},Bz="wrapper";function Gz(e){let{components:n,...t}=e;return(0,s.yg)(Bz,(0,p.A)({},Sz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main interface for scenes."))}Gz.isMDXComponent=!0;const Ez={toc:[]},Oz="wrapper";function Uz(e){let{components:n,...t}=e;return(0,s.yg)(Oz,(0,p.A)({},Ez,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Will be passed as the second argument to the constructor."))}Uz.isMDXComponent=!0;const Fz={toc:[]},Vz="wrapper";function qz(e){let{components:n,...t}=e;return(0,s.yg)(Vz,(0,p.A)({},Fz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Name of the scene."))}qz.isMDXComponent=!0;const jz={toc:[]},Hz="wrapper";function Yz(e){let{components:n,...t}=e;return(0,s.yg)(Hz,(0,p.A)({},jz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reference to the project."))}Yz.isMDXComponent=!0;const Qz={toc:[]},$z="wrapper";function Kz(e){let{components:n,...t}=e;return(0,s.yg)($z,(0,p.A)({},Qz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}Kz.isMDXComponent=!0;const Jz={toc:[]},Zz="wrapper";function eP(e){let{components:n,...t}=e;return(0,s.yg)(Zz,(0,p.A)({},Jz,t,{components:n,mdxType:"MDXLayout"}))}eP.isMDXComponent=!0;const nP={toc:[]},tP="wrapper";function oP(e){let{components:n,...t}=e;return(0,s.yg)(tP,(0,p.A)({},nP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}oP.isMDXComponent=!0;const pP={toc:[]},rP="wrapper";function sP(e){let{components:n,...t}=e;return(0,s.yg)(rP,(0,p.A)({},pP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}sP.isMDXComponent=!0;const cP={toc:[]},aP="wrapper";function iP(e){let{components:n,...t}=e;return(0,s.yg)(aP,(0,p.A)({},cP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether experimental features are enabled."))}iP.isMDXComponent=!0;const lP={toc:[]},uP="wrapper";function mP(e){let{components:n,...t}=e;return(0,s.yg)(uP,(0,p.A)({},lP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene starts."))}mP.isMDXComponent=!0;const yP={toc:[]},dP="wrapper";function hP(e){let{components:n,...t}=e;return(0,s.yg)(dP,(0,p.A)({},yP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene ends."))}hP.isMDXComponent=!0;const gP={toc:[]},fP="wrapper";function DP(e){let{components:n,...t}=e;return(0,s.yg)(fP,(0,p.A)({},gP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}DP.isMDXComponent=!0;const MP={toc:[]},XP="wrapper";function _P(e){let{components:n,...t}=e;return(0,s.yg)(XP,(0,p.A)({},MP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the cached data changes."))}_P.isMDXComponent=!0;const wP={toc:[]},TP="wrapper";function CP(e){let{components:n,...t}=e;return(0,s.yg)(TP,(0,p.A)({},wP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered after scene is recalculated."))}CP.isMDXComponent=!0;const xP={toc:[]},AP="wrapper";function vP(e){let{components:n,...t}=e;return(0,s.yg)(AP,(0,p.A)({},xP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reloaded."))}vP.isMDXComponent=!0;const LP={toc:[]},bP="wrapper";function NP(e){let{components:n,...t}=e;return(0,s.yg)(bP,(0,p.A)({},LP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}NP.isMDXComponent=!0;const kP={toc:[]},zP="wrapper";function PP(e){let{components:n,...t}=e;return(0,s.yg)(zP,(0,p.A)({},kP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reset."))}PP.isMDXComponent=!0;const IP={toc:[]},RP="wrapper";function WP(e){let{components:n,...t}=e;return(0,s.yg)(RP,(0,p.A)({},IP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene directly before this scene, or null if omitted for performance."))}WP.isMDXComponent=!0;const SP={toc:[]},BP="wrapper";function GP(e){let{components:n,...t}=e;return(0,s.yg)(BP,(0,p.A)({},SP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}GP.isMDXComponent=!0;const EP={toc:[]},OP="wrapper";function UP(e){let{components:n,...t}=e;return(0,s.yg)(OP,(0,p.A)({},EP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}UP.isMDXComponent=!0;const FP={toc:[]},VP="wrapper";function qP(e){let{components:n,...t}=e;return(0,s.yg)(VP,(0,p.A)({},FP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}qP.isMDXComponent=!0;const jP={toc:[]},HP="wrapper";function YP(e){let{components:n,...t}=e;return(0,s.yg)(HP,(0,p.A)({},jP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.yg)("inlineCode",{parentName:"a"},"Initial"))," state."))}YP.isMDXComponent=!0;const QP={toc:[]},$P="wrapper";function KP(e){let{components:n,...t}=e;return(0,s.yg)($P,(0,p.A)({},QP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all media assets"))}KP.isMDXComponent=!0;const JP={toc:[]},ZP="wrapper";function eI(e){let{components:n,...t}=e;return(0,s.yg)(ZP,(0,p.A)({},JP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}eI.isMDXComponent=!0;const nI={toc:[]},tI="wrapper";function oI(e){let{components:n,...t}=e;return(0,s.yg)(tI,(0,p.A)({},nI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real size of this scene."))}oI.isMDXComponent=!0;const pI={toc:[]},rI="wrapper";function sI(e){let{components:n,...t}=e;return(0,s.yg)(rI,(0,p.A)({},pI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually returns ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}sI.isMDXComponent=!0;const cI={toc:[]},aI="wrapper";function iI(e){let{components:n,...t}=e;return(0,s.yg)(aI,(0,p.A)({},cI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the size of this scene."))}iI.isMDXComponent=!0;const lI={toc:[]},uI="wrapper";function mI(e){let{components:n,...t}=e;return(0,s.yg)(uI,(0,p.A)({},lI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}mI.isMDXComponent=!0;const yI={toc:[]},dI="wrapper";function hI(e){let{components:n,...t}=e;return(0,s.yg)(dI,(0,p.A)({},yI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used only by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.yg)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.yg)("p",null,"Should always return ",(0,s.yg)("inlineCode",{parentName:"p"},"true"),"."))}hI.isMDXComponent=!0;const gI={toc:[]},fI="wrapper";function DI(e){let{components:n,...t}=e;return(0,s.yg)(fI,(0,p.A)({},gI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene cached?"))}DI.isMDXComponent=!0;const MI={toc:[]},XI="wrapper";function _I(e){let{components:n,...t}=e;return(0,s.yg)(XI,(0,p.A)({},MI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.yg)("inlineCode",{parentName:"a"},"Finished"))," state?"))}_I.isMDXComponent=!0;const wI={toc:[]},TI="wrapper";function CI(e){let{components:n,...t}=e;return(0,s.yg)(TI,(0,p.A)({},wI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress this scene one frame forward."))}CI.isMDXComponent=!0;const xI={toc:[]},AI="wrapper";function vI(e){let{components:n,...t}=e;return(0,s.yg)(AI,(0,p.A)({},xI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.yg)("p",null,"At the end of execution, this method should set ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.yg)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}vI.isMDXComponent=!0;const LI={toc:[]},bI="wrapper";function NI(e){let{components:n,...t}=e;return(0,s.yg)(bI,(0,p.A)({},LI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Recalculate the scene."))}NI.isMDXComponent=!0;const kI={toc:[]},zI="wrapper";function PI(e){let{components:n,...t}=e;return(0,s.yg)(zI,(0,p.A)({},kI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.yg)("inlineCode",{parentName:"a"},"onReloaded")),"."))}PI.isMDXComponent=!0;const II={toc:[]},RI="wrapper";function WI(e){let{components:n,...t}=e;return(0,s.yg)(RI,(0,p.A)({},II,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reload the scene."))}WI.isMDXComponent=!0;const SI={toc:[]},BI="wrapper";function GI(e){let{components:n,...t}=e;return(0,s.yg)(BI,(0,p.A)({},SI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, an updated version of the description."))}GI.isMDXComponent=!0;const EI={toc:[]},OI="wrapper";function UI(e){let{components:n,...t}=e;return(0,s.yg)(OI,(0,p.A)({},EI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the scene onto a canvas."))}UI.isMDXComponent=!0;const FI={toc:[]},VI="wrapper";function qI(e){let{components:n,...t}=e;return(0,s.yg)(VI,(0,p.A)({},FI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to used when rendering."))}qI.isMDXComponent=!0;const jI={toc:[]},HI="wrapper";function YI(e){let{components:n,...t}=e;return(0,s.yg)(HI,(0,p.A)({},jI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset this scene to its initial state."))}YI.isMDXComponent=!0;const QI={toc:[]},$I="wrapper";function KI(e){let{components:n,...t}=e;return(0,s.yg)($I,(0,p.A)({},QI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, the previous scene."))}KI.isMDXComponent=!0;const JI={toc:[]},ZI="wrapper";function eR(e){let{components:n,...t}=e;return(0,s.yg)(ZI,(0,p.A)({},JI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}eR.isMDXComponent=!0;const nR={toc:[]},tR="wrapper";function oR(e){let{components:n,...t}=e;return(0,s.yg)(tR,(0,p.A)({},nR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each class implementing the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}oR.isMDXComponent=!0;const pR={toc:[]},rR="wrapper";function sR(e){let{components:n,...t}=e;return(0,s.yg)(rR,(0,p.A)({},pR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constructor used when creating new scenes."))}sR.isMDXComponent=!0;const cR={toc:[]},aR="wrapper";function iR(e){let{components:n,...t}=e;return(0,s.yg)(aR,(0,p.A)({},cR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.yg)("inlineCode",{parentName:"a"},"config")),"."))}iR.isMDXComponent=!0;const lR={toc:[]},uR="wrapper";function mR(e){let{components:n,...t}=e;return(0,s.yg)(uR,(0,p.A)({},lR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes a scene exposed by scene files."))}mR.isMDXComponent=!0;const yR={toc:[]},dR="wrapper";function hR(e){let{components:n,...t}=e;return(0,s.yg)(dR,(0,p.A)({},yR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configuration object."))}hR.isMDXComponent=!0;const gR={toc:[]},fR="wrapper";function DR(e){let{components:n,...t}=e;return(0,s.yg)(fR,(0,p.A)({},gR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class used to instantiate the scene."))}DR.isMDXComponent=!0;const MR={toc:[]},XR="wrapper";function _R(e){let{components:n,...t}=e;return(0,s.yg)(XR,(0,p.A)({},MR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}_R.isMDXComponent=!0;const wR={toc:[]},TR="wrapper";function CR(e){let{components:n,...t}=e;return(0,s.yg)(TR,(0,p.A)({},wR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace at the moment of creation."))}CR.isMDXComponent=!0;const xR={toc:[]},AR="wrapper";function vR(e){let{components:n,...t}=e;return(0,s.yg)(AR,(0,p.A)({},xR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}vR.isMDXComponent=!0;const LR={toc:[]},bR="wrapper";function NR(e){let{components:n,...t}=e;return(0,s.yg)(bR,(0,p.A)({},LR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A part of the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.yg)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}NR.isMDXComponent=!0;const kR={toc:[]},zR="wrapper";function PR(e){let{components:n,...t}=e;return(0,s.yg)(zR,(0,p.A)({},kR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}PR.isMDXComponent=!0;const IR={toc:[]},RR="wrapper";function WR(e){let{components:n,...t}=e;return(0,s.yg)(RR,(0,p.A)({},IR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This interface is only useful when a scene uses thread generators to run."))}WR.isMDXComponent=!0;const SR={toc:[]},BR="wrapper";function GR(e){let{components:n,...t}=e;return(0,s.yg)(BR,(0,p.A)({},SR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}GR.isMDXComponent=!0;const ER={toc:[]},OR="wrapper";function UR(e){let{components:n,...t}=e;return(0,s.yg)(OR,(0,p.A)({},ER,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the main thread changes."))}UR.isMDXComponent=!0;const FR={toc:[]},VR="wrapper";function qR(e){let{components:n,...t}=e;return(0,s.yg)(VR,(0,p.A)({},FR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents attributes of an inspected element."))}qR.isMDXComponent=!0;const jR={toc:[]},HR="wrapper";function YR(e){let{components:n,...t}=e;return(0,s.yg)(HR,(0,p.A)({},jR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}YR.isMDXComponent=!0;const QR={toc:[]},$R="wrapper";function KR(e){let{components:n,...t}=e;return(0,s.yg)($R,(0,p.A)({},QR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an element to inspect."))}KR.isMDXComponent=!0;const JR={toc:[]},ZR="wrapper";function eW(e){let{components:n,...t}=e;return(0,s.yg)(ZR,(0,p.A)({},JR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A runtime representation of the scene metadata."))}eW.isMDXComponent=!0;const nW={toc:[]},tW="wrapper";function oW(e){let{components:n,...t}=e;return(0,s.yg)(tW,(0,p.A)({},nW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a runtime representation of the scene metadata."))}oW.isMDXComponent=!0;const pW={toc:[]},rW="wrapper";function sW(e){let{components:n,...t}=e;return(0,s.yg)(rW,(0,p.A)({},pW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}sW.isMDXComponent=!0;const cW={toc:[]},aW="wrapper";function iW(e){let{components:n,...t}=e;return(0,s.yg)(aW,(0,p.A)({},cW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}iW.isMDXComponent=!0;const lW={toc:[]},uW="wrapper";function mW(e){let{components:n,...t}=e;return(0,s.yg)(uW,(0,p.A)({},lW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}mW.isMDXComponent=!0;const yW={toc:[]},dW="wrapper";function hW(e){let{components:n,...t}=e;return(0,s.yg)(dW,(0,p.A)({},yW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}hW.isMDXComponent=!0;const gW={toc:[]},fW="wrapper";function DW(e){let{components:n,...t}=e;return(0,s.yg)(fW,(0,p.A)({},gW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}DW.isMDXComponent=!0;const MW={toc:[]},XW="wrapper";function _W(e){let{components:n,...t}=e;return(0,s.yg)(XW,(0,p.A)({},MW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}_W.isMDXComponent=!0;const wW={toc:[]},TW="wrapper";function CW(e){let{components:n,...t}=e;return(0,s.yg)(TW,(0,p.A)({},wW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}CW.isMDXComponent=!0;const xW={toc:[]},AW="wrapper";function vW(e){let{components:n,...t}=e;return(0,s.yg)(AW,(0,p.A)({},xW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}vW.isMDXComponent=!0;const LW={toc:[]},bW="wrapper";function NW(e){let{components:n,...t}=e;return(0,s.yg)(bW,(0,p.A)({},LW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}NW.isMDXComponent=!0;const kW={toc:[]},zW="wrapper";function PW(e){let{components:n,...t}=e;return(0,s.yg)(zW,(0,p.A)({},kW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}PW.isMDXComponent=!0;const IW={toc:[]},RW="wrapper";function WW(e){let{components:n,...t}=e;return(0,s.yg)(RW,(0,p.A)({},IW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}WW.isMDXComponent=!0;const SW={toc:[]},BW="wrapper";function GW(e){let{components:n,...t}=e;return(0,s.yg)(BW,(0,p.A)({},SW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}GW.isMDXComponent=!0;const EW={toc:[]},OW="wrapper";function UW(e){let{components:n,...t}=e;return(0,s.yg)(OW,(0,p.A)({},EW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}UW.isMDXComponent=!0;const FW={toc:[]},VW="wrapper";function qW(e){let{components:n,...t}=e;return(0,s.yg)(VW,(0,p.A)({},FW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}qW.isMDXComponent=!0;const jW={toc:[]},HW="wrapper";function YW(e){let{components:n,...t}=e;return(0,s.yg)(HW,(0,p.A)({},jW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}YW.isMDXComponent=!0;const QW={toc:[]},$W="wrapper";function KW(e){let{components:n,...t}=e;return(0,s.yg)($W,(0,p.A)({},QW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}KW.isMDXComponent=!0;const JW={toc:[]},ZW="wrapper";function eS(e){let{components:n,...t}=e;return(0,s.yg)(ZW,(0,p.A)({},JW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}eS.isMDXComponent=!0;const nS={toc:[]},tS="wrapper";function oS(e){let{components:n,...t}=e;return(0,s.yg)(tS,(0,p.A)({},nS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}oS.isMDXComponent=!0;const pS={toc:[]},rS="wrapper";function sS(e){let{components:n,...t}=e;return(0,s.yg)(rS,(0,p.A)({},pS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}sS.isMDXComponent=!0;const cS={toc:[]},aS="wrapper";function iS(e){let{components:n,...t}=e;return(0,s.yg)(aS,(0,p.A)({},cS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}iS.isMDXComponent=!0;const lS={toc:[]},uS="wrapper";function mS(e){let{components:n,...t}=e;return(0,s.yg)(uS,(0,p.A)({},lS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}mS.isMDXComponent=!0;const yS={toc:[]},dS="wrapper";function hS(e){let{components:n,...t}=e;return(0,s.yg)(dS,(0,p.A)({},yS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}hS.isMDXComponent=!0;const gS={toc:[]},fS="wrapper";function DS(e){let{components:n,...t}=e;return(0,s.yg)(fS,(0,p.A)({},gS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}DS.isMDXComponent=!0;const MS={toc:[]},XS="wrapper";function _S(e){let{components:n,...t}=e;return(0,s.yg)(XS,(0,p.A)({},MS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}_S.isMDXComponent=!0;const wS={toc:[]},TS="wrapper";function CS(e){let{components:n,...t}=e;return(0,s.yg)(TS,(0,p.A)({},wS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}CS.isMDXComponent=!0;const xS={toc:[]},AS="wrapper";function vS(e){let{components:n,...t}=e;return(0,s.yg)(AS,(0,p.A)({},xS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}vS.isMDXComponent=!0;const LS={toc:[]},bS="wrapper";function NS(e){let{components:n,...t}=e;return(0,s.yg)(bS,(0,p.A)({},LS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}NS.isMDXComponent=!0;const kS={toc:[]},zS="wrapper";function PS(e){let{components:n,...t}=e;return(0,s.yg)(zS,(0,p.A)({},kS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}PS.isMDXComponent=!0;const IS={toc:[]},RS="wrapper";function WS(e){let{components:n,...t}=e;return(0,s.yg)(RS,(0,p.A)({},IS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}WS.isMDXComponent=!0;const SS={toc:[]},BS="wrapper";function GS(e){let{components:n,...t}=e;return(0,s.yg)(BS,(0,p.A)({},SS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween back to the original value."))}GS.isMDXComponent=!0;const ES={toc:[]},OS="wrapper";function US(e){let{components:n,...t}=e;return(0,s.yg)(OS,(0,p.A)({},ES,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the tween."))}US.isMDXComponent=!0;const FS={toc:[]},VS="wrapper";function qS(e){let{components:n,...t}=e;return(0,s.yg)(VS,(0,p.A)({},FS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function of the tween."))}qS.isMDXComponent=!0;const jS={toc:[]},HS="wrapper";function YS(e){let{components:n,...t}=e;return(0,s.yg)(HS,(0,p.A)({},jS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interpolation function of the tween."))}YS.isMDXComponent=!0;const QS={toc:[]},$S="wrapper";function KS(e){let{components:n,...t}=e;return(0,s.yg)($S,(0,p.A)({},QS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback."))}KS.isMDXComponent=!0;const JS={toc:[]},ZS="wrapper";function eB(e){let{components:n,...t}=e;return(0,s.yg)(ZS,(0,p.A)({},JS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}eB.isMDXComponent=!0;const nB={toc:[]},tB="wrapper";function oB(e){let{components:n,...t}=e;return(0,s.yg)(tB,(0,p.A)({},nB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given task."))}oB.isMDXComponent=!0;const pB={toc:[]},rB="wrapper";function sB(e){let{components:n,...t}=e;return(0,s.yg)(rB,(0,p.A)({},pB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator to run."))}sB.isMDXComponent=!0;const cB={toc:[]},aB="wrapper";function iB(e){let{components:n,...t}=e;return(0,s.yg)(aB,(0,p.A)({},cB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween to the specified value."))}iB.isMDXComponent=!0;const lB={toc:[]},uB="wrapper";function mB(e){let{components:n,...t}=e;return(0,s.yg)(uB,(0,p.A)({},lB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for the specified duration."))}mB.isMDXComponent=!0;const yB={toc:[]},dB="wrapper";function hB(e){let{components:n,...t}=e;return(0,s.yg)(dB,(0,p.A)({},yB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration to wait."))}hB.isMDXComponent=!0;const gB={toc:[]},fB="wrapper";function DB(e){let{components:n,...t}=e;return(0,s.yg)(fB,(0,p.A)({},gB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Thread management."))}DB.isMDXComponent=!0;const MB={toc:[]},XB="wrapper";function _B(e){let{components:n,...t}=e;return(0,s.yg)(XB,(0,p.A)({},MB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.yg)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}_B.isMDXComponent=!0;const wB={toc:[]},TB="wrapper";function CB(e){let{components:n,...t}=e;return(0,s.yg)(TB,(0,p.A)({},wB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A class representing an individual thread."))}CB.isMDXComponent=!0;const xB={toc:[]},AB="wrapper";function vB(e){let{components:n,...t}=e;return(0,s.yg)(AB,(0,p.A)({},xB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator wrapped by this thread."))}vB.isMDXComponent=!0;const LB={toc:[]},bB="wrapper";function NB(e){let{components:n,...t}=e;return(0,s.yg)(bB,(0,p.A)({},LB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator wrapped by this thread."))}NB.isMDXComponent=!0;const kB={toc:[]},zB="wrapper";function PB(e){let{components:n,...t}=e;return(0,s.yg)(zB,(0,p.A)({},kB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.yg)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}PB.isMDXComponent=!0;const IB={toc:[]},RB="wrapper";function WB(e){let{components:n,...t}=e;return(0,s.yg)(RB,(0,p.A)({},IB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current time of this thread."))}WB.isMDXComponent=!0;const SB={toc:[]},BB="wrapper";function GB(e){let{components:n,...t}=e;return(0,s.yg)(BB,(0,p.A)({},SB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The next value to be passed to the wrapped generator."))}GB.isMDXComponent=!0;const EB={toc:[]},OB="wrapper";function UB(e){let{components:n,...t}=e;return(0,s.yg)(OB,(0,p.A)({},EB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if this thread or any of its ancestors has been canceled."))}UB.isMDXComponent=!0;const FB={toc:[]},VB="wrapper";function qB(e){let{components:n,...t}=e;return(0,s.yg)(VB,(0,p.A)({},FB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.yg)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}qB.isMDXComponent=!0;const jB={toc:[]},HB="wrapper";function YB(e){let{components:n,...t}=e;return(0,s.yg)(HB,(0,p.A)({},jB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The fixed time of this thread."))}YB.isMDXComponent=!0;const QB={toc:[]},$B="wrapper";function KB(e){let{components:n,...t}=e;return(0,s.yg)($B,(0,p.A)({},QB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress the wrapped generator once."))}KB.isMDXComponent=!0;const JB={toc:[]},ZB="wrapper";function eG(e){let{components:n,...t}=e;return(0,s.yg)(ZB,(0,p.A)({},JB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the thread for the next update cycle."))}eG.isMDXComponent=!0;const nG={toc:[]},tG="wrapper";function oG(e){let{components:n,...t}=e;return(0,s.yg)(tG,(0,p.A)({},nG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delta time of the next cycle."))}oG.isMDXComponent=!0;const pG={toc:[]},rG="wrapper";function sG(e){let{components:n,...t}=e;return(0,s.yg)(rG,(0,p.A)({},pG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a normal function that returns a generator."))}sG.isMDXComponent=!0;const cG={toc:[]},aG="wrapper";function iG(e){let{components:n,...t}=e;return(0,s.yg)(aG,(0,p.A)({},cG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.yg)("p",null,"Progress to the next frame:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.yg)("p",null,"Run another generator synchronously:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.yg)("p",null,"Run another generator concurrently:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.yg)("p",null,"Await a Promise:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}iG.isMDXComponent=!0;const lG={toc:[]},uG="wrapper";function mG(e){let{components:n,...t}=e;return(0,s.yg)(uG,(0,p.A)({},lG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}mG.isMDXComponent=!0;const yG={toc:[]},dG="wrapper";function hG(e){let{components:n,...t}=e;return(0,s.yg)(dG,(0,p.A)({},yG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Cancel all listed tasks."),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}hG.isMDXComponent=!0;const gG={toc:[]},fG="wrapper";function DG(e){let{components:n,...t}=e;return(0,s.yg)(fG,(0,p.A)({},gG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to cancel."))}DG.isMDXComponent=!0;const MG={toc:[]},XG="wrapper";function _G(e){let{components:n,...t}=e;return(0,s.yg)(XG,(0,p.A)({},MG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the given value is a ","[Promise][promise]","."))}_G.isMDXComponent=!0;const wG={toc:[]},TG="wrapper";function CG(e){let{components:n,...t}=e;return(0,s.yg)(TG,(0,p.A)({},wG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A possible ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}CG.isMDXComponent=!0;const xG={toc:[]},AG="wrapper";function vG(e){let{components:n,...t}=e;return(0,s.yg)(AG,(0,p.A)({},xG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the given value is a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.yg)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}vG.isMDXComponent=!0;const LG={toc:[]},bG="wrapper";function NG(e){let{components:n,...t}=e;return(0,s.yg)(bG,(0,p.A)({},LG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A possible thread ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.yg)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}NG.isMDXComponent=!0;const kG={toc:[]},zG="wrapper";function PG(e){let{components:n,...t}=e;return(0,s.yg)(zG,(0,p.A)({},kG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}PG.isMDXComponent=!0;const IG={toc:[]},RG="wrapper";function WG(e){let{components:n,...t}=e;return(0,s.yg)(RG,(0,p.A)({},IG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause the current generator until all listed tasks are finished."))}WG.isMDXComponent=!0;const SG={toc:[]},BG="wrapper";function GG(e){let{components:n,...t}=e;return(0,s.yg)(BG,(0,p.A)({},SG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to join."))}GG.isMDXComponent=!0;const EG={toc:[]},OG="wrapper";function UG(e){let{components:n,...t}=e;return(0,s.yg)(OG,(0,p.A)({},EG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}UG.isMDXComponent=!0;const FG={toc:[]},VG="wrapper";function qG(e){let{components:n,...t}=e;return(0,s.yg)(VG,(0,p.A)({},FG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause the current generator until listed tasks are finished."))}qG.isMDXComponent=!0;const jG={toc:[]},HG="wrapper";function YG(e){let{components:n,...t}=e;return(0,s.yg)(HG,(0,p.A)({},jG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether we should wait for all tasks or for at least one."))}YG.isMDXComponent=!0;const QG={toc:[]},$G="wrapper";function KG(e){let{components:n,...t}=e;return(0,s.yg)($G,(0,p.A)({},QG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to join."))}KG.isMDXComponent=!0;const JG={toc:[]},ZG="wrapper";function eE(e){let{components:n,...t}=e;return(0,s.yg)(ZG,(0,p.A)({},JG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using an existing task:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"spawn(rect().opacity(1, 1));\n")),(0,s.yg)("p",null,"Using a generator function:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"spawn(function* () {\n  yield* rect().opacity(1, 1);\n  yield* waitFor('click');\n  yield* rect().opacity(0, 1);\n});\n")),(0,s.yg)("p",null,"Await the spawned task:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = spawn(rect().opacity(1, 1));\n// do some other things\nyield* join(task); // await the task\n")))}eE.isMDXComponent=!0;const nE={toc:[]},tE="wrapper";function oE(e){let{components:n,...t}=e;return(0,s.yg)(tE,(0,p.A)({},nE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given task concurrently."))}oE.isMDXComponent=!0;const pE={toc:[]},rE="wrapper";function sE(e){let{components:n,...t}=e;return(0,s.yg)(rE,(0,p.A)({},pE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a generator function or a task to run."))}sE.isMDXComponent=!0;const cE={toc:[]},aE="wrapper";function iE(e){let{components:n,...t}=e;return(0,s.yg)(aE,(0,p.A)({},cE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"From the perspective of the external generator, ",(0,s.yg)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.yg)("inlineCode",{parentName:"p"},"threads")," generator."))}iE.isMDXComponent=!0;const lE={toc:[]},uE="wrapper";function mE(e){let{components:n,...t}=e;return(0,s.yg)(uE,(0,p.A)({},lE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}mE.isMDXComponent=!0;const yE={toc:[]},dE="wrapper";function hE(e){let{components:n,...t}=e;return(0,s.yg)(dE,(0,p.A)({},yE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a context in which generators can be run concurrently."))}hE.isMDXComponent=!0;const gE={toc:[]},fE="wrapper";function DE(e){let{components:n,...t}=e;return(0,s.yg)(fE,(0,p.A)({},gE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns the generator to run."))}DE.isMDXComponent=!0;const ME={toc:[]},XE="wrapper";function _E(e){let{components:n,...t}=e;return(0,s.yg)(XE,(0,p.A)({},ME,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}_E.isMDXComponent=!0;const wE={toc:[]},TE="wrapper";function CE(e){let{components:n,...t}=e;return(0,s.yg)(TE,(0,p.A)({},wE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transitions between scenes."))}CE.isMDXComponent=!0;const xE={toc:[]},AE="wrapper";function vE(e){let{components:n,...t}=e;return(0,s.yg)(AE,(0,p.A)({},xE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that fades between the scenes."))}vE.isMDXComponent=!0;const LE={toc:[]},bE="wrapper";function NE(e){let{components:n,...t}=e;return(0,s.yg)(bE,(0,p.A)({},LE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}NE.isMDXComponent=!0;const kE={toc:[]},zE="wrapper";function PE(e){let{components:n,...t}=e;return(0,s.yg)(zE,(0,p.A)({},kE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that slides the scene in the given direction."))}PE.isMDXComponent=!0;const IE={toc:[]},RE="wrapper";function WE(e){let{components:n,...t}=e;return(0,s.yg)(RE,(0,p.A)({},IE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The direction in which to slide."))}WE.isMDXComponent=!0;const SE={toc:[]},BE="wrapper";function GE(e){let{components:n,...t}=e;return(0,s.yg)(BE,(0,p.A)({},SE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}GE.isMDXComponent=!0;const EE={toc:[]},OE="wrapper";function UE(e){let{components:n,...t}=e;return(0,s.yg)(OE,(0,p.A)({},EE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that slides the scene towards the given origin."))}UE.isMDXComponent=!0;const FE={toc:[]},VE="wrapper";function qE(e){let{components:n,...t}=e;return(0,s.yg)(VE,(0,p.A)({},FE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The origin towards which to slide."))}qE.isMDXComponent=!0;const jE={toc:[]},HE="wrapper";function YE(e){let{components:n,...t}=e;return(0,s.yg)(HE,(0,p.A)({},jE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}YE.isMDXComponent=!0;const QE={toc:[]},$E="wrapper";function KE(e){let{components:n,...t}=e;return(0,s.yg)($E,(0,p.A)({},QE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}KE.isMDXComponent=!0;const JE={toc:[]},ZE="wrapper";function eO(e){let{components:n,...t}=e;return(0,s.yg)(ZE,(0,p.A)({},JE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to use before the current scene is rendered."))}eO.isMDXComponent=!0;const nO={toc:[]},tO="wrapper";function oO(e){let{components:n,...t}=e;return(0,s.yg)(tO,(0,p.A)({},nO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to use before the previous scene is rendered."))}oO.isMDXComponent=!0;const pO={toc:[]},rO="wrapper";function sO(e){let{components:n,...t}=e;return(0,s.yg)(rO,(0,p.A)({},pO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the previous scene should be rendered on top."))}sO.isMDXComponent=!0;const cO={toc:[]},aO="wrapper";function iO(e){let{components:n,...t}=e;return(0,s.yg)(aO,(0,p.A)({},cO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that zooms in on a given area of the scene."))}iO.isMDXComponent=!0;const lO={toc:[]},uO="wrapper";function mO(e){let{components:n,...t}=e;return(0,s.yg)(uO,(0,p.A)({},lO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The area on which to zoom in."))}mO.isMDXComponent=!0;const yO={toc:[]},dO="wrapper";function hO(e){let{components:n,...t}=e;return(0,s.yg)(dO,(0,p.A)({},yO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}hO.isMDXComponent=!0;const gO={toc:[]},fO="wrapper";function DO(e){let{components:n,...t}=e;return(0,s.yg)(fO,(0,p.A)({},gO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that zooms out from a given area of the scene."))}DO.isMDXComponent=!0;const MO={toc:[]},XO="wrapper";function _O(e){let{components:n,...t}=e;return(0,s.yg)(XO,(0,p.A)({},MO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The area from which to zoom out."))}_O.isMDXComponent=!0;const wO={toc:[]},TO="wrapper";function CO(e){let{components:n,...t}=e;return(0,s.yg)(TO,(0,p.A)({},wO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}CO.isMDXComponent=!0;const xO={toc:[]},AO="wrapper";function vO(e){let{components:n,...t}=e;return(0,s.yg)(AO,(0,p.A)({},xO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolation and timing of tweens."))}vO.isMDXComponent=!0;const LO={toc:[]},bO="wrapper";function NO(e){let{components:n,...t}=e;return(0,s.yg)(bO,(0,p.A)({},LO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Any old key that is missing in ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.yg)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"})))}NO.isMDXComponent=!0;const kO={toc:[]},zO="wrapper";function PO(e){let{components:n,...t}=e;return(0,s.yg)(zO,(0,p.A)({},kO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A value matching the structure of from and to."))}PO.isMDXComponent=!0;const IO={toc:[]},RO="wrapper";function WO(e){let{components:n,...t}=e;return(0,s.yg)(RO,(0,p.A)({},IO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}WO.isMDXComponent=!0;const SO={toc:[]},BO="wrapper";function GO(e){let{components:n,...t}=e;return(0,s.yg)(BO,(0,p.A)({},SO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 0."))}GO.isMDXComponent=!0;const EO={toc:[]},OO="wrapper";function UO(e){let{components:n,...t}=e;return(0,s.yg)(OO,(0,p.A)({},EO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 1."))}UO.isMDXComponent=!0;const FO={toc:[]},VO="wrapper";function qO(e){let{components:n,...t}=e;return(0,s.yg)(VO,(0,p.A)({},FO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}qO.isMDXComponent=!0;const jO={toc:[]},HO="wrapper";function YO(e){let{components:n,...t}=e;return(0,s.yg)(HO,(0,p.A)({},jO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A value matching the structure of from and to."))}YO.isMDXComponent=!0;const QO={toc:[]},$O="wrapper";function KO(e){let{components:n,...t}=e;return(0,s.yg)($O,(0,p.A)({},QO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}KO.isMDXComponent=!0;const JO={toc:[]},ZO="wrapper";function eU(e){let{components:n,...t}=e;return(0,s.yg)(ZO,(0,p.A)({},JO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 0."))}eU.isMDXComponent=!0;const nU={toc:[]},tU="wrapper";function oU(e){let{components:n,...t}=e;return(0,s.yg)(tU,(0,p.A)({},nU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 1."))}oU.isMDXComponent=!0;const pU={toc:[]},rU="wrapper";function sU(e){let{components:n,...t}=e;return(0,s.yg)(rU,(0,p.A)({},pU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}sU.isMDXComponent=!0;const cU={toc:[]},aU="wrapper";function iU(e){let{components:n,...t}=e;return(0,s.yg)(aU,(0,p.A)({},cU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Complex types used in animations."))}iU.isMDXComponent=!0;const lU={toc:[]},uU="wrapper";function mU(e){let{components:n,...t}=e;return(0,s.yg)(uU,(0,p.A)({},lU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/BBox#expand"},(0,s.yg)("inlineCode",{parentName:"a"},"expand"))," instead."))}mU.isMDXComponent=!0;const yU={toc:[]},dU="wrapper";function hU(e){let{components:n,...t}=e;return(0,s.yg)(dU,(0,p.A)({},yU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Expand the bounding box to accommodate the given spacing."))}hU.isMDXComponent=!0;const gU={toc:[]},fU="wrapper";function DU(e){let{components:n,...t}=e;return(0,s.yg)(fU,(0,p.A)({},gU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to expand the bounding box by."))}DU.isMDXComponent=!0;const MU={toc:[]},XU="wrapper";function _U(e){let{components:n,...t}=e;return(0,s.yg)(XU,(0,p.A)({},MU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Expand the bounding box to accommodate the given spacing."))}_U.isMDXComponent=!0;const wU={toc:[]},TU="wrapper";function CU(e){let{components:n,...t}=e;return(0,s.yg)(TU,(0,p.A)({},wU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to expand the bounding box by."))}CU.isMDXComponent=!0;const xU={toc:[]},AU="wrapper";function vU(e){let{components:n,...t}=e;return(0,s.yg)(AU,(0,p.A)({},xU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.yg)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.yg)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.yg)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.yg)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.yg)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.yg)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}vU.isMDXComponent=!0;const LU={toc:[]},bU="wrapper";function NU(e){let{components:n,...t}=e;return(0,s.yg)(bU,(0,p.A)({},LU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the determinant of the matrix."))}NU.isMDXComponent=!0;const kU={toc:[]},zU="wrapper";function PU(e){let{components:n,...t}=e;return(0,s.yg)(zU,(0,p.A)({},kU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.yg)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", instead."))}PU.isMDXComponent=!0;const IU={toc:[]},RU="wrapper";function WU(e){let{components:n,...t}=e;return(0,s.yg)(RU,(0,p.A)({},IU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}WU.isMDXComponent=!0;const SU={toc:[]},BU="wrapper";function GU(e){let{components:n,...t}=e;return(0,s.yg)(BU,(0,p.A)({},SU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the inverse of the matrix."))}GU.isMDXComponent=!0;const EU={toc:[]},OU="wrapper";function UU(e){let{components:n,...t}=e;return(0,s.yg)(OU,(0,p.A)({},EU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}UU.isMDXComponent=!0;const FU={toc:[]},VU="wrapper";function qU(e){let{components:n,...t}=e;return(0,s.yg)(VU,(0,p.A)({},FU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}qU.isMDXComponent=!0;const jU={toc:[]},HU="wrapper";function YU(e){let{components:n,...t}=e;return(0,s.yg)(HU,(0,p.A)({},jU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the provided matrix to this matrix."))}YU.isMDXComponent=!0;const QU={toc:[]},$U="wrapper";function KU(e){let{components:n,...t}=e;return(0,s.yg)($U,(0,p.A)({},QU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to add"))}KU.isMDXComponent=!0;const JU={toc:[]},ZU="wrapper";function eF(e){let{components:n,...t}=e;return(0,s.yg)(ZU,(0,p.A)({},JU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}eF.isMDXComponent=!0;const nF={toc:[]},tF="wrapper";function oF(e){let{components:n,...t}=e;return(0,s.yg)(tF,(0,p.A)({},nF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}oF.isMDXComponent=!0;const pF={toc:[]},rF="wrapper";function sF(e){let{components:n,...t}=e;return(0,s.yg)(rF,(0,p.A)({},pF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the component vector to retrieve."))}sF.isMDXComponent=!0;const cF={toc:[]},aF="wrapper";function iF(e){let{components:n,...t}=e;return(0,s.yg)(aF,(0,p.A)({},cF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}iF.isMDXComponent=!0;const lF={toc:[]},uF="wrapper";function mF(e){let{components:n,...t}=e;return(0,s.yg)(uF,(0,p.A)({},lF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}mF.isMDXComponent=!0;const yF={toc:[]},dF="wrapper";function hF(e){let{components:n,...t}=e;return(0,s.yg)(dF,(0,p.A)({},yF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}hF.isMDXComponent=!0;const gF={toc:[]},fF="wrapper";function DF(e){let{components:n,...t}=e;return(0,s.yg)(fF,(0,p.A)({},gF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to multiply with"))}DF.isMDXComponent=!0;const MF={toc:[]},XF="wrapper";function _F(e){let{components:n,...t}=e;return(0,s.yg)(XF,(0,p.A)({},MF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}_F.isMDXComponent=!0;const wF={toc:[]},TF="wrapper";function CF(e){let{components:n,...t}=e;return(0,s.yg)(TF,(0,p.A)({},wF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}CF.isMDXComponent=!0;const xF={toc:[]},AF="wrapper";function vF(e){let{components:n,...t}=e;return(0,s.yg)(AF,(0,p.A)({},xF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value by which to scale each term"))}vF.isMDXComponent=!0;const LF={toc:[]},bF="wrapper";function NF(e){let{components:n,...t}=e;return(0,s.yg)(bF,(0,p.A)({},LF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}NF.isMDXComponent=!0;const kF={toc:[]},zF="wrapper";function PF(e){let{components:n,...t}=e;return(0,s.yg)(zF,(0,p.A)({},kF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}PF.isMDXComponent=!0;const IF={toc:[]},RF="wrapper";function WF(e){let{components:n,...t}=e;return(0,s.yg)(RF,(0,p.A)({},IF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}WF.isMDXComponent=!0;const SF={toc:[]},BF="wrapper";function GF(e){let{components:n,...t}=e;return(0,s.yg)(BF,(0,p.A)({},SF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The angle by which to rotate the matrix."))}GF.isMDXComponent=!0;const EF={toc:[]},OF="wrapper";function UF(e){let{components:n,...t}=e;return(0,s.yg)(OF,(0,p.A)({},EF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the angle is provided in degrees."))}UF.isMDXComponent=!0;const FF={toc:[]},VF="wrapper";function qF(e){let{components:n,...t}=e;return(0,s.yg)(VF,(0,p.A)({},FF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}qF.isMDXComponent=!0;const jF={toc:[]},HF="wrapper";function YF(e){let{components:n,...t}=e;return(0,s.yg)(HF,(0,p.A)({},jF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}YF.isMDXComponent=!0;const QF={toc:[]},$F="wrapper";function KF(e){let{components:n,...t}=e;return(0,s.yg)($F,(0,p.A)({},QF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the row to retrieve."))}KF.isMDXComponent=!0;const JF={toc:[]},ZF="wrapper";function eV(e){let{components:n,...t}=e;return(0,s.yg)(ZF,(0,p.A)({},JF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}eV.isMDXComponent=!0;const nV={toc:[]},tV="wrapper";function oV(e){let{components:n,...t}=e;return(0,s.yg)(tV,(0,p.A)({},nV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}oV.isMDXComponent=!0;const pV={toc:[]},rV="wrapper";function sV(e){let{components:n,...t}=e;return(0,s.yg)(rV,(0,p.A)({},pV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scale the x and y component vectors of the matrix."))}sV.isMDXComponent=!0;const cV={toc:[]},aV="wrapper";function iV(e){let{components:n,...t}=e;return(0,s.yg)(aV,(0,p.A)({},cV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The factor by which to scale the matrix"))}iV.isMDXComponent=!0;const lV={toc:[]},uV="wrapper";function mV(e){let{components:n,...t}=e;return(0,s.yg)(uV,(0,p.A)({},lV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}mV.isMDXComponent=!0;const yV={toc:[]},dV="wrapper";function hV(e){let{components:n,...t}=e;return(0,s.yg)(dV,(0,p.A)({},yV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}hV.isMDXComponent=!0;const gV={toc:[]},fV="wrapper";function DV(e){let{components:n,...t}=e;return(0,s.yg)(fV,(0,p.A)({},gV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subtract the provided matrix from this matrix."))}DV.isMDXComponent=!0;const MV={toc:[]},XV="wrapper";function _V(e){let{components:n,...t}=e;return(0,s.yg)(XV,(0,p.A)({},MV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to subract"))}_V.isMDXComponent=!0;const wV={toc:[]},TV="wrapper";function CV(e){let{components:n,...t}=e;return(0,s.yg)(TV,(0,p.A)({},wV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}CV.isMDXComponent=!0;const xV={toc:[]},AV="wrapper";function vV(e){let{components:n,...t}=e;return(0,s.yg)(AV,(0,p.A)({},xV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}vV.isMDXComponent=!0;const LV={toc:[]},bV="wrapper";function NV(e){let{components:n,...t}=e;return(0,s.yg)(bV,(0,p.A)({},LV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Translate the matrix by the dimensions of the provided vector."))}NV.isMDXComponent=!0;const kV={toc:[]},zV="wrapper";function PV(e){let{components:n,...t}=e;return(0,s.yg)(zV,(0,p.A)({},kV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector by which to translate the matrix"))}PV.isMDXComponent=!0;const IV={toc:[]},RV="wrapper";function WV(e){let{components:n,...t}=e;return(0,s.yg)(RV,(0,p.A)({},IV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a two-dimensional vector."))}WV.isMDXComponent=!0;const SV={toc:[]},BV="wrapper";function GV(e){let{components:n,...t}=e;return(0,s.yg)(BV,(0,p.A)({},SV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(0, 1)")))}GV.isMDXComponent=!0;const EV={toc:[]},OV="wrapper";function UV(e){let{components:n,...t}=e;return(0,s.yg)(OV,(0,p.A)({},EV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(-1, 1)")))}UV.isMDXComponent=!0;const FV={toc:[]},VV="wrapper";function qV(e){let{components:n,...t}=e;return(0,s.yg)(VV,(0,p.A)({},FV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(1, 1)")))}qV.isMDXComponent=!0;const jV={toc:[]},HV="wrapper";function YV(e){let{components:n,...t}=e;return(0,s.yg)(HV,(0,p.A)({},jV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(0, -1)")))}YV.isMDXComponent=!0;const QV={toc:[]},$V="wrapper";function KV(e){let{components:n,...t}=e;return(0,s.yg)($V,(0,p.A)({},QV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(-1, -1)")))}KV.isMDXComponent=!0;const JV={toc:[]},ZV="wrapper";function eq(e){let{components:n,...t}=e;return(0,s.yg)(ZV,(0,p.A)({},JV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(1, -1)")))}eq.isMDXComponent=!0;const nq={toc:[]},tq="wrapper";function oq(e){let{components:n,...t}=e;return(0,s.yg)(tq,(0,p.A)({},nq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned angle will be between -180 and 180 degrees."))}oq.isMDXComponent=!0;const pq={toc:[]},rq="wrapper";function sq(e){let{components:n,...t}=e;return(0,s.yg)(rq,(0,p.A)({},pq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}sq.isMDXComponent=!0;const cq={toc:[]},aq="wrapper";function iq(e){let{components:n,...t}=e;return(0,s.yg)(aq,(0,p.A)({},cq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}iq.isMDXComponent=!0;const lq={toc:[]},uq="wrapper";function mq(e){let{components:n,...t}=e;return(0,s.yg)(uq,(0,p.A)({},lq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.yg)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}mq.isMDXComponent=!0;const yq={toc:[]},dq="wrapper";function hq(e){let{components:n,...t}=e;return(0,s.yg)(dq,(0,p.A)({},yq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if two vectors are equal to each other."))}hq.isMDXComponent=!0;const gq={toc:[]},fq="wrapper";function Dq(e){let{components:n,...t}=e;return(0,s.yg)(fq,(0,p.A)({},gq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector to compare."))}Dq.isMDXComponent=!0;const Mq={toc:[]},Xq="wrapper";function _q(e){let{components:n,...t}=e;return(0,s.yg)(Xq,(0,p.A)({},Mq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The allowed error threshold when comparing the vectors."))}_q.isMDXComponent=!0;const wq={toc:[]},Tq="wrapper";function Cq(e){let{components:n,...t}=e;return(0,s.yg)(Tq,(0,p.A)({},wq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.yg)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}Cq.isMDXComponent=!0;const xq={toc:[]},Aq="wrapper";function vq(e){let{components:n,...t}=e;return(0,s.yg)(Aq,(0,p.A)({},xq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if two vectors are exactly equal to each other."))}vq.isMDXComponent=!0;const Lq={toc:[]},bq="wrapper";function Nq(e){let{components:n,...t}=e;return(0,s.yg)(bq,(0,p.A)({},Lq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector to compare."))}Nq.isMDXComponent=!0;const kq={toc:[]},zq="wrapper";function Pq(e){let{components:n,...t}=e;return(0,s.yg)(zq,(0,p.A)({},kq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotates the vector around a point by the provided angle."))}Pq.isMDXComponent=!0;const Iq={toc:[]},Rq="wrapper";function Wq(e){let{components:n,...t}=e;return(0,s.yg)(Rq,(0,p.A)({},Iq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The angle by which to rotate in degrees."))}Wq.isMDXComponent=!0;const Sq={toc:[]},Bq="wrapper";function Gq(e){let{components:n,...t}=e;return(0,s.yg)(Bq,(0,p.A)({},Sq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}Gq.isMDXComponent=!0;const Eq={toc:[]},Oq="wrapper";function Uq(e){let{components:n,...t}=e;return(0,s.yg)(Oq,(0,p.A)({},Eq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Helper function to create a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.yg)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}Uq.isMDXComponent=!0;const Fq={toc:[]},Vq="wrapper";function qq(e){let{components:n,...t}=e;return(0,s.yg)(Vq,(0,p.A)({},Fq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the point should get rotated\ncounterclockwise."))}qq.isMDXComponent=!0;const jq={toc:[]},Hq="wrapper";function Yq(e){let{components:n,...t}=e;return(0,s.yg)(Hq,(0,p.A)({},jq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}Yq.isMDXComponent=!0;const Qq={toc:[]},$q="wrapper";function Kq(e){let{components:n,...t}=e;return(0,s.yg)($q,(0,p.A)({},Qq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned angle will be between -180 and 180 degrees."))}Kq.isMDXComponent=!0;const Jq={toc:[]},Zq="wrapper";function ej(e){let{components:n,...t}=e;return(0,s.yg)(Zq,(0,p.A)({},Jq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}ej.isMDXComponent=!0;const nj={toc:[]},tj="wrapper";function oj(e){let{components:n,...t}=e;return(0,s.yg)(tj,(0,p.A)({},nj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x component of the vector."))}oj.isMDXComponent=!0;const pj={toc:[]},rj="wrapper";function sj(e){let{components:n,...t}=e;return(0,s.yg)(rj,(0,p.A)({},pj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y component of the vector."))}sj.isMDXComponent=!0;const cj={toc:[]},aj="wrapper";function ij(e){let{components:n,...t}=e;return(0,s.yg)(aj,(0,p.A)({},cj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This function is useful when used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.yg)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}ij.isMDXComponent=!0;const lj={toc:[]},uj="wrapper";function mj(e){let{components:n,...t}=e;return(0,s.yg)(uj,(0,p.A)({},lj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Animating an object in a circle around the origin"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}mj.isMDXComponent=!0;const yj={toc:[]},dj="wrapper";function hj(e){let{components:n,...t}=e;return(0,s.yg)(dj,(0,p.A)({},yj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotating an object around the point ",(0,s.yg)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}hj.isMDXComponent=!0;const gj={toc:[]},fj="wrapper";function Dj(e){let{components:n,...t}=e;return(0,s.yg)(fj,(0,p.A)({},gj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}Dj.isMDXComponent=!0;const Mj={toc:[]},Xj="wrapper";function _j(e){let{components:n,...t}=e;return(0,s.yg)(Xj,(0,p.A)({},Mj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}_j.isMDXComponent=!0;const wj={toc:[]},Tj="wrapper";function Cj(e){let{components:n,...t}=e;return(0,s.yg)(Tj,(0,p.A)({},wj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting vector."))}Cj.isMDXComponent=!0;const xj={toc:[]},Aj="wrapper";function vj(e){let{components:n,...t}=e;return(0,s.yg)(Aj,(0,p.A)({},xj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The target vector."))}vj.isMDXComponent=!0;const Lj={toc:[]},bj="wrapper";function Nj(e){let{components:n,...t}=e;return(0,s.yg)(bj,(0,p.A)({},Lj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t-value of the interpolation."))}Nj.isMDXComponent=!0;const kj={toc:[]},zj="wrapper";function Pj(e){let{components:n,...t}=e;return(0,s.yg)(zj,(0,p.A)({},kj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.yg)("inlineCode",{parentName:"p"},"false"),"."))}Pj.isMDXComponent=!0;const Ij={toc:[]},Rj="wrapper";function Wj(e){let{components:n,...t}=e;return(0,s.yg)(Rj,(0,p.A)({},Ij,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}Wj.isMDXComponent=!0;const Sj={toc:[]},Bj="wrapper";function Gj(e){let{components:n,...t}=e;return(0,s.yg)(Bj,(0,p.A)({},Sj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}Gj.isMDXComponent=!0;const Ej={toc:[]},Oj="wrapper";function Uj(e){let{components:n,...t}=e;return(0,s.yg)(Oj,(0,p.A)({},Ej,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x component of the vector."))}Uj.isMDXComponent=!0;const Fj={toc:[]},Vj="wrapper";function qj(e){let{components:n,...t}=e;return(0,s.yg)(Vj,(0,p.A)({},Fj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y component of the vector."))}qj.isMDXComponent=!0;const jj={toc:[]},Hj="wrapper";function Yj(e){let{components:n,...t}=e;return(0,s.yg)(Hj,(0,p.A)({},jj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same class as the one created by\n",(0,s.yg)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.yg)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}Yj.isMDXComponent=!0;const Qj={toc:[]},$j="wrapper";function Kj(e){let{components:n,...t}=e;return(0,s.yg)($j,(0,p.A)({},Qj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a color."))}Kj.isMDXComponent=!0;const Jj={toc:[]},Zj="wrapper";function eH(e){let{components:n,...t}=e;return(0,s.yg)(Zj,(0,p.A)({},Jj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}eH.isMDXComponent=!0;const nH={toc:[]},tH="wrapper";function oH(e){let{components:n,...t}=e;return(0,s.yg)(tH,(0,p.A)({},nH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert the given origin to a vector representing its offset."))}oH.isMDXComponent=!0;const pH={toc:[]},rH="wrapper";function sH(e){let{components:n,...t}=e;return(0,s.yg)(rH,(0,p.A)({},pH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The origin to convert."))}sH.isMDXComponent=!0;const cH={toc:[]},aH="wrapper";function iH(e){let{components:n,...t}=e;return(0,s.yg)(aH,(0,p.A)({},cH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"General utilities and helper functions."))}iH.isMDXComponent=!0;const lH={toc:[]},uH="wrapper";function mH(e){let{components:n,...t}=e;return(0,s.yg)(uH,(0,p.A)({},lH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}mH.isMDXComponent=!0;const yH={toc:[]},dH="wrapper";function hH(e){let{components:n,...t}=e;return(0,s.yg)(dH,(0,p.A)({},yH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}hH.isMDXComponent=!0;const gH={toc:[]},fH="wrapper";function DH(e){let{components:n,...t}=e;return(0,s.yg)(fH,(0,p.A)({},gH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}DH.isMDXComponent=!0;const MH={toc:[]},XH="wrapper";function _H(e){let{components:n,...t}=e;return(0,s.yg)(XH,(0,p.A)({},MH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}_H.isMDXComponent=!0;const wH={toc:[]},TH="wrapper";function CH(e){let{components:n,...t}=e;return(0,s.yg)(TH,(0,p.A)({},wH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}CH.isMDXComponent=!0;const xH={toc:[]},AH="wrapper";function vH(e){let{components:n,...t}=e;return(0,s.yg)(AH,(0,p.A)({},xH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}vH.isMDXComponent=!0;const LH={toc:[]},bH="wrapper";function NH(e){let{components:n,...t}=e;return(0,s.yg)(bH,(0,p.A)({},LH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}NH.isMDXComponent=!0;const kH={toc:[]},zH="wrapper";function PH(e){let{components:n,...t}=e;return(0,s.yg)(zH,(0,p.A)({},kH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}PH.isMDXComponent=!0;const IH={toc:[]},RH="wrapper";function WH(e){let{components:n,...t}=e;return(0,s.yg)(RH,(0,p.A)({},IH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}WH.isMDXComponent=!0;const SH={toc:[]},BH="wrapper";function GH(e){let{components:n,...t}=e;return(0,s.yg)(BH,(0,p.A)({},SH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Optional override for formatting stack traces"))}GH.isMDXComponent=!0;const EH={toc:[]},OH="wrapper";function UH(e){let{components:n,...t}=e;return(0,s.yg)(OH,(0,p.A)({},EH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create .stack property on a target object"))}UH.isMDXComponent=!0;const FH={toc:[]},VH="wrapper";function qH(e){let{components:n,...t}=e;return(0,s.yg)(VH,(0,p.A)({},FH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}qH.isMDXComponent=!0;const jH={toc:[]},HH="wrapper";function YH(e){let{components:n,...t}=e;return(0,s.yg)(HH,(0,p.A)({},jH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}YH.isMDXComponent=!0;const QH={toc:[]},$H="wrapper";function KH(e){let{components:n,...t}=e;return(0,s.yg)($H,(0,p.A)({},QH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}KH.isMDXComponent=!0;const JH={toc:[]},ZH="wrapper";function eY(e){let{components:n,...t}=e;return(0,s.yg)(ZH,(0,p.A)({},JH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}eY.isMDXComponent=!0;const nY={toc:[]},tY="wrapper";function oY(e){let{components:n,...t}=e;return(0,s.yg)(tY,(0,p.A)({},nY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}oY.isMDXComponent=!0;const pY={toc:[]},rY="wrapper";function sY(e){let{components:n,...t}=e;return(0,s.yg)(rY,(0,p.A)({},pY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}sY.isMDXComponent=!0;const cY={toc:[]},aY="wrapper";function iY(e){let{components:n,...t}=e;return(0,s.yg)(aY,(0,p.A)({},cY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}iY.isMDXComponent=!0;const lY={toc:[]},uY="wrapper";function mY(e){let{components:n,...t}=e;return(0,s.yg)(uY,(0,p.A)({},lY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}mY.isMDXComponent=!0;const yY={toc:[]},dY="wrapper";function hY(e){let{components:n,...t}=e;return(0,s.yg)(dY,(0,p.A)({},yY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}hY.isMDXComponent=!0;const gY={toc:[]},fY="wrapper";function DY(e){let{components:n,...t}=e;return(0,s.yg)(fY,(0,p.A)({},gY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Optional override for formatting stack traces"))}DY.isMDXComponent=!0;const MY={toc:[]},XY="wrapper";function _Y(e){let{components:n,...t}=e;return(0,s.yg)(XY,(0,p.A)({},MY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create .stack property on a target object"))}_Y.isMDXComponent=!0;const wY={toc:[]},TY="wrapper";function CY(e){let{components:n,...t}=e;return(0,s.yg)(TY,(0,p.A)({},wY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An array of the transformed references."))}CY.isMDXComponent=!0;const xY={toc:[]},AY="wrapper";function vY(e){let{components:n,...t}=e;return(0,s.yg)(AY,(0,p.A)({},xY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Maps the references in this group to a new array."))}vY.isMDXComponent=!0;const LY={toc:[]},bY="wrapper";function NY(e){let{components:n,...t}=e;return(0,s.yg)(bY,(0,p.A)({},LY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function to transform each reference."))}NY.isMDXComponent=!0;const kY={toc:[]},zY="wrapper";function PY(e){let{components:n,...t}=e;return(0,s.yg)(zY,(0,p.A)({},kY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}PY.isMDXComponent=!0;const IY={toc:[]},RY="wrapper";function WY(e){let{components:n,...t}=e;return(0,s.yg)(RY,(0,p.A)({},IY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant for converting degrees to radians"))}WY.isMDXComponent=!0;const SY={toc:[]},BY="wrapper";function GY(e){let{components:n,...t}=e;return(0,s.yg)(BY,(0,p.A)({},SY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}GY.isMDXComponent=!0;const EY={toc:[]},OY="wrapper";function UY(e){let{components:n,...t}=e;return(0,s.yg)(OY,(0,p.A)({},EY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant for converting radians to degrees"))}UY.isMDXComponent=!0;const FY={toc:[]},VY="wrapper";function qY(e){let{components:n,...t}=e;return(0,s.yg)(VY,(0,p.A)({},FY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.yg)("inlineCode",{parentName:"p"},"ref")," property of a node."))}qY.isMDXComponent=!0;const jY={toc:[]},HY="wrapper";function YY(e){let{components:n,...t}=e;return(0,s.yg)(HY,(0,p.A)({},jY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}YY.isMDXComponent=!0;const QY={toc:[]},$Y="wrapper";function KY(e){let{components:n,...t}=e;return(0,s.yg)($Y,(0,p.A)({},QY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array of references."))}KY.isMDXComponent=!0;const JY={toc:[]},ZY="wrapper";function eQ(e){let{components:n,...t}=e;return(0,s.yg)(ZY,(0,p.A)({},JY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.yg)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}eQ.isMDXComponent=!0;const nQ={toc:[]},tQ="wrapper";function oQ(e){let{components:n,...t}=e;return(0,s.yg)(tQ,(0,p.A)({},nQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}oQ.isMDXComponent=!0;const pQ={toc:[]},rQ="wrapper";function sQ(e){let{components:n,...t}=e;return(0,s.yg)(rQ,(0,p.A)({},pQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a group of references."))}sQ.isMDXComponent=!0;const cQ={toc:[]},aQ="wrapper";function iQ(e){let{components:n,...t}=e;return(0,s.yg)(aQ,(0,p.A)({},cQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is a shortcut for calling ",(0,s.yg)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}iQ.isMDXComponent=!0;const lQ={toc:[]},uQ="wrapper";function mQ(e){let{components:n,...t}=e;return(0,s.yg)(uQ,(0,p.A)({},lQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}mQ.isMDXComponent=!0;const yQ={toc:[]},dQ="wrapper";function hQ(e){let{components:n,...t}=e;return(0,s.yg)(dQ,(0,p.A)({},yQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Logs a debug message with an arbitrary payload."))}hQ.isMDXComponent=!0;const gQ={toc:[]},fQ="wrapper";function DQ(e){let{components:n,...t}=e;return(0,s.yg)(fQ,(0,p.A)({},gQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The payload to log"))}DQ.isMDXComponent=!0;const MQ={toc:[]},XQ="wrapper";function _Q(e){let{components:n,...t}=e;return(0,s.yg)(XQ,(0,p.A)({},MQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mark the given function as deprecated."))}_Q.isMDXComponent=!0;const wQ={toc:[]},TQ="wrapper";function CQ(e){let{components:n,...t}=e;return(0,s.yg)(TQ,(0,p.A)({},wQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function to deprecate."))}CQ.isMDXComponent=!0;const xQ={toc:[]},AQ="wrapper";function vQ(e){let{components:n,...t}=e;return(0,s.yg)(AQ,(0,p.A)({},xQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The log message."))}vQ.isMDXComponent=!0;const LQ={toc:[]},bQ="wrapper";function NQ(e){let{components:n,...t}=e;return(0,s.yg)(bQ,(0,p.A)({},LQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The optional log remarks."))}NQ.isMDXComponent=!0;const kQ={toc:[]},zQ="wrapper";function PQ(e){let{components:n,...t}=e;return(0,s.yg)(zQ,(0,p.A)({},kQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}PQ.isMDXComponent=!0;const IQ={toc:[]},RQ="wrapper";function WQ(e){let{components:n,...t}=e;return(0,s.yg)(RQ,(0,p.A)({},IQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mark the current scene as ready to transition out."))}WQ.isMDXComponent=!0;const SQ={toc:[]},BQ="wrapper";function GQ(e){let{components:n,...t}=e;return(0,s.yg)(BQ,(0,p.A)({},SQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}GQ.isMDXComponent=!0;const EQ={toc:[]},OQ="wrapper";function UQ(e){let{components:n,...t}=e;return(0,s.yg)(OQ,(0,p.A)({},EQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.yg)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}UQ.isMDXComponent=!0;const FQ={toc:[]},VQ="wrapper";function qQ(e){let{components:n,...t}=e;return(0,s.yg)(VQ,(0,p.A)({},FQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}qQ.isMDXComponent=!0;const jQ={toc:[]},HQ="wrapper";function YQ(e){let{components:n,...t}=e;return(0,s.yg)(HQ,(0,p.A)({},jQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}YQ.isMDXComponent=!0;const QQ={toc:[]},$Q="wrapper";function KQ(e){let{components:n,...t}=e;return(0,s.yg)($Q,(0,p.A)({},QQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The length of the array."))}KQ.isMDXComponent=!0;const JQ={toc:[]},ZQ="wrapper";function e$(e){let{components:n,...t}=e;return(0,s.yg)(ZQ,(0,p.A)({},JQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}e$.isMDXComponent=!0;const n$={toc:[]},t$="wrapper";function o$(e){let{components:n,...t}=e;return(0,s.yg)(t$,(0,p.A)({},n$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}o$.isMDXComponent=!0;const p$={toc:[]},r$="wrapper";function s$(e){let{components:n,...t}=e;return(0,s.yg)(r$,(0,p.A)({},p$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}s$.isMDXComponent=!0;const c$={toc:[]},a$="wrapper";function i$(e){let{components:n,...t}=e;return(0,s.yg)(a$,(0,p.A)({},c$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}i$.isMDXComponent=!0;const l$={toc:[]},u$="wrapper";function m$(e){let{components:n,...t}=e;return(0,s.yg)(u$,(0,p.A)({},l$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}m$.isMDXComponent=!0;const y$={toc:[]},d$="wrapper";function h$(e){let{components:n,...t}=e;return(0,s.yg)(d$,(0,p.A)({},y$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}h$.isMDXComponent=!0;const g$={toc:[]},f$="wrapper";function D$(e){let{components:n,...t}=e;return(0,s.yg)(f$,(0,p.A)({},g$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}D$.isMDXComponent=!0;const M$={toc:[]},X$="wrapper";function _$(e){let{components:n,...t}=e;return(0,s.yg)(X$,(0,p.A)({},M$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}_$.isMDXComponent=!0;const w$={toc:[]},T$="wrapper";function C$(e){let{components:n,...t}=e;return(0,s.yg)(T$,(0,p.A)({},w$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value by which to increment or decrement."))}C$.isMDXComponent=!0;const x$={toc:[]},A$="wrapper";function v$(e){let{components:n,...t}=e;return(0,s.yg)(A$,(0,p.A)({},x$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}v$.isMDXComponent=!0;const L$={toc:[]},b$="wrapper";function N$(e){let{components:n,...t}=e;return(0,s.yg)(b$,(0,p.A)({},L$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function that will be provided the context before render."))}N$.isMDXComponent=!0;const k$={toc:[]},z$="wrapper";function P$(e){let{components:n,...t}=e;return(0,s.yg)(z$,(0,p.A)({},k$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}P$.isMDXComponent=!0;const I$={toc:[]},R$="wrapper";function W$(e){let{components:n,...t}=e;return(0,s.yg)(R$,(0,p.A)({},I$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function that will be provided the context after render."))}W$.isMDXComponent=!0;const S$={toc:[]},B$="wrapper";function G$(e){let{components:n,...t}=e;return(0,s.yg)(B$,(0,p.A)({},S$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}G$.isMDXComponent=!0;const E$={toc:[]},O$="wrapper";function U$(e){let{components:n,...t}=e;return(0,s.yg)(O$,(0,p.A)({},E$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}U$.isMDXComponent=!0;const F$={toc:[]},V$="wrapper";function q$(e){let{components:n,...t}=e;return(0,s.yg)(V$,(0,p.A)({},F$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the event in seconds."))}q$.isMDXComponent=!0;const j$={toc:[]},H$="wrapper";function Y$(e){let{components:n,...t}=e;return(0,s.yg)(H$,(0,p.A)({},j$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Register a time event and get its duration in seconds."))}Y$.isMDXComponent=!0;const Q$={toc:[]},$$="wrapper";function K$(e){let{components:n,...t}=e;return(0,s.yg)($$,(0,p.A)({},Q$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the event."))}K$.isMDXComponent=!0;const J$={toc:[]},Z$="wrapper";function eK(e){let{components:n,...t}=e;return(0,s.yg)(Z$,(0,p.A)({},J$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the playback status."))}eK.isMDXComponent=!0;const nK={toc:[]},tK="wrapper";function oK(e){let{components:n,...t}=e;return(0,s.yg)(tK,(0,p.A)({},nK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the random number generator for the current scene."))}oK.isMDXComponent=!0;const pK={toc:[]},rK="wrapper";function sK(e){let{components:n,...t}=e;return(0,s.yg)(rK,(0,p.A)({},pK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the random number generator for the given seed."))}sK.isMDXComponent=!0;const cK={toc:[]},aK="wrapper";function iK(e){let{components:n,...t}=e;return(0,s.yg)(aK,(0,p.A)({},cK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The seed for the generator."))}iK.isMDXComponent=!0;const lK={toc:[]},uK="wrapper";function mK(e){let{components:n,...t}=e;return(0,s.yg)(uK,(0,p.A)({},lK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}mK.isMDXComponent=!0;const yK={toc:[]},dK="wrapper";function hK(e){let{components:n,...t}=e;return(0,s.yg)(dK,(0,p.A)({},yK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the current scene."))}hK.isMDXComponent=!0;const gK={toc:[]},fK="wrapper";function DK(e){let{components:n,...t}=e;return(0,s.yg)(fK,(0,p.A)({},gK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the current thread."))}DK.isMDXComponent=!0;const MK={toc:[]},XK="wrapper";function _K(e){let{components:n,...t}=e;return(0,s.yg)(XK,(0,p.A)({},MK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.yg)("inlineCode",{parentName:"a"},"waitFor")),"."))}_K.isMDXComponent=!0;const wK={toc:[]},TK="wrapper";function CK(e){let{components:n,...t}=e;return(0,s.yg)(TK,(0,p.A)({},wK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}CK.isMDXComponent=!0;const xK={toc:[]},AK="wrapper";function vK(e){let{components:n,...t}=e;return(0,s.yg)(AK,(0,p.A)({},xK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real time since the start of the animation."))}vK.isMDXComponent=!0;const LK={toc:[]},bK="wrapper";function NK(e){let{components:n,...t}=e;return(0,s.yg)(bK,(0,p.A)({},LK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This rewrites a remote url like ",(0,s.yg)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.yg)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}NK.isMDXComponent=!0;const kK={toc:[]},zK="wrapper";function PK(e){let{components:n,...t}=e;return(0,s.yg)(zK,(0,p.A)({},kK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Route the given url through a local proxy."))}PK.isMDXComponent=!0;const IK={toc:[]},RK="wrapper";function WK(e){let{components:n,...t}=e;return(0,s.yg)(RK,(0,p.A)({},IK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}WK.isMDXComponent=!0;const SK={toc:[]},BK="wrapper";function GK(e){let{components:n,...t}=e;return(0,s.yg)(BK,(0,p.A)({},SK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}GK.isMDXComponent=!0;const EK={toc:[]},OK="wrapper";function UK(e){let{components:n,...t}=e;return(0,s.yg)(OK,(0,p.A)({},EK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}UK.isMDXComponent=!0;const FK={toc:[]},VK="wrapper";function qK(e){let{components:n,...t}=e;return(0,s.yg)(VK,(0,p.A)({},FK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}qK.isMDXComponent=!0;const jK={toc:[]},HK="wrapper";function YK(e){let{components:n,...t}=e;return(0,s.yg)(HK,(0,p.A)({},jK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}YK.isMDXComponent=!0;const QK={toc:[]},$K="wrapper";function KK(e){let{components:n,...t}=e;return(0,s.yg)($K,(0,p.A)({},QK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}KK.isMDXComponent=!0;const JK={toc:[]},ZK="wrapper";function eJ(e){let{components:n,...t}=e;return(0,s.yg)(ZK,(0,p.A)({},JK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}eJ.isMDXComponent=!0;const nJ={toc:[]},tJ="wrapper";function oJ(e){let{components:n,...t}=e;return(0,s.yg)(tJ,(0,p.A)({},nJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}oJ.isMDXComponent=!0;const pJ={toc:[]},rJ="wrapper";function sJ(e){let{components:n,...t}=e;return(0,s.yg)(rJ,(0,p.A)({},pJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}sJ.isMDXComponent=!0;const cJ={toc:[]},aJ="wrapper";function iJ(e){let{components:n,...t}=e;return(0,s.yg)(aJ,(0,p.A)({},cJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}iJ.isMDXComponent=!0;const lJ={toc:[]},uJ="wrapper";function mJ(e){let{components:n,...t}=e;return(0,s.yg)(uJ,(0,p.A)({},lJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}mJ.isMDXComponent=!0;const yJ={toc:[]},dJ="wrapper";function hJ(e){let{components:n,...t}=e;return(0,s.yg)(dJ,(0,p.A)({},yJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}hJ.isMDXComponent=!0;const gJ={toc:[]},fJ="wrapper";function DJ(e){let{components:n,...t}=e;return(0,s.yg)(fJ,(0,p.A)({},gJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom highlighters used by the Code node."))}DJ.isMDXComponent=!0;const MJ={toc:[]},XJ="wrapper";function _J(e){let{components:n,...t}=e;return(0,s.yg)(XJ,(0,p.A)({},MJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Highlights the code at the given index."))}_J.isMDXComponent=!0;const wJ={toc:[]},TJ="wrapper";function CJ(e){let{components:n,...t}=e;return(0,s.yg)(TJ,(0,p.A)({},wJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the code to highlight."))}CJ.isMDXComponent=!0;const xJ={toc:[]},AJ="wrapper";function vJ(e){let{components:n,...t}=e;return(0,s.yg)(AJ,(0,p.A)({},xJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#prepare"},(0,s.yg)("inlineCode",{parentName:"a"},"prepare")),"."))}vJ.isMDXComponent=!0;const LJ={toc:[]},bJ="wrapper";function NJ(e){let{components:n,...t}=e;return(0,s.yg)(bJ,(0,p.A)({},LJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.yg)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.yg)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}NJ.isMDXComponent=!0;const kJ={toc:[]},zJ="wrapper";function PJ(e){let{components:n,...t}=e;return(0,s.yg)(zJ,(0,p.A)({},kJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializes the highlighter."))}PJ.isMDXComponent=!0;const IJ={toc:[]},RJ="wrapper";function WJ(e){let{components:n,...t}=e;return(0,s.yg)(RJ,(0,p.A)({},IJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#highlight"},(0,s.yg)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}WJ.isMDXComponent=!0;const SJ={toc:[]},BJ="wrapper";function GJ(e){let{components:n,...t}=e;return(0,s.yg)(BJ,(0,p.A)({},SJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepares the code for highlighting."))}GJ.isMDXComponent=!0;const EJ={toc:[]},OJ="wrapper";function UJ(e){let{components:n,...t}=e;return(0,s.yg)(OJ,(0,p.A)({},EJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to prepare."))}UJ.isMDXComponent=!0;const FJ={toc:[]},VJ="wrapper";function qJ(e){let{components:n,...t}=e;return(0,s.yg)(VJ,(0,p.A)({},FJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}qJ.isMDXComponent=!0;const jJ={toc:[]},HJ="wrapper";function YJ(e){let{components:n,...t}=e;return(0,s.yg)(HJ,(0,p.A)({},jJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tokenize the code."))}YJ.isMDXComponent=!0;const QJ={toc:[]},$J="wrapper";function KJ(e){let{components:n,...t}=e;return(0,s.yg)($J,(0,p.A)({},QJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}KJ.isMDXComponent=!0;const JJ={toc:[]},ZJ="wrapper";function eZ(e){let{components:n,...t}=e;return(0,s.yg)(ZJ,(0,p.A)({},JJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}eZ.isMDXComponent=!0;const nZ={toc:[]},tZ="wrapper";function oZ(e){let{components:n,...t}=e;return(0,s.yg)(tZ,(0,p.A)({},nZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom highlighters used by the Code node."))}oZ.isMDXComponent=!0;const pZ={toc:[]},rZ="wrapper";function sZ(e){let{components:n,...t}=e;return(0,s.yg)(rZ,(0,p.A)({},pZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Highlights the code at the given index."))}sZ.isMDXComponent=!0;const cZ={toc:[]},aZ="wrapper";function iZ(e){let{components:n,...t}=e;return(0,s.yg)(aZ,(0,p.A)({},cZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the code to highlight."))}iZ.isMDXComponent=!0;const lZ={toc:[]},uZ="wrapper";function mZ(e){let{components:n,...t}=e;return(0,s.yg)(uZ,(0,p.A)({},lZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#prepare"},(0,s.yg)("inlineCode",{parentName:"a"},"prepare")),"."))}mZ.isMDXComponent=!0;const yZ={toc:[]},dZ="wrapper";function hZ(e){let{components:n,...t}=e;return(0,s.yg)(dZ,(0,p.A)({},yZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.yg)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.yg)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}hZ.isMDXComponent=!0;const gZ={toc:[]},fZ="wrapper";function DZ(e){let{components:n,...t}=e;return(0,s.yg)(fZ,(0,p.A)({},gZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializes the highlighter."))}DZ.isMDXComponent=!0;const MZ={toc:[]},XZ="wrapper";function _Z(e){let{components:n,...t}=e;return(0,s.yg)(XZ,(0,p.A)({},MZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#highlight"},(0,s.yg)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}_Z.isMDXComponent=!0;const wZ={toc:[]},TZ="wrapper";function CZ(e){let{components:n,...t}=e;return(0,s.yg)(TZ,(0,p.A)({},wZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepares the code for highlighting."))}CZ.isMDXComponent=!0;const xZ={toc:[]},AZ="wrapper";function vZ(e){let{components:n,...t}=e;return(0,s.yg)(AZ,(0,p.A)({},xZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to prepare."))}vZ.isMDXComponent=!0;const LZ={toc:[]},bZ="wrapper";function NZ(e){let{components:n,...t}=e;return(0,s.yg)(bZ,(0,p.A)({},LZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}NZ.isMDXComponent=!0;const kZ={toc:[]},zZ="wrapper";function PZ(e){let{components:n,...t}=e;return(0,s.yg)(zZ,(0,p.A)({},kZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tokenize the code."))}PZ.isMDXComponent=!0;const IZ={toc:[]},RZ="wrapper";function WZ(e){let{components:n,...t}=e;return(0,s.yg)(RZ,(0,p.A)({},IZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}WZ.isMDXComponent=!0;const SZ={toc:[]},BZ="wrapper";function GZ(e){let{components:n,...t}=e;return(0,s.yg)(BZ,(0,p.A)({},SZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}GZ.isMDXComponent=!0;const EZ={toc:[]},OZ="wrapper";function UZ(e){let{components:n,...t}=e;return(0,s.yg)(OZ,(0,p.A)({},EZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the cache used by the highlighter."))}UZ.isMDXComponent=!0;const FZ={toc:[]},VZ="wrapper";function qZ(e){let{components:n,...t}=e;return(0,s.yg)(VZ,(0,p.A)({},FZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes the result of a highlight operation."))}qZ.isMDXComponent=!0;const jZ={toc:[]},HZ="wrapper";function YZ(e){let{components:n,...t}=e;return(0,s.yg)(HZ,(0,p.A)({},jZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the code at the given index."))}YZ.isMDXComponent=!0;const QZ={toc:[]},$Z="wrapper";function KZ(e){let{components:n,...t}=e;return(0,s.yg)($Z,(0,p.A)({},QZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This should be used to skip to the end of the currently highlighted token.\nThe returned style will be used for the skipped characters, and they will\nbe drawn as one continuous string keeping emojis and ligatures intact."),(0,s.yg)("p",null,"The returned value is the number of characters to skip ahead, not the\nindex of the end of the token."))}KZ.isMDXComponent=!0;const JZ={toc:[]},ZZ="wrapper";function e0(e){let{components:n,...t}=e;return(0,s.yg)(ZZ,(0,p.A)({},JZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of characters to skip ahead."))}e0.isMDXComponent=!0;const n0={toc:[]},t0="wrapper";function o0(e){let{components:n,...t}=e;return(0,s.yg)(t0,(0,p.A)({},n0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that compares two code snippets and returns a list of\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeTag"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeTag")),"s describing a transition between them."))}o0.isMDXComponent=!0;const p0={toc:[]},r0="wrapper";function s0(e){let{components:n,...t}=e;return(0,s.yg)(r0,(0,p.A)({},p0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default diffing function utilizing ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#patienceDiff"},(0,s.yg)("inlineCode",{parentName:"a"},"patienceDiff")),"."))}s0.isMDXComponent=!0;const c0={toc:[]},a0="wrapper";function i0(e){let{components:n,...t}=e;return(0,s.yg)(a0,(0,p.A)({},c0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The original code scope."))}i0.isMDXComponent=!0;const l0={toc:[]},u0="wrapper";function m0(e){let{components:n,...t}=e;return(0,s.yg)(u0,(0,p.A)({},l0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new code scope."))}m0.isMDXComponent=!0;const y0={toc:[]},d0="wrapper";function h0(e){let{components:n,...t}=e;return(0,s.yg)(d0,(0,p.A)({},y0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The inherited tokenizer to use."))}h0.isMDXComponent=!0;const g0={toc:[]},f0="wrapper";function D0(e){let{components:n,...t}=e;return(0,s.yg)(f0,(0,p.A)({},g0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default tokenizer function used by ownerless code signals."))}D0.isMDXComponent=!0;const M0={toc:[]},X0="wrapper";function _0(e){let{components:n,...t}=e;return(0,s.yg)(X0,(0,p.A)({},M0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}_0.isMDXComponent=!0;const w0={toc:[]},T0="wrapper";function C0(e){let{components:n,...t}=e;return(0,s.yg)(T0,(0,p.A)({},w0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This function will try to preserve the original fragments, resolving them\nonly if they overlap with the range."))}C0.isMDXComponent=!0;const x0={toc:[]},A0="wrapper";function v0(e){let{components:n,...t}=e;return(0,s.yg)(A0,(0,p.A)({},x0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A tuple containing the transformed fragments and the index of the\nisolated fragment within."))}v0.isMDXComponent=!0;const L0={toc:[]},b0="wrapper";function N0(e){let{components:n,...t}=e;return(0,s.yg)(b0,(0,p.A)({},L0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transform the fragments to isolate the given range into its own fragment."))}N0.isMDXComponent=!0;const k0={toc:[]},z0="wrapper";function P0(e){let{components:n,...t}=e;return(0,s.yg)(z0,(0,p.A)({},k0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The range to extract."))}P0.isMDXComponent=!0;const I0={toc:[]},R0="wrapper";function W0(e){let{components:n,...t}=e;return(0,s.yg)(R0,(0,p.A)({},I0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The fragments to transform."))}W0.isMDXComponent=!0;const S0={toc:[]},B0="wrapper";function G0(e){let{components:n,...t}=e;return(0,s.yg)(B0,(0,p.A)({},S0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all code ranges that match the given pattern."))}G0.isMDXComponent=!0;const E0={toc:[]},O0="wrapper";function U0(e){let{components:n,...t}=e;return(0,s.yg)(O0,(0,p.A)({},E0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to search in."))}U0.isMDXComponent=!0;const F0={toc:[]},V0="wrapper";function q0(e){let{components:n,...t}=e;return(0,s.yg)(V0,(0,p.A)({},F0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to search for."))}q0.isMDXComponent=!0;const j0={toc:[]},H0="wrapper";function Y0(e){let{components:n,...t}=e;return(0,s.yg)(H0,(0,p.A)({},j0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional limit on the number of ranges to find."))}Y0.isMDXComponent=!0;const Q0={toc:[]},$0="wrapper";function K0(e){let{components:n,...t}=e;return(0,s.yg)($0,(0,p.A)({},Q0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}K0.isMDXComponent=!0;const J0={toc:[]},Z0="wrapper";function e2(e){let{components:n,...t}=e;return(0,s.yg)(Z0,(0,p.A)({},J0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents an insertion of code."))}e2.isMDXComponent=!0;const n2={toc:[]},t2="wrapper";function o2(e){let{components:n,...t}=e;return(0,s.yg)(t2,(0,p.A)({},n2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to insert."))}o2.isMDXComponent=!0;const p2={toc:[]},r2="wrapper";function s2(e){let{components:n,...t}=e;return(0,s.yg)(r2,(0,p.A)({},p2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code range that spans the given lines."))}s2.isMDXComponent=!0;const c2={toc:[]},a2="wrapper";function i2(e){let{components:n,...t}=e;return(0,s.yg)(a2,(0,p.A)({},c2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line from which the range starts."))}i2.isMDXComponent=!0;const l2={toc:[]},u2="wrapper";function m2(e){let{components:n,...t}=e;return(0,s.yg)(u2,(0,p.A)({},l2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the range ends. If omitted, the range will\ncover only one line."))}m2.isMDXComponent=!0;const y2={toc:[]},d2="wrapper";function h2(e){let{components:n,...t}=e;return(0,s.yg)(d2,(0,p.A)({},y2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Performs a patience diff on two arrays of strings, returning an object\ncontaining the lines that were deleted, inserted, and potentially moved\nlines. The plus parameter can result in a significant performance hit due\nto additional Longest Common Substring searches."))}h2.isMDXComponent=!0;const g2={toc:[]},f2="wrapper";function D2(e){let{components:n,...t}=e;return(0,s.yg)(f2,(0,p.A)({},g2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The original array of strings"))}D2.isMDXComponent=!0;const M2={toc:[]},X2="wrapper";function _2(e){let{components:n,...t}=e;return(0,s.yg)(X2,(0,p.A)({},M2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new array of strings"))}_2.isMDXComponent=!0;const w2={toc:[]},T2="wrapper";function C2(e){let{components:n,...t}=e;return(0,s.yg)(T2,(0,p.A)({},w2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a custom selection range."))}C2.isMDXComponent=!0;const x2={toc:[]},A2="wrapper";function v2(e){let{components:n,...t}=e;return(0,s.yg)(A2,(0,p.A)({},x2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the selection starts."))}v2.isMDXComponent=!0;const L2={toc:[]},b2="wrapper";function N2(e){let{components:n,...t}=e;return(0,s.yg)(b2,(0,p.A)({},L2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the selection starts."))}N2.isMDXComponent=!0;const k2={toc:[]},z2="wrapper";function P2(e){let{components:n,...t}=e;return(0,s.yg)(z2,(0,p.A)({},k2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the selection ends."))}P2.isMDXComponent=!0;const I2={toc:[]},R2="wrapper";function W2(e){let{components:n,...t}=e;return(0,s.yg)(R2,(0,p.A)({},I2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the selection ends."))}W2.isMDXComponent=!0;const S2={toc:[]},B2="wrapper";function G2(e){let{components:n,...t}=e;return(0,s.yg)(B2,(0,p.A)({},S2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}G2.isMDXComponent=!0;const E2={toc:[]},O2="wrapper";function U2(e){let{components:n,...t}=e;return(0,s.yg)(O2,(0,p.A)({},E2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents a removal of code."))}U2.isMDXComponent=!0;const F2={toc:[]},V2="wrapper";function q2(e){let{components:n,...t}=e;return(0,s.yg)(V2,(0,p.A)({},F2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to remove."))}q2.isMDXComponent=!0;const j2={toc:[]},H2="wrapper";function Y2(e){let{components:n,...t}=e;return(0,s.yg)(H2,(0,p.A)({},j2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}Y2.isMDXComponent=!0;const Q2={toc:[]},$2="wrapper";function K2(e){let{components:n,...t}=e;return(0,s.yg)($2,(0,p.A)({},Q2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents a change from one piece of code to\nanother."))}K2.isMDXComponent=!0;const J2={toc:[]},Z2="wrapper";function e4(e){let{components:n,...t}=e;return(0,s.yg)(Z2,(0,p.A)({},J2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to change from."))}e4.isMDXComponent=!0;const n4={toc:[]},t4="wrapper";function o4(e){let{components:n,...t}=e;return(0,s.yg)(t4,(0,p.A)({},n4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to change to."))}o4.isMDXComponent=!0;const p4={toc:[]},r4="wrapper";function s4(e){let{components:n,...t}=e;return(0,s.yg)(r4,(0,p.A)({},p4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code range that highlights the given word."))}s4.isMDXComponent=!0;const c4={toc:[]},a4="wrapper";function i4(e){let{components:n,...t}=e;return(0,s.yg)(a4,(0,p.A)({},c4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the word appears."))}i4.isMDXComponent=!0;const l4={toc:[]},u4="wrapper";function m4(e){let{components:n,...t}=e;return(0,s.yg)(u4,(0,p.A)({},l4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the word starts."))}m4.isMDXComponent=!0;const y4={toc:[]},d4="wrapper";function h4(e){let{components:n,...t}=e;return(0,s.yg)(d4,(0,p.A)({},y4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The length of the word. If omitted, the range will cover the\nrest of the line."))}h4.isMDXComponent=!0;const g4={toc:[]},f4="wrapper";function D4(e){let{components:n,...t}=e;return(0,s.yg)(f4,(0,p.A)({},g4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}D4.isMDXComponent=!0;const M4={toc:[]},X4="wrapper";function _4(e){let{components:n,...t}=e;return(0,s.yg)(X4,(0,p.A)({},M4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}_4.isMDXComponent=!0;const w4={toc:[]},T4="wrapper";function C4(e){let{components:n,...t}=e;return(0,s.yg)(T4,(0,p.A)({},w4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}C4.isMDXComponent=!0;const x4={toc:[]},A4="wrapper";function v4(e){let{components:n,...t}=e;return(0,s.yg)(A4,(0,p.A)({},x4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}v4.isMDXComponent=!0;const L4={toc:[]},b4="wrapper";function N4(e){let{components:n,...t}=e;return(0,s.yg)(b4,(0,p.A)({},L4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}N4.isMDXComponent=!0;const k4={toc:[]},z4="wrapper";function P4(e){let{components:n,...t}=e;return(0,s.yg)(z4,(0,p.A)({},k4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}P4.isMDXComponent=!0;const I4={toc:[]},R4="wrapper";function W4(e){let{components:n,...t}=e;return(0,s.yg)(R4,(0,p.A)({},I4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}W4.isMDXComponent=!0;const S4={toc:[]},B4="wrapper";function G4(e){let{components:n,...t}=e;return(0,s.yg)(B4,(0,p.A)({},S4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}G4.isMDXComponent=!0;const E4={toc:[]},O4="wrapper";function U4(e){let{components:n,...t}=e;return(0,s.yg)(O4,(0,p.A)({},E4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}U4.isMDXComponent=!0;const F4={toc:[]},V4="wrapper";function q4(e){let{components:n,...t}=e;return(0,s.yg)(V4,(0,p.A)({},F4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}q4.isMDXComponent=!0;const j4={toc:[]},H4="wrapper";function Y4(e){let{components:n,...t}=e;return(0,s.yg)(H4,(0,p.A)({},j4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Y4.isMDXComponent=!0;const Q4={toc:[]},$4="wrapper";function K4(e){let{components:n,...t}=e;return(0,s.yg)($4,(0,p.A)({},Q4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}K4.isMDXComponent=!0;const J4={toc:[]},Z4="wrapper";function e8(e){let{components:n,...t}=e;return(0,s.yg)(Z4,(0,p.A)({},J4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}e8.isMDXComponent=!0;const n8={toc:[]},t8="wrapper";function o8(e){let{components:n,...t}=e;return(0,s.yg)(t8,(0,p.A)({},n8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}o8.isMDXComponent=!0;const p8={toc:[]},r8="wrapper";function s8(e){let{components:n,...t}=e;return(0,s.yg)(r8,(0,p.A)({},p8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}s8.isMDXComponent=!0;const c8={toc:[]},a8="wrapper";function i8(e){let{components:n,...t}=e;return(0,s.yg)(a8,(0,p.A)({},c8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}i8.isMDXComponent=!0;const l8={toc:[]},u8="wrapper";function m8(e){let{components:n,...t}=e;return(0,s.yg)(u8,(0,p.A)({},l8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}m8.isMDXComponent=!0;const y8={toc:[]},d8="wrapper";function h8(e){let{components:n,...t}=e;return(0,s.yg)(d8,(0,p.A)({},y8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}h8.isMDXComponent=!0;const g8={toc:[]},f8="wrapper";function D8(e){let{components:n,...t}=e;return(0,s.yg)(f8,(0,p.A)({},g8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}D8.isMDXComponent=!0;const M8={toc:[]},X8="wrapper";function _8(e){let{components:n,...t}=e;return(0,s.yg)(X8,(0,p.A)({},M8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}_8.isMDXComponent=!0;const w8={toc:[]},T8="wrapper";function C8(e){let{components:n,...t}=e;return(0,s.yg)(T8,(0,p.A)({},w8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}C8.isMDXComponent=!0;const x8={toc:[]},A8="wrapper";function v8(e){let{components:n,...t}=e;return(0,s.yg)(A8,(0,p.A)({},x8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}v8.isMDXComponent=!0;const L8={toc:[]},b8="wrapper";function N8(e){let{components:n,...t}=e;return(0,s.yg)(b8,(0,p.A)({},L8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}N8.isMDXComponent=!0;const k8={toc:[]},z8="wrapper";function P8(e){let{components:n,...t}=e;return(0,s.yg)(z8,(0,p.A)({},k8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}P8.isMDXComponent=!0;const I8={toc:[]},R8="wrapper";function W8(e){let{components:n,...t}=e;return(0,s.yg)(R8,(0,p.A)({},I8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}W8.isMDXComponent=!0;const S8={toc:[]},B8="wrapper";function G8(e){let{components:n,...t}=e;return(0,s.yg)(B8,(0,p.A)({},S8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}G8.isMDXComponent=!0;const E8={toc:[]},O8="wrapper";function U8(e){let{components:n,...t}=e;return(0,s.yg)(O8,(0,p.A)({},E8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}U8.isMDXComponent=!0;const F8={toc:[]},V8="wrapper";function q8(e){let{components:n,...t}=e;return(0,s.yg)(V8,(0,p.A)({},F8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}q8.isMDXComponent=!0;const j8={toc:[]},H8="wrapper";function Y8(e){let{components:n,...t}=e;return(0,s.yg)(H8,(0,p.A)({},j8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Y8.isMDXComponent=!0;const Q8={toc:[]},$8="wrapper";function K8(e){let{components:n,...t}=e;return(0,s.yg)($8,(0,p.A)({},Q8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}K8.isMDXComponent=!0;const J8={toc:[]},Z8="wrapper";function e3(e){let{components:n,...t}=e;return(0,s.yg)(Z8,(0,p.A)({},J8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}e3.isMDXComponent=!0;const n3={toc:[]},t3="wrapper";function o3(e){let{components:n,...t}=e;return(0,s.yg)(t3,(0,p.A)({},n3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}o3.isMDXComponent=!0;const p3={toc:[]},r3="wrapper";function s3(e){let{components:n,...t}=e;return(0,s.yg)(r3,(0,p.A)({},p3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}s3.isMDXComponent=!0;const c3={toc:[]},a3="wrapper";function i3(e){let{components:n,...t}=e;return(0,s.yg)(a3,(0,p.A)({},c3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}i3.isMDXComponent=!0;const l3={toc:[]},u3="wrapper";function m3(e){let{components:n,...t}=e;return(0,s.yg)(u3,(0,p.A)({},l3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}m3.isMDXComponent=!0;const y3={toc:[]},d3="wrapper";function h3(e){let{components:n,...t}=e;return(0,s.yg)(d3,(0,p.A)({},y3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}h3.isMDXComponent=!0;const g3={toc:[]},f3="wrapper";function D3(e){let{components:n,...t}=e;return(0,s.yg)(f3,(0,p.A)({},g3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}D3.isMDXComponent=!0;const M3={toc:[]},X3="wrapper";function _3(e){let{components:n,...t}=e;return(0,s.yg)(X3,(0,p.A)({},M3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}_3.isMDXComponent=!0;const w3={toc:[]},T3="wrapper";function C3(e){let{components:n,...t}=e;return(0,s.yg)(T3,(0,p.A)({},w3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}C3.isMDXComponent=!0;const x3={toc:[]},A3="wrapper";function v3(e){let{components:n,...t}=e;return(0,s.yg)(A3,(0,p.A)({},x3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}v3.isMDXComponent=!0;const L3={toc:[]},b3="wrapper";function N3(e){let{components:n,...t}=e;return(0,s.yg)(b3,(0,p.A)({},L3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}N3.isMDXComponent=!0;const k3={toc:[]},z3="wrapper";function P3(e){let{components:n,...t}=e;return(0,s.yg)(z3,(0,p.A)({},k3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}P3.isMDXComponent=!0;const I3={toc:[]},R3="wrapper";function W3(e){let{components:n,...t}=e;return(0,s.yg)(R3,(0,p.A)({},I3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}W3.isMDXComponent=!0;const S3={toc:[]},B3="wrapper";function G3(e){let{components:n,...t}=e;return(0,s.yg)(B3,(0,p.A)({},S3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}G3.isMDXComponent=!0;const E3={toc:[]},O3="wrapper";function U3(e){let{components:n,...t}=e;return(0,s.yg)(O3,(0,p.A)({},E3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}U3.isMDXComponent=!0;const F3={toc:[]},V3="wrapper";function q3(e){let{components:n,...t}=e;return(0,s.yg)(V3,(0,p.A)({},F3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}q3.isMDXComponent=!0;const j3={toc:[]},H3="wrapper";function Y3(e){let{components:n,...t}=e;return(0,s.yg)(H3,(0,p.A)({},j3,t,{components:n,mdxType:"MDXLayout"}))}Y3.isMDXComponent=!0;const Q3={toc:[]},$3="wrapper";function K3(e){let{components:n,...t}=e;return(0,s.yg)($3,(0,p.A)({},Q3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}K3.isMDXComponent=!0;const J3={toc:[]},Z3="wrapper";function e1(e){let{components:n,...t}=e;return(0,s.yg)(Z3,(0,p.A)({},J3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}e1.isMDXComponent=!0;const n1={toc:[]},t1="wrapper";function o1(e){let{components:n,...t}=e;return(0,s.yg)(t1,(0,p.A)({},n1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}o1.isMDXComponent=!0;const p1={toc:[]},r1="wrapper";function s1(e){let{components:n,...t}=e;return(0,s.yg)(r1,(0,p.A)({},p1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}s1.isMDXComponent=!0;const c1={toc:[]},a1="wrapper";function i1(e){let{components:n,...t}=e;return(0,s.yg)(a1,(0,p.A)({},c1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}i1.isMDXComponent=!0;const l1={toc:[]},u1="wrapper";function m1(e){let{components:n,...t}=e;return(0,s.yg)(u1,(0,p.A)({},l1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}m1.isMDXComponent=!0;const y1={toc:[]},d1="wrapper";function h1(e){let{components:n,...t}=e;return(0,s.yg)(d1,(0,p.A)({},y1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}h1.isMDXComponent=!0;const g1={toc:[]},f1="wrapper";function D1(e){let{components:n,...t}=e;return(0,s.yg)(f1,(0,p.A)({},g1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}D1.isMDXComponent=!0;const M1={toc:[]},X1="wrapper";function _1(e){let{components:n,...t}=e;return(0,s.yg)(X1,(0,p.A)({},M1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}_1.isMDXComponent=!0;const w1={toc:[]},T1="wrapper";function C1(e){let{components:n,...t}=e;return(0,s.yg)(T1,(0,p.A)({},w1,t,{components:n,mdxType:"MDXLayout"}))}C1.isMDXComponent=!0;const x1={toc:[]},A1="wrapper";function v1(e){let{components:n,...t}=e;return(0,s.yg)(A1,(0,p.A)({},x1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}v1.isMDXComponent=!0;const L1={toc:[]},b1="wrapper";function N1(e){let{components:n,...t}=e;return(0,s.yg)(b1,(0,p.A)({},L1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}N1.isMDXComponent=!0;const k1={toc:[]},z1="wrapper";function P1(e){let{components:n,...t}=e;return(0,s.yg)(z1,(0,p.A)({},k1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}P1.isMDXComponent=!0;const I1={toc:[]},R1="wrapper";function W1(e){let{components:n,...t}=e;return(0,s.yg)(R1,(0,p.A)({},I1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}W1.isMDXComponent=!0;const S1={toc:[]},B1="wrapper";function G1(e){let{components:n,...t}=e;return(0,s.yg)(B1,(0,p.A)({},S1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}G1.isMDXComponent=!0;const E1={toc:[]},O1="wrapper";function U1(e){let{components:n,...t}=e;return(0,s.yg)(O1,(0,p.A)({},E1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}U1.isMDXComponent=!0;const F1={toc:[]},V1="wrapper";function q1(e){let{components:n,...t}=e;return(0,s.yg)(V1,(0,p.A)({},F1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}q1.isMDXComponent=!0;const j1={toc:[]},H1="wrapper";function Y1(e){let{components:n,...t}=e;return(0,s.yg)(H1,(0,p.A)({},j1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Y1.isMDXComponent=!0;const Q1={toc:[]},$1="wrapper";function K1(e){let{components:n,...t}=e;return(0,s.yg)($1,(0,p.A)({},Q1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}K1.isMDXComponent=!0;const J1={toc:[]},Z1="wrapper";function e6(e){let{components:n,...t}=e;return(0,s.yg)(Z1,(0,p.A)({},J1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}e6.isMDXComponent=!0;const n6={toc:[]},t6="wrapper";function o6(e){let{components:n,...t}=e;return(0,s.yg)(t6,(0,p.A)({},n6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}o6.isMDXComponent=!0;const p6={toc:[]},r6="wrapper";function s6(e){let{components:n,...t}=e;return(0,s.yg)(r6,(0,p.A)({},p6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}s6.isMDXComponent=!0;const c6={toc:[]},a6="wrapper";function i6(e){let{components:n,...t}=e;return(0,s.yg)(a6,(0,p.A)({},c6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}i6.isMDXComponent=!0;const l6={toc:[]},u6="wrapper";function m6(e){let{components:n,...t}=e;return(0,s.yg)(u6,(0,p.A)({},l6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}m6.isMDXComponent=!0;const y6={toc:[]},d6="wrapper";function h6(e){let{components:n,...t}=e;return(0,s.yg)(d6,(0,p.A)({},y6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}h6.isMDXComponent=!0;const g6={toc:[]},f6="wrapper";function D6(e){let{components:n,...t}=e;return(0,s.yg)(f6,(0,p.A)({},g6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}D6.isMDXComponent=!0;const M6={toc:[]},X6="wrapper";function _6(e){let{components:n,...t}=e;return(0,s.yg)(X6,(0,p.A)({},M6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}_6.isMDXComponent=!0;const w6={toc:[]},T6="wrapper";function C6(e){let{components:n,...t}=e;return(0,s.yg)(T6,(0,p.A)({},w6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}C6.isMDXComponent=!0;const x6={toc:[]},A6="wrapper";function v6(e){let{components:n,...t}=e;return(0,s.yg)(A6,(0,p.A)({},x6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}v6.isMDXComponent=!0;const L6={toc:[]},b6="wrapper";function N6(e){let{components:n,...t}=e;return(0,s.yg)(b6,(0,p.A)({},L6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}N6.isMDXComponent=!0;const k6={toc:[]},z6="wrapper";function P6(e){let{components:n,...t}=e;return(0,s.yg)(z6,(0,p.A)({},k6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}P6.isMDXComponent=!0;const I6={toc:[]},R6="wrapper";function W6(e){let{components:n,...t}=e;return(0,s.yg)(R6,(0,p.A)({},I6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}W6.isMDXComponent=!0;const S6={toc:[]},B6="wrapper";function G6(e){let{components:n,...t}=e;return(0,s.yg)(B6,(0,p.A)({},S6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}G6.isMDXComponent=!0;const E6={toc:[]},O6="wrapper";function U6(e){let{components:n,...t}=e;return(0,s.yg)(O6,(0,p.A)({},E6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}U6.isMDXComponent=!0;const F6={toc:[]},V6="wrapper";function q6(e){let{components:n,...t}=e;return(0,s.yg)(V6,(0,p.A)({},F6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}q6.isMDXComponent=!0;const j6={toc:[]},H6="wrapper";function Y6(e){let{components:n,...t}=e;return(0,s.yg)(H6,(0,p.A)({},j6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Y6.isMDXComponent=!0;const Q6={toc:[]},$6="wrapper";function K6(e){let{components:n,...t}=e;return(0,s.yg)($6,(0,p.A)({},Q6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}K6.isMDXComponent=!0;const J6={toc:[]},Z6="wrapper";function e5(e){let{components:n,...t}=e;return(0,s.yg)(Z6,(0,p.A)({},J6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}e5.isMDXComponent=!0;const n5={toc:[]},t5="wrapper";function o5(e){let{components:n,...t}=e;return(0,s.yg)(t5,(0,p.A)({},n5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}o5.isMDXComponent=!0;const p5={toc:[]},r5="wrapper";function s5(e){let{components:n,...t}=e;return(0,s.yg)(r5,(0,p.A)({},p5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}s5.isMDXComponent=!0;const c5={toc:[]},a5="wrapper";function i5(e){let{components:n,...t}=e;return(0,s.yg)(a5,(0,p.A)({},c5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}i5.isMDXComponent=!0;const l5={toc:[]},u5="wrapper";function m5(e){let{components:n,...t}=e;return(0,s.yg)(u5,(0,p.A)({},l5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}m5.isMDXComponent=!0;const y5={toc:[]},d5="wrapper";function h5(e){let{components:n,...t}=e;return(0,s.yg)(d5,(0,p.A)({},y5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}h5.isMDXComponent=!0;const g5={toc:[]},f5="wrapper";function D5(e){let{components:n,...t}=e;return(0,s.yg)(f5,(0,p.A)({},g5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}D5.isMDXComponent=!0;const M5={toc:[]},X5="wrapper";function _5(e){let{components:n,...t}=e;return(0,s.yg)(X5,(0,p.A)({},M5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}_5.isMDXComponent=!0;const w5={toc:[]},T5="wrapper";function C5(e){let{components:n,...t}=e;return(0,s.yg)(T5,(0,p.A)({},w5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}C5.isMDXComponent=!0;const x5={toc:[]},A5="wrapper";function v5(e){let{components:n,...t}=e;return(0,s.yg)(A5,(0,p.A)({},x5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}v5.isMDXComponent=!0;const L5={toc:[]},b5="wrapper";function N5(e){let{components:n,...t}=e;return(0,s.yg)(b5,(0,p.A)({},L5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}N5.isMDXComponent=!0;const k5={toc:[]},z5="wrapper";function P5(e){let{components:n,...t}=e;return(0,s.yg)(z5,(0,p.A)({},k5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}P5.isMDXComponent=!0;const I5={toc:[]},R5="wrapper";function W5(e){let{components:n,...t}=e;return(0,s.yg)(R5,(0,p.A)({},I5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}W5.isMDXComponent=!0;const S5={toc:[]},B5="wrapper";function G5(e){let{components:n,...t}=e;return(0,s.yg)(B5,(0,p.A)({},S5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}G5.isMDXComponent=!0;const E5={toc:[]},O5="wrapper";function U5(e){let{components:n,...t}=e;return(0,s.yg)(O5,(0,p.A)({},E5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}U5.isMDXComponent=!0;const F5={toc:[]},V5="wrapper";function q5(e){let{components:n,...t}=e;return(0,s.yg)(V5,(0,p.A)({},F5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}q5.isMDXComponent=!0;const j5={toc:[]},H5="wrapper";function Y5(e){let{components:n,...t}=e;return(0,s.yg)(H5,(0,p.A)({},j5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Y5.isMDXComponent=!0;const Q5={toc:[]},$5="wrapper";function K5(e){let{components:n,...t}=e;return(0,s.yg)($5,(0,p.A)({},Q5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}K5.isMDXComponent=!0;const J5={toc:[]},Z5="wrapper";function e7(e){let{components:n,...t}=e;return(0,s.yg)(Z5,(0,p.A)({},J5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}e7.isMDXComponent=!0;const n7={toc:[]},t7="wrapper";function o7(e){let{components:n,...t}=e;return(0,s.yg)(t7,(0,p.A)({},n7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}o7.isMDXComponent=!0;const p7={toc:[]},r7="wrapper";function s7(e){let{components:n,...t}=e;return(0,s.yg)(r7,(0,p.A)({},p7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}s7.isMDXComponent=!0;const c7={toc:[]},a7="wrapper";function i7(e){let{components:n,...t}=e;return(0,s.yg)(a7,(0,p.A)({},c7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}i7.isMDXComponent=!0;const l7={toc:[]},u7="wrapper";function m7(e){let{components:n,...t}=e;return(0,s.yg)(u7,(0,p.A)({},l7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}m7.isMDXComponent=!0;const y7={toc:[]},d7="wrapper";function h7(e){let{components:n,...t}=e;return(0,s.yg)(d7,(0,p.A)({},y7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}h7.isMDXComponent=!0;const g7={toc:[]},f7="wrapper";function D7(e){let{components:n,...t}=e;return(0,s.yg)(f7,(0,p.A)({},g7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}D7.isMDXComponent=!0;const M7={toc:[]},X7="wrapper";function _7(e){let{components:n,...t}=e;return(0,s.yg)(X7,(0,p.A)({},M7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}_7.isMDXComponent=!0;const w7={toc:[]},T7="wrapper";function C7(e){let{components:n,...t}=e;return(0,s.yg)(T7,(0,p.A)({},w7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}C7.isMDXComponent=!0;const x7={toc:[]},A7="wrapper";function v7(e){let{components:n,...t}=e;return(0,s.yg)(A7,(0,p.A)({},x7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}v7.isMDXComponent=!0;const L7={toc:[]},b7="wrapper";function N7(e){let{components:n,...t}=e;return(0,s.yg)(b7,(0,p.A)({},L7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}N7.isMDXComponent=!0;const k7={toc:[]},z7="wrapper";function P7(e){let{components:n,...t}=e;return(0,s.yg)(z7,(0,p.A)({},k7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}P7.isMDXComponent=!0;const I7={toc:[]},R7="wrapper";function W7(e){let{components:n,...t}=e;return(0,s.yg)(R7,(0,p.A)({},I7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}W7.isMDXComponent=!0;const S7={toc:[]},B7="wrapper";function G7(e){let{components:n,...t}=e;return(0,s.yg)(B7,(0,p.A)({},S7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}G7.isMDXComponent=!0;const E7={toc:[]},O7="wrapper";function U7(e){let{components:n,...t}=e;return(0,s.yg)(O7,(0,p.A)({},E7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}U7.isMDXComponent=!0;const F7={toc:[]},V7="wrapper";function q7(e){let{components:n,...t}=e;return(0,s.yg)(V7,(0,p.A)({},F7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}q7.isMDXComponent=!0;const j7={toc:[]},H7="wrapper";function Y7(e){let{components:n,...t}=e;return(0,s.yg)(H7,(0,p.A)({},j7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Y7.isMDXComponent=!0;const Q7={toc:[]},$7="wrapper";function K7(e){let{components:n,...t}=e;return(0,s.yg)($7,(0,p.A)({},Q7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}K7.isMDXComponent=!0;const J7={toc:[]},Z7="wrapper";function e9(e){let{components:n,...t}=e;return(0,s.yg)(Z7,(0,p.A)({},J7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}e9.isMDXComponent=!0;const n9={toc:[]},t9="wrapper";function o9(e){let{components:n,...t}=e;return(0,s.yg)(t9,(0,p.A)({},n9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}o9.isMDXComponent=!0;const p9={toc:[]},r9="wrapper";function s9(e){let{components:n,...t}=e;return(0,s.yg)(r9,(0,p.A)({},p9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}s9.isMDXComponent=!0;const c9={toc:[]},a9="wrapper";function i9(e){let{components:n,...t}=e;return(0,s.yg)(a9,(0,p.A)({},c9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}i9.isMDXComponent=!0;const l9={toc:[]},u9="wrapper";function m9(e){let{components:n,...t}=e;return(0,s.yg)(u9,(0,p.A)({},l9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}m9.isMDXComponent=!0;const y9={toc:[]},d9="wrapper";function h9(e){let{components:n,...t}=e;return(0,s.yg)(d9,(0,p.A)({},y9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}h9.isMDXComponent=!0;const g9={toc:[]},f9="wrapper";function D9(e){let{components:n,...t}=e;return(0,s.yg)(f9,(0,p.A)({},g9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}D9.isMDXComponent=!0;const M9={toc:[]},X9="wrapper";function _9(e){let{components:n,...t}=e;return(0,s.yg)(X9,(0,p.A)({},M9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}_9.isMDXComponent=!0;const w9={toc:[]},T9="wrapper";function C9(e){let{components:n,...t}=e;return(0,s.yg)(T9,(0,p.A)({},w9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}C9.isMDXComponent=!0;const x9={toc:[]},A9="wrapper";function v9(e){let{components:n,...t}=e;return(0,s.yg)(A9,(0,p.A)({},x9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}v9.isMDXComponent=!0;const L9={toc:[]},b9="wrapper";function N9(e){let{components:n,...t}=e;return(0,s.yg)(b9,(0,p.A)({},L9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}N9.isMDXComponent=!0;const k9={toc:[]},z9="wrapper";function P9(e){let{components:n,...t}=e;return(0,s.yg)(z9,(0,p.A)({},k9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}P9.isMDXComponent=!0;const I9={toc:[]},R9="wrapper";function W9(e){let{components:n,...t}=e;return(0,s.yg)(R9,(0,p.A)({},I9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}W9.isMDXComponent=!0;const S9={toc:[]},B9="wrapper";function G9(e){let{components:n,...t}=e;return(0,s.yg)(B9,(0,p.A)({},S9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}G9.isMDXComponent=!0;const E9={toc:[]},O9="wrapper";function U9(e){let{components:n,...t}=e;return(0,s.yg)(O9,(0,p.A)({},E9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}U9.isMDXComponent=!0;const F9={toc:[]},V9="wrapper";function q9(e){let{components:n,...t}=e;return(0,s.yg)(V9,(0,p.A)({},F9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}q9.isMDXComponent=!0;const j9={toc:[]},H9="wrapper";function Y9(e){let{components:n,...t}=e;return(0,s.yg)(H9,(0,p.A)({},j9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Y9.isMDXComponent=!0;const Q9={toc:[]},$9="wrapper";function K9(e){let{components:n,...t}=e;return(0,s.yg)($9,(0,p.A)({},Q9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}K9.isMDXComponent=!0;const J9={toc:[]},Z9="wrapper";function eee(e){let{components:n,...t}=e;return(0,s.yg)(Z9,(0,p.A)({},J9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}eee.isMDXComponent=!0;const nee={toc:[]},tee="wrapper";function oee(e){let{components:n,...t}=e;return(0,s.yg)(tee,(0,p.A)({},nee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}oee.isMDXComponent=!0;const pee={toc:[]},ree="wrapper";function see(e){let{components:n,...t}=e;return(0,s.yg)(ree,(0,p.A)({},pee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}see.isMDXComponent=!0;const cee={toc:[]},aee="wrapper";function iee(e){let{components:n,...t}=e;return(0,s.yg)(aee,(0,p.A)({},cee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iee.isMDXComponent=!0;const lee={toc:[]},uee="wrapper";function mee(e){let{components:n,...t}=e;return(0,s.yg)(uee,(0,p.A)({},lee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}mee.isMDXComponent=!0;const yee={toc:[]},dee="wrapper";function hee(e){let{components:n,...t}=e;return(0,s.yg)(dee,(0,p.A)({},yee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}hee.isMDXComponent=!0;const gee={toc:[]},fee="wrapper";function Dee(e){let{components:n,...t}=e;return(0,s.yg)(fee,(0,p.A)({},gee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Dee.isMDXComponent=!0;const Mee={toc:[]},Xee="wrapper";function _ee(e){let{components:n,...t}=e;return(0,s.yg)(Xee,(0,p.A)({},Mee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}_ee.isMDXComponent=!0;const wee={toc:[]},Tee="wrapper";function Cee(e){let{components:n,...t}=e;return(0,s.yg)(Tee,(0,p.A)({},wee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Cee.isMDXComponent=!0;const xee={toc:[]},Aee="wrapper";function vee(e){let{components:n,...t}=e;return(0,s.yg)(Aee,(0,p.A)({},xee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}vee.isMDXComponent=!0;const Lee={toc:[]},bee="wrapper";function Nee(e){let{components:n,...t}=e;return(0,s.yg)(bee,(0,p.A)({},Lee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Nee.isMDXComponent=!0;const kee={toc:[]},zee="wrapper";function Pee(e){let{components:n,...t}=e;return(0,s.yg)(zee,(0,p.A)({},kee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Pee.isMDXComponent=!0;const Iee={toc:[]},Ree="wrapper";function Wee(e){let{components:n,...t}=e;return(0,s.yg)(Ree,(0,p.A)({},Iee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wee.isMDXComponent=!0;const See={toc:[]},Bee="wrapper";function Gee(e){let{components:n,...t}=e;return(0,s.yg)(Bee,(0,p.A)({},See,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Gee.isMDXComponent=!0;const Eee={toc:[]},Oee="wrapper";function Uee(e){let{components:n,...t}=e;return(0,s.yg)(Oee,(0,p.A)({},Eee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Uee.isMDXComponent=!0;const Fee={toc:[]},Vee="wrapper";function qee(e){let{components:n,...t}=e;return(0,s.yg)(Vee,(0,p.A)({},Fee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}qee.isMDXComponent=!0;const jee={toc:[]},Hee="wrapper";function Yee(e){let{components:n,...t}=e;return(0,s.yg)(Hee,(0,p.A)({},jee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Yee.isMDXComponent=!0;const Qee={toc:[]},$ee="wrapper";function Kee(e){let{components:n,...t}=e;return(0,s.yg)($ee,(0,p.A)({},Qee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Kee.isMDXComponent=!0;const Jee={toc:[]},Zee="wrapper";function ene(e){let{components:n,...t}=e;return(0,s.yg)(Zee,(0,p.A)({},Jee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}ene.isMDXComponent=!0;const nne={toc:[]},tne="wrapper";function one(e){let{components:n,...t}=e;return(0,s.yg)(tne,(0,p.A)({},nne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}one.isMDXComponent=!0;const pne={toc:[]},rne="wrapper";function sne(e){let{components:n,...t}=e;return(0,s.yg)(rne,(0,p.A)({},pne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}sne.isMDXComponent=!0;const cne={toc:[]},ane="wrapper";function ine(e){let{components:n,...t}=e;return(0,s.yg)(ane,(0,p.A)({},cne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}ine.isMDXComponent=!0;const lne={toc:[]},une="wrapper";function mne(e){let{components:n,...t}=e;return(0,s.yg)(une,(0,p.A)({},lne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}mne.isMDXComponent=!0;const yne={toc:[]},dne="wrapper";function hne(e){let{components:n,...t}=e;return(0,s.yg)(dne,(0,p.A)({},yne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}hne.isMDXComponent=!0;const gne={toc:[]},fne="wrapper";function Dne(e){let{components:n,...t}=e;return(0,s.yg)(fne,(0,p.A)({},gne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Dne.isMDXComponent=!0;const Mne={toc:[]},Xne="wrapper";function _ne(e){let{components:n,...t}=e;return(0,s.yg)(Xne,(0,p.A)({},Mne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}_ne.isMDXComponent=!0;const wne={toc:[]},Tne="wrapper";function Cne(e){let{components:n,...t}=e;return(0,s.yg)(Tne,(0,p.A)({},wne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Cne.isMDXComponent=!0;const xne={toc:[]},Ane="wrapper";function vne(e){let{components:n,...t}=e;return(0,s.yg)(Ane,(0,p.A)({},xne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}vne.isMDXComponent=!0;const Lne={toc:[]},bne="wrapper";function Nne(e){let{components:n,...t}=e;return(0,s.yg)(bne,(0,p.A)({},Lne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Nne.isMDXComponent=!0;const kne={toc:[]},zne="wrapper";function Pne(e){let{components:n,...t}=e;return(0,s.yg)(zne,(0,p.A)({},kne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Pne.isMDXComponent=!0;const Ine={toc:[]},Rne="wrapper";function Wne(e){let{components:n,...t}=e;return(0,s.yg)(Rne,(0,p.A)({},Ine,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Wne.isMDXComponent=!0;const Sne={toc:[]},Bne="wrapper";function Gne(e){let{components:n,...t}=e;return(0,s.yg)(Bne,(0,p.A)({},Sne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Gne.isMDXComponent=!0;const Ene={toc:[]},One="wrapper";function Une(e){let{components:n,...t}=e;return(0,s.yg)(One,(0,p.A)({},Ene,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Une.isMDXComponent=!0;const Fne={toc:[]},Vne="wrapper";function qne(e){let{components:n,...t}=e;return(0,s.yg)(Vne,(0,p.A)({},Fne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qne.isMDXComponent=!0;const jne={toc:[]},Hne="wrapper";function Yne(e){let{components:n,...t}=e;return(0,s.yg)(Hne,(0,p.A)({},jne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Yne.isMDXComponent=!0;const Qne={toc:[]},$ne="wrapper";function Kne(e){let{components:n,...t}=e;return(0,s.yg)($ne,(0,p.A)({},Qne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Kne.isMDXComponent=!0;const Jne={toc:[]},Zne="wrapper";function ete(e){let{components:n,...t}=e;return(0,s.yg)(Zne,(0,p.A)({},Jne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}ete.isMDXComponent=!0;const nte={toc:[]},tte="wrapper";function ote(e){let{components:n,...t}=e;return(0,s.yg)(tte,(0,p.A)({},nte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}ote.isMDXComponent=!0;const pte={toc:[]},rte="wrapper";function ste(e){let{components:n,...t}=e;return(0,s.yg)(rte,(0,p.A)({},pte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ste.isMDXComponent=!0;const cte={toc:[]},ate="wrapper";function ite(e){let{components:n,...t}=e;return(0,s.yg)(ate,(0,p.A)({},cte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}ite.isMDXComponent=!0;const lte={toc:[]},ute="wrapper";function mte(e){let{components:n,...t}=e;return(0,s.yg)(ute,(0,p.A)({},lte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}mte.isMDXComponent=!0;const yte={toc:[]},dte="wrapper";function hte(e){let{components:n,...t}=e;return(0,s.yg)(dte,(0,p.A)({},yte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}hte.isMDXComponent=!0;const gte={toc:[]},fte="wrapper";function Dte(e){let{components:n,...t}=e;return(0,s.yg)(fte,(0,p.A)({},gte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Dte.isMDXComponent=!0;const Mte={toc:[]},Xte="wrapper";function _te(e){let{components:n,...t}=e;return(0,s.yg)(Xte,(0,p.A)({},Mte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}_te.isMDXComponent=!0;const wte={toc:[]},Tte="wrapper";function Cte(e){let{components:n,...t}=e;return(0,s.yg)(Tte,(0,p.A)({},wte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Cte.isMDXComponent=!0;const xte={toc:[]},Ate="wrapper";function vte(e){let{components:n,...t}=e;return(0,s.yg)(Ate,(0,p.A)({},xte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}vte.isMDXComponent=!0;const Lte={toc:[]},bte="wrapper";function Nte(e){let{components:n,...t}=e;return(0,s.yg)(bte,(0,p.A)({},Lte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Nte.isMDXComponent=!0;const kte={toc:[]},zte="wrapper";function Pte(e){let{components:n,...t}=e;return(0,s.yg)(zte,(0,p.A)({},kte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Pte.isMDXComponent=!0;const Ite={toc:[]},Rte="wrapper";function Wte(e){let{components:n,...t}=e;return(0,s.yg)(Rte,(0,p.A)({},Ite,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Wte.isMDXComponent=!0;const Ste={toc:[]},Bte="wrapper";function Gte(e){let{components:n,...t}=e;return(0,s.yg)(Bte,(0,p.A)({},Ste,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Gte.isMDXComponent=!0;const Ete={toc:[]},Ote="wrapper";function Ute(e){let{components:n,...t}=e;return(0,s.yg)(Ote,(0,p.A)({},Ete,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Ute.isMDXComponent=!0;const Fte={toc:[]},Vte="wrapper";function qte(e){let{components:n,...t}=e;return(0,s.yg)(Vte,(0,p.A)({},Fte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qte.isMDXComponent=!0;const jte={toc:[]},Hte="wrapper";function Yte(e){let{components:n,...t}=e;return(0,s.yg)(Hte,(0,p.A)({},jte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Yte.isMDXComponent=!0;const Qte={toc:[]},$te="wrapper";function Kte(e){let{components:n,...t}=e;return(0,s.yg)($te,(0,p.A)({},Qte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Kte.isMDXComponent=!0;const Jte={toc:[]},Zte="wrapper";function eoe(e){let{components:n,...t}=e;return(0,s.yg)(Zte,(0,p.A)({},Jte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}eoe.isMDXComponent=!0;const noe={toc:[]},toe="wrapper";function ooe(e){let{components:n,...t}=e;return(0,s.yg)(toe,(0,p.A)({},noe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}ooe.isMDXComponent=!0;const poe={toc:[]},roe="wrapper";function soe(e){let{components:n,...t}=e;return(0,s.yg)(roe,(0,p.A)({},poe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}soe.isMDXComponent=!0;const coe={toc:[]},aoe="wrapper";function ioe(e){let{components:n,...t}=e;return(0,s.yg)(aoe,(0,p.A)({},coe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ioe.isMDXComponent=!0;const loe={toc:[]},uoe="wrapper";function moe(e){let{components:n,...t}=e;return(0,s.yg)(uoe,(0,p.A)({},loe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}moe.isMDXComponent=!0;const yoe={toc:[]},doe="wrapper";function hoe(e){let{components:n,...t}=e;return(0,s.yg)(doe,(0,p.A)({},yoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}hoe.isMDXComponent=!0;const goe={toc:[]},foe="wrapper";function Doe(e){let{components:n,...t}=e;return(0,s.yg)(foe,(0,p.A)({},goe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Doe.isMDXComponent=!0;const Moe={toc:[]},Xoe="wrapper";function _oe(e){let{components:n,...t}=e;return(0,s.yg)(Xoe,(0,p.A)({},Moe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}_oe.isMDXComponent=!0;const woe={toc:[]},Toe="wrapper";function Coe(e){let{components:n,...t}=e;return(0,s.yg)(Toe,(0,p.A)({},woe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Coe.isMDXComponent=!0;const xoe={toc:[]},Aoe="wrapper";function voe(e){let{components:n,...t}=e;return(0,s.yg)(Aoe,(0,p.A)({},xoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}voe.isMDXComponent=!0;const Loe={toc:[]},boe="wrapper";function Noe(e){let{components:n,...t}=e;return(0,s.yg)(boe,(0,p.A)({},Loe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Noe.isMDXComponent=!0;const koe={toc:[]},zoe="wrapper";function Poe(e){let{components:n,...t}=e;return(0,s.yg)(zoe,(0,p.A)({},koe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Poe.isMDXComponent=!0;const Ioe={toc:[]},Roe="wrapper";function Woe(e){let{components:n,...t}=e;return(0,s.yg)(Roe,(0,p.A)({},Ioe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Woe.isMDXComponent=!0;const Soe={toc:[]},Boe="wrapper";function Goe(e){let{components:n,...t}=e;return(0,s.yg)(Boe,(0,p.A)({},Soe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Goe.isMDXComponent=!0;const Eoe={toc:[]},Ooe="wrapper";function Uoe(e){let{components:n,...t}=e;return(0,s.yg)(Ooe,(0,p.A)({},Eoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Uoe.isMDXComponent=!0;const Foe={toc:[]},Voe="wrapper";function qoe(e){let{components:n,...t}=e;return(0,s.yg)(Voe,(0,p.A)({},Foe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qoe.isMDXComponent=!0;const joe={toc:[]},Hoe="wrapper";function Yoe(e){let{components:n,...t}=e;return(0,s.yg)(Hoe,(0,p.A)({},joe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Yoe.isMDXComponent=!0;const Qoe={toc:[]},$oe="wrapper";function Koe(e){let{components:n,...t}=e;return(0,s.yg)($oe,(0,p.A)({},Qoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Koe.isMDXComponent=!0;const Joe={toc:[]},Zoe="wrapper";function epe(e){let{components:n,...t}=e;return(0,s.yg)(Zoe,(0,p.A)({},Joe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}epe.isMDXComponent=!0;const npe={toc:[]},tpe="wrapper";function ope(e){let{components:n,...t}=e;return(0,s.yg)(tpe,(0,p.A)({},npe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}ope.isMDXComponent=!0;const ppe={toc:[]},rpe="wrapper";function spe(e){let{components:n,...t}=e;return(0,s.yg)(rpe,(0,p.A)({},ppe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}spe.isMDXComponent=!0;const cpe={toc:[]},ape="wrapper";function ipe(e){let{components:n,...t}=e;return(0,s.yg)(ape,(0,p.A)({},cpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}ipe.isMDXComponent=!0;const lpe={toc:[]},upe="wrapper";function mpe(e){let{components:n,...t}=e;return(0,s.yg)(upe,(0,p.A)({},lpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}mpe.isMDXComponent=!0;const ype={toc:[]},dpe="wrapper";function hpe(e){let{components:n,...t}=e;return(0,s.yg)(dpe,(0,p.A)({},ype,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}hpe.isMDXComponent=!0;const gpe={toc:[]},fpe="wrapper";function Dpe(e){let{components:n,...t}=e;return(0,s.yg)(fpe,(0,p.A)({},gpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Dpe.isMDXComponent=!0;const Mpe={toc:[]},Xpe="wrapper";function _pe(e){let{components:n,...t}=e;return(0,s.yg)(Xpe,(0,p.A)({},Mpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}_pe.isMDXComponent=!0;const wpe={toc:[]},Tpe="wrapper";function Cpe(e){let{components:n,...t}=e;return(0,s.yg)(Tpe,(0,p.A)({},wpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Cpe.isMDXComponent=!0;const xpe={toc:[]},Ape="wrapper";function vpe(e){let{components:n,...t}=e;return(0,s.yg)(Ape,(0,p.A)({},xpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}vpe.isMDXComponent=!0;const Lpe={toc:[]},bpe="wrapper";function Npe(e){let{components:n,...t}=e;return(0,s.yg)(bpe,(0,p.A)({},Lpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Npe.isMDXComponent=!0;const kpe={toc:[]},zpe="wrapper";function Ppe(e){let{components:n,...t}=e;return(0,s.yg)(zpe,(0,p.A)({},kpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Ppe.isMDXComponent=!0;const Ipe={toc:[]},Rpe="wrapper";function Wpe(e){let{components:n,...t}=e;return(0,s.yg)(Rpe,(0,p.A)({},Ipe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Wpe.isMDXComponent=!0;const Spe={toc:[]},Bpe="wrapper";function Gpe(e){let{components:n,...t}=e;return(0,s.yg)(Bpe,(0,p.A)({},Spe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Gpe.isMDXComponent=!0;const Epe={toc:[]},Ope="wrapper";function Upe(e){let{components:n,...t}=e;return(0,s.yg)(Ope,(0,p.A)({},Epe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Upe.isMDXComponent=!0;const Fpe={toc:[]},Vpe="wrapper";function qpe(e){let{components:n,...t}=e;return(0,s.yg)(Vpe,(0,p.A)({},Fpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qpe.isMDXComponent=!0;const jpe={toc:[]},Hpe="wrapper";function Ype(e){let{components:n,...t}=e;return(0,s.yg)(Hpe,(0,p.A)({},jpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Ype.isMDXComponent=!0;const Qpe={toc:[]},$pe="wrapper";function Kpe(e){let{components:n,...t}=e;return(0,s.yg)($pe,(0,p.A)({},Qpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]},Zpe="wrapper";function ere(e){let{components:n,...t}=e;return(0,s.yg)(Zpe,(0,p.A)({},Jpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}ere.isMDXComponent=!0;const nre={toc:[]},tre="wrapper";function ore(e){let{components:n,...t}=e;return(0,s.yg)(tre,(0,p.A)({},nre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ore.isMDXComponent=!0;const pre={toc:[]},rre="wrapper";function sre(e){let{components:n,...t}=e;return(0,s.yg)(rre,(0,p.A)({},pre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}sre.isMDXComponent=!0;const cre={toc:[]},are="wrapper";function ire(e){let{components:n,...t}=e;return(0,s.yg)(are,(0,p.A)({},cre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}ire.isMDXComponent=!0;const lre={toc:[]},ure="wrapper";function mre(e){let{components:n,...t}=e;return(0,s.yg)(ure,(0,p.A)({},lre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}mre.isMDXComponent=!0;const yre={toc:[]},dre="wrapper";function hre(e){let{components:n,...t}=e;return(0,s.yg)(dre,(0,p.A)({},yre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}hre.isMDXComponent=!0;const gre={toc:[]},fre="wrapper";function Dre(e){let{components:n,...t}=e;return(0,s.yg)(fre,(0,p.A)({},gre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Dre.isMDXComponent=!0;const Mre={toc:[]},Xre="wrapper";function _re(e){let{components:n,...t}=e;return(0,s.yg)(Xre,(0,p.A)({},Mre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}_re.isMDXComponent=!0;const wre={toc:[]},Tre="wrapper";function Cre(e){let{components:n,...t}=e;return(0,s.yg)(Tre,(0,p.A)({},wre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Cre.isMDXComponent=!0;const xre={toc:[]},Are="wrapper";function vre(e){let{components:n,...t}=e;return(0,s.yg)(Are,(0,p.A)({},xre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vre.isMDXComponent=!0;const Lre={toc:[]},bre="wrapper";function Nre(e){let{components:n,...t}=e;return(0,s.yg)(bre,(0,p.A)({},Lre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Nre.isMDXComponent=!0;const kre={toc:[]},zre="wrapper";function Pre(e){let{components:n,...t}=e;return(0,s.yg)(zre,(0,p.A)({},kre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Pre.isMDXComponent=!0;const Ire={toc:[]},Rre="wrapper";function Wre(e){let{components:n,...t}=e;return(0,s.yg)(Rre,(0,p.A)({},Ire,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Wre.isMDXComponent=!0;const Sre={toc:[]},Bre="wrapper";function Gre(e){let{components:n,...t}=e;return(0,s.yg)(Bre,(0,p.A)({},Sre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Gre.isMDXComponent=!0;const Ere={toc:[]},Ore="wrapper";function Ure(e){let{components:n,...t}=e;return(0,s.yg)(Ore,(0,p.A)({},Ere,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Ure.isMDXComponent=!0;const Fre={toc:[]},Vre="wrapper";function qre(e){let{components:n,...t}=e;return(0,s.yg)(Vre,(0,p.A)({},Fre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}qre.isMDXComponent=!0;const jre={toc:[]},Hre="wrapper";function Yre(e){let{components:n,...t}=e;return(0,s.yg)(Hre,(0,p.A)({},jre,t,{components:n,mdxType:"MDXLayout"}))}Yre.isMDXComponent=!0;const Qre={toc:[]},$re="wrapper";function Kre(e){let{components:n,...t}=e;return(0,s.yg)($re,(0,p.A)({},Qre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Kre.isMDXComponent=!0;const Jre={toc:[]},Zre="wrapper";function ese(e){let{components:n,...t}=e;return(0,s.yg)(Zre,(0,p.A)({},Jre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ese.isMDXComponent=!0;const nse={toc:[]},tse="wrapper";function ose(e){let{components:n,...t}=e;return(0,s.yg)(tse,(0,p.A)({},nse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}ose.isMDXComponent=!0;const pse={toc:[]},rse="wrapper";function sse(e){let{components:n,...t}=e;return(0,s.yg)(rse,(0,p.A)({},pse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}sse.isMDXComponent=!0;const cse={toc:[]},ase="wrapper";function ise(e){let{components:n,...t}=e;return(0,s.yg)(ase,(0,p.A)({},cse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}ise.isMDXComponent=!0;const lse={toc:[]},use="wrapper";function mse(e){let{components:n,...t}=e;return(0,s.yg)(use,(0,p.A)({},lse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}mse.isMDXComponent=!0;const yse={toc:[]},dse="wrapper";function hse(e){let{components:n,...t}=e;return(0,s.yg)(dse,(0,p.A)({},yse,t,{components:n,mdxType:"MDXLayout"}))}hse.isMDXComponent=!0;const gse={toc:[]},fse="wrapper";function Dse(e){let{components:n,...t}=e;return(0,s.yg)(fse,(0,p.A)({},gse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Dse.isMDXComponent=!0;const Mse={toc:[]},Xse="wrapper";function _se(e){let{components:n,...t}=e;return(0,s.yg)(Xse,(0,p.A)({},Mse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}_se.isMDXComponent=!0;const wse={toc:[]},Tse="wrapper";function Cse(e){let{components:n,...t}=e;return(0,s.yg)(Tse,(0,p.A)({},wse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Cse.isMDXComponent=!0;const xse={toc:[]},Ase="wrapper";function vse(e){let{components:n,...t}=e;return(0,s.yg)(Ase,(0,p.A)({},xse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}vse.isMDXComponent=!0;const Lse={toc:[]},bse="wrapper";function Nse(e){let{components:n,...t}=e;return(0,s.yg)(bse,(0,p.A)({},Lse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Nse.isMDXComponent=!0;const kse={toc:[]},zse="wrapper";function Pse(e){let{components:n,...t}=e;return(0,s.yg)(zse,(0,p.A)({},kse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Pse.isMDXComponent=!0;const Ise={toc:[]},Rse="wrapper";function Wse(e){let{components:n,...t}=e;return(0,s.yg)(Rse,(0,p.A)({},Ise,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Wse.isMDXComponent=!0;const Sse={toc:[]},Bse="wrapper";function Gse(e){let{components:n,...t}=e;return(0,s.yg)(Bse,(0,p.A)({},Sse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Gse.isMDXComponent=!0;const Ese={toc:[]},Ose="wrapper";function Use(e){let{components:n,...t}=e;return(0,s.yg)(Ose,(0,p.A)({},Ese,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Use.isMDXComponent=!0;const Fse={toc:[]},Vse="wrapper";function qse(e){let{components:n,...t}=e;return(0,s.yg)(Vse,(0,p.A)({},Fse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}qse.isMDXComponent=!0;const jse={toc:[]},Hse="wrapper";function Yse(e){let{components:n,...t}=e;return(0,s.yg)(Hse,(0,p.A)({},jse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Yse.isMDXComponent=!0;const Qse={toc:[]},$se="wrapper";function Kse(e){let{components:n,...t}=e;return(0,s.yg)($se,(0,p.A)({},Qse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Kse.isMDXComponent=!0;const Jse={toc:[]},Zse="wrapper";function ece(e){let{components:n,...t}=e;return(0,s.yg)(Zse,(0,p.A)({},Jse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}ece.isMDXComponent=!0;const nce={toc:[]},tce="wrapper";function oce(e){let{components:n,...t}=e;return(0,s.yg)(tce,(0,p.A)({},nce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oce.isMDXComponent=!0;const pce={toc:[]},rce="wrapper";function sce(e){let{components:n,...t}=e;return(0,s.yg)(rce,(0,p.A)({},pce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}sce.isMDXComponent=!0;const cce={toc:[]},ace="wrapper";function ice(e){let{components:n,...t}=e;return(0,s.yg)(ace,(0,p.A)({},cce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}ice.isMDXComponent=!0;const lce={toc:[]},uce="wrapper";function mce(e){let{components:n,...t}=e;return(0,s.yg)(uce,(0,p.A)({},lce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}mce.isMDXComponent=!0;const yce={toc:[]},dce="wrapper";function hce(e){let{components:n,...t}=e;return(0,s.yg)(dce,(0,p.A)({},yce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}hce.isMDXComponent=!0;const gce={toc:[]},fce="wrapper";function Dce(e){let{components:n,...t}=e;return(0,s.yg)(fce,(0,p.A)({},gce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Dce.isMDXComponent=!0;const Mce={toc:[]},Xce="wrapper";function _ce(e){let{components:n,...t}=e;return(0,s.yg)(Xce,(0,p.A)({},Mce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}_ce.isMDXComponent=!0;const wce={toc:[]},Tce="wrapper";function Cce(e){let{components:n,...t}=e;return(0,s.yg)(Tce,(0,p.A)({},wce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Cce.isMDXComponent=!0;const xce={toc:[]},Ace="wrapper";function vce(e){let{components:n,...t}=e;return(0,s.yg)(Ace,(0,p.A)({},xce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}vce.isMDXComponent=!0;const Lce={toc:[]},bce="wrapper";function Nce(e){let{components:n,...t}=e;return(0,s.yg)(bce,(0,p.A)({},Lce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Nce.isMDXComponent=!0;const kce={toc:[]},zce="wrapper";function Pce(e){let{components:n,...t}=e;return(0,s.yg)(zce,(0,p.A)({},kce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Pce.isMDXComponent=!0;const Ice={toc:[]},Rce="wrapper";function Wce(e){let{components:n,...t}=e;return(0,s.yg)(Rce,(0,p.A)({},Ice,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wce.isMDXComponent=!0;const Sce={toc:[]},Bce="wrapper";function Gce(e){let{components:n,...t}=e;return(0,s.yg)(Bce,(0,p.A)({},Sce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Gce.isMDXComponent=!0;const Ece={toc:[]},Oce="wrapper";function Uce(e){let{components:n,...t}=e;return(0,s.yg)(Oce,(0,p.A)({},Ece,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Uce.isMDXComponent=!0;const Fce={toc:[]},Vce="wrapper";function qce(e){let{components:n,...t}=e;return(0,s.yg)(Vce,(0,p.A)({},Fce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qce.isMDXComponent=!0;const jce={toc:[]},Hce="wrapper";function Yce(e){let{components:n,...t}=e;return(0,s.yg)(Hce,(0,p.A)({},jce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Yce.isMDXComponent=!0;const Qce={toc:[]},$ce="wrapper";function Kce(e){let{components:n,...t}=e;return(0,s.yg)($ce,(0,p.A)({},Qce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Kce.isMDXComponent=!0;const Jce={toc:[]},Zce="wrapper";function eae(e){let{components:n,...t}=e;return(0,s.yg)(Zce,(0,p.A)({},Jce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}eae.isMDXComponent=!0;const nae={toc:[]},tae="wrapper";function oae(e){let{components:n,...t}=e;return(0,s.yg)(tae,(0,p.A)({},nae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}oae.isMDXComponent=!0;const pae={toc:[]},rae="wrapper";function sae(e){let{components:n,...t}=e;return(0,s.yg)(rae,(0,p.A)({},pae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}sae.isMDXComponent=!0;const cae={toc:[]},aae="wrapper";function iae(e){let{components:n,...t}=e;return(0,s.yg)(aae,(0,p.A)({},cae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}iae.isMDXComponent=!0;const lae={toc:[]},uae="wrapper";function mae(e){let{components:n,...t}=e;return(0,s.yg)(uae,(0,p.A)({},lae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}mae.isMDXComponent=!0;const yae={toc:[]},dae="wrapper";function hae(e){let{components:n,...t}=e;return(0,s.yg)(dae,(0,p.A)({},yae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}hae.isMDXComponent=!0;const gae={toc:[]},fae="wrapper";function Dae(e){let{components:n,...t}=e;return(0,s.yg)(fae,(0,p.A)({},gae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Dae.isMDXComponent=!0;const Mae={toc:[]},Xae="wrapper";function _ae(e){let{components:n,...t}=e;return(0,s.yg)(Xae,(0,p.A)({},Mae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}_ae.isMDXComponent=!0;const wae={toc:[]},Tae="wrapper";function Cae(e){let{components:n,...t}=e;return(0,s.yg)(Tae,(0,p.A)({},wae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Cae.isMDXComponent=!0;const xae={toc:[]},Aae="wrapper";function vae(e){let{components:n,...t}=e;return(0,s.yg)(Aae,(0,p.A)({},xae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}vae.isMDXComponent=!0;const Lae={toc:[]},bae="wrapper";function Nae(e){let{components:n,...t}=e;return(0,s.yg)(bae,(0,p.A)({},Lae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Nae.isMDXComponent=!0;const kae={toc:[]},zae="wrapper";function Pae(e){let{components:n,...t}=e;return(0,s.yg)(zae,(0,p.A)({},kae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Pae.isMDXComponent=!0;const Iae={toc:[]},Rae="wrapper";function Wae(e){let{components:n,...t}=e;return(0,s.yg)(Rae,(0,p.A)({},Iae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Wae.isMDXComponent=!0;const Sae={toc:[]},Bae="wrapper";function Gae(e){let{components:n,...t}=e;return(0,s.yg)(Bae,(0,p.A)({},Sae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Gae.isMDXComponent=!0;const Eae={toc:[]},Oae="wrapper";function Uae(e){let{components:n,...t}=e;return(0,s.yg)(Oae,(0,p.A)({},Eae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Uae.isMDXComponent=!0;const Fae={toc:[]},Vae="wrapper";function qae(e){let{components:n,...t}=e;return(0,s.yg)(Vae,(0,p.A)({},Fae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qae.isMDXComponent=!0;const jae={toc:[]},Hae="wrapper";function Yae(e){let{components:n,...t}=e;return(0,s.yg)(Hae,(0,p.A)({},jae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Yae.isMDXComponent=!0;const Qae={toc:[]},$ae="wrapper";function Kae(e){let{components:n,...t}=e;return(0,s.yg)($ae,(0,p.A)({},Qae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Kae.isMDXComponent=!0;const Jae={toc:[]},Zae="wrapper";function eie(e){let{components:n,...t}=e;return(0,s.yg)(Zae,(0,p.A)({},Jae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}eie.isMDXComponent=!0;const nie={toc:[]},tie="wrapper";function oie(e){let{components:n,...t}=e;return(0,s.yg)(tie,(0,p.A)({},nie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}oie.isMDXComponent=!0;const pie={toc:[]},rie="wrapper";function sie(e){let{components:n,...t}=e;return(0,s.yg)(rie,(0,p.A)({},pie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}sie.isMDXComponent=!0;const cie={toc:[]},aie="wrapper";function iie(e){let{components:n,...t}=e;return(0,s.yg)(aie,(0,p.A)({},cie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}iie.isMDXComponent=!0;const lie={toc:[]},uie="wrapper";function mie(e){let{components:n,...t}=e;return(0,s.yg)(uie,(0,p.A)({},lie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}mie.isMDXComponent=!0;const yie={toc:[]},die="wrapper";function hie(e){let{components:n,...t}=e;return(0,s.yg)(die,(0,p.A)({},yie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hie.isMDXComponent=!0;const gie={toc:[]},fie="wrapper";function Die(e){let{components:n,...t}=e;return(0,s.yg)(fie,(0,p.A)({},gie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Die.isMDXComponent=!0;const Mie={toc:[]},Xie="wrapper";function _ie(e){let{components:n,...t}=e;return(0,s.yg)(Xie,(0,p.A)({},Mie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_ie.isMDXComponent=!0;const wie={toc:[]},Tie="wrapper";function Cie(e){let{components:n,...t}=e;return(0,s.yg)(Tie,(0,p.A)({},wie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Cie.isMDXComponent=!0;const xie={toc:[]},Aie="wrapper";function vie(e){let{components:n,...t}=e;return(0,s.yg)(Aie,(0,p.A)({},xie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vie.isMDXComponent=!0;const Lie={toc:[]},bie="wrapper";function Nie(e){let{components:n,...t}=e;return(0,s.yg)(bie,(0,p.A)({},Lie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Nie.isMDXComponent=!0;const kie={toc:[]},zie="wrapper";function Pie(e){let{components:n,...t}=e;return(0,s.yg)(zie,(0,p.A)({},kie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Pie.isMDXComponent=!0;const Iie={toc:[]},Rie="wrapper";function Wie(e){let{components:n,...t}=e;return(0,s.yg)(Rie,(0,p.A)({},Iie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Wie.isMDXComponent=!0;const Sie={toc:[]},Bie="wrapper";function Gie(e){let{components:n,...t}=e;return(0,s.yg)(Bie,(0,p.A)({},Sie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Gie.isMDXComponent=!0;const Eie={toc:[]},Oie="wrapper";function Uie(e){let{components:n,...t}=e;return(0,s.yg)(Oie,(0,p.A)({},Eie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Uie.isMDXComponent=!0;const Fie={toc:[]},Vie="wrapper";function qie(e){let{components:n,...t}=e;return(0,s.yg)(Vie,(0,p.A)({},Fie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qie.isMDXComponent=!0;const jie={toc:[]},Hie="wrapper";function Yie(e){let{components:n,...t}=e;return(0,s.yg)(Hie,(0,p.A)({},jie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Yie.isMDXComponent=!0;const Qie={toc:[]},$ie="wrapper";function Kie(e){let{components:n,...t}=e;return(0,s.yg)($ie,(0,p.A)({},Qie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Kie.isMDXComponent=!0;const Jie={toc:[]},Zie="wrapper";function ele(e){let{components:n,...t}=e;return(0,s.yg)(Zie,(0,p.A)({},Jie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}ele.isMDXComponent=!0;const nle={toc:[]},tle="wrapper";function ole(e){let{components:n,...t}=e;return(0,s.yg)(tle,(0,p.A)({},nle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ole.isMDXComponent=!0;const ple={toc:[]},rle="wrapper";function sle(e){let{components:n,...t}=e;return(0,s.yg)(rle,(0,p.A)({},ple,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}sle.isMDXComponent=!0;const cle={toc:[]},ale="wrapper";function ile(e){let{components:n,...t}=e;return(0,s.yg)(ale,(0,p.A)({},cle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ile.isMDXComponent=!0;const lle={toc:[]},ule="wrapper";function mle(e){let{components:n,...t}=e;return(0,s.yg)(ule,(0,p.A)({},lle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}mle.isMDXComponent=!0;const yle={toc:[]},dle="wrapper";function hle(e){let{components:n,...t}=e;return(0,s.yg)(dle,(0,p.A)({},yle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}hle.isMDXComponent=!0;const gle={toc:[]},fle="wrapper";function Dle(e){let{components:n,...t}=e;return(0,s.yg)(fle,(0,p.A)({},gle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Dle.isMDXComponent=!0;const Mle={toc:[]},Xle="wrapper";function _le(e){let{components:n,...t}=e;return(0,s.yg)(Xle,(0,p.A)({},Mle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}_le.isMDXComponent=!0;const wle={toc:[]},Tle="wrapper";function Cle(e){let{components:n,...t}=e;return(0,s.yg)(Tle,(0,p.A)({},wle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Cle.isMDXComponent=!0;const xle={toc:[]},Ale="wrapper";function vle(e){let{components:n,...t}=e;return(0,s.yg)(Ale,(0,p.A)({},xle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}vle.isMDXComponent=!0;const Lle={toc:[]},ble="wrapper";function Nle(e){let{components:n,...t}=e;return(0,s.yg)(ble,(0,p.A)({},Lle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Nle.isMDXComponent=!0;const kle={toc:[]},zle="wrapper";function Ple(e){let{components:n,...t}=e;return(0,s.yg)(zle,(0,p.A)({},kle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Ple.isMDXComponent=!0;const Ile={toc:[]},Rle="wrapper";function Wle(e){let{components:n,...t}=e;return(0,s.yg)(Rle,(0,p.A)({},Ile,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Wle.isMDXComponent=!0;const Sle={toc:[]},Ble="wrapper";function Gle(e){let{components:n,...t}=e;return(0,s.yg)(Ble,(0,p.A)({},Sle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Gle.isMDXComponent=!0;const Ele={toc:[]},Ole="wrapper";function Ule(e){let{components:n,...t}=e;return(0,s.yg)(Ole,(0,p.A)({},Ele,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Ule.isMDXComponent=!0;const Fle={toc:[]},Vle="wrapper";function qle(e){let{components:n,...t}=e;return(0,s.yg)(Vle,(0,p.A)({},Fle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}qle.isMDXComponent=!0;const jle={toc:[]},Hle="wrapper";function Yle(e){let{components:n,...t}=e;return(0,s.yg)(Hle,(0,p.A)({},jle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Yle.isMDXComponent=!0;const Qle={toc:[]},$le="wrapper";function Kle(e){let{components:n,...t}=e;return(0,s.yg)($le,(0,p.A)({},Qle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Kle.isMDXComponent=!0;const Jle={toc:[]},Zle="wrapper";function eue(e){let{components:n,...t}=e;return(0,s.yg)(Zle,(0,p.A)({},Jle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}eue.isMDXComponent=!0;const nue={toc:[]},tue="wrapper";function oue(e){let{components:n,...t}=e;return(0,s.yg)(tue,(0,p.A)({},nue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}oue.isMDXComponent=!0;const pue={toc:[]},rue="wrapper";function sue(e){let{components:n,...t}=e;return(0,s.yg)(rue,(0,p.A)({},pue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sue.isMDXComponent=!0;const cue={toc:[]},aue="wrapper";function iue(e){let{components:n,...t}=e;return(0,s.yg)(aue,(0,p.A)({},cue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iue.isMDXComponent=!0;const lue={toc:[]},uue="wrapper";function mue(e){let{components:n,...t}=e;return(0,s.yg)(uue,(0,p.A)({},lue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}mue.isMDXComponent=!0;const yue={toc:[]},due="wrapper";function hue(e){let{components:n,...t}=e;return(0,s.yg)(due,(0,p.A)({},yue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}hue.isMDXComponent=!0;const gue={toc:[]},fue="wrapper";function Due(e){let{components:n,...t}=e;return(0,s.yg)(fue,(0,p.A)({},gue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Due.isMDXComponent=!0;const Mue={toc:[]},Xue="wrapper";function _ue(e){let{components:n,...t}=e;return(0,s.yg)(Xue,(0,p.A)({},Mue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}_ue.isMDXComponent=!0;const wue={toc:[]},Tue="wrapper";function Cue(e){let{components:n,...t}=e;return(0,s.yg)(Tue,(0,p.A)({},wue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Cue.isMDXComponent=!0;const xue={toc:[]},Aue="wrapper";function vue(e){let{components:n,...t}=e;return(0,s.yg)(Aue,(0,p.A)({},xue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}vue.isMDXComponent=!0;const Lue={toc:[]},bue="wrapper";function Nue(e){let{components:n,...t}=e;return(0,s.yg)(bue,(0,p.A)({},Lue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Nue.isMDXComponent=!0;const kue={toc:[]},zue="wrapper";function Pue(e){let{components:n,...t}=e;return(0,s.yg)(zue,(0,p.A)({},kue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Pue.isMDXComponent=!0;const Iue={toc:[]},Rue="wrapper";function Wue(e){let{components:n,...t}=e;return(0,s.yg)(Rue,(0,p.A)({},Iue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Wue.isMDXComponent=!0;const Sue={toc:[]},Bue="wrapper";function Gue(e){let{components:n,...t}=e;return(0,s.yg)(Bue,(0,p.A)({},Sue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Gue.isMDXComponent=!0;const Eue={toc:[]},Oue="wrapper";function Uue(e){let{components:n,...t}=e;return(0,s.yg)(Oue,(0,p.A)({},Eue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Uue.isMDXComponent=!0;const Fue={toc:[]},Vue="wrapper";function que(e){let{components:n,...t}=e;return(0,s.yg)(Vue,(0,p.A)({},Fue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}que.isMDXComponent=!0;const jue={toc:[]},Hue="wrapper";function Yue(e){let{components:n,...t}=e;return(0,s.yg)(Hue,(0,p.A)({},jue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Yue.isMDXComponent=!0;const Que={toc:[]},$ue="wrapper";function Kue(e){let{components:n,...t}=e;return(0,s.yg)($ue,(0,p.A)({},Que,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Kue.isMDXComponent=!0;const Jue={toc:[]},Zue="wrapper";function eme(e){let{components:n,...t}=e;return(0,s.yg)(Zue,(0,p.A)({},Jue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}eme.isMDXComponent=!0;const nme={toc:[]},tme="wrapper";function ome(e){let{components:n,...t}=e;return(0,s.yg)(tme,(0,p.A)({},nme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}ome.isMDXComponent=!0;const pme={toc:[]},rme="wrapper";function sme(e){let{components:n,...t}=e;return(0,s.yg)(rme,(0,p.A)({},pme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}sme.isMDXComponent=!0;const cme={toc:[]},ame="wrapper";function ime(e){let{components:n,...t}=e;return(0,s.yg)(ame,(0,p.A)({},cme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}ime.isMDXComponent=!0;const lme={toc:[]},ume="wrapper";function mme(e){let{components:n,...t}=e;return(0,s.yg)(ume,(0,p.A)({},lme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}mme.isMDXComponent=!0;const yme={toc:[]},dme="wrapper";function hme(e){let{components:n,...t}=e;return(0,s.yg)(dme,(0,p.A)({},yme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hme.isMDXComponent=!0;const gme={toc:[]},fme="wrapper";function Dme(e){let{components:n,...t}=e;return(0,s.yg)(fme,(0,p.A)({},gme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Dme.isMDXComponent=!0;const Mme={toc:[]},Xme="wrapper";function _me(e){let{components:n,...t}=e;return(0,s.yg)(Xme,(0,p.A)({},Mme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}_me.isMDXComponent=!0;const wme={toc:[]},Tme="wrapper";function Cme(e){let{components:n,...t}=e;return(0,s.yg)(Tme,(0,p.A)({},wme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Cme.isMDXComponent=!0;const xme={toc:[]},Ame="wrapper";function vme(e){let{components:n,...t}=e;return(0,s.yg)(Ame,(0,p.A)({},xme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vme.isMDXComponent=!0;const Lme={toc:[]},bme="wrapper";function Nme(e){let{components:n,...t}=e;return(0,s.yg)(bme,(0,p.A)({},Lme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Nme.isMDXComponent=!0;const kme={toc:[]},zme="wrapper";function Pme(e){let{components:n,...t}=e;return(0,s.yg)(zme,(0,p.A)({},kme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Pme.isMDXComponent=!0;const Ime={toc:[]},Rme="wrapper";function Wme(e){let{components:n,...t}=e;return(0,s.yg)(Rme,(0,p.A)({},Ime,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Wme.isMDXComponent=!0;const Sme={toc:[]},Bme="wrapper";function Gme(e){let{components:n,...t}=e;return(0,s.yg)(Bme,(0,p.A)({},Sme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Gme.isMDXComponent=!0;const Eme={toc:[]},Ome="wrapper";function Ume(e){let{components:n,...t}=e;return(0,s.yg)(Ome,(0,p.A)({},Eme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Ume.isMDXComponent=!0;const Fme={toc:[]},Vme="wrapper";function qme(e){let{components:n,...t}=e;return(0,s.yg)(Vme,(0,p.A)({},Fme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}qme.isMDXComponent=!0;const jme={toc:[]},Hme="wrapper";function Yme(e){let{components:n,...t}=e;return(0,s.yg)(Hme,(0,p.A)({},jme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Yme.isMDXComponent=!0;const Qme={toc:[]},$me="wrapper";function Kme(e){let{components:n,...t}=e;return(0,s.yg)($me,(0,p.A)({},Qme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Kme.isMDXComponent=!0;const Jme={toc:[]},Zme="wrapper";function eye(e){let{components:n,...t}=e;return(0,s.yg)(Zme,(0,p.A)({},Jme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}eye.isMDXComponent=!0;const nye={toc:[]},tye="wrapper";function oye(e){let{components:n,...t}=e;return(0,s.yg)(tye,(0,p.A)({},nye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}oye.isMDXComponent=!0;const pye={toc:[]},rye="wrapper";function sye(e){let{components:n,...t}=e;return(0,s.yg)(rye,(0,p.A)({},pye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}sye.isMDXComponent=!0;const cye={toc:[]},aye="wrapper";function iye(e){let{components:n,...t}=e;return(0,s.yg)(aye,(0,p.A)({},cye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}iye.isMDXComponent=!0;const lye={toc:[]},uye="wrapper";function mye(e){let{components:n,...t}=e;return(0,s.yg)(uye,(0,p.A)({},lye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}mye.isMDXComponent=!0;const yye={toc:[]},dye="wrapper";function hye(e){let{components:n,...t}=e;return(0,s.yg)(dye,(0,p.A)({},yye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}hye.isMDXComponent=!0;const gye={toc:[]},fye="wrapper";function Dye(e){let{components:n,...t}=e;return(0,s.yg)(fye,(0,p.A)({},gye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Dye.isMDXComponent=!0;const Mye={toc:[]},Xye="wrapper";function _ye(e){let{components:n,...t}=e;return(0,s.yg)(Xye,(0,p.A)({},Mye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}_ye.isMDXComponent=!0;const wye={toc:[]},Tye="wrapper";function Cye(e){let{components:n,...t}=e;return(0,s.yg)(Tye,(0,p.A)({},wye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Cye.isMDXComponent=!0;const xye={toc:[]},Aye="wrapper";function vye(e){let{components:n,...t}=e;return(0,s.yg)(Aye,(0,p.A)({},xye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}vye.isMDXComponent=!0;const Lye={toc:[]},bye="wrapper";function Nye(e){let{components:n,...t}=e;return(0,s.yg)(bye,(0,p.A)({},Lye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Nye.isMDXComponent=!0;const kye={toc:[]},zye="wrapper";function Pye(e){let{components:n,...t}=e;return(0,s.yg)(zye,(0,p.A)({},kye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Pye.isMDXComponent=!0;const Iye={toc:[]},Rye="wrapper";function Wye(e){let{components:n,...t}=e;return(0,s.yg)(Rye,(0,p.A)({},Iye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Wye.isMDXComponent=!0;const Sye={toc:[]},Bye="wrapper";function Gye(e){let{components:n,...t}=e;return(0,s.yg)(Bye,(0,p.A)({},Sye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Gye.isMDXComponent=!0;const Eye={toc:[]},Oye="wrapper";function Uye(e){let{components:n,...t}=e;return(0,s.yg)(Oye,(0,p.A)({},Eye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Uye.isMDXComponent=!0;const Fye={toc:[]},Vye="wrapper";function qye(e){let{components:n,...t}=e;return(0,s.yg)(Vye,(0,p.A)({},Fye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}qye.isMDXComponent=!0;const jye={toc:[]},Hye="wrapper";function Yye(e){let{components:n,...t}=e;return(0,s.yg)(Hye,(0,p.A)({},jye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Yye.isMDXComponent=!0;const Qye={toc:[]},$ye="wrapper";function Kye(e){let{components:n,...t}=e;return(0,s.yg)($ye,(0,p.A)({},Qye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Kye.isMDXComponent=!0;const Jye={toc:[]},Zye="wrapper";function ede(e){let{components:n,...t}=e;return(0,s.yg)(Zye,(0,p.A)({},Jye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}ede.isMDXComponent=!0;const nde={toc:[]},tde="wrapper";function ode(e){let{components:n,...t}=e;return(0,s.yg)(tde,(0,p.A)({},nde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ode.isMDXComponent=!0;const pde={toc:[]},rde="wrapper";function sde(e){let{components:n,...t}=e;return(0,s.yg)(rde,(0,p.A)({},pde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}sde.isMDXComponent=!0;const cde={toc:[]},ade="wrapper";function ide(e){let{components:n,...t}=e;return(0,s.yg)(ade,(0,p.A)({},cde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}ide.isMDXComponent=!0;const lde={toc:[]},ude="wrapper";function mde(e){let{components:n,...t}=e;return(0,s.yg)(ude,(0,p.A)({},lde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}mde.isMDXComponent=!0;const yde={toc:[]},dde="wrapper";function hde(e){let{components:n,...t}=e;return(0,s.yg)(dde,(0,p.A)({},yde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}hde.isMDXComponent=!0;const gde={toc:[]},fde="wrapper";function Dde(e){let{components:n,...t}=e;return(0,s.yg)(fde,(0,p.A)({},gde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Dde.isMDXComponent=!0;const Mde={toc:[]},Xde="wrapper";function _de(e){let{components:n,...t}=e;return(0,s.yg)(Xde,(0,p.A)({},Mde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}_de.isMDXComponent=!0;const wde={toc:[]},Tde="wrapper";function Cde(e){let{components:n,...t}=e;return(0,s.yg)(Tde,(0,p.A)({},wde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Cde.isMDXComponent=!0;const xde={toc:[]},Ade="wrapper";function vde(e){let{components:n,...t}=e;return(0,s.yg)(Ade,(0,p.A)({},xde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}vde.isMDXComponent=!0;const Lde={toc:[]},bde="wrapper";function Nde(e){let{components:n,...t}=e;return(0,s.yg)(bde,(0,p.A)({},Lde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Nde.isMDXComponent=!0;const kde={toc:[]},zde="wrapper";function Pde(e){let{components:n,...t}=e;return(0,s.yg)(zde,(0,p.A)({},kde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Pde.isMDXComponent=!0;const Ide={toc:[]},Rde="wrapper";function Wde(e){let{components:n,...t}=e;return(0,s.yg)(Rde,(0,p.A)({},Ide,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Wde.isMDXComponent=!0;const Sde={toc:[]},Bde="wrapper";function Gde(e){let{components:n,...t}=e;return(0,s.yg)(Bde,(0,p.A)({},Sde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Gde.isMDXComponent=!0;const Ede={toc:[]},Ode="wrapper";function Ude(e){let{components:n,...t}=e;return(0,s.yg)(Ode,(0,p.A)({},Ede,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ude.isMDXComponent=!0;const Fde={toc:[]},Vde="wrapper";function qde(e){let{components:n,...t}=e;return(0,s.yg)(Vde,(0,p.A)({},Fde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}qde.isMDXComponent=!0;const jde={toc:[]},Hde="wrapper";function Yde(e){let{components:n,...t}=e;return(0,s.yg)(Hde,(0,p.A)({},jde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Yde.isMDXComponent=!0;const Qde={toc:[]},$de="wrapper";function Kde(e){let{components:n,...t}=e;return(0,s.yg)($de,(0,p.A)({},Qde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Kde.isMDXComponent=!0;const Jde={toc:[]},Zde="wrapper";function ehe(e){let{components:n,...t}=e;return(0,s.yg)(Zde,(0,p.A)({},Jde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}ehe.isMDXComponent=!0;const nhe={toc:[]},the="wrapper";function ohe(e){let{components:n,...t}=e;return(0,s.yg)(the,(0,p.A)({},nhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ohe.isMDXComponent=!0;const phe={toc:[]},rhe="wrapper";function she(e){let{components:n,...t}=e;return(0,s.yg)(rhe,(0,p.A)({},phe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}she.isMDXComponent=!0;const che={toc:[]},ahe="wrapper";function ihe(e){let{components:n,...t}=e;return(0,s.yg)(ahe,(0,p.A)({},che,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ihe.isMDXComponent=!0;const lhe={toc:[]},uhe="wrapper";function mhe(e){let{components:n,...t}=e;return(0,s.yg)(uhe,(0,p.A)({},lhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}mhe.isMDXComponent=!0;const yhe={toc:[]},dhe="wrapper";function hhe(e){let{components:n,...t}=e;return(0,s.yg)(dhe,(0,p.A)({},yhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hhe.isMDXComponent=!0;const ghe={toc:[]},fhe="wrapper";function Dhe(e){let{components:n,...t}=e;return(0,s.yg)(fhe,(0,p.A)({},ghe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Dhe.isMDXComponent=!0;const Mhe={toc:[]},Xhe="wrapper";function _he(e){let{components:n,...t}=e;return(0,s.yg)(Xhe,(0,p.A)({},Mhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_he.isMDXComponent=!0;const whe={toc:[]},The="wrapper";function Che(e){let{components:n,...t}=e;return(0,s.yg)(The,(0,p.A)({},whe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Che.isMDXComponent=!0;const xhe={toc:[]},Ahe="wrapper";function vhe(e){let{components:n,...t}=e;return(0,s.yg)(Ahe,(0,p.A)({},xhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}vhe.isMDXComponent=!0;const Lhe={toc:[]},bhe="wrapper";function Nhe(e){let{components:n,...t}=e;return(0,s.yg)(bhe,(0,p.A)({},Lhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Nhe.isMDXComponent=!0;const khe={toc:[]},zhe="wrapper";function Phe(e){let{components:n,...t}=e;return(0,s.yg)(zhe,(0,p.A)({},khe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Phe.isMDXComponent=!0;const Ihe={toc:[]},Rhe="wrapper";function Whe(e){let{components:n,...t}=e;return(0,s.yg)(Rhe,(0,p.A)({},Ihe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}Whe.isMDXComponent=!0;const She={toc:[]},Bhe="wrapper";function Ghe(e){let{components:n,...t}=e;return(0,s.yg)(Bhe,(0,p.A)({},She,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}Ghe.isMDXComponent=!0;const Ehe={toc:[]},Ohe="wrapper";function Uhe(e){let{components:n,...t}=e;return(0,s.yg)(Ohe,(0,p.A)({},Ehe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing circular shapes."))}Uhe.isMDXComponent=!0;const Fhe={toc:[]},Vhe="wrapper";function qhe(e){let{components:n,...t}=e;return(0,s.yg)(Vhe,(0,p.A)({},Fhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}qhe.isMDXComponent=!0;const jhe={toc:[]},Hhe="wrapper";function Yhe(e){let{components:n,...t}=e;return(0,s.yg)(Hhe,(0,p.A)({},jhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Yhe.isMDXComponent=!0;const Qhe={toc:[]},$he="wrapper";function Khe(e){let{components:n,...t}=e;return(0,s.yg)($he,(0,p.A)({},Qhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Khe.isMDXComponent=!0;const Jhe={toc:[]},Zhe="wrapper";function ege(e){let{components:n,...t}=e;return(0,s.yg)(Zhe,(0,p.A)({},Jhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}ege.isMDXComponent=!0;const nge={toc:[]},tge="wrapper";function oge(e){let{components:n,...t}=e;return(0,s.yg)(tge,(0,p.A)({},nge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}oge.isMDXComponent=!0;const pge={toc:[]},rge="wrapper";function sge(e){let{components:n,...t}=e;return(0,s.yg)(rge,(0,p.A)({},pge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}sge.isMDXComponent=!0;const cge={toc:[]},age="wrapper";function ige(e){let{components:n,...t}=e;return(0,s.yg)(age,(0,p.A)({},cge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}ige.isMDXComponent=!0;const lge={toc:[]},uge="wrapper";function mge(e){let{components:n,...t}=e;return(0,s.yg)(uge,(0,p.A)({},lge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}mge.isMDXComponent=!0;const yge={toc:[]},dge="wrapper";function hge(e){let{components:n,...t}=e;return(0,s.yg)(dge,(0,p.A)({},yge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hge.isMDXComponent=!0;const gge={toc:[]},fge="wrapper";function Dge(e){let{components:n,...t}=e;return(0,s.yg)(fge,(0,p.A)({},gge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Dge.isMDXComponent=!0;const Mge={toc:[]},Xge="wrapper";function _ge(e){let{components:n,...t}=e;return(0,s.yg)(Xge,(0,p.A)({},Mge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}_ge.isMDXComponent=!0;const wge={toc:[]},Tge="wrapper";function Cge(e){let{components:n,...t}=e;return(0,s.yg)(Tge,(0,p.A)({},wge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Cge.isMDXComponent=!0;const xge={toc:[]},Age="wrapper";function vge(e){let{components:n,...t}=e;return(0,s.yg)(Age,(0,p.A)({},xge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}vge.isMDXComponent=!0;const Lge={toc:[]},bge="wrapper";function Nge(e){let{components:n,...t}=e;return(0,s.yg)(bge,(0,p.A)({},Lge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Nge.isMDXComponent=!0;const kge={toc:[]},zge="wrapper";function Pge(e){let{components:n,...t}=e;return(0,s.yg)(zge,(0,p.A)({},kge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Pge.isMDXComponent=!0;const Ige={toc:[]},Rge="wrapper";function Wge(e){let{components:n,...t}=e;return(0,s.yg)(Rge,(0,p.A)({},Ige,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Wge.isMDXComponent=!0;const Sge={toc:[]},Bge="wrapper";function Gge(e){let{components:n,...t}=e;return(0,s.yg)(Bge,(0,p.A)({},Sge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}Gge.isMDXComponent=!0;const Ege={toc:[]},Oge="wrapper";function Uge(e){let{components:n,...t}=e;return(0,s.yg)(Oge,(0,p.A)({},Ege,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A closed circle will look like a pie chart:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.yg)("p",null,"An open one will look like an arc:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}Uge.isMDXComponent=!0;const Fge={toc:[]},Vge="wrapper";function qge(e){let{components:n,...t}=e;return(0,s.yg)(Vge,(0,p.A)({},Fge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"false"))}qge.isMDXComponent=!0;const jge={toc:[]},Hge="wrapper";function Yge(e){let{components:n,...t}=e;return(0,s.yg)(Hge,(0,p.A)({},jge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the path of this circle should be closed."))}Yge.isMDXComponent=!0;const Qge={toc:[]},$ge="wrapper";function Kge(e){let{components:n,...t}=e;return(0,s.yg)($ge,(0,p.A)({},Qge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the circle begins at ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}Kge.isMDXComponent=!0;const Jge={toc:[]},Zge="wrapper";function efe(e){let{components:n,...t}=e;return(0,s.yg)(Zge,(0,p.A)({},Jge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the circle sector should be drawn counterclockwise."))}efe.isMDXComponent=!0;const nfe={toc:[]},tfe="wrapper";function ofe(e){let{components:n,...t}=e;return(0,s.yg)(tfe,(0,p.A)({},nfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ofe.isMDXComponent=!0;const pfe={toc:[]},rfe="wrapper";function sfe(e){let{components:n,...t}=e;return(0,s.yg)(rfe,(0,p.A)({},pfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}sfe.isMDXComponent=!0;const cfe={toc:[]},afe="wrapper";function ife(e){let{components:n,...t}=e;return(0,s.yg)(afe,(0,p.A)({},cfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}ife.isMDXComponent=!0;const lfe={toc:[]},ufe="wrapper";function mfe(e){let{components:n,...t}=e;return(0,s.yg)(ufe,(0,p.A)({},lfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"360"))}mfe.isMDXComponent=!0;const yfe={toc:[]},dfe="wrapper";function hfe(e){let{components:n,...t}=e;return(0,s.yg)(dfe,(0,p.A)({},yfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending angle in degrees for the circle sector."))}hfe.isMDXComponent=!0;const gfe={toc:[]},ffe="wrapper";function Dfe(e){let{components:n,...t}=e;return(0,s.yg)(ffe,(0,p.A)({},gfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Dfe.isMDXComponent=!0;const Mfe={toc:[]},Xfe="wrapper";function _fe(e){let{components:n,...t}=e;return(0,s.yg)(Xfe,(0,p.A)({},Mfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}_fe.isMDXComponent=!0;const wfe={toc:[]},Tfe="wrapper";function Cfe(e){let{components:n,...t}=e;return(0,s.yg)(Tfe,(0,p.A)({},wfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Cfe.isMDXComponent=!0;const xfe={toc:[]},Afe="wrapper";function vfe(e){let{components:n,...t}=e;return(0,s.yg)(Afe,(0,p.A)({},xfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}vfe.isMDXComponent=!0;const Lfe={toc:[]},bfe="wrapper";function Nfe(e){let{components:n,...t}=e;return(0,s.yg)(bfe,(0,p.A)({},Lfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Nfe.isMDXComponent=!0;const kfe={toc:[]},zfe="wrapper";function Pfe(e){let{components:n,...t}=e;return(0,s.yg)(zfe,(0,p.A)({},kfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Pfe.isMDXComponent=!0;const Ife={toc:[]},Rfe="wrapper";function Wfe(e){let{components:n,...t}=e;return(0,s.yg)(Rfe,(0,p.A)({},Ife,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Wfe.isMDXComponent=!0;const Sfe={toc:[]},Bfe="wrapper";function Gfe(e){let{components:n,...t}=e;return(0,s.yg)(Bfe,(0,p.A)({},Sfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Gfe.isMDXComponent=!0;const Efe={toc:[]},Ofe="wrapper";function Ufe(e){let{components:n,...t}=e;return(0,s.yg)(Ofe,(0,p.A)({},Efe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ufe.isMDXComponent=!0;const Ffe={toc:[]},Vfe="wrapper";function qfe(e){let{components:n,...t}=e;return(0,s.yg)(Vfe,(0,p.A)({},Ffe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}qfe.isMDXComponent=!0;const jfe={toc:[]},Hfe="wrapper";function Yfe(e){let{components:n,...t}=e;return(0,s.yg)(Hfe,(0,p.A)({},jfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Yfe.isMDXComponent=!0;const Qfe={toc:[]},$fe="wrapper";function Kfe(e){let{components:n,...t}=e;return(0,s.yg)($fe,(0,p.A)({},Qfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]},Zfe="wrapper";function eDe(e){let{components:n,...t}=e;return(0,s.yg)(Zfe,(0,p.A)({},Jfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eDe.isMDXComponent=!0;const nDe={toc:[]},tDe="wrapper";function oDe(e){let{components:n,...t}=e;return(0,s.yg)(tDe,(0,p.A)({},nDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}oDe.isMDXComponent=!0;const pDe={toc:[]},rDe="wrapper";function sDe(e){let{components:n,...t}=e;return(0,s.yg)(rDe,(0,p.A)({},pDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}sDe.isMDXComponent=!0;const cDe={toc:[]},aDe="wrapper";function iDe(e){let{components:n,...t}=e;return(0,s.yg)(aDe,(0,p.A)({},cDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}iDe.isMDXComponent=!0;const lDe={toc:[]},uDe="wrapper";function mDe(e){let{components:n,...t}=e;return(0,s.yg)(uDe,(0,p.A)({},lDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mDe.isMDXComponent=!0;const yDe={toc:[]},dDe="wrapper";function hDe(e){let{components:n,...t}=e;return(0,s.yg)(dDe,(0,p.A)({},yDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}hDe.isMDXComponent=!0;const gDe={toc:[]},fDe="wrapper";function DDe(e){let{components:n,...t}=e;return(0,s.yg)(fDe,(0,p.A)({},gDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}DDe.isMDXComponent=!0;const MDe={toc:[]},XDe="wrapper";function _De(e){let{components:n,...t}=e;return(0,s.yg)(XDe,(0,p.A)({},MDe,t,{components:n,mdxType:"MDXLayout"}))}_De.isMDXComponent=!0;const wDe={toc:[]},TDe="wrapper";function CDe(e){let{components:n,...t}=e;return(0,s.yg)(TDe,(0,p.A)({},wDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}CDe.isMDXComponent=!0;const xDe={toc:[]},ADe="wrapper";function vDe(e){let{components:n,...t}=e;return(0,s.yg)(ADe,(0,p.A)({},xDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}vDe.isMDXComponent=!0;const LDe={toc:[]},bDe="wrapper";function NDe(e){let{components:n,...t}=e;return(0,s.yg)(bDe,(0,p.A)({},LDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}NDe.isMDXComponent=!0;const kDe={toc:[]},zDe="wrapper";function PDe(e){let{components:n,...t}=e;return(0,s.yg)(zDe,(0,p.A)({},kDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}PDe.isMDXComponent=!0;const IDe={toc:[]},RDe="wrapper";function WDe(e){let{components:n,...t}=e;return(0,s.yg)(RDe,(0,p.A)({},IDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}WDe.isMDXComponent=!0;const SDe={toc:[]},BDe="wrapper";function GDe(e){let{components:n,...t}=e;return(0,s.yg)(BDe,(0,p.A)({},SDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}GDe.isMDXComponent=!0;const EDe={toc:[]},ODe="wrapper";function UDe(e){let{components:n,...t}=e;return(0,s.yg)(ODe,(0,p.A)({},EDe,t,{components:n,mdxType:"MDXLayout"}))}UDe.isMDXComponent=!0;const FDe={toc:[]},VDe="wrapper";function qDe(e){let{components:n,...t}=e;return(0,s.yg)(VDe,(0,p.A)({},FDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}qDe.isMDXComponent=!0;const jDe={toc:[]},HDe="wrapper";function YDe(e){let{components:n,...t}=e;return(0,s.yg)(HDe,(0,p.A)({},jDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}YDe.isMDXComponent=!0;const QDe={toc:[]},$De="wrapper";function KDe(e){let{components:n,...t}=e;return(0,s.yg)($De,(0,p.A)({},QDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}KDe.isMDXComponent=!0;const JDe={toc:[]},ZDe="wrapper";function eMe(e){let{components:n,...t}=e;return(0,s.yg)(ZDe,(0,p.A)({},JDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0"))}eMe.isMDXComponent=!0;const nMe={toc:[]},tMe="wrapper";function oMe(e){let{components:n,...t}=e;return(0,s.yg)(tMe,(0,p.A)({},nMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting angle in degrees for the circle sector."))}oMe.isMDXComponent=!0;const pMe={toc:[]},rMe="wrapper";function sMe(e){let{components:n,...t}=e;return(0,s.yg)(rMe,(0,p.A)({},pMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sMe.isMDXComponent=!0;const cMe={toc:[]},aMe="wrapper";function iMe(e){let{components:n,...t}=e;return(0,s.yg)(aMe,(0,p.A)({},cMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}iMe.isMDXComponent=!0;const lMe={toc:[]},uMe="wrapper";function mMe(e){let{components:n,...t}=e;return(0,s.yg)(uMe,(0,p.A)({},lMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}mMe.isMDXComponent=!0;const yMe={toc:[]},dMe="wrapper";function hMe(e){let{components:n,...t}=e;return(0,s.yg)(dMe,(0,p.A)({},yMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}hMe.isMDXComponent=!0;const gMe={toc:[]},fMe="wrapper";function DMe(e){let{components:n,...t}=e;return(0,s.yg)(fMe,(0,p.A)({},gMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}DMe.isMDXComponent=!0;const MMe={toc:[]},XMe="wrapper";function _Me(e){let{components:n,...t}=e;return(0,s.yg)(XMe,(0,p.A)({},MMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}_Me.isMDXComponent=!0;const wMe={toc:[]},TMe="wrapper";function CMe(e){let{components:n,...t}=e;return(0,s.yg)(TMe,(0,p.A)({},wMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}CMe.isMDXComponent=!0;const xMe={toc:[]},AMe="wrapper";function vMe(e){let{components:n,...t}=e;return(0,s.yg)(AMe,(0,p.A)({},xMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}vMe.isMDXComponent=!0;const LMe={toc:[]},bMe="wrapper";function NMe(e){let{components:n,...t}=e;return(0,s.yg)(bMe,(0,p.A)({},LMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}NMe.isMDXComponent=!0;const kMe={toc:[]},zMe="wrapper";function PMe(e){let{components:n,...t}=e;return(0,s.yg)(zMe,(0,p.A)({},kMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}PMe.isMDXComponent=!0;const IMe={toc:[]},RMe="wrapper";function WMe(e){let{components:n,...t}=e;return(0,s.yg)(RMe,(0,p.A)({},IMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}WMe.isMDXComponent=!0;const SMe={toc:[]},BMe="wrapper";function GMe(e){let{components:n,...t}=e;return(0,s.yg)(BMe,(0,p.A)({},SMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}GMe.isMDXComponent=!0;const EMe={toc:[]},OMe="wrapper";function UMe(e){let{components:n,...t}=e;return(0,s.yg)(OMe,(0,p.A)({},EMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}UMe.isMDXComponent=!0;const FMe={toc:[]},VMe="wrapper";function qMe(e){let{components:n,...t}=e;return(0,s.yg)(VMe,(0,p.A)({},FMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}qMe.isMDXComponent=!0;const jMe={toc:[]},HMe="wrapper";function YMe(e){let{components:n,...t}=e;return(0,s.yg)(HMe,(0,p.A)({},jMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}YMe.isMDXComponent=!0;const QMe={toc:[]},$Me="wrapper";function KMe(e){let{components:n,...t}=e;return(0,s.yg)($Me,(0,p.A)({},QMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}KMe.isMDXComponent=!0;const JMe={toc:[]},ZMe="wrapper";function eXe(e){let{components:n,...t}=e;return(0,s.yg)(ZMe,(0,p.A)({},JMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}eXe.isMDXComponent=!0;const nXe={toc:[]},tXe="wrapper";function oXe(e){let{components:n,...t}=e;return(0,s.yg)(tXe,(0,p.A)({},nXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}oXe.isMDXComponent=!0;const pXe={toc:[]},rXe="wrapper";function sXe(e){let{components:n,...t}=e;return(0,s.yg)(rXe,(0,p.A)({},pXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}sXe.isMDXComponent=!0;const cXe={toc:[]},aXe="wrapper";function iXe(e){let{components:n,...t}=e;return(0,s.yg)(aXe,(0,p.A)({},cXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}iXe.isMDXComponent=!0;const lXe={toc:[]},uXe="wrapper";function mXe(e){let{components:n,...t}=e;return(0,s.yg)(uXe,(0,p.A)({},lXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}mXe.isMDXComponent=!0;const yXe={toc:[]},dXe="wrapper";function hXe(e){let{components:n,...t}=e;return(0,s.yg)(dXe,(0,p.A)({},yXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}hXe.isMDXComponent=!0;const gXe={toc:[]},fXe="wrapper";function DXe(e){let{components:n,...t}=e;return(0,s.yg)(fXe,(0,p.A)({},gXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}DXe.isMDXComponent=!0;const MXe={toc:[]},XXe="wrapper";function _Xe(e){let{components:n,...t}=e;return(0,s.yg)(XXe,(0,p.A)({},MXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}_Xe.isMDXComponent=!0;const wXe={toc:[]},TXe="wrapper";function CXe(e){let{components:n,...t}=e;return(0,s.yg)(TXe,(0,p.A)({},wXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CXe.isMDXComponent=!0;const xXe={toc:[]},AXe="wrapper";function vXe(e){let{components:n,...t}=e;return(0,s.yg)(AXe,(0,p.A)({},xXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vXe.isMDXComponent=!0;const LXe={toc:[]},bXe="wrapper";function NXe(e){let{components:n,...t}=e;return(0,s.yg)(bXe,(0,p.A)({},LXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}NXe.isMDXComponent=!0;const kXe={toc:[]},zXe="wrapper";function PXe(e){let{components:n,...t}=e;return(0,s.yg)(zXe,(0,p.A)({},kXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}PXe.isMDXComponent=!0;const IXe={toc:[]},RXe="wrapper";function WXe(e){let{components:n,...t}=e;return(0,s.yg)(RXe,(0,p.A)({},IXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}WXe.isMDXComponent=!0;const SXe={toc:[]},BXe="wrapper";function GXe(e){let{components:n,...t}=e;return(0,s.yg)(BXe,(0,p.A)({},SXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}GXe.isMDXComponent=!0;const EXe={toc:[]},OXe="wrapper";function UXe(e){let{components:n,...t}=e;return(0,s.yg)(OXe,(0,p.A)({},EXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}UXe.isMDXComponent=!0;const FXe={toc:[]},VXe="wrapper";function qXe(e){let{components:n,...t}=e;return(0,s.yg)(VXe,(0,p.A)({},FXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}qXe.isMDXComponent=!0;const jXe={toc:[]},HXe="wrapper";function YXe(e){let{components:n,...t}=e;return(0,s.yg)(HXe,(0,p.A)({},jXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}YXe.isMDXComponent=!0;const QXe={toc:[]},$Xe="wrapper";function KXe(e){let{components:n,...t}=e;return(0,s.yg)($Xe,(0,p.A)({},QXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}KXe.isMDXComponent=!0;const JXe={toc:[]},ZXe="wrapper";function e_e(e){let{components:n,...t}=e;return(0,s.yg)(ZXe,(0,p.A)({},JXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}e_e.isMDXComponent=!0;const n_e={toc:[]},t_e="wrapper";function o_e(e){let{components:n,...t}=e;return(0,s.yg)(t_e,(0,p.A)({},n_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}o_e.isMDXComponent=!0;const p_e={toc:[]},r_e="wrapper";function s_e(e){let{components:n,...t}=e;return(0,s.yg)(r_e,(0,p.A)({},p_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}s_e.isMDXComponent=!0;const c_e={toc:[]},a_e="wrapper";function i_e(e){let{components:n,...t}=e;return(0,s.yg)(a_e,(0,p.A)({},c_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}i_e.isMDXComponent=!0;const l_e={toc:[]},u_e="wrapper";function m_e(e){let{components:n,...t}=e;return(0,s.yg)(u_e,(0,p.A)({},l_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}m_e.isMDXComponent=!0;const y_e={toc:[]},d_e="wrapper";function h_e(e){let{components:n,...t}=e;return(0,s.yg)(d_e,(0,p.A)({},y_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}h_e.isMDXComponent=!0;const g_e={toc:[]},f_e="wrapper";function D_e(e){let{components:n,...t}=e;return(0,s.yg)(f_e,(0,p.A)({},g_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}D_e.isMDXComponent=!0;const M_e={toc:[]},X_e="wrapper";function __e(e){let{components:n,...t}=e;return(0,s.yg)(X_e,(0,p.A)({},M_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}__e.isMDXComponent=!0;const w_e={toc:[]},T_e="wrapper";function C_e(e){let{components:n,...t}=e;return(0,s.yg)(T_e,(0,p.A)({},w_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}C_e.isMDXComponent=!0;const x_e={toc:[]},A_e="wrapper";function v_e(e){let{components:n,...t}=e;return(0,s.yg)(A_e,(0,p.A)({},x_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}v_e.isMDXComponent=!0;const L_e={toc:[]},b_e="wrapper";function N_e(e){let{components:n,...t}=e;return(0,s.yg)(b_e,(0,p.A)({},L_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}N_e.isMDXComponent=!0;const k_e={toc:[]},z_e="wrapper";function P_e(e){let{components:n,...t}=e;return(0,s.yg)(z_e,(0,p.A)({},k_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}P_e.isMDXComponent=!0;const I_e={toc:[]},R_e="wrapper";function W_e(e){let{components:n,...t}=e;return(0,s.yg)(R_e,(0,p.A)({},I_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}W_e.isMDXComponent=!0;const S_e={toc:[]},B_e="wrapper";function G_e(e){let{components:n,...t}=e;return(0,s.yg)(B_e,(0,p.A)({},S_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}G_e.isMDXComponent=!0;const E_e={toc:[]},O_e="wrapper";function U_e(e){let{components:n,...t}=e;return(0,s.yg)(O_e,(0,p.A)({},E_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}U_e.isMDXComponent=!0;const F_e={toc:[]},V_e="wrapper";function q_e(e){let{components:n,...t}=e;return(0,s.yg)(V_e,(0,p.A)({},F_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}q_e.isMDXComponent=!0;const j_e={toc:[]},H_e="wrapper";function Y_e(e){let{components:n,...t}=e;return(0,s.yg)(H_e,(0,p.A)({},j_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Y_e.isMDXComponent=!0;const Q_e={toc:[]},$_e="wrapper";function K_e(e){let{components:n,...t}=e;return(0,s.yg)($_e,(0,p.A)({},Q_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}K_e.isMDXComponent=!0;const J_e={toc:[]},Z_e="wrapper";function ewe(e){let{components:n,...t}=e;return(0,s.yg)(Z_e,(0,p.A)({},J_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}ewe.isMDXComponent=!0;const nwe={toc:[]},twe="wrapper";function owe(e){let{components:n,...t}=e;return(0,s.yg)(twe,(0,p.A)({},nwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}owe.isMDXComponent=!0;const pwe={toc:[]},rwe="wrapper";function swe(e){let{components:n,...t}=e;return(0,s.yg)(rwe,(0,p.A)({},pwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}swe.isMDXComponent=!0;const cwe={toc:[]},awe="wrapper";function iwe(e){let{components:n,...t}=e;return(0,s.yg)(awe,(0,p.A)({},cwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}iwe.isMDXComponent=!0;const lwe={toc:[]},uwe="wrapper";function mwe(e){let{components:n,...t}=e;return(0,s.yg)(uwe,(0,p.A)({},lwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}mwe.isMDXComponent=!0;const ywe={toc:[]},dwe="wrapper";function hwe(e){let{components:n,...t}=e;return(0,s.yg)(dwe,(0,p.A)({},ywe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hwe.isMDXComponent=!0;const gwe={toc:[]},fwe="wrapper";function Dwe(e){let{components:n,...t}=e;return(0,s.yg)(fwe,(0,p.A)({},gwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Dwe.isMDXComponent=!0;const Mwe={toc:[]},Xwe="wrapper";function _we(e){let{components:n,...t}=e;return(0,s.yg)(Xwe,(0,p.A)({},Mwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_we.isMDXComponent=!0;const wwe={toc:[]},Twe="wrapper";function Cwe(e){let{components:n,...t}=e;return(0,s.yg)(Twe,(0,p.A)({},wwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Cwe.isMDXComponent=!0;const xwe={toc:[]},Awe="wrapper";function vwe(e){let{components:n,...t}=e;return(0,s.yg)(Awe,(0,p.A)({},xwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vwe.isMDXComponent=!0;const Lwe={toc:[]},bwe="wrapper";function Nwe(e){let{components:n,...t}=e;return(0,s.yg)(bwe,(0,p.A)({},Lwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Nwe.isMDXComponent=!0;const kwe={toc:[]},zwe="wrapper";function Pwe(e){let{components:n,...t}=e;return(0,s.yg)(zwe,(0,p.A)({},kwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Pwe.isMDXComponent=!0;const Iwe={toc:[]},Rwe="wrapper";function Wwe(e){let{components:n,...t}=e;return(0,s.yg)(Rwe,(0,p.A)({},Iwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wwe.isMDXComponent=!0;const Swe={toc:[]},Bwe="wrapper";function Gwe(e){let{components:n,...t}=e;return(0,s.yg)(Bwe,(0,p.A)({},Swe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Gwe.isMDXComponent=!0;const Ewe={toc:[]},Owe="wrapper";function Uwe(e){let{components:n,...t}=e;return(0,s.yg)(Owe,(0,p.A)({},Ewe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Uwe.isMDXComponent=!0;const Fwe={toc:[]},Vwe="wrapper";function qwe(e){let{components:n,...t}=e;return(0,s.yg)(Vwe,(0,p.A)({},Fwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qwe.isMDXComponent=!0;const jwe={toc:[]},Hwe="wrapper";function Ywe(e){let{components:n,...t}=e;return(0,s.yg)(Hwe,(0,p.A)({},jwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Ywe.isMDXComponent=!0;const Qwe={toc:[]},$we="wrapper";function Kwe(e){let{components:n,...t}=e;return(0,s.yg)($we,(0,p.A)({},Qwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]},Zwe="wrapper";function eTe(e){let{components:n,...t}=e;return(0,s.yg)(Zwe,(0,p.A)({},Jwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}eTe.isMDXComponent=!0;const nTe={toc:[]},tTe="wrapper";function oTe(e){let{components:n,...t}=e;return(0,s.yg)(tTe,(0,p.A)({},nTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}oTe.isMDXComponent=!0;const pTe={toc:[]},rTe="wrapper";function sTe(e){let{components:n,...t}=e;return(0,s.yg)(rTe,(0,p.A)({},pTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}sTe.isMDXComponent=!0;const cTe={toc:[]},aTe="wrapper";function iTe(e){let{components:n,...t}=e;return(0,s.yg)(aTe,(0,p.A)({},cTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}iTe.isMDXComponent=!0;const lTe={toc:[]},uTe="wrapper";function mTe(e){let{components:n,...t}=e;return(0,s.yg)(uTe,(0,p.A)({},lTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}mTe.isMDXComponent=!0;const yTe={toc:[]},dTe="wrapper";function hTe(e){let{components:n,...t}=e;return(0,s.yg)(dTe,(0,p.A)({},yTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}hTe.isMDXComponent=!0;const gTe={toc:[]},fTe="wrapper";function DTe(e){let{components:n,...t}=e;return(0,s.yg)(fTe,(0,p.A)({},gTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}DTe.isMDXComponent=!0;const MTe={toc:[]},XTe="wrapper";function _Te(e){let{components:n,...t}=e;return(0,s.yg)(XTe,(0,p.A)({},MTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}_Te.isMDXComponent=!0;const wTe={toc:[]},TTe="wrapper";function CTe(e){let{components:n,...t}=e;return(0,s.yg)(TTe,(0,p.A)({},wTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}CTe.isMDXComponent=!0;const xTe={toc:[]},ATe="wrapper";function vTe(e){let{components:n,...t}=e;return(0,s.yg)(ATe,(0,p.A)({},xTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}vTe.isMDXComponent=!0;const LTe={toc:[]},bTe="wrapper";function NTe(e){let{components:n,...t}=e;return(0,s.yg)(bTe,(0,p.A)({},LTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}NTe.isMDXComponent=!0;const kTe={toc:[]},zTe="wrapper";function PTe(e){let{components:n,...t}=e;return(0,s.yg)(zTe,(0,p.A)({},kTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}PTe.isMDXComponent=!0;const ITe={toc:[]},RTe="wrapper";function WTe(e){let{components:n,...t}=e;return(0,s.yg)(RTe,(0,p.A)({},ITe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}WTe.isMDXComponent=!0;const STe={toc:[]},BTe="wrapper";function GTe(e){let{components:n,...t}=e;return(0,s.yg)(BTe,(0,p.A)({},STe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}GTe.isMDXComponent=!0;const ETe={toc:[]},OTe="wrapper";function UTe(e){let{components:n,...t}=e;return(0,s.yg)(OTe,(0,p.A)({},ETe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}UTe.isMDXComponent=!0;const FTe={toc:[]},VTe="wrapper";function qTe(e){let{components:n,...t}=e;return(0,s.yg)(VTe,(0,p.A)({},FTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}qTe.isMDXComponent=!0;const jTe={toc:[]},HTe="wrapper";function YTe(e){let{components:n,...t}=e;return(0,s.yg)(HTe,(0,p.A)({},jTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}YTe.isMDXComponent=!0;const QTe={toc:[]},$Te="wrapper";function KTe(e){let{components:n,...t}=e;return(0,s.yg)($Te,(0,p.A)({},QTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}KTe.isMDXComponent=!0;const JTe={toc:[]},ZTe="wrapper";function eCe(e){let{components:n,...t}=e;return(0,s.yg)(ZTe,(0,p.A)({},JTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}eCe.isMDXComponent=!0;const nCe={toc:[]},tCe="wrapper";function oCe(e){let{components:n,...t}=e;return(0,s.yg)(tCe,(0,p.A)({},nCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}oCe.isMDXComponent=!0;const pCe={toc:[]},rCe="wrapper";function sCe(e){let{components:n,...t}=e;return(0,s.yg)(rCe,(0,p.A)({},pCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}sCe.isMDXComponent=!0;const cCe={toc:[]},aCe="wrapper";function iCe(e){let{components:n,...t}=e;return(0,s.yg)(aCe,(0,p.A)({},cCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}iCe.isMDXComponent=!0;const lCe={toc:[]},uCe="wrapper";function mCe(e){let{components:n,...t}=e;return(0,s.yg)(uCe,(0,p.A)({},lCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}mCe.isMDXComponent=!0;const yCe={toc:[]},dCe="wrapper";function hCe(e){let{components:n,...t}=e;return(0,s.yg)(dCe,(0,p.A)({},yCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hCe.isMDXComponent=!0;const gCe={toc:[]},fCe="wrapper";function DCe(e){let{components:n,...t}=e;return(0,s.yg)(fCe,(0,p.A)({},gCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}DCe.isMDXComponent=!0;const MCe={toc:[]},XCe="wrapper";function _Ce(e){let{components:n,...t}=e;return(0,s.yg)(XCe,(0,p.A)({},MCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}_Ce.isMDXComponent=!0;const wCe={toc:[]},TCe="wrapper";function CCe(e){let{components:n,...t}=e;return(0,s.yg)(TCe,(0,p.A)({},wCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}CCe.isMDXComponent=!0;const xCe={toc:[]},ACe="wrapper";function vCe(e){let{components:n,...t}=e;return(0,s.yg)(ACe,(0,p.A)({},xCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}vCe.isMDXComponent=!0;const LCe={toc:[]},bCe="wrapper";function NCe(e){let{components:n,...t}=e;return(0,s.yg)(bCe,(0,p.A)({},LCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}NCe.isMDXComponent=!0;const kCe={toc:[]},zCe="wrapper";function PCe(e){let{components:n,...t}=e;return(0,s.yg)(zCe,(0,p.A)({},kCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}PCe.isMDXComponent=!0;const ICe={toc:[]},RCe="wrapper";function WCe(e){let{components:n,...t}=e;return(0,s.yg)(RCe,(0,p.A)({},ICe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}WCe.isMDXComponent=!0;const SCe={toc:[]},BCe="wrapper";function GCe(e){let{components:n,...t}=e;return(0,s.yg)(BCe,(0,p.A)({},SCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}GCe.isMDXComponent=!0;const ECe={toc:[]},OCe="wrapper";function UCe(e){let{components:n,...t}=e;return(0,s.yg)(OCe,(0,p.A)({},ECe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}UCe.isMDXComponent=!0;const FCe={toc:[]},VCe="wrapper";function qCe(e){let{components:n,...t}=e;return(0,s.yg)(VCe,(0,p.A)({},FCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}qCe.isMDXComponent=!0;const jCe={toc:[]},HCe="wrapper";function YCe(e){let{components:n,...t}=e;return(0,s.yg)(HCe,(0,p.A)({},jCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}YCe.isMDXComponent=!0;const QCe={toc:[]},$Ce="wrapper";function KCe(e){let{components:n,...t}=e;return(0,s.yg)($Ce,(0,p.A)({},QCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}KCe.isMDXComponent=!0;const JCe={toc:[]},ZCe="wrapper";function exe(e){let{components:n,...t}=e;return(0,s.yg)(ZCe,(0,p.A)({},JCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}exe.isMDXComponent=!0;const nxe={toc:[]},txe="wrapper";function oxe(e){let{components:n,...t}=e;return(0,s.yg)(txe,(0,p.A)({},nxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}oxe.isMDXComponent=!0;const pxe={toc:[]},rxe="wrapper";function sxe(e){let{components:n,...t}=e;return(0,s.yg)(rxe,(0,p.A)({},pxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}sxe.isMDXComponent=!0;const cxe={toc:[]},axe="wrapper";function ixe(e){let{components:n,...t}=e;return(0,s.yg)(axe,(0,p.A)({},cxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ixe.isMDXComponent=!0;const lxe={toc:[]},uxe="wrapper";function mxe(e){let{components:n,...t}=e;return(0,s.yg)(uxe,(0,p.A)({},lxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}mxe.isMDXComponent=!0;const yxe={toc:[]},dxe="wrapper";function hxe(e){let{components:n,...t}=e;return(0,s.yg)(dxe,(0,p.A)({},yxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}hxe.isMDXComponent=!0;const gxe={toc:[]},fxe="wrapper";function Dxe(e){let{components:n,...t}=e;return(0,s.yg)(fxe,(0,p.A)({},gxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Dxe.isMDXComponent=!0;const Mxe={toc:[]},Xxe="wrapper";function _xe(e){let{components:n,...t}=e;return(0,s.yg)(Xxe,(0,p.A)({},Mxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}_xe.isMDXComponent=!0;const wxe={toc:[]},Txe="wrapper";function Cxe(e){let{components:n,...t}=e;return(0,s.yg)(Txe,(0,p.A)({},wxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Cxe.isMDXComponent=!0;const xxe={toc:[]},Axe="wrapper";function vxe(e){let{components:n,...t}=e;return(0,s.yg)(Axe,(0,p.A)({},xxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}vxe.isMDXComponent=!0;const Lxe={toc:[]},bxe="wrapper";function Nxe(e){let{components:n,...t}=e;return(0,s.yg)(bxe,(0,p.A)({},Lxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Nxe.isMDXComponent=!0;const kxe={toc:[]},zxe="wrapper";function Pxe(e){let{components:n,...t}=e;return(0,s.yg)(zxe,(0,p.A)({},kxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Pxe.isMDXComponent=!0;const Ixe={toc:[]},Rxe="wrapper";function Wxe(e){let{components:n,...t}=e;return(0,s.yg)(Rxe,(0,p.A)({},Ixe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Wxe.isMDXComponent=!0;const Sxe={toc:[]},Bxe="wrapper";function Gxe(e){let{components:n,...t}=e;return(0,s.yg)(Bxe,(0,p.A)({},Sxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Gxe.isMDXComponent=!0;const Exe={toc:[]},Oxe="wrapper";function Uxe(e){let{components:n,...t}=e;return(0,s.yg)(Oxe,(0,p.A)({},Exe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Uxe.isMDXComponent=!0;const Fxe={toc:[]},Vxe="wrapper";function qxe(e){let{components:n,...t}=e;return(0,s.yg)(Vxe,(0,p.A)({},Fxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qxe.isMDXComponent=!0;const jxe={toc:[]},Hxe="wrapper";function Yxe(e){let{components:n,...t}=e;return(0,s.yg)(Hxe,(0,p.A)({},jxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Yxe.isMDXComponent=!0;const Qxe={toc:[]},$xe="wrapper";function Kxe(e){let{components:n,...t}=e;return(0,s.yg)($xe,(0,p.A)({},Qxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Kxe.isMDXComponent=!0;const Jxe={toc:[]},Zxe="wrapper";function eAe(e){let{components:n,...t}=e;return(0,s.yg)(Zxe,(0,p.A)({},Jxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}eAe.isMDXComponent=!0;const nAe={toc:[]},tAe="wrapper";function oAe(e){let{components:n,...t}=e;return(0,s.yg)(tAe,(0,p.A)({},nAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}oAe.isMDXComponent=!0;const pAe={toc:[]},rAe="wrapper";function sAe(e){let{components:n,...t}=e;return(0,s.yg)(rAe,(0,p.A)({},pAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}sAe.isMDXComponent=!0;const cAe={toc:[]},aAe="wrapper";function iAe(e){let{components:n,...t}=e;return(0,s.yg)(aAe,(0,p.A)({},cAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}iAe.isMDXComponent=!0;const lAe={toc:[]},uAe="wrapper";function mAe(e){let{components:n,...t}=e;return(0,s.yg)(uAe,(0,p.A)({},lAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}mAe.isMDXComponent=!0;const yAe={toc:[]},dAe="wrapper";function hAe(e){let{components:n,...t}=e;return(0,s.yg)(dAe,(0,p.A)({},yAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}hAe.isMDXComponent=!0;const gAe={toc:[]},fAe="wrapper";function DAe(e){let{components:n,...t}=e;return(0,s.yg)(fAe,(0,p.A)({},gAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}DAe.isMDXComponent=!0;const MAe={toc:[]},XAe="wrapper";function _Ae(e){let{components:n,...t}=e;return(0,s.yg)(XAe,(0,p.A)({},MAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}_Ae.isMDXComponent=!0;const wAe={toc:[]},TAe="wrapper";function CAe(e){let{components:n,...t}=e;return(0,s.yg)(TAe,(0,p.A)({},wAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}CAe.isMDXComponent=!0;const xAe={toc:[]},AAe="wrapper";function vAe(e){let{components:n,...t}=e;return(0,s.yg)(AAe,(0,p.A)({},xAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}vAe.isMDXComponent=!0;const LAe={toc:[]},bAe="wrapper";function NAe(e){let{components:n,...t}=e;return(0,s.yg)(bAe,(0,p.A)({},LAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}NAe.isMDXComponent=!0;const kAe={toc:[]},zAe="wrapper";function PAe(e){let{components:n,...t}=e;return(0,s.yg)(zAe,(0,p.A)({},kAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}PAe.isMDXComponent=!0;const IAe={toc:[]},RAe="wrapper";function WAe(e){let{components:n,...t}=e;return(0,s.yg)(RAe,(0,p.A)({},IAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}WAe.isMDXComponent=!0;const SAe={toc:[]},BAe="wrapper";function GAe(e){let{components:n,...t}=e;return(0,s.yg)(BAe,(0,p.A)({},SAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}GAe.isMDXComponent=!0;const EAe={toc:[]},OAe="wrapper";function UAe(e){let{components:n,...t}=e;return(0,s.yg)(OAe,(0,p.A)({},EAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}UAe.isMDXComponent=!0;const FAe={toc:[]},VAe="wrapper";function qAe(e){let{components:n,...t}=e;return(0,s.yg)(VAe,(0,p.A)({},FAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}qAe.isMDXComponent=!0;const jAe={toc:[]},HAe="wrapper";function YAe(e){let{components:n,...t}=e;return(0,s.yg)(HAe,(0,p.A)({},jAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}YAe.isMDXComponent=!0;const QAe={toc:[]},$Ae="wrapper";function KAe(e){let{components:n,...t}=e;return(0,s.yg)($Ae,(0,p.A)({},QAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}KAe.isMDXComponent=!0;const JAe={toc:[]},ZAe="wrapper";function eve(e){let{components:n,...t}=e;return(0,s.yg)(ZAe,(0,p.A)({},JAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}eve.isMDXComponent=!0;const nve={toc:[]},tve="wrapper";function ove(e){let{components:n,...t}=e;return(0,s.yg)(tve,(0,p.A)({},nve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}ove.isMDXComponent=!0;const pve={toc:[]},rve="wrapper";function sve(e){let{components:n,...t}=e;return(0,s.yg)(rve,(0,p.A)({},pve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}sve.isMDXComponent=!0;const cve={toc:[]},ave="wrapper";function ive(e){let{components:n,...t}=e;return(0,s.yg)(ave,(0,p.A)({},cve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ive.isMDXComponent=!0;const lve={toc:[]},uve="wrapper";function mve(e){let{components:n,...t}=e;return(0,s.yg)(uve,(0,p.A)({},lve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}mve.isMDXComponent=!0;const yve={toc:[]},dve="wrapper";function hve(e){let{components:n,...t}=e;return(0,s.yg)(dve,(0,p.A)({},yve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}hve.isMDXComponent=!0;const gve={toc:[]},fve="wrapper";function Dve(e){let{components:n,...t}=e;return(0,s.yg)(fve,(0,p.A)({},gve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Dve.isMDXComponent=!0;const Mve={toc:[]},Xve="wrapper";function _ve(e){let{components:n,...t}=e;return(0,s.yg)(Xve,(0,p.A)({},Mve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}_ve.isMDXComponent=!0;const wve={toc:[]},Tve="wrapper";function Cve(e){let{components:n,...t}=e;return(0,s.yg)(Tve,(0,p.A)({},wve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Cve.isMDXComponent=!0;const xve={toc:[]},Ave="wrapper";function vve(e){let{components:n,...t}=e;return(0,s.yg)(Ave,(0,p.A)({},xve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}vve.isMDXComponent=!0;const Lve={toc:[]},bve="wrapper";function Nve(e){let{components:n,...t}=e;return(0,s.yg)(bve,(0,p.A)({},Lve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Nve.isMDXComponent=!0;const kve={toc:[]},zve="wrapper";function Pve(e){let{components:n,...t}=e;return(0,s.yg)(zve,(0,p.A)({},kve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Pve.isMDXComponent=!0;const Ive={toc:[]},Rve="wrapper";function Wve(e){let{components:n,...t}=e;return(0,s.yg)(Rve,(0,p.A)({},Ive,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Wve.isMDXComponent=!0;const Sve={toc:[]},Bve="wrapper";function Gve(e){let{components:n,...t}=e;return(0,s.yg)(Bve,(0,p.A)({},Sve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Gve.isMDXComponent=!0;const Eve={toc:[]},Ove="wrapper";function Uve(e){let{components:n,...t}=e;return(0,s.yg)(Ove,(0,p.A)({},Eve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Uve.isMDXComponent=!0;const Fve={toc:[]},Vve="wrapper";function qve(e){let{components:n,...t}=e;return(0,s.yg)(Vve,(0,p.A)({},Fve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qve.isMDXComponent=!0;const jve={toc:[]},Hve="wrapper";function Yve(e){let{components:n,...t}=e;return(0,s.yg)(Hve,(0,p.A)({},jve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Yve.isMDXComponent=!0;const Qve={toc:[]},$ve="wrapper";function Kve(e){let{components:n,...t}=e;return(0,s.yg)($ve,(0,p.A)({},Qve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Kve.isMDXComponent=!0;const Jve={toc:[]},Zve="wrapper";function eLe(e){let{components:n,...t}=e;return(0,s.yg)(Zve,(0,p.A)({},Jve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}eLe.isMDXComponent=!0;const nLe={toc:[]},tLe="wrapper";function oLe(e){let{components:n,...t}=e;return(0,s.yg)(tLe,(0,p.A)({},nLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}oLe.isMDXComponent=!0;const pLe={toc:[]},rLe="wrapper";function sLe(e){let{components:n,...t}=e;return(0,s.yg)(rLe,(0,p.A)({},pLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}sLe.isMDXComponent=!0;const cLe={toc:[]},aLe="wrapper";function iLe(e){let{components:n,...t}=e;return(0,s.yg)(aLe,(0,p.A)({},cLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}iLe.isMDXComponent=!0;const lLe={toc:[]},uLe="wrapper";function mLe(e){let{components:n,...t}=e;return(0,s.yg)(uLe,(0,p.A)({},lLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}mLe.isMDXComponent=!0;const yLe={toc:[]},dLe="wrapper";function hLe(e){let{components:n,...t}=e;return(0,s.yg)(dLe,(0,p.A)({},yLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}hLe.isMDXComponent=!0;const gLe={toc:[]},fLe="wrapper";function DLe(e){let{components:n,...t}=e;return(0,s.yg)(fLe,(0,p.A)({},gLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {parser} from '@lezer/javascript';\nimport {Code, LezerHighlighter, makeScene2D} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  LezerHighlighter.registerParser(parser);\n  const code = createRef<Code>();\n\n  view.add(\n    <Code\n      ref={code}\n      offset={-1}\n      position={view.size().scale(-0.5).add(60)}\n      fontFamily={'JetBrains Mono, monospace'}\n      fontSize={36}\n      code={`\\\nfunction hello() {\n  console.log('Hello');\n}`}\n    />,\n  );\n\n  yield* code()\n    .code(\n      `\\\nfunction hello() {\n  console.warn('Hello World');\n}`,\n      1,\n    )\n    .wait(0.5)\n    .back(1)\n    .wait(0.5);\n});\n")))}DLe.isMDXComponent=!0;const MLe={toc:[]},XLe="wrapper";function _Le(e){let{components:n,...t}=e;return(0,s.yg)(XLe,(0,p.A)({},MLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for displaying and animating code."))}_Le.isMDXComponent=!0;const wLe={toc:[]},TLe="wrapper";function CLe(e){let{components:n,...t}=e;return(0,s.yg)(TLe,(0,p.A)({},wLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}CLe.isMDXComponent=!0;const xLe={toc:[]},ALe="wrapper";function vLe(e){let{components:n,...t}=e;return(0,s.yg)(ALe,(0,p.A)({},xLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}vLe.isMDXComponent=!0;const LLe={toc:[]},bLe="wrapper";function NLe(e){let{components:n,...t}=e;return(0,s.yg)(bLe,(0,p.A)({},LLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NLe.isMDXComponent=!0;const kLe={toc:[]},zLe="wrapper";function PLe(e){let{components:n,...t}=e;return(0,s.yg)(zLe,(0,p.A)({},kLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}PLe.isMDXComponent=!0;const ILe={toc:[]},RLe="wrapper";function WLe(e){let{components:n,...t}=e;return(0,s.yg)(RLe,(0,p.A)({},ILe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}WLe.isMDXComponent=!0;const SLe={toc:[]},BLe="wrapper";function GLe(e){let{components:n,...t}=e;return(0,s.yg)(BLe,(0,p.A)({},SLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}GLe.isMDXComponent=!0;const ELe={toc:[]},OLe="wrapper";function ULe(e){let{components:n,...t}=e;return(0,s.yg)(OLe,(0,p.A)({},ELe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}ULe.isMDXComponent=!0;const FLe={toc:[]},VLe="wrapper";function qLe(e){let{components:n,...t}=e;return(0,s.yg)(VLe,(0,p.A)({},FLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}qLe.isMDXComponent=!0;const jLe={toc:[]},HLe="wrapper";function YLe(e){let{components:n,...t}=e;return(0,s.yg)(HLe,(0,p.A)({},jLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}YLe.isMDXComponent=!0;const QLe={toc:[]},$Le="wrapper";function KLe(e){let{components:n,...t}=e;return(0,s.yg)($Le,(0,p.A)({},QLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}KLe.isMDXComponent=!0;const JLe={toc:[]},ZLe="wrapper";function ebe(e){let{components:n,...t}=e;return(0,s.yg)(ZLe,(0,p.A)({},JLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}ebe.isMDXComponent=!0;const nbe={toc:[]},tbe="wrapper";function obe(e){let{components:n,...t}=e;return(0,s.yg)(tbe,(0,p.A)({},nbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}obe.isMDXComponent=!0;const pbe={toc:[]},rbe="wrapper";function sbe(e){let{components:n,...t}=e;return(0,s.yg)(rbe,(0,p.A)({},pbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}sbe.isMDXComponent=!0;const cbe={toc:[]},abe="wrapper";function ibe(e){let{components:n,...t}=e;return(0,s.yg)(abe,(0,p.A)({},cbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ibe.isMDXComponent=!0;const lbe={toc:[]},ube="wrapper";function mbe(e){let{components:n,...t}=e;return(0,s.yg)(ube,(0,p.A)({},lbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to display."))}mbe.isMDXComponent=!0;const ybe={toc:[]},dbe="wrapper";function hbe(e){let{components:n,...t}=e;return(0,s.yg)(dbe,(0,p.A)({},ybe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This value will be passed to the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeHighlighter")),"\ndefined by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#highlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"highlighter"))," property. Different highlighters may use\nit differently."),(0,s.yg)("p",null,"The default ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter"))," uses it to select\nthe language parser to use. The parser for the given dialect can be\nregistered as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// Import the lezer parser:\nimport {parser} from '@lezer/javascript';\n\n// Register it in the highlighter:\nLezerHighlighter.registerParser(parser, 'js');\n\n// Use the dialect in a code node:\n<Code dialect=\"js\" code=\"const a = 7;\" />\n")),(0,s.yg)("p",null,"When no dialect is provided, the highlighter will use the default\nparser:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'// Register the default parser by omitting the dialect:\nLezerHighlighter.registerParser(parser);\n\n// Code nodes with no dialect will now use the default parser:\n<Code code="const a = 7;" />\n')))}hbe.isMDXComponent=!0;const gbe={toc:[]},fbe="wrapper";function Dbe(e){let{components:n,...t}=e;return(0,s.yg)(fbe,(0,p.A)({},gbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The dialect to use for highlighting the code."))}Dbe.isMDXComponent=!0;const Mbe={toc:[]},Xbe="wrapper";function _be(e){let{components:n,...t}=e;return(0,s.yg)(Xbe,(0,p.A)({},Mbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check out ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.yg)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}_be.isMDXComponent=!0;const wbe={toc:[]},Tbe="wrapper";function Cbe(e){let{components:n,...t}=e;return(0,s.yg)(Tbe,(0,p.A)({},wbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Make the unselected code blurry and transparent:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  drawHooks={{\n    token(ctx, text, position, color, selection) {\n      const blur = map(3, 0, selection);\n      const alpha = map(0.5, 1, selection);\n      ctx.globalAlpha *= alpha;\n      ctx.filter = `blur(${blur}px)`;\n      ctx.fillStyle = color;\n      ctx.fillText(text, position.x, position.y);\n    },\n  }}\n  // ...\n/>\n")))}Cbe.isMDXComponent=!0;const xbe={toc:[]},Abe="wrapper";function vbe(e){let{components:n,...t}=e;return(0,s.yg)(Abe,(0,p.A)({},xbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for the code."))}vbe.isMDXComponent=!0;const Lbe={toc:[]},bbe="wrapper";function Nbe(e){let{components:n,...t}=e;return(0,s.yg)(bbe,(0,p.A)({},Lbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defaults to a shared ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}Nbe.isMDXComponent=!0;const kbe={toc:[]},zbe="wrapper";function Pbe(e){let{components:n,...t}=e;return(0,s.yg)(zbe,(0,p.A)({},kbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code highlighter to use for this code node."))}Pbe.isMDXComponent=!0;const Ibe={toc:[]},Rbe="wrapper";function Wbe(e){let{components:n,...t}=e;return(0,s.yg)(Rbe,(0,p.A)({},Ibe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Wbe.isMDXComponent=!0;const Sbe={toc:[]},Bbe="wrapper";function Gbe(e){let{components:n,...t}=e;return(0,s.yg)(Bbe,(0,p.A)({},Sbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Gbe.isMDXComponent=!0;const Ebe={toc:[]},Obe="wrapper";function Ube(e){let{components:n,...t}=e;return(0,s.yg)(Obe,(0,p.A)({},Ebe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Ube.isMDXComponent=!0;const Fbe={toc:[]},Vbe="wrapper";function qbe(e){let{components:n,...t}=e;return(0,s.yg)(Vbe,(0,p.A)({},Fbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}qbe.isMDXComponent=!0;const jbe={toc:[]},Hbe="wrapper";function Ybe(e){let{components:n,...t}=e;return(0,s.yg)(Hbe,(0,p.A)({},jbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ybe.isMDXComponent=!0;const Qbe={toc:[]},$be="wrapper";function Kbe(e){let{components:n,...t}=e;return(0,s.yg)($be,(0,p.A)({},Qbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Kbe.isMDXComponent=!0;const Jbe={toc:[]},Zbe="wrapper";function eNe(e){let{components:n,...t}=e;return(0,s.yg)(Zbe,(0,p.A)({},Jbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}eNe.isMDXComponent=!0;const nNe={toc:[]},tNe="wrapper";function oNe(e){let{components:n,...t}=e;return(0,s.yg)(tNe,(0,p.A)({},nNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}oNe.isMDXComponent=!0;const pNe={toc:[]},rNe="wrapper";function sNe(e){let{components:n,...t}=e;return(0,s.yg)(rNe,(0,p.A)({},pNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}sNe.isMDXComponent=!0;const cNe={toc:[]},aNe="wrapper";function iNe(e){let{components:n,...t}=e;return(0,s.yg)(aNe,(0,p.A)({},cNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}iNe.isMDXComponent=!0;const lNe={toc:[]},uNe="wrapper";function mNe(e){let{components:n,...t}=e;return(0,s.yg)(uNe,(0,p.A)({},lNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}mNe.isMDXComponent=!0;const yNe={toc:[]},dNe="wrapper";function hNe(e){let{components:n,...t}=e;return(0,s.yg)(dNe,(0,p.A)({},yNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}hNe.isMDXComponent=!0;const gNe={toc:[]},fNe="wrapper";function DNe(e){let{components:n,...t}=e;return(0,s.yg)(fNe,(0,p.A)({},gNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}DNe.isMDXComponent=!0;const MNe={toc:[]},XNe="wrapper";function _Ne(e){let{components:n,...t}=e;return(0,s.yg)(XNe,(0,p.A)({},MNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_Ne.isMDXComponent=!0;const wNe={toc:[]},TNe="wrapper";function CNe(e){let{components:n,...t}=e;return(0,s.yg)(TNe,(0,p.A)({},wNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}CNe.isMDXComponent=!0;const xNe={toc:[]},ANe="wrapper";function vNe(e){let{components:n,...t}=e;return(0,s.yg)(ANe,(0,p.A)({},xNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a single ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.yg)("p",null,"You can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.yg)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.yg)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}vNe.isMDXComponent=!0;const LNe={toc:[]},bNe="wrapper";function NNe(e){let{components:n,...t}=e;return(0,s.yg)(bNe,(0,p.A)({},LNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,'The following will select the word "console" in the code.\nBoth lines and columns are 0-based. So it will select a 7-character-long\n(',(0,s.yg)("inlineCode",{parentName:"p"},"7"),") word in the second line (",(0,s.yg)("inlineCode",{parentName:"p"},"1"),") starting at the third character (",(0,s.yg)("inlineCode",{parentName:"p"},"2"),")."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  selection={word(1, 2, 7)}\n  code={`\\\nfunction hello() => {\n  console.log('Hello');\n}`}\n  // ...\n/>\n")))}NNe.isMDXComponent=!0;const kNe={toc:[]},zNe="wrapper";function PNe(e){let{components:n,...t}=e;return(0,s.yg)(zNe,(0,p.A)({},kNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The currently selected code range."))}PNe.isMDXComponent=!0;const INe={toc:[]},RNe="wrapper";function WNe(e){let{components:n,...t}=e;return(0,s.yg)(RNe,(0,p.A)({},INe,t,{components:n,mdxType:"MDXLayout"}))}WNe.isMDXComponent=!0;const SNe={toc:[]},BNe="wrapper";function GNe(e){let{components:n,...t}=e;return(0,s.yg)(BNe,(0,p.A)({},SNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}GNe.isMDXComponent=!0;const ENe={toc:[]},ONe="wrapper";function UNe(e){let{components:n,...t}=e;return(0,s.yg)(ONe,(0,p.A)({},ENe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}UNe.isMDXComponent=!0;const FNe={toc:[]},VNe="wrapper";function qNe(e){let{components:n,...t}=e;return(0,s.yg)(VNe,(0,p.A)({},FNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}qNe.isMDXComponent=!0;const jNe={toc:[]},HNe="wrapper";function YNe(e){let{components:n,...t}=e;return(0,s.yg)(HNe,(0,p.A)({},jNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}YNe.isMDXComponent=!0;const QNe={toc:[]},$Ne="wrapper";function KNe(e){let{components:n,...t}=e;return(0,s.yg)($Ne,(0,p.A)({},QNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}KNe.isMDXComponent=!0;const JNe={toc:[]},ZNe="wrapper";function eke(e){let{components:n,...t}=e;return(0,s.yg)(ZNe,(0,p.A)({},JNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}eke.isMDXComponent=!0;const nke={toc:[]},tke="wrapper";function oke(e){let{components:n,...t}=e;return(0,s.yg)(tke,(0,p.A)({},nke,t,{components:n,mdxType:"MDXLayout"}))}oke.isMDXComponent=!0;const pke={toc:[]},rke="wrapper";function ske(e){let{components:n,...t}=e;return(0,s.yg)(rke,(0,p.A)({},pke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ske.isMDXComponent=!0;const cke={toc:[]},ake="wrapper";function ike(e){let{components:n,...t}=e;return(0,s.yg)(ake,(0,p.A)({},cke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}ike.isMDXComponent=!0;const lke={toc:[]},uke="wrapper";function mke(e){let{components:n,...t}=e;return(0,s.yg)(uke,(0,p.A)({},lke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}mke.isMDXComponent=!0;const yke={toc:[]},dke="wrapper";function hke(e){let{components:n,...t}=e;return(0,s.yg)(dke,(0,p.A)({},yke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}hke.isMDXComponent=!0;const gke={toc:[]},fke="wrapper";function Dke(e){let{components:n,...t}=e;return(0,s.yg)(fke,(0,p.A)({},gke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Dke.isMDXComponent=!0;const Mke={toc:[]},Xke="wrapper";function _ke(e){let{components:n,...t}=e;return(0,s.yg)(Xke,(0,p.A)({},Mke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}_ke.isMDXComponent=!0;const wke={toc:[]},Tke="wrapper";function Cke(e){let{components:n,...t}=e;return(0,s.yg)(Tke,(0,p.A)({},wke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Cke.isMDXComponent=!0;const xke={toc:[]},Ake="wrapper";function vke(e){let{components:n,...t}=e;return(0,s.yg)(Ake,(0,p.A)({},xke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vke.isMDXComponent=!0;const Lke={toc:[]},bke="wrapper";function Nke(e){let{components:n,...t}=e;return(0,s.yg)(bke,(0,p.A)({},Lke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Nke.isMDXComponent=!0;const kke={toc:[]},zke="wrapper";function Pke(e){let{components:n,...t}=e;return(0,s.yg)(zke,(0,p.A)({},kke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Pke.isMDXComponent=!0;const Ike={toc:[]},Rke="wrapper";function Wke(e){let{components:n,...t}=e;return(0,s.yg)(Rke,(0,p.A)({},Ike,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Wke.isMDXComponent=!0;const Ske={toc:[]},Bke="wrapper";function Gke(e){let{components:n,...t}=e;return(0,s.yg)(Bke,(0,p.A)({},Ske,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Gke.isMDXComponent=!0;const Eke={toc:[]},Oke="wrapper";function Uke(e){let{components:n,...t}=e;return(0,s.yg)(Oke,(0,p.A)({},Eke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Uke.isMDXComponent=!0;const Fke={toc:[]},Vke="wrapper";function qke(e){let{components:n,...t}=e;return(0,s.yg)(Vke,(0,p.A)({},Fke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}qke.isMDXComponent=!0;const jke={toc:[]},Hke="wrapper";function Yke(e){let{components:n,...t}=e;return(0,s.yg)(Hke,(0,p.A)({},jke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Yke.isMDXComponent=!0;const Qke={toc:[]},$ke="wrapper";function Kke(e){let{components:n,...t}=e;return(0,s.yg)($ke,(0,p.A)({},Qke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Kke.isMDXComponent=!0;const Jke={toc:[]},Zke="wrapper";function eze(e){let{components:n,...t}=e;return(0,s.yg)(Zke,(0,p.A)({},Jke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eze.isMDXComponent=!0;const nze={toc:[]},tze="wrapper";function oze(e){let{components:n,...t}=e;return(0,s.yg)(tze,(0,p.A)({},nze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}oze.isMDXComponent=!0;const pze={toc:[]},rze="wrapper";function sze(e){let{components:n,...t}=e;return(0,s.yg)(rze,(0,p.A)({},pze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}sze.isMDXComponent=!0;const cze={toc:[]},aze="wrapper";function ize(e){let{components:n,...t}=e;return(0,s.yg)(aze,(0,p.A)({},cze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}ize.isMDXComponent=!0;const lze={toc:[]},uze="wrapper";function mze(e){let{components:n,...t}=e;return(0,s.yg)(uze,(0,p.A)({},lze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}mze.isMDXComponent=!0;const yze={toc:[]},dze="wrapper";function hze(e){let{components:n,...t}=e;return(0,s.yg)(dze,(0,p.A)({},yze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}hze.isMDXComponent=!0;const gze={toc:[]},fze="wrapper";function Dze(e){let{components:n,...t}=e;return(0,s.yg)(fze,(0,p.A)({},gze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Dze.isMDXComponent=!0;const Mze={toc:[]},Xze="wrapper";function _ze(e){let{components:n,...t}=e;return(0,s.yg)(Xze,(0,p.A)({},Mze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}_ze.isMDXComponent=!0;const wze={toc:[]},Tze="wrapper";function Cze(e){let{components:n,...t}=e;return(0,s.yg)(Tze,(0,p.A)({},wze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Cze.isMDXComponent=!0;const xze={toc:[]},Aze="wrapper";function vze(e){let{components:n,...t}=e;return(0,s.yg)(Aze,(0,p.A)({},xze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}vze.isMDXComponent=!0;const Lze={toc:[]},bze="wrapper";function Nze(e){let{components:n,...t}=e;return(0,s.yg)(bze,(0,p.A)({},Lze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a child code signal."))}Nze.isMDXComponent=!0;const kze={toc:[]},zze="wrapper";function Pze(e){let{components:n,...t}=e;return(0,s.yg)(zze,(0,p.A)({},kze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial code."))}Pze.isMDXComponent=!0;const Ize={toc:[]},Rze="wrapper";function Wze(e){let{components:n,...t}=e;return(0,s.yg)(Rze,(0,p.A)({},Ize,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Wze.isMDXComponent=!0;const Sze={toc:[]},Bze="wrapper";function Gze(e){let{components:n,...t}=e;return(0,s.yg)(Bze,(0,p.A)({},Sze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Gze.isMDXComponent=!0;const Eze={toc:[]},Oze="wrapper";function Uze(e){let{components:n,...t}=e;return(0,s.yg)(Oze,(0,p.A)({},Eze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Uze.isMDXComponent=!0;const Fze={toc:[]},Vze="wrapper";function qze(e){let{components:n,...t}=e;return(0,s.yg)(Vze,(0,p.A)({},Fze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}qze.isMDXComponent=!0;const jze={toc:[]},Hze="wrapper";function Yze(e){let{components:n,...t}=e;return(0,s.yg)(Hze,(0,p.A)({},jze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Yze.isMDXComponent=!0;const Qze={toc:[]},$ze="wrapper";function Kze(e){let{components:n,...t}=e;return(0,s.yg)($ze,(0,p.A)({},Qze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Kze.isMDXComponent=!0;const Jze={toc:[]},Zze="wrapper";function ePe(e){let{components:n,...t}=e;return(0,s.yg)(Zze,(0,p.A)({},Jze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}ePe.isMDXComponent=!0;const nPe={toc:[]},tPe="wrapper";function oPe(e){let{components:n,...t}=e;return(0,s.yg)(tPe,(0,p.A)({},nPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}oPe.isMDXComponent=!0;const pPe={toc:[]},rPe="wrapper";function sPe(e){let{components:n,...t}=e;return(0,s.yg)(rPe,(0,p.A)({},pPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}sPe.isMDXComponent=!0;const cPe={toc:[]},aPe="wrapper";function iPe(e){let{components:n,...t}=e;return(0,s.yg)(aPe,(0,p.A)({},cPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}iPe.isMDXComponent=!0;const lPe={toc:[]},uPe="wrapper";function mPe(e){let{components:n,...t}=e;return(0,s.yg)(uPe,(0,p.A)({},lPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}mPe.isMDXComponent=!0;const yPe={toc:[]},dPe="wrapper";function hPe(e){let{components:n,...t}=e;return(0,s.yg)(dPe,(0,p.A)({},yPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}hPe.isMDXComponent=!0;const gPe={toc:[]},fPe="wrapper";function DPe(e){let{components:n,...t}=e;return(0,s.yg)(fPe,(0,p.A)({},gPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DPe.isMDXComponent=!0;const MPe={toc:[]},XPe="wrapper";function _Pe(e){let{components:n,...t}=e;return(0,s.yg)(XPe,(0,p.A)({},MPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}_Pe.isMDXComponent=!0;const wPe={toc:[]},TPe="wrapper";function CPe(e){let{components:n,...t}=e;return(0,s.yg)(TPe,(0,p.A)({},wPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}CPe.isMDXComponent=!0;const xPe={toc:[]},APe="wrapper";function vPe(e){let{components:n,...t}=e;return(0,s.yg)(APe,(0,p.A)({},xPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all code ranges that match the given pattern."))}vPe.isMDXComponent=!0;const LPe={toc:[]},bPe="wrapper";function NPe(e){let{components:n,...t}=e;return(0,s.yg)(bPe,(0,p.A)({},LPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}NPe.isMDXComponent=!0;const kPe={toc:[]},zPe="wrapper";function PPe(e){let{components:n,...t}=e;return(0,s.yg)(zPe,(0,p.A)({},kPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}PPe.isMDXComponent=!0;const IPe={toc:[]},RPe="wrapper";function WPe(e){let{components:n,...t}=e;return(0,s.yg)(RPe,(0,p.A)({},IPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}WPe.isMDXComponent=!0;const SPe={toc:[]},BPe="wrapper";function GPe(e){let{components:n,...t}=e;return(0,s.yg)(BPe,(0,p.A)({},SPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}GPe.isMDXComponent=!0;const EPe={toc:[]},OPe="wrapper";function UPe(e){let{components:n,...t}=e;return(0,s.yg)(OPe,(0,p.A)({},EPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}UPe.isMDXComponent=!0;const FPe={toc:[]},VPe="wrapper";function qPe(e){let{components:n,...t}=e;return(0,s.yg)(VPe,(0,p.A)({},FPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}qPe.isMDXComponent=!0;const jPe={toc:[]},HPe="wrapper";function YPe(e){let{components:n,...t}=e;return(0,s.yg)(HPe,(0,p.A)({},jPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}YPe.isMDXComponent=!0;const QPe={toc:[]},$Pe="wrapper";function KPe(e){let{components:n,...t}=e;return(0,s.yg)($Pe,(0,p.A)({},QPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}KPe.isMDXComponent=!0;const JPe={toc:[]},ZPe="wrapper";function eIe(e){let{components:n,...t}=e;return(0,s.yg)(ZPe,(0,p.A)({},JPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eIe.isMDXComponent=!0;const nIe={toc:[]},tIe="wrapper";function oIe(e){let{components:n,...t}=e;return(0,s.yg)(tIe,(0,p.A)({},nIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first code range that matches the given pattern."))}oIe.isMDXComponent=!0;const pIe={toc:[]},rIe="wrapper";function sIe(e){let{components:n,...t}=e;return(0,s.yg)(rIe,(0,p.A)({},pIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}sIe.isMDXComponent=!0;const cIe={toc:[]},aIe="wrapper";function iIe(e){let{components:n,...t}=e;return(0,s.yg)(aIe,(0,p.A)({},cIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}iIe.isMDXComponent=!0;const lIe={toc:[]},uIe="wrapper";function mIe(e){let{components:n,...t}=e;return(0,s.yg)(uIe,(0,p.A)({},lIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mIe.isMDXComponent=!0;const yIe={toc:[]},dIe="wrapper";function hIe(e){let{components:n,...t}=e;return(0,s.yg)(dIe,(0,p.A)({},yIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}hIe.isMDXComponent=!0;const gIe={toc:[]},fIe="wrapper";function DIe(e){let{components:n,...t}=e;return(0,s.yg)(fIe,(0,p.A)({},gIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DIe.isMDXComponent=!0;const MIe={toc:[]},XIe="wrapper";function _Ie(e){let{components:n,...t}=e;return(0,s.yg)(XIe,(0,p.A)({},MIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last code range that matches the given pattern."))}_Ie.isMDXComponent=!0;const wIe={toc:[]},TIe="wrapper";function CIe(e){let{components:n,...t}=e;return(0,s.yg)(TIe,(0,p.A)({},wIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}CIe.isMDXComponent=!0;const xIe={toc:[]},AIe="wrapper";function vIe(e){let{components:n,...t}=e;return(0,s.yg)(AIe,(0,p.A)({},xIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}vIe.isMDXComponent=!0;const LIe={toc:[]},bIe="wrapper";function NIe(e){let{components:n,...t}=e;return(0,s.yg)(bIe,(0,p.A)({},LIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}NIe.isMDXComponent=!0;const kIe={toc:[]},zIe="wrapper";function PIe(e){let{components:n,...t}=e;return(0,s.yg)(zIe,(0,p.A)({},kIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}PIe.isMDXComponent=!0;const IIe={toc:[]},RIe="wrapper";function WIe(e){let{components:n,...t}=e;return(0,s.yg)(RIe,(0,p.A)({},IIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}WIe.isMDXComponent=!0;const SIe={toc:[]},BIe="wrapper";function GIe(e){let{components:n,...t}=e;return(0,s.yg)(BIe,(0,p.A)({},SIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bound box is in local space of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Code")," node."))}GIe.isMDXComponent=!0;const EIe={toc:[]},OIe="wrapper";function UIe(e){let{components:n,...t}=e;return(0,s.yg)(OIe,(0,p.A)({},EIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the bounding box of the given point (character) in the code."))}UIe.isMDXComponent=!0;const FIe={toc:[]},VIe="wrapper";function qIe(e){let{components:n,...t}=e;return(0,s.yg)(VIe,(0,p.A)({},FIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The point to get the bounding box for."))}qIe.isMDXComponent=!0;const jIe={toc:[]},HIe="wrapper";function YIe(e){let{components:n,...t}=e;return(0,s.yg)(HIe,(0,p.A)({},jIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bound boxes are in local space of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Code")," node.\nEach line of code has a separate bounding box."))}YIe.isMDXComponent=!0;const QIe={toc:[]},$Ie="wrapper";function KIe(e){let{components:n,...t}=e;return(0,s.yg)($Ie,(0,p.A)({},QIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return bounding boxes of all characters in the selection."))}KIe.isMDXComponent=!0;const JIe={toc:[]},ZIe="wrapper";function eRe(e){let{components:n,...t}=e;return(0,s.yg)(ZIe,(0,p.A)({},JIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The selection to get the bounding boxes for."))}eRe.isMDXComponent=!0;const nRe={toc:[]},tRe="wrapper";function oRe(e){let{components:n,...t}=e;return(0,s.yg)(tRe,(0,p.A)({},nRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}oRe.isMDXComponent=!0;const pRe={toc:[]},rRe="wrapper";function sRe(e){let{components:n,...t}=e;return(0,s.yg)(rRe,(0,p.A)({},pRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}sRe.isMDXComponent=!0;const cRe={toc:[]},aRe="wrapper";function iRe(e){let{components:n,...t}=e;return(0,s.yg)(aRe,(0,p.A)({},cRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}iRe.isMDXComponent=!0;const lRe={toc:[]},uRe="wrapper";function mRe(e){let{components:n,...t}=e;return(0,s.yg)(uRe,(0,p.A)({},lRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}mRe.isMDXComponent=!0;const yRe={toc:[]},dRe="wrapper";function hRe(e){let{components:n,...t}=e;return(0,s.yg)(dRe,(0,p.A)({},yRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}hRe.isMDXComponent=!0;const gRe={toc:[]},fRe="wrapper";function DRe(e){let{components:n,...t}=e;return(0,s.yg)(fRe,(0,p.A)({},gRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}DRe.isMDXComponent=!0;const MRe={toc:[]},XRe="wrapper";function _Re(e){let{components:n,...t}=e;return(0,s.yg)(XRe,(0,p.A)({},MRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}_Re.isMDXComponent=!0;const wRe={toc:[]},TRe="wrapper";function CRe(e){let{components:n,...t}=e;return(0,s.yg)(TRe,(0,p.A)({},wRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}CRe.isMDXComponent=!0;const xRe={toc:[]},ARe="wrapper";function vRe(e){let{components:n,...t}=e;return(0,s.yg)(ARe,(0,p.A)({},xRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}vRe.isMDXComponent=!0;const LRe={toc:[]},bRe="wrapper";function NRe(e){let{components:n,...t}=e;return(0,s.yg)(bRe,(0,p.A)({},LRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}NRe.isMDXComponent=!0;const kRe={toc:[]},zRe="wrapper";function PRe(e){let{components:n,...t}=e;return(0,s.yg)(zRe,(0,p.A)({},kRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}PRe.isMDXComponent=!0;const IRe={toc:[]},RRe="wrapper";function WRe(e){let{components:n,...t}=e;return(0,s.yg)(RRe,(0,p.A)({},IRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}WRe.isMDXComponent=!0;const SRe={toc:[]},BRe="wrapper";function GRe(e){let{components:n,...t}=e;return(0,s.yg)(BRe,(0,p.A)({},SRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}GRe.isMDXComponent=!0;const ERe={toc:[]},ORe="wrapper";function URe(e){let{components:n,...t}=e;return(0,s.yg)(ORe,(0,p.A)({},ERe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}URe.isMDXComponent=!0;const FRe={toc:[]},VRe="wrapper";function qRe(e){let{components:n,...t}=e;return(0,s.yg)(VRe,(0,p.A)({},FRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qRe.isMDXComponent=!0;const jRe={toc:[]},HRe="wrapper";function YRe(e){let{components:n,...t}=e;return(0,s.yg)(HRe,(0,p.A)({},jRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}YRe.isMDXComponent=!0;const QRe={toc:[]},$Re="wrapper";function KRe(e){let{components:n,...t}=e;return(0,s.yg)($Re,(0,p.A)({},QRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}KRe.isMDXComponent=!0;const JRe={toc:[]},ZRe="wrapper";function eWe(e){let{components:n,...t}=e;return(0,s.yg)(ZRe,(0,p.A)({},JRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}eWe.isMDXComponent=!0;const nWe={toc:[]},tWe="wrapper";function oWe(e){let{components:n,...t}=e;return(0,s.yg)(tWe,(0,p.A)({},nWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}oWe.isMDXComponent=!0;const pWe={toc:[]},rWe="wrapper";function sWe(e){let{components:n,...t}=e;return(0,s.yg)(rWe,(0,p.A)({},pWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}sWe.isMDXComponent=!0;const cWe={toc:[]},aWe="wrapper";function iWe(e){let{components:n,...t}=e;return(0,s.yg)(aWe,(0,p.A)({},cWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}iWe.isMDXComponent=!0;const lWe={toc:[]},uWe="wrapper";function mWe(e){let{components:n,...t}=e;return(0,s.yg)(uWe,(0,p.A)({},lWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}mWe.isMDXComponent=!0;const yWe={toc:[]},dWe="wrapper";function hWe(e){let{components:n,...t}=e;return(0,s.yg)(dWe,(0,p.A)({},yWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}hWe.isMDXComponent=!0;const gWe={toc:[]},fWe="wrapper";function DWe(e){let{components:n,...t}=e;return(0,s.yg)(fWe,(0,p.A)({},gWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}DWe.isMDXComponent=!0;const MWe={toc:[]},XWe="wrapper";function _We(e){let{components:n,...t}=e;return(0,s.yg)(XWe,(0,p.A)({},MWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_We.isMDXComponent=!0;const wWe={toc:[]},TWe="wrapper";function CWe(e){let{components:n,...t}=e;return(0,s.yg)(TWe,(0,p.A)({},wWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}CWe.isMDXComponent=!0;const xWe={toc:[]},AWe="wrapper";function vWe(e){let{components:n,...t}=e;return(0,s.yg)(AWe,(0,p.A)({},xWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}vWe.isMDXComponent=!0;const LWe={toc:[]},bWe="wrapper";function NWe(e){let{components:n,...t}=e;return(0,s.yg)(bWe,(0,p.A)({},LWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}NWe.isMDXComponent=!0;const kWe={toc:[]},zWe="wrapper";function PWe(e){let{components:n,...t}=e;return(0,s.yg)(zWe,(0,p.A)({},kWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}PWe.isMDXComponent=!0;const IWe={toc:[]},RWe="wrapper";function WWe(e){let{components:n,...t}=e;return(0,s.yg)(RWe,(0,p.A)({},IWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}WWe.isMDXComponent=!0;const SWe={toc:[]},BWe="wrapper";function GWe(e){let{components:n,...t}=e;return(0,s.yg)(BWe,(0,p.A)({},SWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}GWe.isMDXComponent=!0;const EWe={toc:[]},OWe="wrapper";function UWe(e){let{components:n,...t}=e;return(0,s.yg)(OWe,(0,p.A)({},EWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}UWe.isMDXComponent=!0;const FWe={toc:[]},VWe="wrapper";function qWe(e){let{components:n,...t}=e;return(0,s.yg)(VWe,(0,p.A)({},FWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qWe.isMDXComponent=!0;const jWe={toc:[]},HWe="wrapper";function YWe(e){let{components:n,...t}=e;return(0,s.yg)(HWe,(0,p.A)({},jWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}YWe.isMDXComponent=!0;const QWe={toc:[]},$We="wrapper";function KWe(e){let{components:n,...t}=e;return(0,s.yg)($We,(0,p.A)({},QWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}KWe.isMDXComponent=!0;const JWe={toc:[]},ZWe="wrapper";function eSe(e){let{components:n,...t}=e;return(0,s.yg)(ZWe,(0,p.A)({},JWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}eSe.isMDXComponent=!0;const nSe={toc:[]},tSe="wrapper";function oSe(e){let{components:n,...t}=e;return(0,s.yg)(tSe,(0,p.A)({},nSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}oSe.isMDXComponent=!0;const pSe={toc:[]},rSe="wrapper";function sSe(e){let{components:n,...t}=e;return(0,s.yg)(rSe,(0,p.A)({},pSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sSe.isMDXComponent=!0;const cSe={toc:[]},aSe="wrapper";function iSe(e){let{components:n,...t}=e;return(0,s.yg)(aSe,(0,p.A)({},cSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}iSe.isMDXComponent=!0;const lSe={toc:[]},uSe="wrapper";function mSe(e){let{components:n,...t}=e;return(0,s.yg)(uSe,(0,p.A)({},lSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}mSe.isMDXComponent=!0;const ySe={toc:[]},dSe="wrapper";function hSe(e){let{components:n,...t}=e;return(0,s.yg)(dSe,(0,p.A)({},ySe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}hSe.isMDXComponent=!0;const gSe={toc:[]},fSe="wrapper";function DSe(e){let{components:n,...t}=e;return(0,s.yg)(fSe,(0,p.A)({},gSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}DSe.isMDXComponent=!0;const MSe={toc:[]},XSe="wrapper";function _Se(e){let{components:n,...t}=e;return(0,s.yg)(XSe,(0,p.A)({},MSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}_Se.isMDXComponent=!0;const wSe={toc:[]},TSe="wrapper";function CSe(e){let{components:n,...t}=e;return(0,s.yg)(TSe,(0,p.A)({},wSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}CSe.isMDXComponent=!0;const xSe={toc:[]},ASe="wrapper";function vSe(e){let{components:n,...t}=e;return(0,s.yg)(ASe,(0,p.A)({},xSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the currently displayed code as a string."))}vSe.isMDXComponent=!0;const LSe={toc:[]},bSe="wrapper";function NSe(e){let{components:n,...t}=e;return(0,s.yg)(bSe,(0,p.A)({},LSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}NSe.isMDXComponent=!0;const kSe={toc:[]},zSe="wrapper";function PSe(e){let{components:n,...t}=e;return(0,s.yg)(zSe,(0,p.A)({},kSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}PSe.isMDXComponent=!0;const ISe={toc:[]},RSe="wrapper";function WSe(e){let{components:n,...t}=e;return(0,s.yg)(RSe,(0,p.A)({},ISe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}WSe.isMDXComponent=!0;const SSe={toc:[]},BSe="wrapper";function GSe(e){let{components:n,...t}=e;return(0,s.yg)(BSe,(0,p.A)({},SSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}GSe.isMDXComponent=!0;const ESe={toc:[]},OSe="wrapper";function USe(e){let{components:n,...t}=e;return(0,s.yg)(OSe,(0,p.A)({},ESe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}USe.isMDXComponent=!0;const FSe={toc:[]},VSe="wrapper";function qSe(e){let{components:n,...t}=e;return(0,s.yg)(VSe,(0,p.A)({},FSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}qSe.isMDXComponent=!0;const jSe={toc:[]},HSe="wrapper";function YSe(e){let{components:n,...t}=e;return(0,s.yg)(HSe,(0,p.A)({},jSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}YSe.isMDXComponent=!0;const QSe={toc:[]},$Se="wrapper";function KSe(e){let{components:n,...t}=e;return(0,s.yg)($Se,(0,p.A)({},QSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}KSe.isMDXComponent=!0;const JSe={toc:[]},ZSe="wrapper";function eBe(e){let{components:n,...t}=e;return(0,s.yg)(ZSe,(0,p.A)({},JSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}eBe.isMDXComponent=!0;const nBe={toc:[]},tBe="wrapper";function oBe(e){let{components:n,...t}=e;return(0,s.yg)(tBe,(0,p.A)({},nBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}oBe.isMDXComponent=!0;const pBe={toc:[]},rBe="wrapper";function sBe(e){let{components:n,...t}=e;return(0,s.yg)(rBe,(0,p.A)({},pBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sBe.isMDXComponent=!0;const cBe={toc:[]},aBe="wrapper";function iBe(e){let{components:n,...t}=e;return(0,s.yg)(aBe,(0,p.A)({},cBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}iBe.isMDXComponent=!0;const lBe={toc:[]},uBe="wrapper";function mBe(e){let{components:n,...t}=e;return(0,s.yg)(uBe,(0,p.A)({},lBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}mBe.isMDXComponent=!0;const yBe={toc:[]},dBe="wrapper";function hBe(e){let{components:n,...t}=e;return(0,s.yg)(dBe,(0,p.A)({},yBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}hBe.isMDXComponent=!0;const gBe={toc:[]},fBe="wrapper";function DBe(e){let{components:n,...t}=e;return(0,s.yg)(fBe,(0,p.A)({},gBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}DBe.isMDXComponent=!0;const MBe={toc:[]},XBe="wrapper";function _Be(e){let{components:n,...t}=e;return(0,s.yg)(XBe,(0,p.A)({},MBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}_Be.isMDXComponent=!0;const wBe={toc:[]},TBe="wrapper";function CBe(e){let{components:n,...t}=e;return(0,s.yg)(TBe,(0,p.A)({},wBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}CBe.isMDXComponent=!0;const xBe={toc:[]},ABe="wrapper";function vBe(e){let{components:n,...t}=e;return(0,s.yg)(ABe,(0,p.A)({},xBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}vBe.isMDXComponent=!0;const LBe={toc:[]},bBe="wrapper";function NBe(e){let{components:n,...t}=e;return(0,s.yg)(bBe,(0,p.A)({},LBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}NBe.isMDXComponent=!0;const kBe={toc:[]},zBe="wrapper";function PBe(e){let{components:n,...t}=e;return(0,s.yg)(zBe,(0,p.A)({},kBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PBe.isMDXComponent=!0;const IBe={toc:[]},RBe="wrapper";function WBe(e){let{components:n,...t}=e;return(0,s.yg)(RBe,(0,p.A)({},IBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}WBe.isMDXComponent=!0;const SBe={toc:[]},BBe="wrapper";function GBe(e){let{components:n,...t}=e;return(0,s.yg)(BBe,(0,p.A)({},SBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}GBe.isMDXComponent=!0;const EBe={toc:[]},OBe="wrapper";function UBe(e){let{components:n,...t}=e;return(0,s.yg)(OBe,(0,p.A)({},EBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}UBe.isMDXComponent=!0;const FBe={toc:[]},VBe="wrapper";function qBe(e){let{components:n,...t}=e;return(0,s.yg)(VBe,(0,p.A)({},FBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}qBe.isMDXComponent=!0;const jBe={toc:[]},HBe="wrapper";function YBe(e){let{components:n,...t}=e;return(0,s.yg)(HBe,(0,p.A)({},jBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}YBe.isMDXComponent=!0;const QBe={toc:[]},$Be="wrapper";function KBe(e){let{components:n,...t}=e;return(0,s.yg)($Be,(0,p.A)({},QBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}KBe.isMDXComponent=!0;const JBe={toc:[]},ZBe="wrapper";function eGe(e){let{components:n,...t}=e;return(0,s.yg)(ZBe,(0,p.A)({},JBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}eGe.isMDXComponent=!0;const nGe={toc:[]},tGe="wrapper";function oGe(e){let{components:n,...t}=e;return(0,s.yg)(tGe,(0,p.A)({},nGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}oGe.isMDXComponent=!0;const pGe={toc:[]},rGe="wrapper";function sGe(e){let{components:n,...t}=e;return(0,s.yg)(rGe,(0,p.A)({},pGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}sGe.isMDXComponent=!0;const cGe={toc:[]},aGe="wrapper";function iGe(e){let{components:n,...t}=e;return(0,s.yg)(aGe,(0,p.A)({},cGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}iGe.isMDXComponent=!0;const lGe={toc:[]},uGe="wrapper";function mGe(e){let{components:n,...t}=e;return(0,s.yg)(uGe,(0,p.A)({},lGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}mGe.isMDXComponent=!0;const yGe={toc:[]},dGe="wrapper";function hGe(e){let{components:n,...t}=e;return(0,s.yg)(dGe,(0,p.A)({},yGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}hGe.isMDXComponent=!0;const gGe={toc:[]},fGe="wrapper";function DGe(e){let{components:n,...t}=e;return(0,s.yg)(fGe,(0,p.A)({},gGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}DGe.isMDXComponent=!0;const MGe={toc:[]},XGe="wrapper";function _Ge(e){let{components:n,...t}=e;return(0,s.yg)(XGe,(0,p.A)({},MGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}_Ge.isMDXComponent=!0;const wGe={toc:[]},TGe="wrapper";function CGe(e){let{components:n,...t}=e;return(0,s.yg)(TGe,(0,p.A)({},wGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}CGe.isMDXComponent=!0;const xGe={toc:[]},AGe="wrapper";function vGe(e){let{components:n,...t}=e;return(0,s.yg)(AGe,(0,p.A)({},xGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}vGe.isMDXComponent=!0;const LGe={toc:[]},bGe="wrapper";function NGe(e){let{components:n,...t}=e;return(0,s.yg)(bGe,(0,p.A)({},LGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}NGe.isMDXComponent=!0;const kGe={toc:[]},zGe="wrapper";function PGe(e){let{components:n,...t}=e;return(0,s.yg)(zGe,(0,p.A)({},kGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}PGe.isMDXComponent=!0;const IGe={toc:[]},RGe="wrapper";function WGe(e){let{components:n,...t}=e;return(0,s.yg)(RGe,(0,p.A)({},IGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}WGe.isMDXComponent=!0;const SGe={toc:[]},BGe="wrapper";function GGe(e){let{components:n,...t}=e;return(0,s.yg)(BGe,(0,p.A)({},SGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}GGe.isMDXComponent=!0;const EGe={toc:[]},OGe="wrapper";function UGe(e){let{components:n,...t}=e;return(0,s.yg)(OGe,(0,p.A)({},EGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}UGe.isMDXComponent=!0;const FGe={toc:[]},VGe="wrapper";function qGe(e){let{components:n,...t}=e;return(0,s.yg)(VGe,(0,p.A)({},FGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qGe.isMDXComponent=!0;const jGe={toc:[]},HGe="wrapper";function YGe(e){let{components:n,...t}=e;return(0,s.yg)(HGe,(0,p.A)({},jGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}YGe.isMDXComponent=!0;const QGe={toc:[]},$Ge="wrapper";function KGe(e){let{components:n,...t}=e;return(0,s.yg)($Ge,(0,p.A)({},QGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}KGe.isMDXComponent=!0;const JGe={toc:[]},ZGe="wrapper";function eEe(e){let{components:n,...t}=e;return(0,s.yg)(ZGe,(0,p.A)({},JGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}eEe.isMDXComponent=!0;const nEe={toc:[]},tEe="wrapper";function oEe(e){let{components:n,...t}=e;return(0,s.yg)(tEe,(0,p.A)({},nEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a standalone code signal."))}oEe.isMDXComponent=!0;const pEe={toc:[]},rEe="wrapper";function sEe(e){let{components:n,...t}=e;return(0,s.yg)(rEe,(0,p.A)({},pEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial code."))}sEe.isMDXComponent=!0;const cEe={toc:[]},aEe="wrapper";function iEe(e){let{components:n,...t}=e;return(0,s.yg)(aEe,(0,p.A)({},cEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom highlighter to use."))}iEe.isMDXComponent=!0;const lEe={toc:[]},uEe="wrapper";function mEe(e){let{components:n,...t}=e;return(0,s.yg)(uEe,(0,p.A)({},lEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom dialect to use."))}mEe.isMDXComponent=!0;const yEe={toc:[]},dEe="wrapper";function hEe(e){let{components:n,...t}=e;return(0,s.yg)(dEe,(0,p.A)({},yEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}hEe.isMDXComponent=!0;const gEe={toc:[]},fEe="wrapper";function DEe(e){let{components:n,...t}=e;return(0,s.yg)(fEe,(0,p.A)({},gEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a cubic B\xe9zier curve."))}DEe.isMDXComponent=!0;const MEe={toc:[]},XEe="wrapper";function _Ee(e){let{components:n,...t}=e;return(0,s.yg)(XEe,(0,p.A)({},MEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}_Ee.isMDXComponent=!0;const wEe={toc:[]},TEe="wrapper";function CEe(e){let{components:n,...t}=e;return(0,s.yg)(TEe,(0,p.A)({},wEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}CEe.isMDXComponent=!0;const xEe={toc:[]},AEe="wrapper";function vEe(e){let{components:n,...t}=e;return(0,s.yg)(AEe,(0,p.A)({},xEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}vEe.isMDXComponent=!0;const LEe={toc:[]},bEe="wrapper";function NEe(e){let{components:n,...t}=e;return(0,s.yg)(bEe,(0,p.A)({},LEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}NEe.isMDXComponent=!0;const kEe={toc:[]},zEe="wrapper";function PEe(e){let{components:n,...t}=e;return(0,s.yg)(zEe,(0,p.A)({},kEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}PEe.isMDXComponent=!0;const IEe={toc:[]},REe="wrapper";function WEe(e){let{components:n,...t}=e;return(0,s.yg)(REe,(0,p.A)({},IEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}WEe.isMDXComponent=!0;const SEe={toc:[]},BEe="wrapper";function GEe(e){let{components:n,...t}=e;return(0,s.yg)(BEe,(0,p.A)({},SEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}GEe.isMDXComponent=!0;const EEe={toc:[]},OEe="wrapper";function UEe(e){let{components:n,...t}=e;return(0,s.yg)(OEe,(0,p.A)({},EEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}UEe.isMDXComponent=!0;const FEe={toc:[]},VEe="wrapper";function qEe(e){let{components:n,...t}=e;return(0,s.yg)(VEe,(0,p.A)({},FEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qEe.isMDXComponent=!0;const jEe={toc:[]},HEe="wrapper";function YEe(e){let{components:n,...t}=e;return(0,s.yg)(HEe,(0,p.A)({},jEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}YEe.isMDXComponent=!0;const QEe={toc:[]},$Ee="wrapper";function KEe(e){let{components:n,...t}=e;return(0,s.yg)($Ee,(0,p.A)({},QEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}KEe.isMDXComponent=!0;const JEe={toc:[]},ZEe="wrapper";function eOe(e){let{components:n,...t}=e;return(0,s.yg)(ZEe,(0,p.A)({},JEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}eOe.isMDXComponent=!0;const nOe={toc:[]},tOe="wrapper";function oOe(e){let{components:n,...t}=e;return(0,s.yg)(tOe,(0,p.A)({},nOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}oOe.isMDXComponent=!0;const pOe={toc:[]},rOe="wrapper";function sOe(e){let{components:n,...t}=e;return(0,s.yg)(rOe,(0,p.A)({},pOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}sOe.isMDXComponent=!0;const cOe={toc:[]},aOe="wrapper";function iOe(e){let{components:n,...t}=e;return(0,s.yg)(aOe,(0,p.A)({},cOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}iOe.isMDXComponent=!0;const lOe={toc:[]},uOe="wrapper";function mOe(e){let{components:n,...t}=e;return(0,s.yg)(uOe,(0,p.A)({},lOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}mOe.isMDXComponent=!0;const yOe={toc:[]},dOe="wrapper";function hOe(e){let{components:n,...t}=e;return(0,s.yg)(dOe,(0,p.A)({},yOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}hOe.isMDXComponent=!0;const gOe={toc:[]},fOe="wrapper";function DOe(e){let{components:n,...t}=e;return(0,s.yg)(fOe,(0,p.A)({},gOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}DOe.isMDXComponent=!0;const MOe={toc:[]},XOe="wrapper";function _Oe(e){let{components:n,...t}=e;return(0,s.yg)(XOe,(0,p.A)({},MOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}_Oe.isMDXComponent=!0;const wOe={toc:[]},TOe="wrapper";function COe(e){let{components:n,...t}=e;return(0,s.yg)(TOe,(0,p.A)({},wOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}COe.isMDXComponent=!0;const xOe={toc:[]},AOe="wrapper";function vOe(e){let{components:n,...t}=e;return(0,s.yg)(AOe,(0,p.A)({},xOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}vOe.isMDXComponent=!0;const LOe={toc:[]},bOe="wrapper";function NOe(e){let{components:n,...t}=e;return(0,s.yg)(bOe,(0,p.A)({},LOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}NOe.isMDXComponent=!0;const kOe={toc:[]},zOe="wrapper";function POe(e){let{components:n,...t}=e;return(0,s.yg)(zOe,(0,p.A)({},kOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}POe.isMDXComponent=!0;const IOe={toc:[]},ROe="wrapper";function WOe(e){let{components:n,...t}=e;return(0,s.yg)(ROe,(0,p.A)({},IOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}WOe.isMDXComponent=!0;const SOe={toc:[]},BOe="wrapper";function GOe(e){let{components:n,...t}=e;return(0,s.yg)(BOe,(0,p.A)({},SOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}GOe.isMDXComponent=!0;const EOe={toc:[]},OOe="wrapper";function UOe(e){let{components:n,...t}=e;return(0,s.yg)(OOe,(0,p.A)({},EOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}UOe.isMDXComponent=!0;const FOe={toc:[]},VOe="wrapper";function qOe(e){let{components:n,...t}=e;return(0,s.yg)(VOe,(0,p.A)({},FOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}qOe.isMDXComponent=!0;const jOe={toc:[]},HOe="wrapper";function YOe(e){let{components:n,...t}=e;return(0,s.yg)(HOe,(0,p.A)({},jOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}YOe.isMDXComponent=!0;const QOe={toc:[]},$Oe="wrapper";function KOe(e){let{components:n,...t}=e;return(0,s.yg)($Oe,(0,p.A)({},QOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}KOe.isMDXComponent=!0;const JOe={toc:[]},ZOe="wrapper";function eUe(e){let{components:n,...t}=e;return(0,s.yg)(ZOe,(0,p.A)({},JOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}eUe.isMDXComponent=!0;const nUe={toc:[]},tUe="wrapper";function oUe(e){let{components:n,...t}=e;return(0,s.yg)(tUe,(0,p.A)({},nUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}oUe.isMDXComponent=!0;const pUe={toc:[]},rUe="wrapper";function sUe(e){let{components:n,...t}=e;return(0,s.yg)(rUe,(0,p.A)({},pUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}sUe.isMDXComponent=!0;const cUe={toc:[]},aUe="wrapper";function iUe(e){let{components:n,...t}=e;return(0,s.yg)(aUe,(0,p.A)({},cUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start point of the B\xe9zier curve."))}iUe.isMDXComponent=!0;const lUe={toc:[]},uUe="wrapper";function mUe(e){let{components:n,...t}=e;return(0,s.yg)(uUe,(0,p.A)({},lUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The first control point of the B\xe9zier curve."))}mUe.isMDXComponent=!0;const yUe={toc:[]},dUe="wrapper";function hUe(e){let{components:n,...t}=e;return(0,s.yg)(dUe,(0,p.A)({},yUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The second control point of the B\xe9zier curve."))}hUe.isMDXComponent=!0;const gUe={toc:[]},fUe="wrapper";function DUe(e){let{components:n,...t}=e;return(0,s.yg)(fUe,(0,p.A)({},gUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end point of the B\xe9zier curve."))}DUe.isMDXComponent=!0;const MUe={toc:[]},XUe="wrapper";function _Ue(e){let{components:n,...t}=e;return(0,s.yg)(XUe,(0,p.A)({},MUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}_Ue.isMDXComponent=!0;const wUe={toc:[]},TUe="wrapper";function CUe(e){let{components:n,...t}=e;return(0,s.yg)(TUe,(0,p.A)({},wUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}CUe.isMDXComponent=!0;const xUe={toc:[]},AUe="wrapper";function vUe(e){let{components:n,...t}=e;return(0,s.yg)(AUe,(0,p.A)({},xUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}vUe.isMDXComponent=!0;const LUe={toc:[]},bUe="wrapper";function NUe(e){let{components:n,...t}=e;return(0,s.yg)(bUe,(0,p.A)({},LUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}NUe.isMDXComponent=!0;const kUe={toc:[]},zUe="wrapper";function PUe(e){let{components:n,...t}=e;return(0,s.yg)(zUe,(0,p.A)({},kUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}PUe.isMDXComponent=!0;const IUe={toc:[]},RUe="wrapper";function WUe(e){let{components:n,...t}=e;return(0,s.yg)(RUe,(0,p.A)({},IUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}WUe.isMDXComponent=!0;const SUe={toc:[]},BUe="wrapper";function GUe(e){let{components:n,...t}=e;return(0,s.yg)(BUe,(0,p.A)({},SUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}GUe.isMDXComponent=!0;const EUe={toc:[]},OUe="wrapper";function UUe(e){let{components:n,...t}=e;return(0,s.yg)(OUe,(0,p.A)({},EUe,t,{components:n,mdxType:"MDXLayout"}))}UUe.isMDXComponent=!0;const FUe={toc:[]},VUe="wrapper";function qUe(e){let{components:n,...t}=e;return(0,s.yg)(VUe,(0,p.A)({},FUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}qUe.isMDXComponent=!0;const jUe={toc:[]},HUe="wrapper";function YUe(e){let{components:n,...t}=e;return(0,s.yg)(HUe,(0,p.A)({},jUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}YUe.isMDXComponent=!0;const QUe={toc:[]},$Ue="wrapper";function KUe(e){let{components:n,...t}=e;return(0,s.yg)($Ue,(0,p.A)({},QUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}KUe.isMDXComponent=!0;const JUe={toc:[]},ZUe="wrapper";function eFe(e){let{components:n,...t}=e;return(0,s.yg)(ZUe,(0,p.A)({},JUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}eFe.isMDXComponent=!0;const nFe={toc:[]},tFe="wrapper";function oFe(e){let{components:n,...t}=e;return(0,s.yg)(tFe,(0,p.A)({},nFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}oFe.isMDXComponent=!0;const pFe={toc:[]},rFe="wrapper";function sFe(e){let{components:n,...t}=e;return(0,s.yg)(rFe,(0,p.A)({},pFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}sFe.isMDXComponent=!0;const cFe={toc:[]},aFe="wrapper";function iFe(e){let{components:n,...t}=e;return(0,s.yg)(aFe,(0,p.A)({},cFe,t,{components:n,mdxType:"MDXLayout"}))}iFe.isMDXComponent=!0;const lFe={toc:[]},uFe="wrapper";function mFe(e){let{components:n,...t}=e;return(0,s.yg)(uFe,(0,p.A)({},lFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}mFe.isMDXComponent=!0;const yFe={toc:[]},dFe="wrapper";function hFe(e){let{components:n,...t}=e;return(0,s.yg)(dFe,(0,p.A)({},yFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}hFe.isMDXComponent=!0;const gFe={toc:[]},fFe="wrapper";function DFe(e){let{components:n,...t}=e;return(0,s.yg)(fFe,(0,p.A)({},gFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}DFe.isMDXComponent=!0;const MFe={toc:[]},XFe="wrapper";function _Fe(e){let{components:n,...t}=e;return(0,s.yg)(XFe,(0,p.A)({},MFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}_Fe.isMDXComponent=!0;const wFe={toc:[]},TFe="wrapper";function CFe(e){let{components:n,...t}=e;return(0,s.yg)(TFe,(0,p.A)({},wFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}CFe.isMDXComponent=!0;const xFe={toc:[]},AFe="wrapper";function vFe(e){let{components:n,...t}=e;return(0,s.yg)(AFe,(0,p.A)({},xFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}vFe.isMDXComponent=!0;const LFe={toc:[]},bFe="wrapper";function NFe(e){let{components:n,...t}=e;return(0,s.yg)(bFe,(0,p.A)({},LFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}NFe.isMDXComponent=!0;const kFe={toc:[]},zFe="wrapper";function PFe(e){let{components:n,...t}=e;return(0,s.yg)(zFe,(0,p.A)({},kFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}PFe.isMDXComponent=!0;const IFe={toc:[]},RFe="wrapper";function WFe(e){let{components:n,...t}=e;return(0,s.yg)(RFe,(0,p.A)({},IFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}WFe.isMDXComponent=!0;const SFe={toc:[]},BFe="wrapper";function GFe(e){let{components:n,...t}=e;return(0,s.yg)(BFe,(0,p.A)({},SFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}GFe.isMDXComponent=!0;const EFe={toc:[]},OFe="wrapper";function UFe(e){let{components:n,...t}=e;return(0,s.yg)(OFe,(0,p.A)({},EFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}UFe.isMDXComponent=!0;const FFe={toc:[]},VFe="wrapper";function qFe(e){let{components:n,...t}=e;return(0,s.yg)(VFe,(0,p.A)({},FFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}qFe.isMDXComponent=!0;const jFe={toc:[]},HFe="wrapper";function YFe(e){let{components:n,...t}=e;return(0,s.yg)(HFe,(0,p.A)({},jFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}YFe.isMDXComponent=!0;const QFe={toc:[]},$Fe="wrapper";function KFe(e){let{components:n,...t}=e;return(0,s.yg)($Fe,(0,p.A)({},QFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KFe.isMDXComponent=!0;const JFe={toc:[]},ZFe="wrapper";function eVe(e){let{components:n,...t}=e;return(0,s.yg)(ZFe,(0,p.A)({},JFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}eVe.isMDXComponent=!0;const nVe={toc:[]},tVe="wrapper";function oVe(e){let{components:n,...t}=e;return(0,s.yg)(tVe,(0,p.A)({},nVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}oVe.isMDXComponent=!0;const pVe={toc:[]},rVe="wrapper";function sVe(e){let{components:n,...t}=e;return(0,s.yg)(rVe,(0,p.A)({},pVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}sVe.isMDXComponent=!0;const cVe={toc:[]},aVe="wrapper";function iVe(e){let{components:n,...t}=e;return(0,s.yg)(aVe,(0,p.A)({},cVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}iVe.isMDXComponent=!0;const lVe={toc:[]},uVe="wrapper";function mVe(e){let{components:n,...t}=e;return(0,s.yg)(uVe,(0,p.A)({},lVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}mVe.isMDXComponent=!0;const yVe={toc:[]},dVe="wrapper";function hVe(e){let{components:n,...t}=e;return(0,s.yg)(dVe,(0,p.A)({},yVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}hVe.isMDXComponent=!0;const gVe={toc:[]},fVe="wrapper";function DVe(e){let{components:n,...t}=e;return(0,s.yg)(fVe,(0,p.A)({},gVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}DVe.isMDXComponent=!0;const MVe={toc:[]},XVe="wrapper";function _Ve(e){let{components:n,...t}=e;return(0,s.yg)(XVe,(0,p.A)({},MVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}_Ve.isMDXComponent=!0;const wVe={toc:[]},TVe="wrapper";function CVe(e){let{components:n,...t}=e;return(0,s.yg)(TVe,(0,p.A)({},wVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}CVe.isMDXComponent=!0;const xVe={toc:[]},AVe="wrapper";function vVe(e){let{components:n,...t}=e;return(0,s.yg)(AVe,(0,p.A)({},xVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}vVe.isMDXComponent=!0;const LVe={toc:[]},bVe="wrapper";function NVe(e){let{components:n,...t}=e;return(0,s.yg)(bVe,(0,p.A)({},LVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}NVe.isMDXComponent=!0;const kVe={toc:[]},zVe="wrapper";function PVe(e){let{components:n,...t}=e;return(0,s.yg)(zVe,(0,p.A)({},kVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}PVe.isMDXComponent=!0;const IVe={toc:[]},RVe="wrapper";function WVe(e){let{components:n,...t}=e;return(0,s.yg)(RVe,(0,p.A)({},IVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}WVe.isMDXComponent=!0;const SVe={toc:[]},BVe="wrapper";function GVe(e){let{components:n,...t}=e;return(0,s.yg)(BVe,(0,p.A)({},SVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}GVe.isMDXComponent=!0;const EVe={toc:[]},OVe="wrapper";function UVe(e){let{components:n,...t}=e;return(0,s.yg)(OVe,(0,p.A)({},EVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}UVe.isMDXComponent=!0;const FVe={toc:[]},VVe="wrapper";function qVe(e){let{components:n,...t}=e;return(0,s.yg)(VVe,(0,p.A)({},FVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}qVe.isMDXComponent=!0;const jVe={toc:[]},HVe="wrapper";function YVe(e){let{components:n,...t}=e;return(0,s.yg)(HVe,(0,p.A)({},jVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}YVe.isMDXComponent=!0;const QVe={toc:[]},$Ve="wrapper";function KVe(e){let{components:n,...t}=e;return(0,s.yg)($Ve,(0,p.A)({},QVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}KVe.isMDXComponent=!0;const JVe={toc:[]},ZVe="wrapper";function eqe(e){let{components:n,...t}=e;return(0,s.yg)(ZVe,(0,p.A)({},JVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}eqe.isMDXComponent=!0;const nqe={toc:[]},tqe="wrapper";function oqe(e){let{components:n,...t}=e;return(0,s.yg)(tqe,(0,p.A)({},nqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}oqe.isMDXComponent=!0;const pqe={toc:[]},rqe="wrapper";function sqe(e){let{components:n,...t}=e;return(0,s.yg)(rqe,(0,p.A)({},pqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}sqe.isMDXComponent=!0;const cqe={toc:[]},aqe="wrapper";function iqe(e){let{components:n,...t}=e;return(0,s.yg)(aqe,(0,p.A)({},cqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}iqe.isMDXComponent=!0;const lqe={toc:[]},uqe="wrapper";function mqe(e){let{components:n,...t}=e;return(0,s.yg)(uqe,(0,p.A)({},lqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}mqe.isMDXComponent=!0;const yqe={toc:[]},dqe="wrapper";function hqe(e){let{components:n,...t}=e;return(0,s.yg)(dqe,(0,p.A)({},yqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}hqe.isMDXComponent=!0;const gqe={toc:[]},fqe="wrapper";function Dqe(e){let{components:n,...t}=e;return(0,s.yg)(fqe,(0,p.A)({},gqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Dqe.isMDXComponent=!0;const Mqe={toc:[]},Xqe="wrapper";function _qe(e){let{components:n,...t}=e;return(0,s.yg)(Xqe,(0,p.A)({},Mqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}_qe.isMDXComponent=!0;const wqe={toc:[]},Tqe="wrapper";function Cqe(e){let{components:n,...t}=e;return(0,s.yg)(Tqe,(0,p.A)({},wqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Cqe.isMDXComponent=!0;const xqe={toc:[]},Aqe="wrapper";function vqe(e){let{components:n,...t}=e;return(0,s.yg)(Aqe,(0,p.A)({},xqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}vqe.isMDXComponent=!0;const Lqe={toc:[]},bqe="wrapper";function Nqe(e){let{components:n,...t}=e;return(0,s.yg)(bqe,(0,p.A)({},Lqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Nqe.isMDXComponent=!0;const kqe={toc:[]},zqe="wrapper";function Pqe(e){let{components:n,...t}=e;return(0,s.yg)(zqe,(0,p.A)({},kqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Pqe.isMDXComponent=!0;const Iqe={toc:[]},Rqe="wrapper";function Wqe(e){let{components:n,...t}=e;return(0,s.yg)(Rqe,(0,p.A)({},Iqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Wqe.isMDXComponent=!0;const Sqe={toc:[]},Bqe="wrapper";function Gqe(e){let{components:n,...t}=e;return(0,s.yg)(Bqe,(0,p.A)({},Sqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Gqe.isMDXComponent=!0;const Eqe={toc:[]},Oqe="wrapper";function Uqe(e){let{components:n,...t}=e;return(0,s.yg)(Oqe,(0,p.A)({},Eqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Uqe.isMDXComponent=!0;const Fqe={toc:[]},Vqe="wrapper";function qqe(e){let{components:n,...t}=e;return(0,s.yg)(Vqe,(0,p.A)({},Fqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}qqe.isMDXComponent=!0;const jqe={toc:[]},Hqe="wrapper";function Yqe(e){let{components:n,...t}=e;return(0,s.yg)(Hqe,(0,p.A)({},jqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Yqe.isMDXComponent=!0;const Qqe={toc:[]},$qe="wrapper";function Kqe(e){let{components:n,...t}=e;return(0,s.yg)($qe,(0,p.A)({},Qqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Kqe.isMDXComponent=!0;const Jqe={toc:[]},Zqe="wrapper";function eje(e){let{components:n,...t}=e;return(0,s.yg)(Zqe,(0,p.A)({},Jqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}eje.isMDXComponent=!0;const nje={toc:[]},tje="wrapper";function oje(e){let{components:n,...t}=e;return(0,s.yg)(tje,(0,p.A)({},nje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}oje.isMDXComponent=!0;const pje={toc:[]},rje="wrapper";function sje(e){let{components:n,...t}=e;return(0,s.yg)(rje,(0,p.A)({},pje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}sje.isMDXComponent=!0;const cje={toc:[]},aje="wrapper";function ije(e){let{components:n,...t}=e;return(0,s.yg)(aje,(0,p.A)({},cje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ije.isMDXComponent=!0;const lje={toc:[]},uje="wrapper";function mje(e){let{components:n,...t}=e;return(0,s.yg)(uje,(0,p.A)({},lje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}mje.isMDXComponent=!0;const yje={toc:[]},dje="wrapper";function hje(e){let{components:n,...t}=e;return(0,s.yg)(dje,(0,p.A)({},yje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hje.isMDXComponent=!0;const gje={toc:[]},fje="wrapper";function Dje(e){let{components:n,...t}=e;return(0,s.yg)(fje,(0,p.A)({},gje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Dje.isMDXComponent=!0;const Mje={toc:[]},Xje="wrapper";function _je(e){let{components:n,...t}=e;return(0,s.yg)(Xje,(0,p.A)({},Mje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_je.isMDXComponent=!0;const wje={toc:[]},Tje="wrapper";function Cje(e){let{components:n,...t}=e;return(0,s.yg)(Tje,(0,p.A)({},wje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Cje.isMDXComponent=!0;const xje={toc:[]},Aje="wrapper";function vje(e){let{components:n,...t}=e;return(0,s.yg)(Aje,(0,p.A)({},xje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vje.isMDXComponent=!0;const Lje={toc:[]},bje="wrapper";function Nje(e){let{components:n,...t}=e;return(0,s.yg)(bje,(0,p.A)({},Lje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Nje.isMDXComponent=!0;const kje={toc:[]},zje="wrapper";function Pje(e){let{components:n,...t}=e;return(0,s.yg)(zje,(0,p.A)({},kje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Pje.isMDXComponent=!0;const Ije={toc:[]},Rje="wrapper";function Wje(e){let{components:n,...t}=e;return(0,s.yg)(Rje,(0,p.A)({},Ije,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Wje.isMDXComponent=!0;const Sje={toc:[]},Bje="wrapper";function Gje(e){let{components:n,...t}=e;return(0,s.yg)(Bje,(0,p.A)({},Sje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Gje.isMDXComponent=!0;const Eje={toc:[]},Oje="wrapper";function Uje(e){let{components:n,...t}=e;return(0,s.yg)(Oje,(0,p.A)({},Eje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Uje.isMDXComponent=!0;const Fje={toc:[]},Vje="wrapper";function qje(e){let{components:n,...t}=e;return(0,s.yg)(Vje,(0,p.A)({},Fje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qje.isMDXComponent=!0;const jje={toc:[]},Hje="wrapper";function Yje(e){let{components:n,...t}=e;return(0,s.yg)(Hje,(0,p.A)({},jje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Yje.isMDXComponent=!0;const Qje={toc:[]},$je="wrapper";function Kje(e){let{components:n,...t}=e;return(0,s.yg)($je,(0,p.A)({},Qje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Kje.isMDXComponent=!0;const Jje={toc:[]},Zje="wrapper";function eHe(e){let{components:n,...t}=e;return(0,s.yg)(Zje,(0,p.A)({},Jje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}eHe.isMDXComponent=!0;const nHe={toc:[]},tHe="wrapper";function oHe(e){let{components:n,...t}=e;return(0,s.yg)(tHe,(0,p.A)({},nHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}oHe.isMDXComponent=!0;const pHe={toc:[]},rHe="wrapper";function sHe(e){let{components:n,...t}=e;return(0,s.yg)(rHe,(0,p.A)({},pHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}sHe.isMDXComponent=!0;const cHe={toc:[]},aHe="wrapper";function iHe(e){let{components:n,...t}=e;return(0,s.yg)(aHe,(0,p.A)({},cHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}iHe.isMDXComponent=!0;const lHe={toc:[]},uHe="wrapper";function mHe(e){let{components:n,...t}=e;return(0,s.yg)(uHe,(0,p.A)({},lHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}mHe.isMDXComponent=!0;const yHe={toc:[]},dHe="wrapper";function hHe(e){let{components:n,...t}=e;return(0,s.yg)(dHe,(0,p.A)({},yHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}hHe.isMDXComponent=!0;const gHe={toc:[]},fHe="wrapper";function DHe(e){let{components:n,...t}=e;return(0,s.yg)(fHe,(0,p.A)({},gHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}DHe.isMDXComponent=!0;const MHe={toc:[]},XHe="wrapper";function _He(e){let{components:n,...t}=e;return(0,s.yg)(XHe,(0,p.A)({},MHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}_He.isMDXComponent=!0;const wHe={toc:[]},THe="wrapper";function CHe(e){let{components:n,...t}=e;return(0,s.yg)(THe,(0,p.A)({},wHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}CHe.isMDXComponent=!0;const xHe={toc:[]},AHe="wrapper";function vHe(e){let{components:n,...t}=e;return(0,s.yg)(AHe,(0,p.A)({},xHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}vHe.isMDXComponent=!0;const LHe={toc:[]},bHe="wrapper";function NHe(e){let{components:n,...t}=e;return(0,s.yg)(bHe,(0,p.A)({},LHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}NHe.isMDXComponent=!0;const kHe={toc:[]},zHe="wrapper";function PHe(e){let{components:n,...t}=e;return(0,s.yg)(zHe,(0,p.A)({},kHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}PHe.isMDXComponent=!0;const IHe={toc:[]},RHe="wrapper";function WHe(e){let{components:n,...t}=e;return(0,s.yg)(RHe,(0,p.A)({},IHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}WHe.isMDXComponent=!0;const SHe={toc:[]},BHe="wrapper";function GHe(e){let{components:n,...t}=e;return(0,s.yg)(BHe,(0,p.A)({},SHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}GHe.isMDXComponent=!0;const EHe={toc:[]},OHe="wrapper";function UHe(e){let{components:n,...t}=e;return(0,s.yg)(OHe,(0,p.A)({},EHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}UHe.isMDXComponent=!0;const FHe={toc:[]},VHe="wrapper";function qHe(e){let{components:n,...t}=e;return(0,s.yg)(VHe,(0,p.A)({},FHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}qHe.isMDXComponent=!0;const jHe={toc:[]},HHe="wrapper";function YHe(e){let{components:n,...t}=e;return(0,s.yg)(HHe,(0,p.A)({},jHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}YHe.isMDXComponent=!0;const QHe={toc:[]},$He="wrapper";function KHe(e){let{components:n,...t}=e;return(0,s.yg)($He,(0,p.A)({},QHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}KHe.isMDXComponent=!0;const JHe={toc:[]},ZHe="wrapper";function eYe(e){let{components:n,...t}=e;return(0,s.yg)(ZHe,(0,p.A)({},JHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}eYe.isMDXComponent=!0;const nYe={toc:[]},tYe="wrapper";function oYe(e){let{components:n,...t}=e;return(0,s.yg)(tYe,(0,p.A)({},nYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}oYe.isMDXComponent=!0;const pYe={toc:[]},rYe="wrapper";function sYe(e){let{components:n,...t}=e;return(0,s.yg)(rYe,(0,p.A)({},pYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}sYe.isMDXComponent=!0;const cYe={toc:[]},aYe="wrapper";function iYe(e){let{components:n,...t}=e;return(0,s.yg)(aYe,(0,p.A)({},cYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iYe.isMDXComponent=!0;const lYe={toc:[]},uYe="wrapper";function mYe(e){let{components:n,...t}=e;return(0,s.yg)(uYe,(0,p.A)({},lYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}mYe.isMDXComponent=!0;const yYe={toc:[]},dYe="wrapper";function hYe(e){let{components:n,...t}=e;return(0,s.yg)(dYe,(0,p.A)({},yYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}hYe.isMDXComponent=!0;const gYe={toc:[]},fYe="wrapper";function DYe(e){let{components:n,...t}=e;return(0,s.yg)(fYe,(0,p.A)({},gYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}DYe.isMDXComponent=!0;const MYe={toc:[]},XYe="wrapper";function _Ye(e){let{components:n,...t}=e;return(0,s.yg)(XYe,(0,p.A)({},MYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}_Ye.isMDXComponent=!0;const wYe={toc:[]},TYe="wrapper";function CYe(e){let{components:n,...t}=e;return(0,s.yg)(TYe,(0,p.A)({},wYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}CYe.isMDXComponent=!0;const xYe={toc:[]},AYe="wrapper";function vYe(e){let{components:n,...t}=e;return(0,s.yg)(AYe,(0,p.A)({},xYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vYe.isMDXComponent=!0;const LYe={toc:[]},bYe="wrapper";function NYe(e){let{components:n,...t}=e;return(0,s.yg)(bYe,(0,p.A)({},LYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}NYe.isMDXComponent=!0;const kYe={toc:[]},zYe="wrapper";function PYe(e){let{components:n,...t}=e;return(0,s.yg)(zYe,(0,p.A)({},kYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}PYe.isMDXComponent=!0;const IYe={toc:[]},RYe="wrapper";function WYe(e){let{components:n,...t}=e;return(0,s.yg)(RYe,(0,p.A)({},IYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}WYe.isMDXComponent=!0;const SYe={toc:[]},BYe="wrapper";function GYe(e){let{components:n,...t}=e;return(0,s.yg)(BYe,(0,p.A)({},SYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}GYe.isMDXComponent=!0;const EYe={toc:[]},OYe="wrapper";function UYe(e){let{components:n,...t}=e;return(0,s.yg)(OYe,(0,p.A)({},EYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}UYe.isMDXComponent=!0;const FYe={toc:[]},VYe="wrapper";function qYe(e){let{components:n,...t}=e;return(0,s.yg)(VYe,(0,p.A)({},FYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}qYe.isMDXComponent=!0;const jYe={toc:[]},HYe="wrapper";function YYe(e){let{components:n,...t}=e;return(0,s.yg)(HYe,(0,p.A)({},jYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}YYe.isMDXComponent=!0;const QYe={toc:[]},$Ye="wrapper";function KYe(e){let{components:n,...t}=e;return(0,s.yg)($Ye,(0,p.A)({},QYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}KYe.isMDXComponent=!0;const JYe={toc:[]},ZYe="wrapper";function eQe(e){let{components:n,...t}=e;return(0,s.yg)(ZYe,(0,p.A)({},JYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}eQe.isMDXComponent=!0;const nQe={toc:[]},tQe="wrapper";function oQe(e){let{components:n,...t}=e;return(0,s.yg)(tQe,(0,p.A)({},nQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}oQe.isMDXComponent=!0;const pQe={toc:[]},rQe="wrapper";function sQe(e){let{components:n,...t}=e;return(0,s.yg)(rQe,(0,p.A)({},pQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}sQe.isMDXComponent=!0;const cQe={toc:[]},aQe="wrapper";function iQe(e){let{components:n,...t}=e;return(0,s.yg)(aQe,(0,p.A)({},cQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}iQe.isMDXComponent=!0;const lQe={toc:[]},uQe="wrapper";function mQe(e){let{components:n,...t}=e;return(0,s.yg)(uQe,(0,p.A)({},lQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}mQe.isMDXComponent=!0;const yQe={toc:[]},dQe="wrapper";function hQe(e){let{components:n,...t}=e;return(0,s.yg)(dQe,(0,p.A)({},yQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}hQe.isMDXComponent=!0;const gQe={toc:[]},fQe="wrapper";function DQe(e){let{components:n,...t}=e;return(0,s.yg)(fQe,(0,p.A)({},gQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}DQe.isMDXComponent=!0;const MQe={toc:[]},XQe="wrapper";function _Qe(e){let{components:n,...t}=e;return(0,s.yg)(XQe,(0,p.A)({},MQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}_Qe.isMDXComponent=!0;const wQe={toc:[]},TQe="wrapper";function CQe(e){let{components:n,...t}=e;return(0,s.yg)(TQe,(0,p.A)({},wQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}CQe.isMDXComponent=!0;const xQe={toc:[]},AQe="wrapper";function vQe(e){let{components:n,...t}=e;return(0,s.yg)(AQe,(0,p.A)({},xQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}vQe.isMDXComponent=!0;const LQe={toc:[]},bQe="wrapper";function NQe(e){let{components:n,...t}=e;return(0,s.yg)(bQe,(0,p.A)({},LQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}NQe.isMDXComponent=!0;const kQe={toc:[]},zQe="wrapper";function PQe(e){let{components:n,...t}=e;return(0,s.yg)(zQe,(0,p.A)({},kQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}PQe.isMDXComponent=!0;const IQe={toc:[]},RQe="wrapper";function WQe(e){let{components:n,...t}=e;return(0,s.yg)(RQe,(0,p.A)({},IQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}WQe.isMDXComponent=!0;const SQe={toc:[]},BQe="wrapper";function GQe(e){let{components:n,...t}=e;return(0,s.yg)(BQe,(0,p.A)({},SQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}GQe.isMDXComponent=!0;const EQe={toc:[]},OQe="wrapper";function UQe(e){let{components:n,...t}=e;return(0,s.yg)(OQe,(0,p.A)({},EQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}UQe.isMDXComponent=!0;const FQe={toc:[]},VQe="wrapper";function qQe(e){let{components:n,...t}=e;return(0,s.yg)(VQe,(0,p.A)({},FQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}qQe.isMDXComponent=!0;const jQe={toc:[]},HQe="wrapper";function YQe(e){let{components:n,...t}=e;return(0,s.yg)(HQe,(0,p.A)({},jQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}YQe.isMDXComponent=!0;const QQe={toc:[]},$Qe="wrapper";function KQe(e){let{components:n,...t}=e;return(0,s.yg)($Qe,(0,p.A)({},QQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}KQe.isMDXComponent=!0;const JQe={toc:[]},ZQe="wrapper";function e$e(e){let{components:n,...t}=e;return(0,s.yg)(ZQe,(0,p.A)({},JQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}e$e.isMDXComponent=!0;const n$e={toc:[]},t$e="wrapper";function o$e(e){let{components:n,...t}=e;return(0,s.yg)(t$e,(0,p.A)({},n$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}o$e.isMDXComponent=!0;const p$e={toc:[]},r$e="wrapper";function s$e(e){let{components:n,...t}=e;return(0,s.yg)(r$e,(0,p.A)({},p$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}s$e.isMDXComponent=!0;const c$e={toc:[]},a$e="wrapper";function i$e(e){let{components:n,...t}=e;return(0,s.yg)(a$e,(0,p.A)({},c$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}i$e.isMDXComponent=!0;const l$e={toc:[]},u$e="wrapper";function m$e(e){let{components:n,...t}=e;return(0,s.yg)(u$e,(0,p.A)({},l$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}m$e.isMDXComponent=!0;const y$e={toc:[]},d$e="wrapper";function h$e(e){let{components:n,...t}=e;return(0,s.yg)(d$e,(0,p.A)({},y$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}h$e.isMDXComponent=!0;const g$e={toc:[]},f$e="wrapper";function D$e(e){let{components:n,...t}=e;return(0,s.yg)(f$e,(0,p.A)({},g$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}D$e.isMDXComponent=!0;const M$e={toc:[]},X$e="wrapper";function _$e(e){let{components:n,...t}=e;return(0,s.yg)(X$e,(0,p.A)({},M$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}_$e.isMDXComponent=!0;const w$e={toc:[]},T$e="wrapper";function C$e(e){let{components:n,...t}=e;return(0,s.yg)(T$e,(0,p.A)({},w$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}C$e.isMDXComponent=!0;const x$e={toc:[]},A$e="wrapper";function v$e(e){let{components:n,...t}=e;return(0,s.yg)(A$e,(0,p.A)({},x$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}v$e.isMDXComponent=!0;const L$e={toc:[]},b$e="wrapper";function N$e(e){let{components:n,...t}=e;return(0,s.yg)(b$e,(0,p.A)({},L$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}N$e.isMDXComponent=!0;const k$e={toc:[]},z$e="wrapper";function P$e(e){let{components:n,...t}=e;return(0,s.yg)(z$e,(0,p.A)({},k$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}P$e.isMDXComponent=!0;const I$e={toc:[]},R$e="wrapper";function W$e(e){let{components:n,...t}=e;return(0,s.yg)(R$e,(0,p.A)({},I$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}W$e.isMDXComponent=!0;const S$e={toc:[]},B$e="wrapper";function G$e(e){let{components:n,...t}=e;return(0,s.yg)(B$e,(0,p.A)({},S$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}G$e.isMDXComponent=!0;const E$e={toc:[]},O$e="wrapper";function U$e(e){let{components:n,...t}=e;return(0,s.yg)(O$e,(0,p.A)({},E$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}U$e.isMDXComponent=!0;const F$e={toc:[]},V$e="wrapper";function q$e(e){let{components:n,...t}=e;return(0,s.yg)(V$e,(0,p.A)({},F$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}q$e.isMDXComponent=!0;const j$e={toc:[]},H$e="wrapper";function Y$e(e){let{components:n,...t}=e;return(0,s.yg)(H$e,(0,p.A)({},j$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Y$e.isMDXComponent=!0;const Q$e={toc:[]},$$e="wrapper";function K$e(e){let{components:n,...t}=e;return(0,s.yg)($$e,(0,p.A)({},Q$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}K$e.isMDXComponent=!0;const J$e={toc:[]},Z$e="wrapper";function eKe(e){let{components:n,...t}=e;return(0,s.yg)(Z$e,(0,p.A)({},J$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}eKe.isMDXComponent=!0;const nKe={toc:[]},tKe="wrapper";function oKe(e){let{components:n,...t}=e;return(0,s.yg)(tKe,(0,p.A)({},nKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}oKe.isMDXComponent=!0;const pKe={toc:[]},rKe="wrapper";function sKe(e){let{components:n,...t}=e;return(0,s.yg)(rKe,(0,p.A)({},pKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sKe.isMDXComponent=!0;const cKe={toc:[]},aKe="wrapper";function iKe(e){let{components:n,...t}=e;return(0,s.yg)(aKe,(0,p.A)({},cKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}iKe.isMDXComponent=!0;const lKe={toc:[]},uKe="wrapper";function mKe(e){let{components:n,...t}=e;return(0,s.yg)(uKe,(0,p.A)({},lKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}mKe.isMDXComponent=!0;const yKe={toc:[]},dKe="wrapper";function hKe(e){let{components:n,...t}=e;return(0,s.yg)(dKe,(0,p.A)({},yKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}hKe.isMDXComponent=!0;const gKe={toc:[]},fKe="wrapper";function DKe(e){let{components:n,...t}=e;return(0,s.yg)(fKe,(0,p.A)({},gKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}DKe.isMDXComponent=!0;const MKe={toc:[]},XKe="wrapper";function _Ke(e){let{components:n,...t}=e;return(0,s.yg)(XKe,(0,p.A)({},MKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}_Ke.isMDXComponent=!0;const wKe={toc:[]},TKe="wrapper";function CKe(e){let{components:n,...t}=e;return(0,s.yg)(TKe,(0,p.A)({},wKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}CKe.isMDXComponent=!0;const xKe={toc:[]},AKe="wrapper";function vKe(e){let{components:n,...t}=e;return(0,s.yg)(AKe,(0,p.A)({},xKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}vKe.isMDXComponent=!0;const LKe={toc:[]},bKe="wrapper";function NKe(e){let{components:n,...t}=e;return(0,s.yg)(bKe,(0,p.A)({},LKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}NKe.isMDXComponent=!0;const kKe={toc:[]},zKe="wrapper";function PKe(e){let{components:n,...t}=e;return(0,s.yg)(zKe,(0,p.A)({},kKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}PKe.isMDXComponent=!0;const IKe={toc:[]},RKe="wrapper";function WKe(e){let{components:n,...t}=e;return(0,s.yg)(RKe,(0,p.A)({},IKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}WKe.isMDXComponent=!0;const SKe={toc:[]},BKe="wrapper";function GKe(e){let{components:n,...t}=e;return(0,s.yg)(BKe,(0,p.A)({},SKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}GKe.isMDXComponent=!0;const EKe={toc:[]},OKe="wrapper";function UKe(e){let{components:n,...t}=e;return(0,s.yg)(OKe,(0,p.A)({},EKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}UKe.isMDXComponent=!0;const FKe={toc:[]},VKe="wrapper";function qKe(e){let{components:n,...t}=e;return(0,s.yg)(VKe,(0,p.A)({},FKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}qKe.isMDXComponent=!0;const jKe={toc:[]},HKe="wrapper";function YKe(e){let{components:n,...t}=e;return(0,s.yg)(HKe,(0,p.A)({},jKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}YKe.isMDXComponent=!0;const QKe={toc:[]},$Ke="wrapper";function KKe(e){let{components:n,...t}=e;return(0,s.yg)($Ke,(0,p.A)({},QKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}KKe.isMDXComponent=!0;const JKe={toc:[]},ZKe="wrapper";function eJe(e){let{components:n,...t}=e;return(0,s.yg)(ZKe,(0,p.A)({},JKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}eJe.isMDXComponent=!0;const nJe={toc:[]},tJe="wrapper";function oJe(e){let{components:n,...t}=e;return(0,s.yg)(tJe,(0,p.A)({},nJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}oJe.isMDXComponent=!0;const pJe={toc:[]},rJe="wrapper";function sJe(e){let{components:n,...t}=e;return(0,s.yg)(rJe,(0,p.A)({},pJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}sJe.isMDXComponent=!0;const cJe={toc:[]},aJe="wrapper";function iJe(e){let{components:n,...t}=e;return(0,s.yg)(aJe,(0,p.A)({},cJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}iJe.isMDXComponent=!0;const lJe={toc:[]},uJe="wrapper";function mJe(e){let{components:n,...t}=e;return(0,s.yg)(uJe,(0,p.A)({},lJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}mJe.isMDXComponent=!0;const yJe={toc:[]},dJe="wrapper";function hJe(e){let{components:n,...t}=e;return(0,s.yg)(dJe,(0,p.A)({},yJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}hJe.isMDXComponent=!0;const gJe={toc:[]},fJe="wrapper";function DJe(e){let{components:n,...t}=e;return(0,s.yg)(fJe,(0,p.A)({},gJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}DJe.isMDXComponent=!0;const MJe={toc:[]},XJe="wrapper";function _Je(e){let{components:n,...t}=e;return(0,s.yg)(XJe,(0,p.A)({},MJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}_Je.isMDXComponent=!0;const wJe={toc:[]},TJe="wrapper";function CJe(e){let{components:n,...t}=e;return(0,s.yg)(TJe,(0,p.A)({},wJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}CJe.isMDXComponent=!0;const xJe={toc:[]},AJe="wrapper";function vJe(e){let{components:n,...t}=e;return(0,s.yg)(AJe,(0,p.A)({},xJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}vJe.isMDXComponent=!0;const LJe={toc:[]},bJe="wrapper";function NJe(e){let{components:n,...t}=e;return(0,s.yg)(bJe,(0,p.A)({},LJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}NJe.isMDXComponent=!0;const kJe={toc:[]},zJe="wrapper";function PJe(e){let{components:n,...t}=e;return(0,s.yg)(zJe,(0,p.A)({},kJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}PJe.isMDXComponent=!0;const IJe={toc:[]},RJe="wrapper";function WJe(e){let{components:n,...t}=e;return(0,s.yg)(RJe,(0,p.A)({},IJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WJe.isMDXComponent=!0;const SJe={toc:[]},BJe="wrapper";function GJe(e){let{components:n,...t}=e;return(0,s.yg)(BJe,(0,p.A)({},SJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}GJe.isMDXComponent=!0;const EJe={toc:[]},OJe="wrapper";function UJe(e){let{components:n,...t}=e;return(0,s.yg)(OJe,(0,p.A)({},EJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}UJe.isMDXComponent=!0;const FJe={toc:[]},VJe="wrapper";function qJe(e){let{components:n,...t}=e;return(0,s.yg)(VJe,(0,p.A)({},FJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}qJe.isMDXComponent=!0;const jJe={toc:[]},HJe="wrapper";function YJe(e){let{components:n,...t}=e;return(0,s.yg)(HJe,(0,p.A)({},jJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}YJe.isMDXComponent=!0;const QJe={toc:[]},$Je="wrapper";function KJe(e){let{components:n,...t}=e;return(0,s.yg)($Je,(0,p.A)({},QJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}KJe.isMDXComponent=!0;const JJe={toc:[]},ZJe="wrapper";function eZe(e){let{components:n,...t}=e;return(0,s.yg)(ZJe,(0,p.A)({},JJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}eZe.isMDXComponent=!0;const nZe={toc:[]},tZe="wrapper";function oZe(e){let{components:n,...t}=e;return(0,s.yg)(tZe,(0,p.A)({},nZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}oZe.isMDXComponent=!0;const pZe={toc:[]},rZe="wrapper";function sZe(e){let{components:n,...t}=e;return(0,s.yg)(rZe,(0,p.A)({},pZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}sZe.isMDXComponent=!0;const cZe={toc:[]},aZe="wrapper";function iZe(e){let{components:n,...t}=e;return(0,s.yg)(aZe,(0,p.A)({},cZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}iZe.isMDXComponent=!0;const lZe={toc:[]},uZe="wrapper";function mZe(e){let{components:n,...t}=e;return(0,s.yg)(uZe,(0,p.A)({},lZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}mZe.isMDXComponent=!0;const yZe={toc:[]},dZe="wrapper";function hZe(e){let{components:n,...t}=e;return(0,s.yg)(dZe,(0,p.A)({},yZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}hZe.isMDXComponent=!0;const gZe={toc:[]},fZe="wrapper";function DZe(e){let{components:n,...t}=e;return(0,s.yg)(fZe,(0,p.A)({},gZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}DZe.isMDXComponent=!0;const MZe={toc:[]},XZe="wrapper";function _Ze(e){let{components:n,...t}=e;return(0,s.yg)(XZe,(0,p.A)({},MZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}_Ze.isMDXComponent=!0;const wZe={toc:[]},TZe="wrapper";function CZe(e){let{components:n,...t}=e;return(0,s.yg)(TZe,(0,p.A)({},wZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}CZe.isMDXComponent=!0;const xZe={toc:[]},AZe="wrapper";function vZe(e){let{components:n,...t}=e;return(0,s.yg)(AZe,(0,p.A)({},xZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}vZe.isMDXComponent=!0;const LZe={toc:[]},bZe="wrapper";function NZe(e){let{components:n,...t}=e;return(0,s.yg)(bZe,(0,p.A)({},LZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}NZe.isMDXComponent=!0;const kZe={toc:[]},zZe="wrapper";function PZe(e){let{components:n,...t}=e;return(0,s.yg)(zZe,(0,p.A)({},kZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}PZe.isMDXComponent=!0;const IZe={toc:[]},RZe="wrapper";function WZe(e){let{components:n,...t}=e;return(0,s.yg)(RZe,(0,p.A)({},IZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}WZe.isMDXComponent=!0;const SZe={toc:[]},BZe="wrapper";function GZe(e){let{components:n,...t}=e;return(0,s.yg)(BZe,(0,p.A)({},SZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}GZe.isMDXComponent=!0;const EZe={toc:[]},OZe="wrapper";function UZe(e){let{components:n,...t}=e;return(0,s.yg)(OZe,(0,p.A)({},EZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}UZe.isMDXComponent=!0;const FZe={toc:[]},VZe="wrapper";function qZe(e){let{components:n,...t}=e;return(0,s.yg)(VZe,(0,p.A)({},FZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}qZe.isMDXComponent=!0;const jZe={toc:[]},HZe="wrapper";function YZe(e){let{components:n,...t}=e;return(0,s.yg)(HZe,(0,p.A)({},jZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}YZe.isMDXComponent=!0;const QZe={toc:[]},$Ze="wrapper";function KZe(e){let{components:n,...t}=e;return(0,s.yg)($Ze,(0,p.A)({},QZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}KZe.isMDXComponent=!0;const JZe={toc:[]},ZZe="wrapper";function e0e(e){let{components:n,...t}=e;return(0,s.yg)(ZZe,(0,p.A)({},JZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}e0e.isMDXComponent=!0;const n0e={toc:[]},t0e="wrapper";function o0e(e){let{components:n,...t}=e;return(0,s.yg)(t0e,(0,p.A)({},n0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}o0e.isMDXComponent=!0;const p0e={toc:[]},r0e="wrapper";function s0e(e){let{components:n,...t}=e;return(0,s.yg)(r0e,(0,p.A)({},p0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}s0e.isMDXComponent=!0;const c0e={toc:[]},a0e="wrapper";function i0e(e){let{components:n,...t}=e;return(0,s.yg)(a0e,(0,p.A)({},c0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}i0e.isMDXComponent=!0;const l0e={toc:[]},u0e="wrapper";function m0e(e){let{components:n,...t}=e;return(0,s.yg)(u0e,(0,p.A)({},l0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}m0e.isMDXComponent=!0;const y0e={toc:[]},d0e="wrapper";function h0e(e){let{components:n,...t}=e;return(0,s.yg)(d0e,(0,p.A)({},y0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}h0e.isMDXComponent=!0;const g0e={toc:[]},f0e="wrapper";function D0e(e){let{components:n,...t}=e;return(0,s.yg)(f0e,(0,p.A)({},g0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}D0e.isMDXComponent=!0;const M0e={toc:[]},X0e="wrapper";function _0e(e){let{components:n,...t}=e;return(0,s.yg)(X0e,(0,p.A)({},M0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}_0e.isMDXComponent=!0;const w0e={toc:[]},T0e="wrapper";function C0e(e){let{components:n,...t}=e;return(0,s.yg)(T0e,(0,p.A)({},w0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}C0e.isMDXComponent=!0;const x0e={toc:[]},A0e="wrapper";function v0e(e){let{components:n,...t}=e;return(0,s.yg)(A0e,(0,p.A)({},x0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}v0e.isMDXComponent=!0;const L0e={toc:[]},b0e="wrapper";function N0e(e){let{components:n,...t}=e;return(0,s.yg)(b0e,(0,p.A)({},L0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}N0e.isMDXComponent=!0;const k0e={toc:[]},z0e="wrapper";function P0e(e){let{components:n,...t}=e;return(0,s.yg)(z0e,(0,p.A)({},k0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}P0e.isMDXComponent=!0;const I0e={toc:[]},R0e="wrapper";function W0e(e){let{components:n,...t}=e;return(0,s.yg)(R0e,(0,p.A)({},I0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}W0e.isMDXComponent=!0;const S0e={toc:[]},B0e="wrapper";function G0e(e){let{components:n,...t}=e;return(0,s.yg)(B0e,(0,p.A)({},S0e,t,{components:n,mdxType:"MDXLayout"}))}G0e.isMDXComponent=!0;const E0e={toc:[]},O0e="wrapper";function U0e(e){let{components:n,...t}=e;return(0,s.yg)(O0e,(0,p.A)({},E0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}U0e.isMDXComponent=!0;const F0e={toc:[]},V0e="wrapper";function q0e(e){let{components:n,...t}=e;return(0,s.yg)(V0e,(0,p.A)({},F0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}q0e.isMDXComponent=!0;const j0e={toc:[]},H0e="wrapper";function Y0e(e){let{components:n,...t}=e;return(0,s.yg)(H0e,(0,p.A)({},j0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Y0e.isMDXComponent=!0;const Q0e={toc:[]},$0e="wrapper";function K0e(e){let{components:n,...t}=e;return(0,s.yg)($0e,(0,p.A)({},Q0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}K0e.isMDXComponent=!0;const J0e={toc:[]},Z0e="wrapper";function e2e(e){let{components:n,...t}=e;return(0,s.yg)(Z0e,(0,p.A)({},J0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}e2e.isMDXComponent=!0;const n2e={toc:[]},t2e="wrapper";function o2e(e){let{components:n,...t}=e;return(0,s.yg)(t2e,(0,p.A)({},n2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}o2e.isMDXComponent=!0;const p2e={toc:[]},r2e="wrapper";function s2e(e){let{components:n,...t}=e;return(0,s.yg)(r2e,(0,p.A)({},p2e,t,{components:n,mdxType:"MDXLayout"}))}s2e.isMDXComponent=!0;const c2e={toc:[]},a2e="wrapper";function i2e(e){let{components:n,...t}=e;return(0,s.yg)(a2e,(0,p.A)({},c2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}i2e.isMDXComponent=!0;const l2e={toc:[]},u2e="wrapper";function m2e(e){let{components:n,...t}=e;return(0,s.yg)(u2e,(0,p.A)({},l2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}m2e.isMDXComponent=!0;const y2e={toc:[]},d2e="wrapper";function h2e(e){let{components:n,...t}=e;return(0,s.yg)(d2e,(0,p.A)({},y2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}h2e.isMDXComponent=!0;const g2e={toc:[]},f2e="wrapper";function D2e(e){let{components:n,...t}=e;return(0,s.yg)(f2e,(0,p.A)({},g2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}D2e.isMDXComponent=!0;const M2e={toc:[]},X2e="wrapper";function _2e(e){let{components:n,...t}=e;return(0,s.yg)(X2e,(0,p.A)({},M2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}_2e.isMDXComponent=!0;const w2e={toc:[]},T2e="wrapper";function C2e(e){let{components:n,...t}=e;return(0,s.yg)(T2e,(0,p.A)({},w2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}C2e.isMDXComponent=!0;const x2e={toc:[]},A2e="wrapper";function v2e(e){let{components:n,...t}=e;return(0,s.yg)(A2e,(0,p.A)({},x2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}v2e.isMDXComponent=!0;const L2e={toc:[]},b2e="wrapper";function N2e(e){let{components:n,...t}=e;return(0,s.yg)(b2e,(0,p.A)({},L2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}N2e.isMDXComponent=!0;const k2e={toc:[]},z2e="wrapper";function P2e(e){let{components:n,...t}=e;return(0,s.yg)(z2e,(0,p.A)({},k2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}P2e.isMDXComponent=!0;const I2e={toc:[]},R2e="wrapper";function W2e(e){let{components:n,...t}=e;return(0,s.yg)(R2e,(0,p.A)({},I2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}W2e.isMDXComponent=!0;const S2e={toc:[]},B2e="wrapper";function G2e(e){let{components:n,...t}=e;return(0,s.yg)(B2e,(0,p.A)({},S2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}G2e.isMDXComponent=!0;const E2e={toc:[]},O2e="wrapper";function U2e(e){let{components:n,...t}=e;return(0,s.yg)(O2e,(0,p.A)({},E2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}U2e.isMDXComponent=!0;const F2e={toc:[]},V2e="wrapper";function q2e(e){let{components:n,...t}=e;return(0,s.yg)(V2e,(0,p.A)({},F2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}q2e.isMDXComponent=!0;const j2e={toc:[]},H2e="wrapper";function Y2e(e){let{components:n,...t}=e;return(0,s.yg)(H2e,(0,p.A)({},j2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Y2e.isMDXComponent=!0;const Q2e={toc:[]},$2e="wrapper";function K2e(e){let{components:n,...t}=e;return(0,s.yg)($2e,(0,p.A)({},Q2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}K2e.isMDXComponent=!0;const J2e={toc:[]},Z2e="wrapper";function e4e(e){let{components:n,...t}=e;return(0,s.yg)(Z2e,(0,p.A)({},J2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}e4e.isMDXComponent=!0;const n4e={toc:[]},t4e="wrapper";function o4e(e){let{components:n,...t}=e;return(0,s.yg)(t4e,(0,p.A)({},n4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}o4e.isMDXComponent=!0;const p4e={toc:[]},r4e="wrapper";function s4e(e){let{components:n,...t}=e;return(0,s.yg)(r4e,(0,p.A)({},p4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}s4e.isMDXComponent=!0;const c4e={toc:[]},a4e="wrapper";function i4e(e){let{components:n,...t}=e;return(0,s.yg)(a4e,(0,p.A)({},c4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}i4e.isMDXComponent=!0;const l4e={toc:[]},u4e="wrapper";function m4e(e){let{components:n,...t}=e;return(0,s.yg)(u4e,(0,p.A)({},l4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}m4e.isMDXComponent=!0;const y4e={toc:[]},d4e="wrapper";function h4e(e){let{components:n,...t}=e;return(0,s.yg)(d4e,(0,p.A)({},y4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}h4e.isMDXComponent=!0;const g4e={toc:[]},f4e="wrapper";function D4e(e){let{components:n,...t}=e;return(0,s.yg)(f4e,(0,p.A)({},g4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}D4e.isMDXComponent=!0;const M4e={toc:[]},X4e="wrapper";function _4e(e){let{components:n,...t}=e;return(0,s.yg)(X4e,(0,p.A)({},M4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}_4e.isMDXComponent=!0;const w4e={toc:[]},T4e="wrapper";function C4e(e){let{components:n,...t}=e;return(0,s.yg)(T4e,(0,p.A)({},w4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}C4e.isMDXComponent=!0;const x4e={toc:[]},A4e="wrapper";function v4e(e){let{components:n,...t}=e;return(0,s.yg)(A4e,(0,p.A)({},x4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}v4e.isMDXComponent=!0;const L4e={toc:[]},b4e="wrapper";function N4e(e){let{components:n,...t}=e;return(0,s.yg)(b4e,(0,p.A)({},L4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}N4e.isMDXComponent=!0;const k4e={toc:[]},z4e="wrapper";function P4e(e){let{components:n,...t}=e;return(0,s.yg)(z4e,(0,p.A)({},k4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}P4e.isMDXComponent=!0;const I4e={toc:[]},R4e="wrapper";function W4e(e){let{components:n,...t}=e;return(0,s.yg)(R4e,(0,p.A)({},I4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}W4e.isMDXComponent=!0;const S4e={toc:[]},B4e="wrapper";function G4e(e){let{components:n,...t}=e;return(0,s.yg)(B4e,(0,p.A)({},S4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}G4e.isMDXComponent=!0;const E4e={toc:[]},O4e="wrapper";function U4e(e){let{components:n,...t}=e;return(0,s.yg)(O4e,(0,p.A)({},E4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}U4e.isMDXComponent=!0;const F4e={toc:[]},V4e="wrapper";function q4e(e){let{components:n,...t}=e;return(0,s.yg)(V4e,(0,p.A)({},F4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}q4e.isMDXComponent=!0;const j4e={toc:[]},H4e="wrapper";function Y4e(e){let{components:n,...t}=e;return(0,s.yg)(H4e,(0,p.A)({},j4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Y4e.isMDXComponent=!0;const Q4e={toc:[]},$4e="wrapper";function K4e(e){let{components:n,...t}=e;return(0,s.yg)($4e,(0,p.A)({},Q4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}K4e.isMDXComponent=!0;const J4e={toc:[]},Z4e="wrapper";function e8e(e){let{components:n,...t}=e;return(0,s.yg)(Z4e,(0,p.A)({},J4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}e8e.isMDXComponent=!0;const n8e={toc:[]},t8e="wrapper";function o8e(e){let{components:n,...t}=e;return(0,s.yg)(t8e,(0,p.A)({},n8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}o8e.isMDXComponent=!0;const p8e={toc:[]},r8e="wrapper";function s8e(e){let{components:n,...t}=e;return(0,s.yg)(r8e,(0,p.A)({},p8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}s8e.isMDXComponent=!0;const c8e={toc:[]},a8e="wrapper";function i8e(e){let{components:n,...t}=e;return(0,s.yg)(a8e,(0,p.A)({},c8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}i8e.isMDXComponent=!0;const l8e={toc:[]},u8e="wrapper";function m8e(e){let{components:n,...t}=e;return(0,s.yg)(u8e,(0,p.A)({},l8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}m8e.isMDXComponent=!0;const y8e={toc:[]},d8e="wrapper";function h8e(e){let{components:n,...t}=e;return(0,s.yg)(d8e,(0,p.A)({},y8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}h8e.isMDXComponent=!0;const g8e={toc:[]},f8e="wrapper";function D8e(e){let{components:n,...t}=e;return(0,s.yg)(f8e,(0,p.A)({},g8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}D8e.isMDXComponent=!0;const M8e={toc:[]},X8e="wrapper";function _8e(e){let{components:n,...t}=e;return(0,s.yg)(X8e,(0,p.A)({},M8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_8e.isMDXComponent=!0;const w8e={toc:[]},T8e="wrapper";function C8e(e){let{components:n,...t}=e;return(0,s.yg)(T8e,(0,p.A)({},w8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}C8e.isMDXComponent=!0;const x8e={toc:[]},A8e="wrapper";function v8e(e){let{components:n,...t}=e;return(0,s.yg)(A8e,(0,p.A)({},x8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}v8e.isMDXComponent=!0;const L8e={toc:[]},b8e="wrapper";function N8e(e){let{components:n,...t}=e;return(0,s.yg)(b8e,(0,p.A)({},L8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}N8e.isMDXComponent=!0;const k8e={toc:[]},z8e="wrapper";function P8e(e){let{components:n,...t}=e;return(0,s.yg)(z8e,(0,p.A)({},k8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}P8e.isMDXComponent=!0;const I8e={toc:[]},R8e="wrapper";function W8e(e){let{components:n,...t}=e;return(0,s.yg)(R8e,(0,p.A)({},I8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}W8e.isMDXComponent=!0;const S8e={toc:[]},B8e="wrapper";function G8e(e){let{components:n,...t}=e;return(0,s.yg)(B8e,(0,p.A)({},S8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}G8e.isMDXComponent=!0;const E8e={toc:[]},O8e="wrapper";function U8e(e){let{components:n,...t}=e;return(0,s.yg)(O8e,(0,p.A)({},E8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}U8e.isMDXComponent=!0;const F8e={toc:[]},V8e="wrapper";function q8e(e){let{components:n,...t}=e;return(0,s.yg)(V8e,(0,p.A)({},F8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}q8e.isMDXComponent=!0;const j8e={toc:[]},H8e="wrapper";function Y8e(e){let{components:n,...t}=e;return(0,s.yg)(H8e,(0,p.A)({},j8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Y8e.isMDXComponent=!0;const Q8e={toc:[]},$8e="wrapper";function K8e(e){let{components:n,...t}=e;return(0,s.yg)($8e,(0,p.A)({},Q8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}K8e.isMDXComponent=!0;const J8e={toc:[]},Z8e="wrapper";function e3e(e){let{components:n,...t}=e;return(0,s.yg)(Z8e,(0,p.A)({},J8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}e3e.isMDXComponent=!0;const n3e={toc:[]},t3e="wrapper";function o3e(e){let{components:n,...t}=e;return(0,s.yg)(t3e,(0,p.A)({},n3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}o3e.isMDXComponent=!0;const p3e={toc:[]},r3e="wrapper";function s3e(e){let{components:n,...t}=e;return(0,s.yg)(r3e,(0,p.A)({},p3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}s3e.isMDXComponent=!0;const c3e={toc:[]},a3e="wrapper";function i3e(e){let{components:n,...t}=e;return(0,s.yg)(a3e,(0,p.A)({},c3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}i3e.isMDXComponent=!0;const l3e={toc:[]},u3e="wrapper";function m3e(e){let{components:n,...t}=e;return(0,s.yg)(u3e,(0,p.A)({},l3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}m3e.isMDXComponent=!0;const y3e={toc:[]},d3e="wrapper";function h3e(e){let{components:n,...t}=e;return(0,s.yg)(d3e,(0,p.A)({},y3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}h3e.isMDXComponent=!0;const g3e={toc:[]},f3e="wrapper";function D3e(e){let{components:n,...t}=e;return(0,s.yg)(f3e,(0,p.A)({},g3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}D3e.isMDXComponent=!0;const M3e={toc:[]},X3e="wrapper";function _3e(e){let{components:n,...t}=e;return(0,s.yg)(X3e,(0,p.A)({},M3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}_3e.isMDXComponent=!0;const w3e={toc:[]},T3e="wrapper";function C3e(e){let{components:n,...t}=e;return(0,s.yg)(T3e,(0,p.A)({},w3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}C3e.isMDXComponent=!0;const x3e={toc:[]},A3e="wrapper";function v3e(e){let{components:n,...t}=e;return(0,s.yg)(A3e,(0,p.A)({},x3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}v3e.isMDXComponent=!0;const L3e={toc:[]},b3e="wrapper";function N3e(e){let{components:n,...t}=e;return(0,s.yg)(b3e,(0,p.A)({},L3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}N3e.isMDXComponent=!0;const k3e={toc:[]},z3e="wrapper";function P3e(e){let{components:n,...t}=e;return(0,s.yg)(z3e,(0,p.A)({},k3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}P3e.isMDXComponent=!0;const I3e={toc:[]},R3e="wrapper";function W3e(e){let{components:n,...t}=e;return(0,s.yg)(R3e,(0,p.A)({},I3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}W3e.isMDXComponent=!0;const S3e={toc:[]},B3e="wrapper";function G3e(e){let{components:n,...t}=e;return(0,s.yg)(B3e,(0,p.A)({},S3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}G3e.isMDXComponent=!0;const E3e={toc:[]},O3e="wrapper";function U3e(e){let{components:n,...t}=e;return(0,s.yg)(O3e,(0,p.A)({},E3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}U3e.isMDXComponent=!0;const F3e={toc:[]},V3e="wrapper";function q3e(e){let{components:n,...t}=e;return(0,s.yg)(V3e,(0,p.A)({},F3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}q3e.isMDXComponent=!0;const j3e={toc:[]},H3e="wrapper";function Y3e(e){let{components:n,...t}=e;return(0,s.yg)(H3e,(0,p.A)({},j3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Y3e.isMDXComponent=!0;const Q3e={toc:[]},$3e="wrapper";function K3e(e){let{components:n,...t}=e;return(0,s.yg)($3e,(0,p.A)({},Q3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}K3e.isMDXComponent=!0;const J3e={toc:[]},Z3e="wrapper";function e1e(e){let{components:n,...t}=e;return(0,s.yg)(Z3e,(0,p.A)({},J3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}e1e.isMDXComponent=!0;const n1e={toc:[]},t1e="wrapper";function o1e(e){let{components:n,...t}=e;return(0,s.yg)(t1e,(0,p.A)({},n1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}o1e.isMDXComponent=!0;const p1e={toc:[]},r1e="wrapper";function s1e(e){let{components:n,...t}=e;return(0,s.yg)(r1e,(0,p.A)({},p1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}s1e.isMDXComponent=!0;const c1e={toc:[]},a1e="wrapper";function i1e(e){let{components:n,...t}=e;return(0,s.yg)(a1e,(0,p.A)({},c1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}i1e.isMDXComponent=!0;const l1e={toc:[]},u1e="wrapper";function m1e(e){let{components:n,...t}=e;return(0,s.yg)(u1e,(0,p.A)({},l1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}m1e.isMDXComponent=!0;const y1e={toc:[]},d1e="wrapper";function h1e(e){let{components:n,...t}=e;return(0,s.yg)(d1e,(0,p.A)({},y1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}h1e.isMDXComponent=!0;const g1e={toc:[]},f1e="wrapper";function D1e(e){let{components:n,...t}=e;return(0,s.yg)(f1e,(0,p.A)({},g1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}D1e.isMDXComponent=!0;const M1e={toc:[]},X1e="wrapper";function _1e(e){let{components:n,...t}=e;return(0,s.yg)(X1e,(0,p.A)({},M1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_1e.isMDXComponent=!0;const w1e={toc:[]},T1e="wrapper";function C1e(e){let{components:n,...t}=e;return(0,s.yg)(T1e,(0,p.A)({},w1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}C1e.isMDXComponent=!0;const x1e={toc:[]},A1e="wrapper";function v1e(e){let{components:n,...t}=e;return(0,s.yg)(A1e,(0,p.A)({},x1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}v1e.isMDXComponent=!0;const L1e={toc:[]},b1e="wrapper";function N1e(e){let{components:n,...t}=e;return(0,s.yg)(b1e,(0,p.A)({},L1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}N1e.isMDXComponent=!0;const k1e={toc:[]},z1e="wrapper";function P1e(e){let{components:n,...t}=e;return(0,s.yg)(z1e,(0,p.A)({},k1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}P1e.isMDXComponent=!0;const I1e={toc:[]},R1e="wrapper";function W1e(e){let{components:n,...t}=e;return(0,s.yg)(R1e,(0,p.A)({},I1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}W1e.isMDXComponent=!0;const S1e={toc:[]},B1e="wrapper";function G1e(e){let{components:n,...t}=e;return(0,s.yg)(B1e,(0,p.A)({},S1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}G1e.isMDXComponent=!0;const E1e={toc:[]},O1e="wrapper";function U1e(e){let{components:n,...t}=e;return(0,s.yg)(O1e,(0,p.A)({},E1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}U1e.isMDXComponent=!0;const F1e={toc:[]},V1e="wrapper";function q1e(e){let{components:n,...t}=e;return(0,s.yg)(V1e,(0,p.A)({},F1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}q1e.isMDXComponent=!0;const j1e={toc:[]},H1e="wrapper";function Y1e(e){let{components:n,...t}=e;return(0,s.yg)(H1e,(0,p.A)({},j1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Y1e.isMDXComponent=!0;const Q1e={toc:[]},$1e="wrapper";function K1e(e){let{components:n,...t}=e;return(0,s.yg)($1e,(0,p.A)({},Q1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}K1e.isMDXComponent=!0;const J1e={toc:[]},Z1e="wrapper";function e6e(e){let{components:n,...t}=e;return(0,s.yg)(Z1e,(0,p.A)({},J1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}e6e.isMDXComponent=!0;const n6e={toc:[]},t6e="wrapper";function o6e(e){let{components:n,...t}=e;return(0,s.yg)(t6e,(0,p.A)({},n6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}o6e.isMDXComponent=!0;const p6e={toc:[]},r6e="wrapper";function s6e(e){let{components:n,...t}=e;return(0,s.yg)(r6e,(0,p.A)({},p6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}s6e.isMDXComponent=!0;const c6e={toc:[]},a6e="wrapper";function i6e(e){let{components:n,...t}=e;return(0,s.yg)(a6e,(0,p.A)({},c6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}i6e.isMDXComponent=!0;const l6e={toc:[]},u6e="wrapper";function m6e(e){let{components:n,...t}=e;return(0,s.yg)(u6e,(0,p.A)({},l6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}m6e.isMDXComponent=!0;const y6e={toc:[]},d6e="wrapper";function h6e(e){let{components:n,...t}=e;return(0,s.yg)(d6e,(0,p.A)({},y6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}h6e.isMDXComponent=!0;const g6e={toc:[]},f6e="wrapper";function D6e(e){let{components:n,...t}=e;return(0,s.yg)(f6e,(0,p.A)({},g6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}D6e.isMDXComponent=!0;const M6e={toc:[]},X6e="wrapper";function _6e(e){let{components:n,...t}=e;return(0,s.yg)(X6e,(0,p.A)({},M6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}_6e.isMDXComponent=!0;const w6e={toc:[]},T6e="wrapper";function C6e(e){let{components:n,...t}=e;return(0,s.yg)(T6e,(0,p.A)({},w6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}C6e.isMDXComponent=!0;const x6e={toc:[]},A6e="wrapper";function v6e(e){let{components:n,...t}=e;return(0,s.yg)(A6e,(0,p.A)({},x6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}v6e.isMDXComponent=!0;const L6e={toc:[]},b6e="wrapper";function N6e(e){let{components:n,...t}=e;return(0,s.yg)(b6e,(0,p.A)({},L6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}N6e.isMDXComponent=!0;const k6e={toc:[]},z6e="wrapper";function P6e(e){let{components:n,...t}=e;return(0,s.yg)(z6e,(0,p.A)({},k6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}P6e.isMDXComponent=!0;const I6e={toc:[]},R6e="wrapper";function W6e(e){let{components:n,...t}=e;return(0,s.yg)(R6e,(0,p.A)({},I6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}W6e.isMDXComponent=!0;const S6e={toc:[]},B6e="wrapper";function G6e(e){let{components:n,...t}=e;return(0,s.yg)(B6e,(0,p.A)({},S6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}G6e.isMDXComponent=!0;const E6e={toc:[]},O6e="wrapper";function U6e(e){let{components:n,...t}=e;return(0,s.yg)(O6e,(0,p.A)({},E6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}U6e.isMDXComponent=!0;const F6e={toc:[]},V6e="wrapper";function q6e(e){let{components:n,...t}=e;return(0,s.yg)(V6e,(0,p.A)({},F6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}q6e.isMDXComponent=!0;const j6e={toc:[]},H6e="wrapper";function Y6e(e){let{components:n,...t}=e;return(0,s.yg)(H6e,(0,p.A)({},j6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Y6e.isMDXComponent=!0;const Q6e={toc:[]},$6e="wrapper";function K6e(e){let{components:n,...t}=e;return(0,s.yg)($6e,(0,p.A)({},Q6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}K6e.isMDXComponent=!0;const J6e={toc:[]},Z6e="wrapper";function e5e(e){let{components:n,...t}=e;return(0,s.yg)(Z6e,(0,p.A)({},J6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}e5e.isMDXComponent=!0;const n5e={toc:[]},t5e="wrapper";function o5e(e){let{components:n,...t}=e;return(0,s.yg)(t5e,(0,p.A)({},n5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}o5e.isMDXComponent=!0;const p5e={toc:[]},r5e="wrapper";function s5e(e){let{components:n,...t}=e;return(0,s.yg)(r5e,(0,p.A)({},p5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}s5e.isMDXComponent=!0;const c5e={toc:[]},a5e="wrapper";function i5e(e){let{components:n,...t}=e;return(0,s.yg)(a5e,(0,p.A)({},c5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}i5e.isMDXComponent=!0;const l5e={toc:[]},u5e="wrapper";function m5e(e){let{components:n,...t}=e;return(0,s.yg)(u5e,(0,p.A)({},l5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}m5e.isMDXComponent=!0;const y5e={toc:[]},d5e="wrapper";function h5e(e){let{components:n,...t}=e;return(0,s.yg)(d5e,(0,p.A)({},y5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}h5e.isMDXComponent=!0;const g5e={toc:[]},f5e="wrapper";function D5e(e){let{components:n,...t}=e;return(0,s.yg)(f5e,(0,p.A)({},g5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}D5e.isMDXComponent=!0;const M5e={toc:[]},X5e="wrapper";function _5e(e){let{components:n,...t}=e;return(0,s.yg)(X5e,(0,p.A)({},M5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}_5e.isMDXComponent=!0;const w5e={toc:[]},T5e="wrapper";function C5e(e){let{components:n,...t}=e;return(0,s.yg)(T5e,(0,p.A)({},w5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}C5e.isMDXComponent=!0;const x5e={toc:[]},A5e="wrapper";function v5e(e){let{components:n,...t}=e;return(0,s.yg)(A5e,(0,p.A)({},x5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}v5e.isMDXComponent=!0;const L5e={toc:[]},b5e="wrapper";function N5e(e){let{components:n,...t}=e;return(0,s.yg)(b5e,(0,p.A)({},L5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}N5e.isMDXComponent=!0;const k5e={toc:[]},z5e="wrapper";function P5e(e){let{components:n,...t}=e;return(0,s.yg)(z5e,(0,p.A)({},k5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}P5e.isMDXComponent=!0;const I5e={toc:[]},R5e="wrapper";function W5e(e){let{components:n,...t}=e;return(0,s.yg)(R5e,(0,p.A)({},I5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}W5e.isMDXComponent=!0;const S5e={toc:[]},B5e="wrapper";function G5e(e){let{components:n,...t}=e;return(0,s.yg)(B5e,(0,p.A)({},S5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}G5e.isMDXComponent=!0;const E5e={toc:[]},O5e="wrapper";function U5e(e){let{components:n,...t}=e;return(0,s.yg)(O5e,(0,p.A)({},E5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}U5e.isMDXComponent=!0;const F5e={toc:[]},V5e="wrapper";function q5e(e){let{components:n,...t}=e;return(0,s.yg)(V5e,(0,p.A)({},F5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}q5e.isMDXComponent=!0;const j5e={toc:[]},H5e="wrapper";function Y5e(e){let{components:n,...t}=e;return(0,s.yg)(H5e,(0,p.A)({},j5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Y5e.isMDXComponent=!0;const Q5e={toc:[]},$5e="wrapper";function K5e(e){let{components:n,...t}=e;return(0,s.yg)($5e,(0,p.A)({},Q5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}K5e.isMDXComponent=!0;const J5e={toc:[]},Z5e="wrapper";function e7e(e){let{components:n,...t}=e;return(0,s.yg)(Z5e,(0,p.A)({},J5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}e7e.isMDXComponent=!0;const n7e={toc:[]},t7e="wrapper";function o7e(e){let{components:n,...t}=e;return(0,s.yg)(t7e,(0,p.A)({},n7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}o7e.isMDXComponent=!0;const p7e={toc:[]},r7e="wrapper";function s7e(e){let{components:n,...t}=e;return(0,s.yg)(r7e,(0,p.A)({},p7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}s7e.isMDXComponent=!0;const c7e={toc:[]},a7e="wrapper";function i7e(e){let{components:n,...t}=e;return(0,s.yg)(a7e,(0,p.A)({},c7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}i7e.isMDXComponent=!0;const l7e={toc:[]},u7e="wrapper";function m7e(e){let{components:n,...t}=e;return(0,s.yg)(u7e,(0,p.A)({},l7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}m7e.isMDXComponent=!0;const y7e={toc:[]},d7e="wrapper";function h7e(e){let{components:n,...t}=e;return(0,s.yg)(d7e,(0,p.A)({},y7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}h7e.isMDXComponent=!0;const g7e={toc:[]},f7e="wrapper";function D7e(e){let{components:n,...t}=e;return(0,s.yg)(f7e,(0,p.A)({},g7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}D7e.isMDXComponent=!0;const M7e={toc:[]},X7e="wrapper";function _7e(e){let{components:n,...t}=e;return(0,s.yg)(X7e,(0,p.A)({},M7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}_7e.isMDXComponent=!0;const w7e={toc:[]},T7e="wrapper";function C7e(e){let{components:n,...t}=e;return(0,s.yg)(T7e,(0,p.A)({},w7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}C7e.isMDXComponent=!0;const x7e={toc:[]},A7e="wrapper";function v7e(e){let{components:n,...t}=e;return(0,s.yg)(A7e,(0,p.A)({},x7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}v7e.isMDXComponent=!0;const L7e={toc:[]},b7e="wrapper";function N7e(e){let{components:n,...t}=e;return(0,s.yg)(b7e,(0,p.A)({},L7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}N7e.isMDXComponent=!0;const k7e={toc:[]},z7e="wrapper";function P7e(e){let{components:n,...t}=e;return(0,s.yg)(z7e,(0,p.A)({},k7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}P7e.isMDXComponent=!0;const I7e={toc:[]},R7e="wrapper";function W7e(e){let{components:n,...t}=e;return(0,s.yg)(R7e,(0,p.A)({},I7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}W7e.isMDXComponent=!0;const S7e={toc:[]},B7e="wrapper";function G7e(e){let{components:n,...t}=e;return(0,s.yg)(B7e,(0,p.A)({},S7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}G7e.isMDXComponent=!0;const E7e={toc:[]},O7e="wrapper";function U7e(e){let{components:n,...t}=e;return(0,s.yg)(O7e,(0,p.A)({},E7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}U7e.isMDXComponent=!0;const F7e={toc:[]},V7e="wrapper";function q7e(e){let{components:n,...t}=e;return(0,s.yg)(V7e,(0,p.A)({},F7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}q7e.isMDXComponent=!0;const j7e={toc:[]},H7e="wrapper";function Y7e(e){let{components:n,...t}=e;return(0,s.yg)(H7e,(0,p.A)({},j7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Y7e.isMDXComponent=!0;const Q7e={toc:[]},$7e="wrapper";function K7e(e){let{components:n,...t}=e;return(0,s.yg)($7e,(0,p.A)({},Q7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}K7e.isMDXComponent=!0;const J7e={toc:[]},Z7e="wrapper";function e9e(e){let{components:n,...t}=e;return(0,s.yg)(Z7e,(0,p.A)({},J7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}e9e.isMDXComponent=!0;const n9e={toc:[]},t9e="wrapper";function o9e(e){let{components:n,...t}=e;return(0,s.yg)(t9e,(0,p.A)({},n9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}o9e.isMDXComponent=!0;const p9e={toc:[]},r9e="wrapper";function s9e(e){let{components:n,...t}=e;return(0,s.yg)(r9e,(0,p.A)({},p9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}s9e.isMDXComponent=!0;const c9e={toc:[]},a9e="wrapper";function i9e(e){let{components:n,...t}=e;return(0,s.yg)(a9e,(0,p.A)({},c9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}i9e.isMDXComponent=!0;const l9e={toc:[]},u9e="wrapper";function m9e(e){let{components:n,...t}=e;return(0,s.yg)(u9e,(0,p.A)({},l9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}m9e.isMDXComponent=!0;const y9e={toc:[]},d9e="wrapper";function h9e(e){let{components:n,...t}=e;return(0,s.yg)(d9e,(0,p.A)({},y9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}h9e.isMDXComponent=!0;const g9e={toc:[]},f9e="wrapper";function D9e(e){let{components:n,...t}=e;return(0,s.yg)(f9e,(0,p.A)({},g9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}D9e.isMDXComponent=!0;const M9e={toc:[]},X9e="wrapper";function _9e(e){let{components:n,...t}=e;return(0,s.yg)(X9e,(0,p.A)({},M9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}_9e.isMDXComponent=!0;const w9e={toc:[]},T9e="wrapper";function C9e(e){let{components:n,...t}=e;return(0,s.yg)(T9e,(0,p.A)({},w9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}C9e.isMDXComponent=!0;const x9e={toc:[]},A9e="wrapper";function v9e(e){let{components:n,...t}=e;return(0,s.yg)(A9e,(0,p.A)({},x9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}v9e.isMDXComponent=!0;const L9e={toc:[]},b9e="wrapper";function N9e(e){let{components:n,...t}=e;return(0,s.yg)(b9e,(0,p.A)({},L9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}N9e.isMDXComponent=!0;const k9e={toc:[]},z9e="wrapper";function P9e(e){let{components:n,...t}=e;return(0,s.yg)(z9e,(0,p.A)({},k9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}P9e.isMDXComponent=!0;const I9e={toc:[]},R9e="wrapper";function W9e(e){let{components:n,...t}=e;return(0,s.yg)(R9e,(0,p.A)({},I9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}W9e.isMDXComponent=!0;const S9e={toc:[]},B9e="wrapper";function G9e(e){let{components:n,...t}=e;return(0,s.yg)(B9e,(0,p.A)({},S9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}G9e.isMDXComponent=!0;const E9e={toc:[]},O9e="wrapper";function U9e(e){let{components:n,...t}=e;return(0,s.yg)(O9e,(0,p.A)({},E9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}U9e.isMDXComponent=!0;const F9e={toc:[]},V9e="wrapper";function q9e(e){let{components:n,...t}=e;return(0,s.yg)(V9e,(0,p.A)({},F9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}q9e.isMDXComponent=!0;const j9e={toc:[]},H9e="wrapper";function Y9e(e){let{components:n,...t}=e;return(0,s.yg)(H9e,(0,p.A)({},j9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Y9e.isMDXComponent=!0;const Q9e={toc:[]},$9e="wrapper";function K9e(e){let{components:n,...t}=e;return(0,s.yg)($9e,(0,p.A)({},Q9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}K9e.isMDXComponent=!0;const J9e={toc:[]},Z9e="wrapper";function een(e){let{components:n,...t}=e;return(0,s.yg)(Z9e,(0,p.A)({},J9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}een.isMDXComponent=!0;const nen={toc:[]},ten="wrapper";function oen(e){let{components:n,...t}=e;return(0,s.yg)(ten,(0,p.A)({},nen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}oen.isMDXComponent=!0;const pen={toc:[]},ren="wrapper";function sen(e){let{components:n,...t}=e;return(0,s.yg)(ren,(0,p.A)({},pen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}sen.isMDXComponent=!0;const cen={toc:[]},aen="wrapper";function ien(e){let{components:n,...t}=e;return(0,s.yg)(aen,(0,p.A)({},cen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ien.isMDXComponent=!0;const len={toc:[]},uen="wrapper";function men(e){let{components:n,...t}=e;return(0,s.yg)(uen,(0,p.A)({},len,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}men.isMDXComponent=!0;const yen={toc:[]},den="wrapper";function hen(e){let{components:n,...t}=e;return(0,s.yg)(den,(0,p.A)({},yen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}hen.isMDXComponent=!0;const gen={toc:[]},fen="wrapper";function Den(e){let{components:n,...t}=e;return(0,s.yg)(fen,(0,p.A)({},gen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Den.isMDXComponent=!0;const Men={toc:[]},Xen="wrapper";function _en(e){let{components:n,...t}=e;return(0,s.yg)(Xen,(0,p.A)({},Men,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_en.isMDXComponent=!0;const wen={toc:[]},Ten="wrapper";function Cen(e){let{components:n,...t}=e;return(0,s.yg)(Ten,(0,p.A)({},wen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Cen.isMDXComponent=!0;const xen={toc:[]},Aen="wrapper";function ven(e){let{components:n,...t}=e;return(0,s.yg)(Aen,(0,p.A)({},xen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@revideo/2d';\nimport {all, createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}ven.isMDXComponent=!0;const Len={toc:[]},ben="wrapper";function Nen(e){let{components:n,...t}=e;return(0,s.yg)(ben,(0,p.A)({},Len,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a two-dimensional grid."))}Nen.isMDXComponent=!0;const ken={toc:[]},zen="wrapper";function Pen(e){let{components:n,...t}=e;return(0,s.yg)(zen,(0,p.A)({},ken,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Pen.isMDXComponent=!0;const Ien={toc:[]},Ren="wrapper";function Wen(e){let{components:n,...t}=e;return(0,s.yg)(Ren,(0,p.A)({},Ien,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Wen.isMDXComponent=!0;const Sen={toc:[]},Ben="wrapper";function Gen(e){let{components:n,...t}=e;return(0,s.yg)(Ben,(0,p.A)({},Sen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Gen.isMDXComponent=!0;const Een={toc:[]},Oen="wrapper";function Uen(e){let{components:n,...t}=e;return(0,s.yg)(Oen,(0,p.A)({},Een,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Uen.isMDXComponent=!0;const Fen={toc:[]},Ven="wrapper";function qen(e){let{components:n,...t}=e;return(0,s.yg)(Ven,(0,p.A)({},Fen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}qen.isMDXComponent=!0;const jen={toc:[]},Hen="wrapper";function Yen(e){let{components:n,...t}=e;return(0,s.yg)(Hen,(0,p.A)({},jen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Yen.isMDXComponent=!0;const Qen={toc:[]},$en="wrapper";function Ken(e){let{components:n,...t}=e;return(0,s.yg)($en,(0,p.A)({},Qen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ken.isMDXComponent=!0;const Jen={toc:[]},Zen="wrapper";function enn(e){let{components:n,...t}=e;return(0,s.yg)(Zen,(0,p.A)({},Jen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}enn.isMDXComponent=!0;const nnn={toc:[]},tnn="wrapper";function onn(e){let{components:n,...t}=e;return(0,s.yg)(tnn,(0,p.A)({},nnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}onn.isMDXComponent=!0;const pnn={toc:[]},rnn="wrapper";function snn(e){let{components:n,...t}=e;return(0,s.yg)(rnn,(0,p.A)({},pnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}snn.isMDXComponent=!0;const cnn={toc:[]},ann="wrapper";function inn(e){let{components:n,...t}=e;return(0,s.yg)(ann,(0,p.A)({},cnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}inn.isMDXComponent=!0;const lnn={toc:[]},unn="wrapper";function mnn(e){let{components:n,...t}=e;return(0,s.yg)(unn,(0,p.A)({},lnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}mnn.isMDXComponent=!0;const ynn={toc:[]},dnn="wrapper";function hnn(e){let{components:n,...t}=e;return(0,s.yg)(dnn,(0,p.A)({},ynn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}hnn.isMDXComponent=!0;const gnn={toc:[]},fnn="wrapper";function Dnn(e){let{components:n,...t}=e;return(0,s.yg)(fnn,(0,p.A)({},gnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Dnn.isMDXComponent=!0;const Mnn={toc:[]},Xnn="wrapper";function _nn(e){let{components:n,...t}=e;return(0,s.yg)(Xnn,(0,p.A)({},Mnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}_nn.isMDXComponent=!0;const wnn={toc:[]},Tnn="wrapper";function Cnn(e){let{components:n,...t}=e;return(0,s.yg)(Tnn,(0,p.A)({},wnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the end of each grid line."))}Cnn.isMDXComponent=!0;const xnn={toc:[]},Ann="wrapper";function vnn(e){let{components:n,...t}=e;return(0,s.yg)(Ann,(0,p.A)({},xnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}vnn.isMDXComponent=!0;const Lnn={toc:[]},bnn="wrapper";function Nnn(e){let{components:n,...t}=e;return(0,s.yg)(bnn,(0,p.A)({},Lnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Nnn.isMDXComponent=!0;const knn={toc:[]},znn="wrapper";function Pnn(e){let{components:n,...t}=e;return(0,s.yg)(znn,(0,p.A)({},knn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Pnn.isMDXComponent=!0;const Inn={toc:[]},Rnn="wrapper";function Wnn(e){let{components:n,...t}=e;return(0,s.yg)(Rnn,(0,p.A)({},Inn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Wnn.isMDXComponent=!0;const Snn={toc:[]},Bnn="wrapper";function Gnn(e){let{components:n,...t}=e;return(0,s.yg)(Bnn,(0,p.A)({},Snn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Gnn.isMDXComponent=!0;const Enn={toc:[]},Onn="wrapper";function Unn(e){let{components:n,...t}=e;return(0,s.yg)(Onn,(0,p.A)({},Enn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Unn.isMDXComponent=!0;const Fnn={toc:[]},Vnn="wrapper";function qnn(e){let{components:n,...t}=e;return(0,s.yg)(Vnn,(0,p.A)({},Fnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}qnn.isMDXComponent=!0;const jnn={toc:[]},Hnn="wrapper";function Ynn(e){let{components:n,...t}=e;return(0,s.yg)(Hnn,(0,p.A)({},jnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Ynn.isMDXComponent=!0;const Qnn={toc:[]},$nn="wrapper";function Knn(e){let{components:n,...t}=e;return(0,s.yg)($nn,(0,p.A)({},Qnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Knn.isMDXComponent=!0;const Jnn={toc:[]},Znn="wrapper";function etn(e){let{components:n,...t}=e;return(0,s.yg)(Znn,(0,p.A)({},Jnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}etn.isMDXComponent=!0;const ntn={toc:[]},ttn="wrapper";function otn(e){let{components:n,...t}=e;return(0,s.yg)(ttn,(0,p.A)({},ntn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}otn.isMDXComponent=!0;const ptn={toc:[]},rtn="wrapper";function stn(e){let{components:n,...t}=e;return(0,s.yg)(rtn,(0,p.A)({},ptn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}stn.isMDXComponent=!0;const ctn={toc:[]},atn="wrapper";function itn(e){let{components:n,...t}=e;return(0,s.yg)(atn,(0,p.A)({},ctn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}itn.isMDXComponent=!0;const ltn={toc:[]},utn="wrapper";function mtn(e){let{components:n,...t}=e;return(0,s.yg)(utn,(0,p.A)({},ltn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}mtn.isMDXComponent=!0;const ytn={toc:[]},dtn="wrapper";function htn(e){let{components:n,...t}=e;return(0,s.yg)(dtn,(0,p.A)({},ytn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}htn.isMDXComponent=!0;const gtn={toc:[]},ftn="wrapper";function Dtn(e){let{components:n,...t}=e;return(0,s.yg)(ftn,(0,p.A)({},gtn,t,{components:n,mdxType:"MDXLayout"}))}Dtn.isMDXComponent=!0;const Mtn={toc:[]},Xtn="wrapper";function _tn(e){let{components:n,...t}=e;return(0,s.yg)(Xtn,(0,p.A)({},Mtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_tn.isMDXComponent=!0;const wtn={toc:[]},Ttn="wrapper";function Ctn(e){let{components:n,...t}=e;return(0,s.yg)(Ttn,(0,p.A)({},wtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Ctn.isMDXComponent=!0;const xtn={toc:[]},Atn="wrapper";function vtn(e){let{components:n,...t}=e;return(0,s.yg)(Atn,(0,p.A)({},xtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}vtn.isMDXComponent=!0;const Ltn={toc:[]},btn="wrapper";function Ntn(e){let{components:n,...t}=e;return(0,s.yg)(btn,(0,p.A)({},Ltn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Ntn.isMDXComponent=!0;const ktn={toc:[]},ztn="wrapper";function Ptn(e){let{components:n,...t}=e;return(0,s.yg)(ztn,(0,p.A)({},ktn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Ptn.isMDXComponent=!0;const Itn={toc:[]},Rtn="wrapper";function Wtn(e){let{components:n,...t}=e;return(0,s.yg)(Rtn,(0,p.A)({},Itn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The spacing between the grid lines."))}Wtn.isMDXComponent=!0;const Stn={toc:[]},Btn="wrapper";function Gtn(e){let{components:n,...t}=e;return(0,s.yg)(Btn,(0,p.A)({},Stn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Gtn.isMDXComponent=!0;const Etn={toc:[]},Otn="wrapper";function Utn(e){let{components:n,...t}=e;return(0,s.yg)(Otn,(0,p.A)({},Etn,t,{components:n,mdxType:"MDXLayout"}))}Utn.isMDXComponent=!0;const Ftn={toc:[]},Vtn="wrapper";function qtn(e){let{components:n,...t}=e;return(0,s.yg)(Vtn,(0,p.A)({},Ftn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}qtn.isMDXComponent=!0;const jtn={toc:[]},Htn="wrapper";function Ytn(e){let{components:n,...t}=e;return(0,s.yg)(Htn,(0,p.A)({},jtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}Ytn.isMDXComponent=!0;const Qtn={toc:[]},$tn="wrapper";function Ktn(e){let{components:n,...t}=e;return(0,s.yg)($tn,(0,p.A)({},Qtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]},Ztn="wrapper";function eon(e){let{components:n,...t}=e;return(0,s.yg)(Ztn,(0,p.A)({},Jtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}eon.isMDXComponent=!0;const non={toc:[]},ton="wrapper";function oon(e){let{components:n,...t}=e;return(0,s.yg)(ton,(0,p.A)({},non,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}oon.isMDXComponent=!0;const pon={toc:[]},ron="wrapper";function son(e){let{components:n,...t}=e;return(0,s.yg)(ron,(0,p.A)({},pon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}son.isMDXComponent=!0;const con={toc:[]},aon="wrapper";function ion(e){let{components:n,...t}=e;return(0,s.yg)(aon,(0,p.A)({},con,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ion.isMDXComponent=!0;const lon={toc:[]},uon="wrapper";function mon(e){let{components:n,...t}=e;return(0,s.yg)(uon,(0,p.A)({},lon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}mon.isMDXComponent=!0;const yon={toc:[]},don="wrapper";function hon(e){let{components:n,...t}=e;return(0,s.yg)(don,(0,p.A)({},yon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}hon.isMDXComponent=!0;const gon={toc:[]},fon="wrapper";function Don(e){let{components:n,...t}=e;return(0,s.yg)(fon,(0,p.A)({},gon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Don.isMDXComponent=!0;const Mon={toc:[]},Xon="wrapper";function _on(e){let{components:n,...t}=e;return(0,s.yg)(Xon,(0,p.A)({},Mon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}_on.isMDXComponent=!0;const won={toc:[]},Ton="wrapper";function Con(e){let{components:n,...t}=e;return(0,s.yg)(Ton,(0,p.A)({},won,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Con.isMDXComponent=!0;const xon={toc:[]},Aon="wrapper";function von(e){let{components:n,...t}=e;return(0,s.yg)(Aon,(0,p.A)({},xon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}von.isMDXComponent=!0;const Lon={toc:[]},bon="wrapper";function Non(e){let{components:n,...t}=e;return(0,s.yg)(bon,(0,p.A)({},Lon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Non.isMDXComponent=!0;const kon={toc:[]},zon="wrapper";function Pon(e){let{components:n,...t}=e;return(0,s.yg)(zon,(0,p.A)({},kon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Pon.isMDXComponent=!0;const Ion={toc:[]},Ron="wrapper";function Won(e){let{components:n,...t}=e;return(0,s.yg)(Ron,(0,p.A)({},Ion,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Won.isMDXComponent=!0;const Son={toc:[]},Bon="wrapper";function Gon(e){let{components:n,...t}=e;return(0,s.yg)(Bon,(0,p.A)({},Son,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Gon.isMDXComponent=!0;const Eon={toc:[]},Oon="wrapper";function Uon(e){let{components:n,...t}=e;return(0,s.yg)(Oon,(0,p.A)({},Eon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Uon.isMDXComponent=!0;const Fon={toc:[]},Von="wrapper";function qon(e){let{components:n,...t}=e;return(0,s.yg)(Von,(0,p.A)({},Fon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qon.isMDXComponent=!0;const jon={toc:[]},Hon="wrapper";function Yon(e){let{components:n,...t}=e;return(0,s.yg)(Hon,(0,p.A)({},jon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Yon.isMDXComponent=!0;const Qon={toc:[]},$on="wrapper";function Kon(e){let{components:n,...t}=e;return(0,s.yg)($on,(0,p.A)({},Qon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Kon.isMDXComponent=!0;const Jon={toc:[]},Zon="wrapper";function epn(e){let{components:n,...t}=e;return(0,s.yg)(Zon,(0,p.A)({},Jon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}epn.isMDXComponent=!0;const npn={toc:[]},tpn="wrapper";function opn(e){let{components:n,...t}=e;return(0,s.yg)(tpn,(0,p.A)({},npn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}opn.isMDXComponent=!0;const ppn={toc:[]},rpn="wrapper";function spn(e){let{components:n,...t}=e;return(0,s.yg)(rpn,(0,p.A)({},ppn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}spn.isMDXComponent=!0;const cpn={toc:[]},apn="wrapper";function ipn(e){let{components:n,...t}=e;return(0,s.yg)(apn,(0,p.A)({},cpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ipn.isMDXComponent=!0;const lpn={toc:[]},upn="wrapper";function mpn(e){let{components:n,...t}=e;return(0,s.yg)(upn,(0,p.A)({},lpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}mpn.isMDXComponent=!0;const ypn={toc:[]},dpn="wrapper";function hpn(e){let{components:n,...t}=e;return(0,s.yg)(dpn,(0,p.A)({},ypn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}hpn.isMDXComponent=!0;const gpn={toc:[]},fpn="wrapper";function Dpn(e){let{components:n,...t}=e;return(0,s.yg)(fpn,(0,p.A)({},gpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Dpn.isMDXComponent=!0;const Mpn={toc:[]},Xpn="wrapper";function _pn(e){let{components:n,...t}=e;return(0,s.yg)(Xpn,(0,p.A)({},Mpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}_pn.isMDXComponent=!0;const wpn={toc:[]},Tpn="wrapper";function Cpn(e){let{components:n,...t}=e;return(0,s.yg)(Tpn,(0,p.A)({},wpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Cpn.isMDXComponent=!0;const xpn={toc:[]},Apn="wrapper";function vpn(e){let{components:n,...t}=e;return(0,s.yg)(Apn,(0,p.A)({},xpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}vpn.isMDXComponent=!0;const Lpn={toc:[]},bpn="wrapper";function Npn(e){let{components:n,...t}=e;return(0,s.yg)(bpn,(0,p.A)({},Lpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Npn.isMDXComponent=!0;const kpn={toc:[]},zpn="wrapper";function Ppn(e){let{components:n,...t}=e;return(0,s.yg)(zpn,(0,p.A)({},kpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ppn.isMDXComponent=!0;const Ipn={toc:[]},Rpn="wrapper";function Wpn(e){let{components:n,...t}=e;return(0,s.yg)(Rpn,(0,p.A)({},Ipn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Wpn.isMDXComponent=!0;const Spn={toc:[]},Bpn="wrapper";function Gpn(e){let{components:n,...t}=e;return(0,s.yg)(Bpn,(0,p.A)({},Spn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Gpn.isMDXComponent=!0;const Epn={toc:[]},Opn="wrapper";function Upn(e){let{components:n,...t}=e;return(0,s.yg)(Opn,(0,p.A)({},Epn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Upn.isMDXComponent=!0;const Fpn={toc:[]},Vpn="wrapper";function qpn(e){let{components:n,...t}=e;return(0,s.yg)(Vpn,(0,p.A)({},Fpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}qpn.isMDXComponent=!0;const jpn={toc:[]},Hpn="wrapper";function Ypn(e){let{components:n,...t}=e;return(0,s.yg)(Hpn,(0,p.A)({},jpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Ypn.isMDXComponent=!0;const Qpn={toc:[]},$pn="wrapper";function Kpn(e){let{components:n,...t}=e;return(0,s.yg)($pn,(0,p.A)({},Qpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]},Zpn="wrapper";function ern(e){let{components:n,...t}=e;return(0,s.yg)(Zpn,(0,p.A)({},Jpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}ern.isMDXComponent=!0;const nrn={toc:[]},trn="wrapper";function orn(e){let{components:n,...t}=e;return(0,s.yg)(trn,(0,p.A)({},nrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}orn.isMDXComponent=!0;const prn={toc:[]},rrn="wrapper";function srn(e){let{components:n,...t}=e;return(0,s.yg)(rrn,(0,p.A)({},prn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}srn.isMDXComponent=!0;const crn={toc:[]},arn="wrapper";function irn(e){let{components:n,...t}=e;return(0,s.yg)(arn,(0,p.A)({},crn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}irn.isMDXComponent=!0;const lrn={toc:[]},urn="wrapper";function mrn(e){let{components:n,...t}=e;return(0,s.yg)(urn,(0,p.A)({},lrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}mrn.isMDXComponent=!0;const yrn={toc:[]},drn="wrapper";function hrn(e){let{components:n,...t}=e;return(0,s.yg)(drn,(0,p.A)({},yrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hrn.isMDXComponent=!0;const grn={toc:[]},frn="wrapper";function Drn(e){let{components:n,...t}=e;return(0,s.yg)(frn,(0,p.A)({},grn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Drn.isMDXComponent=!0;const Mrn={toc:[]},Xrn="wrapper";function _rn(e){let{components:n,...t}=e;return(0,s.yg)(Xrn,(0,p.A)({},Mrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_rn.isMDXComponent=!0;const wrn={toc:[]},Trn="wrapper";function Crn(e){let{components:n,...t}=e;return(0,s.yg)(Trn,(0,p.A)({},wrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Crn.isMDXComponent=!0;const xrn={toc:[]},Arn="wrapper";function vrn(e){let{components:n,...t}=e;return(0,s.yg)(Arn,(0,p.A)({},xrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vrn.isMDXComponent=!0;const Lrn={toc:[]},brn="wrapper";function Nrn(e){let{components:n,...t}=e;return(0,s.yg)(brn,(0,p.A)({},Lrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Nrn.isMDXComponent=!0;const krn={toc:[]},zrn="wrapper";function Prn(e){let{components:n,...t}=e;return(0,s.yg)(zrn,(0,p.A)({},krn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Prn.isMDXComponent=!0;const Irn={toc:[]},Rrn="wrapper";function Wrn(e){let{components:n,...t}=e;return(0,s.yg)(Rrn,(0,p.A)({},Irn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wrn.isMDXComponent=!0;const Srn={toc:[]},Brn="wrapper";function Grn(e){let{components:n,...t}=e;return(0,s.yg)(Brn,(0,p.A)({},Srn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Grn.isMDXComponent=!0;const Ern={toc:[]},Orn="wrapper";function Urn(e){let{components:n,...t}=e;return(0,s.yg)(Orn,(0,p.A)({},Ern,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Urn.isMDXComponent=!0;const Frn={toc:[]},Vrn="wrapper";function qrn(e){let{components:n,...t}=e;return(0,s.yg)(Vrn,(0,p.A)({},Frn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qrn.isMDXComponent=!0;const jrn={toc:[]},Hrn="wrapper";function Yrn(e){let{components:n,...t}=e;return(0,s.yg)(Hrn,(0,p.A)({},jrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Yrn.isMDXComponent=!0;const Qrn={toc:[]},$rn="wrapper";function Krn(e){let{components:n,...t}=e;return(0,s.yg)($rn,(0,p.A)({},Qrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Krn.isMDXComponent=!0;const Jrn={toc:[]},Zrn="wrapper";function esn(e){let{components:n,...t}=e;return(0,s.yg)(Zrn,(0,p.A)({},Jrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}esn.isMDXComponent=!0;const nsn={toc:[]},tsn="wrapper";function osn(e){let{components:n,...t}=e;return(0,s.yg)(tsn,(0,p.A)({},nsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}osn.isMDXComponent=!0;const psn={toc:[]},rsn="wrapper";function ssn(e){let{components:n,...t}=e;return(0,s.yg)(rsn,(0,p.A)({},psn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}ssn.isMDXComponent=!0;const csn={toc:[]},asn="wrapper";function isn(e){let{components:n,...t}=e;return(0,s.yg)(asn,(0,p.A)({},csn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}isn.isMDXComponent=!0;const lsn={toc:[]},usn="wrapper";function msn(e){let{components:n,...t}=e;return(0,s.yg)(usn,(0,p.A)({},lsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}msn.isMDXComponent=!0;const ysn={toc:[]},dsn="wrapper";function hsn(e){let{components:n,...t}=e;return(0,s.yg)(dsn,(0,p.A)({},ysn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}hsn.isMDXComponent=!0;const gsn={toc:[]},fsn="wrapper";function Dsn(e){let{components:n,...t}=e;return(0,s.yg)(fsn,(0,p.A)({},gsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Dsn.isMDXComponent=!0;const Msn={toc:[]},Xsn="wrapper";function _sn(e){let{components:n,...t}=e;return(0,s.yg)(Xsn,(0,p.A)({},Msn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}_sn.isMDXComponent=!0;const wsn={toc:[]},Tsn="wrapper";function Csn(e){let{components:n,...t}=e;return(0,s.yg)(Tsn,(0,p.A)({},wsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Csn.isMDXComponent=!0;const xsn={toc:[]},Asn="wrapper";function vsn(e){let{components:n,...t}=e;return(0,s.yg)(Asn,(0,p.A)({},xsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}vsn.isMDXComponent=!0;const Lsn={toc:[]},bsn="wrapper";function Nsn(e){let{components:n,...t}=e;return(0,s.yg)(bsn,(0,p.A)({},Lsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Nsn.isMDXComponent=!0;const ksn={toc:[]},zsn="wrapper";function Psn(e){let{components:n,...t}=e;return(0,s.yg)(zsn,(0,p.A)({},ksn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Psn.isMDXComponent=!0;const Isn={toc:[]},Rsn="wrapper";function Wsn(e){let{components:n,...t}=e;return(0,s.yg)(Rsn,(0,p.A)({},Isn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wsn.isMDXComponent=!0;const Ssn={toc:[]},Bsn="wrapper";function Gsn(e){let{components:n,...t}=e;return(0,s.yg)(Bsn,(0,p.A)({},Ssn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Gsn.isMDXComponent=!0;const Esn={toc:[]},Osn="wrapper";function Usn(e){let{components:n,...t}=e;return(0,s.yg)(Osn,(0,p.A)({},Esn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Usn.isMDXComponent=!0;const Fsn={toc:[]},Vsn="wrapper";function qsn(e){let{components:n,...t}=e;return(0,s.yg)(Vsn,(0,p.A)({},Fsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}qsn.isMDXComponent=!0;const jsn={toc:[]},Hsn="wrapper";function Ysn(e){let{components:n,...t}=e;return(0,s.yg)(Hsn,(0,p.A)({},jsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Ysn.isMDXComponent=!0;const Qsn={toc:[]},$sn="wrapper";function Ksn(e){let{components:n,...t}=e;return(0,s.yg)($sn,(0,p.A)({},Qsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Ksn.isMDXComponent=!0;const Jsn={toc:[]},Zsn="wrapper";function ecn(e){let{components:n,...t}=e;return(0,s.yg)(Zsn,(0,p.A)({},Jsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}ecn.isMDXComponent=!0;const ncn={toc:[]},tcn="wrapper";function ocn(e){let{components:n,...t}=e;return(0,s.yg)(tcn,(0,p.A)({},ncn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}ocn.isMDXComponent=!0;const pcn={toc:[]},rcn="wrapper";function scn(e){let{components:n,...t}=e;return(0,s.yg)(rcn,(0,p.A)({},pcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}scn.isMDXComponent=!0;const ccn={toc:[]},acn="wrapper";function icn(e){let{components:n,...t}=e;return(0,s.yg)(acn,(0,p.A)({},ccn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}icn.isMDXComponent=!0;const lcn={toc:[]},ucn="wrapper";function mcn(e){let{components:n,...t}=e;return(0,s.yg)(ucn,(0,p.A)({},lcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mcn.isMDXComponent=!0;const ycn={toc:[]},dcn="wrapper";function hcn(e){let{components:n,...t}=e;return(0,s.yg)(dcn,(0,p.A)({},ycn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}hcn.isMDXComponent=!0;const gcn={toc:[]},fcn="wrapper";function Dcn(e){let{components:n,...t}=e;return(0,s.yg)(fcn,(0,p.A)({},gcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Dcn.isMDXComponent=!0;const Mcn={toc:[]},Xcn="wrapper";function _cn(e){let{components:n,...t}=e;return(0,s.yg)(Xcn,(0,p.A)({},Mcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_cn.isMDXComponent=!0;const wcn={toc:[]},Tcn="wrapper";function Ccn(e){let{components:n,...t}=e;return(0,s.yg)(Tcn,(0,p.A)({},wcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ccn.isMDXComponent=!0;const xcn={toc:[]},Acn="wrapper";function vcn(e){let{components:n,...t}=e;return(0,s.yg)(Acn,(0,p.A)({},xcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}vcn.isMDXComponent=!0;const Lcn={toc:[]},bcn="wrapper";function Ncn(e){let{components:n,...t}=e;return(0,s.yg)(bcn,(0,p.A)({},Lcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Ncn.isMDXComponent=!0;const kcn={toc:[]},zcn="wrapper";function Pcn(e){let{components:n,...t}=e;return(0,s.yg)(zcn,(0,p.A)({},kcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Pcn.isMDXComponent=!0;const Icn={toc:[]},Rcn="wrapper";function Wcn(e){let{components:n,...t}=e;return(0,s.yg)(Rcn,(0,p.A)({},Icn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Wcn.isMDXComponent=!0;const Scn={toc:[]},Bcn="wrapper";function Gcn(e){let{components:n,...t}=e;return(0,s.yg)(Bcn,(0,p.A)({},Scn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Gcn.isMDXComponent=!0;const Ecn={toc:[]},Ocn="wrapper";function Ucn(e){let{components:n,...t}=e;return(0,s.yg)(Ocn,(0,p.A)({},Ecn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ucn.isMDXComponent=!0;const Fcn={toc:[]},Vcn="wrapper";function qcn(e){let{components:n,...t}=e;return(0,s.yg)(Vcn,(0,p.A)({},Fcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}qcn.isMDXComponent=!0;const jcn={toc:[]},Hcn="wrapper";function Ycn(e){let{components:n,...t}=e;return(0,s.yg)(Hcn,(0,p.A)({},jcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Ycn.isMDXComponent=!0;const Qcn={toc:[]},$cn="wrapper";function Kcn(e){let{components:n,...t}=e;return(0,s.yg)($cn,(0,p.A)({},Qcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Kcn.isMDXComponent=!0;const Jcn={toc:[]},Zcn="wrapper";function ean(e){let{components:n,...t}=e;return(0,s.yg)(Zcn,(0,p.A)({},Jcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}ean.isMDXComponent=!0;const nan={toc:[]},tan="wrapper";function oan(e){let{components:n,...t}=e;return(0,s.yg)(tan,(0,p.A)({},nan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}oan.isMDXComponent=!0;const pan={toc:[]},ran="wrapper";function san(e){let{components:n,...t}=e;return(0,s.yg)(ran,(0,p.A)({},pan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}san.isMDXComponent=!0;const can={toc:[]},aan="wrapper";function ian(e){let{components:n,...t}=e;return(0,s.yg)(aan,(0,p.A)({},can,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ian.isMDXComponent=!0;const lan={toc:[]},uan="wrapper";function man(e){let{components:n,...t}=e;return(0,s.yg)(uan,(0,p.A)({},lan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}man.isMDXComponent=!0;const yan={toc:[]},dan="wrapper";function han(e){let{components:n,...t}=e;return(0,s.yg)(dan,(0,p.A)({},yan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}han.isMDXComponent=!0;const gan={toc:[]},fan="wrapper";function Dan(e){let{components:n,...t}=e;return(0,s.yg)(fan,(0,p.A)({},gan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Dan.isMDXComponent=!0;const Man={toc:[]},Xan="wrapper";function _an(e){let{components:n,...t}=e;return(0,s.yg)(Xan,(0,p.A)({},Man,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}_an.isMDXComponent=!0;const wan={toc:[]},Tan="wrapper";function Can(e){let{components:n,...t}=e;return(0,s.yg)(Tan,(0,p.A)({},wan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Can.isMDXComponent=!0;const xan={toc:[]},Aan="wrapper";function van(e){let{components:n,...t}=e;return(0,s.yg)(Aan,(0,p.A)({},xan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}van.isMDXComponent=!0;const Lan={toc:[]},ban="wrapper";function Nan(e){let{components:n,...t}=e;return(0,s.yg)(ban,(0,p.A)({},Lan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Nan.isMDXComponent=!0;const kan={toc:[]},zan="wrapper";function Pan(e){let{components:n,...t}=e;return(0,s.yg)(zan,(0,p.A)({},kan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Pan.isMDXComponent=!0;const Ian={toc:[]},Ran="wrapper";function Wan(e){let{components:n,...t}=e;return(0,s.yg)(Ran,(0,p.A)({},Ian,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wan.isMDXComponent=!0;const San={toc:[]},Ban="wrapper";function Gan(e){let{components:n,...t}=e;return(0,s.yg)(Ban,(0,p.A)({},San,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Gan.isMDXComponent=!0;const Ean={toc:[]},Oan="wrapper";function Uan(e){let{components:n,...t}=e;return(0,s.yg)(Oan,(0,p.A)({},Ean,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Uan.isMDXComponent=!0;const Fan={toc:[]},Van="wrapper";function qan(e){let{components:n,...t}=e;return(0,s.yg)(Van,(0,p.A)({},Fan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}qan.isMDXComponent=!0;const jan={toc:[]},Han="wrapper";function Yan(e){let{components:n,...t}=e;return(0,s.yg)(Han,(0,p.A)({},jan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Yan.isMDXComponent=!0;const Qan={toc:[]},$an="wrapper";function Kan(e){let{components:n,...t}=e;return(0,s.yg)($an,(0,p.A)({},Qan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Kan.isMDXComponent=!0;const Jan={toc:[]},Zan="wrapper";function ein(e){let{components:n,...t}=e;return(0,s.yg)(Zan,(0,p.A)({},Jan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}ein.isMDXComponent=!0;const nin={toc:[]},tin="wrapper";function oin(e){let{components:n,...t}=e;return(0,s.yg)(tin,(0,p.A)({},nin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}oin.isMDXComponent=!0;const pin={toc:[]},rin="wrapper";function sin(e){let{components:n,...t}=e;return(0,s.yg)(rin,(0,p.A)({},pin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sin.isMDXComponent=!0;const cin={toc:[]},ain="wrapper";function iin(e){let{components:n,...t}=e;return(0,s.yg)(ain,(0,p.A)({},cin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}iin.isMDXComponent=!0;const lin={toc:[]},uin="wrapper";function min(e){let{components:n,...t}=e;return(0,s.yg)(uin,(0,p.A)({},lin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}min.isMDXComponent=!0;const yin={toc:[]},din="wrapper";function hin(e){let{components:n,...t}=e;return(0,s.yg)(din,(0,p.A)({},yin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}hin.isMDXComponent=!0;const gin={toc:[]},fin="wrapper";function Din(e){let{components:n,...t}=e;return(0,s.yg)(fin,(0,p.A)({},gin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Din.isMDXComponent=!0;const Min={toc:[]},Xin="wrapper";function _in(e){let{components:n,...t}=e;return(0,s.yg)(Xin,(0,p.A)({},Min,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}_in.isMDXComponent=!0;const win={toc:[]},Tin="wrapper";function Cin(e){let{components:n,...t}=e;return(0,s.yg)(Tin,(0,p.A)({},win,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Cin.isMDXComponent=!0;const xin={toc:[]},Ain="wrapper";function vin(e){let{components:n,...t}=e;return(0,s.yg)(Ain,(0,p.A)({},xin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}vin.isMDXComponent=!0;const Lin={toc:[]},bin="wrapper";function Nin(e){let{components:n,...t}=e;return(0,s.yg)(bin,(0,p.A)({},Lin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Nin.isMDXComponent=!0;const kin={toc:[]},zin="wrapper";function Pin(e){let{components:n,...t}=e;return(0,s.yg)(zin,(0,p.A)({},kin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pin.isMDXComponent=!0;const Iin={toc:[]},Rin="wrapper";function Win(e){let{components:n,...t}=e;return(0,s.yg)(Rin,(0,p.A)({},Iin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Win.isMDXComponent=!0;const Sin={toc:[]},Bin="wrapper";function Gin(e){let{components:n,...t}=e;return(0,s.yg)(Bin,(0,p.A)({},Sin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Gin.isMDXComponent=!0;const Ein={toc:[]},Oin="wrapper";function Uin(e){let{components:n,...t}=e;return(0,s.yg)(Oin,(0,p.A)({},Ein,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Uin.isMDXComponent=!0;const Fin={toc:[]},Vin="wrapper";function qin(e){let{components:n,...t}=e;return(0,s.yg)(Vin,(0,p.A)({},Fin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}qin.isMDXComponent=!0;const jin={toc:[]},Hin="wrapper";function Yin(e){let{components:n,...t}=e;return(0,s.yg)(Hin,(0,p.A)({},jin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Yin.isMDXComponent=!0;const Qin={toc:[]},$in="wrapper";function Kin(e){let{components:n,...t}=e;return(0,s.yg)($in,(0,p.A)({},Qin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Kin.isMDXComponent=!0;const Jin={toc:[]},Zin="wrapper";function eln(e){let{components:n,...t}=e;return(0,s.yg)(Zin,(0,p.A)({},Jin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}eln.isMDXComponent=!0;const nln={toc:[]},tln="wrapper";function oln(e){let{components:n,...t}=e;return(0,s.yg)(tln,(0,p.A)({},nln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}oln.isMDXComponent=!0;const pln={toc:[]},rln="wrapper";function sln(e){let{components:n,...t}=e;return(0,s.yg)(rln,(0,p.A)({},pln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}sln.isMDXComponent=!0;const cln={toc:[]},aln="wrapper";function iln(e){let{components:n,...t}=e;return(0,s.yg)(aln,(0,p.A)({},cln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}iln.isMDXComponent=!0;const lln={toc:[]},uln="wrapper";function mln(e){let{components:n,...t}=e;return(0,s.yg)(uln,(0,p.A)({},lln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}mln.isMDXComponent=!0;const yln={toc:[]},dln="wrapper";function hln(e){let{components:n,...t}=e;return(0,s.yg)(dln,(0,p.A)({},yln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}hln.isMDXComponent=!0;const gln={toc:[]},fln="wrapper";function Dln(e){let{components:n,...t}=e;return(0,s.yg)(fln,(0,p.A)({},gln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Dln.isMDXComponent=!0;const Mln={toc:[]},Xln="wrapper";function _ln(e){let{components:n,...t}=e;return(0,s.yg)(Xln,(0,p.A)({},Mln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}_ln.isMDXComponent=!0;const wln={toc:[]},Tln="wrapper";function Cln(e){let{components:n,...t}=e;return(0,s.yg)(Tln,(0,p.A)({},wln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Cln.isMDXComponent=!0;const xln={toc:[]},Aln="wrapper";function vln(e){let{components:n,...t}=e;return(0,s.yg)(Aln,(0,p.A)({},xln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}vln.isMDXComponent=!0;const Lln={toc:[]},bln="wrapper";function Nln(e){let{components:n,...t}=e;return(0,s.yg)(bln,(0,p.A)({},Lln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Nln.isMDXComponent=!0;const kln={toc:[]},zln="wrapper";function Pln(e){let{components:n,...t}=e;return(0,s.yg)(zln,(0,p.A)({},kln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Pln.isMDXComponent=!0;const Iln={toc:[]},Rln="wrapper";function Wln(e){let{components:n,...t}=e;return(0,s.yg)(Rln,(0,p.A)({},Iln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Wln.isMDXComponent=!0;const Sln={toc:[]},Bln="wrapper";function Gln(e){let{components:n,...t}=e;return(0,s.yg)(Bln,(0,p.A)({},Sln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Gln.isMDXComponent=!0;const Eln={toc:[]},Oln="wrapper";function Uln(e){let{components:n,...t}=e;return(0,s.yg)(Oln,(0,p.A)({},Eln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Uln.isMDXComponent=!0;const Fln={toc:[]},Vln="wrapper";function qln(e){let{components:n,...t}=e;return(0,s.yg)(Vln,(0,p.A)({},Fln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qln.isMDXComponent=!0;const jln={toc:[]},Hln="wrapper";function Yln(e){let{components:n,...t}=e;return(0,s.yg)(Hln,(0,p.A)({},jln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Yln.isMDXComponent=!0;const Qln={toc:[]},$ln="wrapper";function Kln(e){let{components:n,...t}=e;return(0,s.yg)($ln,(0,p.A)({},Qln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Kln.isMDXComponent=!0;const Jln={toc:[]},Zln="wrapper";function eun(e){let{components:n,...t}=e;return(0,s.yg)(Zln,(0,p.A)({},Jln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}eun.isMDXComponent=!0;const nun={toc:[]},tun="wrapper";function oun(e){let{components:n,...t}=e;return(0,s.yg)(tun,(0,p.A)({},nun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}oun.isMDXComponent=!0;const pun={toc:[]},run="wrapper";function sun(e){let{components:n,...t}=e;return(0,s.yg)(run,(0,p.A)({},pun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}sun.isMDXComponent=!0;const cun={toc:[]},aun="wrapper";function iun(e){let{components:n,...t}=e;return(0,s.yg)(aun,(0,p.A)({},cun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}iun.isMDXComponent=!0;const lun={toc:[]},uun="wrapper";function mun(e){let{components:n,...t}=e;return(0,s.yg)(uun,(0,p.A)({},lun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}mun.isMDXComponent=!0;const yun={toc:[]},dun="wrapper";function hun(e){let{components:n,...t}=e;return(0,s.yg)(dun,(0,p.A)({},yun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}hun.isMDXComponent=!0;const gun={toc:[]},fun="wrapper";function Dun(e){let{components:n,...t}=e;return(0,s.yg)(fun,(0,p.A)({},gun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Dun.isMDXComponent=!0;const Mun={toc:[]},Xun="wrapper";function _un(e){let{components:n,...t}=e;return(0,s.yg)(Xun,(0,p.A)({},Mun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}_un.isMDXComponent=!0;const wun={toc:[]},Tun="wrapper";function Cun(e){let{components:n,...t}=e;return(0,s.yg)(Tun,(0,p.A)({},wun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Cun.isMDXComponent=!0;const xun={toc:[]},Aun="wrapper";function vun(e){let{components:n,...t}=e;return(0,s.yg)(Aun,(0,p.A)({},xun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}vun.isMDXComponent=!0;const Lun={toc:[]},bun="wrapper";function Nun(e){let{components:n,...t}=e;return(0,s.yg)(bun,(0,p.A)({},Lun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Nun.isMDXComponent=!0;const kun={toc:[]},zun="wrapper";function Pun(e){let{components:n,...t}=e;return(0,s.yg)(zun,(0,p.A)({},kun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Pun.isMDXComponent=!0;const Iun={toc:[]},Run="wrapper";function Wun(e){let{components:n,...t}=e;return(0,s.yg)(Run,(0,p.A)({},Iun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Wun.isMDXComponent=!0;const Sun={toc:[]},Bun="wrapper";function Gun(e){let{components:n,...t}=e;return(0,s.yg)(Bun,(0,p.A)({},Sun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Gun.isMDXComponent=!0;const Eun={toc:[]},Oun="wrapper";function Uun(e){let{components:n,...t}=e;return(0,s.yg)(Oun,(0,p.A)({},Eun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Uun.isMDXComponent=!0;const Fun={toc:[]},Vun="wrapper";function qun(e){let{components:n,...t}=e;return(0,s.yg)(Vun,(0,p.A)({},Fun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}qun.isMDXComponent=!0;const jun={toc:[]},Hun="wrapper";function Yun(e){let{components:n,...t}=e;return(0,s.yg)(Hun,(0,p.A)({},jun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Yun.isMDXComponent=!0;const Qun={toc:[]},$un="wrapper";function Kun(e){let{components:n,...t}=e;return(0,s.yg)($un,(0,p.A)({},Qun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Kun.isMDXComponent=!0;const Jun={toc:[]},Zun="wrapper";function emn(e){let{components:n,...t}=e;return(0,s.yg)(Zun,(0,p.A)({},Jun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}emn.isMDXComponent=!0;const nmn={toc:[]},tmn="wrapper";function omn(e){let{components:n,...t}=e;return(0,s.yg)(tmn,(0,p.A)({},nmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}omn.isMDXComponent=!0;const pmn={toc:[]},rmn="wrapper";function smn(e){let{components:n,...t}=e;return(0,s.yg)(rmn,(0,p.A)({},pmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}smn.isMDXComponent=!0;const cmn={toc:[]},amn="wrapper";function imn(e){let{components:n,...t}=e;return(0,s.yg)(amn,(0,p.A)({},cmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}imn.isMDXComponent=!0;const lmn={toc:[]},umn="wrapper";function mmn(e){let{components:n,...t}=e;return(0,s.yg)(umn,(0,p.A)({},lmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide the color in one of the following formats:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"named color like ",(0,s.yg)("inlineCode",{parentName:"li"},"red"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.yg)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.yg)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}mmn.isMDXComponent=!0;const ymn={toc:[]},dmn="wrapper";function hmn(e){let{components:n,...t}=e;return(0,s.yg)(dmn,(0,p.A)({},ymn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"'white'"))}hmn.isMDXComponent=!0;const gmn={toc:[]},fmn="wrapper";function Dmn(e){let{components:n,...t}=e;return(0,s.yg)(fmn,(0,p.A)({},gmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the icon"))}Dmn.isMDXComponent=!0;const Mmn={toc:[]},Xmn="wrapper";function _mn(e){let{components:n,...t}=e;return(0,s.yg)(Xmn,(0,p.A)({},Mmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}_mn.isMDXComponent=!0;const wmn={toc:[]},Tmn="wrapper";function Cmn(e){let{components:n,...t}=e;return(0,s.yg)(Tmn,(0,p.A)({},wmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Cmn.isMDXComponent=!0;const xmn={toc:[]},Amn="wrapper";function vmn(e){let{components:n,...t}=e;return(0,s.yg)(Amn,(0,p.A)({},xmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}vmn.isMDXComponent=!0;const Lmn={toc:[]},bmn="wrapper";function Nmn(e){let{components:n,...t}=e;return(0,s.yg)(bmn,(0,p.A)({},Lmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nmn.isMDXComponent=!0;const kmn={toc:[]},zmn="wrapper";function Pmn(e){let{components:n,...t}=e;return(0,s.yg)(zmn,(0,p.A)({},kmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Pmn.isMDXComponent=!0;const Imn={toc:[]},Rmn="wrapper";function Wmn(e){let{components:n,...t}=e;return(0,s.yg)(Rmn,(0,p.A)({},Imn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wmn.isMDXComponent=!0;const Smn={toc:[]},Bmn="wrapper";function Gmn(e){let{components:n,...t}=e;return(0,s.yg)(Bmn,(0,p.A)({},Smn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Gmn.isMDXComponent=!0;const Emn={toc:[]},Omn="wrapper";function Umn(e){let{components:n,...t}=e;return(0,s.yg)(Omn,(0,p.A)({},Emn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Umn.isMDXComponent=!0;const Fmn={toc:[]},Vmn="wrapper";function qmn(e){let{components:n,...t}=e;return(0,s.yg)(Vmn,(0,p.A)({},Fmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}qmn.isMDXComponent=!0;const jmn={toc:[]},Hmn="wrapper";function Ymn(e){let{components:n,...t}=e;return(0,s.yg)(Hmn,(0,p.A)({},jmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can find identifiers on ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Ymn.isMDXComponent=!0;const Qmn={toc:[]},$mn="wrapper";function Kmn(e){let{components:n,...t}=e;return(0,s.yg)($mn,(0,p.A)({},Qmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The identifier of the icon."))}Kmn.isMDXComponent=!0;const Jmn={toc:[]},Zmn="wrapper";function eyn(e){let{components:n,...t}=e;return(0,s.yg)(Zmn,(0,p.A)({},Jmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}eyn.isMDXComponent=!0;const nyn={toc:[]},tyn="wrapper";function oyn(e){let{components:n,...t}=e;return(0,s.yg)(tyn,(0,p.A)({},nyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}oyn.isMDXComponent=!0;const pyn={toc:[]},ryn="wrapper";function syn(e){let{components:n,...t}=e;return(0,s.yg)(ryn,(0,p.A)({},pyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}syn.isMDXComponent=!0;const cyn={toc:[]},ayn="wrapper";function iyn(e){let{components:n,...t}=e;return(0,s.yg)(ayn,(0,p.A)({},cyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}iyn.isMDXComponent=!0;const lyn={toc:[]},uyn="wrapper";function myn(e){let{components:n,...t}=e;return(0,s.yg)(uyn,(0,p.A)({},lyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}myn.isMDXComponent=!0;const yyn={toc:[]},dyn="wrapper";function hyn(e){let{components:n,...t}=e;return(0,s.yg)(dyn,(0,p.A)({},yyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}hyn.isMDXComponent=!0;const gyn={toc:[]},fyn="wrapper";function Dyn(e){let{components:n,...t}=e;return(0,s.yg)(fyn,(0,p.A)({},gyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Dyn.isMDXComponent=!0;const Myn={toc:[]},Xyn="wrapper";function _yn(e){let{components:n,...t}=e;return(0,s.yg)(Xyn,(0,p.A)({},Myn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}_yn.isMDXComponent=!0;const wyn={toc:[]},Tyn="wrapper";function Cyn(e){let{components:n,...t}=e;return(0,s.yg)(Tyn,(0,p.A)({},wyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Cyn.isMDXComponent=!0;const xyn={toc:[]},Ayn="wrapper";function vyn(e){let{components:n,...t}=e;return(0,s.yg)(Ayn,(0,p.A)({},xyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}vyn.isMDXComponent=!0;const Lyn={toc:[]},byn="wrapper";function Nyn(e){let{components:n,...t}=e;return(0,s.yg)(byn,(0,p.A)({},Lyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Nyn.isMDXComponent=!0;const kyn={toc:[]},zyn="wrapper";function Pyn(e){let{components:n,...t}=e;return(0,s.yg)(zyn,(0,p.A)({},kyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Pyn.isMDXComponent=!0;const Iyn={toc:[]},Ryn="wrapper";function Wyn(e){let{components:n,...t}=e;return(0,s.yg)(Ryn,(0,p.A)({},Iyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Wyn.isMDXComponent=!0;const Syn={toc:[]},Byn="wrapper";function Gyn(e){let{components:n,...t}=e;return(0,s.yg)(Byn,(0,p.A)({},Syn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Gyn.isMDXComponent=!0;const Eyn={toc:[]},Oyn="wrapper";function Uyn(e){let{components:n,...t}=e;return(0,s.yg)(Oyn,(0,p.A)({},Eyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Uyn.isMDXComponent=!0;const Fyn={toc:[]},Vyn="wrapper";function qyn(e){let{components:n,...t}=e;return(0,s.yg)(Vyn,(0,p.A)({},Fyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}qyn.isMDXComponent=!0;const jyn={toc:[]},Hyn="wrapper";function Yyn(e){let{components:n,...t}=e;return(0,s.yg)(Hyn,(0,p.A)({},jyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Yyn.isMDXComponent=!0;const Qyn={toc:[]},$yn="wrapper";function Kyn(e){let{components:n,...t}=e;return(0,s.yg)($yn,(0,p.A)({},Qyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Kyn.isMDXComponent=!0;const Jyn={toc:[]},Zyn="wrapper";function edn(e){let{components:n,...t}=e;return(0,s.yg)(Zyn,(0,p.A)({},Jyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}edn.isMDXComponent=!0;const ndn={toc:[]},tdn="wrapper";function odn(e){let{components:n,...t}=e;return(0,s.yg)(tdn,(0,p.A)({},ndn,t,{components:n,mdxType:"MDXLayout"}))}odn.isMDXComponent=!0;const pdn={toc:[]},rdn="wrapper";function sdn(e){let{components:n,...t}=e;return(0,s.yg)(rdn,(0,p.A)({},pdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}sdn.isMDXComponent=!0;const cdn={toc:[]},adn="wrapper";function idn(e){let{components:n,...t}=e;return(0,s.yg)(adn,(0,p.A)({},cdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}idn.isMDXComponent=!0;const ldn={toc:[]},udn="wrapper";function mdn(e){let{components:n,...t}=e;return(0,s.yg)(udn,(0,p.A)({},ldn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}mdn.isMDXComponent=!0;const ydn={toc:[]},ddn="wrapper";function hdn(e){let{components:n,...t}=e;return(0,s.yg)(ddn,(0,p.A)({},ydn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}hdn.isMDXComponent=!0;const gdn={toc:[]},fdn="wrapper";function Ddn(e){let{components:n,...t}=e;return(0,s.yg)(fdn,(0,p.A)({},gdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Ddn.isMDXComponent=!0;const Mdn={toc:[]},Xdn="wrapper";function _dn(e){let{components:n,...t}=e;return(0,s.yg)(Xdn,(0,p.A)({},Mdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}_dn.isMDXComponent=!0;const wdn={toc:[]},Tdn="wrapper";function Cdn(e){let{components:n,...t}=e;return(0,s.yg)(Tdn,(0,p.A)({},wdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Cdn.isMDXComponent=!0;const xdn={toc:[]},Adn="wrapper";function vdn(e){let{components:n,...t}=e;return(0,s.yg)(Adn,(0,p.A)({},xdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}vdn.isMDXComponent=!0;const Ldn={toc:[]},bdn="wrapper";function Ndn(e){let{components:n,...t}=e;return(0,s.yg)(bdn,(0,p.A)({},Ldn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Ndn.isMDXComponent=!0;const kdn={toc:[]},zdn="wrapper";function Pdn(e){let{components:n,...t}=e;return(0,s.yg)(zdn,(0,p.A)({},kdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}Pdn.isMDXComponent=!0;const Idn={toc:[]},Rdn="wrapper";function Wdn(e){let{components:n,...t}=e;return(0,s.yg)(Rdn,(0,p.A)({},Idn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}Wdn.isMDXComponent=!0;const Sdn={toc:[]},Bdn="wrapper";function Gdn(e){let{components:n,...t}=e;return(0,s.yg)(Bdn,(0,p.A)({},Sdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Gdn.isMDXComponent=!0;const Edn={toc:[]},Odn="wrapper";function Udn(e){let{components:n,...t}=e;return(0,s.yg)(Odn,(0,p.A)({},Edn,t,{components:n,mdxType:"MDXLayout"}))}Udn.isMDXComponent=!0;const Fdn={toc:[]},Vdn="wrapper";function qdn(e){let{components:n,...t}=e;return(0,s.yg)(Vdn,(0,p.A)({},Fdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}qdn.isMDXComponent=!0;const jdn={toc:[]},Hdn="wrapper";function Ydn(e){let{components:n,...t}=e;return(0,s.yg)(Hdn,(0,p.A)({},jdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}Ydn.isMDXComponent=!0;const Qdn={toc:[]},$dn="wrapper";function Kdn(e){let{components:n,...t}=e;return(0,s.yg)($dn,(0,p.A)({},Qdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Kdn.isMDXComponent=!0;const Jdn={toc:[]},Zdn="wrapper";function ehn(e){let{components:n,...t}=e;return(0,s.yg)(Zdn,(0,p.A)({},Jdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}ehn.isMDXComponent=!0;const nhn={toc:[]},thn="wrapper";function ohn(e){let{components:n,...t}=e;return(0,s.yg)(thn,(0,p.A)({},nhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ohn.isMDXComponent=!0;const phn={toc:[]},rhn="wrapper";function shn(e){let{components:n,...t}=e;return(0,s.yg)(rhn,(0,p.A)({},phn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}shn.isMDXComponent=!0;const chn={toc:[]},ahn="wrapper";function ihn(e){let{components:n,...t}=e;return(0,s.yg)(ahn,(0,p.A)({},chn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ihn.isMDXComponent=!0;const lhn={toc:[]},uhn="wrapper";function mhn(e){let{components:n,...t}=e;return(0,s.yg)(uhn,(0,p.A)({},lhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}mhn.isMDXComponent=!0;const yhn={toc:[]},dhn="wrapper";function hhn(e){let{components:n,...t}=e;return(0,s.yg)(dhn,(0,p.A)({},yhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}hhn.isMDXComponent=!0;const ghn={toc:[]},fhn="wrapper";function Dhn(e){let{components:n,...t}=e;return(0,s.yg)(fhn,(0,p.A)({},ghn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Dhn.isMDXComponent=!0;const Mhn={toc:[]},Xhn="wrapper";function _hn(e){let{components:n,...t}=e;return(0,s.yg)(Xhn,(0,p.A)({},Mhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}_hn.isMDXComponent=!0;const whn={toc:[]},Thn="wrapper";function Chn(e){let{components:n,...t}=e;return(0,s.yg)(Thn,(0,p.A)({},whn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Chn.isMDXComponent=!0;const xhn={toc:[]},Ahn="wrapper";function vhn(e){let{components:n,...t}=e;return(0,s.yg)(Ahn,(0,p.A)({},xhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}vhn.isMDXComponent=!0;const Lhn={toc:[]},bhn="wrapper";function Nhn(e){let{components:n,...t}=e;return(0,s.yg)(bhn,(0,p.A)({},Lhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Nhn.isMDXComponent=!0;const khn={toc:[]},zhn="wrapper";function Phn(e){let{components:n,...t}=e;return(0,s.yg)(zhn,(0,p.A)({},khn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Phn.isMDXComponent=!0;const Ihn={toc:[]},Rhn="wrapper";function Whn(e){let{components:n,...t}=e;return(0,s.yg)(Rhn,(0,p.A)({},Ihn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Whn.isMDXComponent=!0;const Shn={toc:[]},Bhn="wrapper";function Ghn(e){let{components:n,...t}=e;return(0,s.yg)(Bhn,(0,p.A)({},Shn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Ghn.isMDXComponent=!0;const Ehn={toc:[]},Ohn="wrapper";function Uhn(e){let{components:n,...t}=e;return(0,s.yg)(Ohn,(0,p.A)({},Ehn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Uhn.isMDXComponent=!0;const Fhn={toc:[]},Vhn="wrapper";function qhn(e){let{components:n,...t}=e;return(0,s.yg)(Vhn,(0,p.A)({},Fhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qhn.isMDXComponent=!0;const jhn={toc:[]},Hhn="wrapper";function Yhn(e){let{components:n,...t}=e;return(0,s.yg)(Hhn,(0,p.A)({},jhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Yhn.isMDXComponent=!0;const Qhn={toc:[]},$hn="wrapper";function Khn(e){let{components:n,...t}=e;return(0,s.yg)($hn,(0,p.A)({},Qhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Khn.isMDXComponent=!0;const Jhn={toc:[]},Zhn="wrapper";function egn(e){let{components:n,...t}=e;return(0,s.yg)(Zhn,(0,p.A)({},Jhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}egn.isMDXComponent=!0;const ngn={toc:[]},tgn="wrapper";function ogn(e){let{components:n,...t}=e;return(0,s.yg)(tgn,(0,p.A)({},ngn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}ogn.isMDXComponent=!0;const pgn={toc:[]},rgn="wrapper";function sgn(e){let{components:n,...t}=e;return(0,s.yg)(rgn,(0,p.A)({},pgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}sgn.isMDXComponent=!0;const cgn={toc:[]},agn="wrapper";function ign(e){let{components:n,...t}=e;return(0,s.yg)(agn,(0,p.A)({},cgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}ign.isMDXComponent=!0;const lgn={toc:[]},ugn="wrapper";function mgn(e){let{components:n,...t}=e;return(0,s.yg)(ugn,(0,p.A)({},lgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}mgn.isMDXComponent=!0;const ygn={toc:[]},dgn="wrapper";function hgn(e){let{components:n,...t}=e;return(0,s.yg)(dgn,(0,p.A)({},ygn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}hgn.isMDXComponent=!0;const ggn={toc:[]},fgn="wrapper";function Dgn(e){let{components:n,...t}=e;return(0,s.yg)(fgn,(0,p.A)({},ggn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Dgn.isMDXComponent=!0;const Mgn={toc:[]},Xgn="wrapper";function _gn(e){let{components:n,...t}=e;return(0,s.yg)(Xgn,(0,p.A)({},Mgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}_gn.isMDXComponent=!0;const wgn={toc:[]},Tgn="wrapper";function Cgn(e){let{components:n,...t}=e;return(0,s.yg)(Tgn,(0,p.A)({},wgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Cgn.isMDXComponent=!0;const xgn={toc:[]},Agn="wrapper";function vgn(e){let{components:n,...t}=e;return(0,s.yg)(Agn,(0,p.A)({},xgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}vgn.isMDXComponent=!0;const Lgn={toc:[]},bgn="wrapper";function Ngn(e){let{components:n,...t}=e;return(0,s.yg)(bgn,(0,p.A)({},Lgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Ngn.isMDXComponent=!0;const kgn={toc:[]},zgn="wrapper";function Pgn(e){let{components:n,...t}=e;return(0,s.yg)(zgn,(0,p.A)({},kgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Pgn.isMDXComponent=!0;const Ign={toc:[]},Rgn="wrapper";function Wgn(e){let{components:n,...t}=e;return(0,s.yg)(Rgn,(0,p.A)({},Ign,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Wgn.isMDXComponent=!0;const Sgn={toc:[]},Bgn="wrapper";function Ggn(e){let{components:n,...t}=e;return(0,s.yg)(Bgn,(0,p.A)({},Sgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Ggn.isMDXComponent=!0;const Egn={toc:[]},Ogn="wrapper";function Ugn(e){let{components:n,...t}=e;return(0,s.yg)(Ogn,(0,p.A)({},Egn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Ugn.isMDXComponent=!0;const Fgn={toc:[]},Vgn="wrapper";function qgn(e){let{components:n,...t}=e;return(0,s.yg)(Vgn,(0,p.A)({},Fgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}qgn.isMDXComponent=!0;const jgn={toc:[]},Hgn="wrapper";function Ygn(e){let{components:n,...t}=e;return(0,s.yg)(Hgn,(0,p.A)({},jgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Ygn.isMDXComponent=!0;const Qgn={toc:[]},$gn="wrapper";function Kgn(e){let{components:n,...t}=e;return(0,s.yg)($gn,(0,p.A)({},Qgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Kgn.isMDXComponent=!0;const Jgn={toc:[]},Zgn="wrapper";function efn(e){let{components:n,...t}=e;return(0,s.yg)(Zgn,(0,p.A)({},Jgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}efn.isMDXComponent=!0;const nfn={toc:[]},tfn="wrapper";function ofn(e){let{components:n,...t}=e;return(0,s.yg)(tfn,(0,p.A)({},nfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}ofn.isMDXComponent=!0;const pfn={toc:[]},rfn="wrapper";function sfn(e){let{components:n,...t}=e;return(0,s.yg)(rfn,(0,p.A)({},pfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}sfn.isMDXComponent=!0;const cfn={toc:[]},afn="wrapper";function ifn(e){let{components:n,...t}=e;return(0,s.yg)(afn,(0,p.A)({},cfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ifn.isMDXComponent=!0;const lfn={toc:[]},ufn="wrapper";function mfn(e){let{components:n,...t}=e;return(0,s.yg)(ufn,(0,p.A)({},lfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}mfn.isMDXComponent=!0;const yfn={toc:[]},dfn="wrapper";function hfn(e){let{components:n,...t}=e;return(0,s.yg)(dfn,(0,p.A)({},yfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}hfn.isMDXComponent=!0;const gfn={toc:[]},ffn="wrapper";function Dfn(e){let{components:n,...t}=e;return(0,s.yg)(ffn,(0,p.A)({},gfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Dfn.isMDXComponent=!0;const Mfn={toc:[]},Xfn="wrapper";function _fn(e){let{components:n,...t}=e;return(0,s.yg)(Xfn,(0,p.A)({},Mfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}_fn.isMDXComponent=!0;const wfn={toc:[]},Tfn="wrapper";function Cfn(e){let{components:n,...t}=e;return(0,s.yg)(Tfn,(0,p.A)({},wfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Cfn.isMDXComponent=!0;const xfn={toc:[]},Afn="wrapper";function vfn(e){let{components:n,...t}=e;return(0,s.yg)(Afn,(0,p.A)({},xfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}vfn.isMDXComponent=!0;const Lfn={toc:[]},bfn="wrapper";function Nfn(e){let{components:n,...t}=e;return(0,s.yg)(bfn,(0,p.A)({},Lfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Nfn.isMDXComponent=!0;const kfn={toc:[]},zfn="wrapper";function Pfn(e){let{components:n,...t}=e;return(0,s.yg)(zfn,(0,p.A)({},kfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Pfn.isMDXComponent=!0;const Ifn={toc:[]},Rfn="wrapper";function Wfn(e){let{components:n,...t}=e;return(0,s.yg)(Rfn,(0,p.A)({},Ifn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Wfn.isMDXComponent=!0;const Sfn={toc:[]},Bfn="wrapper";function Gfn(e){let{components:n,...t}=e;return(0,s.yg)(Bfn,(0,p.A)({},Sfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Gfn.isMDXComponent=!0;const Efn={toc:[]},Ofn="wrapper";function Ufn(e){let{components:n,...t}=e;return(0,s.yg)(Ofn,(0,p.A)({},Efn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Ufn.isMDXComponent=!0;const Ffn={toc:[]},Vfn="wrapper";function qfn(e){let{components:n,...t}=e;return(0,s.yg)(Vfn,(0,p.A)({},Ffn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}qfn.isMDXComponent=!0;const jfn={toc:[]},Hfn="wrapper";function Yfn(e){let{components:n,...t}=e;return(0,s.yg)(Hfn,(0,p.A)({},jfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Yfn.isMDXComponent=!0;const Qfn={toc:[]},$fn="wrapper";function Kfn(e){let{components:n,...t}=e;return(0,s.yg)($fn,(0,p.A)({},Qfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]},Zfn="wrapper";function eDn(e){let{components:n,...t}=e;return(0,s.yg)(Zfn,(0,p.A)({},Jfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eDn.isMDXComponent=!0;const nDn={toc:[]},tDn="wrapper";function oDn(e){let{components:n,...t}=e;return(0,s.yg)(tDn,(0,p.A)({},nDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}oDn.isMDXComponent=!0;const pDn={toc:[]},rDn="wrapper";function sDn(e){let{components:n,...t}=e;return(0,s.yg)(rDn,(0,p.A)({},pDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sDn.isMDXComponent=!0;const cDn={toc:[]},aDn="wrapper";function iDn(e){let{components:n,...t}=e;return(0,s.yg)(aDn,(0,p.A)({},cDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}iDn.isMDXComponent=!0;const lDn={toc:[]},uDn="wrapper";function mDn(e){let{components:n,...t}=e;return(0,s.yg)(uDn,(0,p.A)({},lDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mDn.isMDXComponent=!0;const yDn={toc:[]},dDn="wrapper";function hDn(e){let{components:n,...t}=e;return(0,s.yg)(dDn,(0,p.A)({},yDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}hDn.isMDXComponent=!0;const gDn={toc:[]},fDn="wrapper";function DDn(e){let{components:n,...t}=e;return(0,s.yg)(fDn,(0,p.A)({},gDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DDn.isMDXComponent=!0;const MDn={toc:[]},XDn="wrapper";function _Dn(e){let{components:n,...t}=e;return(0,s.yg)(XDn,(0,p.A)({},MDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}_Dn.isMDXComponent=!0;const wDn={toc:[]},TDn="wrapper";function CDn(e){let{components:n,...t}=e;return(0,s.yg)(TDn,(0,p.A)({},wDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}CDn.isMDXComponent=!0;const xDn={toc:[]},ADn="wrapper";function vDn(e){let{components:n,...t}=e;return(0,s.yg)(ADn,(0,p.A)({},xDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}vDn.isMDXComponent=!0;const LDn={toc:[]},bDn="wrapper";function NDn(e){let{components:n,...t}=e;return(0,s.yg)(bDn,(0,p.A)({},LDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}NDn.isMDXComponent=!0;const kDn={toc:[]},zDn="wrapper";function PDn(e){let{components:n,...t}=e;return(0,s.yg)(zDn,(0,p.A)({},kDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}PDn.isMDXComponent=!0;const IDn={toc:[]},RDn="wrapper";function WDn(e){let{components:n,...t}=e;return(0,s.yg)(RDn,(0,p.A)({},IDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}WDn.isMDXComponent=!0;const SDn={toc:[]},BDn="wrapper";function GDn(e){let{components:n,...t}=e;return(0,s.yg)(BDn,(0,p.A)({},SDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}GDn.isMDXComponent=!0;const EDn={toc:[]},ODn="wrapper";function UDn(e){let{components:n,...t}=e;return(0,s.yg)(ODn,(0,p.A)({},EDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}UDn.isMDXComponent=!0;const FDn={toc:[]},VDn="wrapper";function qDn(e){let{components:n,...t}=e;return(0,s.yg)(VDn,(0,p.A)({},FDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}qDn.isMDXComponent=!0;const jDn={toc:[]},HDn="wrapper";function YDn(e){let{components:n,...t}=e;return(0,s.yg)(HDn,(0,p.A)({},jDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}YDn.isMDXComponent=!0;const QDn={toc:[]},$Dn="wrapper";function KDn(e){let{components:n,...t}=e;return(0,s.yg)($Dn,(0,p.A)({},QDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}KDn.isMDXComponent=!0;const JDn={toc:[]},ZDn="wrapper";function eMn(e){let{components:n,...t}=e;return(0,s.yg)(ZDn,(0,p.A)({},JDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}eMn.isMDXComponent=!0;const nMn={toc:[]},tMn="wrapper";function oMn(e){let{components:n,...t}=e;return(0,s.yg)(tMn,(0,p.A)({},nMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}oMn.isMDXComponent=!0;const pMn={toc:[]},rMn="wrapper";function sMn(e){let{components:n,...t}=e;return(0,s.yg)(rMn,(0,p.A)({},pMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}sMn.isMDXComponent=!0;const cMn={toc:[]},aMn="wrapper";function iMn(e){let{components:n,...t}=e;return(0,s.yg)(aMn,(0,p.A)({},cMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"overrides ",(0,s.yg)("inlineCode",{parentName:"p"},"Image.src")," getter"))}iMn.isMDXComponent=!0;const lMn={toc:[]},uMn="wrapper";function mMn(e){let{components:n,...t}=e;return(0,s.yg)(uMn,(0,p.A)({},lMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}mMn.isMDXComponent=!0;const yMn={toc:[]},dMn="wrapper";function hMn(e){let{components:n,...t}=e;return(0,s.yg)(dMn,(0,p.A)({},yMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}hMn.isMDXComponent=!0;const gMn={toc:[]},fMn="wrapper";function DMn(e){let{components:n,...t}=e;return(0,s.yg)(fMn,(0,p.A)({},gMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}DMn.isMDXComponent=!0;const MMn={toc:[]},XMn="wrapper";function _Mn(e){let{components:n,...t}=e;return(0,s.yg)(XMn,(0,p.A)({},MMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}_Mn.isMDXComponent=!0;const wMn={toc:[]},TMn="wrapper";function CMn(e){let{components:n,...t}=e;return(0,s.yg)(TMn,(0,p.A)({},wMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}CMn.isMDXComponent=!0;const xMn={toc:[]},AMn="wrapper";function vMn(e){let{components:n,...t}=e;return(0,s.yg)(AMn,(0,p.A)({},xMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}vMn.isMDXComponent=!0;const LMn={toc:[]},bMn="wrapper";function NMn(e){let{components:n,...t}=e;return(0,s.yg)(bMn,(0,p.A)({},LMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}NMn.isMDXComponent=!0;const kMn={toc:[]},zMn="wrapper";function PMn(e){let{components:n,...t}=e;return(0,s.yg)(zMn,(0,p.A)({},kMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}PMn.isMDXComponent=!0;const IMn={toc:[]},RMn="wrapper";function WMn(e){let{components:n,...t}=e;return(0,s.yg)(RMn,(0,p.A)({},IMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}WMn.isMDXComponent=!0;const SMn={toc:[]},BMn="wrapper";function GMn(e){let{components:n,...t}=e;return(0,s.yg)(BMn,(0,p.A)({},SMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}GMn.isMDXComponent=!0;const EMn={toc:[]},OMn="wrapper";function UMn(e){let{components:n,...t}=e;return(0,s.yg)(OMn,(0,p.A)({},EMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}UMn.isMDXComponent=!0;const FMn={toc:[]},VMn="wrapper";function qMn(e){let{components:n,...t}=e;return(0,s.yg)(VMn,(0,p.A)({},FMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}qMn.isMDXComponent=!0;const jMn={toc:[]},HMn="wrapper";function YMn(e){let{components:n,...t}=e;return(0,s.yg)(HMn,(0,p.A)({},jMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}YMn.isMDXComponent=!0;const QMn={toc:[]},$Mn="wrapper";function KMn(e){let{components:n,...t}=e;return(0,s.yg)($Mn,(0,p.A)({},QMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}KMn.isMDXComponent=!0;const JMn={toc:[]},ZMn="wrapper";function eXn(e){let{components:n,...t}=e;return(0,s.yg)(ZMn,(0,p.A)({},JMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}eXn.isMDXComponent=!0;const nXn={toc:[]},tXn="wrapper";function oXn(e){let{components:n,...t}=e;return(0,s.yg)(tXn,(0,p.A)({},nXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}oXn.isMDXComponent=!0;const pXn={toc:[]},rXn="wrapper";function sXn(e){let{components:n,...t}=e;return(0,s.yg)(rXn,(0,p.A)({},pXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}sXn.isMDXComponent=!0;const cXn={toc:[]},aXn="wrapper";function iXn(e){let{components:n,...t}=e;return(0,s.yg)(aXn,(0,p.A)({},cXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iXn.isMDXComponent=!0;const lXn={toc:[]},uXn="wrapper";function mXn(e){let{components:n,...t}=e;return(0,s.yg)(uXn,(0,p.A)({},lXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}mXn.isMDXComponent=!0;const yXn={toc:[]},dXn="wrapper";function hXn(e){let{components:n,...t}=e;return(0,s.yg)(dXn,(0,p.A)({},yXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}hXn.isMDXComponent=!0;const gXn={toc:[]},fXn="wrapper";function DXn(e){let{components:n,...t}=e;return(0,s.yg)(fXn,(0,p.A)({},gXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}DXn.isMDXComponent=!0;const MXn={toc:[]},XXn="wrapper";function _Xn(e){let{components:n,...t}=e;return(0,s.yg)(XXn,(0,p.A)({},MXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}_Xn.isMDXComponent=!0;const wXn={toc:[]},TXn="wrapper";function CXn(e){let{components:n,...t}=e;return(0,s.yg)(TXn,(0,p.A)({},wXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}CXn.isMDXComponent=!0;const xXn={toc:[]},AXn="wrapper";function vXn(e){let{components:n,...t}=e;return(0,s.yg)(AXn,(0,p.A)({},xXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vXn.isMDXComponent=!0;const LXn={toc:[]},bXn="wrapper";function NXn(e){let{components:n,...t}=e;return(0,s.yg)(bXn,(0,p.A)({},LXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}NXn.isMDXComponent=!0;const kXn={toc:[]},zXn="wrapper";function PXn(e){let{components:n,...t}=e;return(0,s.yg)(zXn,(0,p.A)({},kXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}PXn.isMDXComponent=!0;const IXn={toc:[]},RXn="wrapper";function WXn(e){let{components:n,...t}=e;return(0,s.yg)(RXn,(0,p.A)({},IXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}WXn.isMDXComponent=!0;const SXn={toc:[]},BXn="wrapper";function GXn(e){let{components:n,...t}=e;return(0,s.yg)(BXn,(0,p.A)({},SXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}GXn.isMDXComponent=!0;const EXn={toc:[]},OXn="wrapper";function UXn(e){let{components:n,...t}=e;return(0,s.yg)(OXn,(0,p.A)({},EXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}UXn.isMDXComponent=!0;const FXn={toc:[]},VXn="wrapper";function qXn(e){let{components:n,...t}=e;return(0,s.yg)(VXn,(0,p.A)({},FXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}qXn.isMDXComponent=!0;const jXn={toc:[]},HXn="wrapper";function YXn(e){let{components:n,...t}=e;return(0,s.yg)(HXn,(0,p.A)({},jXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}YXn.isMDXComponent=!0;const QXn={toc:[]},$Xn="wrapper";function KXn(e){let{components:n,...t}=e;return(0,s.yg)($Xn,(0,p.A)({},QXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}KXn.isMDXComponent=!0;const JXn={toc:[]},ZXn="wrapper";function e_n(e){let{components:n,...t}=e;return(0,s.yg)(ZXn,(0,p.A)({},JXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}e_n.isMDXComponent=!0;const n_n={toc:[]},t_n="wrapper";function o_n(e){let{components:n,...t}=e;return(0,s.yg)(t_n,(0,p.A)({},n_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}o_n.isMDXComponent=!0;const p_n={toc:[]},r_n="wrapper";function s_n(e){let{components:n,...t}=e;return(0,s.yg)(r_n,(0,p.A)({},p_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}s_n.isMDXComponent=!0;const c_n={toc:[]},a_n="wrapper";function i_n(e){let{components:n,...t}=e;return(0,s.yg)(a_n,(0,p.A)({},c_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}i_n.isMDXComponent=!0;const l_n={toc:[]},u_n="wrapper";function m_n(e){let{components:n,...t}=e;return(0,s.yg)(u_n,(0,p.A)({},l_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}m_n.isMDXComponent=!0;const y_n={toc:[]},d_n="wrapper";function h_n(e){let{components:n,...t}=e;return(0,s.yg)(d_n,(0,p.A)({},y_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}h_n.isMDXComponent=!0;const g_n={toc:[]},f_n="wrapper";function D_n(e){let{components:n,...t}=e;return(0,s.yg)(f_n,(0,p.A)({},g_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}D_n.isMDXComponent=!0;const M_n={toc:[]},X_n="wrapper";function __n(e){let{components:n,...t}=e;return(0,s.yg)(X_n,(0,p.A)({},M_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}__n.isMDXComponent=!0;const w_n={toc:[]},T_n="wrapper";function C_n(e){let{components:n,...t}=e;return(0,s.yg)(T_n,(0,p.A)({},w_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}C_n.isMDXComponent=!0;const x_n={toc:[]},A_n="wrapper";function v_n(e){let{components:n,...t}=e;return(0,s.yg)(A_n,(0,p.A)({},x_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}v_n.isMDXComponent=!0;const L_n={toc:[]},b_n="wrapper";function N_n(e){let{components:n,...t}=e;return(0,s.yg)(b_n,(0,p.A)({},L_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}N_n.isMDXComponent=!0;const k_n={toc:[]},z_n="wrapper";function P_n(e){let{components:n,...t}=e;return(0,s.yg)(z_n,(0,p.A)({},k_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}P_n.isMDXComponent=!0;const I_n={toc:[]},R_n="wrapper";function W_n(e){let{components:n,...t}=e;return(0,s.yg)(R_n,(0,p.A)({},I_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}W_n.isMDXComponent=!0;const S_n={toc:[]},B_n="wrapper";function G_n(e){let{components:n,...t}=e;return(0,s.yg)(B_n,(0,p.A)({},S_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}G_n.isMDXComponent=!0;const E_n={toc:[]},O_n="wrapper";function U_n(e){let{components:n,...t}=e;return(0,s.yg)(O_n,(0,p.A)({},E_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}U_n.isMDXComponent=!0;const F_n={toc:[]},V_n="wrapper";function q_n(e){let{components:n,...t}=e;return(0,s.yg)(V_n,(0,p.A)({},F_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}q_n.isMDXComponent=!0;const j_n={toc:[]},H_n="wrapper";function Y_n(e){let{components:n,...t}=e;return(0,s.yg)(H_n,(0,p.A)({},j_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Y_n.isMDXComponent=!0;const Q_n={toc:[]},$_n="wrapper";function K_n(e){let{components:n,...t}=e;return(0,s.yg)($_n,(0,p.A)({},Q_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}K_n.isMDXComponent=!0;const J_n={toc:[]},Z_n="wrapper";function ewn(e){let{components:n,...t}=e;return(0,s.yg)(Z_n,(0,p.A)({},J_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}ewn.isMDXComponent=!0;const nwn={toc:[]},twn="wrapper";function own(e){let{components:n,...t}=e;return(0,s.yg)(twn,(0,p.A)({},nwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}own.isMDXComponent=!0;const pwn={toc:[]},rwn="wrapper";function swn(e){let{components:n,...t}=e;return(0,s.yg)(rwn,(0,p.A)({},pwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}swn.isMDXComponent=!0;const cwn={toc:[]},awn="wrapper";function iwn(e){let{components:n,...t}=e;return(0,s.yg)(awn,(0,p.A)({},cwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}iwn.isMDXComponent=!0;const lwn={toc:[]},uwn="wrapper";function mwn(e){let{components:n,...t}=e;return(0,s.yg)(uwn,(0,p.A)({},lwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}mwn.isMDXComponent=!0;const ywn={toc:[]},dwn="wrapper";function hwn(e){let{components:n,...t}=e;return(0,s.yg)(dwn,(0,p.A)({},ywn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}hwn.isMDXComponent=!0;const gwn={toc:[]},fwn="wrapper";function Dwn(e){let{components:n,...t}=e;return(0,s.yg)(fwn,(0,p.A)({},gwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Dwn.isMDXComponent=!0;const Mwn={toc:[]},Xwn="wrapper";function _wn(e){let{components:n,...t}=e;return(0,s.yg)(Xwn,(0,p.A)({},Mwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}_wn.isMDXComponent=!0;const wwn={toc:[]},Twn="wrapper";function Cwn(e){let{components:n,...t}=e;return(0,s.yg)(Twn,(0,p.A)({},wwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Cwn.isMDXComponent=!0;const xwn={toc:[]},Awn="wrapper";function vwn(e){let{components:n,...t}=e;return(0,s.yg)(Awn,(0,p.A)({},xwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}vwn.isMDXComponent=!0;const Lwn={toc:[]},bwn="wrapper";function Nwn(e){let{components:n,...t}=e;return(0,s.yg)(bwn,(0,p.A)({},Lwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Nwn.isMDXComponent=!0;const kwn={toc:[]},zwn="wrapper";function Pwn(e){let{components:n,...t}=e;return(0,s.yg)(zwn,(0,p.A)({},kwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Pwn.isMDXComponent=!0;const Iwn={toc:[]},Rwn="wrapper";function Wwn(e){let{components:n,...t}=e;return(0,s.yg)(Rwn,(0,p.A)({},Iwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Wwn.isMDXComponent=!0;const Swn={toc:[]},Bwn="wrapper";function Gwn(e){let{components:n,...t}=e;return(0,s.yg)(Bwn,(0,p.A)({},Swn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Gwn.isMDXComponent=!0;const Ewn={toc:[]},Own="wrapper";function Uwn(e){let{components:n,...t}=e;return(0,s.yg)(Own,(0,p.A)({},Ewn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Uwn.isMDXComponent=!0;const Fwn={toc:[]},Vwn="wrapper";function qwn(e){let{components:n,...t}=e;return(0,s.yg)(Vwn,(0,p.A)({},Fwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}qwn.isMDXComponent=!0;const jwn={toc:[]},Hwn="wrapper";function Ywn(e){let{components:n,...t}=e;return(0,s.yg)(Hwn,(0,p.A)({},jwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Ywn.isMDXComponent=!0;const Qwn={toc:[]},$wn="wrapper";function Kwn(e){let{components:n,...t}=e;return(0,s.yg)($wn,(0,p.A)({},Qwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]},Zwn="wrapper";function eTn(e){let{components:n,...t}=e;return(0,s.yg)(Zwn,(0,p.A)({},Jwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}eTn.isMDXComponent=!0;const nTn={toc:[]},tTn="wrapper";function oTn(e){let{components:n,...t}=e;return(0,s.yg)(tTn,(0,p.A)({},nTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}oTn.isMDXComponent=!0;const pTn={toc:[]},rTn="wrapper";function sTn(e){let{components:n,...t}=e;return(0,s.yg)(rTn,(0,p.A)({},pTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}sTn.isMDXComponent=!0;const cTn={toc:[]},aTn="wrapper";function iTn(e){let{components:n,...t}=e;return(0,s.yg)(aTn,(0,p.A)({},cTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}iTn.isMDXComponent=!0;const lTn={toc:[]},uTn="wrapper";function mTn(e){let{components:n,...t}=e;return(0,s.yg)(uTn,(0,p.A)({},lTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}mTn.isMDXComponent=!0;const yTn={toc:[]},dTn="wrapper";function hTn(e){let{components:n,...t}=e;return(0,s.yg)(dTn,(0,p.A)({},yTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}hTn.isMDXComponent=!0;const gTn={toc:[]},fTn="wrapper";function DTn(e){let{components:n,...t}=e;return(0,s.yg)(fTn,(0,p.A)({},gTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}DTn.isMDXComponent=!0;const MTn={toc:[]},XTn="wrapper";function _Tn(e){let{components:n,...t}=e;return(0,s.yg)(XTn,(0,p.A)({},MTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}_Tn.isMDXComponent=!0;const wTn={toc:[]},TTn="wrapper";function CTn(e){let{components:n,...t}=e;return(0,s.yg)(TTn,(0,p.A)({},wTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}CTn.isMDXComponent=!0;const xTn={toc:[]},ATn="wrapper";function vTn(e){let{components:n,...t}=e;return(0,s.yg)(ATn,(0,p.A)({},xTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}vTn.isMDXComponent=!0;const LTn={toc:[]},bTn="wrapper";function NTn(e){let{components:n,...t}=e;return(0,s.yg)(bTn,(0,p.A)({},LTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}NTn.isMDXComponent=!0;const kTn={toc:[]},zTn="wrapper";function PTn(e){let{components:n,...t}=e;return(0,s.yg)(zTn,(0,p.A)({},kTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}PTn.isMDXComponent=!0;const ITn={toc:[]},RTn="wrapper";function WTn(e){let{components:n,...t}=e;return(0,s.yg)(RTn,(0,p.A)({},ITn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}WTn.isMDXComponent=!0;const STn={toc:[]},BTn="wrapper";function GTn(e){let{components:n,...t}=e;return(0,s.yg)(BTn,(0,p.A)({},STn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}GTn.isMDXComponent=!0;const ETn={toc:[]},OTn="wrapper";function UTn(e){let{components:n,...t}=e;return(0,s.yg)(OTn,(0,p.A)({},ETn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"overrides ",(0,s.yg)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}UTn.isMDXComponent=!0;const FTn={toc:[]},VTn="wrapper";function qTn(e){let{components:n,...t}=e;return(0,s.yg)(VTn,(0,p.A)({},FTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qTn.isMDXComponent=!0;const jTn={toc:[]},HTn="wrapper";function YTn(e){let{components:n,...t}=e;return(0,s.yg)(HTn,(0,p.A)({},jTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}YTn.isMDXComponent=!0;const QTn={toc:[]},$Tn="wrapper";function KTn(e){let{components:n,...t}=e;return(0,s.yg)($Tn,(0,p.A)({},QTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}KTn.isMDXComponent=!0;const JTn={toc:[]},ZTn="wrapper";function eCn(e){let{components:n,...t}=e;return(0,s.yg)(ZTn,(0,p.A)({},JTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}eCn.isMDXComponent=!0;const nCn={toc:[]},tCn="wrapper";function oCn(e){let{components:n,...t}=e;return(0,s.yg)(tCn,(0,p.A)({},nCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}oCn.isMDXComponent=!0;const pCn={toc:[]},rCn="wrapper";function sCn(e){let{components:n,...t}=e;return(0,s.yg)(rCn,(0,p.A)({},pCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}sCn.isMDXComponent=!0;const cCn={toc:[]},aCn="wrapper";function iCn(e){let{components:n,...t}=e;return(0,s.yg)(aCn,(0,p.A)({},cCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Address to Iconify API for the requested Icon."))}iCn.isMDXComponent=!0;const lCn={toc:[]},uCn="wrapper";function mCn(e){let{components:n,...t}=e;return(0,s.yg)(uCn,(0,p.A)({},lCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create the URL that will be used as the Image source"))}mCn.isMDXComponent=!0;const yCn={toc:[]},dCn="wrapper";function hCn(e){let{components:n,...t}=e;return(0,s.yg)(dCn,(0,p.A)({},yCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}hCn.isMDXComponent=!0;const gCn={toc:[]},fCn="wrapper";function DCn(e){let{components:n,...t}=e;return(0,s.yg)(fCn,(0,p.A)({},gCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}DCn.isMDXComponent=!0;const MCn={toc:[]},XCn="wrapper";function _Cn(e){let{components:n,...t}=e;return(0,s.yg)(XCn,(0,p.A)({},MCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}_Cn.isMDXComponent=!0;const wCn={toc:[]},TCn="wrapper";function CCn(e){let{components:n,...t}=e;return(0,s.yg)(TCn,(0,p.A)({},wCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}CCn.isMDXComponent=!0;const xCn={toc:[]},ACn="wrapper";function vCn(e){let{components:n,...t}=e;return(0,s.yg)(ACn,(0,p.A)({},xCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}vCn.isMDXComponent=!0;const LCn={toc:[]},bCn="wrapper";function NCn(e){let{components:n,...t}=e;return(0,s.yg)(bCn,(0,p.A)({},LCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}NCn.isMDXComponent=!0;const kCn={toc:[]},zCn="wrapper";function PCn(e){let{components:n,...t}=e;return(0,s.yg)(zCn,(0,p.A)({},kCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}PCn.isMDXComponent=!0;const ICn={toc:[]},RCn="wrapper";function WCn(e){let{components:n,...t}=e;return(0,s.yg)(RCn,(0,p.A)({},ICn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}WCn.isMDXComponent=!0;const SCn={toc:[]},BCn="wrapper";function GCn(e){let{components:n,...t}=e;return(0,s.yg)(BCn,(0,p.A)({},SCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}GCn.isMDXComponent=!0;const ECn={toc:[]},OCn="wrapper";function UCn(e){let{components:n,...t}=e;return(0,s.yg)(OCn,(0,p.A)({},ECn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}UCn.isMDXComponent=!0;const FCn={toc:[]},VCn="wrapper";function qCn(e){let{components:n,...t}=e;return(0,s.yg)(VCn,(0,p.A)({},FCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@revideo/2d';\nimport {all, waitFor} from '@revideo/core';\nimport {createRef} from '@revideo/core';\nimport {makeScene2D} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}qCn.isMDXComponent=!0;const jCn={toc:[]},HCn="wrapper";function YCn(e){let{components:n,...t}=e;return(0,s.yg)(HCn,(0,p.A)({},jCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for displaying images."))}YCn.isMDXComponent=!0;const QCn={toc:[]},$Cn="wrapper";function KCn(e){let{components:n,...t}=e;return(0,s.yg)($Cn,(0,p.A)({},QCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}KCn.isMDXComponent=!0;const JCn={toc:[]},ZCn="wrapper";function exn(e){let{components:n,...t}=e;return(0,s.yg)(ZCn,(0,p.A)({},JCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}exn.isMDXComponent=!0;const nxn={toc:[]},txn="wrapper";function oxn(e){let{components:n,...t}=e;return(0,s.yg)(txn,(0,p.A)({},nxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}oxn.isMDXComponent=!0;const pxn={toc:[]},rxn="wrapper";function sxn(e){let{components:n,...t}=e;return(0,s.yg)(rxn,(0,p.A)({},pxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}sxn.isMDXComponent=!0;const cxn={toc:[]},axn="wrapper";function ixn(e){let{components:n,...t}=e;return(0,s.yg)(axn,(0,p.A)({},cxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}ixn.isMDXComponent=!0;const lxn={toc:[]},uxn="wrapper";function mxn(e){let{components:n,...t}=e;return(0,s.yg)(uxn,(0,p.A)({},lxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}mxn.isMDXComponent=!0;const yxn={toc:[]},dxn="wrapper";function hxn(e){let{components:n,...t}=e;return(0,s.yg)(dxn,(0,p.A)({},yxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}hxn.isMDXComponent=!0;const gxn={toc:[]},fxn="wrapper";function Dxn(e){let{components:n,...t}=e;return(0,s.yg)(fxn,(0,p.A)({},gxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}Dxn.isMDXComponent=!0;const Mxn={toc:[]},Xxn="wrapper";function _xn(e){let{components:n,...t}=e;return(0,s.yg)(Xxn,(0,p.A)({},Mxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}_xn.isMDXComponent=!0;const wxn={toc:[]},Txn="wrapper";function Cxn(e){let{components:n,...t}=e;return(0,s.yg)(Txn,(0,p.A)({},wxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Cxn.isMDXComponent=!0;const xxn={toc:[]},Axn="wrapper";function vxn(e){let{components:n,...t}=e;return(0,s.yg)(Axn,(0,p.A)({},xxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}vxn.isMDXComponent=!0;const Lxn={toc:[]},bxn="wrapper";function Nxn(e){let{components:n,...t}=e;return(0,s.yg)(bxn,(0,p.A)({},Lxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Nxn.isMDXComponent=!0;const kxn={toc:[]},zxn="wrapper";function Pxn(e){let{components:n,...t}=e;return(0,s.yg)(zxn,(0,p.A)({},kxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Pxn.isMDXComponent=!0;const Ixn={toc:[]},Rxn="wrapper";function Wxn(e){let{components:n,...t}=e;return(0,s.yg)(Rxn,(0,p.A)({},Ixn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Wxn.isMDXComponent=!0;const Sxn={toc:[]},Bxn="wrapper";function Gxn(e){let{components:n,...t}=e;return(0,s.yg)(Bxn,(0,p.A)({},Sxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Gxn.isMDXComponent=!0;const Exn={toc:[]},Oxn="wrapper";function Uxn(e){let{components:n,...t}=e;return(0,s.yg)(Oxn,(0,p.A)({},Exn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Uxn.isMDXComponent=!0;const Fxn={toc:[]},Vxn="wrapper";function qxn(e){let{components:n,...t}=e;return(0,s.yg)(Vxn,(0,p.A)({},Fxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}qxn.isMDXComponent=!0;const jxn={toc:[]},Hxn="wrapper";function Yxn(e){let{components:n,...t}=e;return(0,s.yg)(Hxn,(0,p.A)({},jxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Yxn.isMDXComponent=!0;const Qxn={toc:[]},$xn="wrapper";function Kxn(e){let{components:n,...t}=e;return(0,s.yg)($xn,(0,p.A)({},Qxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Kxn.isMDXComponent=!0;const Jxn={toc:[]},Zxn="wrapper";function eAn(e){let{components:n,...t}=e;return(0,s.yg)(Zxn,(0,p.A)({},Jxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}eAn.isMDXComponent=!0;const nAn={toc:[]},tAn="wrapper";function oAn(e){let{components:n,...t}=e;return(0,s.yg)(tAn,(0,p.A)({},nAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}oAn.isMDXComponent=!0;const pAn={toc:[]},rAn="wrapper";function sAn(e){let{components:n,...t}=e;return(0,s.yg)(rAn,(0,p.A)({},pAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}sAn.isMDXComponent=!0;const cAn={toc:[]},aAn="wrapper";function iAn(e){let{components:n,...t}=e;return(0,s.yg)(aAn,(0,p.A)({},cAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}iAn.isMDXComponent=!0;const lAn={toc:[]},uAn="wrapper";function mAn(e){let{components:n,...t}=e;return(0,s.yg)(uAn,(0,p.A)({},lAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}mAn.isMDXComponent=!0;const yAn={toc:[]},dAn="wrapper";function hAn(e){let{components:n,...t}=e;return(0,s.yg)(dAn,(0,p.A)({},yAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}hAn.isMDXComponent=!0;const gAn={toc:[]},fAn="wrapper";function DAn(e){let{components:n,...t}=e;return(0,s.yg)(fAn,(0,p.A)({},gAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}DAn.isMDXComponent=!0;const MAn={toc:[]},XAn="wrapper";function _An(e){let{components:n,...t}=e;return(0,s.yg)(XAn,(0,p.A)({},MAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}_An.isMDXComponent=!0;const wAn={toc:[]},TAn="wrapper";function CAn(e){let{components:n,...t}=e;return(0,s.yg)(TAn,(0,p.A)({},wAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}CAn.isMDXComponent=!0;const xAn={toc:[]},AAn="wrapper";function vAn(e){let{components:n,...t}=e;return(0,s.yg)(AAn,(0,p.A)({},xAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}vAn.isMDXComponent=!0;const LAn={toc:[]},bAn="wrapper";function NAn(e){let{components:n,...t}=e;return(0,s.yg)(bAn,(0,p.A)({},LAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}NAn.isMDXComponent=!0;const kAn={toc:[]},zAn="wrapper";function PAn(e){let{components:n,...t}=e;return(0,s.yg)(zAn,(0,p.A)({},kAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}PAn.isMDXComponent=!0;const IAn={toc:[]},RAn="wrapper";function WAn(e){let{components:n,...t}=e;return(0,s.yg)(RAn,(0,p.A)({},IAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}WAn.isMDXComponent=!0;const SAn={toc:[]},BAn="wrapper";function GAn(e){let{components:n,...t}=e;return(0,s.yg)(BAn,(0,p.A)({},SAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}GAn.isMDXComponent=!0;const EAn={toc:[]},OAn="wrapper";function UAn(e){let{components:n,...t}=e;return(0,s.yg)(OAn,(0,p.A)({},EAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}UAn.isMDXComponent=!0;const FAn={toc:[]},VAn="wrapper";function qAn(e){let{components:n,...t}=e;return(0,s.yg)(VAn,(0,p.A)({},FAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}qAn.isMDXComponent=!0;const jAn={toc:[]},HAn="wrapper";function YAn(e){let{components:n,...t}=e;return(0,s.yg)(HAn,(0,p.A)({},jAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}YAn.isMDXComponent=!0;const QAn={toc:[]},$An="wrapper";function KAn(e){let{components:n,...t}=e;return(0,s.yg)($An,(0,p.A)({},QAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}KAn.isMDXComponent=!0;const JAn={toc:[]},ZAn="wrapper";function evn(e){let{components:n,...t}=e;return(0,s.yg)(ZAn,(0,p.A)({},JAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}evn.isMDXComponent=!0;const nvn={toc:[]},tvn="wrapper";function ovn(e){let{components:n,...t}=e;return(0,s.yg)(tvn,(0,p.A)({},nvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}ovn.isMDXComponent=!0;const pvn={toc:[]},rvn="wrapper";function svn(e){let{components:n,...t}=e;return(0,s.yg)(rvn,(0,p.A)({},pvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}svn.isMDXComponent=!0;const cvn={toc:[]},avn="wrapper";function ivn(e){let{components:n,...t}=e;return(0,s.yg)(avn,(0,p.A)({},cvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}ivn.isMDXComponent=!0;const lvn={toc:[]},uvn="wrapper";function mvn(e){let{components:n,...t}=e;return(0,s.yg)(uvn,(0,p.A)({},lvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}mvn.isMDXComponent=!0;const yvn={toc:[]},dvn="wrapper";function hvn(e){let{components:n,...t}=e;return(0,s.yg)(dvn,(0,p.A)({},yvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}hvn.isMDXComponent=!0;const gvn={toc:[]},fvn="wrapper";function Dvn(e){let{components:n,...t}=e;return(0,s.yg)(fvn,(0,p.A)({},gvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Dvn.isMDXComponent=!0;const Mvn={toc:[]},Xvn="wrapper";function _vn(e){let{components:n,...t}=e;return(0,s.yg)(Xvn,(0,p.A)({},Mvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}_vn.isMDXComponent=!0;const wvn={toc:[]},Tvn="wrapper";function Cvn(e){let{components:n,...t}=e;return(0,s.yg)(Tvn,(0,p.A)({},wvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Cvn.isMDXComponent=!0;const xvn={toc:[]},Avn="wrapper";function vvn(e){let{components:n,...t}=e;return(0,s.yg)(Avn,(0,p.A)({},xvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}vvn.isMDXComponent=!0;const Lvn={toc:[]},bvn="wrapper";function Nvn(e){let{components:n,...t}=e;return(0,s.yg)(bvn,(0,p.A)({},Lvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Nvn.isMDXComponent=!0;const kvn={toc:[]},zvn="wrapper";function Pvn(e){let{components:n,...t}=e;return(0,s.yg)(zvn,(0,p.A)({},kvn,t,{components:n,mdxType:"MDXLayout"}))}Pvn.isMDXComponent=!0;const Ivn={toc:[]},Rvn="wrapper";function Wvn(e){let{components:n,...t}=e;return(0,s.yg)(Rvn,(0,p.A)({},Ivn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Wvn.isMDXComponent=!0;const Svn={toc:[]},Bvn="wrapper";function Gvn(e){let{components:n,...t}=e;return(0,s.yg)(Bvn,(0,p.A)({},Svn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Gvn.isMDXComponent=!0;const Evn={toc:[]},Ovn="wrapper";function Uvn(e){let{components:n,...t}=e;return(0,s.yg)(Ovn,(0,p.A)({},Evn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Uvn.isMDXComponent=!0;const Fvn={toc:[]},Vvn="wrapper";function qvn(e){let{components:n,...t}=e;return(0,s.yg)(Vvn,(0,p.A)({},Fvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}qvn.isMDXComponent=!0;const jvn={toc:[]},Hvn="wrapper";function Yvn(e){let{components:n,...t}=e;return(0,s.yg)(Hvn,(0,p.A)({},jvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Yvn.isMDXComponent=!0;const Qvn={toc:[]},$vn="wrapper";function Kvn(e){let{components:n,...t}=e;return(0,s.yg)($vn,(0,p.A)({},Qvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Kvn.isMDXComponent=!0;const Jvn={toc:[]},Zvn="wrapper";function eLn(e){let{components:n,...t}=e;return(0,s.yg)(Zvn,(0,p.A)({},Jvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}eLn.isMDXComponent=!0;const nLn={toc:[]},tLn="wrapper";function oLn(e){let{components:n,...t}=e;return(0,s.yg)(tLn,(0,p.A)({},nLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}oLn.isMDXComponent=!0;const pLn={toc:[]},rLn="wrapper";function sLn(e){let{components:n,...t}=e;return(0,s.yg)(rLn,(0,p.A)({},pLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}sLn.isMDXComponent=!0;const cLn={toc:[]},aLn="wrapper";function iLn(e){let{components:n,...t}=e;return(0,s.yg)(aLn,(0,p.A)({},cLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}iLn.isMDXComponent=!0;const lLn={toc:[]},uLn="wrapper";function mLn(e){let{components:n,...t}=e;return(0,s.yg)(uLn,(0,p.A)({},lLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}mLn.isMDXComponent=!0;const yLn={toc:[]},dLn="wrapper";function hLn(e){let{components:n,...t}=e;return(0,s.yg)(dLn,(0,p.A)({},yLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}hLn.isMDXComponent=!0;const gLn={toc:[]},fLn="wrapper";function DLn(e){let{components:n,...t}=e;return(0,s.yg)(fLn,(0,p.A)({},gLn,t,{components:n,mdxType:"MDXLayout"}))}DLn.isMDXComponent=!0;const MLn={toc:[]},XLn="wrapper";function _Ln(e){let{components:n,...t}=e;return(0,s.yg)(XLn,(0,p.A)({},MLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}_Ln.isMDXComponent=!0;const wLn={toc:[]},TLn="wrapper";function CLn(e){let{components:n,...t}=e;return(0,s.yg)(TLn,(0,p.A)({},wLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}CLn.isMDXComponent=!0;const xLn={toc:[]},ALn="wrapper";function vLn(e){let{components:n,...t}=e;return(0,s.yg)(ALn,(0,p.A)({},xLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}vLn.isMDXComponent=!0;const LLn={toc:[]},bLn="wrapper";function NLn(e){let{components:n,...t}=e;return(0,s.yg)(bLn,(0,p.A)({},LLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}NLn.isMDXComponent=!0;const kLn={toc:[]},zLn="wrapper";function PLn(e){let{components:n,...t}=e;return(0,s.yg)(zLn,(0,p.A)({},kLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}PLn.isMDXComponent=!0;const ILn={toc:[]},RLn="wrapper";function WLn(e){let{components:n,...t}=e;return(0,s.yg)(RLn,(0,p.A)({},ILn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}WLn.isMDXComponent=!0;const SLn={toc:[]},BLn="wrapper";function GLn(e){let{components:n,...t}=e;return(0,s.yg)(BLn,(0,p.A)({},SLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}GLn.isMDXComponent=!0;const ELn={toc:[]},OLn="wrapper";function ULn(e){let{components:n,...t}=e;return(0,s.yg)(OLn,(0,p.A)({},ELn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}ULn.isMDXComponent=!0;const FLn={toc:[]},VLn="wrapper";function qLn(e){let{components:n,...t}=e;return(0,s.yg)(VLn,(0,p.A)({},FLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}qLn.isMDXComponent=!0;const jLn={toc:[]},HLn="wrapper";function YLn(e){let{components:n,...t}=e;return(0,s.yg)(HLn,(0,p.A)({},jLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}YLn.isMDXComponent=!0;const QLn={toc:[]},$Ln="wrapper";function KLn(e){let{components:n,...t}=e;return(0,s.yg)($Ln,(0,p.A)({},QLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}KLn.isMDXComponent=!0;const JLn={toc:[]},ZLn="wrapper";function ebn(e){let{components:n,...t}=e;return(0,s.yg)(ZLn,(0,p.A)({},JLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}ebn.isMDXComponent=!0;const nbn={toc:[]},tbn="wrapper";function obn(e){let{components:n,...t}=e;return(0,s.yg)(tbn,(0,p.A)({},nbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}obn.isMDXComponent=!0;const pbn={toc:[]},rbn="wrapper";function sbn(e){let{components:n,...t}=e;return(0,s.yg)(rbn,(0,p.A)({},pbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}sbn.isMDXComponent=!0;const cbn={toc:[]},abn="wrapper";function ibn(e){let{components:n,...t}=e;return(0,s.yg)(abn,(0,p.A)({},cbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}ibn.isMDXComponent=!0;const lbn={toc:[]},ubn="wrapper";function mbn(e){let{components:n,...t}=e;return(0,s.yg)(ubn,(0,p.A)({},lbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}mbn.isMDXComponent=!0;const ybn={toc:[]},dbn="wrapper";function hbn(e){let{components:n,...t}=e;return(0,s.yg)(dbn,(0,p.A)({},ybn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}hbn.isMDXComponent=!0;const gbn={toc:[]},fbn="wrapper";function Dbn(e){let{components:n,...t}=e;return(0,s.yg)(fbn,(0,p.A)({},gbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Dbn.isMDXComponent=!0;const Mbn={toc:[]},Xbn="wrapper";function _bn(e){let{components:n,...t}=e;return(0,s.yg)(Xbn,(0,p.A)({},Mbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}_bn.isMDXComponent=!0;const wbn={toc:[]},Tbn="wrapper";function Cbn(e){let{components:n,...t}=e;return(0,s.yg)(Tbn,(0,p.A)({},wbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Cbn.isMDXComponent=!0;const xbn={toc:[]},Abn="wrapper";function vbn(e){let{components:n,...t}=e;return(0,s.yg)(Abn,(0,p.A)({},xbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}vbn.isMDXComponent=!0;const Lbn={toc:[]},bbn="wrapper";function Nbn(e){let{components:n,...t}=e;return(0,s.yg)(bbn,(0,p.A)({},Lbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Nbn.isMDXComponent=!0;const kbn={toc:[]},zbn="wrapper";function Pbn(e){let{components:n,...t}=e;return(0,s.yg)(zbn,(0,p.A)({},kbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Pbn.isMDXComponent=!0;const Ibn={toc:[]},Rbn="wrapper";function Wbn(e){let{components:n,...t}=e;return(0,s.yg)(Rbn,(0,p.A)({},Ibn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Wbn.isMDXComponent=!0;const Sbn={toc:[]},Bbn="wrapper";function Gbn(e){let{components:n,...t}=e;return(0,s.yg)(Bbn,(0,p.A)({},Sbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Gbn.isMDXComponent=!0;const Ebn={toc:[]},Obn="wrapper";function Ubn(e){let{components:n,...t}=e;return(0,s.yg)(Obn,(0,p.A)({},Ebn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Ubn.isMDXComponent=!0;const Fbn={toc:[]},Vbn="wrapper";function qbn(e){let{components:n,...t}=e;return(0,s.yg)(Vbn,(0,p.A)({},Fbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}qbn.isMDXComponent=!0;const jbn={toc:[]},Hbn="wrapper";function Ybn(e){let{components:n,...t}=e;return(0,s.yg)(Hbn,(0,p.A)({},jbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Ybn.isMDXComponent=!0;const Qbn={toc:[]},$bn="wrapper";function Kbn(e){let{components:n,...t}=e;return(0,s.yg)($bn,(0,p.A)({},Qbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Kbn.isMDXComponent=!0;const Jbn={toc:[]},Zbn="wrapper";function eNn(e){let{components:n,...t}=e;return(0,s.yg)(Zbn,(0,p.A)({},Jbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}eNn.isMDXComponent=!0;const nNn={toc:[]},tNn="wrapper";function oNn(e){let{components:n,...t}=e;return(0,s.yg)(tNn,(0,p.A)({},nNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}oNn.isMDXComponent=!0;const pNn={toc:[]},rNn="wrapper";function sNn(e){let{components:n,...t}=e;return(0,s.yg)(rNn,(0,p.A)({},pNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}sNn.isMDXComponent=!0;const cNn={toc:[]},aNn="wrapper";function iNn(e){let{components:n,...t}=e;return(0,s.yg)(aNn,(0,p.A)({},cNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}iNn.isMDXComponent=!0;const lNn={toc:[]},uNn="wrapper";function mNn(e){let{components:n,...t}=e;return(0,s.yg)(uNn,(0,p.A)({},lNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}mNn.isMDXComponent=!0;const yNn={toc:[]},dNn="wrapper";function hNn(e){let{components:n,...t}=e;return(0,s.yg)(dNn,(0,p.A)({},yNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}hNn.isMDXComponent=!0;const gNn={toc:[]},fNn="wrapper";function DNn(e){let{components:n,...t}=e;return(0,s.yg)(fNn,(0,p.A)({},gNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}DNn.isMDXComponent=!0;const MNn={toc:[]},XNn="wrapper";function _Nn(e){let{components:n,...t}=e;return(0,s.yg)(XNn,(0,p.A)({},MNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}_Nn.isMDXComponent=!0;const wNn={toc:[]},TNn="wrapper";function CNn(e){let{components:n,...t}=e;return(0,s.yg)(TNn,(0,p.A)({},wNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}CNn.isMDXComponent=!0;const xNn={toc:[]},ANn="wrapper";function vNn(e){let{components:n,...t}=e;return(0,s.yg)(ANn,(0,p.A)({},xNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}vNn.isMDXComponent=!0;const LNn={toc:[]},bNn="wrapper";function NNn(e){let{components:n,...t}=e;return(0,s.yg)(bNn,(0,p.A)({},LNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}NNn.isMDXComponent=!0;const kNn={toc:[]},zNn="wrapper";function PNn(e){let{components:n,...t}=e;return(0,s.yg)(zNn,(0,p.A)({},kNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}PNn.isMDXComponent=!0;const INn={toc:[]},RNn="wrapper";function WNn(e){let{components:n,...t}=e;return(0,s.yg)(RNn,(0,p.A)({},INn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}WNn.isMDXComponent=!0;const SNn={toc:[]},BNn="wrapper";function GNn(e){let{components:n,...t}=e;return(0,s.yg)(BNn,(0,p.A)({},SNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}GNn.isMDXComponent=!0;const ENn={toc:[]},ONn="wrapper";function UNn(e){let{components:n,...t}=e;return(0,s.yg)(ONn,(0,p.A)({},ENn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}UNn.isMDXComponent=!0;const FNn={toc:[]},VNn="wrapper";function qNn(e){let{components:n,...t}=e;return(0,s.yg)(VNn,(0,p.A)({},FNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}qNn.isMDXComponent=!0;const jNn={toc:[]},HNn="wrapper";function YNn(e){let{components:n,...t}=e;return(0,s.yg)(HNn,(0,p.A)({},jNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}YNn.isMDXComponent=!0;const QNn={toc:[]},$Nn="wrapper";function KNn(e){let{components:n,...t}=e;return(0,s.yg)($Nn,(0,p.A)({},QNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}KNn.isMDXComponent=!0;const JNn={toc:[]},ZNn="wrapper";function ekn(e){let{components:n,...t}=e;return(0,s.yg)(ZNn,(0,p.A)({},JNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ekn.isMDXComponent=!0;const nkn={toc:[]},tkn="wrapper";function okn(e){let{components:n,...t}=e;return(0,s.yg)(tkn,(0,p.A)({},nkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}okn.isMDXComponent=!0;const pkn={toc:[]},rkn="wrapper";function skn(e){let{components:n,...t}=e;return(0,s.yg)(rkn,(0,p.A)({},pkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}skn.isMDXComponent=!0;const ckn={toc:[]},akn="wrapper";function ikn(e){let{components:n,...t}=e;return(0,s.yg)(akn,(0,p.A)({},ckn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ikn.isMDXComponent=!0;const lkn={toc:[]},ukn="wrapper";function mkn(e){let{components:n,...t}=e;return(0,s.yg)(ukn,(0,p.A)({},lkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}mkn.isMDXComponent=!0;const ykn={toc:[]},dkn="wrapper";function hkn(e){let{components:n,...t}=e;return(0,s.yg)(dkn,(0,p.A)({},ykn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}hkn.isMDXComponent=!0;const gkn={toc:[]},fkn="wrapper";function Dkn(e){let{components:n,...t}=e;return(0,s.yg)(fkn,(0,p.A)({},gkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Dkn.isMDXComponent=!0;const Mkn={toc:[]},Xkn="wrapper";function _kn(e){let{components:n,...t}=e;return(0,s.yg)(Xkn,(0,p.A)({},Mkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}_kn.isMDXComponent=!0;const wkn={toc:[]},Tkn="wrapper";function Ckn(e){let{components:n,...t}=e;return(0,s.yg)(Tkn,(0,p.A)({},wkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ckn.isMDXComponent=!0;const xkn={toc:[]},Akn="wrapper";function vkn(e){let{components:n,...t}=e;return(0,s.yg)(Akn,(0,p.A)({},xkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}vkn.isMDXComponent=!0;const Lkn={toc:[]},bkn="wrapper";function Nkn(e){let{components:n,...t}=e;return(0,s.yg)(bkn,(0,p.A)({},Lkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Nkn.isMDXComponent=!0;const kkn={toc:[]},zkn="wrapper";function Pkn(e){let{components:n,...t}=e;return(0,s.yg)(zkn,(0,p.A)({},kkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Pkn.isMDXComponent=!0;const Ikn={toc:[]},Rkn="wrapper";function Wkn(e){let{components:n,...t}=e;return(0,s.yg)(Rkn,(0,p.A)({},Ikn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Wkn.isMDXComponent=!0;const Skn={toc:[]},Bkn="wrapper";function Gkn(e){let{components:n,...t}=e;return(0,s.yg)(Bkn,(0,p.A)({},Skn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Gkn.isMDXComponent=!0;const Ekn={toc:[]},Okn="wrapper";function Ukn(e){let{components:n,...t}=e;return(0,s.yg)(Okn,(0,p.A)({},Ekn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ukn.isMDXComponent=!0;const Fkn={toc:[]},Vkn="wrapper";function qkn(e){let{components:n,...t}=e;return(0,s.yg)(Vkn,(0,p.A)({},Fkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}qkn.isMDXComponent=!0;const jkn={toc:[]},Hkn="wrapper";function Ykn(e){let{components:n,...t}=e;return(0,s.yg)(Hkn,(0,p.A)({},jkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ykn.isMDXComponent=!0;const Qkn={toc:[]},$kn="wrapper";function Kkn(e){let{components:n,...t}=e;return(0,s.yg)($kn,(0,p.A)({},Qkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]},Zkn="wrapper";function ezn(e){let{components:n,...t}=e;return(0,s.yg)(Zkn,(0,p.A)({},Jkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ezn.isMDXComponent=!0;const nzn={toc:[]},tzn="wrapper";function ozn(e){let{components:n,...t}=e;return(0,s.yg)(tzn,(0,p.A)({},nzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}ozn.isMDXComponent=!0;const pzn={toc:[]},rzn="wrapper";function szn(e){let{components:n,...t}=e;return(0,s.yg)(rzn,(0,p.A)({},pzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}szn.isMDXComponent=!0;const czn={toc:[]},azn="wrapper";function izn(e){let{components:n,...t}=e;return(0,s.yg)(azn,(0,p.A)({},czn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}izn.isMDXComponent=!0;const lzn={toc:[]},uzn="wrapper";function mzn(e){let{components:n,...t}=e;return(0,s.yg)(uzn,(0,p.A)({},lzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mzn.isMDXComponent=!0;const yzn={toc:[]},dzn="wrapper";function hzn(e){let{components:n,...t}=e;return(0,s.yg)(dzn,(0,p.A)({},yzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}hzn.isMDXComponent=!0;const gzn={toc:[]},fzn="wrapper";function Dzn(e){let{components:n,...t}=e;return(0,s.yg)(fzn,(0,p.A)({},gzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Dzn.isMDXComponent=!0;const Mzn={toc:[]},Xzn="wrapper";function _zn(e){let{components:n,...t}=e;return(0,s.yg)(Xzn,(0,p.A)({},Mzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}_zn.isMDXComponent=!0;const wzn={toc:[]},Tzn="wrapper";function Czn(e){let{components:n,...t}=e;return(0,s.yg)(Tzn,(0,p.A)({},wzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Czn.isMDXComponent=!0;const xzn={toc:[]},Azn="wrapper";function vzn(e){let{components:n,...t}=e;return(0,s.yg)(Azn,(0,p.A)({},xzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}vzn.isMDXComponent=!0;const Lzn={toc:[]},bzn="wrapper";function Nzn(e){let{components:n,...t}=e;return(0,s.yg)(bzn,(0,p.A)({},Lzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}Nzn.isMDXComponent=!0;const kzn={toc:[]},zzn="wrapper";function Pzn(e){let{components:n,...t}=e;return(0,s.yg)(zzn,(0,p.A)({},kzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}Pzn.isMDXComponent=!0;const Izn={toc:[]},Rzn="wrapper";function Wzn(e){let{components:n,...t}=e;return(0,s.yg)(Rzn,(0,p.A)({},Izn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}Wzn.isMDXComponent=!0;const Szn={toc:[]},Bzn="wrapper";function Gzn(e){let{components:n,...t}=e;return(0,s.yg)(Bzn,(0,p.A)({},Szn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Gzn.isMDXComponent=!0;const Ezn={toc:[]},Ozn="wrapper";function Uzn(e){let{components:n,...t}=e;return(0,s.yg)(Ozn,(0,p.A)({},Ezn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Uzn.isMDXComponent=!0;const Fzn={toc:[]},Vzn="wrapper";function qzn(e){let{components:n,...t}=e;return(0,s.yg)(Vzn,(0,p.A)({},Fzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}qzn.isMDXComponent=!0;const jzn={toc:[]},Hzn="wrapper";function Yzn(e){let{components:n,...t}=e;return(0,s.yg)(Hzn,(0,p.A)({},jzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Yzn.isMDXComponent=!0;const Qzn={toc:[]},$zn="wrapper";function Kzn(e){let{components:n,...t}=e;return(0,s.yg)($zn,(0,p.A)({},Qzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Kzn.isMDXComponent=!0;const Jzn={toc:[]},Zzn="wrapper";function ePn(e){let{components:n,...t}=e;return(0,s.yg)(Zzn,(0,p.A)({},Jzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}ePn.isMDXComponent=!0;const nPn={toc:[]},tPn="wrapper";function oPn(e){let{components:n,...t}=e;return(0,s.yg)(tPn,(0,p.A)({},nPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}oPn.isMDXComponent=!0;const pPn={toc:[]},rPn="wrapper";function sPn(e){let{components:n,...t}=e;return(0,s.yg)(rPn,(0,p.A)({},pPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}sPn.isMDXComponent=!0;const cPn={toc:[]},aPn="wrapper";function iPn(e){let{components:n,...t}=e;return(0,s.yg)(aPn,(0,p.A)({},cPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}iPn.isMDXComponent=!0;const lPn={toc:[]},uPn="wrapper";function mPn(e){let{components:n,...t}=e;return(0,s.yg)(uPn,(0,p.A)({},lPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}mPn.isMDXComponent=!0;const yPn={toc:[]},dPn="wrapper";function hPn(e){let{components:n,...t}=e;return(0,s.yg)(dPn,(0,p.A)({},yPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}hPn.isMDXComponent=!0;const gPn={toc:[]},fPn="wrapper";function DPn(e){let{components:n,...t}=e;return(0,s.yg)(fPn,(0,p.A)({},gPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}DPn.isMDXComponent=!0;const MPn={toc:[]},XPn="wrapper";function _Pn(e){let{components:n,...t}=e;return(0,s.yg)(XPn,(0,p.A)({},MPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}_Pn.isMDXComponent=!0;const wPn={toc:[]},TPn="wrapper";function CPn(e){let{components:n,...t}=e;return(0,s.yg)(TPn,(0,p.A)({},wPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}CPn.isMDXComponent=!0;const xPn={toc:[]},APn="wrapper";function vPn(e){let{components:n,...t}=e;return(0,s.yg)(APn,(0,p.A)({},xPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}vPn.isMDXComponent=!0;const LPn={toc:[]},bPn="wrapper";function NPn(e){let{components:n,...t}=e;return(0,s.yg)(bPn,(0,p.A)({},LPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}NPn.isMDXComponent=!0;const kPn={toc:[]},zPn="wrapper";function PPn(e){let{components:n,...t}=e;return(0,s.yg)(zPn,(0,p.A)({},kPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}PPn.isMDXComponent=!0;const IPn={toc:[]},RPn="wrapper";function WPn(e){let{components:n,...t}=e;return(0,s.yg)(RPn,(0,p.A)({},IPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}WPn.isMDXComponent=!0;const SPn={toc:[]},BPn="wrapper";function GPn(e){let{components:n,...t}=e;return(0,s.yg)(BPn,(0,p.A)({},SPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}GPn.isMDXComponent=!0;const EPn={toc:[]},OPn="wrapper";function UPn(e){let{components:n,...t}=e;return(0,s.yg)(OPn,(0,p.A)({},EPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}UPn.isMDXComponent=!0;const FPn={toc:[]},VPn="wrapper";function qPn(e){let{components:n,...t}=e;return(0,s.yg)(VPn,(0,p.A)({},FPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}qPn.isMDXComponent=!0;const jPn={toc:[]},HPn="wrapper";function YPn(e){let{components:n,...t}=e;return(0,s.yg)(HPn,(0,p.A)({},jPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}YPn.isMDXComponent=!0;const QPn={toc:[]},$Pn="wrapper";function KPn(e){let{components:n,...t}=e;return(0,s.yg)($Pn,(0,p.A)({},QPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}KPn.isMDXComponent=!0;const JPn={toc:[]},ZPn="wrapper";function eIn(e){let{components:n,...t}=e;return(0,s.yg)(ZPn,(0,p.A)({},JPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}eIn.isMDXComponent=!0;const nIn={toc:[]},tIn="wrapper";function oIn(e){let{components:n,...t}=e;return(0,s.yg)(tIn,(0,p.A)({},nIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}oIn.isMDXComponent=!0;const pIn={toc:[]},rIn="wrapper";function sIn(e){let{components:n,...t}=e;return(0,s.yg)(rIn,(0,p.A)({},pIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}sIn.isMDXComponent=!0;const cIn={toc:[]},aIn="wrapper";function iIn(e){let{components:n,...t}=e;return(0,s.yg)(aIn,(0,p.A)({},cIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}iIn.isMDXComponent=!0;const lIn={toc:[]},uIn="wrapper";function mIn(e){let{components:n,...t}=e;return(0,s.yg)(uIn,(0,p.A)({},lIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}mIn.isMDXComponent=!0;const yIn={toc:[]},dIn="wrapper";function hIn(e){let{components:n,...t}=e;return(0,s.yg)(dIn,(0,p.A)({},yIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}hIn.isMDXComponent=!0;const gIn={toc:[]},fIn="wrapper";function DIn(e){let{components:n,...t}=e;return(0,s.yg)(fIn,(0,p.A)({},gIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}DIn.isMDXComponent=!0;const MIn={toc:[]},XIn="wrapper";function _In(e){let{components:n,...t}=e;return(0,s.yg)(XIn,(0,p.A)({},MIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}_In.isMDXComponent=!0;const wIn={toc:[]},TIn="wrapper";function CIn(e){let{components:n,...t}=e;return(0,s.yg)(TIn,(0,p.A)({},wIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}CIn.isMDXComponent=!0;const xIn={toc:[]},AIn="wrapper";function vIn(e){let{components:n,...t}=e;return(0,s.yg)(AIn,(0,p.A)({},xIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}vIn.isMDXComponent=!0;const LIn={toc:[]},bIn="wrapper";function NIn(e){let{components:n,...t}=e;return(0,s.yg)(bIn,(0,p.A)({},LIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}NIn.isMDXComponent=!0;const kIn={toc:[]},zIn="wrapper";function PIn(e){let{components:n,...t}=e;return(0,s.yg)(zIn,(0,p.A)({},kIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}PIn.isMDXComponent=!0;const IIn={toc:[]},RIn="wrapper";function WIn(e){let{components:n,...t}=e;return(0,s.yg)(RIn,(0,p.A)({},IIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}WIn.isMDXComponent=!0;const SIn={toc:[]},BIn="wrapper";function GIn(e){let{components:n,...t}=e;return(0,s.yg)(BIn,(0,p.A)({},SIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}GIn.isMDXComponent=!0;const EIn={toc:[]},OIn="wrapper";function UIn(e){let{components:n,...t}=e;return(0,s.yg)(OIn,(0,p.A)({},EIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}UIn.isMDXComponent=!0;const FIn={toc:[]},VIn="wrapper";function qIn(e){let{components:n,...t}=e;return(0,s.yg)(VIn,(0,p.A)({},FIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}qIn.isMDXComponent=!0;const jIn={toc:[]},HIn="wrapper";function YIn(e){let{components:n,...t}=e;return(0,s.yg)(HIn,(0,p.A)({},jIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}YIn.isMDXComponent=!0;const QIn={toc:[]},$In="wrapper";function KIn(e){let{components:n,...t}=e;return(0,s.yg)($In,(0,p.A)({},QIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}KIn.isMDXComponent=!0;const JIn={toc:[]},ZIn="wrapper";function eRn(e){let{components:n,...t}=e;return(0,s.yg)(ZIn,(0,p.A)({},JIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}eRn.isMDXComponent=!0;const nRn={toc:[]},tRn="wrapper";function oRn(e){let{components:n,...t}=e;return(0,s.yg)(tRn,(0,p.A)({},nRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}oRn.isMDXComponent=!0;const pRn={toc:[]},rRn="wrapper";function sRn(e){let{components:n,...t}=e;return(0,s.yg)(rRn,(0,p.A)({},pRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}sRn.isMDXComponent=!0;const cRn={toc:[]},aRn="wrapper";function iRn(e){let{components:n,...t}=e;return(0,s.yg)(aRn,(0,p.A)({},cRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}iRn.isMDXComponent=!0;const lRn={toc:[]},uRn="wrapper";function mRn(e){let{components:n,...t}=e;return(0,s.yg)(uRn,(0,p.A)({},lRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}mRn.isMDXComponent=!0;const yRn={toc:[]},dRn="wrapper";function hRn(e){let{components:n,...t}=e;return(0,s.yg)(dRn,(0,p.A)({},yRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}hRn.isMDXComponent=!0;const gRn={toc:[]},fRn="wrapper";function DRn(e){let{components:n,...t}=e;return(0,s.yg)(fRn,(0,p.A)({},gRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}DRn.isMDXComponent=!0;const MRn={toc:[]},XRn="wrapper";function _Rn(e){let{components:n,...t}=e;return(0,s.yg)(XRn,(0,p.A)({},MRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}_Rn.isMDXComponent=!0;const wRn={toc:[]},TRn="wrapper";function CRn(e){let{components:n,...t}=e;return(0,s.yg)(TRn,(0,p.A)({},wRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}CRn.isMDXComponent=!0;const xRn={toc:[]},ARn="wrapper";function vRn(e){let{components:n,...t}=e;return(0,s.yg)(ARn,(0,p.A)({},xRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}vRn.isMDXComponent=!0;const LRn={toc:[]},bRn="wrapper";function NRn(e){let{components:n,...t}=e;return(0,s.yg)(bRn,(0,p.A)({},LRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}NRn.isMDXComponent=!0;const kRn={toc:[]},zRn="wrapper";function PRn(e){let{components:n,...t}=e;return(0,s.yg)(zRn,(0,p.A)({},kRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}PRn.isMDXComponent=!0;const IRn={toc:[]},RRn="wrapper";function WRn(e){let{components:n,...t}=e;return(0,s.yg)(RRn,(0,p.A)({},IRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}WRn.isMDXComponent=!0;const SRn={toc:[]},BRn="wrapper";function GRn(e){let{components:n,...t}=e;return(0,s.yg)(BRn,(0,p.A)({},SRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}GRn.isMDXComponent=!0;const ERn={toc:[]},ORn="wrapper";function URn(e){let{components:n,...t}=e;return(0,s.yg)(ORn,(0,p.A)({},ERn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}URn.isMDXComponent=!0;const FRn={toc:[]},VRn="wrapper";function qRn(e){let{components:n,...t}=e;return(0,s.yg)(VRn,(0,p.A)({},FRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}qRn.isMDXComponent=!0;const jRn={toc:[]},HRn="wrapper";function YRn(e){let{components:n,...t}=e;return(0,s.yg)(HRn,(0,p.A)({},jRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}YRn.isMDXComponent=!0;const QRn={toc:[]},$Rn="wrapper";function KRn(e){let{components:n,...t}=e;return(0,s.yg)($Rn,(0,p.A)({},QRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}KRn.isMDXComponent=!0;const JRn={toc:[]},ZRn="wrapper";function eWn(e){let{components:n,...t}=e;return(0,s.yg)(ZRn,(0,p.A)({},JRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}eWn.isMDXComponent=!0;const nWn={toc:[]},tWn="wrapper";function oWn(e){let{components:n,...t}=e;return(0,s.yg)(tWn,(0,p.A)({},nWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}oWn.isMDXComponent=!0;const pWn={toc:[]},rWn="wrapper";function sWn(e){let{components:n,...t}=e;return(0,s.yg)(rWn,(0,p.A)({},pWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sWn.isMDXComponent=!0;const cWn={toc:[]},aWn="wrapper";function iWn(e){let{components:n,...t}=e;return(0,s.yg)(aWn,(0,p.A)({},cWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}iWn.isMDXComponent=!0;const lWn={toc:[]},uWn="wrapper";function mWn(e){let{components:n,...t}=e;return(0,s.yg)(uWn,(0,p.A)({},lWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}mWn.isMDXComponent=!0;const yWn={toc:[]},dWn="wrapper";function hWn(e){let{components:n,...t}=e;return(0,s.yg)(dWn,(0,p.A)({},yWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}hWn.isMDXComponent=!0;const gWn={toc:[]},fWn="wrapper";function DWn(e){let{components:n,...t}=e;return(0,s.yg)(fWn,(0,p.A)({},gWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}DWn.isMDXComponent=!0;const MWn={toc:[]},XWn="wrapper";function _Wn(e){let{components:n,...t}=e;return(0,s.yg)(XWn,(0,p.A)({},MWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}_Wn.isMDXComponent=!0;const wWn={toc:[]},TWn="wrapper";function CWn(e){let{components:n,...t}=e;return(0,s.yg)(TWn,(0,p.A)({},wWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}CWn.isMDXComponent=!0;const xWn={toc:[]},AWn="wrapper";function vWn(e){let{components:n,...t}=e;return(0,s.yg)(AWn,(0,p.A)({},xWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}vWn.isMDXComponent=!0;const LWn={toc:[]},bWn="wrapper";function NWn(e){let{components:n,...t}=e;return(0,s.yg)(bWn,(0,p.A)({},LWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}NWn.isMDXComponent=!0;const kWn={toc:[]},zWn="wrapper";function PWn(e){let{components:n,...t}=e;return(0,s.yg)(zWn,(0,p.A)({},kWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}PWn.isMDXComponent=!0;const IWn={toc:[]},RWn="wrapper";function WWn(e){let{components:n,...t}=e;return(0,s.yg)(RWn,(0,p.A)({},IWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}WWn.isMDXComponent=!0;const SWn={toc:[]},BWn="wrapper";function GWn(e){let{components:n,...t}=e;return(0,s.yg)(BWn,(0,p.A)({},SWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}GWn.isMDXComponent=!0;const EWn={toc:[]},OWn="wrapper";function UWn(e){let{components:n,...t}=e;return(0,s.yg)(OWn,(0,p.A)({},EWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}UWn.isMDXComponent=!0;const FWn={toc:[]},VWn="wrapper";function qWn(e){let{components:n,...t}=e;return(0,s.yg)(VWn,(0,p.A)({},FWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}qWn.isMDXComponent=!0;const jWn={toc:[]},HWn="wrapper";function YWn(e){let{components:n,...t}=e;return(0,s.yg)(HWn,(0,p.A)({},jWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}YWn.isMDXComponent=!0;const QWn={toc:[]},$Wn="wrapper";function KWn(e){let{components:n,...t}=e;return(0,s.yg)($Wn,(0,p.A)({},QWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}KWn.isMDXComponent=!0;const JWn={toc:[]},ZWn="wrapper";function eSn(e){let{components:n,...t}=e;return(0,s.yg)(ZWn,(0,p.A)({},JWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}eSn.isMDXComponent=!0;const nSn={toc:[]},tSn="wrapper";function oSn(e){let{components:n,...t}=e;return(0,s.yg)(tSn,(0,p.A)({},nSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}oSn.isMDXComponent=!0;const pSn={toc:[]},rSn="wrapper";function sSn(e){let{components:n,...t}=e;return(0,s.yg)(rSn,(0,p.A)({},pSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}sSn.isMDXComponent=!0;const cSn={toc:[]},aSn="wrapper";function iSn(e){let{components:n,...t}=e;return(0,s.yg)(aSn,(0,p.A)({},cSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}iSn.isMDXComponent=!0;const lSn={toc:[]},uSn="wrapper";function mSn(e){let{components:n,...t}=e;return(0,s.yg)(uSn,(0,p.A)({},lSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}mSn.isMDXComponent=!0;const ySn={toc:[]},dSn="wrapper";function hSn(e){let{components:n,...t}=e;return(0,s.yg)(dSn,(0,p.A)({},ySn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}hSn.isMDXComponent=!0;const gSn={toc:[]},fSn="wrapper";function DSn(e){let{components:n,...t}=e;return(0,s.yg)(fSn,(0,p.A)({},gSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}DSn.isMDXComponent=!0;const MSn={toc:[]},XSn="wrapper";function _Sn(e){let{components:n,...t}=e;return(0,s.yg)(XSn,(0,p.A)({},MSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}_Sn.isMDXComponent=!0;const wSn={toc:[]},TSn="wrapper";function CSn(e){let{components:n,...t}=e;return(0,s.yg)(TSn,(0,p.A)({},wSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CSn.isMDXComponent=!0;const xSn={toc:[]},ASn="wrapper";function vSn(e){let{components:n,...t}=e;return(0,s.yg)(ASn,(0,p.A)({},xSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}vSn.isMDXComponent=!0;const LSn={toc:[]},bSn="wrapper";function NSn(e){let{components:n,...t}=e;return(0,s.yg)(bSn,(0,p.A)({},LSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}NSn.isMDXComponent=!0;const kSn={toc:[]},zSn="wrapper";function PSn(e){let{components:n,...t}=e;return(0,s.yg)(zSn,(0,p.A)({},kSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}PSn.isMDXComponent=!0;const ISn={toc:[]},RSn="wrapper";function WSn(e){let{components:n,...t}=e;return(0,s.yg)(RSn,(0,p.A)({},ISn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}WSn.isMDXComponent=!0;const SSn={toc:[]},BSn="wrapper";function GSn(e){let{components:n,...t}=e;return(0,s.yg)(BSn,(0,p.A)({},SSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}GSn.isMDXComponent=!0;const ESn={toc:[]},OSn="wrapper";function USn(e){let{components:n,...t}=e;return(0,s.yg)(OSn,(0,p.A)({},ESn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}USn.isMDXComponent=!0;const FSn={toc:[]},VSn="wrapper";function qSn(e){let{components:n,...t}=e;return(0,s.yg)(VSn,(0,p.A)({},FSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}qSn.isMDXComponent=!0;const jSn={toc:[]},HSn="wrapper";function YSn(e){let{components:n,...t}=e;return(0,s.yg)(HSn,(0,p.A)({},jSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}YSn.isMDXComponent=!0;const QSn={toc:[]},$Sn="wrapper";function KSn(e){let{components:n,...t}=e;return(0,s.yg)($Sn,(0,p.A)({},QSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}KSn.isMDXComponent=!0;const JSn={toc:[]},ZSn="wrapper";function eBn(e){let{components:n,...t}=e;return(0,s.yg)(ZSn,(0,p.A)({},JSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}eBn.isMDXComponent=!0;const nBn={toc:[]},tBn="wrapper";function oBn(e){let{components:n,...t}=e;return(0,s.yg)(tBn,(0,p.A)({},nBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oBn.isMDXComponent=!0;const pBn={toc:[]},rBn="wrapper";function sBn(e){let{components:n,...t}=e;return(0,s.yg)(rBn,(0,p.A)({},pBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}sBn.isMDXComponent=!0;const cBn={toc:[]},aBn="wrapper";function iBn(e){let{components:n,...t}=e;return(0,s.yg)(aBn,(0,p.A)({},cBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node representing a knot of a ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.yg)("inlineCode",{parentName:"a"},"Spline")),"."))}iBn.isMDXComponent=!0;const lBn={toc:[]},uBn="wrapper";function mBn(e){let{components:n,...t}=e;return(0,s.yg)(uBn,(0,p.A)({},lBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}mBn.isMDXComponent=!0;const yBn={toc:[]},dBn="wrapper";function hBn(e){let{components:n,...t}=e;return(0,s.yg)(dBn,(0,p.A)({},yBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}hBn.isMDXComponent=!0;const gBn={toc:[]},fBn="wrapper";function DBn(e){let{components:n,...t}=e;return(0,s.yg)(fBn,(0,p.A)({},gBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}DBn.isMDXComponent=!0;const MBn={toc:[]},XBn="wrapper";function _Bn(e){let{components:n,...t}=e;return(0,s.yg)(XBn,(0,p.A)({},MBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}_Bn.isMDXComponent=!0;const wBn={toc:[]},TBn="wrapper";function CBn(e){let{components:n,...t}=e;return(0,s.yg)(TBn,(0,p.A)({},wBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}CBn.isMDXComponent=!0;const xBn={toc:[]},ABn="wrapper";function vBn(e){let{components:n,...t}=e;return(0,s.yg)(ABn,(0,p.A)({},xBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}vBn.isMDXComponent=!0;const LBn={toc:[]},bBn="wrapper";function NBn(e){let{components:n,...t}=e;return(0,s.yg)(bBn,(0,p.A)({},LBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}NBn.isMDXComponent=!0;const kBn={toc:[]},zBn="wrapper";function PBn(e){let{components:n,...t}=e;return(0,s.yg)(zBn,(0,p.A)({},kBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0"))}PBn.isMDXComponent=!0;const IBn={toc:[]},RBn="wrapper";function WBn(e){let{components:n,...t}=e;return(0,s.yg)(RBn,(0,p.A)({},IBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}WBn.isMDXComponent=!0;const SBn={toc:[]},BBn="wrapper";function GBn(e){let{components:n,...t}=e;return(0,s.yg)(BBn,(0,p.A)({},SBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}GBn.isMDXComponent=!0;const EBn={toc:[]},OBn="wrapper";function UBn(e){let{components:n,...t}=e;return(0,s.yg)(OBn,(0,p.A)({},EBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}UBn.isMDXComponent=!0;const FBn={toc:[]},VBn="wrapper";function qBn(e){let{components:n,...t}=e;return(0,s.yg)(VBn,(0,p.A)({},FBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}qBn.isMDXComponent=!0;const jBn={toc:[]},HBn="wrapper";function YBn(e){let{components:n,...t}=e;return(0,s.yg)(HBn,(0,p.A)({},jBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mirrored position of the startHandle."))}YBn.isMDXComponent=!0;const QBn={toc:[]},$Bn="wrapper";function KBn(e){let{components:n,...t}=e;return(0,s.yg)($Bn,(0,p.A)({},QBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}KBn.isMDXComponent=!0;const JBn={toc:[]},ZBn="wrapper";function eGn(e){let{components:n,...t}=e;return(0,s.yg)(ZBn,(0,p.A)({},JBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}eGn.isMDXComponent=!0;const nGn={toc:[]},tGn="wrapper";function oGn(e){let{components:n,...t}=e;return(0,s.yg)(tGn,(0,p.A)({},nGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}oGn.isMDXComponent=!0;const pGn={toc:[]},rGn="wrapper";function sGn(e){let{components:n,...t}=e;return(0,s.yg)(rGn,(0,p.A)({},pGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}sGn.isMDXComponent=!0;const cGn={toc:[]},aGn="wrapper";function iGn(e){let{components:n,...t}=e;return(0,s.yg)(aGn,(0,p.A)({},cGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}iGn.isMDXComponent=!0;const lGn={toc:[]},uGn="wrapper";function mGn(e){let{components:n,...t}=e;return(0,s.yg)(uGn,(0,p.A)({},lGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mGn.isMDXComponent=!0;const yGn={toc:[]},dGn="wrapper";function hGn(e){let{components:n,...t}=e;return(0,s.yg)(dGn,(0,p.A)({},yGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}hGn.isMDXComponent=!0;const gGn={toc:[]},fGn="wrapper";function DGn(e){let{components:n,...t}=e;return(0,s.yg)(fGn,(0,p.A)({},gGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}DGn.isMDXComponent=!0;const MGn={toc:[]},XGn="wrapper";function _Gn(e){let{components:n,...t}=e;return(0,s.yg)(XGn,(0,p.A)({},MGn,t,{components:n,mdxType:"MDXLayout"}))}_Gn.isMDXComponent=!0;const wGn={toc:[]},TGn="wrapper";function CGn(e){let{components:n,...t}=e;return(0,s.yg)(TGn,(0,p.A)({},wGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}CGn.isMDXComponent=!0;const xGn={toc:[]},AGn="wrapper";function vGn(e){let{components:n,...t}=e;return(0,s.yg)(AGn,(0,p.A)({},xGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}vGn.isMDXComponent=!0;const LGn={toc:[]},bGn="wrapper";function NGn(e){let{components:n,...t}=e;return(0,s.yg)(bGn,(0,p.A)({},LGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}NGn.isMDXComponent=!0;const kGn={toc:[]},zGn="wrapper";function PGn(e){let{components:n,...t}=e;return(0,s.yg)(zGn,(0,p.A)({},kGn,t,{components:n,mdxType:"MDXLayout"}))}PGn.isMDXComponent=!0;const IGn={toc:[]},RGn="wrapper";function WGn(e){let{components:n,...t}=e;return(0,s.yg)(RGn,(0,p.A)({},IGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}WGn.isMDXComponent=!0;const SGn={toc:[]},BGn="wrapper";function GGn(e){let{components:n,...t}=e;return(0,s.yg)(BGn,(0,p.A)({},SGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mirrored position of the endHandle."))}GGn.isMDXComponent=!0;const EGn={toc:[]},OGn="wrapper";function UGn(e){let{components:n,...t}=e;return(0,s.yg)(OGn,(0,p.A)({},EGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}UGn.isMDXComponent=!0;const FGn={toc:[]},VGn="wrapper";function qGn(e){let{components:n,...t}=e;return(0,s.yg)(VGn,(0,p.A)({},FGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}qGn.isMDXComponent=!0;const jGn={toc:[]},HGn="wrapper";function YGn(e){let{components:n,...t}=e;return(0,s.yg)(HGn,(0,p.A)({},jGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}YGn.isMDXComponent=!0;const QGn={toc:[]},$Gn="wrapper";function KGn(e){let{components:n,...t}=e;return(0,s.yg)($Gn,(0,p.A)({},QGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}KGn.isMDXComponent=!0;const JGn={toc:[]},ZGn="wrapper";function eEn(e){let{components:n,...t}=e;return(0,s.yg)(ZGn,(0,p.A)({},JGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}eEn.isMDXComponent=!0;const nEn={toc:[]},tEn="wrapper";function oEn(e){let{components:n,...t}=e;return(0,s.yg)(tEn,(0,p.A)({},nEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}oEn.isMDXComponent=!0;const pEn={toc:[]},rEn="wrapper";function sEn(e){let{components:n,...t}=e;return(0,s.yg)(rEn,(0,p.A)({},pEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}sEn.isMDXComponent=!0;const cEn={toc:[]},aEn="wrapper";function iEn(e){let{components:n,...t}=e;return(0,s.yg)(aEn,(0,p.A)({},cEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}iEn.isMDXComponent=!0;const lEn={toc:[]},uEn="wrapper";function mEn(e){let{components:n,...t}=e;return(0,s.yg)(uEn,(0,p.A)({},lEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}mEn.isMDXComponent=!0;const yEn={toc:[]},dEn="wrapper";function hEn(e){let{components:n,...t}=e;return(0,s.yg)(dEn,(0,p.A)({},yEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}hEn.isMDXComponent=!0;const gEn={toc:[]},fEn="wrapper";function DEn(e){let{components:n,...t}=e;return(0,s.yg)(fEn,(0,p.A)({},gEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}DEn.isMDXComponent=!0;const MEn={toc:[]},XEn="wrapper";function _En(e){let{components:n,...t}=e;return(0,s.yg)(XEn,(0,p.A)({},MEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}_En.isMDXComponent=!0;const wEn={toc:[]},TEn="wrapper";function CEn(e){let{components:n,...t}=e;return(0,s.yg)(TEn,(0,p.A)({},wEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}CEn.isMDXComponent=!0;const xEn={toc:[]},AEn="wrapper";function vEn(e){let{components:n,...t}=e;return(0,s.yg)(AEn,(0,p.A)({},xEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}vEn.isMDXComponent=!0;const LEn={toc:[]},bEn="wrapper";function NEn(e){let{components:n,...t}=e;return(0,s.yg)(bEn,(0,p.A)({},LEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}NEn.isMDXComponent=!0;const kEn={toc:[]},zEn="wrapper";function PEn(e){let{components:n,...t}=e;return(0,s.yg)(zEn,(0,p.A)({},kEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}PEn.isMDXComponent=!0;const IEn={toc:[]},REn="wrapper";function WEn(e){let{components:n,...t}=e;return(0,s.yg)(REn,(0,p.A)({},IEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}WEn.isMDXComponent=!0;const SEn={toc:[]},BEn="wrapper";function GEn(e){let{components:n,...t}=e;return(0,s.yg)(BEn,(0,p.A)({},SEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}GEn.isMDXComponent=!0;const EEn={toc:[]},OEn="wrapper";function UEn(e){let{components:n,...t}=e;return(0,s.yg)(OEn,(0,p.A)({},EEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}UEn.isMDXComponent=!0;const FEn={toc:[]},VEn="wrapper";function qEn(e){let{components:n,...t}=e;return(0,s.yg)(VEn,(0,p.A)({},FEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}qEn.isMDXComponent=!0;const jEn={toc:[]},HEn="wrapper";function YEn(e){let{components:n,...t}=e;return(0,s.yg)(HEn,(0,p.A)({},jEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}YEn.isMDXComponent=!0;const QEn={toc:[]},$En="wrapper";function KEn(e){let{components:n,...t}=e;return(0,s.yg)($En,(0,p.A)({},QEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}KEn.isMDXComponent=!0;const JEn={toc:[]},ZEn="wrapper";function eOn(e){let{components:n,...t}=e;return(0,s.yg)(ZEn,(0,p.A)({},JEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}eOn.isMDXComponent=!0;const nOn={toc:[]},tOn="wrapper";function oOn(e){let{components:n,...t}=e;return(0,s.yg)(tOn,(0,p.A)({},nOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}oOn.isMDXComponent=!0;const pOn={toc:[]},rOn="wrapper";function sOn(e){let{components:n,...t}=e;return(0,s.yg)(rOn,(0,p.A)({},pOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}sOn.isMDXComponent=!0;const cOn={toc:[]},aOn="wrapper";function iOn(e){let{components:n,...t}=e;return(0,s.yg)(aOn,(0,p.A)({},cOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}iOn.isMDXComponent=!0;const lOn={toc:[]},uOn="wrapper";function mOn(e){let{components:n,...t}=e;return(0,s.yg)(uOn,(0,p.A)({},lOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mOn.isMDXComponent=!0;const yOn={toc:[]},dOn="wrapper";function hOn(e){let{components:n,...t}=e;return(0,s.yg)(dOn,(0,p.A)({},yOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}hOn.isMDXComponent=!0;const gOn={toc:[]},fOn="wrapper";function DOn(e){let{components:n,...t}=e;return(0,s.yg)(fOn,(0,p.A)({},gOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}DOn.isMDXComponent=!0;const MOn={toc:[]},XOn="wrapper";function _On(e){let{components:n,...t}=e;return(0,s.yg)(XOn,(0,p.A)({},MOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}_On.isMDXComponent=!0;const wOn={toc:[]},TOn="wrapper";function COn(e){let{components:n,...t}=e;return(0,s.yg)(TOn,(0,p.A)({},wOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}COn.isMDXComponent=!0;const xOn={toc:[]},AOn="wrapper";function vOn(e){let{components:n,...t}=e;return(0,s.yg)(AOn,(0,p.A)({},xOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vOn.isMDXComponent=!0;const LOn={toc:[]},bOn="wrapper";function NOn(e){let{components:n,...t}=e;return(0,s.yg)(bOn,(0,p.A)({},LOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}NOn.isMDXComponent=!0;const kOn={toc:[]},zOn="wrapper";function POn(e){let{components:n,...t}=e;return(0,s.yg)(zOn,(0,p.A)({},kOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}POn.isMDXComponent=!0;const IOn={toc:[]},ROn="wrapper";function WOn(e){let{components:n,...t}=e;return(0,s.yg)(ROn,(0,p.A)({},IOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}WOn.isMDXComponent=!0;const SOn={toc:[]},BOn="wrapper";function GOn(e){let{components:n,...t}=e;return(0,s.yg)(BOn,(0,p.A)({},SOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GOn.isMDXComponent=!0;const EOn={toc:[]},OOn="wrapper";function UOn(e){let{components:n,...t}=e;return(0,s.yg)(OOn,(0,p.A)({},EOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}UOn.isMDXComponent=!0;const FOn={toc:[]},VOn="wrapper";function qOn(e){let{components:n,...t}=e;return(0,s.yg)(VOn,(0,p.A)({},FOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qOn.isMDXComponent=!0;const jOn={toc:[]},HOn="wrapper";function YOn(e){let{components:n,...t}=e;return(0,s.yg)(HOn,(0,p.A)({},jOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}YOn.isMDXComponent=!0;const QOn={toc:[]},$On="wrapper";function KOn(e){let{components:n,...t}=e;return(0,s.yg)($On,(0,p.A)({},QOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}KOn.isMDXComponent=!0;const JOn={toc:[]},ZOn="wrapper";function eUn(e){let{components:n,...t}=e;return(0,s.yg)(ZOn,(0,p.A)({},JOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}eUn.isMDXComponent=!0;const nUn={toc:[]},tUn="wrapper";function oUn(e){let{components:n,...t}=e;return(0,s.yg)(tUn,(0,p.A)({},nUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oUn.isMDXComponent=!0;const pUn={toc:[]},rUn="wrapper";function sUn(e){let{components:n,...t}=e;return(0,s.yg)(rUn,(0,p.A)({},pUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}sUn.isMDXComponent=!0;const cUn={toc:[]},aUn="wrapper";function iUn(e){let{components:n,...t}=e;return(0,s.yg)(aUn,(0,p.A)({},cUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}iUn.isMDXComponent=!0;const lUn={toc:[]},uUn="wrapper";function mUn(e){let{components:n,...t}=e;return(0,s.yg)(uUn,(0,p.A)({},lUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}mUn.isMDXComponent=!0;const yUn={toc:[]},dUn="wrapper";function hUn(e){let{components:n,...t}=e;return(0,s.yg)(dUn,(0,p.A)({},yUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hUn.isMDXComponent=!0;const gUn={toc:[]},fUn="wrapper";function DUn(e){let{components:n,...t}=e;return(0,s.yg)(fUn,(0,p.A)({},gUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}DUn.isMDXComponent=!0;const MUn={toc:[]},XUn="wrapper";function _Un(e){let{components:n,...t}=e;return(0,s.yg)(XUn,(0,p.A)({},MUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}_Un.isMDXComponent=!0;const wUn={toc:[]},TUn="wrapper";function CUn(e){let{components:n,...t}=e;return(0,s.yg)(TUn,(0,p.A)({},wUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}CUn.isMDXComponent=!0;const xUn={toc:[]},AUn="wrapper";function vUn(e){let{components:n,...t}=e;return(0,s.yg)(AUn,(0,p.A)({},xUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}vUn.isMDXComponent=!0;const LUn={toc:[]},bUn="wrapper";function NUn(e){let{components:n,...t}=e;return(0,s.yg)(bUn,(0,p.A)({},LUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}NUn.isMDXComponent=!0;const kUn={toc:[]},zUn="wrapper";function PUn(e){let{components:n,...t}=e;return(0,s.yg)(zUn,(0,p.A)({},kUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}PUn.isMDXComponent=!0;const IUn={toc:[]},RUn="wrapper";function WUn(e){let{components:n,...t}=e;return(0,s.yg)(RUn,(0,p.A)({},IUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}WUn.isMDXComponent=!0;const SUn={toc:[]},BUn="wrapper";function GUn(e){let{components:n,...t}=e;return(0,s.yg)(BUn,(0,p.A)({},SUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}GUn.isMDXComponent=!0;const EUn={toc:[]},OUn="wrapper";function UUn(e){let{components:n,...t}=e;return(0,s.yg)(OUn,(0,p.A)({},EUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}UUn.isMDXComponent=!0;const FUn={toc:[]},VUn="wrapper";function qUn(e){let{components:n,...t}=e;return(0,s.yg)(VUn,(0,p.A)({},FUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}qUn.isMDXComponent=!0;const jUn={toc:[]},HUn="wrapper";function YUn(e){let{components:n,...t}=e;return(0,s.yg)(HUn,(0,p.A)({},jUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}YUn.isMDXComponent=!0;const QUn={toc:[]},$Un="wrapper";function KUn(e){let{components:n,...t}=e;return(0,s.yg)($Un,(0,p.A)({},QUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}KUn.isMDXComponent=!0;const JUn={toc:[]},ZUn="wrapper";function eFn(e){let{components:n,...t}=e;return(0,s.yg)(ZUn,(0,p.A)({},JUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}eFn.isMDXComponent=!0;const nFn={toc:[]},tFn="wrapper";function oFn(e){let{components:n,...t}=e;return(0,s.yg)(tFn,(0,p.A)({},nFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}oFn.isMDXComponent=!0;const pFn={toc:[]},rFn="wrapper";function sFn(e){let{components:n,...t}=e;return(0,s.yg)(rFn,(0,p.A)({},pFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}sFn.isMDXComponent=!0;const cFn={toc:[]},aFn="wrapper";function iFn(e){let{components:n,...t}=e;return(0,s.yg)(aFn,(0,p.A)({},cFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}iFn.isMDXComponent=!0;const lFn={toc:[]},uFn="wrapper";function mFn(e){let{components:n,...t}=e;return(0,s.yg)(uFn,(0,p.A)({},lFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}mFn.isMDXComponent=!0;const yFn={toc:[]},dFn="wrapper";function hFn(e){let{components:n,...t}=e;return(0,s.yg)(dFn,(0,p.A)({},yFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}hFn.isMDXComponent=!0;const gFn={toc:[]},fFn="wrapper";function DFn(e){let{components:n,...t}=e;return(0,s.yg)(fFn,(0,p.A)({},gFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}DFn.isMDXComponent=!0;const MFn={toc:[]},XFn="wrapper";function _Fn(e){let{components:n,...t}=e;return(0,s.yg)(XFn,(0,p.A)({},MFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_Fn.isMDXComponent=!0;const wFn={toc:[]},TFn="wrapper";function CFn(e){let{components:n,...t}=e;return(0,s.yg)(TFn,(0,p.A)({},wFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}CFn.isMDXComponent=!0;const xFn={toc:[]},AFn="wrapper";function vFn(e){let{components:n,...t}=e;return(0,s.yg)(AFn,(0,p.A)({},xFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}vFn.isMDXComponent=!0;const LFn={toc:[]},bFn="wrapper";function NFn(e){let{components:n,...t}=e;return(0,s.yg)(bFn,(0,p.A)({},LFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}NFn.isMDXComponent=!0;const kFn={toc:[]},zFn="wrapper";function PFn(e){let{components:n,...t}=e;return(0,s.yg)(zFn,(0,p.A)({},kFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}PFn.isMDXComponent=!0;const IFn={toc:[]},RFn="wrapper";function WFn(e){let{components:n,...t}=e;return(0,s.yg)(RFn,(0,p.A)({},IFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}WFn.isMDXComponent=!0;const SFn={toc:[]},BFn="wrapper";function GFn(e){let{components:n,...t}=e;return(0,s.yg)(BFn,(0,p.A)({},SFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}GFn.isMDXComponent=!0;const EFn={toc:[]},OFn="wrapper";function UFn(e){let{components:n,...t}=e;return(0,s.yg)(OFn,(0,p.A)({},EFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}UFn.isMDXComponent=!0;const FFn={toc:[]},VFn="wrapper";function qFn(e){let{components:n,...t}=e;return(0,s.yg)(VFn,(0,p.A)({},FFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}qFn.isMDXComponent=!0;const jFn={toc:[]},HFn="wrapper";function YFn(e){let{components:n,...t}=e;return(0,s.yg)(HFn,(0,p.A)({},jFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}YFn.isMDXComponent=!0;const QFn={toc:[]},$Fn="wrapper";function KFn(e){let{components:n,...t}=e;return(0,s.yg)($Fn,(0,p.A)({},QFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}KFn.isMDXComponent=!0;const JFn={toc:[]},ZFn="wrapper";function eVn(e){let{components:n,...t}=e;return(0,s.yg)(ZFn,(0,p.A)({},JFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eVn.isMDXComponent=!0;const nVn={toc:[]},tVn="wrapper";function oVn(e){let{components:n,...t}=e;return(0,s.yg)(tVn,(0,p.A)({},nVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}oVn.isMDXComponent=!0;const pVn={toc:[]},rVn="wrapper";function sVn(e){let{components:n,...t}=e;return(0,s.yg)(rVn,(0,p.A)({},pVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}sVn.isMDXComponent=!0;const cVn={toc:[]},aVn="wrapper";function iVn(e){let{components:n,...t}=e;return(0,s.yg)(aVn,(0,p.A)({},cVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}iVn.isMDXComponent=!0;const lVn={toc:[]},uVn="wrapper";function mVn(e){let{components:n,...t}=e;return(0,s.yg)(uVn,(0,p.A)({},lVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}mVn.isMDXComponent=!0;const yVn={toc:[]},dVn="wrapper";function hVn(e){let{components:n,...t}=e;return(0,s.yg)(dVn,(0,p.A)({},yVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hVn.isMDXComponent=!0;const gVn={toc:[]},fVn="wrapper";function DVn(e){let{components:n,...t}=e;return(0,s.yg)(fVn,(0,p.A)({},gVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}DVn.isMDXComponent=!0;const MVn={toc:[]},XVn="wrapper";function _Vn(e){let{components:n,...t}=e;return(0,s.yg)(XVn,(0,p.A)({},MVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}_Vn.isMDXComponent=!0;const wVn={toc:[]},TVn="wrapper";function CVn(e){let{components:n,...t}=e;return(0,s.yg)(TVn,(0,p.A)({},wVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}CVn.isMDXComponent=!0;const xVn={toc:[]},AVn="wrapper";function vVn(e){let{components:n,...t}=e;return(0,s.yg)(AVn,(0,p.A)({},xVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vVn.isMDXComponent=!0;const LVn={toc:[]},bVn="wrapper";function NVn(e){let{components:n,...t}=e;return(0,s.yg)(bVn,(0,p.A)({},LVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}NVn.isMDXComponent=!0;const kVn={toc:[]},zVn="wrapper";function PVn(e){let{components:n,...t}=e;return(0,s.yg)(zVn,(0,p.A)({},kVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}PVn.isMDXComponent=!0;const IVn={toc:[]},RVn="wrapper";function WVn(e){let{components:n,...t}=e;return(0,s.yg)(RVn,(0,p.A)({},IVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}WVn.isMDXComponent=!0;const SVn={toc:[]},BVn="wrapper";function GVn(e){let{components:n,...t}=e;return(0,s.yg)(BVn,(0,p.A)({},SVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}GVn.isMDXComponent=!0;const EVn={toc:[]},OVn="wrapper";function UVn(e){let{components:n,...t}=e;return(0,s.yg)(OVn,(0,p.A)({},EVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}UVn.isMDXComponent=!0;const FVn={toc:[]},VVn="wrapper";function qVn(e){let{components:n,...t}=e;return(0,s.yg)(VVn,(0,p.A)({},FVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}qVn.isMDXComponent=!0;const jVn={toc:[]},HVn="wrapper";function YVn(e){let{components:n,...t}=e;return(0,s.yg)(HVn,(0,p.A)({},jVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}YVn.isMDXComponent=!0;const QVn={toc:[]},$Vn="wrapper";function KVn(e){let{components:n,...t}=e;return(0,s.yg)($Vn,(0,p.A)({},QVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}KVn.isMDXComponent=!0;const JVn={toc:[]},ZVn="wrapper";function eqn(e){let{components:n,...t}=e;return(0,s.yg)(ZVn,(0,p.A)({},JVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}eqn.isMDXComponent=!0;const nqn={toc:[]},tqn="wrapper";function oqn(e){let{components:n,...t}=e;return(0,s.yg)(tqn,(0,p.A)({},nqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}oqn.isMDXComponent=!0;const pqn={toc:[]},rqn="wrapper";function sqn(e){let{components:n,...t}=e;return(0,s.yg)(rqn,(0,p.A)({},pqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}sqn.isMDXComponent=!0;const cqn={toc:[]},aqn="wrapper";function iqn(e){let{components:n,...t}=e;return(0,s.yg)(aqn,(0,p.A)({},cqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}iqn.isMDXComponent=!0;const lqn={toc:[]},uqn="wrapper";function mqn(e){let{components:n,...t}=e;return(0,s.yg)(uqn,(0,p.A)({},lqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}mqn.isMDXComponent=!0;const yqn={toc:[]},dqn="wrapper";function hqn(e){let{components:n,...t}=e;return(0,s.yg)(dqn,(0,p.A)({},yqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}hqn.isMDXComponent=!0;const gqn={toc:[]},fqn="wrapper";function Dqn(e){let{components:n,...t}=e;return(0,s.yg)(fqn,(0,p.A)({},gqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Dqn.isMDXComponent=!0;const Mqn={toc:[]},Xqn="wrapper";function _qn(e){let{components:n,...t}=e;return(0,s.yg)(Xqn,(0,p.A)({},Mqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}_qn.isMDXComponent=!0;const wqn={toc:[]},Tqn="wrapper";function Cqn(e){let{components:n,...t}=e;return(0,s.yg)(Tqn,(0,p.A)({},wqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Cqn.isMDXComponent=!0;const xqn={toc:[]},Aqn="wrapper";function vqn(e){let{components:n,...t}=e;return(0,s.yg)(Aqn,(0,p.A)({},xqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}vqn.isMDXComponent=!0;const Lqn={toc:[]},bqn="wrapper";function Nqn(e){let{components:n,...t}=e;return(0,s.yg)(bqn,(0,p.A)({},Lqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Nqn.isMDXComponent=!0;const kqn={toc:[]},zqn="wrapper";function Pqn(e){let{components:n,...t}=e;return(0,s.yg)(zqn,(0,p.A)({},kqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Pqn.isMDXComponent=!0;const Iqn={toc:[]},Rqn="wrapper";function Wqn(e){let{components:n,...t}=e;return(0,s.yg)(Rqn,(0,p.A)({},Iqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Wqn.isMDXComponent=!0;const Sqn={toc:[]},Bqn="wrapper";function Gqn(e){let{components:n,...t}=e;return(0,s.yg)(Bqn,(0,p.A)({},Sqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Gqn.isMDXComponent=!0;const Eqn={toc:[]},Oqn="wrapper";function Uqn(e){let{components:n,...t}=e;return(0,s.yg)(Oqn,(0,p.A)({},Eqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Uqn.isMDXComponent=!0;const Fqn={toc:[]},Vqn="wrapper";function qqn(e){let{components:n,...t}=e;return(0,s.yg)(Vqn,(0,p.A)({},Fqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}qqn.isMDXComponent=!0;const jqn={toc:[]},Hqn="wrapper";function Yqn(e){let{components:n,...t}=e;return(0,s.yg)(Hqn,(0,p.A)({},jqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Yqn.isMDXComponent=!0;const Qqn={toc:[]},$qn="wrapper";function Kqn(e){let{components:n,...t}=e;return(0,s.yg)($qn,(0,p.A)({},Qqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Kqn.isMDXComponent=!0;const Jqn={toc:[]},Zqn="wrapper";function ejn(e){let{components:n,...t}=e;return(0,s.yg)(Zqn,(0,p.A)({},Jqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ejn.isMDXComponent=!0;const njn={toc:[]},tjn="wrapper";function ojn(e){let{components:n,...t}=e;return(0,s.yg)(tjn,(0,p.A)({},njn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ojn.isMDXComponent=!0;const pjn={toc:[]},rjn="wrapper";function sjn(e){let{components:n,...t}=e;return(0,s.yg)(rjn,(0,p.A)({},pjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}sjn.isMDXComponent=!0;const cjn={toc:[]},ajn="wrapper";function ijn(e){let{components:n,...t}=e;return(0,s.yg)(ajn,(0,p.A)({},cjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}ijn.isMDXComponent=!0;const ljn={toc:[]},ujn="wrapper";function mjn(e){let{components:n,...t}=e;return(0,s.yg)(ujn,(0,p.A)({},ljn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}mjn.isMDXComponent=!0;const yjn={toc:[]},djn="wrapper";function hjn(e){let{components:n,...t}=e;return(0,s.yg)(djn,(0,p.A)({},yjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}hjn.isMDXComponent=!0;const gjn={toc:[]},fjn="wrapper";function Djn(e){let{components:n,...t}=e;return(0,s.yg)(fjn,(0,p.A)({},gjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Djn.isMDXComponent=!0;const Mjn={toc:[]},Xjn="wrapper";function _jn(e){let{components:n,...t}=e;return(0,s.yg)(Xjn,(0,p.A)({},Mjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}_jn.isMDXComponent=!0;const wjn={toc:[]},Tjn="wrapper";function Cjn(e){let{components:n,...t}=e;return(0,s.yg)(Tjn,(0,p.A)({},wjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Cjn.isMDXComponent=!0;const xjn={toc:[]},Ajn="wrapper";function vjn(e){let{components:n,...t}=e;return(0,s.yg)(Ajn,(0,p.A)({},xjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}vjn.isMDXComponent=!0;const Ljn={toc:[]},bjn="wrapper";function Njn(e){let{components:n,...t}=e;return(0,s.yg)(bjn,(0,p.A)({},Ljn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Njn.isMDXComponent=!0;const kjn={toc:[]},zjn="wrapper";function Pjn(e){let{components:n,...t}=e;return(0,s.yg)(zjn,(0,p.A)({},kjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Pjn.isMDXComponent=!0;const Ijn={toc:[]},Rjn="wrapper";function Wjn(e){let{components:n,...t}=e;return(0,s.yg)(Rjn,(0,p.A)({},Ijn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wjn.isMDXComponent=!0;const Sjn={toc:[]},Bjn="wrapper";function Gjn(e){let{components:n,...t}=e;return(0,s.yg)(Bjn,(0,p.A)({},Sjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Gjn.isMDXComponent=!0;const Ejn={toc:[]},Ojn="wrapper";function Ujn(e){let{components:n,...t}=e;return(0,s.yg)(Ojn,(0,p.A)({},Ejn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ujn.isMDXComponent=!0;const Fjn={toc:[]},Vjn="wrapper";function qjn(e){let{components:n,...t}=e;return(0,s.yg)(Vjn,(0,p.A)({},Fjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qjn.isMDXComponent=!0;const jjn={toc:[]},Hjn="wrapper";function Yjn(e){let{components:n,...t}=e;return(0,s.yg)(Hjn,(0,p.A)({},jjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Yjn.isMDXComponent=!0;const Qjn={toc:[]},$jn="wrapper";function Kjn(e){let{components:n,...t}=e;return(0,s.yg)($jn,(0,p.A)({},Qjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Kjn.isMDXComponent=!0;const Jjn={toc:[]},Zjn="wrapper";function eHn(e){let{components:n,...t}=e;return(0,s.yg)(Zjn,(0,p.A)({},Jjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}eHn.isMDXComponent=!0;const nHn={toc:[]},tHn="wrapper";function oHn(e){let{components:n,...t}=e;return(0,s.yg)(tHn,(0,p.A)({},nHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}oHn.isMDXComponent=!0;const pHn={toc:[]},rHn="wrapper";function sHn(e){let{components:n,...t}=e;return(0,s.yg)(rHn,(0,p.A)({},pHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}sHn.isMDXComponent=!0;const cHn={toc:[]},aHn="wrapper";function iHn(e){let{components:n,...t}=e;return(0,s.yg)(aHn,(0,p.A)({},cHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for rendering equations with LaTeX."))}iHn.isMDXComponent=!0;const lHn={toc:[]},uHn="wrapper";function mHn(e){let{components:n,...t}=e;return(0,s.yg)(uHn,(0,p.A)({},lHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}mHn.isMDXComponent=!0;const yHn={toc:[]},dHn="wrapper";function hHn(e){let{components:n,...t}=e;return(0,s.yg)(dHn,(0,p.A)({},yHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}hHn.isMDXComponent=!0;const gHn={toc:[]},fHn="wrapper";function DHn(e){let{components:n,...t}=e;return(0,s.yg)(fHn,(0,p.A)({},gHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}DHn.isMDXComponent=!0;const MHn={toc:[]},XHn="wrapper";function _Hn(e){let{components:n,...t}=e;return(0,s.yg)(XHn,(0,p.A)({},MHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}_Hn.isMDXComponent=!0;const wHn={toc:[]},THn="wrapper";function CHn(e){let{components:n,...t}=e;return(0,s.yg)(THn,(0,p.A)({},wHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}CHn.isMDXComponent=!0;const xHn={toc:[]},AHn="wrapper";function vHn(e){let{components:n,...t}=e;return(0,s.yg)(AHn,(0,p.A)({},xHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}vHn.isMDXComponent=!0;const LHn={toc:[]},bHn="wrapper";function NHn(e){let{components:n,...t}=e;return(0,s.yg)(bHn,(0,p.A)({},LHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}NHn.isMDXComponent=!0;const kHn={toc:[]},zHn="wrapper";function PHn(e){let{components:n,...t}=e;return(0,s.yg)(zHn,(0,p.A)({},kHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}PHn.isMDXComponent=!0;const IHn={toc:[]},RHn="wrapper";function WHn(e){let{components:n,...t}=e;return(0,s.yg)(RHn,(0,p.A)({},IHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}WHn.isMDXComponent=!0;const SHn={toc:[]},BHn="wrapper";function GHn(e){let{components:n,...t}=e;return(0,s.yg)(BHn,(0,p.A)({},SHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}GHn.isMDXComponent=!0;const EHn={toc:[]},OHn="wrapper";function UHn(e){let{components:n,...t}=e;return(0,s.yg)(OHn,(0,p.A)({},EHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}UHn.isMDXComponent=!0;const FHn={toc:[]},VHn="wrapper";function qHn(e){let{components:n,...t}=e;return(0,s.yg)(VHn,(0,p.A)({},FHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}qHn.isMDXComponent=!0;const jHn={toc:[]},HHn="wrapper";function YHn(e){let{components:n,...t}=e;return(0,s.yg)(HHn,(0,p.A)({},jHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}YHn.isMDXComponent=!0;const QHn={toc:[]},$Hn="wrapper";function KHn(e){let{components:n,...t}=e;return(0,s.yg)($Hn,(0,p.A)({},QHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}KHn.isMDXComponent=!0;const JHn={toc:[]},ZHn="wrapper";function eYn(e){let{components:n,...t}=e;return(0,s.yg)(ZHn,(0,p.A)({},JHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}eYn.isMDXComponent=!0;const nYn={toc:[]},tYn="wrapper";function oYn(e){let{components:n,...t}=e;return(0,s.yg)(tYn,(0,p.A)({},nYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}oYn.isMDXComponent=!0;const pYn={toc:[]},rYn="wrapper";function sYn(e){let{components:n,...t}=e;return(0,s.yg)(rYn,(0,p.A)({},pYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}sYn.isMDXComponent=!0;const cYn={toc:[]},aYn="wrapper";function iYn(e){let{components:n,...t}=e;return(0,s.yg)(aYn,(0,p.A)({},cYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}iYn.isMDXComponent=!0;const lYn={toc:[]},uYn="wrapper";function mYn(e){let{components:n,...t}=e;return(0,s.yg)(uYn,(0,p.A)({},lYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}mYn.isMDXComponent=!0;const yYn={toc:[]},dYn="wrapper";function hYn(e){let{components:n,...t}=e;return(0,s.yg)(dYn,(0,p.A)({},yYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}hYn.isMDXComponent=!0;const gYn={toc:[]},fYn="wrapper";function DYn(e){let{components:n,...t}=e;return(0,s.yg)(fYn,(0,p.A)({},gYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}DYn.isMDXComponent=!0;const MYn={toc:[]},XYn="wrapper";function _Yn(e){let{components:n,...t}=e;return(0,s.yg)(XYn,(0,p.A)({},MYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}_Yn.isMDXComponent=!0;const wYn={toc:[]},TYn="wrapper";function CYn(e){let{components:n,...t}=e;return(0,s.yg)(TYn,(0,p.A)({},wYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}CYn.isMDXComponent=!0;const xYn={toc:[]},AYn="wrapper";function vYn(e){let{components:n,...t}=e;return(0,s.yg)(AYn,(0,p.A)({},xYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}vYn.isMDXComponent=!0;const LYn={toc:[]},bYn="wrapper";function NYn(e){let{components:n,...t}=e;return(0,s.yg)(bYn,(0,p.A)({},LYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}NYn.isMDXComponent=!0;const kYn={toc:[]},zYn="wrapper";function PYn(e){let{components:n,...t}=e;return(0,s.yg)(zYn,(0,p.A)({},kYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}PYn.isMDXComponent=!0;const IYn={toc:[]},RYn="wrapper";function WYn(e){let{components:n,...t}=e;return(0,s.yg)(RYn,(0,p.A)({},IYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}WYn.isMDXComponent=!0;const SYn={toc:[]},BYn="wrapper";function GYn(e){let{components:n,...t}=e;return(0,s.yg)(BYn,(0,p.A)({},SYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}GYn.isMDXComponent=!0;const EYn={toc:[]},OYn="wrapper";function UYn(e){let{components:n,...t}=e;return(0,s.yg)(OYn,(0,p.A)({},EYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}UYn.isMDXComponent=!0;const FYn={toc:[]},VYn="wrapper";function qYn(e){let{components:n,...t}=e;return(0,s.yg)(VYn,(0,p.A)({},FYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}qYn.isMDXComponent=!0;const jYn={toc:[]},HYn="wrapper";function YYn(e){let{components:n,...t}=e;return(0,s.yg)(HYn,(0,p.A)({},jYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}YYn.isMDXComponent=!0;const QYn={toc:[]},$Yn="wrapper";function KYn(e){let{components:n,...t}=e;return(0,s.yg)($Yn,(0,p.A)({},QYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}KYn.isMDXComponent=!0;const JYn={toc:[]},ZYn="wrapper";function eQn(e){let{components:n,...t}=e;return(0,s.yg)(ZYn,(0,p.A)({},JYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}eQn.isMDXComponent=!0;const nQn={toc:[]},tQn="wrapper";function oQn(e){let{components:n,...t}=e;return(0,s.yg)(tQn,(0,p.A)({},nQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}oQn.isMDXComponent=!0;const pQn={toc:[]},rQn="wrapper";function sQn(e){let{components:n,...t}=e;return(0,s.yg)(rQn,(0,p.A)({},pQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}sQn.isMDXComponent=!0;const cQn={toc:[]},aQn="wrapper";function iQn(e){let{components:n,...t}=e;return(0,s.yg)(aQn,(0,p.A)({},cQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}iQn.isMDXComponent=!0;const lQn={toc:[]},uQn="wrapper";function mQn(e){let{components:n,...t}=e;return(0,s.yg)(uQn,(0,p.A)({},lQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}mQn.isMDXComponent=!0;const yQn={toc:[]},dQn="wrapper";function hQn(e){let{components:n,...t}=e;return(0,s.yg)(dQn,(0,p.A)({},yQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}hQn.isMDXComponent=!0;const gQn={toc:[]},fQn="wrapper";function DQn(e){let{components:n,...t}=e;return(0,s.yg)(fQn,(0,p.A)({},gQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}DQn.isMDXComponent=!0;const MQn={toc:[]},XQn="wrapper";function _Qn(e){let{components:n,...t}=e;return(0,s.yg)(XQn,(0,p.A)({},MQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}_Qn.isMDXComponent=!0;const wQn={toc:[]},TQn="wrapper";function CQn(e){let{components:n,...t}=e;return(0,s.yg)(TQn,(0,p.A)({},wQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}CQn.isMDXComponent=!0;const xQn={toc:[]},AQn="wrapper";function vQn(e){let{components:n,...t}=e;return(0,s.yg)(AQn,(0,p.A)({},xQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}vQn.isMDXComponent=!0;const LQn={toc:[]},bQn="wrapper";function NQn(e){let{components:n,...t}=e;return(0,s.yg)(bQn,(0,p.A)({},LQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}NQn.isMDXComponent=!0;const kQn={toc:[]},zQn="wrapper";function PQn(e){let{components:n,...t}=e;return(0,s.yg)(zQn,(0,p.A)({},kQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}PQn.isMDXComponent=!0;const IQn={toc:[]},RQn="wrapper";function WQn(e){let{components:n,...t}=e;return(0,s.yg)(RQn,(0,p.A)({},IQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}WQn.isMDXComponent=!0;const SQn={toc:[]},BQn="wrapper";function GQn(e){let{components:n,...t}=e;return(0,s.yg)(BQn,(0,p.A)({},SQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}GQn.isMDXComponent=!0;const EQn={toc:[]},OQn="wrapper";function UQn(e){let{components:n,...t}=e;return(0,s.yg)(OQn,(0,p.A)({},EQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}UQn.isMDXComponent=!0;const FQn={toc:[]},VQn="wrapper";function qQn(e){let{components:n,...t}=e;return(0,s.yg)(VQn,(0,p.A)({},FQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}qQn.isMDXComponent=!0;const jQn={toc:[]},HQn="wrapper";function YQn(e){let{components:n,...t}=e;return(0,s.yg)(HQn,(0,p.A)({},jQn,t,{components:n,mdxType:"MDXLayout"}))}YQn.isMDXComponent=!0;const QQn={toc:[]},$Qn="wrapper";function KQn(e){let{components:n,...t}=e;return(0,s.yg)($Qn,(0,p.A)({},QQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}KQn.isMDXComponent=!0;const JQn={toc:[]},ZQn="wrapper";function e$n(e){let{components:n,...t}=e;return(0,s.yg)(ZQn,(0,p.A)({},JQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}e$n.isMDXComponent=!0;const n$n={toc:[]},t$n="wrapper";function o$n(e){let{components:n,...t}=e;return(0,s.yg)(t$n,(0,p.A)({},n$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}o$n.isMDXComponent=!0;const p$n={toc:[]},r$n="wrapper";function s$n(e){let{components:n,...t}=e;return(0,s.yg)(r$n,(0,p.A)({},p$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}s$n.isMDXComponent=!0;const c$n={toc:[]},a$n="wrapper";function i$n(e){let{components:n,...t}=e;return(0,s.yg)(a$n,(0,p.A)({},c$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}i$n.isMDXComponent=!0;const l$n={toc:[]},u$n="wrapper";function m$n(e){let{components:n,...t}=e;return(0,s.yg)(u$n,(0,p.A)({},l$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}m$n.isMDXComponent=!0;const y$n={toc:[]},d$n="wrapper";function h$n(e){let{components:n,...t}=e;return(0,s.yg)(d$n,(0,p.A)({},y$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}h$n.isMDXComponent=!0;const g$n={toc:[]},f$n="wrapper";function D$n(e){let{components:n,...t}=e;return(0,s.yg)(f$n,(0,p.A)({},g$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}D$n.isMDXComponent=!0;const M$n={toc:[]},X$n="wrapper";function _$n(e){let{components:n,...t}=e;return(0,s.yg)(X$n,(0,p.A)({},M$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}_$n.isMDXComponent=!0;const w$n={toc:[]},T$n="wrapper";function C$n(e){let{components:n,...t}=e;return(0,s.yg)(T$n,(0,p.A)({},w$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}C$n.isMDXComponent=!0;const x$n={toc:[]},A$n="wrapper";function v$n(e){let{components:n,...t}=e;return(0,s.yg)(A$n,(0,p.A)({},x$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}v$n.isMDXComponent=!0;const L$n={toc:[]},b$n="wrapper";function N$n(e){let{components:n,...t}=e;return(0,s.yg)(b$n,(0,p.A)({},L$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}N$n.isMDXComponent=!0;const k$n={toc:[]},z$n="wrapper";function P$n(e){let{components:n,...t}=e;return(0,s.yg)(z$n,(0,p.A)({},k$n,t,{components:n,mdxType:"MDXLayout"}))}P$n.isMDXComponent=!0;const I$n={toc:[]},R$n="wrapper";function W$n(e){let{components:n,...t}=e;return(0,s.yg)(R$n,(0,p.A)({},I$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}W$n.isMDXComponent=!0;const S$n={toc:[]},B$n="wrapper";function G$n(e){let{components:n,...t}=e;return(0,s.yg)(B$n,(0,p.A)({},S$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}G$n.isMDXComponent=!0;const E$n={toc:[]},O$n="wrapper";function U$n(e){let{components:n,...t}=e;return(0,s.yg)(O$n,(0,p.A)({},E$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}U$n.isMDXComponent=!0;const F$n={toc:[]},V$n="wrapper";function q$n(e){let{components:n,...t}=e;return(0,s.yg)(V$n,(0,p.A)({},F$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}q$n.isMDXComponent=!0;const j$n={toc:[]},H$n="wrapper";function Y$n(e){let{components:n,...t}=e;return(0,s.yg)(H$n,(0,p.A)({},j$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Y$n.isMDXComponent=!0;const Q$n={toc:[]},$$n="wrapper";function K$n(e){let{components:n,...t}=e;return(0,s.yg)($$n,(0,p.A)({},Q$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}K$n.isMDXComponent=!0;const J$n={toc:[]},Z$n="wrapper";function eKn(e){let{components:n,...t}=e;return(0,s.yg)(Z$n,(0,p.A)({},J$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}eKn.isMDXComponent=!0;const nKn={toc:[]},tKn="wrapper";function oKn(e){let{components:n,...t}=e;return(0,s.yg)(tKn,(0,p.A)({},nKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}oKn.isMDXComponent=!0;const pKn={toc:[]},rKn="wrapper";function sKn(e){let{components:n,...t}=e;return(0,s.yg)(rKn,(0,p.A)({},pKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}sKn.isMDXComponent=!0;const cKn={toc:[]},aKn="wrapper";function iKn(e){let{components:n,...t}=e;return(0,s.yg)(aKn,(0,p.A)({},cKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}iKn.isMDXComponent=!0;const lKn={toc:[]},uKn="wrapper";function mKn(e){let{components:n,...t}=e;return(0,s.yg)(uKn,(0,p.A)({},lKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}mKn.isMDXComponent=!0;const yKn={toc:[]},dKn="wrapper";function hKn(e){let{components:n,...t}=e;return(0,s.yg)(dKn,(0,p.A)({},yKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}hKn.isMDXComponent=!0;const gKn={toc:[]},fKn="wrapper";function DKn(e){let{components:n,...t}=e;return(0,s.yg)(fKn,(0,p.A)({},gKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}DKn.isMDXComponent=!0;const MKn={toc:[]},XKn="wrapper";function _Kn(e){let{components:n,...t}=e;return(0,s.yg)(XKn,(0,p.A)({},MKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}_Kn.isMDXComponent=!0;const wKn={toc:[]},TKn="wrapper";function CKn(e){let{components:n,...t}=e;return(0,s.yg)(TKn,(0,p.A)({},wKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}CKn.isMDXComponent=!0;const xKn={toc:[]},AKn="wrapper";function vKn(e){let{components:n,...t}=e;return(0,s.yg)(AKn,(0,p.A)({},xKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vKn.isMDXComponent=!0;const LKn={toc:[]},bKn="wrapper";function NKn(e){let{components:n,...t}=e;return(0,s.yg)(bKn,(0,p.A)({},LKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}NKn.isMDXComponent=!0;const kKn={toc:[]},zKn="wrapper";function PKn(e){let{components:n,...t}=e;return(0,s.yg)(zKn,(0,p.A)({},kKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}PKn.isMDXComponent=!0;const IKn={toc:[]},RKn="wrapper";function WKn(e){let{components:n,...t}=e;return(0,s.yg)(RKn,(0,p.A)({},IKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}WKn.isMDXComponent=!0;const SKn={toc:[]},BKn="wrapper";function GKn(e){let{components:n,...t}=e;return(0,s.yg)(BKn,(0,p.A)({},SKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}GKn.isMDXComponent=!0;const EKn={toc:[]},OKn="wrapper";function UKn(e){let{components:n,...t}=e;return(0,s.yg)(OKn,(0,p.A)({},EKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}UKn.isMDXComponent=!0;const FKn={toc:[]},VKn="wrapper";function qKn(e){let{components:n,...t}=e;return(0,s.yg)(VKn,(0,p.A)({},FKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}qKn.isMDXComponent=!0;const jKn={toc:[]},HKn="wrapper";function YKn(e){let{components:n,...t}=e;return(0,s.yg)(HKn,(0,p.A)({},jKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}YKn.isMDXComponent=!0;const QKn={toc:[]},$Kn="wrapper";function KKn(e){let{components:n,...t}=e;return(0,s.yg)($Kn,(0,p.A)({},QKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}KKn.isMDXComponent=!0;const JKn={toc:[]},ZKn="wrapper";function eJn(e){let{components:n,...t}=e;return(0,s.yg)(ZKn,(0,p.A)({},JKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}eJn.isMDXComponent=!0;const nJn={toc:[]},tJn="wrapper";function oJn(e){let{components:n,...t}=e;return(0,s.yg)(tJn,(0,p.A)({},nJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}oJn.isMDXComponent=!0;const pJn={toc:[]},rJn="wrapper";function sJn(e){let{components:n,...t}=e;return(0,s.yg)(rJn,(0,p.A)({},pJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}sJn.isMDXComponent=!0;const cJn={toc:[]},aJn="wrapper";function iJn(e){let{components:n,...t}=e;return(0,s.yg)(aJn,(0,p.A)({},cJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}iJn.isMDXComponent=!0;const lJn={toc:[]},uJn="wrapper";function mJn(e){let{components:n,...t}=e;return(0,s.yg)(uJn,(0,p.A)({},lJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mJn.isMDXComponent=!0;const yJn={toc:[]},dJn="wrapper";function hJn(e){let{components:n,...t}=e;return(0,s.yg)(dJn,(0,p.A)({},yJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hJn.isMDXComponent=!0;const gJn={toc:[]},fJn="wrapper";function DJn(e){let{components:n,...t}=e;return(0,s.yg)(fJn,(0,p.A)({},gJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}DJn.isMDXComponent=!0;const MJn={toc:[]},XJn="wrapper";function _Jn(e){let{components:n,...t}=e;return(0,s.yg)(XJn,(0,p.A)({},MJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}_Jn.isMDXComponent=!0;const wJn={toc:[]},TJn="wrapper";function CJn(e){let{components:n,...t}=e;return(0,s.yg)(TJn,(0,p.A)({},wJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}CJn.isMDXComponent=!0;const xJn={toc:[]},AJn="wrapper";function vJn(e){let{components:n,...t}=e;return(0,s.yg)(AJn,(0,p.A)({},xJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}vJn.isMDXComponent=!0;const LJn={toc:[]},bJn="wrapper";function NJn(e){let{components:n,...t}=e;return(0,s.yg)(bJn,(0,p.A)({},LJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}NJn.isMDXComponent=!0;const kJn={toc:[]},zJn="wrapper";function PJn(e){let{components:n,...t}=e;return(0,s.yg)(zJn,(0,p.A)({},kJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}PJn.isMDXComponent=!0;const IJn={toc:[]},RJn="wrapper";function WJn(e){let{components:n,...t}=e;return(0,s.yg)(RJn,(0,p.A)({},IJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}WJn.isMDXComponent=!0;const SJn={toc:[]},BJn="wrapper";function GJn(e){let{components:n,...t}=e;return(0,s.yg)(BJn,(0,p.A)({},SJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}GJn.isMDXComponent=!0;const EJn={toc:[]},OJn="wrapper";function UJn(e){let{components:n,...t}=e;return(0,s.yg)(OJn,(0,p.A)({},EJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}UJn.isMDXComponent=!0;const FJn={toc:[]},VJn="wrapper";function qJn(e){let{components:n,...t}=e;return(0,s.yg)(VJn,(0,p.A)({},FJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}qJn.isMDXComponent=!0;const jJn={toc:[]},HJn="wrapper";function YJn(e){let{components:n,...t}=e;return(0,s.yg)(HJn,(0,p.A)({},jJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}YJn.isMDXComponent=!0;const QJn={toc:[]},$Jn="wrapper";function KJn(e){let{components:n,...t}=e;return(0,s.yg)($Jn,(0,p.A)({},QJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}KJn.isMDXComponent=!0;const JJn={toc:[]},ZJn="wrapper";function eZn(e){let{components:n,...t}=e;return(0,s.yg)(ZJn,(0,p.A)({},JJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}eZn.isMDXComponent=!0;const nZn={toc:[]},tZn="wrapper";function oZn(e){let{components:n,...t}=e;return(0,s.yg)(tZn,(0,p.A)({},nZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}oZn.isMDXComponent=!0;const pZn={toc:[]},rZn="wrapper";function sZn(e){let{components:n,...t}=e;return(0,s.yg)(rZn,(0,p.A)({},pZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}sZn.isMDXComponent=!0;const cZn={toc:[]},aZn="wrapper";function iZn(e){let{components:n,...t}=e;return(0,s.yg)(aZn,(0,p.A)({},cZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}iZn.isMDXComponent=!0;const lZn={toc:[]},uZn="wrapper";function mZn(e){let{components:n,...t}=e;return(0,s.yg)(uZn,(0,p.A)({},lZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}mZn.isMDXComponent=!0;const yZn={toc:[]},dZn="wrapper";function hZn(e){let{components:n,...t}=e;return(0,s.yg)(dZn,(0,p.A)({},yZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}hZn.isMDXComponent=!0;const gZn={toc:[]},fZn="wrapper";function DZn(e){let{components:n,...t}=e;return(0,s.yg)(fZn,(0,p.A)({},gZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}DZn.isMDXComponent=!0;const MZn={toc:[]},XZn="wrapper";function _Zn(e){let{components:n,...t}=e;return(0,s.yg)(XZn,(0,p.A)({},MZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}_Zn.isMDXComponent=!0;const wZn={toc:[]},TZn="wrapper";function CZn(e){let{components:n,...t}=e;return(0,s.yg)(TZn,(0,p.A)({},wZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}CZn.isMDXComponent=!0;const xZn={toc:[]},AZn="wrapper";function vZn(e){let{components:n,...t}=e;return(0,s.yg)(AZn,(0,p.A)({},xZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}vZn.isMDXComponent=!0;const LZn={toc:[]},bZn="wrapper";function NZn(e){let{components:n,...t}=e;return(0,s.yg)(bZn,(0,p.A)({},LZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}NZn.isMDXComponent=!0;const kZn={toc:[]},zZn="wrapper";function PZn(e){let{components:n,...t}=e;return(0,s.yg)(zZn,(0,p.A)({},kZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}PZn.isMDXComponent=!0;const IZn={toc:[]},RZn="wrapper";function WZn(e){let{components:n,...t}=e;return(0,s.yg)(RZn,(0,p.A)({},IZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}WZn.isMDXComponent=!0;const SZn={toc:[]},BZn="wrapper";function GZn(e){let{components:n,...t}=e;return(0,s.yg)(BZn,(0,p.A)({},SZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GZn.isMDXComponent=!0;const EZn={toc:[]},OZn="wrapper";function UZn(e){let{components:n,...t}=e;return(0,s.yg)(OZn,(0,p.A)({},EZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}UZn.isMDXComponent=!0;const FZn={toc:[]},VZn="wrapper";function qZn(e){let{components:n,...t}=e;return(0,s.yg)(VZn,(0,p.A)({},FZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qZn.isMDXComponent=!0;const jZn={toc:[]},HZn="wrapper";function YZn(e){let{components:n,...t}=e;return(0,s.yg)(HZn,(0,p.A)({},jZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}YZn.isMDXComponent=!0;const QZn={toc:[]},$Zn="wrapper";function KZn(e){let{components:n,...t}=e;return(0,s.yg)($Zn,(0,p.A)({},QZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}KZn.isMDXComponent=!0;const JZn={toc:[]},ZZn="wrapper";function e0n(e){let{components:n,...t}=e;return(0,s.yg)(ZZn,(0,p.A)({},JZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}e0n.isMDXComponent=!0;const n0n={toc:[]},t0n="wrapper";function o0n(e){let{components:n,...t}=e;return(0,s.yg)(t0n,(0,p.A)({},n0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}o0n.isMDXComponent=!0;const p0n={toc:[]},r0n="wrapper";function s0n(e){let{components:n,...t}=e;return(0,s.yg)(r0n,(0,p.A)({},p0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}s0n.isMDXComponent=!0;const c0n={toc:[]},a0n="wrapper";function i0n(e){let{components:n,...t}=e;return(0,s.yg)(a0n,(0,p.A)({},c0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}i0n.isMDXComponent=!0;const l0n={toc:[]},u0n="wrapper";function m0n(e){let{components:n,...t}=e;return(0,s.yg)(u0n,(0,p.A)({},l0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}m0n.isMDXComponent=!0;const y0n={toc:[]},d0n="wrapper";function h0n(e){let{components:n,...t}=e;return(0,s.yg)(d0n,(0,p.A)({},y0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}h0n.isMDXComponent=!0;const g0n={toc:[]},f0n="wrapper";function D0n(e){let{components:n,...t}=e;return(0,s.yg)(f0n,(0,p.A)({},g0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}D0n.isMDXComponent=!0;const M0n={toc:[]},X0n="wrapper";function _0n(e){let{components:n,...t}=e;return(0,s.yg)(X0n,(0,p.A)({},M0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_0n.isMDXComponent=!0;const w0n={toc:[]},T0n="wrapper";function C0n(e){let{components:n,...t}=e;return(0,s.yg)(T0n,(0,p.A)({},w0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}C0n.isMDXComponent=!0;const x0n={toc:[]},A0n="wrapper";function v0n(e){let{components:n,...t}=e;return(0,s.yg)(A0n,(0,p.A)({},x0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}v0n.isMDXComponent=!0;const L0n={toc:[]},b0n="wrapper";function N0n(e){let{components:n,...t}=e;return(0,s.yg)(b0n,(0,p.A)({},L0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}N0n.isMDXComponent=!0;const k0n={toc:[]},z0n="wrapper";function P0n(e){let{components:n,...t}=e;return(0,s.yg)(z0n,(0,p.A)({},k0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}P0n.isMDXComponent=!0;const I0n={toc:[]},R0n="wrapper";function W0n(e){let{components:n,...t}=e;return(0,s.yg)(R0n,(0,p.A)({},I0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}W0n.isMDXComponent=!0;const S0n={toc:[]},B0n="wrapper";function G0n(e){let{components:n,...t}=e;return(0,s.yg)(B0n,(0,p.A)({},S0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}G0n.isMDXComponent=!0;const E0n={toc:[]},O0n="wrapper";function U0n(e){let{components:n,...t}=e;return(0,s.yg)(O0n,(0,p.A)({},E0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}U0n.isMDXComponent=!0;const F0n={toc:[]},V0n="wrapper";function q0n(e){let{components:n,...t}=e;return(0,s.yg)(V0n,(0,p.A)({},F0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}q0n.isMDXComponent=!0;const j0n={toc:[]},H0n="wrapper";function Y0n(e){let{components:n,...t}=e;return(0,s.yg)(H0n,(0,p.A)({},j0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}Y0n.isMDXComponent=!0;const Q0n={toc:[]},$0n="wrapper";function K0n(e){let{components:n,...t}=e;return(0,s.yg)($0n,(0,p.A)({},Q0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}K0n.isMDXComponent=!0;const J0n={toc:[]},Z0n="wrapper";function e2n(e){let{components:n,...t}=e;return(0,s.yg)(Z0n,(0,p.A)({},J0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}e2n.isMDXComponent=!0;const n2n={toc:[]},t2n="wrapper";function o2n(e){let{components:n,...t}=e;return(0,s.yg)(t2n,(0,p.A)({},n2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}o2n.isMDXComponent=!0;const p2n={toc:[]},r2n="wrapper";function s2n(e){let{components:n,...t}=e;return(0,s.yg)(r2n,(0,p.A)({},p2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}s2n.isMDXComponent=!0;const c2n={toc:[]},a2n="wrapper";function i2n(e){let{components:n,...t}=e;return(0,s.yg)(a2n,(0,p.A)({},c2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}i2n.isMDXComponent=!0;const l2n={toc:[]},u2n="wrapper";function m2n(e){let{components:n,...t}=e;return(0,s.yg)(u2n,(0,p.A)({},l2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}m2n.isMDXComponent=!0;const y2n={toc:[]},d2n="wrapper";function h2n(e){let{components:n,...t}=e;return(0,s.yg)(d2n,(0,p.A)({},y2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}h2n.isMDXComponent=!0;const g2n={toc:[]},f2n="wrapper";function D2n(e){let{components:n,...t}=e;return(0,s.yg)(f2n,(0,p.A)({},g2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}D2n.isMDXComponent=!0;const M2n={toc:[]},X2n="wrapper";function _2n(e){let{components:n,...t}=e;return(0,s.yg)(X2n,(0,p.A)({},M2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}_2n.isMDXComponent=!0;const w2n={toc:[]},T2n="wrapper";function C2n(e){let{components:n,...t}=e;return(0,s.yg)(T2n,(0,p.A)({},w2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}C2n.isMDXComponent=!0;const x2n={toc:[]},A2n="wrapper";function v2n(e){let{components:n,...t}=e;return(0,s.yg)(A2n,(0,p.A)({},x2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}v2n.isMDXComponent=!0;const L2n={toc:[]},b2n="wrapper";function N2n(e){let{components:n,...t}=e;return(0,s.yg)(b2n,(0,p.A)({},L2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}N2n.isMDXComponent=!0;const k2n={toc:[]},z2n="wrapper";function P2n(e){let{components:n,...t}=e;return(0,s.yg)(z2n,(0,p.A)({},k2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}P2n.isMDXComponent=!0;const I2n={toc:[]},R2n="wrapper";function W2n(e){let{components:n,...t}=e;return(0,s.yg)(R2n,(0,p.A)({},I2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}W2n.isMDXComponent=!0;const S2n={toc:[]},B2n="wrapper";function G2n(e){let{components:n,...t}=e;return(0,s.yg)(B2n,(0,p.A)({},S2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}G2n.isMDXComponent=!0;const E2n={toc:[]},O2n="wrapper";function U2n(e){let{components:n,...t}=e;return(0,s.yg)(O2n,(0,p.A)({},E2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}U2n.isMDXComponent=!0;const F2n={toc:[]},V2n="wrapper";function q2n(e){let{components:n,...t}=e;return(0,s.yg)(V2n,(0,p.A)({},F2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}q2n.isMDXComponent=!0;const j2n={toc:[]},H2n="wrapper";function Y2n(e){let{components:n,...t}=e;return(0,s.yg)(H2n,(0,p.A)({},j2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Y2n.isMDXComponent=!0;const Q2n={toc:[]},$2n="wrapper";function K2n(e){let{components:n,...t}=e;return(0,s.yg)($2n,(0,p.A)({},Q2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}K2n.isMDXComponent=!0;const J2n={toc:[]},Z2n="wrapper";function e4n(e){let{components:n,...t}=e;return(0,s.yg)(Z2n,(0,p.A)({},J2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}e4n.isMDXComponent=!0;const n4n={toc:[]},t4n="wrapper";function o4n(e){let{components:n,...t}=e;return(0,s.yg)(t4n,(0,p.A)({},n4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}o4n.isMDXComponent=!0;const p4n={toc:[]},r4n="wrapper";function s4n(e){let{components:n,...t}=e;return(0,s.yg)(r4n,(0,p.A)({},p4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}s4n.isMDXComponent=!0;const c4n={toc:[]},a4n="wrapper";function i4n(e){let{components:n,...t}=e;return(0,s.yg)(a4n,(0,p.A)({},c4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}i4n.isMDXComponent=!0;const l4n={toc:[]},u4n="wrapper";function m4n(e){let{components:n,...t}=e;return(0,s.yg)(u4n,(0,p.A)({},l4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}m4n.isMDXComponent=!0;const y4n={toc:[]},d4n="wrapper";function h4n(e){let{components:n,...t}=e;return(0,s.yg)(d4n,(0,p.A)({},y4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}h4n.isMDXComponent=!0;const g4n={toc:[]},f4n="wrapper";function D4n(e){let{components:n,...t}=e;return(0,s.yg)(f4n,(0,p.A)({},g4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}D4n.isMDXComponent=!0;const M4n={toc:[]},X4n="wrapper";function _4n(e){let{components:n,...t}=e;return(0,s.yg)(X4n,(0,p.A)({},M4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}_4n.isMDXComponent=!0;const w4n={toc:[]},T4n="wrapper";function C4n(e){let{components:n,...t}=e;return(0,s.yg)(T4n,(0,p.A)({},w4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}C4n.isMDXComponent=!0;const x4n={toc:[]},A4n="wrapper";function v4n(e){let{components:n,...t}=e;return(0,s.yg)(A4n,(0,p.A)({},x4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}v4n.isMDXComponent=!0;const L4n={toc:[]},b4n="wrapper";function N4n(e){let{components:n,...t}=e;return(0,s.yg)(b4n,(0,p.A)({},L4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}N4n.isMDXComponent=!0;const k4n={toc:[]},z4n="wrapper";function P4n(e){let{components:n,...t}=e;return(0,s.yg)(z4n,(0,p.A)({},k4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}P4n.isMDXComponent=!0;const I4n={toc:[]},R4n="wrapper";function W4n(e){let{components:n,...t}=e;return(0,s.yg)(R4n,(0,p.A)({},I4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}W4n.isMDXComponent=!0;const S4n={toc:[]},B4n="wrapper";function G4n(e){let{components:n,...t}=e;return(0,s.yg)(B4n,(0,p.A)({},S4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}G4n.isMDXComponent=!0;const E4n={toc:[]},O4n="wrapper";function U4n(e){let{components:n,...t}=e;return(0,s.yg)(O4n,(0,p.A)({},E4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}U4n.isMDXComponent=!0;const F4n={toc:[]},V4n="wrapper";function q4n(e){let{components:n,...t}=e;return(0,s.yg)(V4n,(0,p.A)({},F4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}q4n.isMDXComponent=!0;const j4n={toc:[]},H4n="wrapper";function Y4n(e){let{components:n,...t}=e;return(0,s.yg)(H4n,(0,p.A)({},j4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Y4n.isMDXComponent=!0;const Q4n={toc:[]},$4n="wrapper";function K4n(e){let{components:n,...t}=e;return(0,s.yg)($4n,(0,p.A)({},Q4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}K4n.isMDXComponent=!0;const J4n={toc:[]},Z4n="wrapper";function e8n(e){let{components:n,...t}=e;return(0,s.yg)(Z4n,(0,p.A)({},J4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}e8n.isMDXComponent=!0;const n8n={toc:[]},t8n="wrapper";function o8n(e){let{components:n,...t}=e;return(0,s.yg)(t8n,(0,p.A)({},n8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}o8n.isMDXComponent=!0;const p8n={toc:[]},r8n="wrapper";function s8n(e){let{components:n,...t}=e;return(0,s.yg)(r8n,(0,p.A)({},p8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}s8n.isMDXComponent=!0;const c8n={toc:[]},a8n="wrapper";function i8n(e){let{components:n,...t}=e;return(0,s.yg)(a8n,(0,p.A)({},c8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}i8n.isMDXComponent=!0;const l8n={toc:[]},u8n="wrapper";function m8n(e){let{components:n,...t}=e;return(0,s.yg)(u8n,(0,p.A)({},l8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}m8n.isMDXComponent=!0;const y8n={toc:[]},d8n="wrapper";function h8n(e){let{components:n,...t}=e;return(0,s.yg)(d8n,(0,p.A)({},y8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}h8n.isMDXComponent=!0;const g8n={toc:[]},f8n="wrapper";function D8n(e){let{components:n,...t}=e;return(0,s.yg)(f8n,(0,p.A)({},g8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}D8n.isMDXComponent=!0;const M8n={toc:[]},X8n="wrapper";function _8n(e){let{components:n,...t}=e;return(0,s.yg)(X8n,(0,p.A)({},M8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}_8n.isMDXComponent=!0;const w8n={toc:[]},T8n="wrapper";function C8n(e){let{components:n,...t}=e;return(0,s.yg)(T8n,(0,p.A)({},w8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}C8n.isMDXComponent=!0;const x8n={toc:[]},A8n="wrapper";function v8n(e){let{components:n,...t}=e;return(0,s.yg)(A8n,(0,p.A)({},x8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}v8n.isMDXComponent=!0;const L8n={toc:[]},b8n="wrapper";function N8n(e){let{components:n,...t}=e;return(0,s.yg)(b8n,(0,p.A)({},L8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}N8n.isMDXComponent=!0;const k8n={toc:[]},z8n="wrapper";function P8n(e){let{components:n,...t}=e;return(0,s.yg)(z8n,(0,p.A)({},k8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}P8n.isMDXComponent=!0;const I8n={toc:[]},R8n="wrapper";function W8n(e){let{components:n,...t}=e;return(0,s.yg)(R8n,(0,p.A)({},I8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}W8n.isMDXComponent=!0;const S8n={toc:[]},B8n="wrapper";function G8n(e){let{components:n,...t}=e;return(0,s.yg)(B8n,(0,p.A)({},S8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}G8n.isMDXComponent=!0;const E8n={toc:[]},O8n="wrapper";function U8n(e){let{components:n,...t}=e;return(0,s.yg)(O8n,(0,p.A)({},E8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}U8n.isMDXComponent=!0;const F8n={toc:[]},V8n="wrapper";function q8n(e){let{components:n,...t}=e;return(0,s.yg)(V8n,(0,p.A)({},F8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}q8n.isMDXComponent=!0;const j8n={toc:[]},H8n="wrapper";function Y8n(e){let{components:n,...t}=e;return(0,s.yg)(H8n,(0,p.A)({},j8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Y8n.isMDXComponent=!0;const Q8n={toc:[]},$8n="wrapper";function K8n(e){let{components:n,...t}=e;return(0,s.yg)($8n,(0,p.A)({},Q8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}K8n.isMDXComponent=!0;const J8n={toc:[]},Z8n="wrapper";function e3n(e){let{components:n,...t}=e;return(0,s.yg)(Z8n,(0,p.A)({},J8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}e3n.isMDXComponent=!0;const n3n={toc:[]},t3n="wrapper";function o3n(e){let{components:n,...t}=e;return(0,s.yg)(t3n,(0,p.A)({},n3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}o3n.isMDXComponent=!0;const p3n={toc:[]},r3n="wrapper";function s3n(e){let{components:n,...t}=e;return(0,s.yg)(r3n,(0,p.A)({},p3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}s3n.isMDXComponent=!0;const c3n={toc:[]},a3n="wrapper";function i3n(e){let{components:n,...t}=e;return(0,s.yg)(a3n,(0,p.A)({},c3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}i3n.isMDXComponent=!0;const l3n={toc:[]},u3n="wrapper";function m3n(e){let{components:n,...t}=e;return(0,s.yg)(u3n,(0,p.A)({},l3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}m3n.isMDXComponent=!0;const y3n={toc:[]},d3n="wrapper";function h3n(e){let{components:n,...t}=e;return(0,s.yg)(d3n,(0,p.A)({},y3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}h3n.isMDXComponent=!0;const g3n={toc:[]},f3n="wrapper";function D3n(e){let{components:n,...t}=e;return(0,s.yg)(f3n,(0,p.A)({},g3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}D3n.isMDXComponent=!0;const M3n={toc:[]},X3n="wrapper";function _3n(e){let{components:n,...t}=e;return(0,s.yg)(X3n,(0,p.A)({},M3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_3n.isMDXComponent=!0;const w3n={toc:[]},T3n="wrapper";function C3n(e){let{components:n,...t}=e;return(0,s.yg)(T3n,(0,p.A)({},w3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}C3n.isMDXComponent=!0;const x3n={toc:[]},A3n="wrapper";function v3n(e){let{components:n,...t}=e;return(0,s.yg)(A3n,(0,p.A)({},x3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}v3n.isMDXComponent=!0;const L3n={toc:[]},b3n="wrapper";function N3n(e){let{components:n,...t}=e;return(0,s.yg)(b3n,(0,p.A)({},L3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}N3n.isMDXComponent=!0;const k3n={toc:[]},z3n="wrapper";function P3n(e){let{components:n,...t}=e;return(0,s.yg)(z3n,(0,p.A)({},k3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}P3n.isMDXComponent=!0;const I3n={toc:[]},R3n="wrapper";function W3n(e){let{components:n,...t}=e;return(0,s.yg)(R3n,(0,p.A)({},I3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}W3n.isMDXComponent=!0;const S3n={toc:[]},B3n="wrapper";function G3n(e){let{components:n,...t}=e;return(0,s.yg)(B3n,(0,p.A)({},S3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}G3n.isMDXComponent=!0;const E3n={toc:[]},O3n="wrapper";function U3n(e){let{components:n,...t}=e;return(0,s.yg)(O3n,(0,p.A)({},E3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}U3n.isMDXComponent=!0;const F3n={toc:[]},V3n="wrapper";function q3n(e){let{components:n,...t}=e;return(0,s.yg)(V3n,(0,p.A)({},F3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}q3n.isMDXComponent=!0;const j3n={toc:[]},H3n="wrapper";function Y3n(e){let{components:n,...t}=e;return(0,s.yg)(H3n,(0,p.A)({},j3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Y3n.isMDXComponent=!0;const Q3n={toc:[]},$3n="wrapper";function K3n(e){let{components:n,...t}=e;return(0,s.yg)($3n,(0,p.A)({},Q3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}K3n.isMDXComponent=!0;const J3n={toc:[]},Z3n="wrapper";function e1n(e){let{components:n,...t}=e;return(0,s.yg)(Z3n,(0,p.A)({},J3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}e1n.isMDXComponent=!0;const n1n={toc:[]},t1n="wrapper";function o1n(e){let{components:n,...t}=e;return(0,s.yg)(t1n,(0,p.A)({},n1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}o1n.isMDXComponent=!0;const p1n={toc:[]},r1n="wrapper";function s1n(e){let{components:n,...t}=e;return(0,s.yg)(r1n,(0,p.A)({},p1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}s1n.isMDXComponent=!0;const c1n={toc:[]},a1n="wrapper";function i1n(e){let{components:n,...t}=e;return(0,s.yg)(a1n,(0,p.A)({},c1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}i1n.isMDXComponent=!0;const l1n={toc:[]},u1n="wrapper";function m1n(e){let{components:n,...t}=e;return(0,s.yg)(u1n,(0,p.A)({},l1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}m1n.isMDXComponent=!0;const y1n={toc:[]},d1n="wrapper";function h1n(e){let{components:n,...t}=e;return(0,s.yg)(d1n,(0,p.A)({},y1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}h1n.isMDXComponent=!0;const g1n={toc:[]},f1n="wrapper";function D1n(e){let{components:n,...t}=e;return(0,s.yg)(f1n,(0,p.A)({},g1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}D1n.isMDXComponent=!0;const M1n={toc:[]},X1n="wrapper";function _1n(e){let{components:n,...t}=e;return(0,s.yg)(X1n,(0,p.A)({},M1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}_1n.isMDXComponent=!0;const w1n={toc:[]},T1n="wrapper";function C1n(e){let{components:n,...t}=e;return(0,s.yg)(T1n,(0,p.A)({},w1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}C1n.isMDXComponent=!0;const x1n={toc:[]},A1n="wrapper";function v1n(e){let{components:n,...t}=e;return(0,s.yg)(A1n,(0,p.A)({},x1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}v1n.isMDXComponent=!0;const L1n={toc:[]},b1n="wrapper";function N1n(e){let{components:n,...t}=e;return(0,s.yg)(b1n,(0,p.A)({},L1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}N1n.isMDXComponent=!0;const k1n={toc:[]},z1n="wrapper";function P1n(e){let{components:n,...t}=e;return(0,s.yg)(z1n,(0,p.A)({},k1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}P1n.isMDXComponent=!0;const I1n={toc:[]},R1n="wrapper";function W1n(e){let{components:n,...t}=e;return(0,s.yg)(R1n,(0,p.A)({},I1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}W1n.isMDXComponent=!0;const S1n={toc:[]},B1n="wrapper";function G1n(e){let{components:n,...t}=e;return(0,s.yg)(B1n,(0,p.A)({},S1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}G1n.isMDXComponent=!0;const E1n={toc:[]},O1n="wrapper";function U1n(e){let{components:n,...t}=e;return(0,s.yg)(O1n,(0,p.A)({},E1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}U1n.isMDXComponent=!0;const F1n={toc:[]},V1n="wrapper";function q1n(e){let{components:n,...t}=e;return(0,s.yg)(V1n,(0,p.A)({},F1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}q1n.isMDXComponent=!0;const j1n={toc:[]},H1n="wrapper";function Y1n(e){let{components:n,...t}=e;return(0,s.yg)(H1n,(0,p.A)({},j1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Y1n.isMDXComponent=!0;const Q1n={toc:[]},$1n="wrapper";function K1n(e){let{components:n,...t}=e;return(0,s.yg)($1n,(0,p.A)({},Q1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}K1n.isMDXComponent=!0;const J1n={toc:[]},Z1n="wrapper";function e6n(e){let{components:n,...t}=e;return(0,s.yg)(Z1n,(0,p.A)({},J1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}e6n.isMDXComponent=!0;const n6n={toc:[]},t6n="wrapper";function o6n(e){let{components:n,...t}=e;return(0,s.yg)(t6n,(0,p.A)({},n6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}o6n.isMDXComponent=!0;const p6n={toc:[]},r6n="wrapper";function s6n(e){let{components:n,...t}=e;return(0,s.yg)(r6n,(0,p.A)({},p6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}s6n.isMDXComponent=!0;const c6n={toc:[]},a6n="wrapper";function i6n(e){let{components:n,...t}=e;return(0,s.yg)(a6n,(0,p.A)({},c6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}i6n.isMDXComponent=!0;const l6n={toc:[]},u6n="wrapper";function m6n(e){let{components:n,...t}=e;return(0,s.yg)(u6n,(0,p.A)({},l6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}m6n.isMDXComponent=!0;const y6n={toc:[]},d6n="wrapper";function h6n(e){let{components:n,...t}=e;return(0,s.yg)(d6n,(0,p.A)({},y6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}h6n.isMDXComponent=!0;const g6n={toc:[]},f6n="wrapper";function D6n(e){let{components:n,...t}=e;return(0,s.yg)(f6n,(0,p.A)({},g6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}D6n.isMDXComponent=!0;const M6n={toc:[]},X6n="wrapper";function _6n(e){let{components:n,...t}=e;return(0,s.yg)(X6n,(0,p.A)({},M6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}_6n.isMDXComponent=!0;const w6n={toc:[]},T6n="wrapper";function C6n(e){let{components:n,...t}=e;return(0,s.yg)(T6n,(0,p.A)({},w6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}C6n.isMDXComponent=!0;const x6n={toc:[]},A6n="wrapper";function v6n(e){let{components:n,...t}=e;return(0,s.yg)(A6n,(0,p.A)({},x6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}v6n.isMDXComponent=!0;const L6n={toc:[]},b6n="wrapper";function N6n(e){let{components:n,...t}=e;return(0,s.yg)(b6n,(0,p.A)({},L6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}N6n.isMDXComponent=!0;const k6n={toc:[]},z6n="wrapper";function P6n(e){let{components:n,...t}=e;return(0,s.yg)(z6n,(0,p.A)({},k6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}P6n.isMDXComponent=!0;const I6n={toc:[]},R6n="wrapper";function W6n(e){let{components:n,...t}=e;return(0,s.yg)(R6n,(0,p.A)({},I6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}W6n.isMDXComponent=!0;const S6n={toc:[]},B6n="wrapper";function G6n(e){let{components:n,...t}=e;return(0,s.yg)(B6n,(0,p.A)({},S6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}G6n.isMDXComponent=!0;const E6n={toc:[]},O6n="wrapper";function U6n(e){let{components:n,...t}=e;return(0,s.yg)(O6n,(0,p.A)({},E6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}U6n.isMDXComponent=!0;const F6n={toc:[]},V6n="wrapper";function q6n(e){let{components:n,...t}=e;return(0,s.yg)(V6n,(0,p.A)({},F6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}q6n.isMDXComponent=!0;const j6n={toc:[]},H6n="wrapper";function Y6n(e){let{components:n,...t}=e;return(0,s.yg)(H6n,(0,p.A)({},j6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Y6n.isMDXComponent=!0;const Q6n={toc:[]},$6n="wrapper";function K6n(e){let{components:n,...t}=e;return(0,s.yg)($6n,(0,p.A)({},Q6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}K6n.isMDXComponent=!0;const J6n={toc:[]},Z6n="wrapper";function e5n(e){let{components:n,...t}=e;return(0,s.yg)(Z6n,(0,p.A)({},J6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}e5n.isMDXComponent=!0;const n5n={toc:[]},t5n="wrapper";function o5n(e){let{components:n,...t}=e;return(0,s.yg)(t5n,(0,p.A)({},n5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}o5n.isMDXComponent=!0;const p5n={toc:[]},r5n="wrapper";function s5n(e){let{components:n,...t}=e;return(0,s.yg)(r5n,(0,p.A)({},p5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}s5n.isMDXComponent=!0;const c5n={toc:[]},a5n="wrapper";function i5n(e){let{components:n,...t}=e;return(0,s.yg)(a5n,(0,p.A)({},c5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}i5n.isMDXComponent=!0;const l5n={toc:[]},u5n="wrapper";function m5n(e){let{components:n,...t}=e;return(0,s.yg)(u5n,(0,p.A)({},l5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}m5n.isMDXComponent=!0;const y5n={toc:[]},d5n="wrapper";function h5n(e){let{components:n,...t}=e;return(0,s.yg)(d5n,(0,p.A)({},y5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}h5n.isMDXComponent=!0;const g5n={toc:[]},f5n="wrapper";function D5n(e){let{components:n,...t}=e;return(0,s.yg)(f5n,(0,p.A)({},g5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}D5n.isMDXComponent=!0;const M5n={toc:[]},X5n="wrapper";function _5n(e){let{components:n,...t}=e;return(0,s.yg)(X5n,(0,p.A)({},M5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}_5n.isMDXComponent=!0;const w5n={toc:[]},T5n="wrapper";function C5n(e){let{components:n,...t}=e;return(0,s.yg)(T5n,(0,p.A)({},w5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}C5n.isMDXComponent=!0;const x5n={toc:[]},A5n="wrapper";function v5n(e){let{components:n,...t}=e;return(0,s.yg)(A5n,(0,p.A)({},x5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}v5n.isMDXComponent=!0;const L5n={toc:[]},b5n="wrapper";function N5n(e){let{components:n,...t}=e;return(0,s.yg)(b5n,(0,p.A)({},L5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}N5n.isMDXComponent=!0;const k5n={toc:[]},z5n="wrapper";function P5n(e){let{components:n,...t}=e;return(0,s.yg)(z5n,(0,p.A)({},k5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}P5n.isMDXComponent=!0;const I5n={toc:[]},R5n="wrapper";function W5n(e){let{components:n,...t}=e;return(0,s.yg)(R5n,(0,p.A)({},I5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}W5n.isMDXComponent=!0;const S5n={toc:[]},B5n="wrapper";function G5n(e){let{components:n,...t}=e;return(0,s.yg)(B5n,(0,p.A)({},S5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}G5n.isMDXComponent=!0;const E5n={toc:[]},O5n="wrapper";function U5n(e){let{components:n,...t}=e;return(0,s.yg)(O5n,(0,p.A)({},E5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}U5n.isMDXComponent=!0;const F5n={toc:[]},V5n="wrapper";function q5n(e){let{components:n,...t}=e;return(0,s.yg)(V5n,(0,p.A)({},F5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}q5n.isMDXComponent=!0;const j5n={toc:[]},H5n="wrapper";function Y5n(e){let{components:n,...t}=e;return(0,s.yg)(H5n,(0,p.A)({},j5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Y5n.isMDXComponent=!0;const Q5n={toc:[]},$5n="wrapper";function K5n(e){let{components:n,...t}=e;return(0,s.yg)($5n,(0,p.A)({},Q5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}K5n.isMDXComponent=!0;const J5n={toc:[]},Z5n="wrapper";function e7n(e){let{components:n,...t}=e;return(0,s.yg)(Z5n,(0,p.A)({},J5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}e7n.isMDXComponent=!0;const n7n={toc:[]},t7n="wrapper";function o7n(e){let{components:n,...t}=e;return(0,s.yg)(t7n,(0,p.A)({},n7n,t,{components:n,mdxType:"MDXLayout"}))}o7n.isMDXComponent=!0;const p7n={toc:[]},r7n="wrapper";function s7n(e){let{components:n,...t}=e;return(0,s.yg)(r7n,(0,p.A)({},p7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}s7n.isMDXComponent=!0;const c7n={toc:[]},a7n="wrapper";function i7n(e){let{components:n,...t}=e;return(0,s.yg)(a7n,(0,p.A)({},c7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}i7n.isMDXComponent=!0;const l7n={toc:[]},u7n="wrapper";function m7n(e){let{components:n,...t}=e;return(0,s.yg)(u7n,(0,p.A)({},l7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}m7n.isMDXComponent=!0;const y7n={toc:[]},d7n="wrapper";function h7n(e){let{components:n,...t}=e;return(0,s.yg)(d7n,(0,p.A)({},y7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}h7n.isMDXComponent=!0;const g7n={toc:[]},f7n="wrapper";function D7n(e){let{components:n,...t}=e;return(0,s.yg)(f7n,(0,p.A)({},g7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}D7n.isMDXComponent=!0;const M7n={toc:[]},X7n="wrapper";function _7n(e){let{components:n,...t}=e;return(0,s.yg)(X7n,(0,p.A)({},M7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}_7n.isMDXComponent=!0;const w7n={toc:[]},T7n="wrapper";function C7n(e){let{components:n,...t}=e;return(0,s.yg)(T7n,(0,p.A)({},w7n,t,{components:n,mdxType:"MDXLayout"}))}C7n.isMDXComponent=!0;const x7n={toc:[]},A7n="wrapper";function v7n(e){let{components:n,...t}=e;return(0,s.yg)(A7n,(0,p.A)({},x7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}v7n.isMDXComponent=!0;const L7n={toc:[]},b7n="wrapper";function N7n(e){let{components:n,...t}=e;return(0,s.yg)(b7n,(0,p.A)({},L7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}N7n.isMDXComponent=!0;const k7n={toc:[]},z7n="wrapper";function P7n(e){let{components:n,...t}=e;return(0,s.yg)(z7n,(0,p.A)({},k7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}P7n.isMDXComponent=!0;const I7n={toc:[]},R7n="wrapper";function W7n(e){let{components:n,...t}=e;return(0,s.yg)(R7n,(0,p.A)({},I7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}W7n.isMDXComponent=!0;const S7n={toc:[]},B7n="wrapper";function G7n(e){let{components:n,...t}=e;return(0,s.yg)(B7n,(0,p.A)({},S7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}G7n.isMDXComponent=!0;const E7n={toc:[]},O7n="wrapper";function U7n(e){let{components:n,...t}=e;return(0,s.yg)(O7n,(0,p.A)({},E7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}U7n.isMDXComponent=!0;const F7n={toc:[]},V7n="wrapper";function q7n(e){let{components:n,...t}=e;return(0,s.yg)(V7n,(0,p.A)({},F7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}q7n.isMDXComponent=!0;const j7n={toc:[]},H7n="wrapper";function Y7n(e){let{components:n,...t}=e;return(0,s.yg)(H7n,(0,p.A)({},j7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Y7n.isMDXComponent=!0;const Q7n={toc:[]},$7n="wrapper";function K7n(e){let{components:n,...t}=e;return(0,s.yg)($7n,(0,p.A)({},Q7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}K7n.isMDXComponent=!0;const J7n={toc:[]},Z7n="wrapper";function e9n(e){let{components:n,...t}=e;return(0,s.yg)(Z7n,(0,p.A)({},J7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}e9n.isMDXComponent=!0;const n9n={toc:[]},t9n="wrapper";function o9n(e){let{components:n,...t}=e;return(0,s.yg)(t9n,(0,p.A)({},n9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}o9n.isMDXComponent=!0;const p9n={toc:[]},r9n="wrapper";function s9n(e){let{components:n,...t}=e;return(0,s.yg)(r9n,(0,p.A)({},p9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}s9n.isMDXComponent=!0;const c9n={toc:[]},a9n="wrapper";function i9n(e){let{components:n,...t}=e;return(0,s.yg)(a9n,(0,p.A)({},c9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}i9n.isMDXComponent=!0;const l9n={toc:[]},u9n="wrapper";function m9n(e){let{components:n,...t}=e;return(0,s.yg)(u9n,(0,p.A)({},l9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}m9n.isMDXComponent=!0;const y9n={toc:[]},d9n="wrapper";function h9n(e){let{components:n,...t}=e;return(0,s.yg)(d9n,(0,p.A)({},y9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}h9n.isMDXComponent=!0;const g9n={toc:[]},f9n="wrapper";function D9n(e){let{components:n,...t}=e;return(0,s.yg)(f9n,(0,p.A)({},g9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}D9n.isMDXComponent=!0;const M9n={toc:[]},X9n="wrapper";function _9n(e){let{components:n,...t}=e;return(0,s.yg)(X9n,(0,p.A)({},M9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}_9n.isMDXComponent=!0;const w9n={toc:[]},T9n="wrapper";function C9n(e){let{components:n,...t}=e;return(0,s.yg)(T9n,(0,p.A)({},w9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}C9n.isMDXComponent=!0;const x9n={toc:[]},A9n="wrapper";function v9n(e){let{components:n,...t}=e;return(0,s.yg)(A9n,(0,p.A)({},x9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}v9n.isMDXComponent=!0;const L9n={toc:[]},b9n="wrapper";function N9n(e){let{components:n,...t}=e;return(0,s.yg)(b9n,(0,p.A)({},L9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}N9n.isMDXComponent=!0;const k9n={toc:[]},z9n="wrapper";function P9n(e){let{components:n,...t}=e;return(0,s.yg)(z9n,(0,p.A)({},k9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}P9n.isMDXComponent=!0;const I9n={toc:[]},R9n="wrapper";function W9n(e){let{components:n,...t}=e;return(0,s.yg)(R9n,(0,p.A)({},I9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}W9n.isMDXComponent=!0;const S9n={toc:[]},B9n="wrapper";function G9n(e){let{components:n,...t}=e;return(0,s.yg)(B9n,(0,p.A)({},S9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}G9n.isMDXComponent=!0;const E9n={toc:[]},O9n="wrapper";function U9n(e){let{components:n,...t}=e;return(0,s.yg)(O9n,(0,p.A)({},E9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}U9n.isMDXComponent=!0;const F9n={toc:[]},V9n="wrapper";function q9n(e){let{components:n,...t}=e;return(0,s.yg)(V9n,(0,p.A)({},F9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}q9n.isMDXComponent=!0;const j9n={toc:[]},H9n="wrapper";function Y9n(e){let{components:n,...t}=e;return(0,s.yg)(H9n,(0,p.A)({},j9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Y9n.isMDXComponent=!0;const Q9n={toc:[]},$9n="wrapper";function K9n(e){let{components:n,...t}=e;return(0,s.yg)($9n,(0,p.A)({},Q9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}K9n.isMDXComponent=!0;const J9n={toc:[]},Z9n="wrapper";function eet(e){let{components:n,...t}=e;return(0,s.yg)(Z9n,(0,p.A)({},J9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}eet.isMDXComponent=!0;const net={toc:[]},tet="wrapper";function oet(e){let{components:n,...t}=e;return(0,s.yg)(tet,(0,p.A)({},net,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}oet.isMDXComponent=!0;const pet={toc:[]},ret="wrapper";function set(e){let{components:n,...t}=e;return(0,s.yg)(ret,(0,p.A)({},pet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}set.isMDXComponent=!0;const cet={toc:[]},aet="wrapper";function iet(e){let{components:n,...t}=e;return(0,s.yg)(aet,(0,p.A)({},cet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}iet.isMDXComponent=!0;const uet={toc:[]},met="wrapper";function yet(e){let{components:n,...t}=e;return(0,s.yg)(met,(0,p.A)({},uet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}yet.isMDXComponent=!0;const det={toc:[]},het="wrapper";function get(e){let{components:n,...t}=e;return(0,s.yg)(het,(0,p.A)({},det,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}get.isMDXComponent=!0;const fet={toc:[]},Det="wrapper";function Met(e){let{components:n,...t}=e;return(0,s.yg)(Det,(0,p.A)({},fet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Met.isMDXComponent=!0;const Xet={toc:[]},_et="wrapper";function wet(e){let{components:n,...t}=e;return(0,s.yg)(_et,(0,p.A)({},Xet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}wet.isMDXComponent=!0;const Tet={toc:[]},Cet="wrapper";function xet(e){let{components:n,...t}=e;return(0,s.yg)(Cet,(0,p.A)({},Tet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}xet.isMDXComponent=!0;const Aet={toc:[]},vet="wrapper";function Let(e){let{components:n,...t}=e;return(0,s.yg)(vet,(0,p.A)({},Aet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Let.isMDXComponent=!0;const bet={toc:[]},Net="wrapper";function ket(e){let{components:n,...t}=e;return(0,s.yg)(Net,(0,p.A)({},bet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}ket.isMDXComponent=!0;const zet={toc:[]},Pet="wrapper";function Iet(e){let{components:n,...t}=e;return(0,s.yg)(Pet,(0,p.A)({},zet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Iet.isMDXComponent=!0;const Ret={toc:[]},Wet="wrapper";function Set(e){let{components:n,...t}=e;return(0,s.yg)(Wet,(0,p.A)({},Ret,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Set.isMDXComponent=!0;const Bet={toc:[]},Get="wrapper";function Eet(e){let{components:n,...t}=e;return(0,s.yg)(Get,(0,p.A)({},Bet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Eet.isMDXComponent=!0;const Oet={toc:[]},Uet="wrapper";function Fet(e){let{components:n,...t}=e;return(0,s.yg)(Uet,(0,p.A)({},Oet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Fet.isMDXComponent=!0;const Vet={toc:[]},qet="wrapper";function jet(e){let{components:n,...t}=e;return(0,s.yg)(qet,(0,p.A)({},Vet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jet.isMDXComponent=!0;const Het={toc:[]},Yet="wrapper";function Qet(e){let{components:n,...t}=e;return(0,s.yg)(Yet,(0,p.A)({},Het,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Qet.isMDXComponent=!0;const $et={toc:[]},Ket="wrapper";function Jet(e){let{components:n,...t}=e;return(0,s.yg)(Ket,(0,p.A)({},$et,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jet.isMDXComponent=!0;const Zet={toc:[]},ent="wrapper";function nnt(e){let{components:n,...t}=e;return(0,s.yg)(ent,(0,p.A)({},Zet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}nnt.isMDXComponent=!0;const tnt={toc:[]},ont="wrapper";function pnt(e){let{components:n,...t}=e;return(0,s.yg)(ont,(0,p.A)({},tnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pnt.isMDXComponent=!0;const rnt={toc:[]},snt="wrapper";function cnt(e){let{components:n,...t}=e;return(0,s.yg)(snt,(0,p.A)({},rnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}cnt.isMDXComponent=!0;const ant={toc:[]},int="wrapper";function lnt(e){let{components:n,...t}=e;return(0,s.yg)(int,(0,p.A)({},ant,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lnt.isMDXComponent=!0;const unt={toc:[]},mnt="wrapper";function ynt(e){let{components:n,...t}=e;return(0,s.yg)(mnt,(0,p.A)({},unt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}ynt.isMDXComponent=!0;const dnt={toc:[]},hnt="wrapper";function gnt(e){let{components:n,...t}=e;return(0,s.yg)(hnt,(0,p.A)({},dnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gnt.isMDXComponent=!0;const fnt={toc:[]},Dnt="wrapper";function Mnt(e){let{components:n,...t}=e;return(0,s.yg)(Dnt,(0,p.A)({},fnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mnt.isMDXComponent=!0;const Xnt={toc:[]},_nt="wrapper";function wnt(e){let{components:n,...t}=e;return(0,s.yg)(_nt,(0,p.A)({},Xnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wnt.isMDXComponent=!0;const Tnt={toc:[]},Cnt="wrapper";function xnt(e){let{components:n,...t}=e;return(0,s.yg)(Cnt,(0,p.A)({},Tnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}xnt.isMDXComponent=!0;const Ant={toc:[]},vnt="wrapper";function Lnt(e){let{components:n,...t}=e;return(0,s.yg)(vnt,(0,p.A)({},Ant,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lnt.isMDXComponent=!0;const bnt={toc:[]},Nnt="wrapper";function knt(e){let{components:n,...t}=e;return(0,s.yg)(Nnt,(0,p.A)({},bnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}knt.isMDXComponent=!0;const znt={toc:[]},Pnt="wrapper";function Int(e){let{components:n,...t}=e;return(0,s.yg)(Pnt,(0,p.A)({},znt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Int.isMDXComponent=!0;const Rnt={toc:[]},Wnt="wrapper";function Snt(e){let{components:n,...t}=e;return(0,s.yg)(Wnt,(0,p.A)({},Rnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Snt.isMDXComponent=!0;const Bnt={toc:[]},Gnt="wrapper";function Ent(e){let{components:n,...t}=e;return(0,s.yg)(Gnt,(0,p.A)({},Bnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Ent.isMDXComponent=!0;const Ont={toc:[]},Unt="wrapper";function Fnt(e){let{components:n,...t}=e;return(0,s.yg)(Unt,(0,p.A)({},Ont,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Fnt.isMDXComponent=!0;const Vnt={toc:[]},qnt="wrapper";function jnt(e){let{components:n,...t}=e;return(0,s.yg)(qnt,(0,p.A)({},Vnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}jnt.isMDXComponent=!0;const Hnt={toc:[]},Ynt="wrapper";function Qnt(e){let{components:n,...t}=e;return(0,s.yg)(Ynt,(0,p.A)({},Hnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Qnt.isMDXComponent=!0;const $nt={toc:[]},Knt="wrapper";function Jnt(e){let{components:n,...t}=e;return(0,s.yg)(Knt,(0,p.A)({},$nt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Jnt.isMDXComponent=!0;const Znt={toc:[]},ett="wrapper";function ntt(e){let{components:n,...t}=e;return(0,s.yg)(ett,(0,p.A)({},Znt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}ntt.isMDXComponent=!0;const ttt={toc:[]},ott="wrapper";function ptt(e){let{components:n,...t}=e;return(0,s.yg)(ott,(0,p.A)({},ttt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}ptt.isMDXComponent=!0;const rtt={toc:[]},stt="wrapper";function ctt(e){let{components:n,...t}=e;return(0,s.yg)(stt,(0,p.A)({},rtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}ctt.isMDXComponent=!0;const att={toc:[]},itt="wrapper";function ltt(e){let{components:n,...t}=e;return(0,s.yg)(itt,(0,p.A)({},att,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}ltt.isMDXComponent=!0;const utt={toc:[]},mtt="wrapper";function ytt(e){let{components:n,...t}=e;return(0,s.yg)(mtt,(0,p.A)({},utt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ytt.isMDXComponent=!0;const dtt={toc:[]},htt="wrapper";function gtt(e){let{components:n,...t}=e;return(0,s.yg)(htt,(0,p.A)({},dtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}gtt.isMDXComponent=!0;const ftt={toc:[]},Dtt="wrapper";function Mtt(e){let{components:n,...t}=e;return(0,s.yg)(Dtt,(0,p.A)({},ftt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Mtt.isMDXComponent=!0;const Xtt={toc:[]},_tt="wrapper";function wtt(e){let{components:n,...t}=e;return(0,s.yg)(_tt,(0,p.A)({},Xtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}wtt.isMDXComponent=!0;const Ttt={toc:[]},Ctt="wrapper";function xtt(e){let{components:n,...t}=e;return(0,s.yg)(Ctt,(0,p.A)({},Ttt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xtt.isMDXComponent=!0;const Att={toc:[]},vtt="wrapper";function Ltt(e){let{components:n,...t}=e;return(0,s.yg)(vtt,(0,p.A)({},Att,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Ltt.isMDXComponent=!0;const btt={toc:[]},Ntt="wrapper";function ktt(e){let{components:n,...t}=e;return(0,s.yg)(Ntt,(0,p.A)({},btt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}ktt.isMDXComponent=!0;const ztt={toc:[]},Ptt="wrapper";function Itt(e){let{components:n,...t}=e;return(0,s.yg)(Ptt,(0,p.A)({},ztt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Itt.isMDXComponent=!0;const Rtt={toc:[]},Wtt="wrapper";function Stt(e){let{components:n,...t}=e;return(0,s.yg)(Wtt,(0,p.A)({},Rtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Stt.isMDXComponent=!0;const Btt={toc:[]},Gtt="wrapper";function Ett(e){let{components:n,...t}=e;return(0,s.yg)(Gtt,(0,p.A)({},Btt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Ett.isMDXComponent=!0;const Ott={toc:[]},Utt="wrapper";function Ftt(e){let{components:n,...t}=e;return(0,s.yg)(Utt,(0,p.A)({},Ott,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Ftt.isMDXComponent=!0;const Vtt={toc:[]},qtt="wrapper";function jtt(e){let{components:n,...t}=e;return(0,s.yg)(qtt,(0,p.A)({},Vtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}jtt.isMDXComponent=!0;const Htt={toc:[]},Ytt="wrapper";function Qtt(e){let{components:n,...t}=e;return(0,s.yg)(Ytt,(0,p.A)({},Htt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Qtt.isMDXComponent=!0;const $tt={toc:[]},Ktt="wrapper";function Jtt(e){let{components:n,...t}=e;return(0,s.yg)(Ktt,(0,p.A)({},$tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Jtt.isMDXComponent=!0;const Ztt={toc:[]},eot="wrapper";function not(e){let{components:n,...t}=e;return(0,s.yg)(eot,(0,p.A)({},Ztt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}not.isMDXComponent=!0;const tot={toc:[]},oot="wrapper";function pot(e){let{components:n,...t}=e;return(0,s.yg)(oot,(0,p.A)({},tot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}pot.isMDXComponent=!0;const rot={toc:[]},sot="wrapper";function cot(e){let{components:n,...t}=e;return(0,s.yg)(sot,(0,p.A)({},rot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}cot.isMDXComponent=!0;const aot={toc:[]},iot="wrapper";function lot(e){let{components:n,...t}=e;return(0,s.yg)(iot,(0,p.A)({},aot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lot.isMDXComponent=!0;const uot={toc:[]},mot="wrapper";function yot(e){let{components:n,...t}=e;return(0,s.yg)(mot,(0,p.A)({},uot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yot.isMDXComponent=!0;const dot={toc:[]},hot="wrapper";function got(e){let{components:n,...t}=e;return(0,s.yg)(hot,(0,p.A)({},dot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}got.isMDXComponent=!0;const fot={toc:[]},Dot="wrapper";function Mot(e){let{components:n,...t}=e;return(0,s.yg)(Dot,(0,p.A)({},fot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Mot.isMDXComponent=!0;const Xot={toc:[]},_ot="wrapper";function wot(e){let{components:n,...t}=e;return(0,s.yg)(_ot,(0,p.A)({},Xot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}wot.isMDXComponent=!0;const Tot={toc:[]},Cot="wrapper";function xot(e){let{components:n,...t}=e;return(0,s.yg)(Cot,(0,p.A)({},Tot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}xot.isMDXComponent=!0;const Aot={toc:[]},vot="wrapper";function Lot(e){let{components:n,...t}=e;return(0,s.yg)(vot,(0,p.A)({},Aot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Lot.isMDXComponent=!0;const bot={toc:[]},Not="wrapper";function kot(e){let{components:n,...t}=e;return(0,s.yg)(Not,(0,p.A)({},bot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}kot.isMDXComponent=!0;const zot={toc:[]},Pot="wrapper";function Iot(e){let{components:n,...t}=e;return(0,s.yg)(Pot,(0,p.A)({},zot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Iot.isMDXComponent=!0;const Rot={toc:[]},Wot="wrapper";function Sot(e){let{components:n,...t}=e;return(0,s.yg)(Wot,(0,p.A)({},Rot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Sot.isMDXComponent=!0;const Bot={toc:[]},Got="wrapper";function Eot(e){let{components:n,...t}=e;return(0,s.yg)(Got,(0,p.A)({},Bot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Eot.isMDXComponent=!0;const Oot={toc:[]},Uot="wrapper";function Fot(e){let{components:n,...t}=e;return(0,s.yg)(Uot,(0,p.A)({},Oot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Fot.isMDXComponent=!0;const Vot={toc:[]},qot="wrapper";function jot(e){let{components:n,...t}=e;return(0,s.yg)(qot,(0,p.A)({},Vot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jot.isMDXComponent=!0;const Hot={toc:[]},Yot="wrapper";function Qot(e){let{components:n,...t}=e;return(0,s.yg)(Yot,(0,p.A)({},Hot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Qot.isMDXComponent=!0;const $ot={toc:[]},Kot="wrapper";function Jot(e){let{components:n,...t}=e;return(0,s.yg)(Kot,(0,p.A)({},$ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Jot.isMDXComponent=!0;const Zot={toc:[]},ept="wrapper";function npt(e){let{components:n,...t}=e;return(0,s.yg)(ept,(0,p.A)({},Zot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}npt.isMDXComponent=!0;const tpt={toc:[]},opt="wrapper";function ppt(e){let{components:n,...t}=e;return(0,s.yg)(opt,(0,p.A)({},tpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}ppt.isMDXComponent=!0;const rpt={toc:[]},spt="wrapper";function cpt(e){let{components:n,...t}=e;return(0,s.yg)(spt,(0,p.A)({},rpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}cpt.isMDXComponent=!0;const apt={toc:[]},ipt="wrapper";function lpt(e){let{components:n,...t}=e;return(0,s.yg)(ipt,(0,p.A)({},apt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}lpt.isMDXComponent=!0;const upt={toc:[]},mpt="wrapper";function ypt(e){let{components:n,...t}=e;return(0,s.yg)(mpt,(0,p.A)({},upt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ypt.isMDXComponent=!0;const dpt={toc:[]},hpt="wrapper";function gpt(e){let{components:n,...t}=e;return(0,s.yg)(hpt,(0,p.A)({},dpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}gpt.isMDXComponent=!0;const fpt={toc:[]},Dpt="wrapper";function Mpt(e){let{components:n,...t}=e;return(0,s.yg)(Dpt,(0,p.A)({},fpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Mpt.isMDXComponent=!0;const Xpt={toc:[]},_pt="wrapper";function wpt(e){let{components:n,...t}=e;return(0,s.yg)(_pt,(0,p.A)({},Xpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}wpt.isMDXComponent=!0;const Tpt={toc:[]},Cpt="wrapper";function xpt(e){let{components:n,...t}=e;return(0,s.yg)(Cpt,(0,p.A)({},Tpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}xpt.isMDXComponent=!0;const Apt={toc:[]},vpt="wrapper";function Lpt(e){let{components:n,...t}=e;return(0,s.yg)(vpt,(0,p.A)({},Apt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Lpt.isMDXComponent=!0;const bpt={toc:[]},Npt="wrapper";function kpt(e){let{components:n,...t}=e;return(0,s.yg)(Npt,(0,p.A)({},bpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}kpt.isMDXComponent=!0;const zpt={toc:[]},Ppt="wrapper";function Ipt(e){let{components:n,...t}=e;return(0,s.yg)(Ppt,(0,p.A)({},zpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Ipt.isMDXComponent=!0;const Rpt={toc:[]},Wpt="wrapper";function Spt(e){let{components:n,...t}=e;return(0,s.yg)(Wpt,(0,p.A)({},Rpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Spt.isMDXComponent=!0;const Bpt={toc:[]},Gpt="wrapper";function Ept(e){let{components:n,...t}=e;return(0,s.yg)(Gpt,(0,p.A)({},Bpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Ept.isMDXComponent=!0;const Opt={toc:[]},Upt="wrapper";function Fpt(e){let{components:n,...t}=e;return(0,s.yg)(Upt,(0,p.A)({},Opt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Fpt.isMDXComponent=!0;const Vpt={toc:[]},qpt="wrapper";function jpt(e){let{components:n,...t}=e;return(0,s.yg)(qpt,(0,p.A)({},Vpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}jpt.isMDXComponent=!0;const Hpt={toc:[]},Ypt="wrapper";function Qpt(e){let{components:n,...t}=e;return(0,s.yg)(Ypt,(0,p.A)({},Hpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Qpt.isMDXComponent=!0;const $pt={toc:[]},Kpt="wrapper";function Jpt(e){let{components:n,...t}=e;return(0,s.yg)(Kpt,(0,p.A)({},$pt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Jpt.isMDXComponent=!0;const Zpt={toc:[]},ert="wrapper";function nrt(e){let{components:n,...t}=e;return(0,s.yg)(ert,(0,p.A)({},Zpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}nrt.isMDXComponent=!0;const trt={toc:[]},ort="wrapper";function prt(e){let{components:n,...t}=e;return(0,s.yg)(ort,(0,p.A)({},trt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}prt.isMDXComponent=!0;const rrt={toc:[]},srt="wrapper";function crt(e){let{components:n,...t}=e;return(0,s.yg)(srt,(0,p.A)({},rrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}crt.isMDXComponent=!0;const art={toc:[]},irt="wrapper";function lrt(e){let{components:n,...t}=e;return(0,s.yg)(irt,(0,p.A)({},art,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lrt.isMDXComponent=!0;const urt={toc:[]},mrt="wrapper";function yrt(e){let{components:n,...t}=e;return(0,s.yg)(mrt,(0,p.A)({},urt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}yrt.isMDXComponent=!0;const drt={toc:[]},hrt="wrapper";function grt(e){let{components:n,...t}=e;return(0,s.yg)(hrt,(0,p.A)({},drt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}grt.isMDXComponent=!0;const frt={toc:[]},Drt="wrapper";function Mrt(e){let{components:n,...t}=e;return(0,s.yg)(Drt,(0,p.A)({},frt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Mrt.isMDXComponent=!0;const Xrt={toc:[]},_rt="wrapper";function wrt(e){let{components:n,...t}=e;return(0,s.yg)(_rt,(0,p.A)({},Xrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}wrt.isMDXComponent=!0;const Trt={toc:[]},Crt="wrapper";function xrt(e){let{components:n,...t}=e;return(0,s.yg)(Crt,(0,p.A)({},Trt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}xrt.isMDXComponent=!0;const Art={toc:[]},vrt="wrapper";function Lrt(e){let{components:n,...t}=e;return(0,s.yg)(vrt,(0,p.A)({},Art,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Lrt.isMDXComponent=!0;const brt={toc:[]},Nrt="wrapper";function krt(e){let{components:n,...t}=e;return(0,s.yg)(Nrt,(0,p.A)({},brt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}krt.isMDXComponent=!0;const zrt={toc:[]},Prt="wrapper";function Irt(e){let{components:n,...t}=e;return(0,s.yg)(Prt,(0,p.A)({},zrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Irt.isMDXComponent=!0;const Rrt={toc:[]},Wrt="wrapper";function Srt(e){let{components:n,...t}=e;return(0,s.yg)(Wrt,(0,p.A)({},Rrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Srt.isMDXComponent=!0;const Brt={toc:[]},Grt="wrapper";function Ert(e){let{components:n,...t}=e;return(0,s.yg)(Grt,(0,p.A)({},Brt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ert.isMDXComponent=!0;const Ort={toc:[]},Urt="wrapper";function Frt(e){let{components:n,...t}=e;return(0,s.yg)(Urt,(0,p.A)({},Ort,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Frt.isMDXComponent=!0;const Vrt={toc:[]},qrt="wrapper";function jrt(e){let{components:n,...t}=e;return(0,s.yg)(qrt,(0,p.A)({},Vrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}jrt.isMDXComponent=!0;const Hrt={toc:[]},Yrt="wrapper";function Qrt(e){let{components:n,...t}=e;return(0,s.yg)(Yrt,(0,p.A)({},Hrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Qrt.isMDXComponent=!0;const $rt={toc:[]},Krt="wrapper";function Jrt(e){let{components:n,...t}=e;return(0,s.yg)(Krt,(0,p.A)({},$rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Jrt.isMDXComponent=!0;const Zrt={toc:[]},est="wrapper";function nst(e){let{components:n,...t}=e;return(0,s.yg)(est,(0,p.A)({},Zrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}nst.isMDXComponent=!0;const tst={toc:[]},ost="wrapper";function pst(e){let{components:n,...t}=e;return(0,s.yg)(ost,(0,p.A)({},tst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}pst.isMDXComponent=!0;const rst={toc:[]},sst="wrapper";function cst(e){let{components:n,...t}=e;return(0,s.yg)(sst,(0,p.A)({},rst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cst.isMDXComponent=!0;const ast={toc:[]},ist="wrapper";function lst(e){let{components:n,...t}=e;return(0,s.yg)(ist,(0,p.A)({},ast,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}lst.isMDXComponent=!0;const ust={toc:[]},mst="wrapper";function yst(e){let{components:n,...t}=e;return(0,s.yg)(mst,(0,p.A)({},ust,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}yst.isMDXComponent=!0;const dst={toc:[]},hst="wrapper";function gst(e){let{components:n,...t}=e;return(0,s.yg)(hst,(0,p.A)({},dst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gst.isMDXComponent=!0;const fst={toc:[]},Dst="wrapper";function Mst(e){let{components:n,...t}=e;return(0,s.yg)(Dst,(0,p.A)({},fst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Mst.isMDXComponent=!0;const Xst={toc:[]},_st="wrapper";function wst(e){let{components:n,...t}=e;return(0,s.yg)(_st,(0,p.A)({},Xst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wst.isMDXComponent=!0;const Tst={toc:[]},Cst="wrapper";function xst(e){let{components:n,...t}=e;return(0,s.yg)(Cst,(0,p.A)({},Tst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}xst.isMDXComponent=!0;const Ast={toc:[]},vst="wrapper";function Lst(e){let{components:n,...t}=e;return(0,s.yg)(vst,(0,p.A)({},Ast,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Lst.isMDXComponent=!0;const bst={toc:[]},Nst="wrapper";function kst(e){let{components:n,...t}=e;return(0,s.yg)(Nst,(0,p.A)({},bst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}kst.isMDXComponent=!0;const zst={toc:[]},Pst="wrapper";function Ist(e){let{components:n,...t}=e;return(0,s.yg)(Pst,(0,p.A)({},zst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render any polygonal shape defined by a set of\npoints."))}Ist.isMDXComponent=!0;const Rst={toc:[]},Wst="wrapper";function Sst(e){let{components:n,...t}=e;return(0,s.yg)(Wst,(0,p.A)({},Rst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple line\nimport {makeScene2D, Line} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [150, 50],\n        [0, -50],\n        [-150, 50],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={40}\n      startArrow\n    />,\n  );\n});\n\n// snippet Polygon\nimport {makeScene2D, Line} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [-200, 70],\n        [150, 70],\n        [100, -70],\n        [-100, -70],\n      ]}\n      fill={'lightseagreen'}\n      closed\n    />,\n  );\n});\n\n// snippet Using signals\nimport {makeScene2D, Line} from '@revideo/2d';\nimport {createSignal} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const tip = createSignal(-150);\n  view.add(\n    <Line\n      points={[\n        [-150, 70],\n        [150, 70],\n        // this point is dynamically calculated based on the signal:\n        () => [tip(), -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      closed\n    />,\n  );\n\n  yield* tip(150, 1).back(1);\n});\n\n// snippet Tweening points\nimport {makeScene2D, Line} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const line = createRef<Line>();\n  view.add(\n    <Line\n      ref={line}\n      points={[\n        [-150, 70],\n        [150, 70],\n        [0, -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={20}\n      closed\n    />,\n  );\n\n  yield* line()\n    .points(\n      [\n        [-150, 0],\n        [0, 100],\n        [150, 0],\n        [150, -70],\n        [-150, -70],\n      ],\n      2,\n    )\n    .back(2);\n});\n")))}Sst.isMDXComponent=!0;const Bst={toc:[]},Gst="wrapper";function Est(e){let{components:n,...t}=e;return(0,s.yg)(Gst,(0,p.A)({},Bst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing lines and polygons."))}Est.isMDXComponent=!0;const Ost={toc:[]},Ust="wrapper";function Fst(e){let{components:n,...t}=e;return(0,s.yg)(Ust,(0,p.A)({},Ost,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Fst.isMDXComponent=!0;const Vst={toc:[]},qst="wrapper";function jst(e){let{components:n,...t}=e;return(0,s.yg)(qst,(0,p.A)({},Vst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}jst.isMDXComponent=!0;const Hst={toc:[]},Yst="wrapper";function Qst(e){let{components:n,...t}=e;return(0,s.yg)(Yst,(0,p.A)({},Hst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Qst.isMDXComponent=!0;const $st={toc:[]},Kst="wrapper";function Jst(e){let{components:n,...t}=e;return(0,s.yg)(Kst,(0,p.A)({},$st,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Jst.isMDXComponent=!0;const Zst={toc:[]},ect="wrapper";function nct(e){let{components:n,...t}=e;return(0,s.yg)(ect,(0,p.A)({},Zst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}nct.isMDXComponent=!0;const tct={toc:[]},oct="wrapper";function pct(e){let{components:n,...t}=e;return(0,s.yg)(oct,(0,p.A)({},tct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}pct.isMDXComponent=!0;const rct={toc:[]},sct="wrapper";function cct(e){let{components:n,...t}=e;return(0,s.yg)(sct,(0,p.A)({},rct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}cct.isMDXComponent=!0;const act={toc:[]},ict="wrapper";function lct(e){let{components:n,...t}=e;return(0,s.yg)(ict,(0,p.A)({},act,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}lct.isMDXComponent=!0;const uct={toc:[]},mct="wrapper";function yct(e){let{components:n,...t}=e;return(0,s.yg)(mct,(0,p.A)({},uct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}yct.isMDXComponent=!0;const dct={toc:[]},hct="wrapper";function gct(e){let{components:n,...t}=e;return(0,s.yg)(hct,(0,p.A)({},dct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}gct.isMDXComponent=!0;const fct={toc:[]},Dct="wrapper";function Mct(e){let{components:n,...t}=e;return(0,s.yg)(Dct,(0,p.A)({},fct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Mct.isMDXComponent=!0;const Xct={toc:[]},_ct="wrapper";function wct(e){let{components:n,...t}=e;return(0,s.yg)(_ct,(0,p.A)({},Xct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}wct.isMDXComponent=!0;const Tct={toc:[]},Cct="wrapper";function xct(e){let{components:n,...t}=e;return(0,s.yg)(Cct,(0,p.A)({},Tct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}xct.isMDXComponent=!0;const Act={toc:[]},vct="wrapper";function Lct(e){let{components:n,...t}=e;return(0,s.yg)(vct,(0,p.A)({},Act,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Lct.isMDXComponent=!0;const bct={toc:[]},Nct="wrapper";function kct(e){let{components:n,...t}=e;return(0,s.yg)(Nct,(0,p.A)({},bct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kct.isMDXComponent=!0;const zct={toc:[]},Pct="wrapper";function Ict(e){let{components:n,...t}=e;return(0,s.yg)(Pct,(0,p.A)({},zct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ict.isMDXComponent=!0;const Rct={toc:[]},Wct="wrapper";function Sct(e){let{components:n,...t}=e;return(0,s.yg)(Wct,(0,p.A)({},Rct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Sct.isMDXComponent=!0;const Bct={toc:[]},Gct="wrapper";function Ect(e){let{components:n,...t}=e;return(0,s.yg)(Gct,(0,p.A)({},Bct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Ect.isMDXComponent=!0;const Oct={toc:[]},Uct="wrapper";function Fct(e){let{components:n,...t}=e;return(0,s.yg)(Uct,(0,p.A)({},Oct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fct.isMDXComponent=!0;const Vct={toc:[]},qct="wrapper";function jct(e){let{components:n,...t}=e;return(0,s.yg)(qct,(0,p.A)({},Vct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}jct.isMDXComponent=!0;const Hct={toc:[]},Yct="wrapper";function Qct(e){let{components:n,...t}=e;return(0,s.yg)(Yct,(0,p.A)({},Hct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qct.isMDXComponent=!0;const $ct={toc:[]},Kct="wrapper";function Jct(e){let{components:n,...t}=e;return(0,s.yg)(Kct,(0,p.A)({},$ct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Jct.isMDXComponent=!0;const Zct={toc:[]},eat="wrapper";function nat(e){let{components:n,...t}=e;return(0,s.yg)(eat,(0,p.A)({},Zct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}nat.isMDXComponent=!0;const tat={toc:[]},oat="wrapper";function pat(e){let{components:n,...t}=e;return(0,s.yg)(oat,(0,p.A)({},tat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}pat.isMDXComponent=!0;const rat={toc:[]},sat="wrapper";function cat(e){let{components:n,...t}=e;return(0,s.yg)(sat,(0,p.A)({},rat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}cat.isMDXComponent=!0;const aat={toc:[]},iat="wrapper";function lat(e){let{components:n,...t}=e;return(0,s.yg)(iat,(0,p.A)({},aat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}lat.isMDXComponent=!0;const uat={toc:[]},mat="wrapper";function yat(e){let{components:n,...t}=e;return(0,s.yg)(mat,(0,p.A)({},uat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}yat.isMDXComponent=!0;const dat={toc:[]},hat="wrapper";function gat(e){let{components:n,...t}=e;return(0,s.yg)(hat,(0,p.A)({},dat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}gat.isMDXComponent=!0;const fat={toc:[]},Dat="wrapper";function Mat(e){let{components:n,...t}=e;return(0,s.yg)(Dat,(0,p.A)({},fat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Mat.isMDXComponent=!0;const Xat={toc:[]},_at="wrapper";function wat(e){let{components:n,...t}=e;return(0,s.yg)(_at,(0,p.A)({},Xat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}wat.isMDXComponent=!0;const Tat={toc:[]},Cat="wrapper";function xat(e){let{components:n,...t}=e;return(0,s.yg)(Cat,(0,p.A)({},Tat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}xat.isMDXComponent=!0;const Aat={toc:[]},vat="wrapper";function Lat(e){let{components:n,...t}=e;return(0,s.yg)(vat,(0,p.A)({},Aat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Lat.isMDXComponent=!0;const bat={toc:[]},Nat="wrapper";function kat(e){let{components:n,...t}=e;return(0,s.yg)(Nat,(0,p.A)({},bat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}kat.isMDXComponent=!0;const zat={toc:[]},Pat="wrapper";function Iat(e){let{components:n,...t}=e;return(0,s.yg)(Pat,(0,p.A)({},zat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The points of the line."))}Iat.isMDXComponent=!0;const Rat={toc:[]},Wat="wrapper";function Sat(e){let{components:n,...t}=e;return(0,s.yg)(Wat,(0,p.A)({},Rat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Sat.isMDXComponent=!0;const Bat={toc:[]},Gat="wrapper";function Eat(e){let{components:n,...t}=e;return(0,s.yg)(Gat,(0,p.A)({},Bat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Eat.isMDXComponent=!0;const Oat={toc:[]},Uat="wrapper";function Fat(e){let{components:n,...t}=e;return(0,s.yg)(Uat,(0,p.A)({},Oat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the line's corners."))}Fat.isMDXComponent=!0;const Vat={toc:[]},qat="wrapper";function jat(e){let{components:n,...t}=e;return(0,s.yg)(qat,(0,p.A)({},Vat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}jat.isMDXComponent=!0;const Hat={toc:[]},Yat="wrapper";function Qat(e){let{components:n,...t}=e;return(0,s.yg)(Yat,(0,p.A)({},Hat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Qat.isMDXComponent=!0;const $at={toc:[]},Kat="wrapper";function Jat(e){let{components:n,...t}=e;return(0,s.yg)(Kat,(0,p.A)({},$at,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Jat.isMDXComponent=!0;const Zat={toc:[]},eit="wrapper";function nit(e){let{components:n,...t}=e;return(0,s.yg)(eit,(0,p.A)({},Zat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}nit.isMDXComponent=!0;const tit={toc:[]},oit="wrapper";function pit(e){let{components:n,...t}=e;return(0,s.yg)(oit,(0,p.A)({},tit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}pit.isMDXComponent=!0;const rit={toc:[]},sit="wrapper";function cit(e){let{components:n,...t}=e;return(0,s.yg)(sit,(0,p.A)({},rit,t,{components:n,mdxType:"MDXLayout"}))}cit.isMDXComponent=!0;const ait={toc:[]},iit="wrapper";function lit(e){let{components:n,...t}=e;return(0,s.yg)(iit,(0,p.A)({},ait,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}lit.isMDXComponent=!0;const uit={toc:[]},mit="wrapper";function yit(e){let{components:n,...t}=e;return(0,s.yg)(mit,(0,p.A)({},uit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}yit.isMDXComponent=!0;const dit={toc:[]},hit="wrapper";function git(e){let{components:n,...t}=e;return(0,s.yg)(hit,(0,p.A)({},dit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}git.isMDXComponent=!0;const fit={toc:[]},Dit="wrapper";function Mit(e){let{components:n,...t}=e;return(0,s.yg)(Dit,(0,p.A)({},fit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Mit.isMDXComponent=!0;const Xit={toc:[]},_it="wrapper";function wit(e){let{components:n,...t}=e;return(0,s.yg)(_it,(0,p.A)({},Xit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}wit.isMDXComponent=!0;const Tit={toc:[]},Cit="wrapper";function xit(e){let{components:n,...t}=e;return(0,s.yg)(Cit,(0,p.A)({},Tit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}xit.isMDXComponent=!0;const Ait={toc:[]},vit="wrapper";function Lit(e){let{components:n,...t}=e;return(0,s.yg)(vit,(0,p.A)({},Ait,t,{components:n,mdxType:"MDXLayout"}))}Lit.isMDXComponent=!0;const bit={toc:[]},Nit="wrapper";function kit(e){let{components:n,...t}=e;return(0,s.yg)(Nit,(0,p.A)({},bit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}kit.isMDXComponent=!0;const zit={toc:[]},Pit="wrapper";function Iit(e){let{components:n,...t}=e;return(0,s.yg)(Pit,(0,p.A)({},zit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Iit.isMDXComponent=!0;const Rit={toc:[]},Wit="wrapper";function Sit(e){let{components:n,...t}=e;return(0,s.yg)(Wit,(0,p.A)({},Rit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Sit.isMDXComponent=!0;const Bit={toc:[]},Git="wrapper";function Eit(e){let{components:n,...t}=e;return(0,s.yg)(Git,(0,p.A)({},Bit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Eit.isMDXComponent=!0;const Oit={toc:[]},Uit="wrapper";function Fit(e){let{components:n,...t}=e;return(0,s.yg)(Uit,(0,p.A)({},Oit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Fit.isMDXComponent=!0;const Vit={toc:[]},qit="wrapper";function jit(e){let{components:n,...t}=e;return(0,s.yg)(qit,(0,p.A)({},Vit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}jit.isMDXComponent=!0;const Hit={toc:[]},Yit="wrapper";function Qit(e){let{components:n,...t}=e;return(0,s.yg)(Yit,(0,p.A)({},Hit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Qit.isMDXComponent=!0;const $it={toc:[]},Kit="wrapper";function Jit(e){let{components:n,...t}=e;return(0,s.yg)(Kit,(0,p.A)({},$it,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Jit.isMDXComponent=!0;const Zit={toc:[]},elt="wrapper";function nlt(e){let{components:n,...t}=e;return(0,s.yg)(elt,(0,p.A)({},Zit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}nlt.isMDXComponent=!0;const tlt={toc:[]},olt="wrapper";function plt(e){let{components:n,...t}=e;return(0,s.yg)(olt,(0,p.A)({},tlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}plt.isMDXComponent=!0;const rlt={toc:[]},slt="wrapper";function clt(e){let{components:n,...t}=e;return(0,s.yg)(slt,(0,p.A)({},rlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}clt.isMDXComponent=!0;const alt={toc:[]},ilt="wrapper";function llt(e){let{components:n,...t}=e;return(0,s.yg)(ilt,(0,p.A)({},alt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}llt.isMDXComponent=!0;const ult={toc:[]},mlt="wrapper";function ylt(e){let{components:n,...t}=e;return(0,s.yg)(mlt,(0,p.A)({},ult,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}ylt.isMDXComponent=!0;const dlt={toc:[]},hlt="wrapper";function glt(e){let{components:n,...t}=e;return(0,s.yg)(hlt,(0,p.A)({},dlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}glt.isMDXComponent=!0;const flt={toc:[]},Dlt="wrapper";function Mlt(e){let{components:n,...t}=e;return(0,s.yg)(Dlt,(0,p.A)({},flt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Mlt.isMDXComponent=!0;const Xlt={toc:[]},_lt="wrapper";function wlt(e){let{components:n,...t}=e;return(0,s.yg)(_lt,(0,p.A)({},Xlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}wlt.isMDXComponent=!0;const Tlt={toc:[]},Clt="wrapper";function xlt(e){let{components:n,...t}=e;return(0,s.yg)(Clt,(0,p.A)({},Tlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}xlt.isMDXComponent=!0;const Alt={toc:[]},vlt="wrapper";function Llt(e){let{components:n,...t}=e;return(0,s.yg)(vlt,(0,p.A)({},Alt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Llt.isMDXComponent=!0;const blt={toc:[]},Nlt="wrapper";function klt(e){let{components:n,...t}=e;return(0,s.yg)(Nlt,(0,p.A)({},blt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}klt.isMDXComponent=!0;const zlt={toc:[]},Plt="wrapper";function Ilt(e){let{components:n,...t}=e;return(0,s.yg)(Plt,(0,p.A)({},zlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Ilt.isMDXComponent=!0;const Rlt={toc:[]},Wlt="wrapper";function Slt(e){let{components:n,...t}=e;return(0,s.yg)(Wlt,(0,p.A)({},Rlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Slt.isMDXComponent=!0;const Blt={toc:[]},Glt="wrapper";function Elt(e){let{components:n,...t}=e;return(0,s.yg)(Glt,(0,p.A)({},Blt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Elt.isMDXComponent=!0;const Olt={toc:[]},Ult="wrapper";function Flt(e){let{components:n,...t}=e;return(0,s.yg)(Ult,(0,p.A)({},Olt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Flt.isMDXComponent=!0;const Vlt={toc:[]},qlt="wrapper";function jlt(e){let{components:n,...t}=e;return(0,s.yg)(qlt,(0,p.A)({},Vlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}jlt.isMDXComponent=!0;const Hlt={toc:[]},Ylt="wrapper";function Qlt(e){let{components:n,...t}=e;return(0,s.yg)(Ylt,(0,p.A)({},Hlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Qlt.isMDXComponent=!0;const $lt={toc:[]},Klt="wrapper";function Jlt(e){let{components:n,...t}=e;return(0,s.yg)(Klt,(0,p.A)({},$lt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Jlt.isMDXComponent=!0;const Zlt={toc:[]},eut="wrapper";function nut(e){let{components:n,...t}=e;return(0,s.yg)(eut,(0,p.A)({},Zlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nut.isMDXComponent=!0;const tut={toc:[]},out="wrapper";function put(e){let{components:n,...t}=e;return(0,s.yg)(out,(0,p.A)({},tut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}put.isMDXComponent=!0;const rut={toc:[]},sut="wrapper";function cut(e){let{components:n,...t}=e;return(0,s.yg)(sut,(0,p.A)({},rut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}cut.isMDXComponent=!0;const aut={toc:[]},iut="wrapper";function lut(e){let{components:n,...t}=e;return(0,s.yg)(iut,(0,p.A)({},aut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}lut.isMDXComponent=!0;const uut={toc:[]},mut="wrapper";function yut(e){let{components:n,...t}=e;return(0,s.yg)(mut,(0,p.A)({},uut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}yut.isMDXComponent=!0;const dut={toc:[]},hut="wrapper";function gut(e){let{components:n,...t}=e;return(0,s.yg)(hut,(0,p.A)({},dut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}gut.isMDXComponent=!0;const fut={toc:[]},Dut="wrapper";function Mut(e){let{components:n,...t}=e;return(0,s.yg)(Dut,(0,p.A)({},fut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Mut.isMDXComponent=!0;const Xut={toc:[]},_ut="wrapper";function wut(e){let{components:n,...t}=e;return(0,s.yg)(_ut,(0,p.A)({},Xut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}wut.isMDXComponent=!0;const Tut={toc:[]},Cut="wrapper";function xut(e){let{components:n,...t}=e;return(0,s.yg)(Cut,(0,p.A)({},Tut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}xut.isMDXComponent=!0;const Aut={toc:[]},vut="wrapper";function Lut(e){let{components:n,...t}=e;return(0,s.yg)(vut,(0,p.A)({},Aut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Lut.isMDXComponent=!0;const but={toc:[]},Nut="wrapper";function kut(e){let{components:n,...t}=e;return(0,s.yg)(Nut,(0,p.A)({},but,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}kut.isMDXComponent=!0;const zut={toc:[]},Put="wrapper";function Iut(e){let{components:n,...t}=e;return(0,s.yg)(Put,(0,p.A)({},zut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Iut.isMDXComponent=!0;const Rut={toc:[]},Wut="wrapper";function Sut(e){let{components:n,...t}=e;return(0,s.yg)(Wut,(0,p.A)({},Rut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Sut.isMDXComponent=!0;const But={toc:[]},Gut="wrapper";function Eut(e){let{components:n,...t}=e;return(0,s.yg)(Gut,(0,p.A)({},But,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Eut.isMDXComponent=!0;const Out={toc:[]},Uut="wrapper";function Fut(e){let{components:n,...t}=e;return(0,s.yg)(Uut,(0,p.A)({},Out,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Fut.isMDXComponent=!0;const Vut={toc:[]},qut="wrapper";function jut(e){let{components:n,...t}=e;return(0,s.yg)(qut,(0,p.A)({},Vut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}jut.isMDXComponent=!0;const Hut={toc:[]},Yut="wrapper";function Qut(e){let{components:n,...t}=e;return(0,s.yg)(Yut,(0,p.A)({},Hut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Qut.isMDXComponent=!0;const $ut={toc:[]},Kut="wrapper";function Jut(e){let{components:n,...t}=e;return(0,s.yg)(Kut,(0,p.A)({},$ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Jut.isMDXComponent=!0;const Zut={toc:[]},emt="wrapper";function nmt(e){let{components:n,...t}=e;return(0,s.yg)(emt,(0,p.A)({},Zut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}nmt.isMDXComponent=!0;const tmt={toc:[]},omt="wrapper";function pmt(e){let{components:n,...t}=e;return(0,s.yg)(omt,(0,p.A)({},tmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pmt.isMDXComponent=!0;const rmt={toc:[]},smt="wrapper";function cmt(e){let{components:n,...t}=e;return(0,s.yg)(smt,(0,p.A)({},rmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}cmt.isMDXComponent=!0;const amt={toc:[]},imt="wrapper";function lmt(e){let{components:n,...t}=e;return(0,s.yg)(imt,(0,p.A)({},amt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}lmt.isMDXComponent=!0;const umt={toc:[]},mmt="wrapper";function ymt(e){let{components:n,...t}=e;return(0,s.yg)(mmt,(0,p.A)({},umt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ymt.isMDXComponent=!0;const dmt={toc:[]},hmt="wrapper";function gmt(e){let{components:n,...t}=e;return(0,s.yg)(hmt,(0,p.A)({},dmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}gmt.isMDXComponent=!0;const fmt={toc:[]},Dmt="wrapper";function Mmt(e){let{components:n,...t}=e;return(0,s.yg)(Dmt,(0,p.A)({},fmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Mmt.isMDXComponent=!0;const Xmt={toc:[]},_mt="wrapper";function wmt(e){let{components:n,...t}=e;return(0,s.yg)(_mt,(0,p.A)({},Xmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}wmt.isMDXComponent=!0;const Tmt={toc:[]},Cmt="wrapper";function xmt(e){let{components:n,...t}=e;return(0,s.yg)(Cmt,(0,p.A)({},Tmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}xmt.isMDXComponent=!0;const Amt={toc:[]},vmt="wrapper";function Lmt(e){let{components:n,...t}=e;return(0,s.yg)(vmt,(0,p.A)({},Amt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Lmt.isMDXComponent=!0;const bmt={toc:[]},Nmt="wrapper";function kmt(e){let{components:n,...t}=e;return(0,s.yg)(Nmt,(0,p.A)({},bmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}kmt.isMDXComponent=!0;const zmt={toc:[]},Pmt="wrapper";function Imt(e){let{components:n,...t}=e;return(0,s.yg)(Pmt,(0,p.A)({},zmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Imt.isMDXComponent=!0;const Rmt={toc:[]},Wmt="wrapper";function Smt(e){let{components:n,...t}=e;return(0,s.yg)(Wmt,(0,p.A)({},Rmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Smt.isMDXComponent=!0;const Bmt={toc:[]},Gmt="wrapper";function Emt(e){let{components:n,...t}=e;return(0,s.yg)(Gmt,(0,p.A)({},Bmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Emt.isMDXComponent=!0;const Omt={toc:[]},Umt="wrapper";function Fmt(e){let{components:n,...t}=e;return(0,s.yg)(Umt,(0,p.A)({},Omt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Fmt.isMDXComponent=!0;const Vmt={toc:[]},qmt="wrapper";function jmt(e){let{components:n,...t}=e;return(0,s.yg)(qmt,(0,p.A)({},Vmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jmt.isMDXComponent=!0;const Hmt={toc:[]},Ymt="wrapper";function Qmt(e){let{components:n,...t}=e;return(0,s.yg)(Ymt,(0,p.A)({},Hmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Qmt.isMDXComponent=!0;const $mt={toc:[]},Kmt="wrapper";function Jmt(e){let{components:n,...t}=e;return(0,s.yg)(Kmt,(0,p.A)({},$mt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jmt.isMDXComponent=!0;const Zmt={toc:[]},eyt="wrapper";function nyt(e){let{components:n,...t}=e;return(0,s.yg)(eyt,(0,p.A)({},Zmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}nyt.isMDXComponent=!0;const tyt={toc:[]},oyt="wrapper";function pyt(e){let{components:n,...t}=e;return(0,s.yg)(oyt,(0,p.A)({},tyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pyt.isMDXComponent=!0;const ryt={toc:[]},syt="wrapper";function cyt(e){let{components:n,...t}=e;return(0,s.yg)(syt,(0,p.A)({},ryt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}cyt.isMDXComponent=!0;const ayt={toc:[]},iyt="wrapper";function lyt(e){let{components:n,...t}=e;return(0,s.yg)(iyt,(0,p.A)({},ayt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lyt.isMDXComponent=!0;const uyt={toc:[]},myt="wrapper";function yyt(e){let{components:n,...t}=e;return(0,s.yg)(myt,(0,p.A)({},uyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}yyt.isMDXComponent=!0;const dyt={toc:[]},hyt="wrapper";function gyt(e){let{components:n,...t}=e;return(0,s.yg)(hyt,(0,p.A)({},dyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gyt.isMDXComponent=!0;const fyt={toc:[]},Dyt="wrapper";function Myt(e){let{components:n,...t}=e;return(0,s.yg)(Dyt,(0,p.A)({},fyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Myt.isMDXComponent=!0;const Xyt={toc:[]},_yt="wrapper";function wyt(e){let{components:n,...t}=e;return(0,s.yg)(_yt,(0,p.A)({},Xyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wyt.isMDXComponent=!0;const Tyt={toc:[]},Cyt="wrapper";function xyt(e){let{components:n,...t}=e;return(0,s.yg)(Cyt,(0,p.A)({},Tyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}xyt.isMDXComponent=!0;const Ayt={toc:[]},vyt="wrapper";function Lyt(e){let{components:n,...t}=e;return(0,s.yg)(vyt,(0,p.A)({},Ayt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Lyt.isMDXComponent=!0;const byt={toc:[]},Nyt="wrapper";function kyt(e){let{components:n,...t}=e;return(0,s.yg)(Nyt,(0,p.A)({},byt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kyt.isMDXComponent=!0;const zyt={toc:[]},Pyt="wrapper";function Iyt(e){let{components:n,...t}=e;return(0,s.yg)(Pyt,(0,p.A)({},zyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Iyt.isMDXComponent=!0;const Ryt={toc:[]},Wyt="wrapper";function Syt(e){let{components:n,...t}=e;return(0,s.yg)(Wyt,(0,p.A)({},Ryt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Syt.isMDXComponent=!0;const Byt={toc:[]},Gyt="wrapper";function Eyt(e){let{components:n,...t}=e;return(0,s.yg)(Gyt,(0,p.A)({},Byt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Eyt.isMDXComponent=!0;const Oyt={toc:[]},Uyt="wrapper";function Fyt(e){let{components:n,...t}=e;return(0,s.yg)(Uyt,(0,p.A)({},Oyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Fyt.isMDXComponent=!0;const Vyt={toc:[]},qyt="wrapper";function jyt(e){let{components:n,...t}=e;return(0,s.yg)(qyt,(0,p.A)({},Vyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}jyt.isMDXComponent=!0;const Hyt={toc:[]},Yyt="wrapper";function Qyt(e){let{components:n,...t}=e;return(0,s.yg)(Yyt,(0,p.A)({},Hyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Qyt.isMDXComponent=!0;const $yt={toc:[]},Kyt="wrapper";function Jyt(e){let{components:n,...t}=e;return(0,s.yg)(Kyt,(0,p.A)({},$yt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Jyt.isMDXComponent=!0;const Zyt={toc:[]},edt="wrapper";function ndt(e){let{components:n,...t}=e;return(0,s.yg)(edt,(0,p.A)({},Zyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}ndt.isMDXComponent=!0;const tdt={toc:[]},odt="wrapper";function pdt(e){let{components:n,...t}=e;return(0,s.yg)(odt,(0,p.A)({},tdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}pdt.isMDXComponent=!0;const rdt={toc:[]},sdt="wrapper";function cdt(e){let{components:n,...t}=e;return(0,s.yg)(sdt,(0,p.A)({},rdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cdt.isMDXComponent=!0;const adt={toc:[]},idt="wrapper";function ldt(e){let{components:n,...t}=e;return(0,s.yg)(idt,(0,p.A)({},adt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}ldt.isMDXComponent=!0;const udt={toc:[]},mdt="wrapper";function ydt(e){let{components:n,...t}=e;return(0,s.yg)(mdt,(0,p.A)({},udt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}ydt.isMDXComponent=!0;const ddt={toc:[]},hdt="wrapper";function gdt(e){let{components:n,...t}=e;return(0,s.yg)(hdt,(0,p.A)({},ddt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}gdt.isMDXComponent=!0;const fdt={toc:[]},Ddt="wrapper";function Mdt(e){let{components:n,...t}=e;return(0,s.yg)(Ddt,(0,p.A)({},fdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mdt.isMDXComponent=!0;const Xdt={toc:[]},_dt="wrapper";function wdt(e){let{components:n,...t}=e;return(0,s.yg)(_dt,(0,p.A)({},Xdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wdt.isMDXComponent=!0;const Tdt={toc:[]},Cdt="wrapper";function xdt(e){let{components:n,...t}=e;return(0,s.yg)(Cdt,(0,p.A)({},Tdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}xdt.isMDXComponent=!0;const Adt={toc:[]},vdt="wrapper";function Ldt(e){let{components:n,...t}=e;return(0,s.yg)(vdt,(0,p.A)({},Adt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ldt.isMDXComponent=!0;const bdt={toc:[]},Ndt="wrapper";function kdt(e){let{components:n,...t}=e;return(0,s.yg)(Ndt,(0,p.A)({},bdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}kdt.isMDXComponent=!0;const zdt={toc:[]},Pdt="wrapper";function Idt(e){let{components:n,...t}=e;return(0,s.yg)(Pdt,(0,p.A)({},zdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Idt.isMDXComponent=!0;const Rdt={toc:[]},Wdt="wrapper";function Sdt(e){let{components:n,...t}=e;return(0,s.yg)(Wdt,(0,p.A)({},Rdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Sdt.isMDXComponent=!0;const Bdt={toc:[]},Gdt="wrapper";function Edt(e){let{components:n,...t}=e;return(0,s.yg)(Gdt,(0,p.A)({},Bdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Edt.isMDXComponent=!0;const Odt={toc:[]},Udt="wrapper";function Fdt(e){let{components:n,...t}=e;return(0,s.yg)(Udt,(0,p.A)({},Odt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Fdt.isMDXComponent=!0;const Vdt={toc:[]},qdt="wrapper";function jdt(e){let{components:n,...t}=e;return(0,s.yg)(qdt,(0,p.A)({},Vdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}jdt.isMDXComponent=!0;const Hdt={toc:[]},Ydt="wrapper";function Qdt(e){let{components:n,...t}=e;return(0,s.yg)(Ydt,(0,p.A)({},Hdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Qdt.isMDXComponent=!0;const $dt={toc:[]},Kdt="wrapper";function Jdt(e){let{components:n,...t}=e;return(0,s.yg)(Kdt,(0,p.A)({},$dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Jdt.isMDXComponent=!0;const Zdt={toc:[]},eht="wrapper";function nht(e){let{components:n,...t}=e;return(0,s.yg)(eht,(0,p.A)({},Zdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}nht.isMDXComponent=!0;const tht={toc:[]},oht="wrapper";function pht(e){let{components:n,...t}=e;return(0,s.yg)(oht,(0,p.A)({},tht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pht.isMDXComponent=!0;const rht={toc:[]},sht="wrapper";function cht(e){let{components:n,...t}=e;return(0,s.yg)(sht,(0,p.A)({},rht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cht.isMDXComponent=!0;const aht={toc:[]},iht="wrapper";function lht(e){let{components:n,...t}=e;return(0,s.yg)(iht,(0,p.A)({},aht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}lht.isMDXComponent=!0;const uht={toc:[]},mht="wrapper";function yht(e){let{components:n,...t}=e;return(0,s.yg)(mht,(0,p.A)({},uht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yht.isMDXComponent=!0;const dht={toc:[]},hht="wrapper";function ght(e){let{components:n,...t}=e;return(0,s.yg)(hht,(0,p.A)({},dht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}ght.isMDXComponent=!0;const fht={toc:[]},Dht="wrapper";function Mht(e){let{components:n,...t}=e;return(0,s.yg)(Dht,(0,p.A)({},fht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Mht.isMDXComponent=!0;const Xht={toc:[]},_ht="wrapper";function wht(e){let{components:n,...t}=e;return(0,s.yg)(_ht,(0,p.A)({},Xht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}wht.isMDXComponent=!0;const Tht={toc:[]},Cht="wrapper";function xht(e){let{components:n,...t}=e;return(0,s.yg)(Cht,(0,p.A)({},Tht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}xht.isMDXComponent=!0;const Aht={toc:[]},vht="wrapper";function Lht(e){let{components:n,...t}=e;return(0,s.yg)(vht,(0,p.A)({},Aht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Lht.isMDXComponent=!0;const bht={toc:[]},Nht="wrapper";function kht(e){let{components:n,...t}=e;return(0,s.yg)(Nht,(0,p.A)({},bht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}kht.isMDXComponent=!0;const zht={toc:[]},Pht="wrapper";function Iht(e){let{components:n,...t}=e;return(0,s.yg)(Pht,(0,p.A)({},zht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Iht.isMDXComponent=!0;const Rht={toc:[]},Wht="wrapper";function Sht(e){let{components:n,...t}=e;return(0,s.yg)(Wht,(0,p.A)({},Rht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Sht.isMDXComponent=!0;const Bht={toc:[]},Ght="wrapper";function Eht(e){let{components:n,...t}=e;return(0,s.yg)(Ght,(0,p.A)({},Bht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Eht.isMDXComponent=!0;const Oht={toc:[]},Uht="wrapper";function Fht(e){let{components:n,...t}=e;return(0,s.yg)(Uht,(0,p.A)({},Oht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Fht.isMDXComponent=!0;const Vht={toc:[]},qht="wrapper";function jht(e){let{components:n,...t}=e;return(0,s.yg)(qht,(0,p.A)({},Vht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}jht.isMDXComponent=!0;const Hht={toc:[]},Yht="wrapper";function Qht(e){let{components:n,...t}=e;return(0,s.yg)(Yht,(0,p.A)({},Hht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Qht.isMDXComponent=!0;const $ht={toc:[]},Kht="wrapper";function Jht(e){let{components:n,...t}=e;return(0,s.yg)(Kht,(0,p.A)({},$ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Jht.isMDXComponent=!0;const Zht={toc:[]},egt="wrapper";function ngt(e){let{components:n,...t}=e;return(0,s.yg)(egt,(0,p.A)({},Zht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}ngt.isMDXComponent=!0;const tgt={toc:[]},ogt="wrapper";function pgt(e){let{components:n,...t}=e;return(0,s.yg)(ogt,(0,p.A)({},tgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}pgt.isMDXComponent=!0;const rgt={toc:[]},sgt="wrapper";function cgt(e){let{components:n,...t}=e;return(0,s.yg)(sgt,(0,p.A)({},rgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}cgt.isMDXComponent=!0;const agt={toc:[]},igt="wrapper";function lgt(e){let{components:n,...t}=e;return(0,s.yg)(igt,(0,p.A)({},agt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}lgt.isMDXComponent=!0;const ugt={toc:[]},mgt="wrapper";function ygt(e){let{components:n,...t}=e;return(0,s.yg)(mgt,(0,p.A)({},ugt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}ygt.isMDXComponent=!0;const dgt={toc:[]},hgt="wrapper";function ggt(e){let{components:n,...t}=e;return(0,s.yg)(hgt,(0,p.A)({},dgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}ggt.isMDXComponent=!0;const fgt={toc:[]},Dgt="wrapper";function Mgt(e){let{components:n,...t}=e;return(0,s.yg)(Dgt,(0,p.A)({},fgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Mgt.isMDXComponent=!0;const Xgt={toc:[]},_gt="wrapper";function wgt(e){let{components:n,...t}=e;return(0,s.yg)(_gt,(0,p.A)({},Xgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wgt.isMDXComponent=!0;const Tgt={toc:[]},Cgt="wrapper";function xgt(e){let{components:n,...t}=e;return(0,s.yg)(Cgt,(0,p.A)({},Tgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}xgt.isMDXComponent=!0;const Agt={toc:[]},vgt="wrapper";function Lgt(e){let{components:n,...t}=e;return(0,s.yg)(vgt,(0,p.A)({},Agt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Lgt.isMDXComponent=!0;const bgt={toc:[]},Ngt="wrapper";function kgt(e){let{components:n,...t}=e;return(0,s.yg)(Ngt,(0,p.A)({},bgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}kgt.isMDXComponent=!0;const zgt={toc:[]},Pgt="wrapper";function Igt(e){let{components:n,...t}=e;return(0,s.yg)(Pgt,(0,p.A)({},zgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Igt.isMDXComponent=!0;const Rgt={toc:[]},Wgt="wrapper";function Sgt(e){let{components:n,...t}=e;return(0,s.yg)(Wgt,(0,p.A)({},Rgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Sgt.isMDXComponent=!0;const Bgt={toc:[]},Ggt="wrapper";function Egt(e){let{components:n,...t}=e;return(0,s.yg)(Ggt,(0,p.A)({},Bgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Egt.isMDXComponent=!0;const Ogt={toc:[]},Ugt="wrapper";function Fgt(e){let{components:n,...t}=e;return(0,s.yg)(Ugt,(0,p.A)({},Ogt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Fgt.isMDXComponent=!0;const Vgt={toc:[]},qgt="wrapper";function jgt(e){let{components:n,...t}=e;return(0,s.yg)(qgt,(0,p.A)({},Vgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}jgt.isMDXComponent=!0;const Hgt={toc:[]},Ygt="wrapper";function Qgt(e){let{components:n,...t}=e;return(0,s.yg)(Ygt,(0,p.A)({},Hgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Qgt.isMDXComponent=!0;const $gt={toc:[]},Kgt="wrapper";function Jgt(e){let{components:n,...t}=e;return(0,s.yg)(Kgt,(0,p.A)({},$gt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Jgt.isMDXComponent=!0;const Zgt={toc:[]},eft="wrapper";function nft(e){let{components:n,...t}=e;return(0,s.yg)(eft,(0,p.A)({},Zgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}nft.isMDXComponent=!0;const tft={toc:[]},oft="wrapper";function pft(e){let{components:n,...t}=e;return(0,s.yg)(oft,(0,p.A)({},tft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}pft.isMDXComponent=!0;const rft={toc:[]},sft="wrapper";function cft(e){let{components:n,...t}=e;return(0,s.yg)(sft,(0,p.A)({},rft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}cft.isMDXComponent=!0;const aft={toc:[]},ift="wrapper";function lft(e){let{components:n,...t}=e;return(0,s.yg)(ift,(0,p.A)({},aft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}lft.isMDXComponent=!0;const uft={toc:[]},mft="wrapper";function yft(e){let{components:n,...t}=e;return(0,s.yg)(mft,(0,p.A)({},uft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}yft.isMDXComponent=!0;const dft={toc:[]},hft="wrapper";function gft(e){let{components:n,...t}=e;return(0,s.yg)(hft,(0,p.A)({},dft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gft.isMDXComponent=!0;const fft={toc:[]},Dft="wrapper";function Mft(e){let{components:n,...t}=e;return(0,s.yg)(Dft,(0,p.A)({},fft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Mft.isMDXComponent=!0;const Xft={toc:[]},_ft="wrapper";function wft(e){let{components:n,...t}=e;return(0,s.yg)(_ft,(0,p.A)({},Xft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}wft.isMDXComponent=!0;const Tft={toc:[]},Cft="wrapper";function xft(e){let{components:n,...t}=e;return(0,s.yg)(Cft,(0,p.A)({},Tft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}xft.isMDXComponent=!0;const Aft={toc:[]},vft="wrapper";function Lft(e){let{components:n,...t}=e;return(0,s.yg)(vft,(0,p.A)({},Aft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Lft.isMDXComponent=!0;const bft={toc:[]},Nft="wrapper";function kft(e){let{components:n,...t}=e;return(0,s.yg)(Nft,(0,p.A)({},bft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}kft.isMDXComponent=!0;const zft={toc:[]},Pft="wrapper";function Ift(e){let{components:n,...t}=e;return(0,s.yg)(Pft,(0,p.A)({},zft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Ift.isMDXComponent=!0;const Rft={toc:[]},Wft="wrapper";function Sft(e){let{components:n,...t}=e;return(0,s.yg)(Wft,(0,p.A)({},Rft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Sft.isMDXComponent=!0;const Bft={toc:[]},Gft="wrapper";function Eft(e){let{components:n,...t}=e;return(0,s.yg)(Gft,(0,p.A)({},Bft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Eft.isMDXComponent=!0;const Oft={toc:[]},Uft="wrapper";function Fft(e){let{components:n,...t}=e;return(0,s.yg)(Uft,(0,p.A)({},Oft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Fft.isMDXComponent=!0;const Vft={toc:[]},qft="wrapper";function jft(e){let{components:n,...t}=e;return(0,s.yg)(qft,(0,p.A)({},Vft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}jft.isMDXComponent=!0;const Hft={toc:[]},Yft="wrapper";function Qft(e){let{components:n,...t}=e;return(0,s.yg)(Yft,(0,p.A)({},Hft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Qft.isMDXComponent=!0;const $ft={toc:[]},Kft="wrapper";function Jft(e){let{components:n,...t}=e;return(0,s.yg)(Kft,(0,p.A)({},$ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Jft.isMDXComponent=!0;const Zft={toc:[]},eDt="wrapper";function nDt(e){let{components:n,...t}=e;return(0,s.yg)(eDt,(0,p.A)({},Zft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}nDt.isMDXComponent=!0;const tDt={toc:[]},oDt="wrapper";function pDt(e){let{components:n,...t}=e;return(0,s.yg)(oDt,(0,p.A)({},tDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}pDt.isMDXComponent=!0;const rDt={toc:[]},sDt="wrapper";function cDt(e){let{components:n,...t}=e;return(0,s.yg)(sDt,(0,p.A)({},rDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}cDt.isMDXComponent=!0;const aDt={toc:[]},iDt="wrapper";function lDt(e){let{components:n,...t}=e;return(0,s.yg)(iDt,(0,p.A)({},aDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lDt.isMDXComponent=!0;const uDt={toc:[]},mDt="wrapper";function yDt(e){let{components:n,...t}=e;return(0,s.yg)(mDt,(0,p.A)({},uDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}yDt.isMDXComponent=!0;const dDt={toc:[]},hDt="wrapper";function gDt(e){let{components:n,...t}=e;return(0,s.yg)(hDt,(0,p.A)({},dDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}gDt.isMDXComponent=!0;const fDt={toc:[]},DDt="wrapper";function MDt(e){let{components:n,...t}=e;return(0,s.yg)(DDt,(0,p.A)({},fDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}MDt.isMDXComponent=!0;const XDt={toc:[]},_Dt="wrapper";function wDt(e){let{components:n,...t}=e;return(0,s.yg)(_Dt,(0,p.A)({},XDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wDt.isMDXComponent=!0;const TDt={toc:[]},CDt="wrapper";function xDt(e){let{components:n,...t}=e;return(0,s.yg)(CDt,(0,p.A)({},TDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}xDt.isMDXComponent=!0;const ADt={toc:[]},vDt="wrapper";function LDt(e){let{components:n,...t}=e;return(0,s.yg)(vDt,(0,p.A)({},ADt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}LDt.isMDXComponent=!0;const bDt={toc:[]},NDt="wrapper";function kDt(e){let{components:n,...t}=e;return(0,s.yg)(NDt,(0,p.A)({},bDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kDt.isMDXComponent=!0;const zDt={toc:[]},PDt="wrapper";function IDt(e){let{components:n,...t}=e;return(0,s.yg)(PDt,(0,p.A)({},zDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}IDt.isMDXComponent=!0;const RDt={toc:[]},WDt="wrapper";function SDt(e){let{components:n,...t}=e;return(0,s.yg)(WDt,(0,p.A)({},RDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}SDt.isMDXComponent=!0;const BDt={toc:[]},GDt="wrapper";function EDt(e){let{components:n,...t}=e;return(0,s.yg)(GDt,(0,p.A)({},BDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}EDt.isMDXComponent=!0;const ODt={toc:[]},UDt="wrapper";function FDt(e){let{components:n,...t}=e;return(0,s.yg)(UDt,(0,p.A)({},ODt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}FDt.isMDXComponent=!0;const VDt={toc:[]},qDt="wrapper";function jDt(e){let{components:n,...t}=e;return(0,s.yg)(qDt,(0,p.A)({},VDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}jDt.isMDXComponent=!0;const HDt={toc:[]},YDt="wrapper";function QDt(e){let{components:n,...t}=e;return(0,s.yg)(YDt,(0,p.A)({},HDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}QDt.isMDXComponent=!0;const $Dt={toc:[]},KDt="wrapper";function JDt(e){let{components:n,...t}=e;return(0,s.yg)(KDt,(0,p.A)({},$Dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}JDt.isMDXComponent=!0;const ZDt={toc:[]},eMt="wrapper";function nMt(e){let{components:n,...t}=e;return(0,s.yg)(eMt,(0,p.A)({},ZDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nMt.isMDXComponent=!0;const tMt={toc:[]},oMt="wrapper";function pMt(e){let{components:n,...t}=e;return(0,s.yg)(oMt,(0,p.A)({},tMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}pMt.isMDXComponent=!0;const rMt={toc:[]},sMt="wrapper";function cMt(e){let{components:n,...t}=e;return(0,s.yg)(sMt,(0,p.A)({},rMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}cMt.isMDXComponent=!0;const aMt={toc:[]},iMt="wrapper";function lMt(e){let{components:n,...t}=e;return(0,s.yg)(iMt,(0,p.A)({},aMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}lMt.isMDXComponent=!0;const uMt={toc:[]},mMt="wrapper";function yMt(e){let{components:n,...t}=e;return(0,s.yg)(mMt,(0,p.A)({},uMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yMt.isMDXComponent=!0;const dMt={toc:[]},hMt="wrapper";function gMt(e){let{components:n,...t}=e;return(0,s.yg)(hMt,(0,p.A)({},dMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gMt.isMDXComponent=!0;const fMt={toc:[]},DMt="wrapper";function MMt(e){let{components:n,...t}=e;return(0,s.yg)(DMt,(0,p.A)({},fMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}MMt.isMDXComponent=!0;const XMt={toc:[]},_Mt="wrapper";function wMt(e){let{components:n,...t}=e;return(0,s.yg)(_Mt,(0,p.A)({},XMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}wMt.isMDXComponent=!0;const TMt={toc:[]},CMt="wrapper";function xMt(e){let{components:n,...t}=e;return(0,s.yg)(CMt,(0,p.A)({},TMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}xMt.isMDXComponent=!0;const AMt={toc:[]},vMt="wrapper";function LMt(e){let{components:n,...t}=e;return(0,s.yg)(vMt,(0,p.A)({},AMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}LMt.isMDXComponent=!0;const bMt={toc:[]},NMt="wrapper";function kMt(e){let{components:n,...t}=e;return(0,s.yg)(NMt,(0,p.A)({},bMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kMt.isMDXComponent=!0;const zMt={toc:[]},PMt="wrapper";function IMt(e){let{components:n,...t}=e;return(0,s.yg)(PMt,(0,p.A)({},zMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}IMt.isMDXComponent=!0;const RMt={toc:[]},WMt="wrapper";function SMt(e){let{components:n,...t}=e;return(0,s.yg)(WMt,(0,p.A)({},RMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}SMt.isMDXComponent=!0;const BMt={toc:[]},GMt="wrapper";function EMt(e){let{components:n,...t}=e;return(0,s.yg)(GMt,(0,p.A)({},BMt,t,{components:n,mdxType:"MDXLayout"}))}EMt.isMDXComponent=!0;const OMt={toc:[]},UMt="wrapper";function FMt(e){let{components:n,...t}=e;return(0,s.yg)(UMt,(0,p.A)({},OMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}FMt.isMDXComponent=!0;const VMt={toc:[]},qMt="wrapper";function jMt(e){let{components:n,...t}=e;return(0,s.yg)(qMt,(0,p.A)({},VMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}jMt.isMDXComponent=!0;const HMt={toc:[]},YMt="wrapper";function QMt(e){let{components:n,...t}=e;return(0,s.yg)(YMt,(0,p.A)({},HMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}QMt.isMDXComponent=!0;const $Mt={toc:[]},KMt="wrapper";function JMt(e){let{components:n,...t}=e;return(0,s.yg)(KMt,(0,p.A)({},$Mt,t,{components:n,mdxType:"MDXLayout"}))}JMt.isMDXComponent=!0;const ZMt={toc:[]},eXt="wrapper";function nXt(e){let{components:n,...t}=e;return(0,s.yg)(eXt,(0,p.A)({},ZMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}nXt.isMDXComponent=!0;const tXt={toc:[]},oXt="wrapper";function pXt(e){let{components:n,...t}=e;return(0,s.yg)(oXt,(0,p.A)({},tXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}pXt.isMDXComponent=!0;const rXt={toc:[]},sXt="wrapper";function cXt(e){let{components:n,...t}=e;return(0,s.yg)(sXt,(0,p.A)({},rXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}cXt.isMDXComponent=!0;const aXt={toc:[]},iXt="wrapper";function lXt(e){let{components:n,...t}=e;return(0,s.yg)(iXt,(0,p.A)({},aXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}lXt.isMDXComponent=!0;const uXt={toc:[]},mXt="wrapper";function yXt(e){let{components:n,...t}=e;return(0,s.yg)(mXt,(0,p.A)({},uXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}yXt.isMDXComponent=!0;const dXt={toc:[]},hXt="wrapper";function gXt(e){let{components:n,...t}=e;return(0,s.yg)(hXt,(0,p.A)({},dXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}gXt.isMDXComponent=!0;const fXt={toc:[]},DXt="wrapper";function MXt(e){let{components:n,...t}=e;return(0,s.yg)(DXt,(0,p.A)({},fXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}MXt.isMDXComponent=!0;const XXt={toc:[]},_Xt="wrapper";function wXt(e){let{components:n,...t}=e;return(0,s.yg)(_Xt,(0,p.A)({},XXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}wXt.isMDXComponent=!0;const TXt={toc:[]},CXt="wrapper";function xXt(e){let{components:n,...t}=e;return(0,s.yg)(CXt,(0,p.A)({},TXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}xXt.isMDXComponent=!0;const AXt={toc:[]},vXt="wrapper";function LXt(e){let{components:n,...t}=e;return(0,s.yg)(vXt,(0,p.A)({},AXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}LXt.isMDXComponent=!0;const bXt={toc:[]},NXt="wrapper";function kXt(e){let{components:n,...t}=e;return(0,s.yg)(NXt,(0,p.A)({},bXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kXt.isMDXComponent=!0;const zXt={toc:[]},PXt="wrapper";function IXt(e){let{components:n,...t}=e;return(0,s.yg)(PXt,(0,p.A)({},zXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}IXt.isMDXComponent=!0;const RXt={toc:[]},WXt="wrapper";function SXt(e){let{components:n,...t}=e;return(0,s.yg)(WXt,(0,p.A)({},RXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}SXt.isMDXComponent=!0;const BXt={toc:[]},GXt="wrapper";function EXt(e){let{components:n,...t}=e;return(0,s.yg)(GXt,(0,p.A)({},BXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}EXt.isMDXComponent=!0;const OXt={toc:[]},UXt="wrapper";function FXt(e){let{components:n,...t}=e;return(0,s.yg)(UXt,(0,p.A)({},OXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}FXt.isMDXComponent=!0;const VXt={toc:[]},qXt="wrapper";function jXt(e){let{components:n,...t}=e;return(0,s.yg)(qXt,(0,p.A)({},VXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}jXt.isMDXComponent=!0;const HXt={toc:[]},YXt="wrapper";function QXt(e){let{components:n,...t}=e;return(0,s.yg)(YXt,(0,p.A)({},HXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}QXt.isMDXComponent=!0;const $Xt={toc:[]},KXt="wrapper";function JXt(e){let{components:n,...t}=e;return(0,s.yg)(KXt,(0,p.A)({},$Xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}JXt.isMDXComponent=!0;const ZXt={toc:[]},e_t="wrapper";function n_t(e){let{components:n,...t}=e;return(0,s.yg)(e_t,(0,p.A)({},ZXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}n_t.isMDXComponent=!0;const t_t={toc:[]},o_t="wrapper";function p_t(e){let{components:n,...t}=e;return(0,s.yg)(o_t,(0,p.A)({},t_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}p_t.isMDXComponent=!0;const r_t={toc:[]},s_t="wrapper";function c_t(e){let{components:n,...t}=e;return(0,s.yg)(s_t,(0,p.A)({},r_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}c_t.isMDXComponent=!0;const a_t={toc:[]},i_t="wrapper";function l_t(e){let{components:n,...t}=e;return(0,s.yg)(i_t,(0,p.A)({},a_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}l_t.isMDXComponent=!0;const u_t={toc:[]},m_t="wrapper";function y_t(e){let{components:n,...t}=e;return(0,s.yg)(m_t,(0,p.A)({},u_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}y_t.isMDXComponent=!0;const d_t={toc:[]},h_t="wrapper";function g_t(e){let{components:n,...t}=e;return(0,s.yg)(h_t,(0,p.A)({},d_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}g_t.isMDXComponent=!0;const f_t={toc:[]},D_t="wrapper";function M_t(e){let{components:n,...t}=e;return(0,s.yg)(D_t,(0,p.A)({},f_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}M_t.isMDXComponent=!0;const X_t={toc:[]},__t="wrapper";function w_t(e){let{components:n,...t}=e;return(0,s.yg)(__t,(0,p.A)({},X_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}w_t.isMDXComponent=!0;const T_t={toc:[]},C_t="wrapper";function x_t(e){let{components:n,...t}=e;return(0,s.yg)(C_t,(0,p.A)({},T_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}x_t.isMDXComponent=!0;const A_t={toc:[]},v_t="wrapper";function L_t(e){let{components:n,...t}=e;return(0,s.yg)(v_t,(0,p.A)({},A_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}L_t.isMDXComponent=!0;const b_t={toc:[]},N_t="wrapper";function k_t(e){let{components:n,...t}=e;return(0,s.yg)(N_t,(0,p.A)({},b_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}k_t.isMDXComponent=!0;const z_t={toc:[]},P_t="wrapper";function I_t(e){let{components:n,...t}=e;return(0,s.yg)(P_t,(0,p.A)({},z_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}I_t.isMDXComponent=!0;const R_t={toc:[]},W_t="wrapper";function S_t(e){let{components:n,...t}=e;return(0,s.yg)(W_t,(0,p.A)({},R_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}S_t.isMDXComponent=!0;const B_t={toc:[]},G_t="wrapper";function E_t(e){let{components:n,...t}=e;return(0,s.yg)(G_t,(0,p.A)({},B_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}E_t.isMDXComponent=!0;const O_t={toc:[]},U_t="wrapper";function F_t(e){let{components:n,...t}=e;return(0,s.yg)(U_t,(0,p.A)({},O_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}F_t.isMDXComponent=!0;const V_t={toc:[]},q_t="wrapper";function j_t(e){let{components:n,...t}=e;return(0,s.yg)(q_t,(0,p.A)({},V_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}j_t.isMDXComponent=!0;const H_t={toc:[]},Y_t="wrapper";function Q_t(e){let{components:n,...t}=e;return(0,s.yg)(Y_t,(0,p.A)({},H_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Q_t.isMDXComponent=!0;const $_t={toc:[]},K_t="wrapper";function J_t(e){let{components:n,...t}=e;return(0,s.yg)(K_t,(0,p.A)({},$_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}J_t.isMDXComponent=!0;const Z_t={toc:[]},ewt="wrapper";function nwt(e){let{components:n,...t}=e;return(0,s.yg)(ewt,(0,p.A)({},Z_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nwt.isMDXComponent=!0;const twt={toc:[]},owt="wrapper";function pwt(e){let{components:n,...t}=e;return(0,s.yg)(owt,(0,p.A)({},twt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}pwt.isMDXComponent=!0;const rwt={toc:[]},swt="wrapper";function cwt(e){let{components:n,...t}=e;return(0,s.yg)(swt,(0,p.A)({},rwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cwt.isMDXComponent=!0;const awt={toc:[]},iwt="wrapper";function lwt(e){let{components:n,...t}=e;return(0,s.yg)(iwt,(0,p.A)({},awt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}lwt.isMDXComponent=!0;const uwt={toc:[]},mwt="wrapper";function ywt(e){let{components:n,...t}=e;return(0,s.yg)(mwt,(0,p.A)({},uwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ywt.isMDXComponent=!0;const dwt={toc:[]},hwt="wrapper";function gwt(e){let{components:n,...t}=e;return(0,s.yg)(hwt,(0,p.A)({},dwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}gwt.isMDXComponent=!0;const fwt={toc:[]},Dwt="wrapper";function Mwt(e){let{components:n,...t}=e;return(0,s.yg)(Dwt,(0,p.A)({},fwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mwt.isMDXComponent=!0;const Xwt={toc:[]},_wt="wrapper";function wwt(e){let{components:n,...t}=e;return(0,s.yg)(_wt,(0,p.A)({},Xwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}wwt.isMDXComponent=!0;const Twt={toc:[]},Cwt="wrapper";function xwt(e){let{components:n,...t}=e;return(0,s.yg)(Cwt,(0,p.A)({},Twt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xwt.isMDXComponent=!0;const Awt={toc:[]},vwt="wrapper";function Lwt(e){let{components:n,...t}=e;return(0,s.yg)(vwt,(0,p.A)({},Awt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Lwt.isMDXComponent=!0;const bwt={toc:[]},Nwt="wrapper";function kwt(e){let{components:n,...t}=e;return(0,s.yg)(Nwt,(0,p.A)({},bwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kwt.isMDXComponent=!0;const zwt={toc:[]},Pwt="wrapper";function Iwt(e){let{components:n,...t}=e;return(0,s.yg)(Pwt,(0,p.A)({},zwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Iwt.isMDXComponent=!0;const Rwt={toc:[]},Wwt="wrapper";function Swt(e){let{components:n,...t}=e;return(0,s.yg)(Wwt,(0,p.A)({},Rwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Swt.isMDXComponent=!0;const Bwt={toc:[]},Gwt="wrapper";function Ewt(e){let{components:n,...t}=e;return(0,s.yg)(Gwt,(0,p.A)({},Bwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ewt.isMDXComponent=!0;const Owt={toc:[]},Uwt="wrapper";function Fwt(e){let{components:n,...t}=e;return(0,s.yg)(Uwt,(0,p.A)({},Owt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Fwt.isMDXComponent=!0;const Vwt={toc:[]},qwt="wrapper";function jwt(e){let{components:n,...t}=e;return(0,s.yg)(qwt,(0,p.A)({},Vwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}jwt.isMDXComponent=!0;const Hwt={toc:[]},Ywt="wrapper";function Qwt(e){let{components:n,...t}=e;return(0,s.yg)(Ywt,(0,p.A)({},Hwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Qwt.isMDXComponent=!0;const $wt={toc:[]},Kwt="wrapper";function Jwt(e){let{components:n,...t}=e;return(0,s.yg)(Kwt,(0,p.A)({},$wt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Jwt.isMDXComponent=!0;const Zwt={toc:[]},eTt="wrapper";function nTt(e){let{components:n,...t}=e;return(0,s.yg)(eTt,(0,p.A)({},Zwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}nTt.isMDXComponent=!0;const tTt={toc:[]},oTt="wrapper";function pTt(e){let{components:n,...t}=e;return(0,s.yg)(oTt,(0,p.A)({},tTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}pTt.isMDXComponent=!0;const rTt={toc:[]},sTt="wrapper";function cTt(e){let{components:n,...t}=e;return(0,s.yg)(sTt,(0,p.A)({},rTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}cTt.isMDXComponent=!0;const aTt={toc:[]},iTt="wrapper";function lTt(e){let{components:n,...t}=e;return(0,s.yg)(iTt,(0,p.A)({},aTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}lTt.isMDXComponent=!0;const uTt={toc:[]},mTt="wrapper";function yTt(e){let{components:n,...t}=e;return(0,s.yg)(mTt,(0,p.A)({},uTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}yTt.isMDXComponent=!0;const dTt={toc:[]},hTt="wrapper";function gTt(e){let{components:n,...t}=e;return(0,s.yg)(hTt,(0,p.A)({},dTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gTt.isMDXComponent=!0;const fTt={toc:[]},DTt="wrapper";function MTt(e){let{components:n,...t}=e;return(0,s.yg)(DTt,(0,p.A)({},fTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}MTt.isMDXComponent=!0;const XTt={toc:[]},_Tt="wrapper";function wTt(e){let{components:n,...t}=e;return(0,s.yg)(_Tt,(0,p.A)({},XTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wTt.isMDXComponent=!0;const TTt={toc:[]},CTt="wrapper";function xTt(e){let{components:n,...t}=e;return(0,s.yg)(CTt,(0,p.A)({},TTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}xTt.isMDXComponent=!0;const ATt={toc:[]},vTt="wrapper";function LTt(e){let{components:n,...t}=e;return(0,s.yg)(vTt,(0,p.A)({},ATt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}LTt.isMDXComponent=!0;const bTt={toc:[]},NTt="wrapper";function kTt(e){let{components:n,...t}=e;return(0,s.yg)(NTt,(0,p.A)({},bTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kTt.isMDXComponent=!0;const zTt={toc:[]},PTt="wrapper";function ITt(e){let{components:n,...t}=e;return(0,s.yg)(PTt,(0,p.A)({},zTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}ITt.isMDXComponent=!0;const RTt={toc:[]},WTt="wrapper";function STt(e){let{components:n,...t}=e;return(0,s.yg)(WTt,(0,p.A)({},RTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}STt.isMDXComponent=!0;const BTt={toc:[]},GTt="wrapper";function ETt(e){let{components:n,...t}=e;return(0,s.yg)(GTt,(0,p.A)({},BTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ETt.isMDXComponent=!0;const OTt={toc:[]},UTt="wrapper";function FTt(e){let{components:n,...t}=e;return(0,s.yg)(UTt,(0,p.A)({},OTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}FTt.isMDXComponent=!0;const VTt={toc:[]},qTt="wrapper";function jTt(e){let{components:n,...t}=e;return(0,s.yg)(qTt,(0,p.A)({},VTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}jTt.isMDXComponent=!0;const HTt={toc:[]},YTt="wrapper";function QTt(e){let{components:n,...t}=e;return(0,s.yg)(YTt,(0,p.A)({},HTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}QTt.isMDXComponent=!0;const $Tt={toc:[]},KTt="wrapper";function JTt(e){let{components:n,...t}=e;return(0,s.yg)(KTt,(0,p.A)({},$Tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}JTt.isMDXComponent=!0;const ZTt={toc:[]},eCt="wrapper";function nCt(e){let{components:n,...t}=e;return(0,s.yg)(eCt,(0,p.A)({},ZTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}nCt.isMDXComponent=!0;const tCt={toc:[]},oCt="wrapper";function pCt(e){let{components:n,...t}=e;return(0,s.yg)(oCt,(0,p.A)({},tCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}pCt.isMDXComponent=!0;const rCt={toc:[]},sCt="wrapper";function cCt(e){let{components:n,...t}=e;return(0,s.yg)(sCt,(0,p.A)({},rCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cCt.isMDXComponent=!0;const aCt={toc:[]},iCt="wrapper";function lCt(e){let{components:n,...t}=e;return(0,s.yg)(iCt,(0,p.A)({},aCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lCt.isMDXComponent=!0;const uCt={toc:[]},mCt="wrapper";function yCt(e){let{components:n,...t}=e;return(0,s.yg)(mCt,(0,p.A)({},uCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}yCt.isMDXComponent=!0;const dCt={toc:[]},hCt="wrapper";function gCt(e){let{components:n,...t}=e;return(0,s.yg)(hCt,(0,p.A)({},dCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}gCt.isMDXComponent=!0;const fCt={toc:[]},DCt="wrapper";function MCt(e){let{components:n,...t}=e;return(0,s.yg)(DCt,(0,p.A)({},fCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}MCt.isMDXComponent=!0;const XCt={toc:[]},_Ct="wrapper";function wCt(e){let{components:n,...t}=e;return(0,s.yg)(_Ct,(0,p.A)({},XCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}wCt.isMDXComponent=!0;const TCt={toc:[]},CCt="wrapper";function xCt(e){let{components:n,...t}=e;return(0,s.yg)(CCt,(0,p.A)({},TCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}xCt.isMDXComponent=!0;const ACt={toc:[]},vCt="wrapper";function LCt(e){let{components:n,...t}=e;return(0,s.yg)(vCt,(0,p.A)({},ACt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}LCt.isMDXComponent=!0;const bCt={toc:[]},NCt="wrapper";function kCt(e){let{components:n,...t}=e;return(0,s.yg)(NCt,(0,p.A)({},bCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}kCt.isMDXComponent=!0;const zCt={toc:[]},PCt="wrapper";function ICt(e){let{components:n,...t}=e;return(0,s.yg)(PCt,(0,p.A)({},zCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}ICt.isMDXComponent=!0;const RCt={toc:[]},WCt="wrapper";function SCt(e){let{components:n,...t}=e;return(0,s.yg)(WCt,(0,p.A)({},RCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}SCt.isMDXComponent=!0;const BCt={toc:[]},GCt="wrapper";function ECt(e){let{components:n,...t}=e;return(0,s.yg)(GCt,(0,p.A)({},BCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}ECt.isMDXComponent=!0;const OCt={toc:[]},UCt="wrapper";function FCt(e){let{components:n,...t}=e;return(0,s.yg)(UCt,(0,p.A)({},OCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}FCt.isMDXComponent=!0;const VCt={toc:[]},qCt="wrapper";function jCt(e){let{components:n,...t}=e;return(0,s.yg)(qCt,(0,p.A)({},VCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}jCt.isMDXComponent=!0;const HCt={toc:[]},YCt="wrapper";function QCt(e){let{components:n,...t}=e;return(0,s.yg)(YCt,(0,p.A)({},HCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}QCt.isMDXComponent=!0;const $Ct={toc:[]},KCt="wrapper";function JCt(e){let{components:n,...t}=e;return(0,s.yg)(KCt,(0,p.A)({},$Ct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}JCt.isMDXComponent=!0;const ZCt={toc:[]},ext="wrapper";function nxt(e){let{components:n,...t}=e;return(0,s.yg)(ext,(0,p.A)({},ZCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}nxt.isMDXComponent=!0;const txt={toc:[]},oxt="wrapper";function pxt(e){let{components:n,...t}=e;return(0,s.yg)(oxt,(0,p.A)({},txt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pxt.isMDXComponent=!0;const rxt={toc:[]},sxt="wrapper";function cxt(e){let{components:n,...t}=e;return(0,s.yg)(sxt,(0,p.A)({},rxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}cxt.isMDXComponent=!0;const axt={toc:[]},ixt="wrapper";function lxt(e){let{components:n,...t}=e;return(0,s.yg)(ixt,(0,p.A)({},axt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}lxt.isMDXComponent=!0;const uxt={toc:[]},mxt="wrapper";function yxt(e){let{components:n,...t}=e;return(0,s.yg)(mxt,(0,p.A)({},uxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}yxt.isMDXComponent=!0;const dxt={toc:[]},hxt="wrapper";function gxt(e){let{components:n,...t}=e;return(0,s.yg)(hxt,(0,p.A)({},dxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}gxt.isMDXComponent=!0;const fxt={toc:[]},Dxt="wrapper";function Mxt(e){let{components:n,...t}=e;return(0,s.yg)(Dxt,(0,p.A)({},fxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Mxt.isMDXComponent=!0;const Xxt={toc:[]},_xt="wrapper";function wxt(e){let{components:n,...t}=e;return(0,s.yg)(_xt,(0,p.A)({},Xxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}wxt.isMDXComponent=!0;const Txt={toc:[]},Cxt="wrapper";function xxt(e){let{components:n,...t}=e;return(0,s.yg)(Cxt,(0,p.A)({},Txt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}xxt.isMDXComponent=!0;const Axt={toc:[]},vxt="wrapper";function Lxt(e){let{components:n,...t}=e;return(0,s.yg)(vxt,(0,p.A)({},Axt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Lxt.isMDXComponent=!0;const bxt={toc:[]},Nxt="wrapper";function kxt(e){let{components:n,...t}=e;return(0,s.yg)(Nxt,(0,p.A)({},bxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}kxt.isMDXComponent=!0;const zxt={toc:[]},Pxt="wrapper";function Ixt(e){let{components:n,...t}=e;return(0,s.yg)(Pxt,(0,p.A)({},zxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Ixt.isMDXComponent=!0;const Rxt={toc:[]},Wxt="wrapper";function Sxt(e){let{components:n,...t}=e;return(0,s.yg)(Wxt,(0,p.A)({},Rxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Sxt.isMDXComponent=!0;const Bxt={toc:[]},Gxt="wrapper";function Ext(e){let{components:n,...t}=e;return(0,s.yg)(Gxt,(0,p.A)({},Bxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Ext.isMDXComponent=!0;const Oxt={toc:[]},Uxt="wrapper";function Fxt(e){let{components:n,...t}=e;return(0,s.yg)(Uxt,(0,p.A)({},Oxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Fxt.isMDXComponent=!0;const Vxt={toc:[]},qxt="wrapper";function jxt(e){let{components:n,...t}=e;return(0,s.yg)(qxt,(0,p.A)({},Vxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}jxt.isMDXComponent=!0;const Hxt={toc:[]},Yxt="wrapper";function Qxt(e){let{components:n,...t}=e;return(0,s.yg)(Yxt,(0,p.A)({},Hxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qxt.isMDXComponent=!0;const $xt={toc:[]},Kxt="wrapper";function Jxt(e){let{components:n,...t}=e;return(0,s.yg)(Kxt,(0,p.A)({},$xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Jxt.isMDXComponent=!0;const Zxt={toc:[]},eAt="wrapper";function nAt(e){let{components:n,...t}=e;return(0,s.yg)(eAt,(0,p.A)({},Zxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}nAt.isMDXComponent=!0;const tAt={toc:[]},oAt="wrapper";function pAt(e){let{components:n,...t}=e;return(0,s.yg)(oAt,(0,p.A)({},tAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}pAt.isMDXComponent=!0;const rAt={toc:[]},sAt="wrapper";function cAt(e){let{components:n,...t}=e;return(0,s.yg)(sAt,(0,p.A)({},rAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}cAt.isMDXComponent=!0;const aAt={toc:[]},iAt="wrapper";function lAt(e){let{components:n,...t}=e;return(0,s.yg)(iAt,(0,p.A)({},aAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}lAt.isMDXComponent=!0;const uAt={toc:[]},mAt="wrapper";function yAt(e){let{components:n,...t}=e;return(0,s.yg)(mAt,(0,p.A)({},uAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}yAt.isMDXComponent=!0;const dAt={toc:[]},hAt="wrapper";function gAt(e){let{components:n,...t}=e;return(0,s.yg)(hAt,(0,p.A)({},dAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}gAt.isMDXComponent=!0;const fAt={toc:[]},DAt="wrapper";function MAt(e){let{components:n,...t}=e;return(0,s.yg)(DAt,(0,p.A)({},fAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}MAt.isMDXComponent=!0;const XAt={toc:[]},_At="wrapper";function wAt(e){let{components:n,...t}=e;return(0,s.yg)(_At,(0,p.A)({},XAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}wAt.isMDXComponent=!0;const TAt={toc:[]},CAt="wrapper";function xAt(e){let{components:n,...t}=e;return(0,s.yg)(CAt,(0,p.A)({},TAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}xAt.isMDXComponent=!0;const AAt={toc:[]},vAt="wrapper";function LAt(e){let{components:n,...t}=e;return(0,s.yg)(vAt,(0,p.A)({},AAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}LAt.isMDXComponent=!0;const bAt={toc:[]},NAt="wrapper";function kAt(e){let{components:n,...t}=e;return(0,s.yg)(NAt,(0,p.A)({},bAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}kAt.isMDXComponent=!0;const zAt={toc:[]},PAt="wrapper";function IAt(e){let{components:n,...t}=e;return(0,s.yg)(PAt,(0,p.A)({},zAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}IAt.isMDXComponent=!0;const RAt={toc:[]},WAt="wrapper";function SAt(e){let{components:n,...t}=e;return(0,s.yg)(WAt,(0,p.A)({},RAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}SAt.isMDXComponent=!0;const BAt={toc:[]},GAt="wrapper";function EAt(e){let{components:n,...t}=e;return(0,s.yg)(GAt,(0,p.A)({},BAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}EAt.isMDXComponent=!0;const OAt={toc:[]},UAt="wrapper";function FAt(e){let{components:n,...t}=e;return(0,s.yg)(UAt,(0,p.A)({},OAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FAt.isMDXComponent=!0;const VAt={toc:[]},qAt="wrapper";function jAt(e){let{components:n,...t}=e;return(0,s.yg)(qAt,(0,p.A)({},VAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}jAt.isMDXComponent=!0;const HAt={toc:[]},YAt="wrapper";function QAt(e){let{components:n,...t}=e;return(0,s.yg)(YAt,(0,p.A)({},HAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}QAt.isMDXComponent=!0;const $At={toc:[]},KAt="wrapper";function JAt(e){let{components:n,...t}=e;return(0,s.yg)(KAt,(0,p.A)({},$At,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}JAt.isMDXComponent=!0;const ZAt={toc:[]},evt="wrapper";function nvt(e){let{components:n,...t}=e;return(0,s.yg)(evt,(0,p.A)({},ZAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nvt.isMDXComponent=!0;const tvt={toc:[]},ovt="wrapper";function pvt(e){let{components:n,...t}=e;return(0,s.yg)(ovt,(0,p.A)({},tvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pvt.isMDXComponent=!0;const rvt={toc:[]},svt="wrapper";function cvt(e){let{components:n,...t}=e;return(0,s.yg)(svt,(0,p.A)({},rvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}cvt.isMDXComponent=!0;const avt={toc:[]},ivt="wrapper";function lvt(e){let{components:n,...t}=e;return(0,s.yg)(ivt,(0,p.A)({},avt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lvt.isMDXComponent=!0;const uvt={toc:[]},mvt="wrapper";function yvt(e){let{components:n,...t}=e;return(0,s.yg)(mvt,(0,p.A)({},uvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}yvt.isMDXComponent=!0;const dvt={toc:[]},hvt="wrapper";function gvt(e){let{components:n,...t}=e;return(0,s.yg)(hvt,(0,p.A)({},dvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}gvt.isMDXComponent=!0;const fvt={toc:[]},Dvt="wrapper";function Mvt(e){let{components:n,...t}=e;return(0,s.yg)(Dvt,(0,p.A)({},fvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Mvt.isMDXComponent=!0;const Xvt={toc:[]},_vt="wrapper";function wvt(e){let{components:n,...t}=e;return(0,s.yg)(_vt,(0,p.A)({},Xvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wvt.isMDXComponent=!0;const Tvt={toc:[]},Cvt="wrapper";function xvt(e){let{components:n,...t}=e;return(0,s.yg)(Cvt,(0,p.A)({},Tvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}xvt.isMDXComponent=!0;const Avt={toc:[]},vvt="wrapper";function Lvt(e){let{components:n,...t}=e;return(0,s.yg)(vvt,(0,p.A)({},Avt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Lvt.isMDXComponent=!0;const bvt={toc:[]},Nvt="wrapper";function kvt(e){let{components:n,...t}=e;return(0,s.yg)(Nvt,(0,p.A)({},bvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}kvt.isMDXComponent=!0;const zvt={toc:[]},Pvt="wrapper";function Ivt(e){let{components:n,...t}=e;return(0,s.yg)(Pvt,(0,p.A)({},zvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ivt.isMDXComponent=!0;const Rvt={toc:[]},Wvt="wrapper";function Svt(e){let{components:n,...t}=e;return(0,s.yg)(Wvt,(0,p.A)({},Rvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Svt.isMDXComponent=!0;const Bvt={toc:[]},Gvt="wrapper";function Evt(e){let{components:n,...t}=e;return(0,s.yg)(Gvt,(0,p.A)({},Bvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Evt.isMDXComponent=!0;const Ovt={toc:[]},Uvt="wrapper";function Fvt(e){let{components:n,...t}=e;return(0,s.yg)(Uvt,(0,p.A)({},Ovt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Fvt.isMDXComponent=!0;const Vvt={toc:[]},qvt="wrapper";function jvt(e){let{components:n,...t}=e;return(0,s.yg)(qvt,(0,p.A)({},Vvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}jvt.isMDXComponent=!0;const Hvt={toc:[]},Yvt="wrapper";function Qvt(e){let{components:n,...t}=e;return(0,s.yg)(Yvt,(0,p.A)({},Hvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Qvt.isMDXComponent=!0;const $vt={toc:[]},Kvt="wrapper";function Jvt(e){let{components:n,...t}=e;return(0,s.yg)(Kvt,(0,p.A)({},$vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Jvt.isMDXComponent=!0;const Zvt={toc:[]},eLt="wrapper";function nLt(e){let{components:n,...t}=e;return(0,s.yg)(eLt,(0,p.A)({},Zvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}nLt.isMDXComponent=!0;const tLt={toc:[]},oLt="wrapper";function pLt(e){let{components:n,...t}=e;return(0,s.yg)(oLt,(0,p.A)({},tLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pLt.isMDXComponent=!0;const rLt={toc:[]},sLt="wrapper";function cLt(e){let{components:n,...t}=e;return(0,s.yg)(sLt,(0,p.A)({},rLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cLt.isMDXComponent=!0;const aLt={toc:[]},iLt="wrapper";function lLt(e){let{components:n,...t}=e;return(0,s.yg)(iLt,(0,p.A)({},aLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}lLt.isMDXComponent=!0;const uLt={toc:[]},mLt="wrapper";function yLt(e){let{components:n,...t}=e;return(0,s.yg)(mLt,(0,p.A)({},uLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}yLt.isMDXComponent=!0;const dLt={toc:[]},hLt="wrapper";function gLt(e){let{components:n,...t}=e;return(0,s.yg)(hLt,(0,p.A)({},dLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}gLt.isMDXComponent=!0;const fLt={toc:[]},DLt="wrapper";function MLt(e){let{components:n,...t}=e;return(0,s.yg)(DLt,(0,p.A)({},fLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}MLt.isMDXComponent=!0;const XLt={toc:[]},_Lt="wrapper";function wLt(e){let{components:n,...t}=e;return(0,s.yg)(_Lt,(0,p.A)({},XLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wLt.isMDXComponent=!0;const TLt={toc:[]},CLt="wrapper";function xLt(e){let{components:n,...t}=e;return(0,s.yg)(CLt,(0,p.A)({},TLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}xLt.isMDXComponent=!0;const ALt={toc:[]},vLt="wrapper";function LLt(e){let{components:n,...t}=e;return(0,s.yg)(vLt,(0,p.A)({},ALt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LLt.isMDXComponent=!0;const bLt={toc:[]},NLt="wrapper";function kLt(e){let{components:n,...t}=e;return(0,s.yg)(NLt,(0,p.A)({},bLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}kLt.isMDXComponent=!0;const zLt={toc:[]},PLt="wrapper";function ILt(e){let{components:n,...t}=e;return(0,s.yg)(PLt,(0,p.A)({},zLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ILt.isMDXComponent=!0;const RLt={toc:[]},WLt="wrapper";function SLt(e){let{components:n,...t}=e;return(0,s.yg)(WLt,(0,p.A)({},RLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}SLt.isMDXComponent=!0;const BLt={toc:[]},GLt="wrapper";function ELt(e){let{components:n,...t}=e;return(0,s.yg)(GLt,(0,p.A)({},BLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}ELt.isMDXComponent=!0;const OLt={toc:[]},ULt="wrapper";function FLt(e){let{components:n,...t}=e;return(0,s.yg)(ULt,(0,p.A)({},OLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}FLt.isMDXComponent=!0;const VLt={toc:[]},qLt="wrapper";function jLt(e){let{components:n,...t}=e;return(0,s.yg)(qLt,(0,p.A)({},VLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}jLt.isMDXComponent=!0;const HLt={toc:[]},YLt="wrapper";function QLt(e){let{components:n,...t}=e;return(0,s.yg)(YLt,(0,p.A)({},HLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}QLt.isMDXComponent=!0;const $Lt={toc:[]},KLt="wrapper";function JLt(e){let{components:n,...t}=e;return(0,s.yg)(KLt,(0,p.A)({},$Lt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}JLt.isMDXComponent=!0;const ZLt={toc:[]},ebt="wrapper";function nbt(e){let{components:n,...t}=e;return(0,s.yg)(ebt,(0,p.A)({},ZLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}nbt.isMDXComponent=!0;const tbt={toc:[]},obt="wrapper";function pbt(e){let{components:n,...t}=e;return(0,s.yg)(obt,(0,p.A)({},tbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pbt.isMDXComponent=!0;const rbt={toc:[]},sbt="wrapper";function cbt(e){let{components:n,...t}=e;return(0,s.yg)(sbt,(0,p.A)({},rbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}cbt.isMDXComponent=!0;const abt={toc:[]},ibt="wrapper";function lbt(e){let{components:n,...t}=e;return(0,s.yg)(ibt,(0,p.A)({},abt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lbt.isMDXComponent=!0;const ubt={toc:[]},mbt="wrapper";function ybt(e){let{components:n,...t}=e;return(0,s.yg)(mbt,(0,p.A)({},ubt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}ybt.isMDXComponent=!0;const dbt={toc:[]},hbt="wrapper";function gbt(e){let{components:n,...t}=e;return(0,s.yg)(hbt,(0,p.A)({},dbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}gbt.isMDXComponent=!0;const fbt={toc:[]},Dbt="wrapper";function Mbt(e){let{components:n,...t}=e;return(0,s.yg)(Dbt,(0,p.A)({},fbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Mbt.isMDXComponent=!0;const Xbt={toc:[]},_bt="wrapper";function wbt(e){let{components:n,...t}=e;return(0,s.yg)(_bt,(0,p.A)({},Xbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}wbt.isMDXComponent=!0;const Tbt={toc:[]},Cbt="wrapper";function xbt(e){let{components:n,...t}=e;return(0,s.yg)(Cbt,(0,p.A)({},Tbt,t,{components:n,mdxType:"MDXLayout"}))}xbt.isMDXComponent=!0;const Abt={toc:[]},vbt="wrapper";function Lbt(e){let{components:n,...t}=e;return(0,s.yg)(vbt,(0,p.A)({},Abt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Lbt.isMDXComponent=!0;const bbt={toc:[]},Nbt="wrapper";function kbt(e){let{components:n,...t}=e;return(0,s.yg)(Nbt,(0,p.A)({},bbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}kbt.isMDXComponent=!0;const zbt={toc:[]},Pbt="wrapper";function Ibt(e){let{components:n,...t}=e;return(0,s.yg)(Pbt,(0,p.A)({},zbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Ibt.isMDXComponent=!0;const Rbt={toc:[]},Wbt="wrapper";function Sbt(e){let{components:n,...t}=e;return(0,s.yg)(Wbt,(0,p.A)({},Rbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Sbt.isMDXComponent=!0;const Bbt={toc:[]},Gbt="wrapper";function Ebt(e){let{components:n,...t}=e;return(0,s.yg)(Gbt,(0,p.A)({},Bbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Ebt.isMDXComponent=!0;const Obt={toc:[]},Ubt="wrapper";function Fbt(e){let{components:n,...t}=e;return(0,s.yg)(Ubt,(0,p.A)({},Obt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Fbt.isMDXComponent=!0;const Vbt={toc:[]},qbt="wrapper";function jbt(e){let{components:n,...t}=e;return(0,s.yg)(qbt,(0,p.A)({},Vbt,t,{components:n,mdxType:"MDXLayout"}))}jbt.isMDXComponent=!0;const Hbt={toc:[]},Ybt="wrapper";function Qbt(e){let{components:n,...t}=e;return(0,s.yg)(Ybt,(0,p.A)({},Hbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Qbt.isMDXComponent=!0;const $bt={toc:[]},Kbt="wrapper";function Jbt(e){let{components:n,...t}=e;return(0,s.yg)(Kbt,(0,p.A)({},$bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Jbt.isMDXComponent=!0;const Zbt={toc:[]},eNt="wrapper";function nNt(e){let{components:n,...t}=e;return(0,s.yg)(eNt,(0,p.A)({},Zbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nNt.isMDXComponent=!0;const tNt={toc:[]},oNt="wrapper";function pNt(e){let{components:n,...t}=e;return(0,s.yg)(oNt,(0,p.A)({},tNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}pNt.isMDXComponent=!0;const rNt={toc:[]},sNt="wrapper";function cNt(e){let{components:n,...t}=e;return(0,s.yg)(sNt,(0,p.A)({},rNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}cNt.isMDXComponent=!0;const aNt={toc:[]},iNt="wrapper";function lNt(e){let{components:n,...t}=e;return(0,s.yg)(iNt,(0,p.A)({},aNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}lNt.isMDXComponent=!0;const uNt={toc:[]},mNt="wrapper";function yNt(e){let{components:n,...t}=e;return(0,s.yg)(mNt,(0,p.A)({},uNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}yNt.isMDXComponent=!0;const dNt={toc:[]},hNt="wrapper";function gNt(e){let{components:n,...t}=e;return(0,s.yg)(hNt,(0,p.A)({},dNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}gNt.isMDXComponent=!0;const fNt={toc:[]},DNt="wrapper";function MNt(e){let{components:n,...t}=e;return(0,s.yg)(DNt,(0,p.A)({},fNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}MNt.isMDXComponent=!0;const XNt={toc:[]},_Nt="wrapper";function wNt(e){let{components:n,...t}=e;return(0,s.yg)(_Nt,(0,p.A)({},XNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}wNt.isMDXComponent=!0;const TNt={toc:[]},CNt="wrapper";function xNt(e){let{components:n,...t}=e;return(0,s.yg)(CNt,(0,p.A)({},TNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}xNt.isMDXComponent=!0;const ANt={toc:[]},vNt="wrapper";function LNt(e){let{components:n,...t}=e;return(0,s.yg)(vNt,(0,p.A)({},ANt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}LNt.isMDXComponent=!0;const bNt={toc:[]},NNt="wrapper";function kNt(e){let{components:n,...t}=e;return(0,s.yg)(NNt,(0,p.A)({},bNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}kNt.isMDXComponent=!0;const zNt={toc:[]},PNt="wrapper";function INt(e){let{components:n,...t}=e;return(0,s.yg)(PNt,(0,p.A)({},zNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}INt.isMDXComponent=!0;const RNt={toc:[]},WNt="wrapper";function SNt(e){let{components:n,...t}=e;return(0,s.yg)(WNt,(0,p.A)({},RNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}SNt.isMDXComponent=!0;const BNt={toc:[]},GNt="wrapper";function ENt(e){let{components:n,...t}=e;return(0,s.yg)(GNt,(0,p.A)({},BNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}ENt.isMDXComponent=!0;const ONt={toc:[]},UNt="wrapper";function FNt(e){let{components:n,...t}=e;return(0,s.yg)(UNt,(0,p.A)({},ONt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}FNt.isMDXComponent=!0;const VNt={toc:[]},qNt="wrapper";function jNt(e){let{components:n,...t}=e;return(0,s.yg)(qNt,(0,p.A)({},VNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}jNt.isMDXComponent=!0;const HNt={toc:[]},YNt="wrapper";function QNt(e){let{components:n,...t}=e;return(0,s.yg)(YNt,(0,p.A)({},HNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}QNt.isMDXComponent=!0;const $Nt={toc:[]},KNt="wrapper";function JNt(e){let{components:n,...t}=e;return(0,s.yg)(KNt,(0,p.A)({},$Nt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}JNt.isMDXComponent=!0;const ZNt={toc:[]},ekt="wrapper";function nkt(e){let{components:n,...t}=e;return(0,s.yg)(ekt,(0,p.A)({},ZNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}nkt.isMDXComponent=!0;const tkt={toc:[]},okt="wrapper";function pkt(e){let{components:n,...t}=e;return(0,s.yg)(okt,(0,p.A)({},tkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}pkt.isMDXComponent=!0;const rkt={toc:[]},skt="wrapper";function ckt(e){let{components:n,...t}=e;return(0,s.yg)(skt,(0,p.A)({},rkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}ckt.isMDXComponent=!0;const akt={toc:[]},ikt="wrapper";function lkt(e){let{components:n,...t}=e;return(0,s.yg)(ikt,(0,p.A)({},akt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}lkt.isMDXComponent=!0;const ukt={toc:[]},mkt="wrapper";function ykt(e){let{components:n,...t}=e;return(0,s.yg)(mkt,(0,p.A)({},ukt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}ykt.isMDXComponent=!0;const dkt={toc:[]},hkt="wrapper";function gkt(e){let{components:n,...t}=e;return(0,s.yg)(hkt,(0,p.A)({},dkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}gkt.isMDXComponent=!0;const fkt={toc:[]},Dkt="wrapper";function Mkt(e){let{components:n,...t}=e;return(0,s.yg)(Dkt,(0,p.A)({},fkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Mkt.isMDXComponent=!0;const Xkt={toc:[]},_kt="wrapper";function wkt(e){let{components:n,...t}=e;return(0,s.yg)(_kt,(0,p.A)({},Xkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}wkt.isMDXComponent=!0;const Tkt={toc:[]},Ckt="wrapper";function xkt(e){let{components:n,...t}=e;return(0,s.yg)(Ckt,(0,p.A)({},Tkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}xkt.isMDXComponent=!0;const Akt={toc:[]},vkt="wrapper";function Lkt(e){let{components:n,...t}=e;return(0,s.yg)(vkt,(0,p.A)({},Akt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Lkt.isMDXComponent=!0;const bkt={toc:[]},Nkt="wrapper";function kkt(e){let{components:n,...t}=e;return(0,s.yg)(Nkt,(0,p.A)({},bkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}kkt.isMDXComponent=!0;const zkt={toc:[]},Pkt="wrapper";function Ikt(e){let{components:n,...t}=e;return(0,s.yg)(Pkt,(0,p.A)({},zkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Ikt.isMDXComponent=!0;const Rkt={toc:[]},Wkt="wrapper";function Skt(e){let{components:n,...t}=e;return(0,s.yg)(Wkt,(0,p.A)({},Rkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Skt.isMDXComponent=!0;const Bkt={toc:[]},Gkt="wrapper";function Ekt(e){let{components:n,...t}=e;return(0,s.yg)(Gkt,(0,p.A)({},Bkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Ekt.isMDXComponent=!0;const Okt={toc:[]},Ukt="wrapper";function Fkt(e){let{components:n,...t}=e;return(0,s.yg)(Ukt,(0,p.A)({},Okt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Fkt.isMDXComponent=!0;const Vkt={toc:[]},qkt="wrapper";function jkt(e){let{components:n,...t}=e;return(0,s.yg)(qkt,(0,p.A)({},Vkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}jkt.isMDXComponent=!0;const Hkt={toc:[]},Ykt="wrapper";function Qkt(e){let{components:n,...t}=e;return(0,s.yg)(Ykt,(0,p.A)({},Hkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Qkt.isMDXComponent=!0;const $kt={toc:[]},Kkt="wrapper";function Jkt(e){let{components:n,...t}=e;return(0,s.yg)(Kkt,(0,p.A)({},$kt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Jkt.isMDXComponent=!0;const Zkt={toc:[]},ezt="wrapper";function nzt(e){let{components:n,...t}=e;return(0,s.yg)(ezt,(0,p.A)({},Zkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}nzt.isMDXComponent=!0;const tzt={toc:[]},ozt="wrapper";function pzt(e){let{components:n,...t}=e;return(0,s.yg)(ozt,(0,p.A)({},tzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}pzt.isMDXComponent=!0;const rzt={toc:[]},szt="wrapper";function czt(e){let{components:n,...t}=e;return(0,s.yg)(szt,(0,p.A)({},rzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}czt.isMDXComponent=!0;const azt={toc:[]},izt="wrapper";function lzt(e){let{components:n,...t}=e;return(0,s.yg)(izt,(0,p.A)({},azt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}lzt.isMDXComponent=!0;const uzt={toc:[]},mzt="wrapper";function yzt(e){let{components:n,...t}=e;return(0,s.yg)(mzt,(0,p.A)({},uzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}yzt.isMDXComponent=!0;const dzt={toc:[]},hzt="wrapper";function gzt(e){let{components:n,...t}=e;return(0,s.yg)(hzt,(0,p.A)({},dzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}gzt.isMDXComponent=!0;const fzt={toc:[]},Dzt="wrapper";function Mzt(e){let{components:n,...t}=e;return(0,s.yg)(Dzt,(0,p.A)({},fzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Mzt.isMDXComponent=!0;const Xzt={toc:[]},_zt="wrapper";function wzt(e){let{components:n,...t}=e;return(0,s.yg)(_zt,(0,p.A)({},Xzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wzt.isMDXComponent=!0;const Tzt={toc:[]},Czt="wrapper";function xzt(e){let{components:n,...t}=e;return(0,s.yg)(Czt,(0,p.A)({},Tzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}xzt.isMDXComponent=!0;const Azt={toc:[]},vzt="wrapper";function Lzt(e){let{components:n,...t}=e;return(0,s.yg)(vzt,(0,p.A)({},Azt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Lzt.isMDXComponent=!0;const bzt={toc:[]},Nzt="wrapper";function kzt(e){let{components:n,...t}=e;return(0,s.yg)(Nzt,(0,p.A)({},bzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kzt.isMDXComponent=!0;const zzt={toc:[]},Pzt="wrapper";function Izt(e){let{components:n,...t}=e;return(0,s.yg)(Pzt,(0,p.A)({},zzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Izt.isMDXComponent=!0;const Rzt={toc:[]},Wzt="wrapper";function Szt(e){let{components:n,...t}=e;return(0,s.yg)(Wzt,(0,p.A)({},Rzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Szt.isMDXComponent=!0;const Bzt={toc:[]},Gzt="wrapper";function Ezt(e){let{components:n,...t}=e;return(0,s.yg)(Gzt,(0,p.A)({},Bzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Ezt.isMDXComponent=!0;const Ozt={toc:[]},Uzt="wrapper";function Fzt(e){let{components:n,...t}=e;return(0,s.yg)(Uzt,(0,p.A)({},Ozt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Fzt.isMDXComponent=!0;const Vzt={toc:[]},qzt="wrapper";function jzt(e){let{components:n,...t}=e;return(0,s.yg)(qzt,(0,p.A)({},Vzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jzt.isMDXComponent=!0;const Hzt={toc:[]},Yzt="wrapper";function Qzt(e){let{components:n,...t}=e;return(0,s.yg)(Yzt,(0,p.A)({},Hzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Qzt.isMDXComponent=!0;const $zt={toc:[]},Kzt="wrapper";function Jzt(e){let{components:n,...t}=e;return(0,s.yg)(Kzt,(0,p.A)({},$zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jzt.isMDXComponent=!0;const Zzt={toc:[]},ePt="wrapper";function nPt(e){let{components:n,...t}=e;return(0,s.yg)(ePt,(0,p.A)({},Zzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nPt.isMDXComponent=!0;const tPt={toc:[]},oPt="wrapper";function pPt(e){let{components:n,...t}=e;return(0,s.yg)(oPt,(0,p.A)({},tPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pPt.isMDXComponent=!0;const rPt={toc:[]},sPt="wrapper";function cPt(e){let{components:n,...t}=e;return(0,s.yg)(sPt,(0,p.A)({},rPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cPt.isMDXComponent=!0;const aPt={toc:[]},iPt="wrapper";function lPt(e){let{components:n,...t}=e;return(0,s.yg)(iPt,(0,p.A)({},aPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lPt.isMDXComponent=!0;const uPt={toc:[]},mPt="wrapper";function yPt(e){let{components:n,...t}=e;return(0,s.yg)(mPt,(0,p.A)({},uPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}yPt.isMDXComponent=!0;const dPt={toc:[]},hPt="wrapper";function gPt(e){let{components:n,...t}=e;return(0,s.yg)(hPt,(0,p.A)({},dPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gPt.isMDXComponent=!0;const fPt={toc:[]},DPt="wrapper";function MPt(e){let{components:n,...t}=e;return(0,s.yg)(DPt,(0,p.A)({},fPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}MPt.isMDXComponent=!0;const XPt={toc:[]},_Pt="wrapper";function wPt(e){let{components:n,...t}=e;return(0,s.yg)(_Pt,(0,p.A)({},XPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wPt.isMDXComponent=!0;const TPt={toc:[]},CPt="wrapper";function xPt(e){let{components:n,...t}=e;return(0,s.yg)(CPt,(0,p.A)({},TPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}xPt.isMDXComponent=!0;const APt={toc:[]},vPt="wrapper";function LPt(e){let{components:n,...t}=e;return(0,s.yg)(vPt,(0,p.A)({},APt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LPt.isMDXComponent=!0;const bPt={toc:[]},NPt="wrapper";function kPt(e){let{components:n,...t}=e;return(0,s.yg)(NPt,(0,p.A)({},bPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}kPt.isMDXComponent=!0;const zPt={toc:[]},PPt="wrapper";function IPt(e){let{components:n,...t}=e;return(0,s.yg)(PPt,(0,p.A)({},zPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}IPt.isMDXComponent=!0;const RPt={toc:[]},WPt="wrapper";function SPt(e){let{components:n,...t}=e;return(0,s.yg)(WPt,(0,p.A)({},RPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}SPt.isMDXComponent=!0;const BPt={toc:[]},GPt="wrapper";function EPt(e){let{components:n,...t}=e;return(0,s.yg)(GPt,(0,p.A)({},BPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}EPt.isMDXComponent=!0;const OPt={toc:[]},UPt="wrapper";function FPt(e){let{components:n,...t}=e;return(0,s.yg)(UPt,(0,p.A)({},OPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}FPt.isMDXComponent=!0;const VPt={toc:[]},qPt="wrapper";function jPt(e){let{components:n,...t}=e;return(0,s.yg)(qPt,(0,p.A)({},VPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}jPt.isMDXComponent=!0;const HPt={toc:[]},YPt="wrapper";function QPt(e){let{components:n,...t}=e;return(0,s.yg)(YPt,(0,p.A)({},HPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}QPt.isMDXComponent=!0;const $Pt={toc:[]},KPt="wrapper";function JPt(e){let{components:n,...t}=e;return(0,s.yg)(KPt,(0,p.A)({},$Pt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}JPt.isMDXComponent=!0;const ZPt={toc:[]},eIt="wrapper";function nIt(e){let{components:n,...t}=e;return(0,s.yg)(eIt,(0,p.A)({},ZPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}nIt.isMDXComponent=!0;const tIt={toc:[]},oIt="wrapper";function pIt(e){let{components:n,...t}=e;return(0,s.yg)(oIt,(0,p.A)({},tIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}pIt.isMDXComponent=!0;const rIt={toc:[]},sIt="wrapper";function cIt(e){let{components:n,...t}=e;return(0,s.yg)(sIt,(0,p.A)({},rIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}cIt.isMDXComponent=!0;const aIt={toc:[]},iIt="wrapper";function lIt(e){let{components:n,...t}=e;return(0,s.yg)(iIt,(0,p.A)({},aIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}lIt.isMDXComponent=!0;const uIt={toc:[]},mIt="wrapper";function yIt(e){let{components:n,...t}=e;return(0,s.yg)(mIt,(0,p.A)({},uIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}yIt.isMDXComponent=!0;const dIt={toc:[]},hIt="wrapper";function gIt(e){let{components:n,...t}=e;return(0,s.yg)(hIt,(0,p.A)({},dIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}gIt.isMDXComponent=!0;const fIt={toc:[]},DIt="wrapper";function MIt(e){let{components:n,...t}=e;return(0,s.yg)(DIt,(0,p.A)({},fIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}MIt.isMDXComponent=!0;const XIt={toc:[]},_It="wrapper";function wIt(e){let{components:n,...t}=e;return(0,s.yg)(_It,(0,p.A)({},XIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}wIt.isMDXComponent=!0;const TIt={toc:[]},CIt="wrapper";function xIt(e){let{components:n,...t}=e;return(0,s.yg)(CIt,(0,p.A)({},TIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}xIt.isMDXComponent=!0;const AIt={toc:[]},vIt="wrapper";function LIt(e){let{components:n,...t}=e;return(0,s.yg)(vIt,(0,p.A)({},AIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}LIt.isMDXComponent=!0;const bIt={toc:[]},NIt="wrapper";function kIt(e){let{components:n,...t}=e;return(0,s.yg)(NIt,(0,p.A)({},bIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kIt.isMDXComponent=!0;const zIt={toc:[]},PIt="wrapper";function IIt(e){let{components:n,...t}=e;return(0,s.yg)(PIt,(0,p.A)({},zIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}IIt.isMDXComponent=!0;const RIt={toc:[]},WIt="wrapper";function SIt(e){let{components:n,...t}=e;return(0,s.yg)(WIt,(0,p.A)({},RIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}SIt.isMDXComponent=!0;const BIt={toc:[]},GIt="wrapper";function EIt(e){let{components:n,...t}=e;return(0,s.yg)(GIt,(0,p.A)({},BIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}EIt.isMDXComponent=!0;const OIt={toc:[]},UIt="wrapper";function FIt(e){let{components:n,...t}=e;return(0,s.yg)(UIt,(0,p.A)({},OIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}FIt.isMDXComponent=!0;const VIt={toc:[]},qIt="wrapper";function jIt(e){let{components:n,...t}=e;return(0,s.yg)(qIt,(0,p.A)({},VIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}jIt.isMDXComponent=!0;const HIt={toc:[]},YIt="wrapper";function QIt(e){let{components:n,...t}=e;return(0,s.yg)(YIt,(0,p.A)({},HIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}QIt.isMDXComponent=!0;const $It={toc:[]},KIt="wrapper";function JIt(e){let{components:n,...t}=e;return(0,s.yg)(KIt,(0,p.A)({},$It,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}JIt.isMDXComponent=!0;const ZIt={toc:[]},eRt="wrapper";function nRt(e){let{components:n,...t}=e;return(0,s.yg)(eRt,(0,p.A)({},ZIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}nRt.isMDXComponent=!0;const tRt={toc:[]},oRt="wrapper";function pRt(e){let{components:n,...t}=e;return(0,s.yg)(oRt,(0,p.A)({},tRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}pRt.isMDXComponent=!0;const rRt={toc:[]},sRt="wrapper";function cRt(e){let{components:n,...t}=e;return(0,s.yg)(sRt,(0,p.A)({},rRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}cRt.isMDXComponent=!0;const aRt={toc:[]},iRt="wrapper";function lRt(e){let{components:n,...t}=e;return(0,s.yg)(iRt,(0,p.A)({},aRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}lRt.isMDXComponent=!0;const uRt={toc:[]},mRt="wrapper";function yRt(e){let{components:n,...t}=e;return(0,s.yg)(mRt,(0,p.A)({},uRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}yRt.isMDXComponent=!0;const dRt={toc:[]},hRt="wrapper";function gRt(e){let{components:n,...t}=e;return(0,s.yg)(hRt,(0,p.A)({},dRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}gRt.isMDXComponent=!0;const fRt={toc:[]},DRt="wrapper";function MRt(e){let{components:n,...t}=e;return(0,s.yg)(DRt,(0,p.A)({},fRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}MRt.isMDXComponent=!0;const XRt={toc:[]},_Rt="wrapper";function wRt(e){let{components:n,...t}=e;return(0,s.yg)(_Rt,(0,p.A)({},XRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wRt.isMDXComponent=!0;const TRt={toc:[]},CRt="wrapper";function xRt(e){let{components:n,...t}=e;return(0,s.yg)(CRt,(0,p.A)({},TRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}xRt.isMDXComponent=!0;const ARt={toc:[]},vRt="wrapper";function LRt(e){let{components:n,...t}=e;return(0,s.yg)(vRt,(0,p.A)({},ARt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}LRt.isMDXComponent=!0;const bRt={toc:[]},NRt="wrapper";function kRt(e){let{components:n,...t}=e;return(0,s.yg)(NRt,(0,p.A)({},bRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kRt.isMDXComponent=!0;const zRt={toc:[]},PRt="wrapper";function IRt(e){let{components:n,...t}=e;return(0,s.yg)(PRt,(0,p.A)({},zRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}IRt.isMDXComponent=!0;const RRt={toc:[]},WRt="wrapper";function SRt(e){let{components:n,...t}=e;return(0,s.yg)(WRt,(0,p.A)({},RRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}SRt.isMDXComponent=!0;const BRt={toc:[]},GRt="wrapper";function ERt(e){let{components:n,...t}=e;return(0,s.yg)(GRt,(0,p.A)({},BRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}ERt.isMDXComponent=!0;const ORt={toc:[]},URt="wrapper";function FRt(e){let{components:n,...t}=e;return(0,s.yg)(URt,(0,p.A)({},ORt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}FRt.isMDXComponent=!0;const VRt={toc:[]},qRt="wrapper";function jRt(e){let{components:n,...t}=e;return(0,s.yg)(qRt,(0,p.A)({},VRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}jRt.isMDXComponent=!0;const HRt={toc:[]},YRt="wrapper";function QRt(e){let{components:n,...t}=e;return(0,s.yg)(YRt,(0,p.A)({},HRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}QRt.isMDXComponent=!0;const $Rt={toc:[]},KRt="wrapper";function JRt(e){let{components:n,...t}=e;return(0,s.yg)(KRt,(0,p.A)({},$Rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}JRt.isMDXComponent=!0;const ZRt={toc:[]},eWt="wrapper";function nWt(e){let{components:n,...t}=e;return(0,s.yg)(eWt,(0,p.A)({},ZRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}nWt.isMDXComponent=!0;const tWt={toc:[]},oWt="wrapper";function pWt(e){let{components:n,...t}=e;return(0,s.yg)(oWt,(0,p.A)({},tWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pWt.isMDXComponent=!0;const rWt={toc:[]},sWt="wrapper";function cWt(e){let{components:n,...t}=e;return(0,s.yg)(sWt,(0,p.A)({},rWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}cWt.isMDXComponent=!0;const aWt={toc:[]},iWt="wrapper";function lWt(e){let{components:n,...t}=e;return(0,s.yg)(iWt,(0,p.A)({},aWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}lWt.isMDXComponent=!0;const uWt={toc:[]},mWt="wrapper";function yWt(e){let{components:n,...t}=e;return(0,s.yg)(mWt,(0,p.A)({},uWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}yWt.isMDXComponent=!0;const dWt={toc:[]},hWt="wrapper";function gWt(e){let{components:n,...t}=e;return(0,s.yg)(hWt,(0,p.A)({},dWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}gWt.isMDXComponent=!0;const fWt={toc:[]},DWt="wrapper";function MWt(e){let{components:n,...t}=e;return(0,s.yg)(DWt,(0,p.A)({},fWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}MWt.isMDXComponent=!0;const XWt={toc:[]},_Wt="wrapper";function wWt(e){let{components:n,...t}=e;return(0,s.yg)(_Wt,(0,p.A)({},XWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}wWt.isMDXComponent=!0;const TWt={toc:[]},CWt="wrapper";function xWt(e){let{components:n,...t}=e;return(0,s.yg)(CWt,(0,p.A)({},TWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}xWt.isMDXComponent=!0;const AWt={toc:[]},vWt="wrapper";function LWt(e){let{components:n,...t}=e;return(0,s.yg)(vWt,(0,p.A)({},AWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}LWt.isMDXComponent=!0;const bWt={toc:[]},NWt="wrapper";function kWt(e){let{components:n,...t}=e;return(0,s.yg)(NWt,(0,p.A)({},bWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}kWt.isMDXComponent=!0;const zWt={toc:[]},PWt="wrapper";function IWt(e){let{components:n,...t}=e;return(0,s.yg)(PWt,(0,p.A)({},zWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}IWt.isMDXComponent=!0;const RWt={toc:[]},WWt="wrapper";function SWt(e){let{components:n,...t}=e;return(0,s.yg)(WWt,(0,p.A)({},RWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}SWt.isMDXComponent=!0;const BWt={toc:[]},GWt="wrapper";function EWt(e){let{components:n,...t}=e;return(0,s.yg)(GWt,(0,p.A)({},BWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}EWt.isMDXComponent=!0;const OWt={toc:[]},UWt="wrapper";function FWt(e){let{components:n,...t}=e;return(0,s.yg)(UWt,(0,p.A)({},OWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}FWt.isMDXComponent=!0;const VWt={toc:[]},qWt="wrapper";function jWt(e){let{components:n,...t}=e;return(0,s.yg)(qWt,(0,p.A)({},VWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}jWt.isMDXComponent=!0;const HWt={toc:[]},YWt="wrapper";function QWt(e){let{components:n,...t}=e;return(0,s.yg)(YWt,(0,p.A)({},HWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}QWt.isMDXComponent=!0;const $Wt={toc:[]},KWt="wrapper";function JWt(e){let{components:n,...t}=e;return(0,s.yg)(KWt,(0,p.A)({},$Wt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}JWt.isMDXComponent=!0;const ZWt={toc:[]},eSt="wrapper";function nSt(e){let{components:n,...t}=e;return(0,s.yg)(eSt,(0,p.A)({},ZWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}nSt.isMDXComponent=!0;const tSt={toc:[]},oSt="wrapper";function pSt(e){let{components:n,...t}=e;return(0,s.yg)(oSt,(0,p.A)({},tSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}pSt.isMDXComponent=!0;const rSt={toc:[]},sSt="wrapper";function cSt(e){let{components:n,...t}=e;return(0,s.yg)(sSt,(0,p.A)({},rSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}cSt.isMDXComponent=!0;const aSt={toc:[]},iSt="wrapper";function lSt(e){let{components:n,...t}=e;return(0,s.yg)(iSt,(0,p.A)({},aSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lSt.isMDXComponent=!0;const uSt={toc:[]},mSt="wrapper";function ySt(e){let{components:n,...t}=e;return(0,s.yg)(mSt,(0,p.A)({},uSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}ySt.isMDXComponent=!0;const dSt={toc:[]},hSt="wrapper";function gSt(e){let{components:n,...t}=e;return(0,s.yg)(hSt,(0,p.A)({},dSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}gSt.isMDXComponent=!0;const fSt={toc:[]},DSt="wrapper";function MSt(e){let{components:n,...t}=e;return(0,s.yg)(DSt,(0,p.A)({},fSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}MSt.isMDXComponent=!0;const XSt={toc:[]},_St="wrapper";function wSt(e){let{components:n,...t}=e;return(0,s.yg)(_St,(0,p.A)({},XSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}wSt.isMDXComponent=!0;const TSt={toc:[]},CSt="wrapper";function xSt(e){let{components:n,...t}=e;return(0,s.yg)(CSt,(0,p.A)({},TSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}xSt.isMDXComponent=!0;const ASt={toc:[]},vSt="wrapper";function LSt(e){let{components:n,...t}=e;return(0,s.yg)(vSt,(0,p.A)({},ASt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}LSt.isMDXComponent=!0;const bSt={toc:[]},NSt="wrapper";function kSt(e){let{components:n,...t}=e;return(0,s.yg)(NSt,(0,p.A)({},bSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}kSt.isMDXComponent=!0;const zSt={toc:[]},PSt="wrapper";function ISt(e){let{components:n,...t}=e;return(0,s.yg)(PSt,(0,p.A)({},zSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ISt.isMDXComponent=!0;const RSt={toc:[]},WSt="wrapper";function SSt(e){let{components:n,...t}=e;return(0,s.yg)(WSt,(0,p.A)({},RSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}SSt.isMDXComponent=!0;const BSt={toc:[]},GSt="wrapper";function ESt(e){let{components:n,...t}=e;return(0,s.yg)(GSt,(0,p.A)({},BSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}ESt.isMDXComponent=!0;const OSt={toc:[]},USt="wrapper";function FSt(e){let{components:n,...t}=e;return(0,s.yg)(USt,(0,p.A)({},OSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}FSt.isMDXComponent=!0;const VSt={toc:[]},qSt="wrapper";function jSt(e){let{components:n,...t}=e;return(0,s.yg)(qSt,(0,p.A)({},VSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}jSt.isMDXComponent=!0;const HSt={toc:[]},YSt="wrapper";function QSt(e){let{components:n,...t}=e;return(0,s.yg)(YSt,(0,p.A)({},HSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}QSt.isMDXComponent=!0;const $St={toc:[]},KSt="wrapper";function JSt(e){let{components:n,...t}=e;return(0,s.yg)(KSt,(0,p.A)({},$St,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}JSt.isMDXComponent=!0;const ZSt={toc:[]},eBt="wrapper";function nBt(e){let{components:n,...t}=e;return(0,s.yg)(eBt,(0,p.A)({},ZSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}nBt.isMDXComponent=!0;const tBt={toc:[]},oBt="wrapper";function pBt(e){let{components:n,...t}=e;return(0,s.yg)(oBt,(0,p.A)({},tBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pBt.isMDXComponent=!0;const rBt={toc:[]},sBt="wrapper";function cBt(e){let{components:n,...t}=e;return(0,s.yg)(sBt,(0,p.A)({},rBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cBt.isMDXComponent=!0;const aBt={toc:[]},iBt="wrapper";function lBt(e){let{components:n,...t}=e;return(0,s.yg)(iBt,(0,p.A)({},aBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lBt.isMDXComponent=!0;const uBt={toc:[]},mBt="wrapper";function yBt(e){let{components:n,...t}=e;return(0,s.yg)(mBt,(0,p.A)({},uBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}yBt.isMDXComponent=!0;const dBt={toc:[]},hBt="wrapper";function gBt(e){let{components:n,...t}=e;return(0,s.yg)(hBt,(0,p.A)({},dBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}gBt.isMDXComponent=!0;const fBt={toc:[]},DBt="wrapper";function MBt(e){let{components:n,...t}=e;return(0,s.yg)(DBt,(0,p.A)({},fBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MBt.isMDXComponent=!0;const XBt={toc:[]},_Bt="wrapper";function wBt(e){let{components:n,...t}=e;return(0,s.yg)(_Bt,(0,p.A)({},XBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}wBt.isMDXComponent=!0;const TBt={toc:[]},CBt="wrapper";function xBt(e){let{components:n,...t}=e;return(0,s.yg)(CBt,(0,p.A)({},TBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}xBt.isMDXComponent=!0;const ABt={toc:[]},vBt="wrapper";function LBt(e){let{components:n,...t}=e;return(0,s.yg)(vBt,(0,p.A)({},ABt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}LBt.isMDXComponent=!0;const bBt={toc:[]},NBt="wrapper";function kBt(e){let{components:n,...t}=e;return(0,s.yg)(NBt,(0,p.A)({},bBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}kBt.isMDXComponent=!0;const zBt={toc:[]},PBt="wrapper";function IBt(e){let{components:n,...t}=e;return(0,s.yg)(PBt,(0,p.A)({},zBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}IBt.isMDXComponent=!0;const RBt={toc:[]},WBt="wrapper";function SBt(e){let{components:n,...t}=e;return(0,s.yg)(WBt,(0,p.A)({},RBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}SBt.isMDXComponent=!0;const BBt={toc:[]},GBt="wrapper";function EBt(e){let{components:n,...t}=e;return(0,s.yg)(GBt,(0,p.A)({},BBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}EBt.isMDXComponent=!0;const OBt={toc:[]},UBt="wrapper";function FBt(e){let{components:n,...t}=e;return(0,s.yg)(UBt,(0,p.A)({},OBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}FBt.isMDXComponent=!0;const VBt={toc:[]},qBt="wrapper";function jBt(e){let{components:n,...t}=e;return(0,s.yg)(qBt,(0,p.A)({},VBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}jBt.isMDXComponent=!0;const HBt={toc:[]},YBt="wrapper";function QBt(e){let{components:n,...t}=e;return(0,s.yg)(YBt,(0,p.A)({},HBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}QBt.isMDXComponent=!0;const $Bt={toc:[]},KBt="wrapper";function JBt(e){let{components:n,...t}=e;return(0,s.yg)(KBt,(0,p.A)({},$Bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}JBt.isMDXComponent=!0;const ZBt={toc:[]},eGt="wrapper";function nGt(e){let{components:n,...t}=e;return(0,s.yg)(eGt,(0,p.A)({},ZBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nGt.isMDXComponent=!0;const tGt={toc:[]},oGt="wrapper";function pGt(e){let{components:n,...t}=e;return(0,s.yg)(oGt,(0,p.A)({},tGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}pGt.isMDXComponent=!0;const rGt={toc:[]},sGt="wrapper";function cGt(e){let{components:n,...t}=e;return(0,s.yg)(sGt,(0,p.A)({},rGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cGt.isMDXComponent=!0;const aGt={toc:[]},iGt="wrapper";function lGt(e){let{components:n,...t}=e;return(0,s.yg)(iGt,(0,p.A)({},aGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}lGt.isMDXComponent=!0;const uGt={toc:[]},mGt="wrapper";function yGt(e){let{components:n,...t}=e;return(0,s.yg)(mGt,(0,p.A)({},uGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.yg)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.yg)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}yGt.isMDXComponent=!0;const dGt={toc:[]},hGt="wrapper";function gGt(e){let{components:n,...t}=e;return(0,s.yg)(hGt,(0,p.A)({},dGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      radius={30}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}gGt.isMDXComponent=!0;const fGt={toc:[]},DGt="wrapper";function MGt(e){let{components:n,...t}=e;return(0,s.yg)(DGt,(0,p.A)({},fGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing regular polygons."))}MGt.isMDXComponent=!0;const XGt={toc:[]},_Gt="wrapper";function wGt(e){let{components:n,...t}=e;return(0,s.yg)(_Gt,(0,p.A)({},XGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}wGt.isMDXComponent=!0;const TGt={toc:[]},CGt="wrapper";function xGt(e){let{components:n,...t}=e;return(0,s.yg)(CGt,(0,p.A)({},TGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}xGt.isMDXComponent=!0;const AGt={toc:[]},vGt="wrapper";function LGt(e){let{components:n,...t}=e;return(0,s.yg)(vGt,(0,p.A)({},AGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}LGt.isMDXComponent=!0;const bGt={toc:[]},NGt="wrapper";function kGt(e){let{components:n,...t}=e;return(0,s.yg)(NGt,(0,p.A)({},bGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}kGt.isMDXComponent=!0;const zGt={toc:[]},PGt="wrapper";function IGt(e){let{components:n,...t}=e;return(0,s.yg)(PGt,(0,p.A)({},zGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}IGt.isMDXComponent=!0;const RGt={toc:[]},WGt="wrapper";function SGt(e){let{components:n,...t}=e;return(0,s.yg)(WGt,(0,p.A)({},RGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}SGt.isMDXComponent=!0;const BGt={toc:[]},GGt="wrapper";function EGt(e){let{components:n,...t}=e;return(0,s.yg)(GGt,(0,p.A)({},BGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}EGt.isMDXComponent=!0;const OGt={toc:[]},UGt="wrapper";function FGt(e){let{components:n,...t}=e;return(0,s.yg)(UGt,(0,p.A)({},OGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}FGt.isMDXComponent=!0;const VGt={toc:[]},qGt="wrapper";function jGt(e){let{components:n,...t}=e;return(0,s.yg)(qGt,(0,p.A)({},VGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}jGt.isMDXComponent=!0;const HGt={toc:[]},YGt="wrapper";function QGt(e){let{components:n,...t}=e;return(0,s.yg)(YGt,(0,p.A)({},HGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}QGt.isMDXComponent=!0;const $Gt={toc:[]},KGt="wrapper";function JGt(e){let{components:n,...t}=e;return(0,s.yg)(KGt,(0,p.A)({},$Gt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}JGt.isMDXComponent=!0;const ZGt={toc:[]},eEt="wrapper";function nEt(e){let{components:n,...t}=e;return(0,s.yg)(eEt,(0,p.A)({},ZGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}nEt.isMDXComponent=!0;const tEt={toc:[]},oEt="wrapper";function pEt(e){let{components:n,...t}=e;return(0,s.yg)(oEt,(0,p.A)({},tEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pEt.isMDXComponent=!0;const rEt={toc:[]},sEt="wrapper";function cEt(e){let{components:n,...t}=e;return(0,s.yg)(sEt,(0,p.A)({},rEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}cEt.isMDXComponent=!0;const aEt={toc:[]},iEt="wrapper";function lEt(e){let{components:n,...t}=e;return(0,s.yg)(iEt,(0,p.A)({},aEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lEt.isMDXComponent=!0;const uEt={toc:[]},mEt="wrapper";function yEt(e){let{components:n,...t}=e;return(0,s.yg)(mEt,(0,p.A)({},uEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yEt.isMDXComponent=!0;const dEt={toc:[]},hEt="wrapper";function gEt(e){let{components:n,...t}=e;return(0,s.yg)(hEt,(0,p.A)({},dEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}gEt.isMDXComponent=!0;const fEt={toc:[]},DEt="wrapper";function MEt(e){let{components:n,...t}=e;return(0,s.yg)(DEt,(0,p.A)({},fEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}MEt.isMDXComponent=!0;const XEt={toc:[]},_Et="wrapper";function wEt(e){let{components:n,...t}=e;return(0,s.yg)(_Et,(0,p.A)({},XEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}wEt.isMDXComponent=!0;const TEt={toc:[]},CEt="wrapper";function xEt(e){let{components:n,...t}=e;return(0,s.yg)(CEt,(0,p.A)({},TEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}xEt.isMDXComponent=!0;const AEt={toc:[]},vEt="wrapper";function LEt(e){let{components:n,...t}=e;return(0,s.yg)(vEt,(0,p.A)({},AEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LEt.isMDXComponent=!0;const bEt={toc:[]},NEt="wrapper";function kEt(e){let{components:n,...t}=e;return(0,s.yg)(NEt,(0,p.A)({},bEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}kEt.isMDXComponent=!0;const zEt={toc:[]},PEt="wrapper";function IEt(e){let{components:n,...t}=e;return(0,s.yg)(PEt,(0,p.A)({},zEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}IEt.isMDXComponent=!0;const REt={toc:[]},WEt="wrapper";function SEt(e){let{components:n,...t}=e;return(0,s.yg)(WEt,(0,p.A)({},REt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}SEt.isMDXComponent=!0;const BEt={toc:[]},GEt="wrapper";function EEt(e){let{components:n,...t}=e;return(0,s.yg)(GEt,(0,p.A)({},BEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}EEt.isMDXComponent=!0;const OEt={toc:[]},UEt="wrapper";function FEt(e){let{components:n,...t}=e;return(0,s.yg)(UEt,(0,p.A)({},OEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}FEt.isMDXComponent=!0;const VEt={toc:[]},qEt="wrapper";function jEt(e){let{components:n,...t}=e;return(0,s.yg)(qEt,(0,p.A)({},VEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}jEt.isMDXComponent=!0;const HEt={toc:[]},YEt="wrapper";function QEt(e){let{components:n,...t}=e;return(0,s.yg)(YEt,(0,p.A)({},HEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}QEt.isMDXComponent=!0;const $Et={toc:[]},KEt="wrapper";function JEt(e){let{components:n,...t}=e;return(0,s.yg)(KEt,(0,p.A)({},$Et,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}JEt.isMDXComponent=!0;const ZEt={toc:[]},eOt="wrapper";function nOt(e){let{components:n,...t}=e;return(0,s.yg)(eOt,(0,p.A)({},ZEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}nOt.isMDXComponent=!0;const tOt={toc:[]},oOt="wrapper";function pOt(e){let{components:n,...t}=e;return(0,s.yg)(oOt,(0,p.A)({},tOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}pOt.isMDXComponent=!0;const rOt={toc:[]},sOt="wrapper";function cOt(e){let{components:n,...t}=e;return(0,s.yg)(sOt,(0,p.A)({},rOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}cOt.isMDXComponent=!0;const aOt={toc:[]},iOt="wrapper";function lOt(e){let{components:n,...t}=e;return(0,s.yg)(iOt,(0,p.A)({},aOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lOt.isMDXComponent=!0;const uOt={toc:[]},mOt="wrapper";function yOt(e){let{components:n,...t}=e;return(0,s.yg)(mOt,(0,p.A)({},uOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}yOt.isMDXComponent=!0;const dOt={toc:[]},hOt="wrapper";function gOt(e){let{components:n,...t}=e;return(0,s.yg)(hOt,(0,p.A)({},dOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  radius={30}\n  size={320}\n  sides={3}\n  stroke={'#fff'}\n  lineWidth={8}\n/>\n")))}gOt.isMDXComponent=!0;const fOt={toc:[]},DOt="wrapper";function MOt(e){let{components:n,...t}=e;return(0,s.yg)(DOt,(0,p.A)({},fOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the polygon's corners."))}MOt.isMDXComponent=!0;const XOt={toc:[]},_Ot="wrapper";function wOt(e){let{components:n,...t}=e;return(0,s.yg)(_Ot,(0,p.A)({},XOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wOt.isMDXComponent=!0;const TOt={toc:[]},COt="wrapper";function xOt(e){let{components:n,...t}=e;return(0,s.yg)(COt,(0,p.A)({},TOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}xOt.isMDXComponent=!0;const AOt={toc:[]},vOt="wrapper";function LOt(e){let{components:n,...t}=e;return(0,s.yg)(vOt,(0,p.A)({},AOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LOt.isMDXComponent=!0;const bOt={toc:[]},NOt="wrapper";function kOt(e){let{components:n,...t}=e;return(0,s.yg)(NOt,(0,p.A)({},bOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kOt.isMDXComponent=!0;const zOt={toc:[]},POt="wrapper";function IOt(e){let{components:n,...t}=e;return(0,s.yg)(POt,(0,p.A)({},zOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}IOt.isMDXComponent=!0;const ROt={toc:[]},WOt="wrapper";function SOt(e){let{components:n,...t}=e;return(0,s.yg)(WOt,(0,p.A)({},ROt,t,{components:n,mdxType:"MDXLayout"}))}SOt.isMDXComponent=!0;const BOt={toc:[]},GOt="wrapper";function EOt(e){let{components:n,...t}=e;return(0,s.yg)(GOt,(0,p.A)({},BOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"For example, a value of 6 creates a hexagon."))}EOt.isMDXComponent=!0;const OOt={toc:[]},UOt="wrapper";function FOt(e){let{components:n,...t}=e;return(0,s.yg)(UOt,(0,p.A)({},OOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}FOt.isMDXComponent=!0;const VOt={toc:[]},qOt="wrapper";function jOt(e){let{components:n,...t}=e;return(0,s.yg)(qOt,(0,p.A)({},VOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of sides of the polygon."))}jOt.isMDXComponent=!0;const HOt={toc:[]},YOt="wrapper";function QOt(e){let{components:n,...t}=e;return(0,s.yg)(YOt,(0,p.A)({},HOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}QOt.isMDXComponent=!0;const $Ot={toc:[]},KOt="wrapper";function JOt(e){let{components:n,...t}=e;return(0,s.yg)(KOt,(0,p.A)({},$Ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}JOt.isMDXComponent=!0;const ZOt={toc:[]},eUt="wrapper";function nUt(e){let{components:n,...t}=e;return(0,s.yg)(eUt,(0,p.A)({},ZOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}nUt.isMDXComponent=!0;const tUt={toc:[]},oUt="wrapper";function pUt(e){let{components:n,...t}=e;return(0,s.yg)(oUt,(0,p.A)({},tUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}pUt.isMDXComponent=!0;const rUt={toc:[]},sUt="wrapper";function cUt(e){let{components:n,...t}=e;return(0,s.yg)(sUt,(0,p.A)({},rUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}cUt.isMDXComponent=!0;const aUt={toc:[]},iUt="wrapper";function lUt(e){let{components:n,...t}=e;return(0,s.yg)(iUt,(0,p.A)({},aUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}lUt.isMDXComponent=!0;const uUt={toc:[]},mUt="wrapper";function yUt(e){let{components:n,...t}=e;return(0,s.yg)(mUt,(0,p.A)({},uUt,t,{components:n,mdxType:"MDXLayout"}))}yUt.isMDXComponent=!0;const dUt={toc:[]},hUt="wrapper";function gUt(e){let{components:n,...t}=e;return(0,s.yg)(hUt,(0,p.A)({},dUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}gUt.isMDXComponent=!0;const fUt={toc:[]},DUt="wrapper";function MUt(e){let{components:n,...t}=e;return(0,s.yg)(DUt,(0,p.A)({},fUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}MUt.isMDXComponent=!0;const XUt={toc:[]},_Ut="wrapper";function wUt(e){let{components:n,...t}=e;return(0,s.yg)(_Ut,(0,p.A)({},XUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wUt.isMDXComponent=!0;const TUt={toc:[]},CUt="wrapper";function xUt(e){let{components:n,...t}=e;return(0,s.yg)(CUt,(0,p.A)({},TUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}xUt.isMDXComponent=!0;const AUt={toc:[]},vUt="wrapper";function LUt(e){let{components:n,...t}=e;return(0,s.yg)(vUt,(0,p.A)({},AUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}LUt.isMDXComponent=!0;const bUt={toc:[]},NUt="wrapper";function kUt(e){let{components:n,...t}=e;return(0,s.yg)(NUt,(0,p.A)({},bUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}kUt.isMDXComponent=!0;const zUt={toc:[]},PUt="wrapper";function IUt(e){let{components:n,...t}=e;return(0,s.yg)(PUt,(0,p.A)({},zUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}IUt.isMDXComponent=!0;const RUt={toc:[]},WUt="wrapper";function SUt(e){let{components:n,...t}=e;return(0,s.yg)(WUt,(0,p.A)({},RUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}SUt.isMDXComponent=!0;const BUt={toc:[]},GUt="wrapper";function EUt(e){let{components:n,...t}=e;return(0,s.yg)(GUt,(0,p.A)({},BUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}EUt.isMDXComponent=!0;const OUt={toc:[]},UUt="wrapper";function FUt(e){let{components:n,...t}=e;return(0,s.yg)(UUt,(0,p.A)({},OUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}FUt.isMDXComponent=!0;const VUt={toc:[]},qUt="wrapper";function jUt(e){let{components:n,...t}=e;return(0,s.yg)(qUt,(0,p.A)({},VUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}jUt.isMDXComponent=!0;const HUt={toc:[]},YUt="wrapper";function QUt(e){let{components:n,...t}=e;return(0,s.yg)(YUt,(0,p.A)({},HUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}QUt.isMDXComponent=!0;const $Ut={toc:[]},KUt="wrapper";function JUt(e){let{components:n,...t}=e;return(0,s.yg)(KUt,(0,p.A)({},$Ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}JUt.isMDXComponent=!0;const ZUt={toc:[]},eFt="wrapper";function nFt(e){let{components:n,...t}=e;return(0,s.yg)(eFt,(0,p.A)({},ZUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nFt.isMDXComponent=!0;const tFt={toc:[]},oFt="wrapper";function pFt(e){let{components:n,...t}=e;return(0,s.yg)(oFt,(0,p.A)({},tFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}pFt.isMDXComponent=!0;const rFt={toc:[]},sFt="wrapper";function cFt(e){let{components:n,...t}=e;return(0,s.yg)(sFt,(0,p.A)({},rFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}cFt.isMDXComponent=!0;const aFt={toc:[]},iFt="wrapper";function lFt(e){let{components:n,...t}=e;return(0,s.yg)(iFt,(0,p.A)({},aFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}lFt.isMDXComponent=!0;const uFt={toc:[]},mFt="wrapper";function yFt(e){let{components:n,...t}=e;return(0,s.yg)(mFt,(0,p.A)({},uFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}yFt.isMDXComponent=!0;const dFt={toc:[]},hFt="wrapper";function gFt(e){let{components:n,...t}=e;return(0,s.yg)(hFt,(0,p.A)({},dFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}gFt.isMDXComponent=!0;const fFt={toc:[]},DFt="wrapper";function MFt(e){let{components:n,...t}=e;return(0,s.yg)(DFt,(0,p.A)({},fFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}MFt.isMDXComponent=!0;const XFt={toc:[]},_Ft="wrapper";function wFt(e){let{components:n,...t}=e;return(0,s.yg)(_Ft,(0,p.A)({},XFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}wFt.isMDXComponent=!0;const TFt={toc:[]},CFt="wrapper";function xFt(e){let{components:n,...t}=e;return(0,s.yg)(CFt,(0,p.A)({},TFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xFt.isMDXComponent=!0;const AFt={toc:[]},vFt="wrapper";function LFt(e){let{components:n,...t}=e;return(0,s.yg)(vFt,(0,p.A)({},AFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}LFt.isMDXComponent=!0;const bFt={toc:[]},NFt="wrapper";function kFt(e){let{components:n,...t}=e;return(0,s.yg)(NFt,(0,p.A)({},bFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}kFt.isMDXComponent=!0;const zFt={toc:[]},PFt="wrapper";function IFt(e){let{components:n,...t}=e;return(0,s.yg)(PFt,(0,p.A)({},zFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}IFt.isMDXComponent=!0;const RFt={toc:[]},WFt="wrapper";function SFt(e){let{components:n,...t}=e;return(0,s.yg)(WFt,(0,p.A)({},RFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}SFt.isMDXComponent=!0;const BFt={toc:[]},GFt="wrapper";function EFt(e){let{components:n,...t}=e;return(0,s.yg)(GFt,(0,p.A)({},BFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}EFt.isMDXComponent=!0;const OFt={toc:[]},UFt="wrapper";function FFt(e){let{components:n,...t}=e;return(0,s.yg)(UFt,(0,p.A)({},OFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}FFt.isMDXComponent=!0;const VFt={toc:[]},qFt="wrapper";function jFt(e){let{components:n,...t}=e;return(0,s.yg)(qFt,(0,p.A)({},VFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}jFt.isMDXComponent=!0;const HFt={toc:[]},YFt="wrapper";function QFt(e){let{components:n,...t}=e;return(0,s.yg)(YFt,(0,p.A)({},HFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}QFt.isMDXComponent=!0;const $Ft={toc:[]},KFt="wrapper";function JFt(e){let{components:n,...t}=e;return(0,s.yg)(KFt,(0,p.A)({},$Ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}JFt.isMDXComponent=!0;const ZFt={toc:[]},eVt="wrapper";function nVt(e){let{components:n,...t}=e;return(0,s.yg)(eVt,(0,p.A)({},ZFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}nVt.isMDXComponent=!0;const tVt={toc:[]},oVt="wrapper";function pVt(e){let{components:n,...t}=e;return(0,s.yg)(oVt,(0,p.A)({},tVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}pVt.isMDXComponent=!0;const rVt={toc:[]},sVt="wrapper";function cVt(e){let{components:n,...t}=e;return(0,s.yg)(sVt,(0,p.A)({},rVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}cVt.isMDXComponent=!0;const aVt={toc:[]},iVt="wrapper";function lVt(e){let{components:n,...t}=e;return(0,s.yg)(iVt,(0,p.A)({},aVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lVt.isMDXComponent=!0;const uVt={toc:[]},mVt="wrapper";function yVt(e){let{components:n,...t}=e;return(0,s.yg)(mVt,(0,p.A)({},uVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}yVt.isMDXComponent=!0;const dVt={toc:[]},hVt="wrapper";function gVt(e){let{components:n,...t}=e;return(0,s.yg)(hVt,(0,p.A)({},dVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}gVt.isMDXComponent=!0;const fVt={toc:[]},DVt="wrapper";function MVt(e){let{components:n,...t}=e;return(0,s.yg)(DVt,(0,p.A)({},fVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}MVt.isMDXComponent=!0;const XVt={toc:[]},_Vt="wrapper";function wVt(e){let{components:n,...t}=e;return(0,s.yg)(_Vt,(0,p.A)({},XVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wVt.isMDXComponent=!0;const TVt={toc:[]},CVt="wrapper";function xVt(e){let{components:n,...t}=e;return(0,s.yg)(CVt,(0,p.A)({},TVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}xVt.isMDXComponent=!0;const AVt={toc:[]},vVt="wrapper";function LVt(e){let{components:n,...t}=e;return(0,s.yg)(vVt,(0,p.A)({},AVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}LVt.isMDXComponent=!0;const bVt={toc:[]},NVt="wrapper";function kVt(e){let{components:n,...t}=e;return(0,s.yg)(NVt,(0,p.A)({},bVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}kVt.isMDXComponent=!0;const zVt={toc:[]},PVt="wrapper";function IVt(e){let{components:n,...t}=e;return(0,s.yg)(PVt,(0,p.A)({},zVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}IVt.isMDXComponent=!0;const RVt={toc:[]},WVt="wrapper";function SVt(e){let{components:n,...t}=e;return(0,s.yg)(WVt,(0,p.A)({},RVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}SVt.isMDXComponent=!0;const BVt={toc:[]},GVt="wrapper";function EVt(e){let{components:n,...t}=e;return(0,s.yg)(GVt,(0,p.A)({},BVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}EVt.isMDXComponent=!0;const OVt={toc:[]},UVt="wrapper";function FVt(e){let{components:n,...t}=e;return(0,s.yg)(UVt,(0,p.A)({},OVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}FVt.isMDXComponent=!0;const VVt={toc:[]},qVt="wrapper";function jVt(e){let{components:n,...t}=e;return(0,s.yg)(qVt,(0,p.A)({},VVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}jVt.isMDXComponent=!0;const HVt={toc:[]},YVt="wrapper";function QVt(e){let{components:n,...t}=e;return(0,s.yg)(YVt,(0,p.A)({},HVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}QVt.isMDXComponent=!0;const $Vt={toc:[]},KVt="wrapper";function JVt(e){let{components:n,...t}=e;return(0,s.yg)(KVt,(0,p.A)({},$Vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}JVt.isMDXComponent=!0;const ZVt={toc:[]},eqt="wrapper";function nqt(e){let{components:n,...t}=e;return(0,s.yg)(eqt,(0,p.A)({},ZVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}nqt.isMDXComponent=!0;const tqt={toc:[]},oqt="wrapper";function pqt(e){let{components:n,...t}=e;return(0,s.yg)(oqt,(0,p.A)({},tqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}pqt.isMDXComponent=!0;const rqt={toc:[]},sqt="wrapper";function cqt(e){let{components:n,...t}=e;return(0,s.yg)(sqt,(0,p.A)({},rqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}cqt.isMDXComponent=!0;const aqt={toc:[]},iqt="wrapper";function lqt(e){let{components:n,...t}=e;return(0,s.yg)(iqt,(0,p.A)({},aqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}lqt.isMDXComponent=!0;const uqt={toc:[]},mqt="wrapper";function yqt(e){let{components:n,...t}=e;return(0,s.yg)(mqt,(0,p.A)({},uqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yqt.isMDXComponent=!0;const dqt={toc:[]},hqt="wrapper";function gqt(e){let{components:n,...t}=e;return(0,s.yg)(hqt,(0,p.A)({},dqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}gqt.isMDXComponent=!0;const fqt={toc:[]},Dqt="wrapper";function Mqt(e){let{components:n,...t}=e;return(0,s.yg)(Dqt,(0,p.A)({},fqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mqt.isMDXComponent=!0;const Xqt={toc:[]},_qt="wrapper";function wqt(e){let{components:n,...t}=e;return(0,s.yg)(_qt,(0,p.A)({},Xqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wqt.isMDXComponent=!0;const Tqt={toc:[]},Cqt="wrapper";function xqt(e){let{components:n,...t}=e;return(0,s.yg)(Cqt,(0,p.A)({},Tqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xqt.isMDXComponent=!0;const Aqt={toc:[]},vqt="wrapper";function Lqt(e){let{components:n,...t}=e;return(0,s.yg)(vqt,(0,p.A)({},Aqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Lqt.isMDXComponent=!0;const bqt={toc:[]},Nqt="wrapper";function kqt(e){let{components:n,...t}=e;return(0,s.yg)(Nqt,(0,p.A)({},bqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kqt.isMDXComponent=!0;const zqt={toc:[]},Pqt="wrapper";function Iqt(e){let{components:n,...t}=e;return(0,s.yg)(Pqt,(0,p.A)({},zqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Iqt.isMDXComponent=!0;const Rqt={toc:[]},Wqt="wrapper";function Sqt(e){let{components:n,...t}=e;return(0,s.yg)(Wqt,(0,p.A)({},Rqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Sqt.isMDXComponent=!0;const Bqt={toc:[]},Gqt="wrapper";function Eqt(e){let{components:n,...t}=e;return(0,s.yg)(Gqt,(0,p.A)({},Bqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Eqt.isMDXComponent=!0;const Oqt={toc:[]},Uqt="wrapper";function Fqt(e){let{components:n,...t}=e;return(0,s.yg)(Uqt,(0,p.A)({},Oqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fqt.isMDXComponent=!0;const Vqt={toc:[]},qqt="wrapper";function jqt(e){let{components:n,...t}=e;return(0,s.yg)(qqt,(0,p.A)({},Vqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}jqt.isMDXComponent=!0;const Hqt={toc:[]},Yqt="wrapper";function Qqt(e){let{components:n,...t}=e;return(0,s.yg)(Yqt,(0,p.A)({},Hqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qqt.isMDXComponent=!0;const $qt={toc:[]},Kqt="wrapper";function Jqt(e){let{components:n,...t}=e;return(0,s.yg)(Kqt,(0,p.A)({},$qt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Jqt.isMDXComponent=!0;const Zqt={toc:[]},ejt="wrapper";function njt(e){let{components:n,...t}=e;return(0,s.yg)(ejt,(0,p.A)({},Zqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}njt.isMDXComponent=!0;const tjt={toc:[]},ojt="wrapper";function pjt(e){let{components:n,...t}=e;return(0,s.yg)(ojt,(0,p.A)({},tjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}pjt.isMDXComponent=!0;const rjt={toc:[]},sjt="wrapper";function cjt(e){let{components:n,...t}=e;return(0,s.yg)(sjt,(0,p.A)({},rjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cjt.isMDXComponent=!0;const ajt={toc:[]},ijt="wrapper";function ljt(e){let{components:n,...t}=e;return(0,s.yg)(ijt,(0,p.A)({},ajt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}ljt.isMDXComponent=!0;const ujt={toc:[]},mjt="wrapper";function yjt(e){let{components:n,...t}=e;return(0,s.yg)(mjt,(0,p.A)({},ujt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}yjt.isMDXComponent=!0;const djt={toc:[]},hjt="wrapper";function gjt(e){let{components:n,...t}=e;return(0,s.yg)(hjt,(0,p.A)({},djt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}gjt.isMDXComponent=!0;const fjt={toc:[]},Djt="wrapper";function Mjt(e){let{components:n,...t}=e;return(0,s.yg)(Djt,(0,p.A)({},fjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Mjt.isMDXComponent=!0;const Xjt={toc:[]},_jt="wrapper";function wjt(e){let{components:n,...t}=e;return(0,s.yg)(_jt,(0,p.A)({},Xjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}wjt.isMDXComponent=!0;const Tjt={toc:[]},Cjt="wrapper";function xjt(e){let{components:n,...t}=e;return(0,s.yg)(Cjt,(0,p.A)({},Tjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}xjt.isMDXComponent=!0;const Ajt={toc:[]},vjt="wrapper";function Ljt(e){let{components:n,...t}=e;return(0,s.yg)(vjt,(0,p.A)({},Ajt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Ljt.isMDXComponent=!0;const bjt={toc:[]},Njt="wrapper";function kjt(e){let{components:n,...t}=e;return(0,s.yg)(Njt,(0,p.A)({},bjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}kjt.isMDXComponent=!0;const zjt={toc:[]},Pjt="wrapper";function Ijt(e){let{components:n,...t}=e;return(0,s.yg)(Pjt,(0,p.A)({},zjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Ijt.isMDXComponent=!0;const Rjt={toc:[]},Wjt="wrapper";function Sjt(e){let{components:n,...t}=e;return(0,s.yg)(Wjt,(0,p.A)({},Rjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Sjt.isMDXComponent=!0;const Bjt={toc:[]},Gjt="wrapper";function Ejt(e){let{components:n,...t}=e;return(0,s.yg)(Gjt,(0,p.A)({},Bjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Ejt.isMDXComponent=!0;const Ojt={toc:[]},Ujt="wrapper";function Fjt(e){let{components:n,...t}=e;return(0,s.yg)(Ujt,(0,p.A)({},Ojt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Fjt.isMDXComponent=!0;const Vjt={toc:[]},qjt="wrapper";function jjt(e){let{components:n,...t}=e;return(0,s.yg)(qjt,(0,p.A)({},Vjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}jjt.isMDXComponent=!0;const Hjt={toc:[]},Yjt="wrapper";function Qjt(e){let{components:n,...t}=e;return(0,s.yg)(Yjt,(0,p.A)({},Hjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Qjt.isMDXComponent=!0;const $jt={toc:[]},Kjt="wrapper";function Jjt(e){let{components:n,...t}=e;return(0,s.yg)(Kjt,(0,p.A)({},$jt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Jjt.isMDXComponent=!0;const Zjt={toc:[]},eHt="wrapper";function nHt(e){let{components:n,...t}=e;return(0,s.yg)(eHt,(0,p.A)({},Zjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}nHt.isMDXComponent=!0;const tHt={toc:[]},oHt="wrapper";function pHt(e){let{components:n,...t}=e;return(0,s.yg)(oHt,(0,p.A)({},tHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pHt.isMDXComponent=!0;const rHt={toc:[]},sHt="wrapper";function cHt(e){let{components:n,...t}=e;return(0,s.yg)(sHt,(0,p.A)({},rHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cHt.isMDXComponent=!0;const aHt={toc:[]},iHt="wrapper";function lHt(e){let{components:n,...t}=e;return(0,s.yg)(iHt,(0,p.A)({},aHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}lHt.isMDXComponent=!0;const uHt={toc:[]},mHt="wrapper";function yHt(e){let{components:n,...t}=e;return(0,s.yg)(mHt,(0,p.A)({},uHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}yHt.isMDXComponent=!0;const dHt={toc:[]},hHt="wrapper";function gHt(e){let{components:n,...t}=e;return(0,s.yg)(hHt,(0,p.A)({},dHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}gHt.isMDXComponent=!0;const fHt={toc:[]},DHt="wrapper";function MHt(e){let{components:n,...t}=e;return(0,s.yg)(DHt,(0,p.A)({},fHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}MHt.isMDXComponent=!0;const XHt={toc:[]},_Ht="wrapper";function wHt(e){let{components:n,...t}=e;return(0,s.yg)(_Ht,(0,p.A)({},XHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wHt.isMDXComponent=!0;const THt={toc:[]},CHt="wrapper";function xHt(e){let{components:n,...t}=e;return(0,s.yg)(CHt,(0,p.A)({},THt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}xHt.isMDXComponent=!0;const AHt={toc:[]},vHt="wrapper";function LHt(e){let{components:n,...t}=e;return(0,s.yg)(vHt,(0,p.A)({},AHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}LHt.isMDXComponent=!0;const bHt={toc:[]},NHt="wrapper";function kHt(e){let{components:n,...t}=e;return(0,s.yg)(NHt,(0,p.A)({},bHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}kHt.isMDXComponent=!0;const zHt={toc:[]},PHt="wrapper";function IHt(e){let{components:n,...t}=e;return(0,s.yg)(PHt,(0,p.A)({},zHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}IHt.isMDXComponent=!0;const RHt={toc:[]},WHt="wrapper";function SHt(e){let{components:n,...t}=e;return(0,s.yg)(WHt,(0,p.A)({},RHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}SHt.isMDXComponent=!0;const BHt={toc:[]},GHt="wrapper";function EHt(e){let{components:n,...t}=e;return(0,s.yg)(GHt,(0,p.A)({},BHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}EHt.isMDXComponent=!0;const OHt={toc:[]},UHt="wrapper";function FHt(e){let{components:n,...t}=e;return(0,s.yg)(UHt,(0,p.A)({},OHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}FHt.isMDXComponent=!0;const VHt={toc:[]},qHt="wrapper";function jHt(e){let{components:n,...t}=e;return(0,s.yg)(qHt,(0,p.A)({},VHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jHt.isMDXComponent=!0;const HHt={toc:[]},YHt="wrapper";function QHt(e){let{components:n,...t}=e;return(0,s.yg)(YHt,(0,p.A)({},HHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}QHt.isMDXComponent=!0;const $Ht={toc:[]},KHt="wrapper";function JHt(e){let{components:n,...t}=e;return(0,s.yg)(KHt,(0,p.A)({},$Ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}JHt.isMDXComponent=!0;const ZHt={toc:[]},eYt="wrapper";function nYt(e){let{components:n,...t}=e;return(0,s.yg)(eYt,(0,p.A)({},ZHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}nYt.isMDXComponent=!0;const tYt={toc:[]},oYt="wrapper";function pYt(e){let{components:n,...t}=e;return(0,s.yg)(oYt,(0,p.A)({},tYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pYt.isMDXComponent=!0;const rYt={toc:[]},sYt="wrapper";function cYt(e){let{components:n,...t}=e;return(0,s.yg)(sYt,(0,p.A)({},rYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}cYt.isMDXComponent=!0;const aYt={toc:[]},iYt="wrapper";function lYt(e){let{components:n,...t}=e;return(0,s.yg)(iYt,(0,p.A)({},aYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}lYt.isMDXComponent=!0;const uYt={toc:[]},mYt="wrapper";function yYt(e){let{components:n,...t}=e;return(0,s.yg)(mYt,(0,p.A)({},uYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}yYt.isMDXComponent=!0;const dYt={toc:[]},hYt="wrapper";function gYt(e){let{components:n,...t}=e;return(0,s.yg)(hYt,(0,p.A)({},dYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}gYt.isMDXComponent=!0;const fYt={toc:[]},DYt="wrapper";function MYt(e){let{components:n,...t}=e;return(0,s.yg)(DYt,(0,p.A)({},fYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}MYt.isMDXComponent=!0;const XYt={toc:[]},_Yt="wrapper";function wYt(e){let{components:n,...t}=e;return(0,s.yg)(_Yt,(0,p.A)({},XYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}wYt.isMDXComponent=!0;const TYt={toc:[]},CYt="wrapper";function xYt(e){let{components:n,...t}=e;return(0,s.yg)(CYt,(0,p.A)({},TYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}xYt.isMDXComponent=!0;const AYt={toc:[]},vYt="wrapper";function LYt(e){let{components:n,...t}=e;return(0,s.yg)(vYt,(0,p.A)({},AYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}LYt.isMDXComponent=!0;const bYt={toc:[]},NYt="wrapper";function kYt(e){let{components:n,...t}=e;return(0,s.yg)(NYt,(0,p.A)({},bYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}kYt.isMDXComponent=!0;const zYt={toc:[]},PYt="wrapper";function IYt(e){let{components:n,...t}=e;return(0,s.yg)(PYt,(0,p.A)({},zYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}IYt.isMDXComponent=!0;const RYt={toc:[]},WYt="wrapper";function SYt(e){let{components:n,...t}=e;return(0,s.yg)(WYt,(0,p.A)({},RYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}SYt.isMDXComponent=!0;const BYt={toc:[]},GYt="wrapper";function EYt(e){let{components:n,...t}=e;return(0,s.yg)(GYt,(0,p.A)({},BYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}EYt.isMDXComponent=!0;const OYt={toc:[]},UYt="wrapper";function FYt(e){let{components:n,...t}=e;return(0,s.yg)(UYt,(0,p.A)({},OYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}FYt.isMDXComponent=!0;const VYt={toc:[]},qYt="wrapper";function jYt(e){let{components:n,...t}=e;return(0,s.yg)(qYt,(0,p.A)({},VYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}jYt.isMDXComponent=!0;const HYt={toc:[]},YYt="wrapper";function QYt(e){let{components:n,...t}=e;return(0,s.yg)(YYt,(0,p.A)({},HYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}QYt.isMDXComponent=!0;const $Yt={toc:[]},KYt="wrapper";function JYt(e){let{components:n,...t}=e;return(0,s.yg)(KYt,(0,p.A)({},$Yt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}JYt.isMDXComponent=!0;const ZYt={toc:[]},eQt="wrapper";function nQt(e){let{components:n,...t}=e;return(0,s.yg)(eQt,(0,p.A)({},ZYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}nQt.isMDXComponent=!0;const tQt={toc:[]},oQt="wrapper";function pQt(e){let{components:n,...t}=e;return(0,s.yg)(oQt,(0,p.A)({},tQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}pQt.isMDXComponent=!0;const rQt={toc:[]},sQt="wrapper";function cQt(e){let{components:n,...t}=e;return(0,s.yg)(sQt,(0,p.A)({},rQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cQt.isMDXComponent=!0;const aQt={toc:[]},iQt="wrapper";function lQt(e){let{components:n,...t}=e;return(0,s.yg)(iQt,(0,p.A)({},aQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}lQt.isMDXComponent=!0;const uQt={toc:[]},mQt="wrapper";function yQt(e){let{components:n,...t}=e;return(0,s.yg)(mQt,(0,p.A)({},uQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}yQt.isMDXComponent=!0;const dQt={toc:[]},hQt="wrapper";function gQt(e){let{components:n,...t}=e;return(0,s.yg)(hQt,(0,p.A)({},dQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}gQt.isMDXComponent=!0;const fQt={toc:[]},DQt="wrapper";function MQt(e){let{components:n,...t}=e;return(0,s.yg)(DQt,(0,p.A)({},fQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}MQt.isMDXComponent=!0;const XQt={toc:[]},_Qt="wrapper";function wQt(e){let{components:n,...t}=e;return(0,s.yg)(_Qt,(0,p.A)({},XQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}wQt.isMDXComponent=!0;const TQt={toc:[]},CQt="wrapper";function xQt(e){let{components:n,...t}=e;return(0,s.yg)(CQt,(0,p.A)({},TQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}xQt.isMDXComponent=!0;const AQt={toc:[]},vQt="wrapper";function LQt(e){let{components:n,...t}=e;return(0,s.yg)(vQt,(0,p.A)({},AQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}LQt.isMDXComponent=!0;const bQt={toc:[]},NQt="wrapper";function kQt(e){let{components:n,...t}=e;return(0,s.yg)(NQt,(0,p.A)({},bQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}kQt.isMDXComponent=!0;const zQt={toc:[]},PQt="wrapper";function IQt(e){let{components:n,...t}=e;return(0,s.yg)(PQt,(0,p.A)({},zQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}IQt.isMDXComponent=!0;const RQt={toc:[]},WQt="wrapper";function SQt(e){let{components:n,...t}=e;return(0,s.yg)(WQt,(0,p.A)({},RQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}SQt.isMDXComponent=!0;const BQt={toc:[]},GQt="wrapper";function EQt(e){let{components:n,...t}=e;return(0,s.yg)(GQt,(0,p.A)({},BQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}EQt.isMDXComponent=!0;const OQt={toc:[]},UQt="wrapper";function FQt(e){let{components:n,...t}=e;return(0,s.yg)(UQt,(0,p.A)({},OQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}FQt.isMDXComponent=!0;const VQt={toc:[]},qQt="wrapper";function jQt(e){let{components:n,...t}=e;return(0,s.yg)(qQt,(0,p.A)({},VQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}jQt.isMDXComponent=!0;const HQt={toc:[]},YQt="wrapper";function QQt(e){let{components:n,...t}=e;return(0,s.yg)(YQt,(0,p.A)({},HQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}QQt.isMDXComponent=!0;const $Qt={toc:[]},KQt="wrapper";function JQt(e){let{components:n,...t}=e;return(0,s.yg)(KQt,(0,p.A)({},$Qt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}JQt.isMDXComponent=!0;const ZQt={toc:[]},e$t="wrapper";function n$t(e){let{components:n,...t}=e;return(0,s.yg)(e$t,(0,p.A)({},ZQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}n$t.isMDXComponent=!0;const t$t={toc:[]},o$t="wrapper";function p$t(e){let{components:n,...t}=e;return(0,s.yg)(o$t,(0,p.A)({},t$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}p$t.isMDXComponent=!0;const r$t={toc:[]},s$t="wrapper";function c$t(e){let{components:n,...t}=e;return(0,s.yg)(s$t,(0,p.A)({},r$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}c$t.isMDXComponent=!0;const a$t={toc:[]},i$t="wrapper";function l$t(e){let{components:n,...t}=e;return(0,s.yg)(i$t,(0,p.A)({},a$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}l$t.isMDXComponent=!0;const u$t={toc:[]},m$t="wrapper";function y$t(e){let{components:n,...t}=e;return(0,s.yg)(m$t,(0,p.A)({},u$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}y$t.isMDXComponent=!0;const d$t={toc:[]},h$t="wrapper";function g$t(e){let{components:n,...t}=e;return(0,s.yg)(h$t,(0,p.A)({},d$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}g$t.isMDXComponent=!0;const f$t={toc:[]},D$t="wrapper";function M$t(e){let{components:n,...t}=e;return(0,s.yg)(D$t,(0,p.A)({},f$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}M$t.isMDXComponent=!0;const X$t={toc:[]},_$t="wrapper";function w$t(e){let{components:n,...t}=e;return(0,s.yg)(_$t,(0,p.A)({},X$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}w$t.isMDXComponent=!0;const T$t={toc:[]},C$t="wrapper";function x$t(e){let{components:n,...t}=e;return(0,s.yg)(C$t,(0,p.A)({},T$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}x$t.isMDXComponent=!0;const A$t={toc:[]},v$t="wrapper";function L$t(e){let{components:n,...t}=e;return(0,s.yg)(v$t,(0,p.A)({},A$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}L$t.isMDXComponent=!0;const b$t={toc:[]},N$t="wrapper";function k$t(e){let{components:n,...t}=e;return(0,s.yg)(N$t,(0,p.A)({},b$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}k$t.isMDXComponent=!0;const z$t={toc:[]},P$t="wrapper";function I$t(e){let{components:n,...t}=e;return(0,s.yg)(P$t,(0,p.A)({},z$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}I$t.isMDXComponent=!0;const R$t={toc:[]},W$t="wrapper";function S$t(e){let{components:n,...t}=e;return(0,s.yg)(W$t,(0,p.A)({},R$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}S$t.isMDXComponent=!0;const B$t={toc:[]},G$t="wrapper";function E$t(e){let{components:n,...t}=e;return(0,s.yg)(G$t,(0,p.A)({},B$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}E$t.isMDXComponent=!0;const O$t={toc:[]},U$t="wrapper";function F$t(e){let{components:n,...t}=e;return(0,s.yg)(U$t,(0,p.A)({},O$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}F$t.isMDXComponent=!0;const V$t={toc:[]},q$t="wrapper";function j$t(e){let{components:n,...t}=e;return(0,s.yg)(q$t,(0,p.A)({},V$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}j$t.isMDXComponent=!0;const H$t={toc:[]},Y$t="wrapper";function Q$t(e){let{components:n,...t}=e;return(0,s.yg)(Y$t,(0,p.A)({},H$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Q$t.isMDXComponent=!0;const $$t={toc:[]},K$t="wrapper";function J$t(e){let{components:n,...t}=e;return(0,s.yg)(K$t,(0,p.A)({},$$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}J$t.isMDXComponent=!0;const Z$t={toc:[]},eKt="wrapper";function nKt(e){let{components:n,...t}=e;return(0,s.yg)(eKt,(0,p.A)({},Z$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}nKt.isMDXComponent=!0;const tKt={toc:[]},oKt="wrapper";function pKt(e){let{components:n,...t}=e;return(0,s.yg)(oKt,(0,p.A)({},tKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}pKt.isMDXComponent=!0;const rKt={toc:[]},sKt="wrapper";function cKt(e){let{components:n,...t}=e;return(0,s.yg)(sKt,(0,p.A)({},rKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cKt.isMDXComponent=!0;const aKt={toc:[]},iKt="wrapper";function lKt(e){let{components:n,...t}=e;return(0,s.yg)(iKt,(0,p.A)({},aKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}lKt.isMDXComponent=!0;const uKt={toc:[]},mKt="wrapper";function yKt(e){let{components:n,...t}=e;return(0,s.yg)(mKt,(0,p.A)({},uKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}yKt.isMDXComponent=!0;const dKt={toc:[]},hKt="wrapper";function gKt(e){let{components:n,...t}=e;return(0,s.yg)(hKt,(0,p.A)({},dKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gKt.isMDXComponent=!0;const fKt={toc:[]},DKt="wrapper";function MKt(e){let{components:n,...t}=e;return(0,s.yg)(DKt,(0,p.A)({},fKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}MKt.isMDXComponent=!0;const XKt={toc:[]},_Kt="wrapper";function wKt(e){let{components:n,...t}=e;return(0,s.yg)(_Kt,(0,p.A)({},XKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wKt.isMDXComponent=!0;const TKt={toc:[]},CKt="wrapper";function xKt(e){let{components:n,...t}=e;return(0,s.yg)(CKt,(0,p.A)({},TKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}xKt.isMDXComponent=!0;const AKt={toc:[]},vKt="wrapper";function LKt(e){let{components:n,...t}=e;return(0,s.yg)(vKt,(0,p.A)({},AKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LKt.isMDXComponent=!0;const bKt={toc:[]},NKt="wrapper";function kKt(e){let{components:n,...t}=e;return(0,s.yg)(NKt,(0,p.A)({},bKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}kKt.isMDXComponent=!0;const zKt={toc:[]},PKt="wrapper";function IKt(e){let{components:n,...t}=e;return(0,s.yg)(PKt,(0,p.A)({},zKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}IKt.isMDXComponent=!0;const RKt={toc:[]},WKt="wrapper";function SKt(e){let{components:n,...t}=e;return(0,s.yg)(WKt,(0,p.A)({},RKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}SKt.isMDXComponent=!0;const BKt={toc:[]},GKt="wrapper";function EKt(e){let{components:n,...t}=e;return(0,s.yg)(GKt,(0,p.A)({},BKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}EKt.isMDXComponent=!0;const OKt={toc:[]},UKt="wrapper";function FKt(e){let{components:n,...t}=e;return(0,s.yg)(UKt,(0,p.A)({},OKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}FKt.isMDXComponent=!0;const VKt={toc:[]},qKt="wrapper";function jKt(e){let{components:n,...t}=e;return(0,s.yg)(qKt,(0,p.A)({},VKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}jKt.isMDXComponent=!0;const HKt={toc:[]},YKt="wrapper";function QKt(e){let{components:n,...t}=e;return(0,s.yg)(YKt,(0,p.A)({},HKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}QKt.isMDXComponent=!0;const $Kt={toc:[]},KKt="wrapper";function JKt(e){let{components:n,...t}=e;return(0,s.yg)(KKt,(0,p.A)({},$Kt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}JKt.isMDXComponent=!0;const ZKt={toc:[]},eJt="wrapper";function nJt(e){let{components:n,...t}=e;return(0,s.yg)(eJt,(0,p.A)({},ZKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}nJt.isMDXComponent=!0;const tJt={toc:[]},oJt="wrapper";function pJt(e){let{components:n,...t}=e;return(0,s.yg)(oJt,(0,p.A)({},tJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}pJt.isMDXComponent=!0;const rJt={toc:[]},sJt="wrapper";function cJt(e){let{components:n,...t}=e;return(0,s.yg)(sJt,(0,p.A)({},rJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}cJt.isMDXComponent=!0;const aJt={toc:[]},iJt="wrapper";function lJt(e){let{components:n,...t}=e;return(0,s.yg)(iJt,(0,p.A)({},aJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lJt.isMDXComponent=!0;const uJt={toc:[]},mJt="wrapper";function yJt(e){let{components:n,...t}=e;return(0,s.yg)(mJt,(0,p.A)({},uJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}yJt.isMDXComponent=!0;const dJt={toc:[]},hJt="wrapper";function gJt(e){let{components:n,...t}=e;return(0,s.yg)(hJt,(0,p.A)({},dJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}gJt.isMDXComponent=!0;const fJt={toc:[]},DJt="wrapper";function MJt(e){let{components:n,...t}=e;return(0,s.yg)(DJt,(0,p.A)({},fJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}MJt.isMDXComponent=!0;const XJt={toc:[]},_Jt="wrapper";function wJt(e){let{components:n,...t}=e;return(0,s.yg)(_Jt,(0,p.A)({},XJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}wJt.isMDXComponent=!0;const TJt={toc:[]},CJt="wrapper";function xJt(e){let{components:n,...t}=e;return(0,s.yg)(CJt,(0,p.A)({},TJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}xJt.isMDXComponent=!0;const AJt={toc:[]},vJt="wrapper";function LJt(e){let{components:n,...t}=e;return(0,s.yg)(vJt,(0,p.A)({},AJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}LJt.isMDXComponent=!0;const bJt={toc:[]},NJt="wrapper";function kJt(e){let{components:n,...t}=e;return(0,s.yg)(NJt,(0,p.A)({},bJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kJt.isMDXComponent=!0;const zJt={toc:[]},PJt="wrapper";function IJt(e){let{components:n,...t}=e;return(0,s.yg)(PJt,(0,p.A)({},zJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}IJt.isMDXComponent=!0;const RJt={toc:[]},WJt="wrapper";function SJt(e){let{components:n,...t}=e;return(0,s.yg)(WJt,(0,p.A)({},RJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}SJt.isMDXComponent=!0;const BJt={toc:[]},GJt="wrapper";function EJt(e){let{components:n,...t}=e;return(0,s.yg)(GJt,(0,p.A)({},BJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}EJt.isMDXComponent=!0;const OJt={toc:[]},UJt="wrapper";function FJt(e){let{components:n,...t}=e;return(0,s.yg)(UJt,(0,p.A)({},OJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}FJt.isMDXComponent=!0;const VJt={toc:[]},qJt="wrapper";function jJt(e){let{components:n,...t}=e;return(0,s.yg)(qJt,(0,p.A)({},VJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}jJt.isMDXComponent=!0;const HJt={toc:[]},YJt="wrapper";function QJt(e){let{components:n,...t}=e;return(0,s.yg)(YJt,(0,p.A)({},HJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}QJt.isMDXComponent=!0;const $Jt={toc:[]},KJt="wrapper";function JJt(e){let{components:n,...t}=e;return(0,s.yg)(KJt,(0,p.A)({},$Jt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}JJt.isMDXComponent=!0;const ZJt={toc:[]},eZt="wrapper";function nZt(e){let{components:n,...t}=e;return(0,s.yg)(eZt,(0,p.A)({},ZJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}nZt.isMDXComponent=!0;const tZt={toc:[]},oZt="wrapper";function pZt(e){let{components:n,...t}=e;return(0,s.yg)(oZt,(0,p.A)({},tZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pZt.isMDXComponent=!0;const rZt={toc:[]},sZt="wrapper";function cZt(e){let{components:n,...t}=e;return(0,s.yg)(sZt,(0,p.A)({},rZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}cZt.isMDXComponent=!0;const aZt={toc:[]},iZt="wrapper";function lZt(e){let{components:n,...t}=e;return(0,s.yg)(iZt,(0,p.A)({},aZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}lZt.isMDXComponent=!0;const uZt={toc:[]},mZt="wrapper";function yZt(e){let{components:n,...t}=e;return(0,s.yg)(mZt,(0,p.A)({},uZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}yZt.isMDXComponent=!0;const dZt={toc:[]},hZt="wrapper";function gZt(e){let{components:n,...t}=e;return(0,s.yg)(hZt,(0,p.A)({},dZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gZt.isMDXComponent=!0;const fZt={toc:[]},DZt="wrapper";function MZt(e){let{components:n,...t}=e;return(0,s.yg)(DZt,(0,p.A)({},fZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}MZt.isMDXComponent=!0;const XZt={toc:[]},_Zt="wrapper";function wZt(e){let{components:n,...t}=e;return(0,s.yg)(_Zt,(0,p.A)({},XZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}wZt.isMDXComponent=!0;const TZt={toc:[]},CZt="wrapper";function xZt(e){let{components:n,...t}=e;return(0,s.yg)(CZt,(0,p.A)({},TZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}xZt.isMDXComponent=!0;const AZt={toc:[]},vZt="wrapper";function LZt(e){let{components:n,...t}=e;return(0,s.yg)(vZt,(0,p.A)({},AZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start point of the B\xe9zier curve."))}LZt.isMDXComponent=!0;const bZt={toc:[]},NZt="wrapper";function kZt(e){let{components:n,...t}=e;return(0,s.yg)(NZt,(0,p.A)({},bZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The control point of the B\xe9zier curve."))}kZt.isMDXComponent=!0;const zZt={toc:[]},PZt="wrapper";function IZt(e){let{components:n,...t}=e;return(0,s.yg)(PZt,(0,p.A)({},zZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end point of the B\xe9zier curve."))}IZt.isMDXComponent=!0;const RZt={toc:[]},WZt="wrapper";function SZt(e){let{components:n,...t}=e;return(0,s.yg)(WZt,(0,p.A)({},RZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}SZt.isMDXComponent=!0;const BZt={toc:[]},GZt="wrapper";function EZt(e){let{components:n,...t}=e;return(0,s.yg)(GZt,(0,p.A)({},BZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}EZt.isMDXComponent=!0;const OZt={toc:[]},UZt="wrapper";function FZt(e){let{components:n,...t}=e;return(0,s.yg)(UZt,(0,p.A)({},OZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}FZt.isMDXComponent=!0;const VZt={toc:[]},qZt="wrapper";function jZt(e){let{components:n,...t}=e;return(0,s.yg)(qZt,(0,p.A)({},VZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}jZt.isMDXComponent=!0;const HZt={toc:[]},YZt="wrapper";function QZt(e){let{components:n,...t}=e;return(0,s.yg)(YZt,(0,p.A)({},HZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}QZt.isMDXComponent=!0;const $Zt={toc:[]},KZt="wrapper";function JZt(e){let{components:n,...t}=e;return(0,s.yg)(KZt,(0,p.A)({},$Zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}JZt.isMDXComponent=!0;const ZZt={toc:[]},e0t="wrapper";function n0t(e){let{components:n,...t}=e;return(0,s.yg)(e0t,(0,p.A)({},ZZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}n0t.isMDXComponent=!0;const t0t={toc:[]},o0t="wrapper";function p0t(e){let{components:n,...t}=e;return(0,s.yg)(o0t,(0,p.A)({},t0t,t,{components:n,mdxType:"MDXLayout"}))}p0t.isMDXComponent=!0;const r0t={toc:[]},s0t="wrapper";function c0t(e){let{components:n,...t}=e;return(0,s.yg)(s0t,(0,p.A)({},r0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}c0t.isMDXComponent=!0;const a0t={toc:[]},i0t="wrapper";function l0t(e){let{components:n,...t}=e;return(0,s.yg)(i0t,(0,p.A)({},a0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}l0t.isMDXComponent=!0;const u0t={toc:[]},m0t="wrapper";function y0t(e){let{components:n,...t}=e;return(0,s.yg)(m0t,(0,p.A)({},u0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}y0t.isMDXComponent=!0;const d0t={toc:[]},h0t="wrapper";function g0t(e){let{components:n,...t}=e;return(0,s.yg)(h0t,(0,p.A)({},d0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}g0t.isMDXComponent=!0;const f0t={toc:[]},D0t="wrapper";function M0t(e){let{components:n,...t}=e;return(0,s.yg)(D0t,(0,p.A)({},f0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}M0t.isMDXComponent=!0;const X0t={toc:[]},_0t="wrapper";function w0t(e){let{components:n,...t}=e;return(0,s.yg)(_0t,(0,p.A)({},X0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}w0t.isMDXComponent=!0;const T0t={toc:[]},C0t="wrapper";function x0t(e){let{components:n,...t}=e;return(0,s.yg)(C0t,(0,p.A)({},T0t,t,{components:n,mdxType:"MDXLayout"}))}x0t.isMDXComponent=!0;const A0t={toc:[]},v0t="wrapper";function L0t(e){let{components:n,...t}=e;return(0,s.yg)(v0t,(0,p.A)({},A0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}L0t.isMDXComponent=!0;const b0t={toc:[]},N0t="wrapper";function k0t(e){let{components:n,...t}=e;return(0,s.yg)(N0t,(0,p.A)({},b0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}k0t.isMDXComponent=!0;const z0t={toc:[]},P0t="wrapper";function I0t(e){let{components:n,...t}=e;return(0,s.yg)(P0t,(0,p.A)({},z0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}I0t.isMDXComponent=!0;const R0t={toc:[]},W0t="wrapper";function S0t(e){let{components:n,...t}=e;return(0,s.yg)(W0t,(0,p.A)({},R0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}S0t.isMDXComponent=!0;const B0t={toc:[]},G0t="wrapper";function E0t(e){let{components:n,...t}=e;return(0,s.yg)(G0t,(0,p.A)({},B0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}E0t.isMDXComponent=!0;const O0t={toc:[]},U0t="wrapper";function F0t(e){let{components:n,...t}=e;return(0,s.yg)(U0t,(0,p.A)({},O0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}F0t.isMDXComponent=!0;const V0t={toc:[]},q0t="wrapper";function j0t(e){let{components:n,...t}=e;return(0,s.yg)(q0t,(0,p.A)({},V0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}j0t.isMDXComponent=!0;const H0t={toc:[]},Y0t="wrapper";function Q0t(e){let{components:n,...t}=e;return(0,s.yg)(Y0t,(0,p.A)({},H0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Q0t.isMDXComponent=!0;const $0t={toc:[]},K0t="wrapper";function J0t(e){let{components:n,...t}=e;return(0,s.yg)(K0t,(0,p.A)({},$0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}J0t.isMDXComponent=!0;const Z0t={toc:[]},e2t="wrapper";function n2t(e){let{components:n,...t}=e;return(0,s.yg)(e2t,(0,p.A)({},Z0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}n2t.isMDXComponent=!0;const t2t={toc:[]},o2t="wrapper";function p2t(e){let{components:n,...t}=e;return(0,s.yg)(o2t,(0,p.A)({},t2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}p2t.isMDXComponent=!0;const r2t={toc:[]},s2t="wrapper";function c2t(e){let{components:n,...t}=e;return(0,s.yg)(s2t,(0,p.A)({},r2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}c2t.isMDXComponent=!0;const a2t={toc:[]},i2t="wrapper";function l2t(e){let{components:n,...t}=e;return(0,s.yg)(i2t,(0,p.A)({},a2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}l2t.isMDXComponent=!0;const u2t={toc:[]},m2t="wrapper";function y2t(e){let{components:n,...t}=e;return(0,s.yg)(m2t,(0,p.A)({},u2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}y2t.isMDXComponent=!0;const d2t={toc:[]},h2t="wrapper";function g2t(e){let{components:n,...t}=e;return(0,s.yg)(h2t,(0,p.A)({},d2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}g2t.isMDXComponent=!0;const f2t={toc:[]},D2t="wrapper";function M2t(e){let{components:n,...t}=e;return(0,s.yg)(D2t,(0,p.A)({},f2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}M2t.isMDXComponent=!0;const X2t={toc:[]},_2t="wrapper";function w2t(e){let{components:n,...t}=e;return(0,s.yg)(_2t,(0,p.A)({},X2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}w2t.isMDXComponent=!0;const T2t={toc:[]},C2t="wrapper";function x2t(e){let{components:n,...t}=e;return(0,s.yg)(C2t,(0,p.A)({},T2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}x2t.isMDXComponent=!0;const A2t={toc:[]},v2t="wrapper";function L2t(e){let{components:n,...t}=e;return(0,s.yg)(v2t,(0,p.A)({},A2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}L2t.isMDXComponent=!0;const b2t={toc:[]},N2t="wrapper";function k2t(e){let{components:n,...t}=e;return(0,s.yg)(N2t,(0,p.A)({},b2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}k2t.isMDXComponent=!0;const z2t={toc:[]},P2t="wrapper";function I2t(e){let{components:n,...t}=e;return(0,s.yg)(P2t,(0,p.A)({},z2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}I2t.isMDXComponent=!0;const R2t={toc:[]},W2t="wrapper";function S2t(e){let{components:n,...t}=e;return(0,s.yg)(W2t,(0,p.A)({},R2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}S2t.isMDXComponent=!0;const B2t={toc:[]},G2t="wrapper";function E2t(e){let{components:n,...t}=e;return(0,s.yg)(G2t,(0,p.A)({},B2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}E2t.isMDXComponent=!0;const O2t={toc:[]},U2t="wrapper";function F2t(e){let{components:n,...t}=e;return(0,s.yg)(U2t,(0,p.A)({},O2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}F2t.isMDXComponent=!0;const V2t={toc:[]},q2t="wrapper";function j2t(e){let{components:n,...t}=e;return(0,s.yg)(q2t,(0,p.A)({},V2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}j2t.isMDXComponent=!0;const H2t={toc:[]},Y2t="wrapper";function Q2t(e){let{components:n,...t}=e;return(0,s.yg)(Y2t,(0,p.A)({},H2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Q2t.isMDXComponent=!0;const $2t={toc:[]},K2t="wrapper";function J2t(e){let{components:n,...t}=e;return(0,s.yg)(K2t,(0,p.A)({},$2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}J2t.isMDXComponent=!0;const Z2t={toc:[]},e4t="wrapper";function n4t(e){let{components:n,...t}=e;return(0,s.yg)(e4t,(0,p.A)({},Z2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}n4t.isMDXComponent=!0;const t4t={toc:[]},o4t="wrapper";function p4t(e){let{components:n,...t}=e;return(0,s.yg)(o4t,(0,p.A)({},t4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}p4t.isMDXComponent=!0;const r4t={toc:[]},s4t="wrapper";function c4t(e){let{components:n,...t}=e;return(0,s.yg)(s4t,(0,p.A)({},r4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}c4t.isMDXComponent=!0;const a4t={toc:[]},i4t="wrapper";function l4t(e){let{components:n,...t}=e;return(0,s.yg)(i4t,(0,p.A)({},a4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}l4t.isMDXComponent=!0;const u4t={toc:[]},m4t="wrapper";function y4t(e){let{components:n,...t}=e;return(0,s.yg)(m4t,(0,p.A)({},u4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}y4t.isMDXComponent=!0;const d4t={toc:[]},h4t="wrapper";function g4t(e){let{components:n,...t}=e;return(0,s.yg)(h4t,(0,p.A)({},d4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}g4t.isMDXComponent=!0;const f4t={toc:[]},D4t="wrapper";function M4t(e){let{components:n,...t}=e;return(0,s.yg)(D4t,(0,p.A)({},f4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}M4t.isMDXComponent=!0;const X4t={toc:[]},_4t="wrapper";function w4t(e){let{components:n,...t}=e;return(0,s.yg)(_4t,(0,p.A)({},X4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}w4t.isMDXComponent=!0;const T4t={toc:[]},C4t="wrapper";function x4t(e){let{components:n,...t}=e;return(0,s.yg)(C4t,(0,p.A)({},T4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}x4t.isMDXComponent=!0;const A4t={toc:[]},v4t="wrapper";function L4t(e){let{components:n,...t}=e;return(0,s.yg)(v4t,(0,p.A)({},A4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}L4t.isMDXComponent=!0;const b4t={toc:[]},N4t="wrapper";function k4t(e){let{components:n,...t}=e;return(0,s.yg)(N4t,(0,p.A)({},b4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}k4t.isMDXComponent=!0;const z4t={toc:[]},P4t="wrapper";function I4t(e){let{components:n,...t}=e;return(0,s.yg)(P4t,(0,p.A)({},z4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}I4t.isMDXComponent=!0;const R4t={toc:[]},W4t="wrapper";function S4t(e){let{components:n,...t}=e;return(0,s.yg)(W4t,(0,p.A)({},R4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}S4t.isMDXComponent=!0;const B4t={toc:[]},G4t="wrapper";function E4t(e){let{components:n,...t}=e;return(0,s.yg)(G4t,(0,p.A)({},B4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}E4t.isMDXComponent=!0;const O4t={toc:[]},U4t="wrapper";function F4t(e){let{components:n,...t}=e;return(0,s.yg)(U4t,(0,p.A)({},O4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}F4t.isMDXComponent=!0;const V4t={toc:[]},q4t="wrapper";function j4t(e){let{components:n,...t}=e;return(0,s.yg)(q4t,(0,p.A)({},V4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}j4t.isMDXComponent=!0;const H4t={toc:[]},Y4t="wrapper";function Q4t(e){let{components:n,...t}=e;return(0,s.yg)(Y4t,(0,p.A)({},H4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Q4t.isMDXComponent=!0;const $4t={toc:[]},K4t="wrapper";function J4t(e){let{components:n,...t}=e;return(0,s.yg)(K4t,(0,p.A)({},$4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}J4t.isMDXComponent=!0;const Z4t={toc:[]},e8t="wrapper";function n8t(e){let{components:n,...t}=e;return(0,s.yg)(e8t,(0,p.A)({},Z4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}n8t.isMDXComponent=!0;const t8t={toc:[]},o8t="wrapper";function p8t(e){let{components:n,...t}=e;return(0,s.yg)(o8t,(0,p.A)({},t8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}p8t.isMDXComponent=!0;const r8t={toc:[]},s8t="wrapper";function c8t(e){let{components:n,...t}=e;return(0,s.yg)(s8t,(0,p.A)({},r8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}c8t.isMDXComponent=!0;const a8t={toc:[]},i8t="wrapper";function l8t(e){let{components:n,...t}=e;return(0,s.yg)(i8t,(0,p.A)({},a8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}l8t.isMDXComponent=!0;const u8t={toc:[]},m8t="wrapper";function y8t(e){let{components:n,...t}=e;return(0,s.yg)(m8t,(0,p.A)({},u8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}y8t.isMDXComponent=!0;const d8t={toc:[]},h8t="wrapper";function g8t(e){let{components:n,...t}=e;return(0,s.yg)(h8t,(0,p.A)({},d8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}g8t.isMDXComponent=!0;const f8t={toc:[]},D8t="wrapper";function M8t(e){let{components:n,...t}=e;return(0,s.yg)(D8t,(0,p.A)({},f8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}M8t.isMDXComponent=!0;const X8t={toc:[]},_8t="wrapper";function w8t(e){let{components:n,...t}=e;return(0,s.yg)(_8t,(0,p.A)({},X8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}w8t.isMDXComponent=!0;const T8t={toc:[]},C8t="wrapper";function x8t(e){let{components:n,...t}=e;return(0,s.yg)(C8t,(0,p.A)({},T8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}x8t.isMDXComponent=!0;const A8t={toc:[]},v8t="wrapper";function L8t(e){let{components:n,...t}=e;return(0,s.yg)(v8t,(0,p.A)({},A8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}L8t.isMDXComponent=!0;const b8t={toc:[]},N8t="wrapper";function k8t(e){let{components:n,...t}=e;return(0,s.yg)(N8t,(0,p.A)({},b8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}k8t.isMDXComponent=!0;const z8t={toc:[]},P8t="wrapper";function I8t(e){let{components:n,...t}=e;return(0,s.yg)(P8t,(0,p.A)({},z8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}I8t.isMDXComponent=!0;const R8t={toc:[]},W8t="wrapper";function S8t(e){let{components:n,...t}=e;return(0,s.yg)(W8t,(0,p.A)({},R8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}S8t.isMDXComponent=!0;const B8t={toc:[]},G8t="wrapper";function E8t(e){let{components:n,...t}=e;return(0,s.yg)(G8t,(0,p.A)({},B8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}E8t.isMDXComponent=!0;const O8t={toc:[]},U8t="wrapper";function F8t(e){let{components:n,...t}=e;return(0,s.yg)(U8t,(0,p.A)({},O8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}F8t.isMDXComponent=!0;const V8t={toc:[]},q8t="wrapper";function j8t(e){let{components:n,...t}=e;return(0,s.yg)(q8t,(0,p.A)({},V8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}j8t.isMDXComponent=!0;const H8t={toc:[]},Y8t="wrapper";function Q8t(e){let{components:n,...t}=e;return(0,s.yg)(Y8t,(0,p.A)({},H8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Q8t.isMDXComponent=!0;const $8t={toc:[]},K8t="wrapper";function J8t(e){let{components:n,...t}=e;return(0,s.yg)(K8t,(0,p.A)({},$8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}J8t.isMDXComponent=!0;const Z8t={toc:[]},e3t="wrapper";function n3t(e){let{components:n,...t}=e;return(0,s.yg)(e3t,(0,p.A)({},Z8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}n3t.isMDXComponent=!0;const t3t={toc:[]},o3t="wrapper";function p3t(e){let{components:n,...t}=e;return(0,s.yg)(o3t,(0,p.A)({},t3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}p3t.isMDXComponent=!0;const r3t={toc:[]},s3t="wrapper";function c3t(e){let{components:n,...t}=e;return(0,s.yg)(s3t,(0,p.A)({},r3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}c3t.isMDXComponent=!0;const a3t={toc:[]},i3t="wrapper";function l3t(e){let{components:n,...t}=e;return(0,s.yg)(i3t,(0,p.A)({},a3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}l3t.isMDXComponent=!0;const u3t={toc:[]},m3t="wrapper";function y3t(e){let{components:n,...t}=e;return(0,s.yg)(m3t,(0,p.A)({},u3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}y3t.isMDXComponent=!0;const d3t={toc:[]},h3t="wrapper";function g3t(e){let{components:n,...t}=e;return(0,s.yg)(h3t,(0,p.A)({},d3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}g3t.isMDXComponent=!0;const f3t={toc:[]},D3t="wrapper";function M3t(e){let{components:n,...t}=e;return(0,s.yg)(D3t,(0,p.A)({},f3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}M3t.isMDXComponent=!0;const X3t={toc:[]},_3t="wrapper";function w3t(e){let{components:n,...t}=e;return(0,s.yg)(_3t,(0,p.A)({},X3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}w3t.isMDXComponent=!0;const T3t={toc:[]},C3t="wrapper";function x3t(e){let{components:n,...t}=e;return(0,s.yg)(C3t,(0,p.A)({},T3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}x3t.isMDXComponent=!0;const A3t={toc:[]},v3t="wrapper";function L3t(e){let{components:n,...t}=e;return(0,s.yg)(v3t,(0,p.A)({},A3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}L3t.isMDXComponent=!0;const b3t={toc:[]},N3t="wrapper";function k3t(e){let{components:n,...t}=e;return(0,s.yg)(N3t,(0,p.A)({},b3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}k3t.isMDXComponent=!0;const z3t={toc:[]},P3t="wrapper";function I3t(e){let{components:n,...t}=e;return(0,s.yg)(P3t,(0,p.A)({},z3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}I3t.isMDXComponent=!0;const R3t={toc:[]},W3t="wrapper";function S3t(e){let{components:n,...t}=e;return(0,s.yg)(W3t,(0,p.A)({},R3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}S3t.isMDXComponent=!0;const B3t={toc:[]},G3t="wrapper";function E3t(e){let{components:n,...t}=e;return(0,s.yg)(G3t,(0,p.A)({},B3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}E3t.isMDXComponent=!0;const O3t={toc:[]},U3t="wrapper";function F3t(e){let{components:n,...t}=e;return(0,s.yg)(U3t,(0,p.A)({},O3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}F3t.isMDXComponent=!0;const V3t={toc:[]},q3t="wrapper";function j3t(e){let{components:n,...t}=e;return(0,s.yg)(q3t,(0,p.A)({},V3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}j3t.isMDXComponent=!0;const H3t={toc:[]},Y3t="wrapper";function Q3t(e){let{components:n,...t}=e;return(0,s.yg)(Y3t,(0,p.A)({},H3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Q3t.isMDXComponent=!0;const $3t={toc:[]},K3t="wrapper";function J3t(e){let{components:n,...t}=e;return(0,s.yg)(K3t,(0,p.A)({},$3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}J3t.isMDXComponent=!0;const Z3t={toc:[]},e1t="wrapper";function n1t(e){let{components:n,...t}=e;return(0,s.yg)(e1t,(0,p.A)({},Z3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}n1t.isMDXComponent=!0;const t1t={toc:[]},o1t="wrapper";function p1t(e){let{components:n,...t}=e;return(0,s.yg)(o1t,(0,p.A)({},t1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}p1t.isMDXComponent=!0;const r1t={toc:[]},s1t="wrapper";function c1t(e){let{components:n,...t}=e;return(0,s.yg)(s1t,(0,p.A)({},r1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}c1t.isMDXComponent=!0;const a1t={toc:[]},i1t="wrapper";function l1t(e){let{components:n,...t}=e;return(0,s.yg)(i1t,(0,p.A)({},a1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}l1t.isMDXComponent=!0;const u1t={toc:[]},m1t="wrapper";function y1t(e){let{components:n,...t}=e;return(0,s.yg)(m1t,(0,p.A)({},u1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}y1t.isMDXComponent=!0;const d1t={toc:[]},h1t="wrapper";function g1t(e){let{components:n,...t}=e;return(0,s.yg)(h1t,(0,p.A)({},d1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}g1t.isMDXComponent=!0;const f1t={toc:[]},D1t="wrapper";function M1t(e){let{components:n,...t}=e;return(0,s.yg)(D1t,(0,p.A)({},f1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}M1t.isMDXComponent=!0;const X1t={toc:[]},_1t="wrapper";function w1t(e){let{components:n,...t}=e;return(0,s.yg)(_1t,(0,p.A)({},X1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}w1t.isMDXComponent=!0;const T1t={toc:[]},C1t="wrapper";function x1t(e){let{components:n,...t}=e;return(0,s.yg)(C1t,(0,p.A)({},T1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}x1t.isMDXComponent=!0;const A1t={toc:[]},v1t="wrapper";function L1t(e){let{components:n,...t}=e;return(0,s.yg)(v1t,(0,p.A)({},A1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}L1t.isMDXComponent=!0;const b1t={toc:[]},N1t="wrapper";function k1t(e){let{components:n,...t}=e;return(0,s.yg)(N1t,(0,p.A)({},b1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}k1t.isMDXComponent=!0;const z1t={toc:[]},P1t="wrapper";function I1t(e){let{components:n,...t}=e;return(0,s.yg)(P1t,(0,p.A)({},z1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}I1t.isMDXComponent=!0;const R1t={toc:[]},W1t="wrapper";function S1t(e){let{components:n,...t}=e;return(0,s.yg)(W1t,(0,p.A)({},R1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}S1t.isMDXComponent=!0;const B1t={toc:[]},G1t="wrapper";function E1t(e){let{components:n,...t}=e;return(0,s.yg)(G1t,(0,p.A)({},B1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}E1t.isMDXComponent=!0;const O1t={toc:[]},U1t="wrapper";function F1t(e){let{components:n,...t}=e;return(0,s.yg)(U1t,(0,p.A)({},O1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}F1t.isMDXComponent=!0;const V1t={toc:[]},q1t="wrapper";function j1t(e){let{components:n,...t}=e;return(0,s.yg)(q1t,(0,p.A)({},V1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}j1t.isMDXComponent=!0;const H1t={toc:[]},Y1t="wrapper";function Q1t(e){let{components:n,...t}=e;return(0,s.yg)(Y1t,(0,p.A)({},H1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Q1t.isMDXComponent=!0;const $1t={toc:[]},K1t="wrapper";function J1t(e){let{components:n,...t}=e;return(0,s.yg)(K1t,(0,p.A)({},$1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}J1t.isMDXComponent=!0;const Z1t={toc:[]},e6t="wrapper";function n6t(e){let{components:n,...t}=e;return(0,s.yg)(e6t,(0,p.A)({},Z1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}n6t.isMDXComponent=!0;const t6t={toc:[]},o6t="wrapper";function p6t(e){let{components:n,...t}=e;return(0,s.yg)(o6t,(0,p.A)({},t6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}p6t.isMDXComponent=!0;const r6t={toc:[]},s6t="wrapper";function c6t(e){let{components:n,...t}=e;return(0,s.yg)(s6t,(0,p.A)({},r6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}c6t.isMDXComponent=!0;const a6t={toc:[]},i6t="wrapper";function l6t(e){let{components:n,...t}=e;return(0,s.yg)(i6t,(0,p.A)({},a6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}l6t.isMDXComponent=!0;const u6t={toc:[]},m6t="wrapper";function y6t(e){let{components:n,...t}=e;return(0,s.yg)(m6t,(0,p.A)({},u6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}y6t.isMDXComponent=!0;const d6t={toc:[]},h6t="wrapper";function g6t(e){let{components:n,...t}=e;return(0,s.yg)(h6t,(0,p.A)({},d6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}g6t.isMDXComponent=!0;const f6t={toc:[]},D6t="wrapper";function M6t(e){let{components:n,...t}=e;return(0,s.yg)(D6t,(0,p.A)({},f6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}M6t.isMDXComponent=!0;const X6t={toc:[]},_6t="wrapper";function w6t(e){let{components:n,...t}=e;return(0,s.yg)(_6t,(0,p.A)({},X6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}w6t.isMDXComponent=!0;const T6t={toc:[]},C6t="wrapper";function x6t(e){let{components:n,...t}=e;return(0,s.yg)(C6t,(0,p.A)({},T6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}x6t.isMDXComponent=!0;const A6t={toc:[]},v6t="wrapper";function L6t(e){let{components:n,...t}=e;return(0,s.yg)(v6t,(0,p.A)({},A6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}L6t.isMDXComponent=!0;const b6t={toc:[]},N6t="wrapper";function k6t(e){let{components:n,...t}=e;return(0,s.yg)(N6t,(0,p.A)({},b6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}k6t.isMDXComponent=!0;const z6t={toc:[]},P6t="wrapper";function I6t(e){let{components:n,...t}=e;return(0,s.yg)(P6t,(0,p.A)({},z6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}I6t.isMDXComponent=!0;const R6t={toc:[]},W6t="wrapper";function S6t(e){let{components:n,...t}=e;return(0,s.yg)(W6t,(0,p.A)({},R6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}S6t.isMDXComponent=!0;const B6t={toc:[]},G6t="wrapper";function E6t(e){let{components:n,...t}=e;return(0,s.yg)(G6t,(0,p.A)({},B6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}E6t.isMDXComponent=!0;const O6t={toc:[]},U6t="wrapper";function F6t(e){let{components:n,...t}=e;return(0,s.yg)(U6t,(0,p.A)({},O6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}F6t.isMDXComponent=!0;const V6t={toc:[]},q6t="wrapper";function j6t(e){let{components:n,...t}=e;return(0,s.yg)(q6t,(0,p.A)({},V6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}j6t.isMDXComponent=!0;const H6t={toc:[]},Y6t="wrapper";function Q6t(e){let{components:n,...t}=e;return(0,s.yg)(Y6t,(0,p.A)({},H6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Q6t.isMDXComponent=!0;const $6t={toc:[]},K6t="wrapper";function J6t(e){let{components:n,...t}=e;return(0,s.yg)(K6t,(0,p.A)({},$6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}J6t.isMDXComponent=!0;const Z6t={toc:[]},e5t="wrapper";function n5t(e){let{components:n,...t}=e;return(0,s.yg)(e5t,(0,p.A)({},Z6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}n5t.isMDXComponent=!0;const t5t={toc:[]},o5t="wrapper";function p5t(e){let{components:n,...t}=e;return(0,s.yg)(o5t,(0,p.A)({},t5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}p5t.isMDXComponent=!0;const r5t={toc:[]},s5t="wrapper";function c5t(e){let{components:n,...t}=e;return(0,s.yg)(s5t,(0,p.A)({},r5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}c5t.isMDXComponent=!0;const a5t={toc:[]},i5t="wrapper";function l5t(e){let{components:n,...t}=e;return(0,s.yg)(i5t,(0,p.A)({},a5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}l5t.isMDXComponent=!0;const u5t={toc:[]},m5t="wrapper";function y5t(e){let{components:n,...t}=e;return(0,s.yg)(m5t,(0,p.A)({},u5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}y5t.isMDXComponent=!0;const d5t={toc:[]},h5t="wrapper";function g5t(e){let{components:n,...t}=e;return(0,s.yg)(h5t,(0,p.A)({},d5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}g5t.isMDXComponent=!0;const f5t={toc:[]},D5t="wrapper";function M5t(e){let{components:n,...t}=e;return(0,s.yg)(D5t,(0,p.A)({},f5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}M5t.isMDXComponent=!0;const X5t={toc:[]},_5t="wrapper";function w5t(e){let{components:n,...t}=e;return(0,s.yg)(_5t,(0,p.A)({},X5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}w5t.isMDXComponent=!0;const T5t={toc:[]},C5t="wrapper";function x5t(e){let{components:n,...t}=e;return(0,s.yg)(C5t,(0,p.A)({},T5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}x5t.isMDXComponent=!0;const A5t={toc:[]},v5t="wrapper";function L5t(e){let{components:n,...t}=e;return(0,s.yg)(v5t,(0,p.A)({},A5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}L5t.isMDXComponent=!0;const b5t={toc:[]},N5t="wrapper";function k5t(e){let{components:n,...t}=e;return(0,s.yg)(N5t,(0,p.A)({},b5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}k5t.isMDXComponent=!0;const z5t={toc:[]},P5t="wrapper";function I5t(e){let{components:n,...t}=e;return(0,s.yg)(P5t,(0,p.A)({},z5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}I5t.isMDXComponent=!0;const R5t={toc:[]},W5t="wrapper";function S5t(e){let{components:n,...t}=e;return(0,s.yg)(W5t,(0,p.A)({},R5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}S5t.isMDXComponent=!0;const B5t={toc:[]},G5t="wrapper";function E5t(e){let{components:n,...t}=e;return(0,s.yg)(G5t,(0,p.A)({},B5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}E5t.isMDXComponent=!0;const O5t={toc:[]},U5t="wrapper";function F5t(e){let{components:n,...t}=e;return(0,s.yg)(U5t,(0,p.A)({},O5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}F5t.isMDXComponent=!0;const V5t={toc:[]},q5t="wrapper";function j5t(e){let{components:n,...t}=e;return(0,s.yg)(q5t,(0,p.A)({},V5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}j5t.isMDXComponent=!0;const H5t={toc:[]},Y5t="wrapper";function Q5t(e){let{components:n,...t}=e;return(0,s.yg)(Y5t,(0,p.A)({},H5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Q5t.isMDXComponent=!0;const $5t={toc:[]},K5t="wrapper";function J5t(e){let{components:n,...t}=e;return(0,s.yg)(K5t,(0,p.A)({},$5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}J5t.isMDXComponent=!0;const Z5t={toc:[]},e7t="wrapper";function n7t(e){let{components:n,...t}=e;return(0,s.yg)(e7t,(0,p.A)({},Z5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}n7t.isMDXComponent=!0;const t7t={toc:[]},o7t="wrapper";function p7t(e){let{components:n,...t}=e;return(0,s.yg)(o7t,(0,p.A)({},t7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}p7t.isMDXComponent=!0;const r7t={toc:[]},s7t="wrapper";function c7t(e){let{components:n,...t}=e;return(0,s.yg)(s7t,(0,p.A)({},r7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}c7t.isMDXComponent=!0;const a7t={toc:[]},i7t="wrapper";function l7t(e){let{components:n,...t}=e;return(0,s.yg)(i7t,(0,p.A)({},a7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}l7t.isMDXComponent=!0;const u7t={toc:[]},m7t="wrapper";function y7t(e){let{components:n,...t}=e;return(0,s.yg)(m7t,(0,p.A)({},u7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}y7t.isMDXComponent=!0;const d7t={toc:[]},h7t="wrapper";function g7t(e){let{components:n,...t}=e;return(0,s.yg)(h7t,(0,p.A)({},d7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}g7t.isMDXComponent=!0;const f7t={toc:[]},D7t="wrapper";function M7t(e){let{components:n,...t}=e;return(0,s.yg)(D7t,(0,p.A)({},f7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}M7t.isMDXComponent=!0;const X7t={toc:[]},_7t="wrapper";function w7t(e){let{components:n,...t}=e;return(0,s.yg)(_7t,(0,p.A)({},X7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}w7t.isMDXComponent=!0;const T7t={toc:[]},C7t="wrapper";function x7t(e){let{components:n,...t}=e;return(0,s.yg)(C7t,(0,p.A)({},T7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}x7t.isMDXComponent=!0;const A7t={toc:[]},v7t="wrapper";function L7t(e){let{components:n,...t}=e;return(0,s.yg)(v7t,(0,p.A)({},A7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}L7t.isMDXComponent=!0;const b7t={toc:[]},N7t="wrapper";function k7t(e){let{components:n,...t}=e;return(0,s.yg)(N7t,(0,p.A)({},b7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}k7t.isMDXComponent=!0;const z7t={toc:[]},P7t="wrapper";function I7t(e){let{components:n,...t}=e;return(0,s.yg)(P7t,(0,p.A)({},z7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}I7t.isMDXComponent=!0;const R7t={toc:[]},W7t="wrapper";function S7t(e){let{components:n,...t}=e;return(0,s.yg)(W7t,(0,p.A)({},R7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}S7t.isMDXComponent=!0;const B7t={toc:[]},G7t="wrapper";function E7t(e){let{components:n,...t}=e;return(0,s.yg)(G7t,(0,p.A)({},B7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}E7t.isMDXComponent=!0;const O7t={toc:[]},U7t="wrapper";function F7t(e){let{components:n,...t}=e;return(0,s.yg)(U7t,(0,p.A)({},O7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}F7t.isMDXComponent=!0;const V7t={toc:[]},q7t="wrapper";function j7t(e){let{components:n,...t}=e;return(0,s.yg)(q7t,(0,p.A)({},V7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}j7t.isMDXComponent=!0;const H7t={toc:[]},Y7t="wrapper";function Q7t(e){let{components:n,...t}=e;return(0,s.yg)(Y7t,(0,p.A)({},H7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Q7t.isMDXComponent=!0;const $7t={toc:[]},K7t="wrapper";function J7t(e){let{components:n,...t}=e;return(0,s.yg)(K7t,(0,p.A)({},$7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}J7t.isMDXComponent=!0;const Z7t={toc:[]},e9t="wrapper";function n9t(e){let{components:n,...t}=e;return(0,s.yg)(e9t,(0,p.A)({},Z7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}n9t.isMDXComponent=!0;const t9t={toc:[]},o9t="wrapper";function p9t(e){let{components:n,...t}=e;return(0,s.yg)(o9t,(0,p.A)({},t9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}p9t.isMDXComponent=!0;const r9t={toc:[]},s9t="wrapper";function c9t(e){let{components:n,...t}=e;return(0,s.yg)(s9t,(0,p.A)({},r9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}c9t.isMDXComponent=!0;const a9t={toc:[]},i9t="wrapper";function l9t(e){let{components:n,...t}=e;return(0,s.yg)(i9t,(0,p.A)({},a9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}l9t.isMDXComponent=!0;const u9t={toc:[]},m9t="wrapper";function y9t(e){let{components:n,...t}=e;return(0,s.yg)(m9t,(0,p.A)({},u9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}y9t.isMDXComponent=!0;const d9t={toc:[]},h9t="wrapper";function g9t(e){let{components:n,...t}=e;return(0,s.yg)(h9t,(0,p.A)({},d9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}g9t.isMDXComponent=!0;const f9t={toc:[]},D9t="wrapper";function M9t(e){let{components:n,...t}=e;return(0,s.yg)(D9t,(0,p.A)({},f9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}M9t.isMDXComponent=!0;const X9t={toc:[]},_9t="wrapper";function w9t(e){let{components:n,...t}=e;return(0,s.yg)(_9t,(0,p.A)({},X9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}w9t.isMDXComponent=!0;const T9t={toc:[]},C9t="wrapper";function x9t(e){let{components:n,...t}=e;return(0,s.yg)(C9t,(0,p.A)({},T9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}x9t.isMDXComponent=!0;const A9t={toc:[]},v9t="wrapper";function L9t(e){let{components:n,...t}=e;return(0,s.yg)(v9t,(0,p.A)({},A9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}L9t.isMDXComponent=!0;const b9t={toc:[]},N9t="wrapper";function k9t(e){let{components:n,...t}=e;return(0,s.yg)(N9t,(0,p.A)({},b9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}k9t.isMDXComponent=!0;const z9t={toc:[]},P9t="wrapper";function I9t(e){let{components:n,...t}=e;return(0,s.yg)(P9t,(0,p.A)({},z9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}I9t.isMDXComponent=!0;const R9t={toc:[]},W9t="wrapper";function S9t(e){let{components:n,...t}=e;return(0,s.yg)(W9t,(0,p.A)({},R9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}S9t.isMDXComponent=!0;const B9t={toc:[]},G9t="wrapper";function E9t(e){let{components:n,...t}=e;return(0,s.yg)(G9t,(0,p.A)({},B9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}E9t.isMDXComponent=!0;const O9t={toc:[]},U9t="wrapper";function F9t(e){let{components:n,...t}=e;return(0,s.yg)(U9t,(0,p.A)({},O9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}F9t.isMDXComponent=!0;const V9t={toc:[]},q9t="wrapper";function j9t(e){let{components:n,...t}=e;return(0,s.yg)(q9t,(0,p.A)({},V9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@revideo/2d';\nimport {Ray} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}j9t.isMDXComponent=!0;const H9t={toc:[]},Y9t="wrapper";function Q9t(e){let{components:n,...t}=e;return(0,s.yg)(Y9t,(0,p.A)({},H9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing an individual line segment."))}Q9t.isMDXComponent=!0;const $9t={toc:[]},K9t="wrapper";function J9t(e){let{components:n,...t}=e;return(0,s.yg)(K9t,(0,p.A)({},$9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}J9t.isMDXComponent=!0;const Z9t={toc:[]},eeo="wrapper";function neo(e){let{components:n,...t}=e;return(0,s.yg)(eeo,(0,p.A)({},Z9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}neo.isMDXComponent=!0;const teo={toc:[]},oeo="wrapper";function peo(e){let{components:n,...t}=e;return(0,s.yg)(oeo,(0,p.A)({},teo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}peo.isMDXComponent=!0;const reo={toc:[]},seo="wrapper";function ceo(e){let{components:n,...t}=e;return(0,s.yg)(seo,(0,p.A)({},reo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}ceo.isMDXComponent=!0;const aeo={toc:[]},ieo="wrapper";function leo(e){let{components:n,...t}=e;return(0,s.yg)(ieo,(0,p.A)({},aeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}leo.isMDXComponent=!0;const ueo={toc:[]},meo="wrapper";function yeo(e){let{components:n,...t}=e;return(0,s.yg)(meo,(0,p.A)({},ueo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}yeo.isMDXComponent=!0;const deo={toc:[]},heo="wrapper";function geo(e){let{components:n,...t}=e;return(0,s.yg)(heo,(0,p.A)({},deo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}geo.isMDXComponent=!0;const feo={toc:[]},Deo="wrapper";function Meo(e){let{components:n,...t}=e;return(0,s.yg)(Deo,(0,p.A)({},feo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Meo.isMDXComponent=!0;const Xeo={toc:[]},_eo="wrapper";function weo(e){let{components:n,...t}=e;return(0,s.yg)(_eo,(0,p.A)({},Xeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}weo.isMDXComponent=!0;const Teo={toc:[]},Ceo="wrapper";function xeo(e){let{components:n,...t}=e;return(0,s.yg)(Ceo,(0,p.A)({},Teo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}xeo.isMDXComponent=!0;const Aeo={toc:[]},veo="wrapper";function Leo(e){let{components:n,...t}=e;return(0,s.yg)(veo,(0,p.A)({},Aeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Leo.isMDXComponent=!0;const beo={toc:[]},Neo="wrapper";function keo(e){let{components:n,...t}=e;return(0,s.yg)(Neo,(0,p.A)({},beo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}keo.isMDXComponent=!0;const zeo={toc:[]},Peo="wrapper";function Ieo(e){let{components:n,...t}=e;return(0,s.yg)(Peo,(0,p.A)({},zeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Ieo.isMDXComponent=!0;const Reo={toc:[]},Weo="wrapper";function Seo(e){let{components:n,...t}=e;return(0,s.yg)(Weo,(0,p.A)({},Reo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Seo.isMDXComponent=!0;const Beo={toc:[]},Geo="wrapper";function Eeo(e){let{components:n,...t}=e;return(0,s.yg)(Geo,(0,p.A)({},Beo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Eeo.isMDXComponent=!0;const Oeo={toc:[]},Ueo="wrapper";function Feo(e){let{components:n,...t}=e;return(0,s.yg)(Ueo,(0,p.A)({},Oeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Feo.isMDXComponent=!0;const Veo={toc:[]},qeo="wrapper";function jeo(e){let{components:n,...t}=e;return(0,s.yg)(qeo,(0,p.A)({},Veo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}jeo.isMDXComponent=!0;const Heo={toc:[]},Yeo="wrapper";function Qeo(e){let{components:n,...t}=e;return(0,s.yg)(Yeo,(0,p.A)({},Heo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Qeo.isMDXComponent=!0;const $eo={toc:[]},Keo="wrapper";function Jeo(e){let{components:n,...t}=e;return(0,s.yg)(Keo,(0,p.A)({},$eo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Jeo.isMDXComponent=!0;const Zeo={toc:[]},eno="wrapper";function nno(e){let{components:n,...t}=e;return(0,s.yg)(eno,(0,p.A)({},Zeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}nno.isMDXComponent=!0;const tno={toc:[]},ono="wrapper";function pno(e){let{components:n,...t}=e;return(0,s.yg)(ono,(0,p.A)({},tno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pno.isMDXComponent=!0;const rno={toc:[]},sno="wrapper";function cno(e){let{components:n,...t}=e;return(0,s.yg)(sno,(0,p.A)({},rno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}cno.isMDXComponent=!0;const ano={toc:[]},ino="wrapper";function lno(e){let{components:n,...t}=e;return(0,s.yg)(ino,(0,p.A)({},ano,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}lno.isMDXComponent=!0;const uno={toc:[]},mno="wrapper";function yno(e){let{components:n,...t}=e;return(0,s.yg)(mno,(0,p.A)({},uno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}yno.isMDXComponent=!0;const dno={toc:[]},hno="wrapper";function gno(e){let{components:n,...t}=e;return(0,s.yg)(hno,(0,p.A)({},dno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting point of the ray."))}gno.isMDXComponent=!0;const fno={toc:[]},Dno="wrapper";function Mno(e){let{components:n,...t}=e;return(0,s.yg)(Dno,(0,p.A)({},fno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Mno.isMDXComponent=!0;const Xno={toc:[]},_no="wrapper";function wno(e){let{components:n,...t}=e;return(0,s.yg)(_no,(0,p.A)({},Xno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}wno.isMDXComponent=!0;const Tno={toc:[]},Cno="wrapper";function xno(e){let{components:n,...t}=e;return(0,s.yg)(Cno,(0,p.A)({},Tno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}xno.isMDXComponent=!0;const Ano={toc:[]},vno="wrapper";function Lno(e){let{components:n,...t}=e;return(0,s.yg)(vno,(0,p.A)({},Ano,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Lno.isMDXComponent=!0;const bno={toc:[]},Nno="wrapper";function kno(e){let{components:n,...t}=e;return(0,s.yg)(Nno,(0,p.A)({},bno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kno.isMDXComponent=!0;const zno={toc:[]},Pno="wrapper";function Ino(e){let{components:n,...t}=e;return(0,s.yg)(Pno,(0,p.A)({},zno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Ino.isMDXComponent=!0;const Rno={toc:[]},Wno="wrapper";function Sno(e){let{components:n,...t}=e;return(0,s.yg)(Wno,(0,p.A)({},Rno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Sno.isMDXComponent=!0;const Bno={toc:[]},Gno="wrapper";function Eno(e){let{components:n,...t}=e;return(0,s.yg)(Gno,(0,p.A)({},Bno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Eno.isMDXComponent=!0;const Ono={toc:[]},Uno="wrapper";function Fno(e){let{components:n,...t}=e;return(0,s.yg)(Uno,(0,p.A)({},Ono,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Fno.isMDXComponent=!0;const Vno={toc:[]},qno="wrapper";function jno(e){let{components:n,...t}=e;return(0,s.yg)(qno,(0,p.A)({},Vno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}jno.isMDXComponent=!0;const Hno={toc:[]},Yno="wrapper";function Qno(e){let{components:n,...t}=e;return(0,s.yg)(Yno,(0,p.A)({},Hno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Qno.isMDXComponent=!0;const $no={toc:[]},Kno="wrapper";function Jno(e){let{components:n,...t}=e;return(0,s.yg)(Kno,(0,p.A)({},$no,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Jno.isMDXComponent=!0;const Zno={toc:[]},eto="wrapper";function nto(e){let{components:n,...t}=e;return(0,s.yg)(eto,(0,p.A)({},Zno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nto.isMDXComponent=!0;const tto={toc:[]},oto="wrapper";function pto(e){let{components:n,...t}=e;return(0,s.yg)(oto,(0,p.A)({},tto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pto.isMDXComponent=!0;const rto={toc:[]},sto="wrapper";function cto(e){let{components:n,...t}=e;return(0,s.yg)(sto,(0,p.A)({},rto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}cto.isMDXComponent=!0;const ato={toc:[]},ito="wrapper";function lto(e){let{components:n,...t}=e;return(0,s.yg)(ito,(0,p.A)({},ato,t,{components:n,mdxType:"MDXLayout"}))}lto.isMDXComponent=!0;const uto={toc:[]},mto="wrapper";function yto(e){let{components:n,...t}=e;return(0,s.yg)(mto,(0,p.A)({},uto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}yto.isMDXComponent=!0;const dto={toc:[]},hto="wrapper";function gto(e){let{components:n,...t}=e;return(0,s.yg)(hto,(0,p.A)({},dto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}gto.isMDXComponent=!0;const fto={toc:[]},Dto="wrapper";function Mto(e){let{components:n,...t}=e;return(0,s.yg)(Dto,(0,p.A)({},fto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Mto.isMDXComponent=!0;const Xto={toc:[]},_to="wrapper";function wto(e){let{components:n,...t}=e;return(0,s.yg)(_to,(0,p.A)({},Xto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}wto.isMDXComponent=!0;const Tto={toc:[]},Cto="wrapper";function xto(e){let{components:n,...t}=e;return(0,s.yg)(Cto,(0,p.A)({},Tto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}xto.isMDXComponent=!0;const Ato={toc:[]},vto="wrapper";function Lto(e){let{components:n,...t}=e;return(0,s.yg)(vto,(0,p.A)({},Ato,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Lto.isMDXComponent=!0;const bto={toc:[]},Nto="wrapper";function kto(e){let{components:n,...t}=e;return(0,s.yg)(Nto,(0,p.A)({},bto,t,{components:n,mdxType:"MDXLayout"}))}kto.isMDXComponent=!0;const zto={toc:[]},Pto="wrapper";function Ito(e){let{components:n,...t}=e;return(0,s.yg)(Pto,(0,p.A)({},zto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ito.isMDXComponent=!0;const Rto={toc:[]},Wto="wrapper";function Sto(e){let{components:n,...t}=e;return(0,s.yg)(Wto,(0,p.A)({},Rto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Sto.isMDXComponent=!0;const Bto={toc:[]},Gto="wrapper";function Eto(e){let{components:n,...t}=e;return(0,s.yg)(Gto,(0,p.A)({},Bto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Eto.isMDXComponent=!0;const Oto={toc:[]},Uto="wrapper";function Fto(e){let{components:n,...t}=e;return(0,s.yg)(Uto,(0,p.A)({},Oto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Fto.isMDXComponent=!0;const Vto={toc:[]},qto="wrapper";function jto(e){let{components:n,...t}=e;return(0,s.yg)(qto,(0,p.A)({},Vto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jto.isMDXComponent=!0;const Hto={toc:[]},Yto="wrapper";function Qto(e){let{components:n,...t}=e;return(0,s.yg)(Yto,(0,p.A)({},Hto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Qto.isMDXComponent=!0;const $to={toc:[]},Kto="wrapper";function Jto(e){let{components:n,...t}=e;return(0,s.yg)(Kto,(0,p.A)({},$to,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending point of the ray."))}Jto.isMDXComponent=!0;const Zto={toc:[]},eoo="wrapper";function noo(e){let{components:n,...t}=e;return(0,s.yg)(eoo,(0,p.A)({},Zto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}noo.isMDXComponent=!0;const too={toc:[]},ooo="wrapper";function poo(e){let{components:n,...t}=e;return(0,s.yg)(ooo,(0,p.A)({},too,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}poo.isMDXComponent=!0;const roo={toc:[]},soo="wrapper";function coo(e){let{components:n,...t}=e;return(0,s.yg)(soo,(0,p.A)({},roo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}coo.isMDXComponent=!0;const aoo={toc:[]},ioo="wrapper";function loo(e){let{components:n,...t}=e;return(0,s.yg)(ioo,(0,p.A)({},aoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}loo.isMDXComponent=!0;const uoo={toc:[]},moo="wrapper";function yoo(e){let{components:n,...t}=e;return(0,s.yg)(moo,(0,p.A)({},uoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}yoo.isMDXComponent=!0;const doo={toc:[]},hoo="wrapper";function goo(e){let{components:n,...t}=e;return(0,s.yg)(hoo,(0,p.A)({},doo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}goo.isMDXComponent=!0;const foo={toc:[]},Doo="wrapper";function Moo(e){let{components:n,...t}=e;return(0,s.yg)(Doo,(0,p.A)({},foo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Moo.isMDXComponent=!0;const Xoo={toc:[]},_oo="wrapper";function woo(e){let{components:n,...t}=e;return(0,s.yg)(_oo,(0,p.A)({},Xoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}woo.isMDXComponent=!0;const Too={toc:[]},Coo="wrapper";function xoo(e){let{components:n,...t}=e;return(0,s.yg)(Coo,(0,p.A)({},Too,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}xoo.isMDXComponent=!0;const Aoo={toc:[]},voo="wrapper";function Loo(e){let{components:n,...t}=e;return(0,s.yg)(voo,(0,p.A)({},Aoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Loo.isMDXComponent=!0;const boo={toc:[]},Noo="wrapper";function koo(e){let{components:n,...t}=e;return(0,s.yg)(Noo,(0,p.A)({},boo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}koo.isMDXComponent=!0;const zoo={toc:[]},Poo="wrapper";function Ioo(e){let{components:n,...t}=e;return(0,s.yg)(Poo,(0,p.A)({},zoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Ioo.isMDXComponent=!0;const Roo={toc:[]},Woo="wrapper";function Soo(e){let{components:n,...t}=e;return(0,s.yg)(Woo,(0,p.A)({},Roo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Soo.isMDXComponent=!0;const Boo={toc:[]},Goo="wrapper";function Eoo(e){let{components:n,...t}=e;return(0,s.yg)(Goo,(0,p.A)({},Boo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Eoo.isMDXComponent=!0;const Ooo={toc:[]},Uoo="wrapper";function Foo(e){let{components:n,...t}=e;return(0,s.yg)(Uoo,(0,p.A)({},Ooo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Foo.isMDXComponent=!0;const Voo={toc:[]},qoo="wrapper";function joo(e){let{components:n,...t}=e;return(0,s.yg)(qoo,(0,p.A)({},Voo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}joo.isMDXComponent=!0;const Hoo={toc:[]},Yoo="wrapper";function Qoo(e){let{components:n,...t}=e;return(0,s.yg)(Yoo,(0,p.A)({},Hoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Qoo.isMDXComponent=!0;const $oo={toc:[]},Koo="wrapper";function Joo(e){let{components:n,...t}=e;return(0,s.yg)(Koo,(0,p.A)({},$oo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Joo.isMDXComponent=!0;const Zoo={toc:[]},epo="wrapper";function npo(e){let{components:n,...t}=e;return(0,s.yg)(epo,(0,p.A)({},Zoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}npo.isMDXComponent=!0;const tpo={toc:[]},opo="wrapper";function ppo(e){let{components:n,...t}=e;return(0,s.yg)(opo,(0,p.A)({},tpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}ppo.isMDXComponent=!0;const rpo={toc:[]},spo="wrapper";function cpo(e){let{components:n,...t}=e;return(0,s.yg)(spo,(0,p.A)({},rpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}cpo.isMDXComponent=!0;const apo={toc:[]},ipo="wrapper";function lpo(e){let{components:n,...t}=e;return(0,s.yg)(ipo,(0,p.A)({},apo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lpo.isMDXComponent=!0;const upo={toc:[]},mpo="wrapper";function ypo(e){let{components:n,...t}=e;return(0,s.yg)(mpo,(0,p.A)({},upo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}ypo.isMDXComponent=!0;const dpo={toc:[]},hpo="wrapper";function gpo(e){let{components:n,...t}=e;return(0,s.yg)(hpo,(0,p.A)({},dpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}gpo.isMDXComponent=!0;const fpo={toc:[]},Dpo="wrapper";function Mpo(e){let{components:n,...t}=e;return(0,s.yg)(Dpo,(0,p.A)({},fpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Mpo.isMDXComponent=!0;const Xpo={toc:[]},_po="wrapper";function wpo(e){let{components:n,...t}=e;return(0,s.yg)(_po,(0,p.A)({},Xpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}wpo.isMDXComponent=!0;const Tpo={toc:[]},Cpo="wrapper";function xpo(e){let{components:n,...t}=e;return(0,s.yg)(Cpo,(0,p.A)({},Tpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}xpo.isMDXComponent=!0;const Apo={toc:[]},vpo="wrapper";function Lpo(e){let{components:n,...t}=e;return(0,s.yg)(vpo,(0,p.A)({},Apo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Lpo.isMDXComponent=!0;const bpo={toc:[]},Npo="wrapper";function kpo(e){let{components:n,...t}=e;return(0,s.yg)(Npo,(0,p.A)({},bpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}kpo.isMDXComponent=!0;const zpo={toc:[]},Ppo="wrapper";function Ipo(e){let{components:n,...t}=e;return(0,s.yg)(Ppo,(0,p.A)({},zpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Ipo.isMDXComponent=!0;const Rpo={toc:[]},Wpo="wrapper";function Spo(e){let{components:n,...t}=e;return(0,s.yg)(Wpo,(0,p.A)({},Rpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Spo.isMDXComponent=!0;const Bpo={toc:[]},Gpo="wrapper";function Epo(e){let{components:n,...t}=e;return(0,s.yg)(Gpo,(0,p.A)({},Bpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Epo.isMDXComponent=!0;const Opo={toc:[]},Upo="wrapper";function Fpo(e){let{components:n,...t}=e;return(0,s.yg)(Upo,(0,p.A)({},Opo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Fpo.isMDXComponent=!0;const Vpo={toc:[]},qpo="wrapper";function jpo(e){let{components:n,...t}=e;return(0,s.yg)(qpo,(0,p.A)({},Vpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}jpo.isMDXComponent=!0;const Hpo={toc:[]},Ypo="wrapper";function Qpo(e){let{components:n,...t}=e;return(0,s.yg)(Ypo,(0,p.A)({},Hpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Qpo.isMDXComponent=!0;const $po={toc:[]},Kpo="wrapper";function Jpo(e){let{components:n,...t}=e;return(0,s.yg)(Kpo,(0,p.A)({},$po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Jpo.isMDXComponent=!0;const Zpo={toc:[]},ero="wrapper";function nro(e){let{components:n,...t}=e;return(0,s.yg)(ero,(0,p.A)({},Zpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}nro.isMDXComponent=!0;const tro={toc:[]},oro="wrapper";function pro(e){let{components:n,...t}=e;return(0,s.yg)(oro,(0,p.A)({},tro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}pro.isMDXComponent=!0;const rro={toc:[]},sro="wrapper";function cro(e){let{components:n,...t}=e;return(0,s.yg)(sro,(0,p.A)({},rro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}cro.isMDXComponent=!0;const aro={toc:[]},iro="wrapper";function lro(e){let{components:n,...t}=e;return(0,s.yg)(iro,(0,p.A)({},aro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}lro.isMDXComponent=!0;const uro={toc:[]},mro="wrapper";function yro(e){let{components:n,...t}=e;return(0,s.yg)(mro,(0,p.A)({},uro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}yro.isMDXComponent=!0;const dro={toc:[]},hro="wrapper";function gro(e){let{components:n,...t}=e;return(0,s.yg)(hro,(0,p.A)({},dro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}gro.isMDXComponent=!0;const fro={toc:[]},Dro="wrapper";function Mro(e){let{components:n,...t}=e;return(0,s.yg)(Dro,(0,p.A)({},fro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Mro.isMDXComponent=!0;const Xro={toc:[]},_ro="wrapper";function wro(e){let{components:n,...t}=e;return(0,s.yg)(_ro,(0,p.A)({},Xro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}wro.isMDXComponent=!0;const Tro={toc:[]},Cro="wrapper";function xro(e){let{components:n,...t}=e;return(0,s.yg)(Cro,(0,p.A)({},Tro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}xro.isMDXComponent=!0;const Aro={toc:[]},vro="wrapper";function Lro(e){let{components:n,...t}=e;return(0,s.yg)(vro,(0,p.A)({},Aro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Lro.isMDXComponent=!0;const bro={toc:[]},Nro="wrapper";function kro(e){let{components:n,...t}=e;return(0,s.yg)(Nro,(0,p.A)({},bro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}kro.isMDXComponent=!0;const zro={toc:[]},Pro="wrapper";function Iro(e){let{components:n,...t}=e;return(0,s.yg)(Pro,(0,p.A)({},zro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Iro.isMDXComponent=!0;const Rro={toc:[]},Wro="wrapper";function Sro(e){let{components:n,...t}=e;return(0,s.yg)(Wro,(0,p.A)({},Rro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Sro.isMDXComponent=!0;const Bro={toc:[]},Gro="wrapper";function Ero(e){let{components:n,...t}=e;return(0,s.yg)(Gro,(0,p.A)({},Bro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ero.isMDXComponent=!0;const Oro={toc:[]},Uro="wrapper";function Fro(e){let{components:n,...t}=e;return(0,s.yg)(Uro,(0,p.A)({},Oro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Fro.isMDXComponent=!0;const Vro={toc:[]},qro="wrapper";function jro(e){let{components:n,...t}=e;return(0,s.yg)(qro,(0,p.A)({},Vro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jro.isMDXComponent=!0;const Hro={toc:[]},Yro="wrapper";function Qro(e){let{components:n,...t}=e;return(0,s.yg)(Yro,(0,p.A)({},Hro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Qro.isMDXComponent=!0;const $ro={toc:[]},Kro="wrapper";function Jro(e){let{components:n,...t}=e;return(0,s.yg)(Kro,(0,p.A)({},$ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jro.isMDXComponent=!0;const Zro={toc:[]},eso="wrapper";function nso(e){let{components:n,...t}=e;return(0,s.yg)(eso,(0,p.A)({},Zro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}nso.isMDXComponent=!0;const tso={toc:[]},oso="wrapper";function pso(e){let{components:n,...t}=e;return(0,s.yg)(oso,(0,p.A)({},tso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pso.isMDXComponent=!0;const rso={toc:[]},sso="wrapper";function cso(e){let{components:n,...t}=e;return(0,s.yg)(sso,(0,p.A)({},rso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}cso.isMDXComponent=!0;const aso={toc:[]},iso="wrapper";function lso(e){let{components:n,...t}=e;return(0,s.yg)(iso,(0,p.A)({},aso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lso.isMDXComponent=!0;const uso={toc:[]},mso="wrapper";function yso(e){let{components:n,...t}=e;return(0,s.yg)(mso,(0,p.A)({},uso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}yso.isMDXComponent=!0;const dso={toc:[]},hso="wrapper";function gso(e){let{components:n,...t}=e;return(0,s.yg)(hso,(0,p.A)({},dso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gso.isMDXComponent=!0;const fso={toc:[]},Dso="wrapper";function Mso(e){let{components:n,...t}=e;return(0,s.yg)(Dso,(0,p.A)({},fso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mso.isMDXComponent=!0;const Xso={toc:[]},_so="wrapper";function wso(e){let{components:n,...t}=e;return(0,s.yg)(_so,(0,p.A)({},Xso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wso.isMDXComponent=!0;const Tso={toc:[]},Cso="wrapper";function xso(e){let{components:n,...t}=e;return(0,s.yg)(Cso,(0,p.A)({},Tso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}xso.isMDXComponent=!0;const Aso={toc:[]},vso="wrapper";function Lso(e){let{components:n,...t}=e;return(0,s.yg)(vso,(0,p.A)({},Aso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lso.isMDXComponent=!0;const bso={toc:[]},Nso="wrapper";function kso(e){let{components:n,...t}=e;return(0,s.yg)(Nso,(0,p.A)({},bso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}kso.isMDXComponent=!0;const zso={toc:[]},Pso="wrapper";function Iso(e){let{components:n,...t}=e;return(0,s.yg)(Pso,(0,p.A)({},zso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Iso.isMDXComponent=!0;const Rso={toc:[]},Wso="wrapper";function Sso(e){let{components:n,...t}=e;return(0,s.yg)(Wso,(0,p.A)({},Rso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Sso.isMDXComponent=!0;const Bso={toc:[]},Gso="wrapper";function Eso(e){let{components:n,...t}=e;return(0,s.yg)(Gso,(0,p.A)({},Bso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Eso.isMDXComponent=!0;const Oso={toc:[]},Uso="wrapper";function Fso(e){let{components:n,...t}=e;return(0,s.yg)(Uso,(0,p.A)({},Oso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Fso.isMDXComponent=!0;const Vso={toc:[]},qso="wrapper";function jso(e){let{components:n,...t}=e;return(0,s.yg)(qso,(0,p.A)({},Vso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}jso.isMDXComponent=!0;const Hso={toc:[]},Yso="wrapper";function Qso(e){let{components:n,...t}=e;return(0,s.yg)(Yso,(0,p.A)({},Hso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Qso.isMDXComponent=!0;const $so={toc:[]},Kso="wrapper";function Jso(e){let{components:n,...t}=e;return(0,s.yg)(Kso,(0,p.A)({},$so,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Jso.isMDXComponent=!0;const Zso={toc:[]},eco="wrapper";function nco(e){let{components:n,...t}=e;return(0,s.yg)(eco,(0,p.A)({},Zso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}nco.isMDXComponent=!0;const tco={toc:[]},oco="wrapper";function pco(e){let{components:n,...t}=e;return(0,s.yg)(oco,(0,p.A)({},tco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}pco.isMDXComponent=!0;const rco={toc:[]},sco="wrapper";function cco(e){let{components:n,...t}=e;return(0,s.yg)(sco,(0,p.A)({},rco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}cco.isMDXComponent=!0;const aco={toc:[]},ico="wrapper";function lco(e){let{components:n,...t}=e;return(0,s.yg)(ico,(0,p.A)({},aco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}lco.isMDXComponent=!0;const uco={toc:[]},mco="wrapper";function yco(e){let{components:n,...t}=e;return(0,s.yg)(mco,(0,p.A)({},uco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yco.isMDXComponent=!0;const dco={toc:[]},hco="wrapper";function gco(e){let{components:n,...t}=e;return(0,s.yg)(hco,(0,p.A)({},dco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}gco.isMDXComponent=!0;const fco={toc:[]},Dco="wrapper";function Mco(e){let{components:n,...t}=e;return(0,s.yg)(Dco,(0,p.A)({},fco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Mco.isMDXComponent=!0;const Xco={toc:[]},_co="wrapper";function wco(e){let{components:n,...t}=e;return(0,s.yg)(_co,(0,p.A)({},Xco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}wco.isMDXComponent=!0;const Tco={toc:[]},Cco="wrapper";function xco(e){let{components:n,...t}=e;return(0,s.yg)(Cco,(0,p.A)({},Tco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xco.isMDXComponent=!0;const Aco={toc:[]},vco="wrapper";function Lco(e){let{components:n,...t}=e;return(0,s.yg)(vco,(0,p.A)({},Aco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Lco.isMDXComponent=!0;const bco={toc:[]},Nco="wrapper";function kco(e){let{components:n,...t}=e;return(0,s.yg)(Nco,(0,p.A)({},bco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}kco.isMDXComponent=!0;const zco={toc:[]},Pco="wrapper";function Ico(e){let{components:n,...t}=e;return(0,s.yg)(Pco,(0,p.A)({},zco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ico.isMDXComponent=!0;const Rco={toc:[]},Wco="wrapper";function Sco(e){let{components:n,...t}=e;return(0,s.yg)(Wco,(0,p.A)({},Rco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Sco.isMDXComponent=!0;const Bco={toc:[]},Gco="wrapper";function Eco(e){let{components:n,...t}=e;return(0,s.yg)(Gco,(0,p.A)({},Bco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Eco.isMDXComponent=!0;const Oco={toc:[]},Uco="wrapper";function Fco(e){let{components:n,...t}=e;return(0,s.yg)(Uco,(0,p.A)({},Oco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Fco.isMDXComponent=!0;const Vco={toc:[]},qco="wrapper";function jco(e){let{components:n,...t}=e;return(0,s.yg)(qco,(0,p.A)({},Vco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}jco.isMDXComponent=!0;const Hco={toc:[]},Yco="wrapper";function Qco(e){let{components:n,...t}=e;return(0,s.yg)(Yco,(0,p.A)({},Hco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Qco.isMDXComponent=!0;const $co={toc:[]},Kco="wrapper";function Jco(e){let{components:n,...t}=e;return(0,s.yg)(Kco,(0,p.A)({},$co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Jco.isMDXComponent=!0;const Zco={toc:[]},eao="wrapper";function nao(e){let{components:n,...t}=e;return(0,s.yg)(eao,(0,p.A)({},Zco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nao.isMDXComponent=!0;const tao={toc:[]},oao="wrapper";function pao(e){let{components:n,...t}=e;return(0,s.yg)(oao,(0,p.A)({},tao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}pao.isMDXComponent=!0;const rao={toc:[]},sao="wrapper";function cao(e){let{components:n,...t}=e;return(0,s.yg)(sao,(0,p.A)({},rao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}cao.isMDXComponent=!0;const aao={toc:[]},iao="wrapper";function lao(e){let{components:n,...t}=e;return(0,s.yg)(iao,(0,p.A)({},aao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lao.isMDXComponent=!0;const uao={toc:[]},mao="wrapper";function yao(e){let{components:n,...t}=e;return(0,s.yg)(mao,(0,p.A)({},uao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yao.isMDXComponent=!0;const dao={toc:[]},hao="wrapper";function gao(e){let{components:n,...t}=e;return(0,s.yg)(hao,(0,p.A)({},dao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}gao.isMDXComponent=!0;const fao={toc:[]},Dao="wrapper";function Mao(e){let{components:n,...t}=e;return(0,s.yg)(Dao,(0,p.A)({},fao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Mao.isMDXComponent=!0;const Xao={toc:[]},_ao="wrapper";function wao(e){let{components:n,...t}=e;return(0,s.yg)(_ao,(0,p.A)({},Xao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}wao.isMDXComponent=!0;const Tao={toc:[]},Cao="wrapper";function xao(e){let{components:n,...t}=e;return(0,s.yg)(Cao,(0,p.A)({},Tao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}xao.isMDXComponent=!0;const Aao={toc:[]},vao="wrapper";function Lao(e){let{components:n,...t}=e;return(0,s.yg)(vao,(0,p.A)({},Aao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Lao.isMDXComponent=!0;const bao={toc:[]},Nao="wrapper";function kao(e){let{components:n,...t}=e;return(0,s.yg)(Nao,(0,p.A)({},bao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}kao.isMDXComponent=!0;const zao={toc:[]},Pao="wrapper";function Iao(e){let{components:n,...t}=e;return(0,s.yg)(Pao,(0,p.A)({},zao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Iao.isMDXComponent=!0;const Rao={toc:[]},Wao="wrapper";function Sao(e){let{components:n,...t}=e;return(0,s.yg)(Wao,(0,p.A)({},Rao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Sao.isMDXComponent=!0;const Bao={toc:[]},Gao="wrapper";function Eao(e){let{components:n,...t}=e;return(0,s.yg)(Gao,(0,p.A)({},Bao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Eao.isMDXComponent=!0;const Oao={toc:[]},Uao="wrapper";function Fao(e){let{components:n,...t}=e;return(0,s.yg)(Uao,(0,p.A)({},Oao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Fao.isMDXComponent=!0;const Vao={toc:[]},qao="wrapper";function jao(e){let{components:n,...t}=e;return(0,s.yg)(qao,(0,p.A)({},Vao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jao.isMDXComponent=!0;const Hao={toc:[]},Yao="wrapper";function Qao(e){let{components:n,...t}=e;return(0,s.yg)(Yao,(0,p.A)({},Hao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Qao.isMDXComponent=!0;const $ao={toc:[]},Kao="wrapper";function Jao(e){let{components:n,...t}=e;return(0,s.yg)(Kao,(0,p.A)({},$ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Jao.isMDXComponent=!0;const Zao={toc:[]},eio="wrapper";function nio(e){let{components:n,...t}=e;return(0,s.yg)(eio,(0,p.A)({},Zao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}nio.isMDXComponent=!0;const tio={toc:[]},oio="wrapper";function pio(e){let{components:n,...t}=e;return(0,s.yg)(oio,(0,p.A)({},tio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}pio.isMDXComponent=!0;const rio={toc:[]},sio="wrapper";function cio(e){let{components:n,...t}=e;return(0,s.yg)(sio,(0,p.A)({},rio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}cio.isMDXComponent=!0;const aio={toc:[]},iio="wrapper";function lio(e){let{components:n,...t}=e;return(0,s.yg)(iio,(0,p.A)({},aio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}lio.isMDXComponent=!0;const uio={toc:[]},mio="wrapper";function yio(e){let{components:n,...t}=e;return(0,s.yg)(mio,(0,p.A)({},uio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}yio.isMDXComponent=!0;const dio={toc:[]},hio="wrapper";function gio(e){let{components:n,...t}=e;return(0,s.yg)(hio,(0,p.A)({},dio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}gio.isMDXComponent=!0;const fio={toc:[]},Dio="wrapper";function Mio(e){let{components:n,...t}=e;return(0,s.yg)(Dio,(0,p.A)({},fio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Mio.isMDXComponent=!0;const Xio={toc:[]},_io="wrapper";function wio(e){let{components:n,...t}=e;return(0,s.yg)(_io,(0,p.A)({},Xio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}wio.isMDXComponent=!0;const Tio={toc:[]},Cio="wrapper";function xio(e){let{components:n,...t}=e;return(0,s.yg)(Cio,(0,p.A)({},Tio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}xio.isMDXComponent=!0;const Aio={toc:[]},vio="wrapper";function Lio(e){let{components:n,...t}=e;return(0,s.yg)(vio,(0,p.A)({},Aio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Lio.isMDXComponent=!0;const bio={toc:[]},Nio="wrapper";function kio(e){let{components:n,...t}=e;return(0,s.yg)(Nio,(0,p.A)({},bio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}kio.isMDXComponent=!0;const zio={toc:[]},Pio="wrapper";function Iio(e){let{components:n,...t}=e;return(0,s.yg)(Pio,(0,p.A)({},zio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Iio.isMDXComponent=!0;const Rio={toc:[]},Wio="wrapper";function Sio(e){let{components:n,...t}=e;return(0,s.yg)(Wio,(0,p.A)({},Rio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Sio.isMDXComponent=!0;const Bio={toc:[]},Gio="wrapper";function Eio(e){let{components:n,...t}=e;return(0,s.yg)(Gio,(0,p.A)({},Bio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Eio.isMDXComponent=!0;const Oio={toc:[]},Uio="wrapper";function Fio(e){let{components:n,...t}=e;return(0,s.yg)(Uio,(0,p.A)({},Oio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Fio.isMDXComponent=!0;const Vio={toc:[]},qio="wrapper";function jio(e){let{components:n,...t}=e;return(0,s.yg)(qio,(0,p.A)({},Vio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}jio.isMDXComponent=!0;const Hio={toc:[]},Yio="wrapper";function Qio(e){let{components:n,...t}=e;return(0,s.yg)(Yio,(0,p.A)({},Hio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Qio.isMDXComponent=!0;const $io={toc:[]},Kio="wrapper";function Jio(e){let{components:n,...t}=e;return(0,s.yg)(Kio,(0,p.A)({},$io,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Jio.isMDXComponent=!0;const Zio={toc:[]},elo="wrapper";function nlo(e){let{components:n,...t}=e;return(0,s.yg)(elo,(0,p.A)({},Zio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}nlo.isMDXComponent=!0;const tlo={toc:[]},olo="wrapper";function plo(e){let{components:n,...t}=e;return(0,s.yg)(olo,(0,p.A)({},tlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}plo.isMDXComponent=!0;const rlo={toc:[]},slo="wrapper";function clo(e){let{components:n,...t}=e;return(0,s.yg)(slo,(0,p.A)({},rlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}clo.isMDXComponent=!0;const alo={toc:[]},ilo="wrapper";function llo(e){let{components:n,...t}=e;return(0,s.yg)(ilo,(0,p.A)({},alo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}llo.isMDXComponent=!0;const ulo={toc:[]},mlo="wrapper";function ylo(e){let{components:n,...t}=e;return(0,s.yg)(mlo,(0,p.A)({},ulo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}ylo.isMDXComponent=!0;const dlo={toc:[]},hlo="wrapper";function glo(e){let{components:n,...t}=e;return(0,s.yg)(hlo,(0,p.A)({},dlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}glo.isMDXComponent=!0;const flo={toc:[]},Dlo="wrapper";function Mlo(e){let{components:n,...t}=e;return(0,s.yg)(Dlo,(0,p.A)({},flo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Mlo.isMDXComponent=!0;const Xlo={toc:[]},_lo="wrapper";function wlo(e){let{components:n,...t}=e;return(0,s.yg)(_lo,(0,p.A)({},Xlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wlo.isMDXComponent=!0;const Tlo={toc:[]},Clo="wrapper";function xlo(e){let{components:n,...t}=e;return(0,s.yg)(Clo,(0,p.A)({},Tlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}xlo.isMDXComponent=!0;const Alo={toc:[]},vlo="wrapper";function Llo(e){let{components:n,...t}=e;return(0,s.yg)(vlo,(0,p.A)({},Alo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Llo.isMDXComponent=!0;const blo={toc:[]},Nlo="wrapper";function klo(e){let{components:n,...t}=e;return(0,s.yg)(Nlo,(0,p.A)({},blo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}klo.isMDXComponent=!0;const zlo={toc:[]},Plo="wrapper";function Ilo(e){let{components:n,...t}=e;return(0,s.yg)(Plo,(0,p.A)({},zlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ilo.isMDXComponent=!0;const Rlo={toc:[]},Wlo="wrapper";function Slo(e){let{components:n,...t}=e;return(0,s.yg)(Wlo,(0,p.A)({},Rlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Slo.isMDXComponent=!0;const Blo={toc:[]},Glo="wrapper";function Elo(e){let{components:n,...t}=e;return(0,s.yg)(Glo,(0,p.A)({},Blo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Elo.isMDXComponent=!0;const Olo={toc:[]},Ulo="wrapper";function Flo(e){let{components:n,...t}=e;return(0,s.yg)(Ulo,(0,p.A)({},Olo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Flo.isMDXComponent=!0;const Vlo={toc:[]},qlo="wrapper";function jlo(e){let{components:n,...t}=e;return(0,s.yg)(qlo,(0,p.A)({},Vlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}jlo.isMDXComponent=!0;const Hlo={toc:[]},Ylo="wrapper";function Qlo(e){let{components:n,...t}=e;return(0,s.yg)(Ylo,(0,p.A)({},Hlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Qlo.isMDXComponent=!0;const $lo={toc:[]},Klo="wrapper";function Jlo(e){let{components:n,...t}=e;return(0,s.yg)(Klo,(0,p.A)({},$lo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Jlo.isMDXComponent=!0;const Zlo={toc:[]},euo="wrapper";function nuo(e){let{components:n,...t}=e;return(0,s.yg)(euo,(0,p.A)({},Zlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}nuo.isMDXComponent=!0;const tuo={toc:[]},ouo="wrapper";function puo(e){let{components:n,...t}=e;return(0,s.yg)(ouo,(0,p.A)({},tuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}puo.isMDXComponent=!0;const ruo={toc:[]},suo="wrapper";function cuo(e){let{components:n,...t}=e;return(0,s.yg)(suo,(0,p.A)({},ruo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}cuo.isMDXComponent=!0;const auo={toc:[]},iuo="wrapper";function luo(e){let{components:n,...t}=e;return(0,s.yg)(iuo,(0,p.A)({},auo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}luo.isMDXComponent=!0;const uuo={toc:[]},muo="wrapper";function yuo(e){let{components:n,...t}=e;return(0,s.yg)(muo,(0,p.A)({},uuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}yuo.isMDXComponent=!0;const duo={toc:[]},huo="wrapper";function guo(e){let{components:n,...t}=e;return(0,s.yg)(huo,(0,p.A)({},duo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}guo.isMDXComponent=!0;const fuo={toc:[]},Duo="wrapper";function Muo(e){let{components:n,...t}=e;return(0,s.yg)(Duo,(0,p.A)({},fuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Muo.isMDXComponent=!0;const Xuo={toc:[]},_uo="wrapper";function wuo(e){let{components:n,...t}=e;return(0,s.yg)(_uo,(0,p.A)({},Xuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}wuo.isMDXComponent=!0;const Tuo={toc:[]},Cuo="wrapper";function xuo(e){let{components:n,...t}=e;return(0,s.yg)(Cuo,(0,p.A)({},Tuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}xuo.isMDXComponent=!0;const Auo={toc:[]},vuo="wrapper";function Luo(e){let{components:n,...t}=e;return(0,s.yg)(vuo,(0,p.A)({},Auo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Luo.isMDXComponent=!0;const buo={toc:[]},Nuo="wrapper";function kuo(e){let{components:n,...t}=e;return(0,s.yg)(Nuo,(0,p.A)({},buo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}kuo.isMDXComponent=!0;const zuo={toc:[]},Puo="wrapper";function Iuo(e){let{components:n,...t}=e;return(0,s.yg)(Puo,(0,p.A)({},zuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Iuo.isMDXComponent=!0;const Ruo={toc:[]},Wuo="wrapper";function Suo(e){let{components:n,...t}=e;return(0,s.yg)(Wuo,(0,p.A)({},Ruo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Suo.isMDXComponent=!0;const Buo={toc:[]},Guo="wrapper";function Euo(e){let{components:n,...t}=e;return(0,s.yg)(Guo,(0,p.A)({},Buo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Euo.isMDXComponent=!0;const Ouo={toc:[]},Uuo="wrapper";function Fuo(e){let{components:n,...t}=e;return(0,s.yg)(Uuo,(0,p.A)({},Ouo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Fuo.isMDXComponent=!0;const Vuo={toc:[]},quo="wrapper";function juo(e){let{components:n,...t}=e;return(0,s.yg)(quo,(0,p.A)({},Vuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}juo.isMDXComponent=!0;const Huo={toc:[]},Yuo="wrapper";function Quo(e){let{components:n,...t}=e;return(0,s.yg)(Yuo,(0,p.A)({},Huo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Quo.isMDXComponent=!0;const $uo={toc:[]},Kuo="wrapper";function Juo(e){let{components:n,...t}=e;return(0,s.yg)(Kuo,(0,p.A)({},$uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Juo.isMDXComponent=!0;const Zuo={toc:[]},emo="wrapper";function nmo(e){let{components:n,...t}=e;return(0,s.yg)(emo,(0,p.A)({},Zuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}nmo.isMDXComponent=!0;const tmo={toc:[]},omo="wrapper";function pmo(e){let{components:n,...t}=e;return(0,s.yg)(omo,(0,p.A)({},tmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}pmo.isMDXComponent=!0;const rmo={toc:[]},smo="wrapper";function cmo(e){let{components:n,...t}=e;return(0,s.yg)(smo,(0,p.A)({},rmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cmo.isMDXComponent=!0;const amo={toc:[]},imo="wrapper";function lmo(e){let{components:n,...t}=e;return(0,s.yg)(imo,(0,p.A)({},amo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}lmo.isMDXComponent=!0;const umo={toc:[]},mmo="wrapper";function ymo(e){let{components:n,...t}=e;return(0,s.yg)(mmo,(0,p.A)({},umo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}ymo.isMDXComponent=!0;const dmo={toc:[]},hmo="wrapper";function gmo(e){let{components:n,...t}=e;return(0,s.yg)(hmo,(0,p.A)({},dmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}gmo.isMDXComponent=!0;const fmo={toc:[]},Dmo="wrapper";function Mmo(e){let{components:n,...t}=e;return(0,s.yg)(Dmo,(0,p.A)({},fmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Mmo.isMDXComponent=!0;const Xmo={toc:[]},_mo="wrapper";function wmo(e){let{components:n,...t}=e;return(0,s.yg)(_mo,(0,p.A)({},Xmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}wmo.isMDXComponent=!0;const Tmo={toc:[]},Cmo="wrapper";function xmo(e){let{components:n,...t}=e;return(0,s.yg)(Cmo,(0,p.A)({},Tmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}xmo.isMDXComponent=!0;const Amo={toc:[]},vmo="wrapper";function Lmo(e){let{components:n,...t}=e;return(0,s.yg)(vmo,(0,p.A)({},Amo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Lmo.isMDXComponent=!0;const bmo={toc:[]},Nmo="wrapper";function kmo(e){let{components:n,...t}=e;return(0,s.yg)(Nmo,(0,p.A)({},bmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}kmo.isMDXComponent=!0;const zmo={toc:[]},Pmo="wrapper";function Imo(e){let{components:n,...t}=e;return(0,s.yg)(Pmo,(0,p.A)({},zmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Imo.isMDXComponent=!0;const Rmo={toc:[]},Wmo="wrapper";function Smo(e){let{components:n,...t}=e;return(0,s.yg)(Wmo,(0,p.A)({},Rmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Smo.isMDXComponent=!0;const Bmo={toc:[]},Gmo="wrapper";function Emo(e){let{components:n,...t}=e;return(0,s.yg)(Gmo,(0,p.A)({},Bmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Emo.isMDXComponent=!0;const Omo={toc:[]},Umo="wrapper";function Fmo(e){let{components:n,...t}=e;return(0,s.yg)(Umo,(0,p.A)({},Omo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Fmo.isMDXComponent=!0;const Vmo={toc:[]},qmo="wrapper";function jmo(e){let{components:n,...t}=e;return(0,s.yg)(qmo,(0,p.A)({},Vmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jmo.isMDXComponent=!0;const Hmo={toc:[]},Ymo="wrapper";function Qmo(e){let{components:n,...t}=e;return(0,s.yg)(Ymo,(0,p.A)({},Hmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Qmo.isMDXComponent=!0;const $mo={toc:[]},Kmo="wrapper";function Jmo(e){let{components:n,...t}=e;return(0,s.yg)(Kmo,(0,p.A)({},$mo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Jmo.isMDXComponent=!0;const Zmo={toc:[]},eyo="wrapper";function nyo(e){let{components:n,...t}=e;return(0,s.yg)(eyo,(0,p.A)({},Zmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}nyo.isMDXComponent=!0;const tyo={toc:[]},oyo="wrapper";function pyo(e){let{components:n,...t}=e;return(0,s.yg)(oyo,(0,p.A)({},tyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}pyo.isMDXComponent=!0;const ryo={toc:[]},syo="wrapper";function cyo(e){let{components:n,...t}=e;return(0,s.yg)(syo,(0,p.A)({},ryo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}cyo.isMDXComponent=!0;const ayo={toc:[]},iyo="wrapper";function lyo(e){let{components:n,...t}=e;return(0,s.yg)(iyo,(0,p.A)({},ayo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}lyo.isMDXComponent=!0;const uyo={toc:[]},myo="wrapper";function yyo(e){let{components:n,...t}=e;return(0,s.yg)(myo,(0,p.A)({},uyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}yyo.isMDXComponent=!0;const dyo={toc:[]},hyo="wrapper";function gyo(e){let{components:n,...t}=e;return(0,s.yg)(hyo,(0,p.A)({},dyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gyo.isMDXComponent=!0;const fyo={toc:[]},Dyo="wrapper";function Myo(e){let{components:n,...t}=e;return(0,s.yg)(Dyo,(0,p.A)({},fyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Myo.isMDXComponent=!0;const Xyo={toc:[]},_yo="wrapper";function wyo(e){let{components:n,...t}=e;return(0,s.yg)(_yo,(0,p.A)({},Xyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wyo.isMDXComponent=!0;const Tyo={toc:[]},Cyo="wrapper";function xyo(e){let{components:n,...t}=e;return(0,s.yg)(Cyo,(0,p.A)({},Tyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}xyo.isMDXComponent=!0;const Ayo={toc:[]},vyo="wrapper";function Lyo(e){let{components:n,...t}=e;return(0,s.yg)(vyo,(0,p.A)({},Ayo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Lyo.isMDXComponent=!0;const byo={toc:[]},Nyo="wrapper";function kyo(e){let{components:n,...t}=e;return(0,s.yg)(Nyo,(0,p.A)({},byo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}kyo.isMDXComponent=!0;const zyo={toc:[]},Pyo="wrapper";function Iyo(e){let{components:n,...t}=e;return(0,s.yg)(Pyo,(0,p.A)({},zyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Iyo.isMDXComponent=!0;const Ryo={toc:[]},Wyo="wrapper";function Syo(e){let{components:n,...t}=e;return(0,s.yg)(Wyo,(0,p.A)({},Ryo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Syo.isMDXComponent=!0;const Byo={toc:[]},Gyo="wrapper";function Eyo(e){let{components:n,...t}=e;return(0,s.yg)(Gyo,(0,p.A)({},Byo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Eyo.isMDXComponent=!0;const Oyo={toc:[]},Uyo="wrapper";function Fyo(e){let{components:n,...t}=e;return(0,s.yg)(Uyo,(0,p.A)({},Oyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Fyo.isMDXComponent=!0;const Vyo={toc:[]},qyo="wrapper";function jyo(e){let{components:n,...t}=e;return(0,s.yg)(qyo,(0,p.A)({},Vyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}jyo.isMDXComponent=!0;const Hyo={toc:[]},Yyo="wrapper";function Qyo(e){let{components:n,...t}=e;return(0,s.yg)(Yyo,(0,p.A)({},Hyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Qyo.isMDXComponent=!0;const $yo={toc:[]},Kyo="wrapper";function Jyo(e){let{components:n,...t}=e;return(0,s.yg)(Kyo,(0,p.A)({},$yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Jyo.isMDXComponent=!0;const Zyo={toc:[]},edo="wrapper";function ndo(e){let{components:n,...t}=e;return(0,s.yg)(edo,(0,p.A)({},Zyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}ndo.isMDXComponent=!0;const tdo={toc:[]},odo="wrapper";function pdo(e){let{components:n,...t}=e;return(0,s.yg)(odo,(0,p.A)({},tdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}pdo.isMDXComponent=!0;const rdo={toc:[]},sdo="wrapper";function cdo(e){let{components:n,...t}=e;return(0,s.yg)(sdo,(0,p.A)({},rdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}cdo.isMDXComponent=!0;const ado={toc:[]},ido="wrapper";function ldo(e){let{components:n,...t}=e;return(0,s.yg)(ido,(0,p.A)({},ado,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}ldo.isMDXComponent=!0;const udo={toc:[]},mdo="wrapper";function ydo(e){let{components:n,...t}=e;return(0,s.yg)(mdo,(0,p.A)({},udo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}ydo.isMDXComponent=!0;const ddo={toc:[]},hdo="wrapper";function gdo(e){let{components:n,...t}=e;return(0,s.yg)(hdo,(0,p.A)({},ddo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}gdo.isMDXComponent=!0;const fdo={toc:[]},Ddo="wrapper";function Mdo(e){let{components:n,...t}=e;return(0,s.yg)(Ddo,(0,p.A)({},fdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Mdo.isMDXComponent=!0;const Xdo={toc:[]},_do="wrapper";function wdo(e){let{components:n,...t}=e;return(0,s.yg)(_do,(0,p.A)({},Xdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wdo.isMDXComponent=!0;const Tdo={toc:[]},Cdo="wrapper";function xdo(e){let{components:n,...t}=e;return(0,s.yg)(Cdo,(0,p.A)({},Tdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}xdo.isMDXComponent=!0;const Ado={toc:[]},vdo="wrapper";function Ldo(e){let{components:n,...t}=e;return(0,s.yg)(vdo,(0,p.A)({},Ado,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Ldo.isMDXComponent=!0;const bdo={toc:[]},Ndo="wrapper";function kdo(e){let{components:n,...t}=e;return(0,s.yg)(Ndo,(0,p.A)({},bdo,t,{components:n,mdxType:"MDXLayout"}))}kdo.isMDXComponent=!0;const zdo={toc:[]},Pdo="wrapper";function Ido(e){let{components:n,...t}=e;return(0,s.yg)(Pdo,(0,p.A)({},zdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ido.isMDXComponent=!0;const Rdo={toc:[]},Wdo="wrapper";function Sdo(e){let{components:n,...t}=e;return(0,s.yg)(Wdo,(0,p.A)({},Rdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Sdo.isMDXComponent=!0;const Bdo={toc:[]},Gdo="wrapper";function Edo(e){let{components:n,...t}=e;return(0,s.yg)(Gdo,(0,p.A)({},Bdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Edo.isMDXComponent=!0;const Odo={toc:[]},Udo="wrapper";function Fdo(e){let{components:n,...t}=e;return(0,s.yg)(Udo,(0,p.A)({},Odo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Fdo.isMDXComponent=!0;const Vdo={toc:[]},qdo="wrapper";function jdo(e){let{components:n,...t}=e;return(0,s.yg)(qdo,(0,p.A)({},Vdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}jdo.isMDXComponent=!0;const Hdo={toc:[]},Ydo="wrapper";function Qdo(e){let{components:n,...t}=e;return(0,s.yg)(Ydo,(0,p.A)({},Hdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Qdo.isMDXComponent=!0;const $do={toc:[]},Kdo="wrapper";function Jdo(e){let{components:n,...t}=e;return(0,s.yg)(Kdo,(0,p.A)({},$do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Jdo.isMDXComponent=!0;const Zdo={toc:[]},eho="wrapper";function nho(e){let{components:n,...t}=e;return(0,s.yg)(eho,(0,p.A)({},Zdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}nho.isMDXComponent=!0;const tho={toc:[]},oho="wrapper";function pho(e){let{components:n,...t}=e;return(0,s.yg)(oho,(0,p.A)({},tho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}pho.isMDXComponent=!0;const rho={toc:[]},sho="wrapper";function cho(e){let{components:n,...t}=e;return(0,s.yg)(sho,(0,p.A)({},rho,t,{components:n,mdxType:"MDXLayout"}))}cho.isMDXComponent=!0;const aho={toc:[]},iho="wrapper";function lho(e){let{components:n,...t}=e;return(0,s.yg)(iho,(0,p.A)({},aho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}lho.isMDXComponent=!0;const uho={toc:[]},mho="wrapper";function yho(e){let{components:n,...t}=e;return(0,s.yg)(mho,(0,p.A)({},uho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}yho.isMDXComponent=!0;const dho={toc:[]},hho="wrapper";function gho(e){let{components:n,...t}=e;return(0,s.yg)(hho,(0,p.A)({},dho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gho.isMDXComponent=!0;const fho={toc:[]},Dho="wrapper";function Mho(e){let{components:n,...t}=e;return(0,s.yg)(Dho,(0,p.A)({},fho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Mho.isMDXComponent=!0;const Xho={toc:[]},_ho="wrapper";function who(e){let{components:n,...t}=e;return(0,s.yg)(_ho,(0,p.A)({},Xho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}who.isMDXComponent=!0;const Tho={toc:[]},Cho="wrapper";function xho(e){let{components:n,...t}=e;return(0,s.yg)(Cho,(0,p.A)({},Tho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}xho.isMDXComponent=!0;const Aho={toc:[]},vho="wrapper";function Lho(e){let{components:n,...t}=e;return(0,s.yg)(vho,(0,p.A)({},Aho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Lho.isMDXComponent=!0;const bho={toc:[]},Nho="wrapper";function kho(e){let{components:n,...t}=e;return(0,s.yg)(Nho,(0,p.A)({},bho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}kho.isMDXComponent=!0;const zho={toc:[]},Pho="wrapper";function Iho(e){let{components:n,...t}=e;return(0,s.yg)(Pho,(0,p.A)({},zho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Iho.isMDXComponent=!0;const Rho={toc:[]},Who="wrapper";function Sho(e){let{components:n,...t}=e;return(0,s.yg)(Who,(0,p.A)({},Rho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Sho.isMDXComponent=!0;const Bho={toc:[]},Gho="wrapper";function Eho(e){let{components:n,...t}=e;return(0,s.yg)(Gho,(0,p.A)({},Bho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Eho.isMDXComponent=!0;const Oho={toc:[]},Uho="wrapper";function Fho(e){let{components:n,...t}=e;return(0,s.yg)(Uho,(0,p.A)({},Oho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Fho.isMDXComponent=!0;const Vho={toc:[]},qho="wrapper";function jho(e){let{components:n,...t}=e;return(0,s.yg)(qho,(0,p.A)({},Vho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}jho.isMDXComponent=!0;const Hho={toc:[]},Yho="wrapper";function Qho(e){let{components:n,...t}=e;return(0,s.yg)(Yho,(0,p.A)({},Hho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qho.isMDXComponent=!0;const $ho={toc:[]},Kho="wrapper";function Jho(e){let{components:n,...t}=e;return(0,s.yg)(Kho,(0,p.A)({},$ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Jho.isMDXComponent=!0;const Zho={toc:[]},ego="wrapper";function ngo(e){let{components:n,...t}=e;return(0,s.yg)(ego,(0,p.A)({},Zho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}ngo.isMDXComponent=!0;const tgo={toc:[]},ogo="wrapper";function pgo(e){let{components:n,...t}=e;return(0,s.yg)(ogo,(0,p.A)({},tgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pgo.isMDXComponent=!0;const rgo={toc:[]},sgo="wrapper";function cgo(e){let{components:n,...t}=e;return(0,s.yg)(sgo,(0,p.A)({},rgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}cgo.isMDXComponent=!0;const ago={toc:[]},igo="wrapper";function lgo(e){let{components:n,...t}=e;return(0,s.yg)(igo,(0,p.A)({},ago,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lgo.isMDXComponent=!0;const ugo={toc:[]},mgo="wrapper";function ygo(e){let{components:n,...t}=e;return(0,s.yg)(mgo,(0,p.A)({},ugo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}ygo.isMDXComponent=!0;const dgo={toc:[]},hgo="wrapper";function ggo(e){let{components:n,...t}=e;return(0,s.yg)(hgo,(0,p.A)({},dgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}ggo.isMDXComponent=!0;const fgo={toc:[]},Dgo="wrapper";function Mgo(e){let{components:n,...t}=e;return(0,s.yg)(Dgo,(0,p.A)({},fgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Mgo.isMDXComponent=!0;const Xgo={toc:[]},_go="wrapper";function wgo(e){let{components:n,...t}=e;return(0,s.yg)(_go,(0,p.A)({},Xgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}wgo.isMDXComponent=!0;const Tgo={toc:[]},Cgo="wrapper";function xgo(e){let{components:n,...t}=e;return(0,s.yg)(Cgo,(0,p.A)({},Tgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}xgo.isMDXComponent=!0;const Ago={toc:[]},vgo="wrapper";function Lgo(e){let{components:n,...t}=e;return(0,s.yg)(vgo,(0,p.A)({},Ago,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Lgo.isMDXComponent=!0;const bgo={toc:[]},Ngo="wrapper";function kgo(e){let{components:n,...t}=e;return(0,s.yg)(Ngo,(0,p.A)({},bgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}kgo.isMDXComponent=!0;const zgo={toc:[]},Pgo="wrapper";function Igo(e){let{components:n,...t}=e;return(0,s.yg)(Pgo,(0,p.A)({},zgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Igo.isMDXComponent=!0;const Rgo={toc:[]},Wgo="wrapper";function Sgo(e){let{components:n,...t}=e;return(0,s.yg)(Wgo,(0,p.A)({},Rgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Sgo.isMDXComponent=!0;const Bgo={toc:[]},Ggo="wrapper";function Ego(e){let{components:n,...t}=e;return(0,s.yg)(Ggo,(0,p.A)({},Bgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Ego.isMDXComponent=!0;const Ogo={toc:[]},Ugo="wrapper";function Fgo(e){let{components:n,...t}=e;return(0,s.yg)(Ugo,(0,p.A)({},Ogo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Fgo.isMDXComponent=!0;const Vgo={toc:[]},qgo="wrapper";function jgo(e){let{components:n,...t}=e;return(0,s.yg)(qgo,(0,p.A)({},Vgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}jgo.isMDXComponent=!0;const Hgo={toc:[]},Ygo="wrapper";function Qgo(e){let{components:n,...t}=e;return(0,s.yg)(Ygo,(0,p.A)({},Hgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Qgo.isMDXComponent=!0;const $go={toc:[]},Kgo="wrapper";function Jgo(e){let{components:n,...t}=e;return(0,s.yg)(Kgo,(0,p.A)({},$go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Jgo.isMDXComponent=!0;const Zgo={toc:[]},efo="wrapper";function nfo(e){let{components:n,...t}=e;return(0,s.yg)(efo,(0,p.A)({},Zgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}nfo.isMDXComponent=!0;const tfo={toc:[]},ofo="wrapper";function pfo(e){let{components:n,...t}=e;return(0,s.yg)(ofo,(0,p.A)({},tfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}pfo.isMDXComponent=!0;const rfo={toc:[]},sfo="wrapper";function cfo(e){let{components:n,...t}=e;return(0,s.yg)(sfo,(0,p.A)({},rfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}cfo.isMDXComponent=!0;const afo={toc:[]},ifo="wrapper";function lfo(e){let{components:n,...t}=e;return(0,s.yg)(ifo,(0,p.A)({},afo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}lfo.isMDXComponent=!0;const ufo={toc:[]},mfo="wrapper";function yfo(e){let{components:n,...t}=e;return(0,s.yg)(mfo,(0,p.A)({},ufo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}yfo.isMDXComponent=!0;const dfo={toc:[]},hfo="wrapper";function gfo(e){let{components:n,...t}=e;return(0,s.yg)(hfo,(0,p.A)({},dfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}gfo.isMDXComponent=!0;const ffo={toc:[]},Dfo="wrapper";function Mfo(e){let{components:n,...t}=e;return(0,s.yg)(Dfo,(0,p.A)({},ffo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Mfo.isMDXComponent=!0;const Xfo={toc:[]},_fo="wrapper";function wfo(e){let{components:n,...t}=e;return(0,s.yg)(_fo,(0,p.A)({},Xfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wfo.isMDXComponent=!0;const Tfo={toc:[]},Cfo="wrapper";function xfo(e){let{components:n,...t}=e;return(0,s.yg)(Cfo,(0,p.A)({},Tfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}xfo.isMDXComponent=!0;const Afo={toc:[]},vfo="wrapper";function Lfo(e){let{components:n,...t}=e;return(0,s.yg)(vfo,(0,p.A)({},Afo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Lfo.isMDXComponent=!0;const bfo={toc:[]},Nfo="wrapper";function kfo(e){let{components:n,...t}=e;return(0,s.yg)(Nfo,(0,p.A)({},bfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}kfo.isMDXComponent=!0;const zfo={toc:[]},Pfo="wrapper";function Ifo(e){let{components:n,...t}=e;return(0,s.yg)(Pfo,(0,p.A)({},zfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Ifo.isMDXComponent=!0;const Rfo={toc:[]},Wfo="wrapper";function Sfo(e){let{components:n,...t}=e;return(0,s.yg)(Wfo,(0,p.A)({},Rfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Sfo.isMDXComponent=!0;const Bfo={toc:[]},Gfo="wrapper";function Efo(e){let{components:n,...t}=e;return(0,s.yg)(Gfo,(0,p.A)({},Bfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Efo.isMDXComponent=!0;const Ofo={toc:[]},Ufo="wrapper";function Ffo(e){let{components:n,...t}=e;return(0,s.yg)(Ufo,(0,p.A)({},Ofo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Ffo.isMDXComponent=!0;const Vfo={toc:[]},qfo="wrapper";function jfo(e){let{components:n,...t}=e;return(0,s.yg)(qfo,(0,p.A)({},Vfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jfo.isMDXComponent=!0;const Hfo={toc:[]},Yfo="wrapper";function Qfo(e){let{components:n,...t}=e;return(0,s.yg)(Yfo,(0,p.A)({},Hfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Qfo.isMDXComponent=!0;const $fo={toc:[]},Kfo="wrapper";function Jfo(e){let{components:n,...t}=e;return(0,s.yg)(Kfo,(0,p.A)({},$fo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Jfo.isMDXComponent=!0;const Zfo={toc:[]},eDo="wrapper";function nDo(e){let{components:n,...t}=e;return(0,s.yg)(eDo,(0,p.A)({},Zfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}nDo.isMDXComponent=!0;const tDo={toc:[]},oDo="wrapper";function pDo(e){let{components:n,...t}=e;return(0,s.yg)(oDo,(0,p.A)({},tDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}pDo.isMDXComponent=!0;const rDo={toc:[]},sDo="wrapper";function cDo(e){let{components:n,...t}=e;return(0,s.yg)(sDo,(0,p.A)({},rDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cDo.isMDXComponent=!0;const aDo={toc:[]},iDo="wrapper";function lDo(e){let{components:n,...t}=e;return(0,s.yg)(iDo,(0,p.A)({},aDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}lDo.isMDXComponent=!0;const uDo={toc:[]},mDo="wrapper";function yDo(e){let{components:n,...t}=e;return(0,s.yg)(mDo,(0,p.A)({},uDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yDo.isMDXComponent=!0;const dDo={toc:[]},hDo="wrapper";function gDo(e){let{components:n,...t}=e;return(0,s.yg)(hDo,(0,p.A)({},dDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}gDo.isMDXComponent=!0;const fDo={toc:[]},DDo="wrapper";function MDo(e){let{components:n,...t}=e;return(0,s.yg)(DDo,(0,p.A)({},fDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}MDo.isMDXComponent=!0;const XDo={toc:[]},_Do="wrapper";function wDo(e){let{components:n,...t}=e;return(0,s.yg)(_Do,(0,p.A)({},XDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wDo.isMDXComponent=!0;const TDo={toc:[]},CDo="wrapper";function xDo(e){let{components:n,...t}=e;return(0,s.yg)(CDo,(0,p.A)({},TDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xDo.isMDXComponent=!0;const ADo={toc:[]},vDo="wrapper";function LDo(e){let{components:n,...t}=e;return(0,s.yg)(vDo,(0,p.A)({},ADo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}LDo.isMDXComponent=!0;const bDo={toc:[]},NDo="wrapper";function kDo(e){let{components:n,...t}=e;return(0,s.yg)(NDo,(0,p.A)({},bDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kDo.isMDXComponent=!0;const zDo={toc:[]},PDo="wrapper";function IDo(e){let{components:n,...t}=e;return(0,s.yg)(PDo,(0,p.A)({},zDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}IDo.isMDXComponent=!0;const RDo={toc:[]},WDo="wrapper";function SDo(e){let{components:n,...t}=e;return(0,s.yg)(WDo,(0,p.A)({},RDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}SDo.isMDXComponent=!0;const BDo={toc:[]},GDo="wrapper";function EDo(e){let{components:n,...t}=e;return(0,s.yg)(GDo,(0,p.A)({},BDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}EDo.isMDXComponent=!0;const ODo={toc:[]},UDo="wrapper";function FDo(e){let{components:n,...t}=e;return(0,s.yg)(UDo,(0,p.A)({},ODo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}FDo.isMDXComponent=!0;const VDo={toc:[]},qDo="wrapper";function jDo(e){let{components:n,...t}=e;return(0,s.yg)(qDo,(0,p.A)({},VDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}jDo.isMDXComponent=!0;const HDo={toc:[]},YDo="wrapper";function QDo(e){let{components:n,...t}=e;return(0,s.yg)(YDo,(0,p.A)({},HDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}QDo.isMDXComponent=!0;const $Do={toc:[]},KDo="wrapper";function JDo(e){let{components:n,...t}=e;return(0,s.yg)(KDo,(0,p.A)({},$Do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}JDo.isMDXComponent=!0;const ZDo={toc:[]},eMo="wrapper";function nMo(e){let{components:n,...t}=e;return(0,s.yg)(eMo,(0,p.A)({},ZDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nMo.isMDXComponent=!0;const tMo={toc:[]},oMo="wrapper";function pMo(e){let{components:n,...t}=e;return(0,s.yg)(oMo,(0,p.A)({},tMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}pMo.isMDXComponent=!0;const rMo={toc:[]},sMo="wrapper";function cMo(e){let{components:n,...t}=e;return(0,s.yg)(sMo,(0,p.A)({},rMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}cMo.isMDXComponent=!0;const aMo={toc:[]},iMo="wrapper";function lMo(e){let{components:n,...t}=e;return(0,s.yg)(iMo,(0,p.A)({},aMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lMo.isMDXComponent=!0;const uMo={toc:[]},mMo="wrapper";function yMo(e){let{components:n,...t}=e;return(0,s.yg)(mMo,(0,p.A)({},uMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}yMo.isMDXComponent=!0;const dMo={toc:[]},hMo="wrapper";function gMo(e){let{components:n,...t}=e;return(0,s.yg)(hMo,(0,p.A)({},dMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}gMo.isMDXComponent=!0;const fMo={toc:[]},DMo="wrapper";function MMo(e){let{components:n,...t}=e;return(0,s.yg)(DMo,(0,p.A)({},fMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}MMo.isMDXComponent=!0;const XMo={toc:[]},_Mo="wrapper";function wMo(e){let{components:n,...t}=e;return(0,s.yg)(_Mo,(0,p.A)({},XMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wMo.isMDXComponent=!0;const TMo={toc:[]},CMo="wrapper";function xMo(e){let{components:n,...t}=e;return(0,s.yg)(CMo,(0,p.A)({},TMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}xMo.isMDXComponent=!0;const AMo={toc:[]},vMo="wrapper";function LMo(e){let{components:n,...t}=e;return(0,s.yg)(vMo,(0,p.A)({},AMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}LMo.isMDXComponent=!0;const bMo={toc:[]},NMo="wrapper";function kMo(e){let{components:n,...t}=e;return(0,s.yg)(NMo,(0,p.A)({},bMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}kMo.isMDXComponent=!0;const zMo={toc:[]},PMo="wrapper";function IMo(e){let{components:n,...t}=e;return(0,s.yg)(PMo,(0,p.A)({},zMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}IMo.isMDXComponent=!0;const RMo={toc:[]},WMo="wrapper";function SMo(e){let{components:n,...t}=e;return(0,s.yg)(WMo,(0,p.A)({},RMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}SMo.isMDXComponent=!0;const BMo={toc:[]},GMo="wrapper";function EMo(e){let{components:n,...t}=e;return(0,s.yg)(GMo,(0,p.A)({},BMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}EMo.isMDXComponent=!0;const OMo={toc:[]},UMo="wrapper";function FMo(e){let{components:n,...t}=e;return(0,s.yg)(UMo,(0,p.A)({},OMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}FMo.isMDXComponent=!0;const VMo={toc:[]},qMo="wrapper";function jMo(e){let{components:n,...t}=e;return(0,s.yg)(qMo,(0,p.A)({},VMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jMo.isMDXComponent=!0;const HMo={toc:[]},YMo="wrapper";function QMo(e){let{components:n,...t}=e;return(0,s.yg)(YMo,(0,p.A)({},HMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}QMo.isMDXComponent=!0;const $Mo={toc:[]},KMo="wrapper";function JMo(e){let{components:n,...t}=e;return(0,s.yg)(KMo,(0,p.A)({},$Mo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}JMo.isMDXComponent=!0;const ZMo={toc:[]},eXo="wrapper";function nXo(e){let{components:n,...t}=e;return(0,s.yg)(eXo,(0,p.A)({},ZMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nXo.isMDXComponent=!0;const tXo={toc:[]},oXo="wrapper";function pXo(e){let{components:n,...t}=e;return(0,s.yg)(oXo,(0,p.A)({},tXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}pXo.isMDXComponent=!0;const rXo={toc:[]},sXo="wrapper";function cXo(e){let{components:n,...t}=e;return(0,s.yg)(sXo,(0,p.A)({},rXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cXo.isMDXComponent=!0;const aXo={toc:[]},iXo="wrapper";function lXo(e){let{components:n,...t}=e;return(0,s.yg)(iXo,(0,p.A)({},aXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}lXo.isMDXComponent=!0;const uXo={toc:[]},mXo="wrapper";function yXo(e){let{components:n,...t}=e;return(0,s.yg)(mXo,(0,p.A)({},uXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}yXo.isMDXComponent=!0;const dXo={toc:[]},hXo="wrapper";function gXo(e){let{components:n,...t}=e;return(0,s.yg)(hXo,(0,p.A)({},dXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}gXo.isMDXComponent=!0;const fXo={toc:[]},DXo="wrapper";function MXo(e){let{components:n,...t}=e;return(0,s.yg)(DXo,(0,p.A)({},fXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}MXo.isMDXComponent=!0;const XXo={toc:[]},_Xo="wrapper";function wXo(e){let{components:n,...t}=e;return(0,s.yg)(_Xo,(0,p.A)({},XXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}wXo.isMDXComponent=!0;const TXo={toc:[]},CXo="wrapper";function xXo(e){let{components:n,...t}=e;return(0,s.yg)(CXo,(0,p.A)({},TXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xXo.isMDXComponent=!0;const AXo={toc:[]},vXo="wrapper";function LXo(e){let{components:n,...t}=e;return(0,s.yg)(vXo,(0,p.A)({},AXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LXo.isMDXComponent=!0;const bXo={toc:[]},NXo="wrapper";function kXo(e){let{components:n,...t}=e;return(0,s.yg)(NXo,(0,p.A)({},bXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}kXo.isMDXComponent=!0;const zXo={toc:[]},PXo="wrapper";function IXo(e){let{components:n,...t}=e;return(0,s.yg)(PXo,(0,p.A)({},zXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}IXo.isMDXComponent=!0;const RXo={toc:[]},WXo="wrapper";function SXo(e){let{components:n,...t}=e;return(0,s.yg)(WXo,(0,p.A)({},RXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}SXo.isMDXComponent=!0;const BXo={toc:[]},GXo="wrapper";function EXo(e){let{components:n,...t}=e;return(0,s.yg)(GXo,(0,p.A)({},BXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}EXo.isMDXComponent=!0;const OXo={toc:[]},UXo="wrapper";function FXo(e){let{components:n,...t}=e;return(0,s.yg)(UXo,(0,p.A)({},OXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}FXo.isMDXComponent=!0;const VXo={toc:[]},qXo="wrapper";function jXo(e){let{components:n,...t}=e;return(0,s.yg)(qXo,(0,p.A)({},VXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}jXo.isMDXComponent=!0;const HXo={toc:[]},YXo="wrapper";function QXo(e){let{components:n,...t}=e;return(0,s.yg)(YXo,(0,p.A)({},HXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}QXo.isMDXComponent=!0;const $Xo={toc:[]},KXo="wrapper";function JXo(e){let{components:n,...t}=e;return(0,s.yg)(KXo,(0,p.A)({},$Xo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}JXo.isMDXComponent=!0;const ZXo={toc:[]},e_o="wrapper";function n_o(e){let{components:n,...t}=e;return(0,s.yg)(e_o,(0,p.A)({},ZXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}n_o.isMDXComponent=!0;const t_o={toc:[]},o_o="wrapper";function p_o(e){let{components:n,...t}=e;return(0,s.yg)(o_o,(0,p.A)({},t_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}p_o.isMDXComponent=!0;const r_o={toc:[]},s_o="wrapper";function c_o(e){let{components:n,...t}=e;return(0,s.yg)(s_o,(0,p.A)({},r_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}c_o.isMDXComponent=!0;const a_o={toc:[]},i_o="wrapper";function l_o(e){let{components:n,...t}=e;return(0,s.yg)(i_o,(0,p.A)({},a_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}l_o.isMDXComponent=!0;const u_o={toc:[]},m_o="wrapper";function y_o(e){let{components:n,...t}=e;return(0,s.yg)(m_o,(0,p.A)({},u_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}y_o.isMDXComponent=!0;const d_o={toc:[]},h_o="wrapper";function g_o(e){let{components:n,...t}=e;return(0,s.yg)(h_o,(0,p.A)({},d_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}g_o.isMDXComponent=!0;const f_o={toc:[]},D_o="wrapper";function M_o(e){let{components:n,...t}=e;return(0,s.yg)(D_o,(0,p.A)({},f_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}M_o.isMDXComponent=!0;const X_o={toc:[]},__o="wrapper";function w_o(e){let{components:n,...t}=e;return(0,s.yg)(__o,(0,p.A)({},X_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}w_o.isMDXComponent=!0;const T_o={toc:[]},C_o="wrapper";function x_o(e){let{components:n,...t}=e;return(0,s.yg)(C_o,(0,p.A)({},T_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}x_o.isMDXComponent=!0;const A_o={toc:[]},v_o="wrapper";function L_o(e){let{components:n,...t}=e;return(0,s.yg)(v_o,(0,p.A)({},A_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}L_o.isMDXComponent=!0;const b_o={toc:[]},N_o="wrapper";function k_o(e){let{components:n,...t}=e;return(0,s.yg)(N_o,(0,p.A)({},b_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}k_o.isMDXComponent=!0;const z_o={toc:[]},P_o="wrapper";function I_o(e){let{components:n,...t}=e;return(0,s.yg)(P_o,(0,p.A)({},z_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}I_o.isMDXComponent=!0;const R_o={toc:[]},W_o="wrapper";function S_o(e){let{components:n,...t}=e;return(0,s.yg)(W_o,(0,p.A)({},R_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}S_o.isMDXComponent=!0;const B_o={toc:[]},G_o="wrapper";function E_o(e){let{components:n,...t}=e;return(0,s.yg)(G_o,(0,p.A)({},B_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}E_o.isMDXComponent=!0;const O_o={toc:[]},U_o="wrapper";function F_o(e){let{components:n,...t}=e;return(0,s.yg)(U_o,(0,p.A)({},O_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}F_o.isMDXComponent=!0;const V_o={toc:[]},q_o="wrapper";function j_o(e){let{components:n,...t}=e;return(0,s.yg)(q_o,(0,p.A)({},V_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}j_o.isMDXComponent=!0;const H_o={toc:[]},Y_o="wrapper";function Q_o(e){let{components:n,...t}=e;return(0,s.yg)(Y_o,(0,p.A)({},H_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Q_o.isMDXComponent=!0;const $_o={toc:[]},K_o="wrapper";function J_o(e){let{components:n,...t}=e;return(0,s.yg)(K_o,(0,p.A)({},$_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}J_o.isMDXComponent=!0;const Z_o={toc:[]},ewo="wrapper";function nwo(e){let{components:n,...t}=e;return(0,s.yg)(ewo,(0,p.A)({},Z_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nwo.isMDXComponent=!0;const two={toc:[]},owo="wrapper";function pwo(e){let{components:n,...t}=e;return(0,s.yg)(owo,(0,p.A)({},two,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}pwo.isMDXComponent=!0;const rwo={toc:[]},swo="wrapper";function cwo(e){let{components:n,...t}=e;return(0,s.yg)(swo,(0,p.A)({},rwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}cwo.isMDXComponent=!0;const awo={toc:[]},iwo="wrapper";function lwo(e){let{components:n,...t}=e;return(0,s.yg)(iwo,(0,p.A)({},awo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}lwo.isMDXComponent=!0;const uwo={toc:[]},mwo="wrapper";function ywo(e){let{components:n,...t}=e;return(0,s.yg)(mwo,(0,p.A)({},uwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}ywo.isMDXComponent=!0;const dwo={toc:[]},hwo="wrapper";function gwo(e){let{components:n,...t}=e;return(0,s.yg)(hwo,(0,p.A)({},dwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}gwo.isMDXComponent=!0;const fwo={toc:[]},Dwo="wrapper";function Mwo(e){let{components:n,...t}=e;return(0,s.yg)(Dwo,(0,p.A)({},fwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Mwo.isMDXComponent=!0;const Xwo={toc:[]},_wo="wrapper";function wwo(e){let{components:n,...t}=e;return(0,s.yg)(_wo,(0,p.A)({},Xwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wwo.isMDXComponent=!0;const Two={toc:[]},Cwo="wrapper";function xwo(e){let{components:n,...t}=e;return(0,s.yg)(Cwo,(0,p.A)({},Two,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}xwo.isMDXComponent=!0;const Awo={toc:[]},vwo="wrapper";function Lwo(e){let{components:n,...t}=e;return(0,s.yg)(vwo,(0,p.A)({},Awo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lwo.isMDXComponent=!0;const bwo={toc:[]},Nwo="wrapper";function kwo(e){let{components:n,...t}=e;return(0,s.yg)(Nwo,(0,p.A)({},bwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}kwo.isMDXComponent=!0;const zwo={toc:[]},Pwo="wrapper";function Iwo(e){let{components:n,...t}=e;return(0,s.yg)(Pwo,(0,p.A)({},zwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Iwo.isMDXComponent=!0;const Rwo={toc:[]},Wwo="wrapper";function Swo(e){let{components:n,...t}=e;return(0,s.yg)(Wwo,(0,p.A)({},Rwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Swo.isMDXComponent=!0;const Bwo={toc:[]},Gwo="wrapper";function Ewo(e){let{components:n,...t}=e;return(0,s.yg)(Gwo,(0,p.A)({},Bwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Ewo.isMDXComponent=!0;const Owo={toc:[]},Uwo="wrapper";function Fwo(e){let{components:n,...t}=e;return(0,s.yg)(Uwo,(0,p.A)({},Owo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Fwo.isMDXComponent=!0;const Vwo={toc:[]},qwo="wrapper";function jwo(e){let{components:n,...t}=e;return(0,s.yg)(qwo,(0,p.A)({},Vwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}jwo.isMDXComponent=!0;const Hwo={toc:[]},Ywo="wrapper";function Qwo(e){let{components:n,...t}=e;return(0,s.yg)(Ywo,(0,p.A)({},Hwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qwo.isMDXComponent=!0;const $wo={toc:[]},Kwo="wrapper";function Jwo(e){let{components:n,...t}=e;return(0,s.yg)(Kwo,(0,p.A)({},$wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Jwo.isMDXComponent=!0;const Zwo={toc:[]},eTo="wrapper";function nTo(e){let{components:n,...t}=e;return(0,s.yg)(eTo,(0,p.A)({},Zwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}nTo.isMDXComponent=!0;const tTo={toc:[]},oTo="wrapper";function pTo(e){let{components:n,...t}=e;return(0,s.yg)(oTo,(0,p.A)({},tTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pTo.isMDXComponent=!0;const rTo={toc:[]},sTo="wrapper";function cTo(e){let{components:n,...t}=e;return(0,s.yg)(sTo,(0,p.A)({},rTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cTo.isMDXComponent=!0;const aTo={toc:[]},iTo="wrapper";function lTo(e){let{components:n,...t}=e;return(0,s.yg)(iTo,(0,p.A)({},aTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}lTo.isMDXComponent=!0;const uTo={toc:[]},mTo="wrapper";function yTo(e){let{components:n,...t}=e;return(0,s.yg)(mTo,(0,p.A)({},uTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}yTo.isMDXComponent=!0;const dTo={toc:[]},hTo="wrapper";function gTo(e){let{components:n,...t}=e;return(0,s.yg)(hTo,(0,p.A)({},dTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}gTo.isMDXComponent=!0;const fTo={toc:[]},DTo="wrapper";function MTo(e){let{components:n,...t}=e;return(0,s.yg)(DTo,(0,p.A)({},fTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}MTo.isMDXComponent=!0;const XTo={toc:[]},_To="wrapper";function wTo(e){let{components:n,...t}=e;return(0,s.yg)(_To,(0,p.A)({},XTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wTo.isMDXComponent=!0;const TTo={toc:[]},CTo="wrapper";function xTo(e){let{components:n,...t}=e;return(0,s.yg)(CTo,(0,p.A)({},TTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}xTo.isMDXComponent=!0;const ATo={toc:[]},vTo="wrapper";function LTo(e){let{components:n,...t}=e;return(0,s.yg)(vTo,(0,p.A)({},ATo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}LTo.isMDXComponent=!0;const bTo={toc:[]},NTo="wrapper";function kTo(e){let{components:n,...t}=e;return(0,s.yg)(NTo,(0,p.A)({},bTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}kTo.isMDXComponent=!0;const zTo={toc:[]},PTo="wrapper";function ITo(e){let{components:n,...t}=e;return(0,s.yg)(PTo,(0,p.A)({},zTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ITo.isMDXComponent=!0;const RTo={toc:[]},WTo="wrapper";function STo(e){let{components:n,...t}=e;return(0,s.yg)(WTo,(0,p.A)({},RTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}STo.isMDXComponent=!0;const BTo={toc:[]},GTo="wrapper";function ETo(e){let{components:n,...t}=e;return(0,s.yg)(GTo,(0,p.A)({},BTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}ETo.isMDXComponent=!0;const OTo={toc:[]},UTo="wrapper";function FTo(e){let{components:n,...t}=e;return(0,s.yg)(UTo,(0,p.A)({},OTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}FTo.isMDXComponent=!0;const VTo={toc:[]},qTo="wrapper";function jTo(e){let{components:n,...t}=e;return(0,s.yg)(qTo,(0,p.A)({},VTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}jTo.isMDXComponent=!0;const HTo={toc:[]},YTo="wrapper";function QTo(e){let{components:n,...t}=e;return(0,s.yg)(YTo,(0,p.A)({},HTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}QTo.isMDXComponent=!0;const $To={toc:[]},KTo="wrapper";function JTo(e){let{components:n,...t}=e;return(0,s.yg)(KTo,(0,p.A)({},$To,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}JTo.isMDXComponent=!0;const ZTo={toc:[]},eCo="wrapper";function nCo(e){let{components:n,...t}=e;return(0,s.yg)(eCo,(0,p.A)({},ZTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nCo.isMDXComponent=!0;const tCo={toc:[]},oCo="wrapper";function pCo(e){let{components:n,...t}=e;return(0,s.yg)(oCo,(0,p.A)({},tCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}pCo.isMDXComponent=!0;const rCo={toc:[]},sCo="wrapper";function cCo(e){let{components:n,...t}=e;return(0,s.yg)(sCo,(0,p.A)({},rCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cCo.isMDXComponent=!0;const aCo={toc:[]},iCo="wrapper";function lCo(e){let{components:n,...t}=e;return(0,s.yg)(iCo,(0,p.A)({},aCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lCo.isMDXComponent=!0;const uCo={toc:[]},mCo="wrapper";function yCo(e){let{components:n,...t}=e;return(0,s.yg)(mCo,(0,p.A)({},uCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}yCo.isMDXComponent=!0;const dCo={toc:[]},hCo="wrapper";function gCo(e){let{components:n,...t}=e;return(0,s.yg)(hCo,(0,p.A)({},dCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gCo.isMDXComponent=!0;const fCo={toc:[]},DCo="wrapper";function MCo(e){let{components:n,...t}=e;return(0,s.yg)(DCo,(0,p.A)({},fCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}MCo.isMDXComponent=!0;const XCo={toc:[]},_Co="wrapper";function wCo(e){let{components:n,...t}=e;return(0,s.yg)(_Co,(0,p.A)({},XCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wCo.isMDXComponent=!0;const TCo={toc:[]},CCo="wrapper";function xCo(e){let{components:n,...t}=e;return(0,s.yg)(CCo,(0,p.A)({},TCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}xCo.isMDXComponent=!0;const ACo={toc:[]},vCo="wrapper";function LCo(e){let{components:n,...t}=e;return(0,s.yg)(vCo,(0,p.A)({},ACo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you're not interested in animating SVG, you can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,s.yg)("inlineCode",{parentName:"a"},"Img"))," instead."))}LCo.isMDXComponent=!0;const bCo={toc:[]},NCo="wrapper";function kCo(e){let{components:n,...t}=e;return(0,s.yg)(NCo,(0,p.A)({},bCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A Node for drawing and animating SVG images."))}kCo.isMDXComponent=!0;const zCo={toc:[]},PCo="wrapper";function ICo(e){let{components:n,...t}=e;return(0,s.yg)(PCo,(0,p.A)({},zCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}ICo.isMDXComponent=!0;const RCo={toc:[]},WCo="wrapper";function SCo(e){let{components:n,...t}=e;return(0,s.yg)(WCo,(0,p.A)({},RCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}SCo.isMDXComponent=!0;const BCo={toc:[]},GCo="wrapper";function ECo(e){let{components:n,...t}=e;return(0,s.yg)(GCo,(0,p.A)({},BCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ECo.isMDXComponent=!0;const OCo={toc:[]},UCo="wrapper";function FCo(e){let{components:n,...t}=e;return(0,s.yg)(UCo,(0,p.A)({},OCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}FCo.isMDXComponent=!0;const VCo={toc:[]},qCo="wrapper";function jCo(e){let{components:n,...t}=e;return(0,s.yg)(qCo,(0,p.A)({},VCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}jCo.isMDXComponent=!0;const HCo={toc:[]},YCo="wrapper";function QCo(e){let{components:n,...t}=e;return(0,s.yg)(YCo,(0,p.A)({},HCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}QCo.isMDXComponent=!0;const $Co={toc:[]},KCo="wrapper";function JCo(e){let{components:n,...t}=e;return(0,s.yg)(KCo,(0,p.A)({},$Co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}JCo.isMDXComponent=!0;const ZCo={toc:[]},exo="wrapper";function nxo(e){let{components:n,...t}=e;return(0,s.yg)(exo,(0,p.A)({},ZCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}nxo.isMDXComponent=!0;const txo={toc:[]},oxo="wrapper";function pxo(e){let{components:n,...t}=e;return(0,s.yg)(oxo,(0,p.A)({},txo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pxo.isMDXComponent=!0;const rxo={toc:[]},sxo="wrapper";function cxo(e){let{components:n,...t}=e;return(0,s.yg)(sxo,(0,p.A)({},rxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}cxo.isMDXComponent=!0;const axo={toc:[]},ixo="wrapper";function lxo(e){let{components:n,...t}=e;return(0,s.yg)(ixo,(0,p.A)({},axo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lxo.isMDXComponent=!0;const uxo={toc:[]},mxo="wrapper";function yxo(e){let{components:n,...t}=e;return(0,s.yg)(mxo,(0,p.A)({},uxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}yxo.isMDXComponent=!0;const dxo={toc:[]},hxo="wrapper";function gxo(e){let{components:n,...t}=e;return(0,s.yg)(hxo,(0,p.A)({},dxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gxo.isMDXComponent=!0;const fxo={toc:[]},Dxo="wrapper";function Mxo(e){let{components:n,...t}=e;return(0,s.yg)(Dxo,(0,p.A)({},fxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Mxo.isMDXComponent=!0;const Xxo={toc:[]},_xo="wrapper";function wxo(e){let{components:n,...t}=e;return(0,s.yg)(_xo,(0,p.A)({},Xxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}wxo.isMDXComponent=!0;const Txo={toc:[]},Cxo="wrapper";function xxo(e){let{components:n,...t}=e;return(0,s.yg)(Cxo,(0,p.A)({},Txo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}xxo.isMDXComponent=!0;const Axo={toc:[]},vxo="wrapper";function Lxo(e){let{components:n,...t}=e;return(0,s.yg)(vxo,(0,p.A)({},Axo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Lxo.isMDXComponent=!0;const bxo={toc:[]},Nxo="wrapper";function kxo(e){let{components:n,...t}=e;return(0,s.yg)(Nxo,(0,p.A)({},bxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}kxo.isMDXComponent=!0;const zxo={toc:[]},Pxo="wrapper";function Ixo(e){let{components:n,...t}=e;return(0,s.yg)(Pxo,(0,p.A)({},zxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ixo.isMDXComponent=!0;const Rxo={toc:[]},Wxo="wrapper";function Sxo(e){let{components:n,...t}=e;return(0,s.yg)(Wxo,(0,p.A)({},Rxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Sxo.isMDXComponent=!0;const Bxo={toc:[]},Gxo="wrapper";function Exo(e){let{components:n,...t}=e;return(0,s.yg)(Gxo,(0,p.A)({},Bxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Exo.isMDXComponent=!0;const Oxo={toc:[]},Uxo="wrapper";function Fxo(e){let{components:n,...t}=e;return(0,s.yg)(Uxo,(0,p.A)({},Oxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Fxo.isMDXComponent=!0;const Vxo={toc:[]},qxo="wrapper";function jxo(e){let{components:n,...t}=e;return(0,s.yg)(qxo,(0,p.A)({},Vxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jxo.isMDXComponent=!0;const Hxo={toc:[]},Yxo="wrapper";function Qxo(e){let{components:n,...t}=e;return(0,s.yg)(Yxo,(0,p.A)({},Hxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Qxo.isMDXComponent=!0;const $xo={toc:[]},Kxo="wrapper";function Jxo(e){let{components:n,...t}=e;return(0,s.yg)(Kxo,(0,p.A)({},$xo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Jxo.isMDXComponent=!0;const Zxo={toc:[]},eAo="wrapper";function nAo(e){let{components:n,...t}=e;return(0,s.yg)(eAo,(0,p.A)({},Zxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}nAo.isMDXComponent=!0;const tAo={toc:[]},oAo="wrapper";function pAo(e){let{components:n,...t}=e;return(0,s.yg)(oAo,(0,p.A)({},tAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}pAo.isMDXComponent=!0;const rAo={toc:[]},sAo="wrapper";function cAo(e){let{components:n,...t}=e;return(0,s.yg)(sAo,(0,p.A)({},rAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cAo.isMDXComponent=!0;const aAo={toc:[]},iAo="wrapper";function lAo(e){let{components:n,...t}=e;return(0,s.yg)(iAo,(0,p.A)({},aAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}lAo.isMDXComponent=!0;const uAo={toc:[]},mAo="wrapper";function yAo(e){let{components:n,...t}=e;return(0,s.yg)(mAo,(0,p.A)({},uAo,t,{components:n,mdxType:"MDXLayout"}))}yAo.isMDXComponent=!0;const dAo={toc:[]},hAo="wrapper";function gAo(e){let{components:n,...t}=e;return(0,s.yg)(hAo,(0,p.A)({},dAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gAo.isMDXComponent=!0;const fAo={toc:[]},DAo="wrapper";function MAo(e){let{components:n,...t}=e;return(0,s.yg)(DAo,(0,p.A)({},fAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}MAo.isMDXComponent=!0;const XAo={toc:[]},_Ao="wrapper";function wAo(e){let{components:n,...t}=e;return(0,s.yg)(_Ao,(0,p.A)({},XAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}wAo.isMDXComponent=!0;const TAo={toc:[]},CAo="wrapper";function xAo(e){let{components:n,...t}=e;return(0,s.yg)(CAo,(0,p.A)({},TAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}xAo.isMDXComponent=!0;const AAo={toc:[]},vAo="wrapper";function LAo(e){let{components:n,...t}=e;return(0,s.yg)(vAo,(0,p.A)({},AAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}LAo.isMDXComponent=!0;const bAo={toc:[]},NAo="wrapper";function kAo(e){let{components:n,...t}=e;return(0,s.yg)(NAo,(0,p.A)({},bAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}kAo.isMDXComponent=!0;const zAo={toc:[]},PAo="wrapper";function IAo(e){let{components:n,...t}=e;return(0,s.yg)(PAo,(0,p.A)({},zAo,t,{components:n,mdxType:"MDXLayout"}))}IAo.isMDXComponent=!0;const RAo={toc:[]},WAo="wrapper";function SAo(e){let{components:n,...t}=e;return(0,s.yg)(WAo,(0,p.A)({},RAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"SVG string to be rendered"))}SAo.isMDXComponent=!0;const BAo={toc:[]},GAo="wrapper";function EAo(e){let{components:n,...t}=e;return(0,s.yg)(GAo,(0,p.A)({},BAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}EAo.isMDXComponent=!0;const OAo={toc:[]},UAo="wrapper";function FAo(e){let{components:n,...t}=e;return(0,s.yg)(UAo,(0,p.A)({},OAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}FAo.isMDXComponent=!0;const VAo={toc:[]},qAo="wrapper";function jAo(e){let{components:n,...t}=e;return(0,s.yg)(qAo,(0,p.A)({},VAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}jAo.isMDXComponent=!0;const HAo={toc:[]},YAo="wrapper";function QAo(e){let{components:n,...t}=e;return(0,s.yg)(YAo,(0,p.A)({},HAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}QAo.isMDXComponent=!0;const $Ao={toc:[]},KAo="wrapper";function JAo(e){let{components:n,...t}=e;return(0,s.yg)(KAo,(0,p.A)({},$Ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}JAo.isMDXComponent=!0;const ZAo={toc:[]},evo="wrapper";function nvo(e){let{components:n,...t}=e;return(0,s.yg)(evo,(0,p.A)({},ZAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}nvo.isMDXComponent=!0;const tvo={toc:[]},ovo="wrapper";function pvo(e){let{components:n,...t}=e;return(0,s.yg)(ovo,(0,p.A)({},tvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Child to wrap all SVG node"))}pvo.isMDXComponent=!0;const rvo={toc:[]},svo="wrapper";function cvo(e){let{components:n,...t}=e;return(0,s.yg)(svo,(0,p.A)({},rvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}cvo.isMDXComponent=!0;const avo={toc:[]},ivo="wrapper";function lvo(e){let{components:n,...t}=e;return(0,s.yg)(ivo,(0,p.A)({},avo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lvo.isMDXComponent=!0;const uvo={toc:[]},mvo="wrapper";function yvo(e){let{components:n,...t}=e;return(0,s.yg)(mvo,(0,p.A)({},uvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}yvo.isMDXComponent=!0;const dvo={toc:[]},hvo="wrapper";function gvo(e){let{components:n,...t}=e;return(0,s.yg)(hvo,(0,p.A)({},dvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}gvo.isMDXComponent=!0;const fvo={toc:[]},Dvo="wrapper";function Mvo(e){let{components:n,...t}=e;return(0,s.yg)(Dvo,(0,p.A)({},fvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Mvo.isMDXComponent=!0;const Xvo={toc:[]},_vo="wrapper";function wvo(e){let{components:n,...t}=e;return(0,s.yg)(_vo,(0,p.A)({},Xvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}wvo.isMDXComponent=!0;const Tvo={toc:[]},Cvo="wrapper";function xvo(e){let{components:n,...t}=e;return(0,s.yg)(Cvo,(0,p.A)({},Tvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}xvo.isMDXComponent=!0;const Avo={toc:[]},vvo="wrapper";function Lvo(e){let{components:n,...t}=e;return(0,s.yg)(vvo,(0,p.A)({},Avo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Lvo.isMDXComponent=!0;const bvo={toc:[]},Nvo="wrapper";function kvo(e){let{components:n,...t}=e;return(0,s.yg)(Nvo,(0,p.A)({},bvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}kvo.isMDXComponent=!0;const zvo={toc:[]},Pvo="wrapper";function Ivo(e){let{components:n,...t}=e;return(0,s.yg)(Pvo,(0,p.A)({},zvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Ivo.isMDXComponent=!0;const Rvo={toc:[]},Wvo="wrapper";function Svo(e){let{components:n,...t}=e;return(0,s.yg)(Wvo,(0,p.A)({},Rvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}Svo.isMDXComponent=!0;const Bvo={toc:[]},Gvo="wrapper";function Evo(e){let{components:n,...t}=e;return(0,s.yg)(Gvo,(0,p.A)({},Bvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," to convert."))}Evo.isMDXComponent=!0;const Ovo={toc:[]},Uvo="wrapper";function Fvo(e){let{components:n,...t}=e;return(0,s.yg)(Uvo,(0,p.A)({},Ovo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGShapeData")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGShape"),"."))}Fvo.isMDXComponent=!0;const Vvo={toc:[]},qvo="wrapper";function jvo(e){let{components:n,...t}=e;return(0,s.yg)(qvo,(0,p.A)({},Vvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGShapeData")," to convert."))}jvo.isMDXComponent=!0;const Hvo={toc:[]},Yvo="wrapper";function Qvo(e){let{components:n,...t}=e;return(0,s.yg)(Yvo,(0,p.A)({},Hvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Qvo.isMDXComponent=!0;const $vo={toc:[]},Kvo="wrapper";function Jvo(e){let{components:n,...t}=e;return(0,s.yg)(Kvo,(0,p.A)({},$vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Jvo.isMDXComponent=!0;const Zvo={toc:[]},eLo="wrapper";function nLo(e){let{components:n,...t}=e;return(0,s.yg)(eLo,(0,p.A)({},Zvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}nLo.isMDXComponent=!0;const tLo={toc:[]},oLo="wrapper";function pLo(e){let{components:n,...t}=e;return(0,s.yg)(oLo,(0,p.A)({},tLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}pLo.isMDXComponent=!0;const rLo={toc:[]},sLo="wrapper";function cLo(e){let{components:n,...t}=e;return(0,s.yg)(sLo,(0,p.A)({},rLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}cLo.isMDXComponent=!0;const aLo={toc:[]},iLo="wrapper";function lLo(e){let{components:n,...t}=e;return(0,s.yg)(iLo,(0,p.A)({},aLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}lLo.isMDXComponent=!0;const uLo={toc:[]},mLo="wrapper";function yLo(e){let{components:n,...t}=e;return(0,s.yg)(mLo,(0,p.A)({},uLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}yLo.isMDXComponent=!0;const dLo={toc:[]},hLo="wrapper";function gLo(e){let{components:n,...t}=e;return(0,s.yg)(hLo,(0,p.A)({},dLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}gLo.isMDXComponent=!0;const fLo={toc:[]},DLo="wrapper";function MLo(e){let{components:n,...t}=e;return(0,s.yg)(DLo,(0,p.A)({},fLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}MLo.isMDXComponent=!0;const XLo={toc:[]},_Lo="wrapper";function wLo(e){let{components:n,...t}=e;return(0,s.yg)(_Lo,(0,p.A)({},XLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}wLo.isMDXComponent=!0;const TLo={toc:[]},CLo="wrapper";function xLo(e){let{components:n,...t}=e;return(0,s.yg)(CLo,(0,p.A)({},TLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}xLo.isMDXComponent=!0;const ALo={toc:[]},vLo="wrapper";function LLo(e){let{components:n,...t}=e;return(0,s.yg)(vLo,(0,p.A)({},ALo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}LLo.isMDXComponent=!0;const bLo={toc:[]},NLo="wrapper";function kLo(e){let{components:n,...t}=e;return(0,s.yg)(NLo,(0,p.A)({},bLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kLo.isMDXComponent=!0;const zLo={toc:[]},PLo="wrapper";function ILo(e){let{components:n,...t}=e;return(0,s.yg)(PLo,(0,p.A)({},zLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}ILo.isMDXComponent=!0;const RLo={toc:[]},WLo="wrapper";function SLo(e){let{components:n,...t}=e;return(0,s.yg)(WLo,(0,p.A)({},RLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}SLo.isMDXComponent=!0;const BLo={toc:[]},GLo="wrapper";function ELo(e){let{components:n,...t}=e;return(0,s.yg)(GLo,(0,p.A)({},BLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}ELo.isMDXComponent=!0;const OLo={toc:[]},ULo="wrapper";function FLo(e){let{components:n,...t}=e;return(0,s.yg)(ULo,(0,p.A)({},OLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}FLo.isMDXComponent=!0;const VLo={toc:[]},qLo="wrapper";function jLo(e){let{components:n,...t}=e;return(0,s.yg)(qLo,(0,p.A)({},VLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jLo.isMDXComponent=!0;const HLo={toc:[]},YLo="wrapper";function QLo(e){let{components:n,...t}=e;return(0,s.yg)(YLo,(0,p.A)({},HLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}QLo.isMDXComponent=!0;const $Lo={toc:[]},KLo="wrapper";function JLo(e){let{components:n,...t}=e;return(0,s.yg)(KLo,(0,p.A)({},$Lo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}JLo.isMDXComponent=!0;const ZLo={toc:[]},ebo="wrapper";function nbo(e){let{components:n,...t}=e;return(0,s.yg)(ebo,(0,p.A)({},ZLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}nbo.isMDXComponent=!0;const tbo={toc:[]},obo="wrapper";function pbo(e){let{components:n,...t}=e;return(0,s.yg)(obo,(0,p.A)({},tbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}pbo.isMDXComponent=!0;const rbo={toc:[]},sbo="wrapper";function cbo(e){let{components:n,...t}=e;return(0,s.yg)(sbo,(0,p.A)({},rbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cbo.isMDXComponent=!0;const abo={toc:[]},ibo="wrapper";function lbo(e){let{components:n,...t}=e;return(0,s.yg)(ibo,(0,p.A)({},abo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}lbo.isMDXComponent=!0;const ubo={toc:[]},mbo="wrapper";function ybo(e){let{components:n,...t}=e;return(0,s.yg)(mbo,(0,p.A)({},ubo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ybo.isMDXComponent=!0;const dbo={toc:[]},hbo="wrapper";function gbo(e){let{components:n,...t}=e;return(0,s.yg)(hbo,(0,p.A)({},dbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}gbo.isMDXComponent=!0;const fbo={toc:[]},Dbo="wrapper";function Mbo(e){let{components:n,...t}=e;return(0,s.yg)(Dbo,(0,p.A)({},fbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mbo.isMDXComponent=!0;const Xbo={toc:[]},_bo="wrapper";function wbo(e){let{components:n,...t}=e;return(0,s.yg)(_bo,(0,p.A)({},Xbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wbo.isMDXComponent=!0;const Tbo={toc:[]},Cbo="wrapper";function xbo(e){let{components:n,...t}=e;return(0,s.yg)(Cbo,(0,p.A)({},Tbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xbo.isMDXComponent=!0;const Abo={toc:[]},vbo="wrapper";function Lbo(e){let{components:n,...t}=e;return(0,s.yg)(vbo,(0,p.A)({},Abo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Lbo.isMDXComponent=!0;const bbo={toc:[]},Nbo="wrapper";function kbo(e){let{components:n,...t}=e;return(0,s.yg)(Nbo,(0,p.A)({},bbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kbo.isMDXComponent=!0;const zbo={toc:[]},Pbo="wrapper";function Ibo(e){let{components:n,...t}=e;return(0,s.yg)(Pbo,(0,p.A)({},zbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ibo.isMDXComponent=!0;const Rbo={toc:[]},Wbo="wrapper";function Sbo(e){let{components:n,...t}=e;return(0,s.yg)(Wbo,(0,p.A)({},Rbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Sbo.isMDXComponent=!0;const Bbo={toc:[]},Gbo="wrapper";function Ebo(e){let{components:n,...t}=e;return(0,s.yg)(Gbo,(0,p.A)({},Bbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Ebo.isMDXComponent=!0;const Obo={toc:[]},Ubo="wrapper";function Fbo(e){let{components:n,...t}=e;return(0,s.yg)(Ubo,(0,p.A)({},Obo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fbo.isMDXComponent=!0;const Vbo={toc:[]},qbo="wrapper";function jbo(e){let{components:n,...t}=e;return(0,s.yg)(qbo,(0,p.A)({},Vbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}jbo.isMDXComponent=!0;const Hbo={toc:[]},Ybo="wrapper";function Qbo(e){let{components:n,...t}=e;return(0,s.yg)(Ybo,(0,p.A)({},Hbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qbo.isMDXComponent=!0;const $bo={toc:[]},Kbo="wrapper";function Jbo(e){let{components:n,...t}=e;return(0,s.yg)(Kbo,(0,p.A)({},$bo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Jbo.isMDXComponent=!0;const Zbo={toc:[]},eNo="wrapper";function nNo(e){let{components:n,...t}=e;return(0,s.yg)(eNo,(0,p.A)({},Zbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nNo.isMDXComponent=!0;const tNo={toc:[]},oNo="wrapper";function pNo(e){let{components:n,...t}=e;return(0,s.yg)(oNo,(0,p.A)({},tNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a tweening list to tween between two SVG nodes."))}pNo.isMDXComponent=!0;const rNo={toc:[]},sNo="wrapper";function cNo(e){let{components:n,...t}=e;return(0,s.yg)(sNo,(0,p.A)({},rNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial node,"))}cNo.isMDXComponent=!0;const aNo={toc:[]},iNo="wrapper";function lNo(e){let{components:n,...t}=e;return(0,s.yg)(iNo,(0,p.A)({},aNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The final node."))}lNo.isMDXComponent=!0;const uNo={toc:[]},mNo="wrapper";function yNo(e){let{components:n,...t}=e;return(0,s.yg)(mNo,(0,p.A)({},uNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the tween."))}yNo.isMDXComponent=!0;const dNo={toc:[]},hNo="wrapper";function gNo(e){let{components:n,...t}=e;return(0,s.yg)(hNo,(0,p.A)({},dNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function."))}gNo.isMDXComponent=!0;const fNo={toc:[]},DNo="wrapper";function MNo(e){let{components:n,...t}=e;return(0,s.yg)(DNo,(0,p.A)({},fNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}MNo.isMDXComponent=!0;const XNo={toc:[]},_No="wrapper";function wNo(e){let{components:n,...t}=e;return(0,s.yg)(_No,(0,p.A)({},XNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}wNo.isMDXComponent=!0;const TNo={toc:[]},CNo="wrapper";function xNo(e){let{components:n,...t}=e;return(0,s.yg)(CNo,(0,p.A)({},TNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all SVG nodes with the given id."))}xNo.isMDXComponent=!0;const ANo={toc:[]},vNo="wrapper";function LNo(e){let{components:n,...t}=e;return(0,s.yg)(vNo,(0,p.A)({},ANo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An id to query."))}LNo.isMDXComponent=!0;const bNo={toc:[]},NNo="wrapper";function kNo(e){let{components:n,...t}=e;return(0,s.yg)(NNo,(0,p.A)({},bNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kNo.isMDXComponent=!0;const zNo={toc:[]},PNo="wrapper";function INo(e){let{components:n,...t}=e;return(0,s.yg)(PNo,(0,p.A)({},zNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}INo.isMDXComponent=!0;const RNo={toc:[]},WNo="wrapper";function SNo(e){let{components:n,...t}=e;return(0,s.yg)(WNo,(0,p.A)({},RNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}SNo.isMDXComponent=!0;const BNo={toc:[]},GNo="wrapper";function ENo(e){let{components:n,...t}=e;return(0,s.yg)(GNo,(0,p.A)({},BNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}ENo.isMDXComponent=!0;const ONo={toc:[]},UNo="wrapper";function FNo(e){let{components:n,...t}=e;return(0,s.yg)(UNo,(0,p.A)({},ONo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}FNo.isMDXComponent=!0;const VNo={toc:[]},qNo="wrapper";function jNo(e){let{components:n,...t}=e;return(0,s.yg)(qNo,(0,p.A)({},VNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}jNo.isMDXComponent=!0;const HNo={toc:[]},YNo="wrapper";function QNo(e){let{components:n,...t}=e;return(0,s.yg)(YNo,(0,p.A)({},HNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}QNo.isMDXComponent=!0;const $No={toc:[]},KNo="wrapper";function JNo(e){let{components:n,...t}=e;return(0,s.yg)(KNo,(0,p.A)({},$No,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}JNo.isMDXComponent=!0;const ZNo={toc:[]},eko="wrapper";function nko(e){let{components:n,...t}=e;return(0,s.yg)(eko,(0,p.A)({},ZNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}nko.isMDXComponent=!0;const tko={toc:[]},oko="wrapper";function pko(e){let{components:n,...t}=e;return(0,s.yg)(oko,(0,p.A)({},tko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}pko.isMDXComponent=!0;const rko={toc:[]},sko="wrapper";function cko(e){let{components:n,...t}=e;return(0,s.yg)(sko,(0,p.A)({},rko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cko.isMDXComponent=!0;const ako={toc:[]},iko="wrapper";function lko(e){let{components:n,...t}=e;return(0,s.yg)(iko,(0,p.A)({},ako,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}lko.isMDXComponent=!0;const uko={toc:[]},mko="wrapper";function yko(e){let{components:n,...t}=e;return(0,s.yg)(mko,(0,p.A)({},uko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}yko.isMDXComponent=!0;const dko={toc:[]},hko="wrapper";function gko(e){let{components:n,...t}=e;return(0,s.yg)(hko,(0,p.A)({},dko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}gko.isMDXComponent=!0;const fko={toc:[]},Dko="wrapper";function Mko(e){let{components:n,...t}=e;return(0,s.yg)(Dko,(0,p.A)({},fko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mko.isMDXComponent=!0;const Xko={toc:[]},_ko="wrapper";function wko(e){let{components:n,...t}=e;return(0,s.yg)(_ko,(0,p.A)({},Xko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wko.isMDXComponent=!0;const Tko={toc:[]},Cko="wrapper";function xko(e){let{components:n,...t}=e;return(0,s.yg)(Cko,(0,p.A)({},Tko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}xko.isMDXComponent=!0;const Ako={toc:[]},vko="wrapper";function Lko(e){let{components:n,...t}=e;return(0,s.yg)(vko,(0,p.A)({},Ako,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Lko.isMDXComponent=!0;const bko={toc:[]},Nko="wrapper";function kko(e){let{components:n,...t}=e;return(0,s.yg)(Nko,(0,p.A)({},bko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}kko.isMDXComponent=!0;const zko={toc:[]},Pko="wrapper";function Iko(e){let{components:n,...t}=e;return(0,s.yg)(Pko,(0,p.A)({},zko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Iko.isMDXComponent=!0;const Rko={toc:[]},Wko="wrapper";function Sko(e){let{components:n,...t}=e;return(0,s.yg)(Wko,(0,p.A)({},Rko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Sko.isMDXComponent=!0;const Bko={toc:[]},Gko="wrapper";function Eko(e){let{components:n,...t}=e;return(0,s.yg)(Gko,(0,p.A)({},Bko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Eko.isMDXComponent=!0;const Oko={toc:[]},Uko="wrapper";function Fko(e){let{components:n,...t}=e;return(0,s.yg)(Uko,(0,p.A)({},Oko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Fko.isMDXComponent=!0;const Vko={toc:[]},qko="wrapper";function jko(e){let{components:n,...t}=e;return(0,s.yg)(qko,(0,p.A)({},Vko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}jko.isMDXComponent=!0;const Hko={toc:[]},Yko="wrapper";function Qko(e){let{components:n,...t}=e;return(0,s.yg)(Yko,(0,p.A)({},Hko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Qko.isMDXComponent=!0;const $ko={toc:[]},Kko="wrapper";function Jko(e){let{components:n,...t}=e;return(0,s.yg)(Kko,(0,p.A)({},$ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Jko.isMDXComponent=!0;const Zko={toc:[]},ezo="wrapper";function nzo(e){let{components:n,...t}=e;return(0,s.yg)(ezo,(0,p.A)({},Zko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}nzo.isMDXComponent=!0;const tzo={toc:[]},ozo="wrapper";function pzo(e){let{components:n,...t}=e;return(0,s.yg)(ozo,(0,p.A)({},tzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pzo.isMDXComponent=!0;const rzo={toc:[]},szo="wrapper";function czo(e){let{components:n,...t}=e;return(0,s.yg)(szo,(0,p.A)({},rzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}czo.isMDXComponent=!0;const azo={toc:[]},izo="wrapper";function lzo(e){let{components:n,...t}=e;return(0,s.yg)(izo,(0,p.A)({},azo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}lzo.isMDXComponent=!0;const uzo={toc:[]},mzo="wrapper";function yzo(e){let{components:n,...t}=e;return(0,s.yg)(mzo,(0,p.A)({},uzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yzo.isMDXComponent=!0;const dzo={toc:[]},hzo="wrapper";function gzo(e){let{components:n,...t}=e;return(0,s.yg)(hzo,(0,p.A)({},dzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}gzo.isMDXComponent=!0;const fzo={toc:[]},Dzo="wrapper";function Mzo(e){let{components:n,...t}=e;return(0,s.yg)(Dzo,(0,p.A)({},fzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Mzo.isMDXComponent=!0;const Xzo={toc:[]},_zo="wrapper";function wzo(e){let{components:n,...t}=e;return(0,s.yg)(_zo,(0,p.A)({},Xzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}wzo.isMDXComponent=!0;const Tzo={toc:[]},Czo="wrapper";function xzo(e){let{components:n,...t}=e;return(0,s.yg)(Czo,(0,p.A)({},Tzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}xzo.isMDXComponent=!0;const Azo={toc:[]},vzo="wrapper";function Lzo(e){let{components:n,...t}=e;return(0,s.yg)(vzo,(0,p.A)({},Azo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Lzo.isMDXComponent=!0;const bzo={toc:[]},Nzo="wrapper";function kzo(e){let{components:n,...t}=e;return(0,s.yg)(Nzo,(0,p.A)({},bzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}kzo.isMDXComponent=!0;const zzo={toc:[]},Pzo="wrapper";function Izo(e){let{components:n,...t}=e;return(0,s.yg)(Pzo,(0,p.A)({},zzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Izo.isMDXComponent=!0;const Rzo={toc:[]},Wzo="wrapper";function Szo(e){let{components:n,...t}=e;return(0,s.yg)(Wzo,(0,p.A)({},Rzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Szo.isMDXComponent=!0;const Bzo={toc:[]},Gzo="wrapper";function Ezo(e){let{components:n,...t}=e;return(0,s.yg)(Gzo,(0,p.A)({},Bzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Ezo.isMDXComponent=!0;const Ozo={toc:[]},Uzo="wrapper";function Fzo(e){let{components:n,...t}=e;return(0,s.yg)(Uzo,(0,p.A)({},Ozo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Fzo.isMDXComponent=!0;const Vzo={toc:[]},qzo="wrapper";function jzo(e){let{components:n,...t}=e;return(0,s.yg)(qzo,(0,p.A)({},Vzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}jzo.isMDXComponent=!0;const Hzo={toc:[]},Yzo="wrapper";function Qzo(e){let{components:n,...t}=e;return(0,s.yg)(Yzo,(0,p.A)({},Hzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Qzo.isMDXComponent=!0;const $zo={toc:[]},Kzo="wrapper";function Jzo(e){let{components:n,...t}=e;return(0,s.yg)(Kzo,(0,p.A)({},$zo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Jzo.isMDXComponent=!0;const Zzo={toc:[]},ePo="wrapper";function nPo(e){let{components:n,...t}=e;return(0,s.yg)(ePo,(0,p.A)({},Zzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert an SVG string to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}nPo.isMDXComponent=!0;const tPo={toc:[]},oPo="wrapper";function pPo(e){let{components:n,...t}=e;return(0,s.yg)(oPo,(0,p.A)({},tPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An SVG string to be parsed."))}pPo.isMDXComponent=!0;const rPo={toc:[]},sPo="wrapper";function cPo(e){let{components:n,...t}=e;return(0,s.yg)(sPo,(0,p.A)({},rPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}cPo.isMDXComponent=!0;const aPo={toc:[]},iPo="wrapper";function lPo(e){let{components:n,...t}=e;return(0,s.yg)(iPo,(0,p.A)({},aPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}lPo.isMDXComponent=!0;const uPo={toc:[]},mPo="wrapper";function yPo(e){let{components:n,...t}=e;return(0,s.yg)(mPo,(0,p.A)({},uPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}yPo.isMDXComponent=!0;const dPo={toc:[]},hPo="wrapper";function gPo(e){let{components:n,...t}=e;return(0,s.yg)(hPo,(0,p.A)({},dPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}gPo.isMDXComponent=!0;const fPo={toc:[]},DPo="wrapper";function MPo(e){let{components:n,...t}=e;return(0,s.yg)(DPo,(0,p.A)({},fPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}MPo.isMDXComponent=!0;const XPo={toc:[]},_Po="wrapper";function wPo(e){let{components:n,...t}=e;return(0,s.yg)(_Po,(0,p.A)({},XPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}wPo.isMDXComponent=!0;const TPo={toc:[]},CPo="wrapper";function xPo(e){let{components:n,...t}=e;return(0,s.yg)(CPo,(0,p.A)({},TPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}xPo.isMDXComponent=!0;const APo={toc:[]},vPo="wrapper";function LPo(e){let{components:n,...t}=e;return(0,s.yg)(vPo,(0,p.A)({},APo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}LPo.isMDXComponent=!0;const bPo={toc:[]},NPo="wrapper";function kPo(e){let{components:n,...t}=e;return(0,s.yg)(NPo,(0,p.A)({},bPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}kPo.isMDXComponent=!0;const zPo={toc:[]},PPo="wrapper";function IPo(e){let{components:n,...t}=e;return(0,s.yg)(PPo,(0,p.A)({},zPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}IPo.isMDXComponent=!0;const RPo={toc:[]},WPo="wrapper";function SPo(e){let{components:n,...t}=e;return(0,s.yg)(WPo,(0,p.A)({},RPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}SPo.isMDXComponent=!0;const BPo={toc:[]},GPo="wrapper";function EPo(e){let{components:n,...t}=e;return(0,s.yg)(GPo,(0,p.A)({},BPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}EPo.isMDXComponent=!0;const OPo={toc:[]},UPo="wrapper";function FPo(e){let{components:n,...t}=e;return(0,s.yg)(UPo,(0,p.A)({},OPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}FPo.isMDXComponent=!0;const VPo={toc:[]},qPo="wrapper";function jPo(e){let{components:n,...t}=e;return(0,s.yg)(qPo,(0,p.A)({},VPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}jPo.isMDXComponent=!0;const HPo={toc:[]},YPo="wrapper";function QPo(e){let{components:n,...t}=e;return(0,s.yg)(YPo,(0,p.A)({},HPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}QPo.isMDXComponent=!0;const $Po={toc:[]},KPo="wrapper";function JPo(e){let{components:n,...t}=e;return(0,s.yg)(KPo,(0,p.A)({},$Po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}JPo.isMDXComponent=!0;const ZPo={toc:[]},eIo="wrapper";function nIo(e){let{components:n,...t}=e;return(0,s.yg)(eIo,(0,p.A)({},ZPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}nIo.isMDXComponent=!0;const tIo={toc:[]},oIo="wrapper";function pIo(e){let{components:n,...t}=e;return(0,s.yg)(oIo,(0,p.A)({},tIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}pIo.isMDXComponent=!0;const rIo={toc:[]},sIo="wrapper";function cIo(e){let{components:n,...t}=e;return(0,s.yg)(sIo,(0,p.A)({},rIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}cIo.isMDXComponent=!0;const aIo={toc:[]},iIo="wrapper";function lIo(e){let{components:n,...t}=e;return(0,s.yg)(iIo,(0,p.A)({},aIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lIo.isMDXComponent=!0;const uIo={toc:[]},mIo="wrapper";function yIo(e){let{components:n,...t}=e;return(0,s.yg)(mIo,(0,p.A)({},uIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}yIo.isMDXComponent=!0;const dIo={toc:[]},hIo="wrapper";function gIo(e){let{components:n,...t}=e;return(0,s.yg)(hIo,(0,p.A)({},dIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}gIo.isMDXComponent=!0;const fIo={toc:[]},DIo="wrapper";function MIo(e){let{components:n,...t}=e;return(0,s.yg)(DIo,(0,p.A)({},fIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}MIo.isMDXComponent=!0;const XIo={toc:[]},_Io="wrapper";function wIo(e){let{components:n,...t}=e;return(0,s.yg)(_Io,(0,p.A)({},XIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}wIo.isMDXComponent=!0;const TIo={toc:[]},CIo="wrapper";function xIo(e){let{components:n,...t}=e;return(0,s.yg)(CIo,(0,p.A)({},TIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}xIo.isMDXComponent=!0;const AIo={toc:[]},vIo="wrapper";function LIo(e){let{components:n,...t}=e;return(0,s.yg)(vIo,(0,p.A)({},AIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}LIo.isMDXComponent=!0;const bIo={toc:[]},NIo="wrapper";function kIo(e){let{components:n,...t}=e;return(0,s.yg)(NIo,(0,p.A)({},bIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}kIo.isMDXComponent=!0;const zIo={toc:[]},PIo="wrapper";function IIo(e){let{components:n,...t}=e;return(0,s.yg)(PIo,(0,p.A)({},zIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}IIo.isMDXComponent=!0;const RIo={toc:[]},WIo="wrapper";function SIo(e){let{components:n,...t}=e;return(0,s.yg)(WIo,(0,p.A)({},RIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}SIo.isMDXComponent=!0;const BIo={toc:[]},GIo="wrapper";function EIo(e){let{components:n,...t}=e;return(0,s.yg)(GIo,(0,p.A)({},BIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}EIo.isMDXComponent=!0;const OIo={toc:[]},UIo="wrapper";function FIo(e){let{components:n,...t}=e;return(0,s.yg)(UIo,(0,p.A)({},OIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}FIo.isMDXComponent=!0;const VIo={toc:[]},qIo="wrapper";function jIo(e){let{components:n,...t}=e;return(0,s.yg)(qIo,(0,p.A)({},VIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}jIo.isMDXComponent=!0;const HIo={toc:[]},YIo="wrapper";function QIo(e){let{components:n,...t}=e;return(0,s.yg)(YIo,(0,p.A)({},HIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QIo.isMDXComponent=!0;const $Io={toc:[]},KIo="wrapper";function JIo(e){let{components:n,...t}=e;return(0,s.yg)(KIo,(0,p.A)({},$Io,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}JIo.isMDXComponent=!0;const ZIo={toc:[]},eRo="wrapper";function nRo(e){let{components:n,...t}=e;return(0,s.yg)(eRo,(0,p.A)({},ZIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}nRo.isMDXComponent=!0;const tRo={toc:[]},oRo="wrapper";function pRo(e){let{components:n,...t}=e;return(0,s.yg)(oRo,(0,p.A)({},tRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}pRo.isMDXComponent=!0;const rRo={toc:[]},sRo="wrapper";function cRo(e){let{components:n,...t}=e;return(0,s.yg)(sRo,(0,p.A)({},rRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cRo.isMDXComponent=!0;const aRo={toc:[]},iRo="wrapper";function lRo(e){let{components:n,...t}=e;return(0,s.yg)(iRo,(0,p.A)({},aRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}lRo.isMDXComponent=!0;const uRo={toc:[]},mRo="wrapper";function yRo(e){let{components:n,...t}=e;return(0,s.yg)(mRo,(0,p.A)({},uRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}yRo.isMDXComponent=!0;const dRo={toc:[]},hRo="wrapper";function gRo(e){let{components:n,...t}=e;return(0,s.yg)(hRo,(0,p.A)({},dRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gRo.isMDXComponent=!0;const fRo={toc:[]},DRo="wrapper";function MRo(e){let{components:n,...t}=e;return(0,s.yg)(DRo,(0,p.A)({},fRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}MRo.isMDXComponent=!0;const XRo={toc:[]},_Ro="wrapper";function wRo(e){let{components:n,...t}=e;return(0,s.yg)(_Ro,(0,p.A)({},XRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wRo.isMDXComponent=!0;const TRo={toc:[]},CRo="wrapper";function xRo(e){let{components:n,...t}=e;return(0,s.yg)(CRo,(0,p.A)({},TRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}xRo.isMDXComponent=!0;const ARo={toc:[]},vRo="wrapper";function LRo(e){let{components:n,...t}=e;return(0,s.yg)(vRo,(0,p.A)({},ARo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LRo.isMDXComponent=!0;const bRo={toc:[]},NRo="wrapper";function kRo(e){let{components:n,...t}=e;return(0,s.yg)(NRo,(0,p.A)({},bRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}kRo.isMDXComponent=!0;const zRo={toc:[]},PRo="wrapper";function IRo(e){let{components:n,...t}=e;return(0,s.yg)(PRo,(0,p.A)({},zRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"MotionCanvas Shape properties"))}IRo.isMDXComponent=!0;const RRo={toc:[]},WRo="wrapper";function SRo(e){let{components:n,...t}=e;return(0,s.yg)(WRo,(0,p.A)({},RRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get position, rotation and scale from Matrix transformation as Shape properties"))}SRo.isMDXComponent=!0;const BRo={toc:[]},GRo="wrapper";function ERo(e){let{components:n,...t}=e;return(0,s.yg)(GRo,(0,p.A)({},BRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Matrix transformation"))}ERo.isMDXComponent=!0;const ORo={toc:[]},URo="wrapper";function FRo(e){let{components:n,...t}=e;return(0,s.yg)(URo,(0,p.A)({},ORo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," that can be used to build SVGDocument."))}FRo.isMDXComponent=!0;const VRo={toc:[]},qRo="wrapper";function jRo(e){let{components:n,...t}=e;return(0,s.yg)(qRo,(0,p.A)({},VRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse an SVG string as ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData"),"."))}jRo.isMDXComponent=!0;const HRo={toc:[]},YRo="wrapper";function QRo(e){let{components:n,...t}=e;return(0,s.yg)(YRo,(0,p.A)({},HRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"And SVG string to be parsed."))}QRo.isMDXComponent=!0;const $Ro={toc:[]},KRo="wrapper";function JRo(e){let{components:n,...t}=e;return(0,s.yg)(KRo,(0,p.A)({},$Ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}JRo.isMDXComponent=!0;const ZRo={toc:[]},eWo="wrapper";function nWo(e){let{components:n,...t}=e;return(0,s.yg)(eWo,(0,p.A)({},ZRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}nWo.isMDXComponent=!0;const tWo={toc:[]},oWo="wrapper";function pWo(e){let{components:n,...t}=e;return(0,s.yg)(oWo,(0,p.A)({},tWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pWo.isMDXComponent=!0;const rWo={toc:[]},sWo="wrapper";function cWo(e){let{components:n,...t}=e;return(0,s.yg)(sWo,(0,p.A)({},rWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}cWo.isMDXComponent=!0;const aWo={toc:[]},iWo="wrapper";function lWo(e){let{components:n,...t}=e;return(0,s.yg)(iWo,(0,p.A)({},aWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}lWo.isMDXComponent=!0;const uWo={toc:[]},mWo="wrapper";function yWo(e){let{components:n,...t}=e;return(0,s.yg)(mWo,(0,p.A)({},uWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}yWo.isMDXComponent=!0;const dWo={toc:[]},hWo="wrapper";function gWo(e){let{components:n,...t}=e;return(0,s.yg)(hWo,(0,p.A)({},dWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}gWo.isMDXComponent=!0;const fWo={toc:[]},DWo="wrapper";function MWo(e){let{components:n,...t}=e;return(0,s.yg)(DWo,(0,p.A)({},fWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}MWo.isMDXComponent=!0;const XWo={toc:[]},_Wo="wrapper";function wWo(e){let{components:n,...t}=e;return(0,s.yg)(_Wo,(0,p.A)({},XWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wWo.isMDXComponent=!0;const TWo={toc:[]},CWo="wrapper";function xWo(e){let{components:n,...t}=e;return(0,s.yg)(CWo,(0,p.A)({},TWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}xWo.isMDXComponent=!0;const AWo={toc:[]},vWo="wrapper";function LWo(e){let{components:n,...t}=e;return(0,s.yg)(vWo,(0,p.A)({},AWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}LWo.isMDXComponent=!0;const bWo={toc:[]},NWo="wrapper";function kWo(e){let{components:n,...t}=e;return(0,s.yg)(NWo,(0,p.A)({},bWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}kWo.isMDXComponent=!0;const zWo={toc:[]},PWo="wrapper";function IWo(e){let{components:n,...t}=e;return(0,s.yg)(PWo,(0,p.A)({},zWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}IWo.isMDXComponent=!0;const RWo={toc:[]},WWo="wrapper";function SWo(e){let{components:n,...t}=e;return(0,s.yg)(WWo,(0,p.A)({},RWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SWo.isMDXComponent=!0;const BWo={toc:[]},GWo="wrapper";function EWo(e){let{components:n,...t}=e;return(0,s.yg)(GWo,(0,p.A)({},BWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}EWo.isMDXComponent=!0;const OWo={toc:[]},UWo="wrapper";function FWo(e){let{components:n,...t}=e;return(0,s.yg)(UWo,(0,p.A)({},OWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}FWo.isMDXComponent=!0;const VWo={toc:[]},qWo="wrapper";function jWo(e){let{components:n,...t}=e;return(0,s.yg)(qWo,(0,p.A)({},VWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}jWo.isMDXComponent=!0;const HWo={toc:[]},YWo="wrapper";function QWo(e){let{components:n,...t}=e;return(0,s.yg)(YWo,(0,p.A)({},HWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}QWo.isMDXComponent=!0;const $Wo={toc:[]},KWo="wrapper";function JWo(e){let{components:n,...t}=e;return(0,s.yg)(KWo,(0,p.A)({},$Wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}JWo.isMDXComponent=!0;const ZWo={toc:[]},eSo="wrapper";function nSo(e){let{components:n,...t}=e;return(0,s.yg)(eSo,(0,p.A)({},ZWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}nSo.isMDXComponent=!0;const tSo={toc:[]},oSo="wrapper";function pSo(e){let{components:n,...t}=e;return(0,s.yg)(oSo,(0,p.A)({},tSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}pSo.isMDXComponent=!0;const rSo={toc:[]},sSo="wrapper";function cSo(e){let{components:n,...t}=e;return(0,s.yg)(sSo,(0,p.A)({},rSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}cSo.isMDXComponent=!0;const aSo={toc:[]},iSo="wrapper";function lSo(e){let{components:n,...t}=e;return(0,s.yg)(iSo,(0,p.A)({},aSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lSo.isMDXComponent=!0;const uSo={toc:[]},mSo="wrapper";function ySo(e){let{components:n,...t}=e;return(0,s.yg)(mSo,(0,p.A)({},uSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}ySo.isMDXComponent=!0;const dSo={toc:[]},hSo="wrapper";function gSo(e){let{components:n,...t}=e;return(0,s.yg)(hSo,(0,p.A)({},dSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}gSo.isMDXComponent=!0;const fSo={toc:[]},DSo="wrapper";function MSo(e){let{components:n,...t}=e;return(0,s.yg)(DSo,(0,p.A)({},fSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}MSo.isMDXComponent=!0;const XSo={toc:[]},_So="wrapper";function wSo(e){let{components:n,...t}=e;return(0,s.yg)(_So,(0,p.A)({},XSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wSo.isMDXComponent=!0;const TSo={toc:[]},CSo="wrapper";function xSo(e){let{components:n,...t}=e;return(0,s.yg)(CSo,(0,p.A)({},TSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}xSo.isMDXComponent=!0;const ASo={toc:[]},vSo="wrapper";function LSo(e){let{components:n,...t}=e;return(0,s.yg)(vSo,(0,p.A)({},ASo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}LSo.isMDXComponent=!0;const bSo={toc:[]},NSo="wrapper";function kSo(e){let{components:n,...t}=e;return(0,s.yg)(NSo,(0,p.A)({},bSo,t,{components:n,mdxType:"MDXLayout"}))}kSo.isMDXComponent=!0;const zSo={toc:[]},PSo="wrapper";function ISo(e){let{components:n,...t}=e;return(0,s.yg)(PSo,(0,p.A)({},zSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ISo.isMDXComponent=!0;const RSo={toc:[]},WSo="wrapper";function SSo(e){let{components:n,...t}=e;return(0,s.yg)(WSo,(0,p.A)({},RSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}SSo.isMDXComponent=!0;const BSo={toc:[]},GSo="wrapper";function ESo(e){let{components:n,...t}=e;return(0,s.yg)(GSo,(0,p.A)({},BSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}ESo.isMDXComponent=!0;const OSo={toc:[]},USo="wrapper";function FSo(e){let{components:n,...t}=e;return(0,s.yg)(USo,(0,p.A)({},OSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}FSo.isMDXComponent=!0;const VSo={toc:[]},qSo="wrapper";function jSo(e){let{components:n,...t}=e;return(0,s.yg)(qSo,(0,p.A)({},VSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}jSo.isMDXComponent=!0;const HSo={toc:[]},YSo="wrapper";function QSo(e){let{components:n,...t}=e;return(0,s.yg)(YSo,(0,p.A)({},HSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}QSo.isMDXComponent=!0;const $So={toc:[]},KSo="wrapper";function JSo(e){let{components:n,...t}=e;return(0,s.yg)(KSo,(0,p.A)({},$So,t,{components:n,mdxType:"MDXLayout"}))}JSo.isMDXComponent=!0;const ZSo={toc:[]},eBo="wrapper";function nBo(e){let{components:n,...t}=e;return(0,s.yg)(eBo,(0,p.A)({},ZSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}nBo.isMDXComponent=!0;const tBo={toc:[]},oBo="wrapper";function pBo(e){let{components:n,...t}=e;return(0,s.yg)(oBo,(0,p.A)({},tBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}pBo.isMDXComponent=!0;const rBo={toc:[]},sBo="wrapper";function cBo(e){let{components:n,...t}=e;return(0,s.yg)(sBo,(0,p.A)({},rBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}cBo.isMDXComponent=!0;const aBo={toc:[]},iBo="wrapper";function lBo(e){let{components:n,...t}=e;return(0,s.yg)(iBo,(0,p.A)({},aBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}lBo.isMDXComponent=!0;const uBo={toc:[]},mBo="wrapper";function yBo(e){let{components:n,...t}=e;return(0,s.yg)(mBo,(0,p.A)({},uBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}yBo.isMDXComponent=!0;const dBo={toc:[]},hBo="wrapper";function gBo(e){let{components:n,...t}=e;return(0,s.yg)(hBo,(0,p.A)({},dBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}gBo.isMDXComponent=!0;const fBo={toc:[]},DBo="wrapper";function MBo(e){let{components:n,...t}=e;return(0,s.yg)(DBo,(0,p.A)({},fBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}MBo.isMDXComponent=!0;const XBo={toc:[]},_Bo="wrapper";function wBo(e){let{components:n,...t}=e;return(0,s.yg)(_Bo,(0,p.A)({},XBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wBo.isMDXComponent=!0;const TBo={toc:[]},CBo="wrapper";function xBo(e){let{components:n,...t}=e;return(0,s.yg)(CBo,(0,p.A)({},TBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}xBo.isMDXComponent=!0;const ABo={toc:[]},vBo="wrapper";function LBo(e){let{components:n,...t}=e;return(0,s.yg)(vBo,(0,p.A)({},ABo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}LBo.isMDXComponent=!0;const bBo={toc:[]},NBo="wrapper";function kBo(e){let{components:n,...t}=e;return(0,s.yg)(NBo,(0,p.A)({},bBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}kBo.isMDXComponent=!0;const zBo={toc:[]},PBo="wrapper";function IBo(e){let{components:n,...t}=e;return(0,s.yg)(PBo,(0,p.A)({},zBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}IBo.isMDXComponent=!0;const RBo={toc:[]},WBo="wrapper";function SBo(e){let{components:n,...t}=e;return(0,s.yg)(WBo,(0,p.A)({},RBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}SBo.isMDXComponent=!0;const BBo={toc:[]},GBo="wrapper";function EBo(e){let{components:n,...t}=e;return(0,s.yg)(GBo,(0,p.A)({},BBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}EBo.isMDXComponent=!0;const OBo={toc:[]},UBo="wrapper";function FBo(e){let{components:n,...t}=e;return(0,s.yg)(UBo,(0,p.A)({},OBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}FBo.isMDXComponent=!0;const VBo={toc:[]},qBo="wrapper";function jBo(e){let{components:n,...t}=e;return(0,s.yg)(qBo,(0,p.A)({},VBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}jBo.isMDXComponent=!0;const HBo={toc:[]},YBo="wrapper";function QBo(e){let{components:n,...t}=e;return(0,s.yg)(YBo,(0,p.A)({},HBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}QBo.isMDXComponent=!0;const $Bo={toc:[]},KBo="wrapper";function JBo(e){let{components:n,...t}=e;return(0,s.yg)(KBo,(0,p.A)({},$Bo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}JBo.isMDXComponent=!0;const ZBo={toc:[]},eGo="wrapper";function nGo(e){let{components:n,...t}=e;return(0,s.yg)(eGo,(0,p.A)({},ZBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}nGo.isMDXComponent=!0;const tGo={toc:[]},oGo="wrapper";function pGo(e){let{components:n,...t}=e;return(0,s.yg)(oGo,(0,p.A)({},tGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}pGo.isMDXComponent=!0;const rGo={toc:[]},sGo="wrapper";function cGo(e){let{components:n,...t}=e;return(0,s.yg)(sGo,(0,p.A)({},rGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}cGo.isMDXComponent=!0;const aGo={toc:[]},iGo="wrapper";function lGo(e){let{components:n,...t}=e;return(0,s.yg)(iGo,(0,p.A)({},aGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}lGo.isMDXComponent=!0;const uGo={toc:[]},mGo="wrapper";function yGo(e){let{components:n,...t}=e;return(0,s.yg)(mGo,(0,p.A)({},uGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}yGo.isMDXComponent=!0;const dGo={toc:[]},hGo="wrapper";function gGo(e){let{components:n,...t}=e;return(0,s.yg)(hGo,(0,p.A)({},dGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}gGo.isMDXComponent=!0;const fGo={toc:[]},DGo="wrapper";function MGo(e){let{components:n,...t}=e;return(0,s.yg)(DGo,(0,p.A)({},fGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}MGo.isMDXComponent=!0;const XGo={toc:[]},_Go="wrapper";function wGo(e){let{components:n,...t}=e;return(0,s.yg)(_Go,(0,p.A)({},XGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}wGo.isMDXComponent=!0;const TGo={toc:[]},CGo="wrapper";function xGo(e){let{components:n,...t}=e;return(0,s.yg)(CGo,(0,p.A)({},TGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}xGo.isMDXComponent=!0;const AGo={toc:[]},vGo="wrapper";function LGo(e){let{components:n,...t}=e;return(0,s.yg)(vGo,(0,p.A)({},AGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}LGo.isMDXComponent=!0;const bGo={toc:[]},NGo="wrapper";function kGo(e){let{components:n,...t}=e;return(0,s.yg)(NGo,(0,p.A)({},bGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kGo.isMDXComponent=!0;const zGo={toc:[]},PGo="wrapper";function IGo(e){let{components:n,...t}=e;return(0,s.yg)(PGo,(0,p.A)({},zGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}IGo.isMDXComponent=!0;const RGo={toc:[]},WGo="wrapper";function SGo(e){let{components:n,...t}=e;return(0,s.yg)(WGo,(0,p.A)({},RGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}SGo.isMDXComponent=!0;const BGo={toc:[]},GGo="wrapper";function EGo(e){let{components:n,...t}=e;return(0,s.yg)(GGo,(0,p.A)({},BGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}EGo.isMDXComponent=!0;const OGo={toc:[]},UGo="wrapper";function FGo(e){let{components:n,...t}=e;return(0,s.yg)(UGo,(0,p.A)({},OGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}FGo.isMDXComponent=!0;const VGo={toc:[]},qGo="wrapper";function jGo(e){let{components:n,...t}=e;return(0,s.yg)(qGo,(0,p.A)({},VGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jGo.isMDXComponent=!0;const HGo={toc:[]},YGo="wrapper";function QGo(e){let{components:n,...t}=e;return(0,s.yg)(YGo,(0,p.A)({},HGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}QGo.isMDXComponent=!0;const $Go={toc:[]},KGo="wrapper";function JGo(e){let{components:n,...t}=e;return(0,s.yg)(KGo,(0,p.A)({},$Go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}JGo.isMDXComponent=!0;const ZGo={toc:[]},eEo="wrapper";function nEo(e){let{components:n,...t}=e;return(0,s.yg)(eEo,(0,p.A)({},ZGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}nEo.isMDXComponent=!0;const tEo={toc:[]},oEo="wrapper";function pEo(e){let{components:n,...t}=e;return(0,s.yg)(oEo,(0,p.A)({},tEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}pEo.isMDXComponent=!0;const rEo={toc:[]},sEo="wrapper";function cEo(e){let{components:n,...t}=e;return(0,s.yg)(sEo,(0,p.A)({},rEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cEo.isMDXComponent=!0;const aEo={toc:[]},iEo="wrapper";function lEo(e){let{components:n,...t}=e;return(0,s.yg)(iEo,(0,p.A)({},aEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}lEo.isMDXComponent=!0;const uEo={toc:[]},mEo="wrapper";function yEo(e){let{components:n,...t}=e;return(0,s.yg)(mEo,(0,p.A)({},uEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yEo.isMDXComponent=!0;const dEo={toc:[]},hEo="wrapper";function gEo(e){let{components:n,...t}=e;return(0,s.yg)(hEo,(0,p.A)({},dEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}gEo.isMDXComponent=!0;const fEo={toc:[]},DEo="wrapper";function MEo(e){let{components:n,...t}=e;return(0,s.yg)(DEo,(0,p.A)({},fEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}MEo.isMDXComponent=!0;const XEo={toc:[]},_Eo="wrapper";function wEo(e){let{components:n,...t}=e;return(0,s.yg)(_Eo,(0,p.A)({},XEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wEo.isMDXComponent=!0;const TEo={toc:[]},CEo="wrapper";function xEo(e){let{components:n,...t}=e;return(0,s.yg)(CEo,(0,p.A)({},TEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xEo.isMDXComponent=!0;const AEo={toc:[]},vEo="wrapper";function LEo(e){let{components:n,...t}=e;return(0,s.yg)(vEo,(0,p.A)({},AEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}LEo.isMDXComponent=!0;const bEo={toc:[]},NEo="wrapper";function kEo(e){let{components:n,...t}=e;return(0,s.yg)(NEo,(0,p.A)({},bEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kEo.isMDXComponent=!0;const zEo={toc:[]},PEo="wrapper";function IEo(e){let{components:n,...t}=e;return(0,s.yg)(PEo,(0,p.A)({},zEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}IEo.isMDXComponent=!0;const REo={toc:[]},WEo="wrapper";function SEo(e){let{components:n,...t}=e;return(0,s.yg)(WEo,(0,p.A)({},REo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}SEo.isMDXComponent=!0;const BEo={toc:[]},GEo="wrapper";function EEo(e){let{components:n,...t}=e;return(0,s.yg)(GEo,(0,p.A)({},BEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}EEo.isMDXComponent=!0;const OEo={toc:[]},UEo="wrapper";function FEo(e){let{components:n,...t}=e;return(0,s.yg)(UEo,(0,p.A)({},OEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}FEo.isMDXComponent=!0;const VEo={toc:[]},qEo="wrapper";function jEo(e){let{components:n,...t}=e;return(0,s.yg)(qEo,(0,p.A)({},VEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}jEo.isMDXComponent=!0;const HEo={toc:[]},YEo="wrapper";function QEo(e){let{components:n,...t}=e;return(0,s.yg)(YEo,(0,p.A)({},HEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}QEo.isMDXComponent=!0;const $Eo={toc:[]},KEo="wrapper";function JEo(e){let{components:n,...t}=e;return(0,s.yg)(KEo,(0,p.A)({},$Eo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}JEo.isMDXComponent=!0;const ZEo={toc:[]},eOo="wrapper";function nOo(e){let{components:n,...t}=e;return(0,s.yg)(eOo,(0,p.A)({},ZEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nOo.isMDXComponent=!0;const tOo={toc:[]},oOo="wrapper";function pOo(e){let{components:n,...t}=e;return(0,s.yg)(oOo,(0,p.A)({},tOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}pOo.isMDXComponent=!0;const rOo={toc:[]},sOo="wrapper";function cOo(e){let{components:n,...t}=e;return(0,s.yg)(sOo,(0,p.A)({},rOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}cOo.isMDXComponent=!0;const aOo={toc:[]},iOo="wrapper";function lOo(e){let{components:n,...t}=e;return(0,s.yg)(iOo,(0,p.A)({},aOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lOo.isMDXComponent=!0;const uOo={toc:[]},mOo="wrapper";function yOo(e){let{components:n,...t}=e;return(0,s.yg)(mOo,(0,p.A)({},uOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}yOo.isMDXComponent=!0;const dOo={toc:[]},hOo="wrapper";function gOo(e){let{components:n,...t}=e;return(0,s.yg)(hOo,(0,p.A)({},dOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}gOo.isMDXComponent=!0;const fOo={toc:[]},DOo="wrapper";function MOo(e){let{components:n,...t}=e;return(0,s.yg)(DOo,(0,p.A)({},fOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}MOo.isMDXComponent=!0;const XOo={toc:[]},_Oo="wrapper";function wOo(e){let{components:n,...t}=e;return(0,s.yg)(_Oo,(0,p.A)({},XOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wOo.isMDXComponent=!0;const TOo={toc:[]},COo="wrapper";function xOo(e){let{components:n,...t}=e;return(0,s.yg)(COo,(0,p.A)({},TOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}xOo.isMDXComponent=!0;const AOo={toc:[]},vOo="wrapper";function LOo(e){let{components:n,...t}=e;return(0,s.yg)(vOo,(0,p.A)({},AOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}LOo.isMDXComponent=!0;const bOo={toc:[]},NOo="wrapper";function kOo(e){let{components:n,...t}=e;return(0,s.yg)(NOo,(0,p.A)({},bOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}kOo.isMDXComponent=!0;const zOo={toc:[]},POo="wrapper";function IOo(e){let{components:n,...t}=e;return(0,s.yg)(POo,(0,p.A)({},zOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}IOo.isMDXComponent=!0;const ROo={toc:[]},WOo="wrapper";function SOo(e){let{components:n,...t}=e;return(0,s.yg)(WOo,(0,p.A)({},ROo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}SOo.isMDXComponent=!0;const BOo={toc:[]},GOo="wrapper";function EOo(e){let{components:n,...t}=e;return(0,s.yg)(GOo,(0,p.A)({},BOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}EOo.isMDXComponent=!0;const OOo={toc:[]},UOo="wrapper";function FOo(e){let{components:n,...t}=e;return(0,s.yg)(UOo,(0,p.A)({},OOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}FOo.isMDXComponent=!0;const VOo={toc:[]},qOo="wrapper";function jOo(e){let{components:n,...t}=e;return(0,s.yg)(qOo,(0,p.A)({},VOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jOo.isMDXComponent=!0;const HOo={toc:[]},YOo="wrapper";function QOo(e){let{components:n,...t}=e;return(0,s.yg)(YOo,(0,p.A)({},HOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}QOo.isMDXComponent=!0;const $Oo={toc:[]},KOo="wrapper";function JOo(e){let{components:n,...t}=e;return(0,s.yg)(KOo,(0,p.A)({},$Oo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}JOo.isMDXComponent=!0;const ZOo={toc:[]},eUo="wrapper";function nUo(e){let{components:n,...t}=e;return(0,s.yg)(eUo,(0,p.A)({},ZOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nUo.isMDXComponent=!0;const tUo={toc:[]},oUo="wrapper";function pUo(e){let{components:n,...t}=e;return(0,s.yg)(oUo,(0,p.A)({},tUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}pUo.isMDXComponent=!0;const rUo={toc:[]},sUo="wrapper";function cUo(e){let{components:n,...t}=e;return(0,s.yg)(sUo,(0,p.A)({},rUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cUo.isMDXComponent=!0;const aUo={toc:[]},iUo="wrapper";function lUo(e){let{components:n,...t}=e;return(0,s.yg)(iUo,(0,p.A)({},aUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}lUo.isMDXComponent=!0;const uUo={toc:[]},mUo="wrapper";function yUo(e){let{components:n,...t}=e;return(0,s.yg)(mUo,(0,p.A)({},uUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}yUo.isMDXComponent=!0;const dUo={toc:[]},hUo="wrapper";function gUo(e){let{components:n,...t}=e;return(0,s.yg)(hUo,(0,p.A)({},dUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}gUo.isMDXComponent=!0;const fUo={toc:[]},DUo="wrapper";function MUo(e){let{components:n,...t}=e;return(0,s.yg)(DUo,(0,p.A)({},fUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}MUo.isMDXComponent=!0;const XUo={toc:[]},_Uo="wrapper";function wUo(e){let{components:n,...t}=e;return(0,s.yg)(_Uo,(0,p.A)({},XUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}wUo.isMDXComponent=!0;const TUo={toc:[]},CUo="wrapper";function xUo(e){let{components:n,...t}=e;return(0,s.yg)(CUo,(0,p.A)({},TUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xUo.isMDXComponent=!0;const AUo={toc:[]},vUo="wrapper";function LUo(e){let{components:n,...t}=e;return(0,s.yg)(vUo,(0,p.A)({},AUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LUo.isMDXComponent=!0;const bUo={toc:[]},NUo="wrapper";function kUo(e){let{components:n,...t}=e;return(0,s.yg)(NUo,(0,p.A)({},bUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}kUo.isMDXComponent=!0;const zUo={toc:[]},PUo="wrapper";function IUo(e){let{components:n,...t}=e;return(0,s.yg)(PUo,(0,p.A)({},zUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}IUo.isMDXComponent=!0;const RUo={toc:[]},WUo="wrapper";function SUo(e){let{components:n,...t}=e;return(0,s.yg)(WUo,(0,p.A)({},RUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}SUo.isMDXComponent=!0;const BUo={toc:[]},GUo="wrapper";function EUo(e){let{components:n,...t}=e;return(0,s.yg)(GUo,(0,p.A)({},BUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}EUo.isMDXComponent=!0;const OUo={toc:[]},UUo="wrapper";function FUo(e){let{components:n,...t}=e;return(0,s.yg)(UUo,(0,p.A)({},OUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}FUo.isMDXComponent=!0;const VUo={toc:[]},qUo="wrapper";function jUo(e){let{components:n,...t}=e;return(0,s.yg)(qUo,(0,p.A)({},VUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}jUo.isMDXComponent=!0;const HUo={toc:[]},YUo="wrapper";function QUo(e){let{components:n,...t}=e;return(0,s.yg)(YUo,(0,p.A)({},HUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}QUo.isMDXComponent=!0;const $Uo={toc:[]},KUo="wrapper";function JUo(e){let{components:n,...t}=e;return(0,s.yg)(KUo,(0,p.A)({},$Uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}JUo.isMDXComponent=!0;const ZUo={toc:[]},eFo="wrapper";function nFo(e){let{components:n,...t}=e;return(0,s.yg)(eFo,(0,p.A)({},ZUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}nFo.isMDXComponent=!0;const tFo={toc:[]},oFo="wrapper";function pFo(e){let{components:n,...t}=e;return(0,s.yg)(oFo,(0,p.A)({},tFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}pFo.isMDXComponent=!0;const rFo={toc:[]},sFo="wrapper";function cFo(e){let{components:n,...t}=e;return(0,s.yg)(sFo,(0,p.A)({},rFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cFo.isMDXComponent=!0;const aFo={toc:[]},iFo="wrapper";function lFo(e){let{components:n,...t}=e;return(0,s.yg)(iFo,(0,p.A)({},aFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}lFo.isMDXComponent=!0;const uFo={toc:[]},mFo="wrapper";function yFo(e){let{components:n,...t}=e;return(0,s.yg)(mFo,(0,p.A)({},uFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yFo.isMDXComponent=!0;const dFo={toc:[]},hFo="wrapper";function gFo(e){let{components:n,...t}=e;return(0,s.yg)(hFo,(0,p.A)({},dFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}gFo.isMDXComponent=!0;const fFo={toc:[]},DFo="wrapper";function MFo(e){let{components:n,...t}=e;return(0,s.yg)(DFo,(0,p.A)({},fFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}MFo.isMDXComponent=!0;const XFo={toc:[]},_Fo="wrapper";function wFo(e){let{components:n,...t}=e;return(0,s.yg)(_Fo,(0,p.A)({},XFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}wFo.isMDXComponent=!0;const TFo={toc:[]},CFo="wrapper";function xFo(e){let{components:n,...t}=e;return(0,s.yg)(CFo,(0,p.A)({},TFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}xFo.isMDXComponent=!0;const AFo={toc:[]},vFo="wrapper";function LFo(e){let{components:n,...t}=e;return(0,s.yg)(vFo,(0,p.A)({},AFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}LFo.isMDXComponent=!0;const bFo={toc:[]},NFo="wrapper";function kFo(e){let{components:n,...t}=e;return(0,s.yg)(NFo,(0,p.A)({},bFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}kFo.isMDXComponent=!0;const zFo={toc:[]},PFo="wrapper";function IFo(e){let{components:n,...t}=e;return(0,s.yg)(PFo,(0,p.A)({},zFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}IFo.isMDXComponent=!0;const RFo={toc:[]},WFo="wrapper";function SFo(e){let{components:n,...t}=e;return(0,s.yg)(WFo,(0,p.A)({},RFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}SFo.isMDXComponent=!0;const BFo={toc:[]},GFo="wrapper";function EFo(e){let{components:n,...t}=e;return(0,s.yg)(GFo,(0,p.A)({},BFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}EFo.isMDXComponent=!0;const OFo={toc:[]},UFo="wrapper";function FFo(e){let{components:n,...t}=e;return(0,s.yg)(UFo,(0,p.A)({},OFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}FFo.isMDXComponent=!0;const VFo={toc:[]},qFo="wrapper";function jFo(e){let{components:n,...t}=e;return(0,s.yg)(qFo,(0,p.A)({},VFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}jFo.isMDXComponent=!0;const HFo={toc:[]},YFo="wrapper";function QFo(e){let{components:n,...t}=e;return(0,s.yg)(YFo,(0,p.A)({},HFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}QFo.isMDXComponent=!0;const $Fo={toc:[]},KFo="wrapper";function JFo(e){let{components:n,...t}=e;return(0,s.yg)(KFo,(0,p.A)({},$Fo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}JFo.isMDXComponent=!0;const ZFo={toc:[]},eVo="wrapper";function nVo(e){let{components:n,...t}=e;return(0,s.yg)(eVo,(0,p.A)({},ZFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}nVo.isMDXComponent=!0;const tVo={toc:[]},oVo="wrapper";function pVo(e){let{components:n,...t}=e;return(0,s.yg)(oVo,(0,p.A)({},tVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}pVo.isMDXComponent=!0;const rVo={toc:[]},sVo="wrapper";function cVo(e){let{components:n,...t}=e;return(0,s.yg)(sVo,(0,p.A)({},rVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}cVo.isMDXComponent=!0;const aVo={toc:[]},iVo="wrapper";function lVo(e){let{components:n,...t}=e;return(0,s.yg)(iVo,(0,p.A)({},aVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lVo.isMDXComponent=!0;const uVo={toc:[]},mVo="wrapper";function yVo(e){let{components:n,...t}=e;return(0,s.yg)(mVo,(0,p.A)({},uVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}yVo.isMDXComponent=!0;const dVo={toc:[]},hVo="wrapper";function gVo(e){let{components:n,...t}=e;return(0,s.yg)(hVo,(0,p.A)({},dVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}gVo.isMDXComponent=!0;const fVo={toc:[]},DVo="wrapper";function MVo(e){let{components:n,...t}=e;return(0,s.yg)(DVo,(0,p.A)({},fVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}MVo.isMDXComponent=!0;const XVo={toc:[]},_Vo="wrapper";function wVo(e){let{components:n,...t}=e;return(0,s.yg)(_Vo,(0,p.A)({},XVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}wVo.isMDXComponent=!0;const TVo={toc:[]},CVo="wrapper";function xVo(e){let{components:n,...t}=e;return(0,s.yg)(CVo,(0,p.A)({},TVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}xVo.isMDXComponent=!0;const AVo={toc:[]},vVo="wrapper";function LVo(e){let{components:n,...t}=e;return(0,s.yg)(vVo,(0,p.A)({},AVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}LVo.isMDXComponent=!0;const bVo={toc:[]},NVo="wrapper";function kVo(e){let{components:n,...t}=e;return(0,s.yg)(NVo,(0,p.A)({},bVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}kVo.isMDXComponent=!0;const zVo={toc:[]},PVo="wrapper";function IVo(e){let{components:n,...t}=e;return(0,s.yg)(PVo,(0,p.A)({},zVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}IVo.isMDXComponent=!0;const RVo={toc:[]},WVo="wrapper";function SVo(e){let{components:n,...t}=e;return(0,s.yg)(WVo,(0,p.A)({},RVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}SVo.isMDXComponent=!0;const BVo={toc:[]},GVo="wrapper";function EVo(e){let{components:n,...t}=e;return(0,s.yg)(GVo,(0,p.A)({},BVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}EVo.isMDXComponent=!0;const OVo={toc:[]},UVo="wrapper";function FVo(e){let{components:n,...t}=e;return(0,s.yg)(UVo,(0,p.A)({},OVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}FVo.isMDXComponent=!0;const VVo={toc:[]},qVo="wrapper";function jVo(e){let{components:n,...t}=e;return(0,s.yg)(qVo,(0,p.A)({},VVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}jVo.isMDXComponent=!0;const HVo={toc:[]},YVo="wrapper";function QVo(e){let{components:n,...t}=e;return(0,s.yg)(YVo,(0,p.A)({},HVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}QVo.isMDXComponent=!0;const $Vo={toc:[]},KVo="wrapper";function JVo(e){let{components:n,...t}=e;return(0,s.yg)(KVo,(0,p.A)({},$Vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}JVo.isMDXComponent=!0;const ZVo={toc:[]},eqo="wrapper";function nqo(e){let{components:n,...t}=e;return(0,s.yg)(eqo,(0,p.A)({},ZVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nqo.isMDXComponent=!0;const tqo={toc:[]},oqo="wrapper";function pqo(e){let{components:n,...t}=e;return(0,s.yg)(oqo,(0,p.A)({},tqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}pqo.isMDXComponent=!0;const rqo={toc:[]},sqo="wrapper";function cqo(e){let{components:n,...t}=e;return(0,s.yg)(sqo,(0,p.A)({},rqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}cqo.isMDXComponent=!0;const aqo={toc:[]},iqo="wrapper";function lqo(e){let{components:n,...t}=e;return(0,s.yg)(iqo,(0,p.A)({},aqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}lqo.isMDXComponent=!0;const uqo={toc:[]},mqo="wrapper";function yqo(e){let{components:n,...t}=e;return(0,s.yg)(mqo,(0,p.A)({},uqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}yqo.isMDXComponent=!0;const dqo={toc:[]},hqo="wrapper";function gqo(e){let{components:n,...t}=e;return(0,s.yg)(hqo,(0,p.A)({},dqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}gqo.isMDXComponent=!0;const fqo={toc:[]},Dqo="wrapper";function Mqo(e){let{components:n,...t}=e;return(0,s.yg)(Dqo,(0,p.A)({},fqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Mqo.isMDXComponent=!0;const Xqo={toc:[]},_qo="wrapper";function wqo(e){let{components:n,...t}=e;return(0,s.yg)(_qo,(0,p.A)({},Xqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}wqo.isMDXComponent=!0;const Tqo={toc:[]},Cqo="wrapper";function xqo(e){let{components:n,...t}=e;return(0,s.yg)(Cqo,(0,p.A)({},Tqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}xqo.isMDXComponent=!0;const Aqo={toc:[]},vqo="wrapper";function Lqo(e){let{components:n,...t}=e;return(0,s.yg)(vqo,(0,p.A)({},Aqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Lqo.isMDXComponent=!0;const bqo={toc:[]},Nqo="wrapper";function kqo(e){let{components:n,...t}=e;return(0,s.yg)(Nqo,(0,p.A)({},bqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kqo.isMDXComponent=!0;const zqo={toc:[]},Pqo="wrapper";function Iqo(e){let{components:n,...t}=e;return(0,s.yg)(Pqo,(0,p.A)({},zqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Iqo.isMDXComponent=!0;const Rqo={toc:[]},Wqo="wrapper";function Sqo(e){let{components:n,...t}=e;return(0,s.yg)(Wqo,(0,p.A)({},Rqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Sqo.isMDXComponent=!0;const Bqo={toc:[]},Gqo="wrapper";function Eqo(e){let{components:n,...t}=e;return(0,s.yg)(Gqo,(0,p.A)({},Bqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Eqo.isMDXComponent=!0;const Oqo={toc:[]},Uqo="wrapper";function Fqo(e){let{components:n,...t}=e;return(0,s.yg)(Uqo,(0,p.A)({},Oqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Fqo.isMDXComponent=!0;const Vqo={toc:[]},qqo="wrapper";function jqo(e){let{components:n,...t}=e;return(0,s.yg)(qqo,(0,p.A)({},Vqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}jqo.isMDXComponent=!0;const Hqo={toc:[]},Yqo="wrapper";function Qqo(e){let{components:n,...t}=e;return(0,s.yg)(Yqo,(0,p.A)({},Hqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Qqo.isMDXComponent=!0;const $qo={toc:[]},Kqo="wrapper";function Jqo(e){let{components:n,...t}=e;return(0,s.yg)(Kqo,(0,p.A)({},$qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Jqo.isMDXComponent=!0;const Zqo={toc:[]},ejo="wrapper";function njo(e){let{components:n,...t}=e;return(0,s.yg)(ejo,(0,p.A)({},Zqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}njo.isMDXComponent=!0;const tjo={toc:[]},ojo="wrapper";function pjo(e){let{components:n,...t}=e;return(0,s.yg)(ojo,(0,p.A)({},tjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}pjo.isMDXComponent=!0;const rjo={toc:[]},sjo="wrapper";function cjo(e){let{components:n,...t}=e;return(0,s.yg)(sjo,(0,p.A)({},rjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}cjo.isMDXComponent=!0;const ajo={toc:[]},ijo="wrapper";function ljo(e){let{components:n,...t}=e;return(0,s.yg)(ijo,(0,p.A)({},ajo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defining knots using the ",(0,s.yg)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.yg)("p",null,"Defining knots with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.yg)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}ljo.isMDXComponent=!0;const ujo={toc:[]},mjo="wrapper";function yjo(e){let{components:n,...t}=e;return(0,s.yg)(mjo,(0,p.A)({},ujo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a smooth line through a number of points."))}yjo.isMDXComponent=!0;const djo={toc:[]},hjo="wrapper";function gjo(e){let{components:n,...t}=e;return(0,s.yg)(hjo,(0,p.A)({},djo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}gjo.isMDXComponent=!0;const fjo={toc:[]},Djo="wrapper";function Mjo(e){let{components:n,...t}=e;return(0,s.yg)(Djo,(0,p.A)({},fjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Mjo.isMDXComponent=!0;const Xjo={toc:[]},_jo="wrapper";function wjo(e){let{components:n,...t}=e;return(0,s.yg)(_jo,(0,p.A)({},Xjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wjo.isMDXComponent=!0;const Tjo={toc:[]},Cjo="wrapper";function xjo(e){let{components:n,...t}=e;return(0,s.yg)(Cjo,(0,p.A)({},Tjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}xjo.isMDXComponent=!0;const Ajo={toc:[]},vjo="wrapper";function Ljo(e){let{components:n,...t}=e;return(0,s.yg)(vjo,(0,p.A)({},Ajo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Ljo.isMDXComponent=!0;const bjo={toc:[]},Njo="wrapper";function kjo(e){let{components:n,...t}=e;return(0,s.yg)(Njo,(0,p.A)({},bjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}kjo.isMDXComponent=!0;const zjo={toc:[]},Pjo="wrapper";function Ijo(e){let{components:n,...t}=e;return(0,s.yg)(Pjo,(0,p.A)({},zjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ijo.isMDXComponent=!0;const Rjo={toc:[]},Wjo="wrapper";function Sjo(e){let{components:n,...t}=e;return(0,s.yg)(Wjo,(0,p.A)({},Rjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Sjo.isMDXComponent=!0;const Bjo={toc:[]},Gjo="wrapper";function Ejo(e){let{components:n,...t}=e;return(0,s.yg)(Gjo,(0,p.A)({},Bjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ejo.isMDXComponent=!0;const Ojo={toc:[]},Ujo="wrapper";function Fjo(e){let{components:n,...t}=e;return(0,s.yg)(Ujo,(0,p.A)({},Ojo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Fjo.isMDXComponent=!0;const Vjo={toc:[]},qjo="wrapper";function jjo(e){let{components:n,...t}=e;return(0,s.yg)(qjo,(0,p.A)({},Vjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}jjo.isMDXComponent=!0;const Hjo={toc:[]},Yjo="wrapper";function Qjo(e){let{components:n,...t}=e;return(0,s.yg)(Yjo,(0,p.A)({},Hjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Qjo.isMDXComponent=!0;const $jo={toc:[]},Kjo="wrapper";function Jjo(e){let{components:n,...t}=e;return(0,s.yg)(Kjo,(0,p.A)({},$jo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Jjo.isMDXComponent=!0;const Zjo={toc:[]},eHo="wrapper";function nHo(e){let{components:n,...t}=e;return(0,s.yg)(eHo,(0,p.A)({},Zjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}nHo.isMDXComponent=!0;const tHo={toc:[]},oHo="wrapper";function pHo(e){let{components:n,...t}=e;return(0,s.yg)(oHo,(0,p.A)({},tHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pHo.isMDXComponent=!0;const rHo={toc:[]},sHo="wrapper";function cHo(e){let{components:n,...t}=e;return(0,s.yg)(sHo,(0,p.A)({},rHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cHo.isMDXComponent=!0;const aHo={toc:[]},iHo="wrapper";function lHo(e){let{components:n,...t}=e;return(0,s.yg)(iHo,(0,p.A)({},aHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}lHo.isMDXComponent=!0;const uHo={toc:[]},mHo="wrapper";function yHo(e){let{components:n,...t}=e;return(0,s.yg)(mHo,(0,p.A)({},uHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}yHo.isMDXComponent=!0;const dHo={toc:[]},hHo="wrapper";function gHo(e){let{components:n,...t}=e;return(0,s.yg)(hHo,(0,p.A)({},dHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}gHo.isMDXComponent=!0;const fHo={toc:[]},DHo="wrapper";function MHo(e){let{components:n,...t}=e;return(0,s.yg)(DHo,(0,p.A)({},fHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}MHo.isMDXComponent=!0;const XHo={toc:[]},_Ho="wrapper";function wHo(e){let{components:n,...t}=e;return(0,s.yg)(_Ho,(0,p.A)({},XHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wHo.isMDXComponent=!0;const THo={toc:[]},CHo="wrapper";function xHo(e){let{components:n,...t}=e;return(0,s.yg)(CHo,(0,p.A)({},THo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}xHo.isMDXComponent=!0;const AHo={toc:[]},vHo="wrapper";function LHo(e){let{components:n,...t}=e;return(0,s.yg)(vHo,(0,p.A)({},AHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LHo.isMDXComponent=!0;const bHo={toc:[]},NHo="wrapper";function kHo(e){let{components:n,...t}=e;return(0,s.yg)(NHo,(0,p.A)({},bHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}kHo.isMDXComponent=!0;const zHo={toc:[]},PHo="wrapper";function IHo(e){let{components:n,...t}=e;return(0,s.yg)(PHo,(0,p.A)({},zHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}IHo.isMDXComponent=!0;const RHo={toc:[]},WHo="wrapper";function SHo(e){let{components:n,...t}=e;return(0,s.yg)(WHo,(0,p.A)({},RHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}SHo.isMDXComponent=!0;const BHo={toc:[]},GHo="wrapper";function EHo(e){let{components:n,...t}=e;return(0,s.yg)(GHo,(0,p.A)({},BHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}EHo.isMDXComponent=!0;const OHo={toc:[]},UHo="wrapper";function FHo(e){let{components:n,...t}=e;return(0,s.yg)(UHo,(0,p.A)({},OHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}FHo.isMDXComponent=!0;const VHo={toc:[]},qHo="wrapper";function jHo(e){let{components:n,...t}=e;return(0,s.yg)(qHo,(0,p.A)({},VHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}jHo.isMDXComponent=!0;const HHo={toc:[]},YHo="wrapper";function QHo(e){let{components:n,...t}=e;return(0,s.yg)(YHo,(0,p.A)({},HHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}QHo.isMDXComponent=!0;const $Ho={toc:[]},KHo="wrapper";function JHo(e){let{components:n,...t}=e;return(0,s.yg)(KHo,(0,p.A)({},$Ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}JHo.isMDXComponent=!0;const ZHo={toc:[]},eYo="wrapper";function nYo(e){let{components:n,...t}=e;return(0,s.yg)(eYo,(0,p.A)({},ZHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}nYo.isMDXComponent=!0;const tYo={toc:[]},oYo="wrapper";function pYo(e){let{components:n,...t}=e;return(0,s.yg)(oYo,(0,p.A)({},tYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."))}pYo.isMDXComponent=!0;const rYo={toc:[]},sYo="wrapper";function cYo(e){let{components:n,...t}=e;return(0,s.yg)(sYo,(0,p.A)({},rYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}cYo.isMDXComponent=!0;const aYo={toc:[]},iYo="wrapper";function lYo(e){let{components:n,...t}=e;return(0,s.yg)(iYo,(0,p.A)({},aYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lYo.isMDXComponent=!0;const uYo={toc:[]},mYo="wrapper";function yYo(e){let{components:n,...t}=e;return(0,s.yg)(mYo,(0,p.A)({},uYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}yYo.isMDXComponent=!0;const dYo={toc:[]},hYo="wrapper";function gYo(e){let{components:n,...t}=e;return(0,s.yg)(hYo,(0,p.A)({},dYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}gYo.isMDXComponent=!0;const fYo={toc:[]},DYo="wrapper";function MYo(e){let{components:n,...t}=e;return(0,s.yg)(DYo,(0,p.A)({},fYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}MYo.isMDXComponent=!0;const XYo={toc:[]},_Yo="wrapper";function wYo(e){let{components:n,...t}=e;return(0,s.yg)(_Yo,(0,p.A)({},XYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wYo.isMDXComponent=!0;const TYo={toc:[]},CYo="wrapper";function xYo(e){let{components:n,...t}=e;return(0,s.yg)(CYo,(0,p.A)({},TYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}xYo.isMDXComponent=!0;const AYo={toc:[]},vYo="wrapper";function LYo(e){let{components:n,...t}=e;return(0,s.yg)(vYo,(0,p.A)({},AYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}LYo.isMDXComponent=!0;const bYo={toc:[]},NYo="wrapper";function kYo(e){let{components:n,...t}=e;return(0,s.yg)(NYo,(0,p.A)({},bYo,t,{components:n,mdxType:"MDXLayout"}))}kYo.isMDXComponent=!0;const zYo={toc:[]},PYo="wrapper";function IYo(e){let{components:n,...t}=e;return(0,s.yg)(PYo,(0,p.A)({},zYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}IYo.isMDXComponent=!0;const RYo={toc:[]},WYo="wrapper";function SYo(e){let{components:n,...t}=e;return(0,s.yg)(WYo,(0,p.A)({},RYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}SYo.isMDXComponent=!0;const BYo={toc:[]},GYo="wrapper";function EYo(e){let{components:n,...t}=e;return(0,s.yg)(GYo,(0,p.A)({},BYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}EYo.isMDXComponent=!0;const OYo={toc:[]},UYo="wrapper";function FYo(e){let{components:n,...t}=e;return(0,s.yg)(UYo,(0,p.A)({},OYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}FYo.isMDXComponent=!0;const VYo={toc:[]},qYo="wrapper";function jYo(e){let{components:n,...t}=e;return(0,s.yg)(qYo,(0,p.A)({},VYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}jYo.isMDXComponent=!0;const HYo={toc:[]},YYo="wrapper";function QYo(e){let{components:n,...t}=e;return(0,s.yg)(YYo,(0,p.A)({},HYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property is only applied to knots that don't use explicit handles."))}QYo.isMDXComponent=!0;const $Yo={toc:[]},KYo="wrapper";function JYo(e){let{components:n,...t}=e;return(0,s.yg)(KYo,(0,p.A)({},$Yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0.4"))}JYo.isMDXComponent=!0;const ZYo={toc:[]},eQo="wrapper";function nQo(e){let{components:n,...t}=e;return(0,s.yg)(eQo,(0,p.A)({},ZYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The smoothness of the spline when using auto-calculated handles."))}nQo.isMDXComponent=!0;const tQo={toc:[]},oQo="wrapper";function pQo(e){let{components:n,...t}=e;return(0,s.yg)(oQo,(0,p.A)({},tQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}pQo.isMDXComponent=!0;const rQo={toc:[]},sQo="wrapper";function cQo(e){let{components:n,...t}=e;return(0,s.yg)(sQo,(0,p.A)({},rQo,t,{components:n,mdxType:"MDXLayout"}))}cQo.isMDXComponent=!0;const aQo={toc:[]},iQo="wrapper";function lQo(e){let{components:n,...t}=e;return(0,s.yg)(iQo,(0,p.A)({},aQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}lQo.isMDXComponent=!0;const uQo={toc:[]},mQo="wrapper";function yQo(e){let{components:n,...t}=e;return(0,s.yg)(mQo,(0,p.A)({},uQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}yQo.isMDXComponent=!0;const dQo={toc:[]},hQo="wrapper";function gQo(e){let{components:n,...t}=e;return(0,s.yg)(hQo,(0,p.A)({},dQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gQo.isMDXComponent=!0;const fQo={toc:[]},DQo="wrapper";function MQo(e){let{components:n,...t}=e;return(0,s.yg)(DQo,(0,p.A)({},fQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}MQo.isMDXComponent=!0;const XQo={toc:[]},_Qo="wrapper";function wQo(e){let{components:n,...t}=e;return(0,s.yg)(_Qo,(0,p.A)({},XQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wQo.isMDXComponent=!0;const TQo={toc:[]},CQo="wrapper";function xQo(e){let{components:n,...t}=e;return(0,s.yg)(CQo,(0,p.A)({},TQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}xQo.isMDXComponent=!0;const AQo={toc:[]},vQo="wrapper";function LQo(e){let{components:n,...t}=e;return(0,s.yg)(vQo,(0,p.A)({},AQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}LQo.isMDXComponent=!0;const bQo={toc:[]},NQo="wrapper";function kQo(e){let{components:n,...t}=e;return(0,s.yg)(NQo,(0,p.A)({},bQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}kQo.isMDXComponent=!0;const zQo={toc:[]},PQo="wrapper";function IQo(e){let{components:n,...t}=e;return(0,s.yg)(PQo,(0,p.A)({},zQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}IQo.isMDXComponent=!0;const RQo={toc:[]},WQo="wrapper";function SQo(e){let{components:n,...t}=e;return(0,s.yg)(WQo,(0,p.A)({},RQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}SQo.isMDXComponent=!0;const BQo={toc:[]},GQo="wrapper";function EQo(e){let{components:n,...t}=e;return(0,s.yg)(GQo,(0,p.A)({},BQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}EQo.isMDXComponent=!0;const OQo={toc:[]},UQo="wrapper";function FQo(e){let{components:n,...t}=e;return(0,s.yg)(UQo,(0,p.A)({},OQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}FQo.isMDXComponent=!0;const VQo={toc:[]},qQo="wrapper";function jQo(e){let{components:n,...t}=e;return(0,s.yg)(qQo,(0,p.A)({},VQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}jQo.isMDXComponent=!0;const HQo={toc:[]},YQo="wrapper";function QQo(e){let{components:n,...t}=e;return(0,s.yg)(YQo,(0,p.A)({},HQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}QQo.isMDXComponent=!0;const $Qo={toc:[]},KQo="wrapper";function JQo(e){let{components:n,...t}=e;return(0,s.yg)(KQo,(0,p.A)({},$Qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}JQo.isMDXComponent=!0;const ZQo={toc:[]},e$o="wrapper";function n$o(e){let{components:n,...t}=e;return(0,s.yg)(e$o,(0,p.A)({},ZQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}n$o.isMDXComponent=!0;const t$o={toc:[]},o$o="wrapper";function p$o(e){let{components:n,...t}=e;return(0,s.yg)(o$o,(0,p.A)({},t$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}p$o.isMDXComponent=!0;const r$o={toc:[]},s$o="wrapper";function c$o(e){let{components:n,...t}=e;return(0,s.yg)(s$o,(0,p.A)({},r$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}c$o.isMDXComponent=!0;const a$o={toc:[]},i$o="wrapper";function l$o(e){let{components:n,...t}=e;return(0,s.yg)(i$o,(0,p.A)({},a$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}l$o.isMDXComponent=!0;const u$o={toc:[]},m$o="wrapper";function y$o(e){let{components:n,...t}=e;return(0,s.yg)(m$o,(0,p.A)({},u$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}y$o.isMDXComponent=!0;const d$o={toc:[]},h$o="wrapper";function g$o(e){let{components:n,...t}=e;return(0,s.yg)(h$o,(0,p.A)({},d$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}g$o.isMDXComponent=!0;const f$o={toc:[]},D$o="wrapper";function M$o(e){let{components:n,...t}=e;return(0,s.yg)(D$o,(0,p.A)({},f$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}M$o.isMDXComponent=!0;const X$o={toc:[]},_$o="wrapper";function w$o(e){let{components:n,...t}=e;return(0,s.yg)(_$o,(0,p.A)({},X$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}w$o.isMDXComponent=!0;const T$o={toc:[]},C$o="wrapper";function x$o(e){let{components:n,...t}=e;return(0,s.yg)(C$o,(0,p.A)({},T$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}x$o.isMDXComponent=!0;const A$o={toc:[]},v$o="wrapper";function L$o(e){let{components:n,...t}=e;return(0,s.yg)(v$o,(0,p.A)({},A$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}L$o.isMDXComponent=!0;const b$o={toc:[]},N$o="wrapper";function k$o(e){let{components:n,...t}=e;return(0,s.yg)(N$o,(0,p.A)({},b$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}k$o.isMDXComponent=!0;const z$o={toc:[]},P$o="wrapper";function I$o(e){let{components:n,...t}=e;return(0,s.yg)(P$o,(0,p.A)({},z$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}I$o.isMDXComponent=!0;const R$o={toc:[]},W$o="wrapper";function S$o(e){let{components:n,...t}=e;return(0,s.yg)(W$o,(0,p.A)({},R$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}S$o.isMDXComponent=!0;const B$o={toc:[]},G$o="wrapper";function E$o(e){let{components:n,...t}=e;return(0,s.yg)(G$o,(0,p.A)({},B$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}E$o.isMDXComponent=!0;const O$o={toc:[]},U$o="wrapper";function F$o(e){let{components:n,...t}=e;return(0,s.yg)(U$o,(0,p.A)({},O$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}F$o.isMDXComponent=!0;const V$o={toc:[]},q$o="wrapper";function j$o(e){let{components:n,...t}=e;return(0,s.yg)(q$o,(0,p.A)({},V$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}j$o.isMDXComponent=!0;const H$o={toc:[]},Y$o="wrapper";function Q$o(e){let{components:n,...t}=e;return(0,s.yg)(Y$o,(0,p.A)({},H$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Q$o.isMDXComponent=!0;const $$o={toc:[]},K$o="wrapper";function J$o(e){let{components:n,...t}=e;return(0,s.yg)(K$o,(0,p.A)({},$$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}J$o.isMDXComponent=!0;const Z$o={toc:[]},eKo="wrapper";function nKo(e){let{components:n,...t}=e;return(0,s.yg)(eKo,(0,p.A)({},Z$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}nKo.isMDXComponent=!0;const tKo={toc:[]},oKo="wrapper";function pKo(e){let{components:n,...t}=e;return(0,s.yg)(oKo,(0,p.A)({},tKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}pKo.isMDXComponent=!0;const rKo={toc:[]},sKo="wrapper";function cKo(e){let{components:n,...t}=e;return(0,s.yg)(sKo,(0,p.A)({},rKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}cKo.isMDXComponent=!0;const aKo={toc:[]},iKo="wrapper";function lKo(e){let{components:n,...t}=e;return(0,s.yg)(iKo,(0,p.A)({},aKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}lKo.isMDXComponent=!0;const uKo={toc:[]},mKo="wrapper";function yKo(e){let{components:n,...t}=e;return(0,s.yg)(mKo,(0,p.A)({},uKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}yKo.isMDXComponent=!0;const dKo={toc:[]},hKo="wrapper";function gKo(e){let{components:n,...t}=e;return(0,s.yg)(hKo,(0,p.A)({},dKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}gKo.isMDXComponent=!0;const fKo={toc:[]},DKo="wrapper";function MKo(e){let{components:n,...t}=e;return(0,s.yg)(DKo,(0,p.A)({},fKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}MKo.isMDXComponent=!0;const XKo={toc:[]},_Ko="wrapper";function wKo(e){let{components:n,...t}=e;return(0,s.yg)(_Ko,(0,p.A)({},XKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wKo.isMDXComponent=!0;const TKo={toc:[]},CKo="wrapper";function xKo(e){let{components:n,...t}=e;return(0,s.yg)(CKo,(0,p.A)({},TKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}xKo.isMDXComponent=!0;const AKo={toc:[]},vKo="wrapper";function LKo(e){let{components:n,...t}=e;return(0,s.yg)(vKo,(0,p.A)({},AKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}LKo.isMDXComponent=!0;const bKo={toc:[]},NKo="wrapper";function kKo(e){let{components:n,...t}=e;return(0,s.yg)(NKo,(0,p.A)({},bKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}kKo.isMDXComponent=!0;const zKo={toc:[]},PKo="wrapper";function IKo(e){let{components:n,...t}=e;return(0,s.yg)(PKo,(0,p.A)({},zKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}IKo.isMDXComponent=!0;const RKo={toc:[]},WKo="wrapper";function SKo(e){let{components:n,...t}=e;return(0,s.yg)(WKo,(0,p.A)({},RKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}SKo.isMDXComponent=!0;const BKo={toc:[]},GKo="wrapper";function EKo(e){let{components:n,...t}=e;return(0,s.yg)(GKo,(0,p.A)({},BKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}EKo.isMDXComponent=!0;const OKo={toc:[]},UKo="wrapper";function FKo(e){let{components:n,...t}=e;return(0,s.yg)(UKo,(0,p.A)({},OKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}FKo.isMDXComponent=!0;const VKo={toc:[]},qKo="wrapper";function jKo(e){let{components:n,...t}=e;return(0,s.yg)(qKo,(0,p.A)({},VKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jKo.isMDXComponent=!0;const HKo={toc:[]},YKo="wrapper";function QKo(e){let{components:n,...t}=e;return(0,s.yg)(YKo,(0,p.A)({},HKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}QKo.isMDXComponent=!0;const $Ko={toc:[]},KKo="wrapper";function JKo(e){let{components:n,...t}=e;return(0,s.yg)(KKo,(0,p.A)({},$Ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}JKo.isMDXComponent=!0;const ZKo={toc:[]},eJo="wrapper";function nJo(e){let{components:n,...t}=e;return(0,s.yg)(eJo,(0,p.A)({},ZKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}nJo.isMDXComponent=!0;const tJo={toc:[]},oJo="wrapper";function pJo(e){let{components:n,...t}=e;return(0,s.yg)(oJo,(0,p.A)({},tJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}pJo.isMDXComponent=!0;const rJo={toc:[]},sJo="wrapper";function cJo(e){let{components:n,...t}=e;return(0,s.yg)(sJo,(0,p.A)({},rJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cJo.isMDXComponent=!0;const aJo={toc:[]},iJo="wrapper";function lJo(e){let{components:n,...t}=e;return(0,s.yg)(iJo,(0,p.A)({},aJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}lJo.isMDXComponent=!0;const uJo={toc:[]},mJo="wrapper";function yJo(e){let{components:n,...t}=e;return(0,s.yg)(mJo,(0,p.A)({},uJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yJo.isMDXComponent=!0;const dJo={toc:[]},hJo="wrapper";function gJo(e){let{components:n,...t}=e;return(0,s.yg)(hJo,(0,p.A)({},dJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}gJo.isMDXComponent=!0;const fJo={toc:[]},DJo="wrapper";function MJo(e){let{components:n,...t}=e;return(0,s.yg)(DJo,(0,p.A)({},fJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}MJo.isMDXComponent=!0;const XJo={toc:[]},_Jo="wrapper";function wJo(e){let{components:n,...t}=e;return(0,s.yg)(_Jo,(0,p.A)({},XJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wJo.isMDXComponent=!0;const TJo={toc:[]},CJo="wrapper";function xJo(e){let{components:n,...t}=e;return(0,s.yg)(CJo,(0,p.A)({},TJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xJo.isMDXComponent=!0;const AJo={toc:[]},vJo="wrapper";function LJo(e){let{components:n,...t}=e;return(0,s.yg)(vJo,(0,p.A)({},AJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}LJo.isMDXComponent=!0;const bJo={toc:[]},NJo="wrapper";function kJo(e){let{components:n,...t}=e;return(0,s.yg)(NJo,(0,p.A)({},bJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kJo.isMDXComponent=!0;const zJo={toc:[]},PJo="wrapper";function IJo(e){let{components:n,...t}=e;return(0,s.yg)(PJo,(0,p.A)({},zJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}IJo.isMDXComponent=!0;const RJo={toc:[]},WJo="wrapper";function SJo(e){let{components:n,...t}=e;return(0,s.yg)(WJo,(0,p.A)({},RJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}SJo.isMDXComponent=!0;const BJo={toc:[]},GJo="wrapper";function EJo(e){let{components:n,...t}=e;return(0,s.yg)(GJo,(0,p.A)({},BJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}EJo.isMDXComponent=!0;const OJo={toc:[]},UJo="wrapper";function FJo(e){let{components:n,...t}=e;return(0,s.yg)(UJo,(0,p.A)({},OJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}FJo.isMDXComponent=!0;const VJo={toc:[]},qJo="wrapper";function jJo(e){let{components:n,...t}=e;return(0,s.yg)(qJo,(0,p.A)({},VJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}jJo.isMDXComponent=!0;const HJo={toc:[]},YJo="wrapper";function QJo(e){let{components:n,...t}=e;return(0,s.yg)(YJo,(0,p.A)({},HJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}QJo.isMDXComponent=!0;const $Jo={toc:[]},KJo="wrapper";function JJo(e){let{components:n,...t}=e;return(0,s.yg)(KJo,(0,p.A)({},$Jo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}JJo.isMDXComponent=!0;const ZJo={toc:[]},eZo="wrapper";function nZo(e){let{components:n,...t}=e;return(0,s.yg)(eZo,(0,p.A)({},ZJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nZo.isMDXComponent=!0;const tZo={toc:[]},oZo="wrapper";function pZo(e){let{components:n,...t}=e;return(0,s.yg)(oZo,(0,p.A)({},tZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}pZo.isMDXComponent=!0;const rZo={toc:[]},sZo="wrapper";function cZo(e){let{components:n,...t}=e;return(0,s.yg)(sZo,(0,p.A)({},rZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}cZo.isMDXComponent=!0;const aZo={toc:[]},iZo="wrapper";function lZo(e){let{components:n,...t}=e;return(0,s.yg)(iZo,(0,p.A)({},aZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lZo.isMDXComponent=!0;const uZo={toc:[]},mZo="wrapper";function yZo(e){let{components:n,...t}=e;return(0,s.yg)(mZo,(0,p.A)({},uZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}yZo.isMDXComponent=!0;const dZo={toc:[]},hZo="wrapper";function gZo(e){let{components:n,...t}=e;return(0,s.yg)(hZo,(0,p.A)({},dZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}gZo.isMDXComponent=!0;const fZo={toc:[]},DZo="wrapper";function MZo(e){let{components:n,...t}=e;return(0,s.yg)(DZo,(0,p.A)({},fZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}MZo.isMDXComponent=!0;const XZo={toc:[]},_Zo="wrapper";function wZo(e){let{components:n,...t}=e;return(0,s.yg)(_Zo,(0,p.A)({},XZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wZo.isMDXComponent=!0;const TZo={toc:[]},CZo="wrapper";function xZo(e){let{components:n,...t}=e;return(0,s.yg)(CZo,(0,p.A)({},TZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}xZo.isMDXComponent=!0;const AZo={toc:[]},vZo="wrapper";function LZo(e){let{components:n,...t}=e;return(0,s.yg)(vZo,(0,p.A)({},AZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}LZo.isMDXComponent=!0;const bZo={toc:[]},NZo="wrapper";function kZo(e){let{components:n,...t}=e;return(0,s.yg)(NZo,(0,p.A)({},bZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}kZo.isMDXComponent=!0;const zZo={toc:[]},PZo="wrapper";function IZo(e){let{components:n,...t}=e;return(0,s.yg)(PZo,(0,p.A)({},zZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}IZo.isMDXComponent=!0;const RZo={toc:[]},WZo="wrapper";function SZo(e){let{components:n,...t}=e;return(0,s.yg)(WZo,(0,p.A)({},RZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}SZo.isMDXComponent=!0;const BZo={toc:[]},GZo="wrapper";function EZo(e){let{components:n,...t}=e;return(0,s.yg)(GZo,(0,p.A)({},BZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}EZo.isMDXComponent=!0;const OZo={toc:[]},UZo="wrapper";function FZo(e){let{components:n,...t}=e;return(0,s.yg)(UZo,(0,p.A)({},OZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}FZo.isMDXComponent=!0;const VZo={toc:[]},qZo="wrapper";function jZo(e){let{components:n,...t}=e;return(0,s.yg)(qZo,(0,p.A)({},VZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jZo.isMDXComponent=!0;const HZo={toc:[]},YZo="wrapper";function QZo(e){let{components:n,...t}=e;return(0,s.yg)(YZo,(0,p.A)({},HZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}QZo.isMDXComponent=!0;const $Zo={toc:[]},KZo="wrapper";function JZo(e){let{components:n,...t}=e;return(0,s.yg)(KZo,(0,p.A)({},$Zo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}JZo.isMDXComponent=!0;const ZZo={toc:[]},e0o="wrapper";function n0o(e){let{components:n,...t}=e;return(0,s.yg)(e0o,(0,p.A)({},ZZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}n0o.isMDXComponent=!0;const t0o={toc:[]},o0o="wrapper";function p0o(e){let{components:n,...t}=e;return(0,s.yg)(o0o,(0,p.A)({},t0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}p0o.isMDXComponent=!0;const r0o={toc:[]},s0o="wrapper";function c0o(e){let{components:n,...t}=e;return(0,s.yg)(s0o,(0,p.A)({},r0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}c0o.isMDXComponent=!0;const a0o={toc:[]},i0o="wrapper";function l0o(e){let{components:n,...t}=e;return(0,s.yg)(i0o,(0,p.A)({},a0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}l0o.isMDXComponent=!0;const u0o={toc:[]},m0o="wrapper";function y0o(e){let{components:n,...t}=e;return(0,s.yg)(m0o,(0,p.A)({},u0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}y0o.isMDXComponent=!0;const d0o={toc:[]},h0o="wrapper";function g0o(e){let{components:n,...t}=e;return(0,s.yg)(h0o,(0,p.A)({},d0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}g0o.isMDXComponent=!0;const f0o={toc:[]},D0o="wrapper";function M0o(e){let{components:n,...t}=e;return(0,s.yg)(D0o,(0,p.A)({},f0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}M0o.isMDXComponent=!0;const X0o={toc:[]},_0o="wrapper";function w0o(e){let{components:n,...t}=e;return(0,s.yg)(_0o,(0,p.A)({},X0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}w0o.isMDXComponent=!0;const T0o={toc:[]},C0o="wrapper";function x0o(e){let{components:n,...t}=e;return(0,s.yg)(C0o,(0,p.A)({},T0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}x0o.isMDXComponent=!0;const A0o={toc:[]},v0o="wrapper";function L0o(e){let{components:n,...t}=e;return(0,s.yg)(v0o,(0,p.A)({},A0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}L0o.isMDXComponent=!0;const b0o={toc:[]},N0o="wrapper";function k0o(e){let{components:n,...t}=e;return(0,s.yg)(N0o,(0,p.A)({},b0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}k0o.isMDXComponent=!0;const z0o={toc:[]},P0o="wrapper";function I0o(e){let{components:n,...t}=e;return(0,s.yg)(P0o,(0,p.A)({},z0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}I0o.isMDXComponent=!0;const R0o={toc:[]},W0o="wrapper";function S0o(e){let{components:n,...t}=e;return(0,s.yg)(W0o,(0,p.A)({},R0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}S0o.isMDXComponent=!0;const B0o={toc:[]},G0o="wrapper";function E0o(e){let{components:n,...t}=e;return(0,s.yg)(G0o,(0,p.A)({},B0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}E0o.isMDXComponent=!0;const O0o={toc:[]},U0o="wrapper";function F0o(e){let{components:n,...t}=e;return(0,s.yg)(U0o,(0,p.A)({},O0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}F0o.isMDXComponent=!0;const V0o={toc:[]},q0o="wrapper";function j0o(e){let{components:n,...t}=e;return(0,s.yg)(q0o,(0,p.A)({},V0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}j0o.isMDXComponent=!0;const H0o={toc:[]},Y0o="wrapper";function Q0o(e){let{components:n,...t}=e;return(0,s.yg)(Y0o,(0,p.A)({},H0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Q0o.isMDXComponent=!0;const $0o={toc:[]},K0o="wrapper";function J0o(e){let{components:n,...t}=e;return(0,s.yg)(K0o,(0,p.A)({},$0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}J0o.isMDXComponent=!0;const Z0o={toc:[]},e2o="wrapper";function n2o(e){let{components:n,...t}=e;return(0,s.yg)(e2o,(0,p.A)({},Z0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}n2o.isMDXComponent=!0;const t2o={toc:[]},o2o="wrapper";function p2o(e){let{components:n,...t}=e;return(0,s.yg)(o2o,(0,p.A)({},t2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}p2o.isMDXComponent=!0;const r2o={toc:[]},s2o="wrapper";function c2o(e){let{components:n,...t}=e;return(0,s.yg)(s2o,(0,p.A)({},r2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}c2o.isMDXComponent=!0;const a2o={toc:[]},i2o="wrapper";function l2o(e){let{components:n,...t}=e;return(0,s.yg)(i2o,(0,p.A)({},a2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}l2o.isMDXComponent=!0;const u2o={toc:[]},m2o="wrapper";function y2o(e){let{components:n,...t}=e;return(0,s.yg)(m2o,(0,p.A)({},u2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}y2o.isMDXComponent=!0;const d2o={toc:[]},h2o="wrapper";function g2o(e){let{components:n,...t}=e;return(0,s.yg)(h2o,(0,p.A)({},d2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}g2o.isMDXComponent=!0;const f2o={toc:[]},D2o="wrapper";function M2o(e){let{components:n,...t}=e;return(0,s.yg)(D2o,(0,p.A)({},f2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}M2o.isMDXComponent=!0;const X2o={toc:[]},_2o="wrapper";function w2o(e){let{components:n,...t}=e;return(0,s.yg)(_2o,(0,p.A)({},X2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}w2o.isMDXComponent=!0;const T2o={toc:[]},C2o="wrapper";function x2o(e){let{components:n,...t}=e;return(0,s.yg)(C2o,(0,p.A)({},T2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}x2o.isMDXComponent=!0;const A2o={toc:[]},v2o="wrapper";function L2o(e){let{components:n,...t}=e;return(0,s.yg)(v2o,(0,p.A)({},A2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}L2o.isMDXComponent=!0;const b2o={toc:[]},N2o="wrapper";function k2o(e){let{components:n,...t}=e;return(0,s.yg)(N2o,(0,p.A)({},b2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}k2o.isMDXComponent=!0;const z2o={toc:[]},P2o="wrapper";function I2o(e){let{components:n,...t}=e;return(0,s.yg)(P2o,(0,p.A)({},z2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}I2o.isMDXComponent=!0;const R2o={toc:[]},W2o="wrapper";function S2o(e){let{components:n,...t}=e;return(0,s.yg)(W2o,(0,p.A)({},R2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}S2o.isMDXComponent=!0;const B2o={toc:[]},G2o="wrapper";function E2o(e){let{components:n,...t}=e;return(0,s.yg)(G2o,(0,p.A)({},B2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}E2o.isMDXComponent=!0;const O2o={toc:[]},U2o="wrapper";function F2o(e){let{components:n,...t}=e;return(0,s.yg)(U2o,(0,p.A)({},O2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}F2o.isMDXComponent=!0;const V2o={toc:[]},q2o="wrapper";function j2o(e){let{components:n,...t}=e;return(0,s.yg)(q2o,(0,p.A)({},V2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}j2o.isMDXComponent=!0;const H2o={toc:[]},Y2o="wrapper";function Q2o(e){let{components:n,...t}=e;return(0,s.yg)(Y2o,(0,p.A)({},H2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Q2o.isMDXComponent=!0;const $2o={toc:[]},K2o="wrapper";function J2o(e){let{components:n,...t}=e;return(0,s.yg)(K2o,(0,p.A)({},$2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}J2o.isMDXComponent=!0;const Z2o={toc:[]},e4o="wrapper";function n4o(e){let{components:n,...t}=e;return(0,s.yg)(e4o,(0,p.A)({},Z2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}n4o.isMDXComponent=!0;const t4o={toc:[]},o4o="wrapper";function p4o(e){let{components:n,...t}=e;return(0,s.yg)(o4o,(0,p.A)({},t4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}p4o.isMDXComponent=!0;const r4o={toc:[]},s4o="wrapper";function c4o(e){let{components:n,...t}=e;return(0,s.yg)(s4o,(0,p.A)({},r4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}c4o.isMDXComponent=!0;const a4o={toc:[]},i4o="wrapper";function l4o(e){let{components:n,...t}=e;return(0,s.yg)(i4o,(0,p.A)({},a4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}l4o.isMDXComponent=!0;const u4o={toc:[]},m4o="wrapper";function y4o(e){let{components:n,...t}=e;return(0,s.yg)(m4o,(0,p.A)({},u4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}y4o.isMDXComponent=!0;const d4o={toc:[]},h4o="wrapper";function g4o(e){let{components:n,...t}=e;return(0,s.yg)(h4o,(0,p.A)({},d4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}g4o.isMDXComponent=!0;const f4o={toc:[]},D4o="wrapper";function M4o(e){let{components:n,...t}=e;return(0,s.yg)(D4o,(0,p.A)({},f4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}M4o.isMDXComponent=!0;const X4o={toc:[]},_4o="wrapper";function w4o(e){let{components:n,...t}=e;return(0,s.yg)(_4o,(0,p.A)({},X4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}w4o.isMDXComponent=!0;const T4o={toc:[]},C4o="wrapper";function x4o(e){let{components:n,...t}=e;return(0,s.yg)(C4o,(0,p.A)({},T4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}x4o.isMDXComponent=!0;const A4o={toc:[]},v4o="wrapper";function L4o(e){let{components:n,...t}=e;return(0,s.yg)(v4o,(0,p.A)({},A4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}L4o.isMDXComponent=!0;const b4o={toc:[]},N4o="wrapper";function k4o(e){let{components:n,...t}=e;return(0,s.yg)(N4o,(0,p.A)({},b4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}k4o.isMDXComponent=!0;const z4o={toc:[]},P4o="wrapper";function I4o(e){let{components:n,...t}=e;return(0,s.yg)(P4o,(0,p.A)({},z4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}I4o.isMDXComponent=!0;const R4o={toc:[]},W4o="wrapper";function S4o(e){let{components:n,...t}=e;return(0,s.yg)(W4o,(0,p.A)({},R4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}S4o.isMDXComponent=!0;const B4o={toc:[]},G4o="wrapper";function E4o(e){let{components:n,...t}=e;return(0,s.yg)(G4o,(0,p.A)({},B4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}E4o.isMDXComponent=!0;const O4o={toc:[]},U4o="wrapper";function F4o(e){let{components:n,...t}=e;return(0,s.yg)(U4o,(0,p.A)({},O4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}F4o.isMDXComponent=!0;const V4o={toc:[]},q4o="wrapper";function j4o(e){let{components:n,...t}=e;return(0,s.yg)(q4o,(0,p.A)({},V4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}j4o.isMDXComponent=!0;const H4o={toc:[]},Y4o="wrapper";function Q4o(e){let{components:n,...t}=e;return(0,s.yg)(Y4o,(0,p.A)({},H4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Q4o.isMDXComponent=!0;const $4o={toc:[]},K4o="wrapper";function J4o(e){let{components:n,...t}=e;return(0,s.yg)(K4o,(0,p.A)({},$4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}J4o.isMDXComponent=!0;const Z4o={toc:[]},e8o="wrapper";function n8o(e){let{components:n,...t}=e;return(0,s.yg)(e8o,(0,p.A)({},Z4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}n8o.isMDXComponent=!0;const t8o={toc:[]},o8o="wrapper";function p8o(e){let{components:n,...t}=e;return(0,s.yg)(o8o,(0,p.A)({},t8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}p8o.isMDXComponent=!0;const r8o={toc:[]},s8o="wrapper";function c8o(e){let{components:n,...t}=e;return(0,s.yg)(s8o,(0,p.A)({},r8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}c8o.isMDXComponent=!0;const a8o={toc:[]},i8o="wrapper";function l8o(e){let{components:n,...t}=e;return(0,s.yg)(i8o,(0,p.A)({},a8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}l8o.isMDXComponent=!0;const u8o={toc:[]},m8o="wrapper";function y8o(e){let{components:n,...t}=e;return(0,s.yg)(m8o,(0,p.A)({},u8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}y8o.isMDXComponent=!0;const d8o={toc:[]},h8o="wrapper";function g8o(e){let{components:n,...t}=e;return(0,s.yg)(h8o,(0,p.A)({},d8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}g8o.isMDXComponent=!0;const f8o={toc:[]},D8o="wrapper";function M8o(e){let{components:n,...t}=e;return(0,s.yg)(D8o,(0,p.A)({},f8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}M8o.isMDXComponent=!0;const X8o={toc:[]},_8o="wrapper";function w8o(e){let{components:n,...t}=e;return(0,s.yg)(_8o,(0,p.A)({},X8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}w8o.isMDXComponent=!0;const T8o={toc:[]},C8o="wrapper";function x8o(e){let{components:n,...t}=e;return(0,s.yg)(C8o,(0,p.A)({},T8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}x8o.isMDXComponent=!0;const A8o={toc:[]},v8o="wrapper";function L8o(e){let{components:n,...t}=e;return(0,s.yg)(v8o,(0,p.A)({},A8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}L8o.isMDXComponent=!0;const b8o={toc:[]},N8o="wrapper";function k8o(e){let{components:n,...t}=e;return(0,s.yg)(N8o,(0,p.A)({},b8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}k8o.isMDXComponent=!0;const z8o={toc:[]},P8o="wrapper";function I8o(e){let{components:n,...t}=e;return(0,s.yg)(P8o,(0,p.A)({},z8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}I8o.isMDXComponent=!0;const R8o={toc:[]},W8o="wrapper";function S8o(e){let{components:n,...t}=e;return(0,s.yg)(W8o,(0,p.A)({},R8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}S8o.isMDXComponent=!0;const B8o={toc:[]},G8o="wrapper";function E8o(e){let{components:n,...t}=e;return(0,s.yg)(G8o,(0,p.A)({},B8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}E8o.isMDXComponent=!0;const O8o={toc:[]},U8o="wrapper";function F8o(e){let{components:n,...t}=e;return(0,s.yg)(U8o,(0,p.A)({},O8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}F8o.isMDXComponent=!0;const V8o={toc:[]},q8o="wrapper";function j8o(e){let{components:n,...t}=e;return(0,s.yg)(q8o,(0,p.A)({},V8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}j8o.isMDXComponent=!0;const H8o={toc:[]},Y8o="wrapper";function Q8o(e){let{components:n,...t}=e;return(0,s.yg)(Y8o,(0,p.A)({},H8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Q8o.isMDXComponent=!0;const $8o={toc:[]},K8o="wrapper";function J8o(e){let{components:n,...t}=e;return(0,s.yg)(K8o,(0,p.A)({},$8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}J8o.isMDXComponent=!0;const Z8o={toc:[]},e3o="wrapper";function n3o(e){let{components:n,...t}=e;return(0,s.yg)(e3o,(0,p.A)({},Z8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}n3o.isMDXComponent=!0;const t3o={toc:[]},o3o="wrapper";function p3o(e){let{components:n,...t}=e;return(0,s.yg)(o3o,(0,p.A)({},t3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}p3o.isMDXComponent=!0;const r3o={toc:[]},s3o="wrapper";function c3o(e){let{components:n,...t}=e;return(0,s.yg)(s3o,(0,p.A)({},r3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}c3o.isMDXComponent=!0;const a3o={toc:[]},i3o="wrapper";function l3o(e){let{components:n,...t}=e;return(0,s.yg)(i3o,(0,p.A)({},a3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}l3o.isMDXComponent=!0;const u3o={toc:[]},m3o="wrapper";function y3o(e){let{components:n,...t}=e;return(0,s.yg)(m3o,(0,p.A)({},u3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}y3o.isMDXComponent=!0;const d3o={toc:[]},h3o="wrapper";function g3o(e){let{components:n,...t}=e;return(0,s.yg)(h3o,(0,p.A)({},d3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}g3o.isMDXComponent=!0;const f3o={toc:[]},D3o="wrapper";function M3o(e){let{components:n,...t}=e;return(0,s.yg)(D3o,(0,p.A)({},f3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}M3o.isMDXComponent=!0;const X3o={toc:[]},_3o="wrapper";function w3o(e){let{components:n,...t}=e;return(0,s.yg)(_3o,(0,p.A)({},X3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}w3o.isMDXComponent=!0;const T3o={toc:[]},C3o="wrapper";function x3o(e){let{components:n,...t}=e;return(0,s.yg)(C3o,(0,p.A)({},T3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}x3o.isMDXComponent=!0;const A3o={toc:[]},v3o="wrapper";function L3o(e){let{components:n,...t}=e;return(0,s.yg)(v3o,(0,p.A)({},A3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}L3o.isMDXComponent=!0;const b3o={toc:[]},N3o="wrapper";function k3o(e){let{components:n,...t}=e;return(0,s.yg)(N3o,(0,p.A)({},b3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}k3o.isMDXComponent=!0;const z3o={toc:[]},P3o="wrapper";function I3o(e){let{components:n,...t}=e;return(0,s.yg)(P3o,(0,p.A)({},z3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}I3o.isMDXComponent=!0;const R3o={toc:[]},W3o="wrapper";function S3o(e){let{components:n,...t}=e;return(0,s.yg)(W3o,(0,p.A)({},R3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}S3o.isMDXComponent=!0;const B3o={toc:[]},G3o="wrapper";function E3o(e){let{components:n,...t}=e;return(0,s.yg)(G3o,(0,p.A)({},B3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}E3o.isMDXComponent=!0;const O3o={toc:[]},U3o="wrapper";function F3o(e){let{components:n,...t}=e;return(0,s.yg)(U3o,(0,p.A)({},O3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}F3o.isMDXComponent=!0;const V3o={toc:[]},q3o="wrapper";function j3o(e){let{components:n,...t}=e;return(0,s.yg)(q3o,(0,p.A)({},V3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}j3o.isMDXComponent=!0;const H3o={toc:[]},Y3o="wrapper";function Q3o(e){let{components:n,...t}=e;return(0,s.yg)(Y3o,(0,p.A)({},H3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Q3o.isMDXComponent=!0;const $3o={toc:[]},K3o="wrapper";function J3o(e){let{components:n,...t}=e;return(0,s.yg)(K3o,(0,p.A)({},$3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}J3o.isMDXComponent=!0;const Z3o={toc:[]},e1o="wrapper";function n1o(e){let{components:n,...t}=e;return(0,s.yg)(e1o,(0,p.A)({},Z3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}n1o.isMDXComponent=!0;const t1o={toc:[]},o1o="wrapper";function p1o(e){let{components:n,...t}=e;return(0,s.yg)(o1o,(0,p.A)({},t1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}p1o.isMDXComponent=!0;const r1o={toc:[]},s1o="wrapper";function c1o(e){let{components:n,...t}=e;return(0,s.yg)(s1o,(0,p.A)({},r1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}c1o.isMDXComponent=!0;const a1o={toc:[]},i1o="wrapper";function l1o(e){let{components:n,...t}=e;return(0,s.yg)(i1o,(0,p.A)({},a1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}l1o.isMDXComponent=!0;const u1o={toc:[]},m1o="wrapper";function y1o(e){let{components:n,...t}=e;return(0,s.yg)(m1o,(0,p.A)({},u1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}y1o.isMDXComponent=!0;const d1o={toc:[]},h1o="wrapper";function g1o(e){let{components:n,...t}=e;return(0,s.yg)(h1o,(0,p.A)({},d1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}g1o.isMDXComponent=!0;const f1o={toc:[]},D1o="wrapper";function M1o(e){let{components:n,...t}=e;return(0,s.yg)(D1o,(0,p.A)({},f1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}M1o.isMDXComponent=!0;const X1o={toc:[]},_1o="wrapper";function w1o(e){let{components:n,...t}=e;return(0,s.yg)(_1o,(0,p.A)({},X1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}w1o.isMDXComponent=!0;const T1o={toc:[]},C1o="wrapper";function x1o(e){let{components:n,...t}=e;return(0,s.yg)(C1o,(0,p.A)({},T1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}x1o.isMDXComponent=!0;const A1o={toc:[]},v1o="wrapper";function L1o(e){let{components:n,...t}=e;return(0,s.yg)(v1o,(0,p.A)({},A1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}L1o.isMDXComponent=!0;const b1o={toc:[]},N1o="wrapper";function k1o(e){let{components:n,...t}=e;return(0,s.yg)(N1o,(0,p.A)({},b1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}k1o.isMDXComponent=!0;const z1o={toc:[]},P1o="wrapper";function I1o(e){let{components:n,...t}=e;return(0,s.yg)(P1o,(0,p.A)({},z1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}I1o.isMDXComponent=!0;const R1o={toc:[]},W1o="wrapper";function S1o(e){let{components:n,...t}=e;return(0,s.yg)(W1o,(0,p.A)({},R1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}S1o.isMDXComponent=!0;const B1o={toc:[]},G1o="wrapper";function E1o(e){let{components:n,...t}=e;return(0,s.yg)(G1o,(0,p.A)({},B1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}E1o.isMDXComponent=!0;const O1o={toc:[]},U1o="wrapper";function F1o(e){let{components:n,...t}=e;return(0,s.yg)(U1o,(0,p.A)({},O1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}F1o.isMDXComponent=!0;const V1o={toc:[]},q1o="wrapper";function j1o(e){let{components:n,...t}=e;return(0,s.yg)(q1o,(0,p.A)({},V1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}j1o.isMDXComponent=!0;const H1o={toc:[]},Y1o="wrapper";function Q1o(e){let{components:n,...t}=e;return(0,s.yg)(Y1o,(0,p.A)({},H1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Q1o.isMDXComponent=!0;const $1o={toc:[]},K1o="wrapper";function J1o(e){let{components:n,...t}=e;return(0,s.yg)(K1o,(0,p.A)({},$1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}J1o.isMDXComponent=!0;const Z1o={toc:[]},e6o="wrapper";function n6o(e){let{components:n,...t}=e;return(0,s.yg)(e6o,(0,p.A)({},Z1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}n6o.isMDXComponent=!0;const t6o={toc:[]},o6o="wrapper";function p6o(e){let{components:n,...t}=e;return(0,s.yg)(o6o,(0,p.A)({},t6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}p6o.isMDXComponent=!0;const r6o={toc:[]},s6o="wrapper";function c6o(e){let{components:n,...t}=e;return(0,s.yg)(s6o,(0,p.A)({},r6o,t,{components:n,mdxType:"MDXLayout"}))}c6o.isMDXComponent=!0;const a6o={toc:[]},i6o="wrapper";function l6o(e){let{components:n,...t}=e;return(0,s.yg)(i6o,(0,p.A)({},a6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}l6o.isMDXComponent=!0;const u6o={toc:[]},m6o="wrapper";function y6o(e){let{components:n,...t}=e;return(0,s.yg)(m6o,(0,p.A)({},u6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}y6o.isMDXComponent=!0;const d6o={toc:[]},h6o="wrapper";function g6o(e){let{components:n,...t}=e;return(0,s.yg)(h6o,(0,p.A)({},d6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}g6o.isMDXComponent=!0;const f6o={toc:[]},D6o="wrapper";function M6o(e){let{components:n,...t}=e;return(0,s.yg)(D6o,(0,p.A)({},f6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}M6o.isMDXComponent=!0;const X6o={toc:[]},_6o="wrapper";function w6o(e){let{components:n,...t}=e;return(0,s.yg)(_6o,(0,p.A)({},X6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}w6o.isMDXComponent=!0;const T6o={toc:[]},C6o="wrapper";function x6o(e){let{components:n,...t}=e;return(0,s.yg)(C6o,(0,p.A)({},T6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}x6o.isMDXComponent=!0;const A6o={toc:[]},v6o="wrapper";function L6o(e){let{components:n,...t}=e;return(0,s.yg)(v6o,(0,p.A)({},A6o,t,{components:n,mdxType:"MDXLayout"}))}L6o.isMDXComponent=!0;const b6o={toc:[]},N6o="wrapper";function k6o(e){let{components:n,...t}=e;return(0,s.yg)(N6o,(0,p.A)({},b6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}k6o.isMDXComponent=!0;const z6o={toc:[]},P6o="wrapper";function I6o(e){let{components:n,...t}=e;return(0,s.yg)(P6o,(0,p.A)({},z6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}I6o.isMDXComponent=!0;const R6o={toc:[]},W6o="wrapper";function S6o(e){let{components:n,...t}=e;return(0,s.yg)(W6o,(0,p.A)({},R6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}S6o.isMDXComponent=!0;const B6o={toc:[]},G6o="wrapper";function E6o(e){let{components:n,...t}=e;return(0,s.yg)(G6o,(0,p.A)({},B6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}E6o.isMDXComponent=!0;const O6o={toc:[]},U6o="wrapper";function F6o(e){let{components:n,...t}=e;return(0,s.yg)(U6o,(0,p.A)({},O6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}F6o.isMDXComponent=!0;const V6o={toc:[]},q6o="wrapper";function j6o(e){let{components:n,...t}=e;return(0,s.yg)(q6o,(0,p.A)({},V6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}j6o.isMDXComponent=!0;const H6o={toc:[]},Y6o="wrapper";function Q6o(e){let{components:n,...t}=e;return(0,s.yg)(Y6o,(0,p.A)({},H6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Q6o.isMDXComponent=!0;const $6o={toc:[]},K6o="wrapper";function J6o(e){let{components:n,...t}=e;return(0,s.yg)(K6o,(0,p.A)({},$6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}J6o.isMDXComponent=!0;const Z6o={toc:[]},e5o="wrapper";function n5o(e){let{components:n,...t}=e;return(0,s.yg)(e5o,(0,p.A)({},Z6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}n5o.isMDXComponent=!0;const t5o={toc:[]},o5o="wrapper";function p5o(e){let{components:n,...t}=e;return(0,s.yg)(o5o,(0,p.A)({},t5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}p5o.isMDXComponent=!0;const r5o={toc:[]},s5o="wrapper";function c5o(e){let{components:n,...t}=e;return(0,s.yg)(s5o,(0,p.A)({},r5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}c5o.isMDXComponent=!0;const a5o={toc:[]},i5o="wrapper";function l5o(e){let{components:n,...t}=e;return(0,s.yg)(i5o,(0,p.A)({},a5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}l5o.isMDXComponent=!0;const u5o={toc:[]},m5o="wrapper";function y5o(e){let{components:n,...t}=e;return(0,s.yg)(m5o,(0,p.A)({},u5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}y5o.isMDXComponent=!0;const d5o={toc:[]},h5o="wrapper";function g5o(e){let{components:n,...t}=e;return(0,s.yg)(h5o,(0,p.A)({},d5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}g5o.isMDXComponent=!0;const f5o={toc:[]},D5o="wrapper";function M5o(e){let{components:n,...t}=e;return(0,s.yg)(D5o,(0,p.A)({},f5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}M5o.isMDXComponent=!0;const X5o={toc:[]},_5o="wrapper";function w5o(e){let{components:n,...t}=e;return(0,s.yg)(_5o,(0,p.A)({},X5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}w5o.isMDXComponent=!0;const T5o={toc:[]},C5o="wrapper";function x5o(e){let{components:n,...t}=e;return(0,s.yg)(C5o,(0,p.A)({},T5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}x5o.isMDXComponent=!0;const A5o={toc:[]},v5o="wrapper";function L5o(e){let{components:n,...t}=e;return(0,s.yg)(v5o,(0,p.A)({},A5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}L5o.isMDXComponent=!0;const b5o={toc:[]},N5o="wrapper";function k5o(e){let{components:n,...t}=e;return(0,s.yg)(N5o,(0,p.A)({},b5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}k5o.isMDXComponent=!0;const z5o={toc:[]},P5o="wrapper";function I5o(e){let{components:n,...t}=e;return(0,s.yg)(P5o,(0,p.A)({},z5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}I5o.isMDXComponent=!0;const R5o={toc:[]},W5o="wrapper";function S5o(e){let{components:n,...t}=e;return(0,s.yg)(W5o,(0,p.A)({},R5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}S5o.isMDXComponent=!0;const B5o={toc:[]},G5o="wrapper";function E5o(e){let{components:n,...t}=e;return(0,s.yg)(G5o,(0,p.A)({},B5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}E5o.isMDXComponent=!0;const O5o={toc:[]},U5o="wrapper";function F5o(e){let{components:n,...t}=e;return(0,s.yg)(U5o,(0,p.A)({},O5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}F5o.isMDXComponent=!0;const V5o={toc:[]},q5o="wrapper";function j5o(e){let{components:n,...t}=e;return(0,s.yg)(q5o,(0,p.A)({},V5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}j5o.isMDXComponent=!0;const H5o={toc:[]},Y5o="wrapper";function Q5o(e){let{components:n,...t}=e;return(0,s.yg)(Y5o,(0,p.A)({},H5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Q5o.isMDXComponent=!0;const $5o={toc:[]},K5o="wrapper";function J5o(e){let{components:n,...t}=e;return(0,s.yg)(K5o,(0,p.A)({},$5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}J5o.isMDXComponent=!0;const Z5o={toc:[]},e7o="wrapper";function n7o(e){let{components:n,...t}=e;return(0,s.yg)(e7o,(0,p.A)({},Z5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}n7o.isMDXComponent=!0;const t7o={toc:[]},o7o="wrapper";function p7o(e){let{components:n,...t}=e;return(0,s.yg)(o7o,(0,p.A)({},t7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}p7o.isMDXComponent=!0;const r7o={toc:[]},s7o="wrapper";function c7o(e){let{components:n,...t}=e;return(0,s.yg)(s7o,(0,p.A)({},r7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}c7o.isMDXComponent=!0;const a7o={toc:[]},i7o="wrapper";function l7o(e){let{components:n,...t}=e;return(0,s.yg)(i7o,(0,p.A)({},a7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}l7o.isMDXComponent=!0;const u7o={toc:[]},m7o="wrapper";function y7o(e){let{components:n,...t}=e;return(0,s.yg)(m7o,(0,p.A)({},u7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}y7o.isMDXComponent=!0;const d7o={toc:[]},h7o="wrapper";function g7o(e){let{components:n,...t}=e;return(0,s.yg)(h7o,(0,p.A)({},d7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}g7o.isMDXComponent=!0;const f7o={toc:[]},D7o="wrapper";function M7o(e){let{components:n,...t}=e;return(0,s.yg)(D7o,(0,p.A)({},f7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}M7o.isMDXComponent=!0;const X7o={toc:[]},_7o="wrapper";function w7o(e){let{components:n,...t}=e;return(0,s.yg)(_7o,(0,p.A)({},X7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}w7o.isMDXComponent=!0;const T7o={toc:[]},C7o="wrapper";function x7o(e){let{components:n,...t}=e;return(0,s.yg)(C7o,(0,p.A)({},T7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}x7o.isMDXComponent=!0;const A7o={toc:[]},v7o="wrapper";function L7o(e){let{components:n,...t}=e;return(0,s.yg)(v7o,(0,p.A)({},A7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}L7o.isMDXComponent=!0;const b7o={toc:[]},N7o="wrapper";function k7o(e){let{components:n,...t}=e;return(0,s.yg)(N7o,(0,p.A)({},b7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}k7o.isMDXComponent=!0;const z7o={toc:[]},P7o="wrapper";function I7o(e){let{components:n,...t}=e;return(0,s.yg)(P7o,(0,p.A)({},z7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}I7o.isMDXComponent=!0;const R7o={toc:[]},W7o="wrapper";function S7o(e){let{components:n,...t}=e;return(0,s.yg)(W7o,(0,p.A)({},R7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}S7o.isMDXComponent=!0;const B7o={toc:[]},G7o="wrapper";function E7o(e){let{components:n,...t}=e;return(0,s.yg)(G7o,(0,p.A)({},B7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}E7o.isMDXComponent=!0;const O7o={toc:[]},U7o="wrapper";function F7o(e){let{components:n,...t}=e;return(0,s.yg)(U7o,(0,p.A)({},O7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}F7o.isMDXComponent=!0;const V7o={toc:[]},q7o="wrapper";function j7o(e){let{components:n,...t}=e;return(0,s.yg)(q7o,(0,p.A)({},V7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}j7o.isMDXComponent=!0;const H7o={toc:[]},Y7o="wrapper";function Q7o(e){let{components:n,...t}=e;return(0,s.yg)(Y7o,(0,p.A)({},H7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Q7o.isMDXComponent=!0;const $7o={toc:[]},K7o="wrapper";function J7o(e){let{components:n,...t}=e;return(0,s.yg)(K7o,(0,p.A)({},$7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}J7o.isMDXComponent=!0;const Z7o={toc:[]},e9o="wrapper";function n9o(e){let{components:n,...t}=e;return(0,s.yg)(e9o,(0,p.A)({},Z7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}n9o.isMDXComponent=!0;const t9o={toc:[]},o9o="wrapper";function p9o(e){let{components:n,...t}=e;return(0,s.yg)(o9o,(0,p.A)({},t9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}p9o.isMDXComponent=!0;const r9o={toc:[]},s9o="wrapper";function c9o(e){let{components:n,...t}=e;return(0,s.yg)(s9o,(0,p.A)({},r9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}c9o.isMDXComponent=!0;const a9o={toc:[]},i9o="wrapper";function l9o(e){let{components:n,...t}=e;return(0,s.yg)(i9o,(0,p.A)({},a9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}l9o.isMDXComponent=!0;const u9o={toc:[]},m9o="wrapper";function y9o(e){let{components:n,...t}=e;return(0,s.yg)(m9o,(0,p.A)({},u9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}y9o.isMDXComponent=!0;const d9o={toc:[]},h9o="wrapper";function g9o(e){let{components:n,...t}=e;return(0,s.yg)(h9o,(0,p.A)({},d9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}g9o.isMDXComponent=!0;const f9o={toc:[]},D9o="wrapper";function M9o(e){let{components:n,...t}=e;return(0,s.yg)(D9o,(0,p.A)({},f9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}M9o.isMDXComponent=!0;const X9o={toc:[]},_9o="wrapper";function w9o(e){let{components:n,...t}=e;return(0,s.yg)(_9o,(0,p.A)({},X9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}w9o.isMDXComponent=!0;const T9o={toc:[]},C9o="wrapper";function x9o(e){let{components:n,...t}=e;return(0,s.yg)(C9o,(0,p.A)({},T9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}x9o.isMDXComponent=!0;const A9o={toc:[]},v9o="wrapper";function L9o(e){let{components:n,...t}=e;return(0,s.yg)(v9o,(0,p.A)({},A9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}L9o.isMDXComponent=!0;const b9o={toc:[]},N9o="wrapper";function k9o(e){let{components:n,...t}=e;return(0,s.yg)(N9o,(0,p.A)({},b9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}k9o.isMDXComponent=!0;const z9o={toc:[]},P9o="wrapper";function I9o(e){let{components:n,...t}=e;return(0,s.yg)(P9o,(0,p.A)({},z9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}I9o.isMDXComponent=!0;const R9o={toc:[]},W9o="wrapper";function S9o(e){let{components:n,...t}=e;return(0,s.yg)(W9o,(0,p.A)({},R9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}S9o.isMDXComponent=!0;const B9o={toc:[]},G9o="wrapper";function E9o(e){let{components:n,...t}=e;return(0,s.yg)(G9o,(0,p.A)({},B9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}E9o.isMDXComponent=!0;const O9o={toc:[]},U9o="wrapper";function F9o(e){let{components:n,...t}=e;return(0,s.yg)(U9o,(0,p.A)({},O9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}F9o.isMDXComponent=!0;const V9o={toc:[]},q9o="wrapper";function j9o(e){let{components:n,...t}=e;return(0,s.yg)(q9o,(0,p.A)({},V9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}j9o.isMDXComponent=!0;const H9o={toc:[]},Y9o="wrapper";function Q9o(e){let{components:n,...t}=e;return(0,s.yg)(Y9o,(0,p.A)({},H9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Q9o.isMDXComponent=!0;const $9o={toc:[]},K9o="wrapper";function J9o(e){let{components:n,...t}=e;return(0,s.yg)(K9o,(0,p.A)({},$9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}J9o.isMDXComponent=!0;const Z9o={toc:[]},eep="wrapper";function nep(e){let{components:n,...t}=e;return(0,s.yg)(eep,(0,p.A)({},Z9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}nep.isMDXComponent=!0;const tep={toc:[]},oep="wrapper";function pep(e){let{components:n,...t}=e;return(0,s.yg)(oep,(0,p.A)({},tep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}pep.isMDXComponent=!0;const rep={toc:[]},sep="wrapper";function cep(e){let{components:n,...t}=e;return(0,s.yg)(sep,(0,p.A)({},rep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}cep.isMDXComponent=!0;const aep={toc:[]},iep="wrapper";function lep(e){let{components:n,...t}=e;return(0,s.yg)(iep,(0,p.A)({},aep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}lep.isMDXComponent=!0;const uep={toc:[]},mep="wrapper";function yep(e){let{components:n,...t}=e;return(0,s.yg)(mep,(0,p.A)({},uep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}yep.isMDXComponent=!0;const dep={toc:[]},hep="wrapper";function gep(e){let{components:n,...t}=e;return(0,s.yg)(hep,(0,p.A)({},dep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gep.isMDXComponent=!0;const fep={toc:[]},Dep="wrapper";function Mep(e){let{components:n,...t}=e;return(0,s.yg)(Dep,(0,p.A)({},fep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Mep.isMDXComponent=!0;const Xep={toc:[]},_ep="wrapper";function wep(e){let{components:n,...t}=e;return(0,s.yg)(_ep,(0,p.A)({},Xep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wep.isMDXComponent=!0;const Tep={toc:[]},Cep="wrapper";function xep(e){let{components:n,...t}=e;return(0,s.yg)(Cep,(0,p.A)({},Tep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}xep.isMDXComponent=!0;const Aep={toc:[]},vep="wrapper";function Lep(e){let{components:n,...t}=e;return(0,s.yg)(vep,(0,p.A)({},Aep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Lep.isMDXComponent=!0;const bep={toc:[]},Nep="wrapper";function kep(e){let{components:n,...t}=e;return(0,s.yg)(Nep,(0,p.A)({},bep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kep.isMDXComponent=!0;const zep={toc:[]},Pep="wrapper";function Iep(e){let{components:n,...t}=e;return(0,s.yg)(Pep,(0,p.A)({},zep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Iep.isMDXComponent=!0;const Rep={toc:[]},Wep="wrapper";function Sep(e){let{components:n,...t}=e;return(0,s.yg)(Wep,(0,p.A)({},Rep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Sep.isMDXComponent=!0;const Bep={toc:[]},Gep="wrapper";function Eep(e){let{components:n,...t}=e;return(0,s.yg)(Gep,(0,p.A)({},Bep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Eep.isMDXComponent=!0;const Oep={toc:[]},Uep="wrapper";function Fep(e){let{components:n,...t}=e;return(0,s.yg)(Uep,(0,p.A)({},Oep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Fep.isMDXComponent=!0;const Vep={toc:[]},qep="wrapper";function jep(e){let{components:n,...t}=e;return(0,s.yg)(qep,(0,p.A)({},Vep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}jep.isMDXComponent=!0;const Hep={toc:[]},Yep="wrapper";function Qep(e){let{components:n,...t}=e;return(0,s.yg)(Yep,(0,p.A)({},Hep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Qep.isMDXComponent=!0;const $ep={toc:[]},Kep="wrapper";function Jep(e){let{components:n,...t}=e;return(0,s.yg)(Kep,(0,p.A)({},$ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Jep.isMDXComponent=!0;const Zep={toc:[]},enp="wrapper";function nnp(e){let{components:n,...t}=e;return(0,s.yg)(enp,(0,p.A)({},Zep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nnp.isMDXComponent=!0;const tnp={toc:[]},onp="wrapper";function pnp(e){let{components:n,...t}=e;return(0,s.yg)(onp,(0,p.A)({},tnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pnp.isMDXComponent=!0;const rnp={toc:[]},snp="wrapper";function cnp(e){let{components:n,...t}=e;return(0,s.yg)(snp,(0,p.A)({},rnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}cnp.isMDXComponent=!0;const anp={toc:[]},inp="wrapper";function lnp(e){let{components:n,...t}=e;return(0,s.yg)(inp,(0,p.A)({},anp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}lnp.isMDXComponent=!0;const unp={toc:[]},mnp="wrapper";function ynp(e){let{components:n,...t}=e;return(0,s.yg)(mnp,(0,p.A)({},unp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}ynp.isMDXComponent=!0;const dnp={toc:[]},hnp="wrapper";function gnp(e){let{components:n,...t}=e;return(0,s.yg)(hnp,(0,p.A)({},dnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gnp.isMDXComponent=!0;const fnp={toc:[]},Dnp="wrapper";function Mnp(e){let{components:n,...t}=e;return(0,s.yg)(Dnp,(0,p.A)({},fnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Mnp.isMDXComponent=!0;const Xnp={toc:[]},_np="wrapper";function wnp(e){let{components:n,...t}=e;return(0,s.yg)(_np,(0,p.A)({},Xnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wnp.isMDXComponent=!0;const Tnp={toc:[]},Cnp="wrapper";function xnp(e){let{components:n,...t}=e;return(0,s.yg)(Cnp,(0,p.A)({},Tnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}xnp.isMDXComponent=!0;const Anp={toc:[]},vnp="wrapper";function Lnp(e){let{components:n,...t}=e;return(0,s.yg)(vnp,(0,p.A)({},Anp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Lnp.isMDXComponent=!0;const bnp={toc:[]},Nnp="wrapper";function knp(e){let{components:n,...t}=e;return(0,s.yg)(Nnp,(0,p.A)({},bnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}knp.isMDXComponent=!0;const znp={toc:[]},Pnp="wrapper";function Inp(e){let{components:n,...t}=e;return(0,s.yg)(Pnp,(0,p.A)({},znp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Inp.isMDXComponent=!0;const Rnp={toc:[]},Wnp="wrapper";function Snp(e){let{components:n,...t}=e;return(0,s.yg)(Wnp,(0,p.A)({},Rnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Snp.isMDXComponent=!0;const Bnp={toc:[]},Gnp="wrapper";function Enp(e){let{components:n,...t}=e;return(0,s.yg)(Gnp,(0,p.A)({},Bnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Enp.isMDXComponent=!0;const Onp={toc:[]},Unp="wrapper";function Fnp(e){let{components:n,...t}=e;return(0,s.yg)(Unp,(0,p.A)({},Onp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fnp.isMDXComponent=!0;const Vnp={toc:[]},qnp="wrapper";function jnp(e){let{components:n,...t}=e;return(0,s.yg)(qnp,(0,p.A)({},Vnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}jnp.isMDXComponent=!0;const Hnp={toc:[]},Ynp="wrapper";function Qnp(e){let{components:n,...t}=e;return(0,s.yg)(Ynp,(0,p.A)({},Hnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Qnp.isMDXComponent=!0;const $np={toc:[]},Knp="wrapper";function Jnp(e){let{components:n,...t}=e;return(0,s.yg)(Knp,(0,p.A)({},$np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Jnp.isMDXComponent=!0;const Znp={toc:[]},etp="wrapper";function ntp(e){let{components:n,...t}=e;return(0,s.yg)(etp,(0,p.A)({},Znp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}ntp.isMDXComponent=!0;const ttp={toc:[]},otp="wrapper";function ptp(e){let{components:n,...t}=e;return(0,s.yg)(otp,(0,p.A)({},ttp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}ptp.isMDXComponent=!0;const rtp={toc:[]},stp="wrapper";function ctp(e){let{components:n,...t}=e;return(0,s.yg)(stp,(0,p.A)({},rtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}ctp.isMDXComponent=!0;const atp={toc:[]},itp="wrapper";function ltp(e){let{components:n,...t}=e;return(0,s.yg)(itp,(0,p.A)({},atp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}ltp.isMDXComponent=!0;const utp={toc:[]},mtp="wrapper";function ytp(e){let{components:n,...t}=e;return(0,s.yg)(mtp,(0,p.A)({},utp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}ytp.isMDXComponent=!0;const dtp={toc:[]},htp="wrapper";function gtp(e){let{components:n,...t}=e;return(0,s.yg)(htp,(0,p.A)({},dtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}gtp.isMDXComponent=!0;const ftp={toc:[]},Dtp="wrapper";function Mtp(e){let{components:n,...t}=e;return(0,s.yg)(Dtp,(0,p.A)({},ftp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Mtp.isMDXComponent=!0;const Xtp={toc:[]},_tp="wrapper";function wtp(e){let{components:n,...t}=e;return(0,s.yg)(_tp,(0,p.A)({},Xtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}wtp.isMDXComponent=!0;const Ttp={toc:[]},Ctp="wrapper";function xtp(e){let{components:n,...t}=e;return(0,s.yg)(Ctp,(0,p.A)({},Ttp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}xtp.isMDXComponent=!0;const Atp={toc:[]},vtp="wrapper";function Ltp(e){let{components:n,...t}=e;return(0,s.yg)(vtp,(0,p.A)({},Atp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Ltp.isMDXComponent=!0;const btp={toc:[]},Ntp="wrapper";function ktp(e){let{components:n,...t}=e;return(0,s.yg)(Ntp,(0,p.A)({},btp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}ktp.isMDXComponent=!0;const ztp={toc:[]},Ptp="wrapper";function Itp(e){let{components:n,...t}=e;return(0,s.yg)(Ptp,(0,p.A)({},ztp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Itp.isMDXComponent=!0;const Rtp={toc:[]},Wtp="wrapper";function Stp(e){let{components:n,...t}=e;return(0,s.yg)(Wtp,(0,p.A)({},Rtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Stp.isMDXComponent=!0;const Btp={toc:[]},Gtp="wrapper";function Etp(e){let{components:n,...t}=e;return(0,s.yg)(Gtp,(0,p.A)({},Btp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Etp.isMDXComponent=!0;const Otp={toc:[]},Utp="wrapper";function Ftp(e){let{components:n,...t}=e;return(0,s.yg)(Utp,(0,p.A)({},Otp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Ftp.isMDXComponent=!0;const Vtp={toc:[]},qtp="wrapper";function jtp(e){let{components:n,...t}=e;return(0,s.yg)(qtp,(0,p.A)({},Vtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}jtp.isMDXComponent=!0;const Htp={toc:[]},Ytp="wrapper";function Qtp(e){let{components:n,...t}=e;return(0,s.yg)(Ytp,(0,p.A)({},Htp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Qtp.isMDXComponent=!0;const $tp={toc:[]},Ktp="wrapper";function Jtp(e){let{components:n,...t}=e;return(0,s.yg)(Ktp,(0,p.A)({},$tp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Jtp.isMDXComponent=!0;const Ztp={toc:[]},eop="wrapper";function nop(e){let{components:n,...t}=e;return(0,s.yg)(eop,(0,p.A)({},Ztp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}nop.isMDXComponent=!0;const top={toc:[]},oop="wrapper";function pop(e){let{components:n,...t}=e;return(0,s.yg)(oop,(0,p.A)({},top,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pop.isMDXComponent=!0;const rop={toc:[]},sop="wrapper";function cop(e){let{components:n,...t}=e;return(0,s.yg)(sop,(0,p.A)({},rop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}cop.isMDXComponent=!0;const aop={toc:[]},iop="wrapper";function lop(e){let{components:n,...t}=e;return(0,s.yg)(iop,(0,p.A)({},aop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}lop.isMDXComponent=!0;const uop={toc:[]},mop="wrapper";function yop(e){let{components:n,...t}=e;return(0,s.yg)(mop,(0,p.A)({},uop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}yop.isMDXComponent=!0;const dop={toc:[]},hop="wrapper";function gop(e){let{components:n,...t}=e;return(0,s.yg)(hop,(0,p.A)({},dop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gop.isMDXComponent=!0;const fop={toc:[]},Dop="wrapper";function Mop(e){let{components:n,...t}=e;return(0,s.yg)(Dop,(0,p.A)({},fop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Mop.isMDXComponent=!0;const Xop={toc:[]},_op="wrapper";function wop(e){let{components:n,...t}=e;return(0,s.yg)(_op,(0,p.A)({},Xop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}wop.isMDXComponent=!0;const Top={toc:[]},Cop="wrapper";function xop(e){let{components:n,...t}=e;return(0,s.yg)(Cop,(0,p.A)({},Top,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xop.isMDXComponent=!0;const Aop={toc:[]},vop="wrapper";function Lop(e){let{components:n,...t}=e;return(0,s.yg)(vop,(0,p.A)({},Aop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Lop.isMDXComponent=!0;const bop={toc:[]},Nop="wrapper";function kop(e){let{components:n,...t}=e;return(0,s.yg)(Nop,(0,p.A)({},bop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kop.isMDXComponent=!0;const zop={toc:[]},Pop="wrapper";function Iop(e){let{components:n,...t}=e;return(0,s.yg)(Pop,(0,p.A)({},zop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Iop.isMDXComponent=!0;const Rop={toc:[]},Wop="wrapper";function Sop(e){let{components:n,...t}=e;return(0,s.yg)(Wop,(0,p.A)({},Rop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Sop.isMDXComponent=!0;const Bop={toc:[]},Gop="wrapper";function Eop(e){let{components:n,...t}=e;return(0,s.yg)(Gop,(0,p.A)({},Bop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Eop.isMDXComponent=!0;const Oop={toc:[]},Uop="wrapper";function Fop(e){let{components:n,...t}=e;return(0,s.yg)(Uop,(0,p.A)({},Oop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Fop.isMDXComponent=!0;const Vop={toc:[]},qop="wrapper";function jop(e){let{components:n,...t}=e;return(0,s.yg)(qop,(0,p.A)({},Vop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}jop.isMDXComponent=!0;const Hop={toc:[]},Yop="wrapper";function Qop(e){let{components:n,...t}=e;return(0,s.yg)(Yop,(0,p.A)({},Hop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Qop.isMDXComponent=!0;const $op={toc:[]},Kop="wrapper";function Jop(e){let{components:n,...t}=e;return(0,s.yg)(Kop,(0,p.A)({},$op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Jop.isMDXComponent=!0;const Zop={toc:[]},epp="wrapper";function npp(e){let{components:n,...t}=e;return(0,s.yg)(epp,(0,p.A)({},Zop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}npp.isMDXComponent=!0;const tpp={toc:[]},opp="wrapper";function ppp(e){let{components:n,...t}=e;return(0,s.yg)(opp,(0,p.A)({},tpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ppp.isMDXComponent=!0;const rpp={toc:[]},spp="wrapper";function cpp(e){let{components:n,...t}=e;return(0,s.yg)(spp,(0,p.A)({},rpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cpp.isMDXComponent=!0;const app={toc:[]},ipp="wrapper";function lpp(e){let{components:n,...t}=e;return(0,s.yg)(ipp,(0,p.A)({},app,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lpp.isMDXComponent=!0;const upp={toc:[]},mpp="wrapper";function ypp(e){let{components:n,...t}=e;return(0,s.yg)(mpp,(0,p.A)({},upp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}ypp.isMDXComponent=!0;const dpp={toc:[]},hpp="wrapper";function gpp(e){let{components:n,...t}=e;return(0,s.yg)(hpp,(0,p.A)({},dpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gpp.isMDXComponent=!0;const fpp={toc:[]},Dpp="wrapper";function Mpp(e){let{components:n,...t}=e;return(0,s.yg)(Dpp,(0,p.A)({},fpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Mpp.isMDXComponent=!0;const Xpp={toc:[]},_pp="wrapper";function wpp(e){let{components:n,...t}=e;return(0,s.yg)(_pp,(0,p.A)({},Xpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wpp.isMDXComponent=!0;const Tpp={toc:[]},Cpp="wrapper";function xpp(e){let{components:n,...t}=e;return(0,s.yg)(Cpp,(0,p.A)({},Tpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xpp.isMDXComponent=!0;const App={toc:[]},vpp="wrapper";function Lpp(e){let{components:n,...t}=e;return(0,s.yg)(vpp,(0,p.A)({},App,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Lpp.isMDXComponent=!0;const bpp={toc:[]},Npp="wrapper";function kpp(e){let{components:n,...t}=e;return(0,s.yg)(Npp,(0,p.A)({},bpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kpp.isMDXComponent=!0;const zpp={toc:[]},Ppp="wrapper";function Ipp(e){let{components:n,...t}=e;return(0,s.yg)(Ppp,(0,p.A)({},zpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Ipp.isMDXComponent=!0;const Rpp={toc:[]},Wpp="wrapper";function Spp(e){let{components:n,...t}=e;return(0,s.yg)(Wpp,(0,p.A)({},Rpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut for"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontWeight={700} />\n")))}Spp.isMDXComponent=!0;const Bpp={toc:[]},Gpp="wrapper";function Epp(e){let{components:n,...t}=e;return(0,s.yg)(Gpp,(0,p.A)({},Bpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a bold text node."))}Epp.isMDXComponent=!0;const Opp={toc:[]},Upp="wrapper";function Fpp(e){let{components:n,...t}=e;return(0,s.yg)(Upp,(0,p.A)({},Opp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional text properties."))}Fpp.isMDXComponent=!0;const Vpp={toc:[]},qpp="wrapper";function jpp(e){let{components:n,...t}=e;return(0,s.yg)(qpp,(0,p.A)({},Vpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut for"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontStyle={'italic'} />\n")))}jpp.isMDXComponent=!0;const Hpp={toc:[]},Ypp="wrapper";function Qpp(e){let{components:n,...t}=e;return(0,s.yg)(Ypp,(0,p.A)({},Hpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an italic text node."))}Qpp.isMDXComponent=!0;const $pp={toc:[]},Kpp="wrapper";function Jpp(e){let{components:n,...t}=e;return(0,s.yg)(Kpp,(0,p.A)({},$pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional text properties."))}Jpp.isMDXComponent=!0;const Zpp={toc:[]},erp="wrapper";function nrp(e){let{components:n,...t}=e;return(0,s.yg)(erp,(0,p.A)({},Zpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}nrp.isMDXComponent=!0;const trp={toc:[]},orp="wrapper";function prp(e){let{components:n,...t}=e;return(0,s.yg)(orp,(0,p.A)({},trp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}prp.isMDXComponent=!0;const rrp={toc:[]},srp="wrapper";function crp(e){let{components:n,...t}=e;return(0,s.yg)(srp,(0,p.A)({},rrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}crp.isMDXComponent=!0;const arp={toc:[]},irp="wrapper";function lrp(e){let{components:n,...t}=e;return(0,s.yg)(irp,(0,p.A)({},arp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}lrp.isMDXComponent=!0;const urp={toc:[]},mrp="wrapper";function yrp(e){let{components:n,...t}=e;return(0,s.yg)(mrp,(0,p.A)({},urp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}yrp.isMDXComponent=!0;const drp={toc:[]},hrp="wrapper";function grp(e){let{components:n,...t}=e;return(0,s.yg)(hrp,(0,p.A)({},drp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}grp.isMDXComponent=!0;const frp={toc:[]},Drp="wrapper";function Mrp(e){let{components:n,...t}=e;return(0,s.yg)(Drp,(0,p.A)({},frp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Mrp.isMDXComponent=!0;const Xrp={toc:[]},_rp="wrapper";function wrp(e){let{components:n,...t}=e;return(0,s.yg)(_rp,(0,p.A)({},Xrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this video."))}wrp.isMDXComponent=!0;const Trp={toc:[]},Crp="wrapper";function xrp(e){let{components:n,...t}=e;return(0,s.yg)(Crp,(0,p.A)({},Trp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}xrp.isMDXComponent=!0;const Arp={toc:[]},vrp="wrapper";function Lrp(e){let{components:n,...t}=e;return(0,s.yg)(vrp,(0,p.A)({},Arp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Lrp.isMDXComponent=!0;const brp={toc:[]},Nrp="wrapper";function krp(e){let{components:n,...t}=e;return(0,s.yg)(Nrp,(0,p.A)({},brp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}krp.isMDXComponent=!0;const zrp={toc:[]},Prp="wrapper";function Irp(e){let{components:n,...t}=e;return(0,s.yg)(Prp,(0,p.A)({},zrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Irp.isMDXComponent=!0;const Rrp={toc:[]},Wrp="wrapper";function Srp(e){let{components:n,...t}=e;return(0,s.yg)(Wrp,(0,p.A)({},Rrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Srp.isMDXComponent=!0;const Brp={toc:[]},Grp="wrapper";function Erp(e){let{components:n,...t}=e;return(0,s.yg)(Grp,(0,p.A)({},Brp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Erp.isMDXComponent=!0;const Orp={toc:[]},Urp="wrapper";function Frp(e){let{components:n,...t}=e;return(0,s.yg)(Urp,(0,p.A)({},Orp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Frp.isMDXComponent=!0;const Vrp={toc:[]},qrp="wrapper";function jrp(e){let{components:n,...t}=e;return(0,s.yg)(qrp,(0,p.A)({},Vrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}jrp.isMDXComponent=!0;const Hrp={toc:[]},Yrp="wrapper";function Qrp(e){let{components:n,...t}=e;return(0,s.yg)(Yrp,(0,p.A)({},Hrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Qrp.isMDXComponent=!0;const $rp={toc:[]},Krp="wrapper";function Jrp(e){let{components:n,...t}=e;return(0,s.yg)(Krp,(0,p.A)({},$rp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Jrp.isMDXComponent=!0;const Zrp={toc:[]},esp="wrapper";function nsp(e){let{components:n,...t}=e;return(0,s.yg)(esp,(0,p.A)({},Zrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}nsp.isMDXComponent=!0;const tsp={toc:[]},osp="wrapper";function psp(e){let{components:n,...t}=e;return(0,s.yg)(osp,(0,p.A)({},tsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}psp.isMDXComponent=!0;const rsp={toc:[]},ssp="wrapper";function csp(e){let{components:n,...t}=e;return(0,s.yg)(ssp,(0,p.A)({},rsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}csp.isMDXComponent=!0;const asp={toc:[]},isp="wrapper";function lsp(e){let{components:n,...t}=e;return(0,s.yg)(isp,(0,p.A)({},asp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}lsp.isMDXComponent=!0;const usp={toc:[]},msp="wrapper";function ysp(e){let{components:n,...t}=e;return(0,s.yg)(msp,(0,p.A)({},usp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}ysp.isMDXComponent=!0;const dsp={toc:[]},hsp="wrapper";function gsp(e){let{components:n,...t}=e;return(0,s.yg)(hsp,(0,p.A)({},dsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}gsp.isMDXComponent=!0;const fsp={toc:[]},Dsp="wrapper";function Msp(e){let{components:n,...t}=e;return(0,s.yg)(Dsp,(0,p.A)({},fsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Msp.isMDXComponent=!0;const Xsp={toc:[]},_sp="wrapper";function wsp(e){let{components:n,...t}=e;return(0,s.yg)(_sp,(0,p.A)({},Xsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wsp.isMDXComponent=!0;const Tsp={toc:[]},Csp="wrapper";function xsp(e){let{components:n,...t}=e;return(0,s.yg)(Csp,(0,p.A)({},Tsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}xsp.isMDXComponent=!0;const Asp={toc:[]},vsp="wrapper";function Lsp(e){let{components:n,...t}=e;return(0,s.yg)(vsp,(0,p.A)({},Asp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Lsp.isMDXComponent=!0;const bsp={toc:[]},Nsp="wrapper";function ksp(e){let{components:n,...t}=e;return(0,s.yg)(Nsp,(0,p.A)({},bsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}ksp.isMDXComponent=!0;const zsp={toc:[]},Psp="wrapper";function Isp(e){let{components:n,...t}=e;return(0,s.yg)(Psp,(0,p.A)({},zsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Isp.isMDXComponent=!0;const Rsp={toc:[]},Wsp="wrapper";function Ssp(e){let{components:n,...t}=e;return(0,s.yg)(Wsp,(0,p.A)({},Rsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ssp.isMDXComponent=!0;const Bsp={toc:[]},Gsp="wrapper";function Esp(e){let{components:n,...t}=e;return(0,s.yg)(Gsp,(0,p.A)({},Bsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Esp.isMDXComponent=!0;const Osp={toc:[]},Usp="wrapper";function Fsp(e){let{components:n,...t}=e;return(0,s.yg)(Usp,(0,p.A)({},Osp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Fsp.isMDXComponent=!0;const Vsp={toc:[]},qsp="wrapper";function jsp(e){let{components:n,...t}=e;return(0,s.yg)(qsp,(0,p.A)({},Vsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}jsp.isMDXComponent=!0;const Hsp={toc:[]},Ysp="wrapper";function Qsp(e){let{components:n,...t}=e;return(0,s.yg)(Ysp,(0,p.A)({},Hsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Qsp.isMDXComponent=!0;const $sp={toc:[]},Ksp="wrapper";function Jsp(e){let{components:n,...t}=e;return(0,s.yg)(Ksp,(0,p.A)({},$sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Jsp.isMDXComponent=!0;const Zsp={toc:[]},ecp="wrapper";function ncp(e){let{components:n,...t}=e;return(0,s.yg)(ecp,(0,p.A)({},Zsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}ncp.isMDXComponent=!0;const tcp={toc:[]},ocp="wrapper";function pcp(e){let{components:n,...t}=e;return(0,s.yg)(ocp,(0,p.A)({},tcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pcp.isMDXComponent=!0;const rcp={toc:[]},scp="wrapper";function ccp(e){let{components:n,...t}=e;return(0,s.yg)(scp,(0,p.A)({},rcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}ccp.isMDXComponent=!0;const acp={toc:[]},icp="wrapper";function lcp(e){let{components:n,...t}=e;return(0,s.yg)(icp,(0,p.A)({},acp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lcp.isMDXComponent=!0;const ucp={toc:[]},mcp="wrapper";function ycp(e){let{components:n,...t}=e;return(0,s.yg)(mcp,(0,p.A)({},ucp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}ycp.isMDXComponent=!0;const dcp={toc:[]},hcp="wrapper";function gcp(e){let{components:n,...t}=e;return(0,s.yg)(hcp,(0,p.A)({},dcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}gcp.isMDXComponent=!0;const fcp={toc:[]},Dcp="wrapper";function Mcp(e){let{components:n,...t}=e;return(0,s.yg)(Dcp,(0,p.A)({},fcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Mcp.isMDXComponent=!0;const Xcp={toc:[]},_cp="wrapper";function wcp(e){let{components:n,...t}=e;return(0,s.yg)(_cp,(0,p.A)({},Xcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wcp.isMDXComponent=!0;const Tcp={toc:[]},Ccp="wrapper";function xcp(e){let{components:n,...t}=e;return(0,s.yg)(Ccp,(0,p.A)({},Tcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}xcp.isMDXComponent=!0;const Acp={toc:[]},vcp="wrapper";function Lcp(e){let{components:n,...t}=e;return(0,s.yg)(vcp,(0,p.A)({},Acp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Lcp.isMDXComponent=!0;const bcp={toc:[]},Ncp="wrapper";function kcp(e){let{components:n,...t}=e;return(0,s.yg)(Ncp,(0,p.A)({},bcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kcp.isMDXComponent=!0;const zcp={toc:[]},Pcp="wrapper";function Icp(e){let{components:n,...t}=e;return(0,s.yg)(Pcp,(0,p.A)({},zcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Icp.isMDXComponent=!0;const Rcp={toc:[]},Wcp="wrapper";function Scp(e){let{components:n,...t}=e;return(0,s.yg)(Wcp,(0,p.A)({},Rcp,t,{components:n,mdxType:"MDXLayout"}))}Scp.isMDXComponent=!0;const Bcp={toc:[]},Gcp="wrapper";function Ecp(e){let{components:n,...t}=e;return(0,s.yg)(Gcp,(0,p.A)({},Bcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ecp.isMDXComponent=!0;const Ocp={toc:[]},Ucp="wrapper";function Fcp(e){let{components:n,...t}=e;return(0,s.yg)(Ucp,(0,p.A)({},Ocp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Fcp.isMDXComponent=!0;const Vcp={toc:[]},qcp="wrapper";function jcp(e){let{components:n,...t}=e;return(0,s.yg)(qcp,(0,p.A)({},Vcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}jcp.isMDXComponent=!0;const Hcp={toc:[]},Ycp="wrapper";function Qcp(e){let{components:n,...t}=e;return(0,s.yg)(Ycp,(0,p.A)({},Hcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Qcp.isMDXComponent=!0;const $cp={toc:[]},Kcp="wrapper";function Jcp(e){let{components:n,...t}=e;return(0,s.yg)(Kcp,(0,p.A)({},$cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Jcp.isMDXComponent=!0;const Zcp={toc:[]},eap="wrapper";function nap(e){let{components:n,...t}=e;return(0,s.yg)(eap,(0,p.A)({},Zcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}nap.isMDXComponent=!0;const tap={toc:[]},oap="wrapper";function pap(e){let{components:n,...t}=e;return(0,s.yg)(oap,(0,p.A)({},tap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}pap.isMDXComponent=!0;const rap={toc:[]},sap="wrapper";function cap(e){let{components:n,...t}=e;return(0,s.yg)(sap,(0,p.A)({},rap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}cap.isMDXComponent=!0;const aap={toc:[]},iap="wrapper";function lap(e){let{components:n,...t}=e;return(0,s.yg)(iap,(0,p.A)({},aap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}lap.isMDXComponent=!0;const uap={toc:[]},map="wrapper";function yap(e){let{components:n,...t}=e;return(0,s.yg)(map,(0,p.A)({},uap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}yap.isMDXComponent=!0;const dap={toc:[]},hap="wrapper";function gap(e){let{components:n,...t}=e;return(0,s.yg)(hap,(0,p.A)({},dap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video should be smoothed."))}gap.isMDXComponent=!0;const fap={toc:[]},Dap="wrapper";function Map(e){let{components:n,...t}=e;return(0,s.yg)(Dap,(0,p.A)({},fap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Map.isMDXComponent=!0;const Xap={toc:[]},_ap="wrapper";function wap(e){let{components:n,...t}=e;return(0,s.yg)(_ap,(0,p.A)({},Xap,t,{components:n,mdxType:"MDXLayout"}))}wap.isMDXComponent=!0;const Tap={toc:[]},Cap="wrapper";function xap(e){let{components:n,...t}=e;return(0,s.yg)(Cap,(0,p.A)({},Tap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}xap.isMDXComponent=!0;const Aap={toc:[]},vap="wrapper";function Lap(e){let{components:n,...t}=e;return(0,s.yg)(vap,(0,p.A)({},Aap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Lap.isMDXComponent=!0;const bap={toc:[]},Nap="wrapper";function kap(e){let{components:n,...t}=e;return(0,s.yg)(Nap,(0,p.A)({},bap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kap.isMDXComponent=!0;const zap={toc:[]},Pap="wrapper";function Iap(e){let{components:n,...t}=e;return(0,s.yg)(Pap,(0,p.A)({},zap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Iap.isMDXComponent=!0;const Rap={toc:[]},Wap="wrapper";function Sap(e){let{components:n,...t}=e;return(0,s.yg)(Wap,(0,p.A)({},Rap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Sap.isMDXComponent=!0;const Bap={toc:[]},Gap="wrapper";function Eap(e){let{components:n,...t}=e;return(0,s.yg)(Gap,(0,p.A)({},Bap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Eap.isMDXComponent=!0;const Oap={toc:[]},Uap="wrapper";function Fap(e){let{components:n,...t}=e;return(0,s.yg)(Uap,(0,p.A)({},Oap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Fap.isMDXComponent=!0;const Vap={toc:[]},qap="wrapper";function jap(e){let{components:n,...t}=e;return(0,s.yg)(qap,(0,p.A)({},Vap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}jap.isMDXComponent=!0;const Hap={toc:[]},Yap="wrapper";function Qap(e){let{components:n,...t}=e;return(0,s.yg)(Yap,(0,p.A)({},Hap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Qap.isMDXComponent=!0;const $ap={toc:[]},Kap="wrapper";function Jap(e){let{components:n,...t}=e;return(0,s.yg)(Kap,(0,p.A)({},$ap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Jap.isMDXComponent=!0;const Zap={toc:[]},eip="wrapper";function nip(e){let{components:n,...t}=e;return(0,s.yg)(eip,(0,p.A)({},Zap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}nip.isMDXComponent=!0;const tip={toc:[]},oip="wrapper";function pip(e){let{components:n,...t}=e;return(0,s.yg)(oip,(0,p.A)({},tip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}pip.isMDXComponent=!0;const rip={toc:[]},sip="wrapper";function cip(e){let{components:n,...t}=e;return(0,s.yg)(sip,(0,p.A)({},rip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}cip.isMDXComponent=!0;const aip={toc:[]},iip="wrapper";function lip(e){let{components:n,...t}=e;return(0,s.yg)(iip,(0,p.A)({},aip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lip.isMDXComponent=!0;const uip={toc:[]},mip="wrapper";function yip(e){let{components:n,...t}=e;return(0,s.yg)(mip,(0,p.A)({},uip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}yip.isMDXComponent=!0;const dip={toc:[]},hip="wrapper";function gip(e){let{components:n,...t}=e;return(0,s.yg)(hip,(0,p.A)({},dip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}gip.isMDXComponent=!0;const fip={toc:[]},Dip="wrapper";function Mip(e){let{components:n,...t}=e;return(0,s.yg)(Dip,(0,p.A)({},fip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Mip.isMDXComponent=!0;const Xip={toc:[]},_ip="wrapper";function wip(e){let{components:n,...t}=e;return(0,s.yg)(_ip,(0,p.A)({},Xip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}wip.isMDXComponent=!0;const Tip={toc:[]},Cip="wrapper";function xip(e){let{components:n,...t}=e;return(0,s.yg)(Cip,(0,p.A)({},Tip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}xip.isMDXComponent=!0;const Aip={toc:[]},vip="wrapper";function Lip(e){let{components:n,...t}=e;return(0,s.yg)(vip,(0,p.A)({},Aip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Lip.isMDXComponent=!0;const bip={toc:[]},Nip="wrapper";function kip(e){let{components:n,...t}=e;return(0,s.yg)(Nip,(0,p.A)({},bip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}kip.isMDXComponent=!0;const zip={toc:[]},Pip="wrapper";function Iip(e){let{components:n,...t}=e;return(0,s.yg)(Pip,(0,p.A)({},zip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Iip.isMDXComponent=!0;const Rip={toc:[]},Wip="wrapper";function Sip(e){let{components:n,...t}=e;return(0,s.yg)(Wip,(0,p.A)({},Rip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Sip.isMDXComponent=!0;const Bip={toc:[]},Gip="wrapper";function Eip(e){let{components:n,...t}=e;return(0,s.yg)(Gip,(0,p.A)({},Bip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Eip.isMDXComponent=!0;const Oip={toc:[]},Uip="wrapper";function Fip(e){let{components:n,...t}=e;return(0,s.yg)(Uip,(0,p.A)({},Oip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Fip.isMDXComponent=!0;const Vip={toc:[]},qip="wrapper";function jip(e){let{components:n,...t}=e;return(0,s.yg)(qip,(0,p.A)({},Vip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}jip.isMDXComponent=!0;const Hip={toc:[]},Yip="wrapper";function Qip(e){let{components:n,...t}=e;return(0,s.yg)(Yip,(0,p.A)({},Hip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Qip.isMDXComponent=!0;const $ip={toc:[]},Kip="wrapper";function Jip(e){let{components:n,...t}=e;return(0,s.yg)(Kip,(0,p.A)({},$ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Jip.isMDXComponent=!0;const Zip={toc:[]},elp="wrapper";function nlp(e){let{components:n,...t}=e;return(0,s.yg)(elp,(0,p.A)({},Zip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}nlp.isMDXComponent=!0;const tlp={toc:[]},olp="wrapper";function plp(e){let{components:n,...t}=e;return(0,s.yg)(olp,(0,p.A)({},tlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}plp.isMDXComponent=!0;const rlp={toc:[]},slp="wrapper";function clp(e){let{components:n,...t}=e;return(0,s.yg)(slp,(0,p.A)({},rlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}clp.isMDXComponent=!0;const alp={toc:[]},ilp="wrapper";function llp(e){let{components:n,...t}=e;return(0,s.yg)(ilp,(0,p.A)({},alp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}llp.isMDXComponent=!0;const ulp={toc:[]},mlp="wrapper";function ylp(e){let{components:n,...t}=e;return(0,s.yg)(mlp,(0,p.A)({},ulp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ylp.isMDXComponent=!0;const dlp={toc:[]},hlp="wrapper";function glp(e){let{components:n,...t}=e;return(0,s.yg)(hlp,(0,p.A)({},dlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}glp.isMDXComponent=!0;const flp={toc:[]},Dlp="wrapper";function Mlp(e){let{components:n,...t}=e;return(0,s.yg)(Dlp,(0,p.A)({},flp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Mlp.isMDXComponent=!0;const Xlp={toc:[]},_lp="wrapper";function wlp(e){let{components:n,...t}=e;return(0,s.yg)(_lp,(0,p.A)({},Xlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}wlp.isMDXComponent=!0;const Tlp={toc:[]},Clp="wrapper";function xlp(e){let{components:n,...t}=e;return(0,s.yg)(Clp,(0,p.A)({},Tlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}xlp.isMDXComponent=!0;const Alp={toc:[]},vlp="wrapper";function Llp(e){let{components:n,...t}=e;return(0,s.yg)(vlp,(0,p.A)({},Alp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Llp.isMDXComponent=!0;const blp={toc:[]},Nlp="wrapper";function klp(e){let{components:n,...t}=e;return(0,s.yg)(Nlp,(0,p.A)({},blp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}klp.isMDXComponent=!0;const zlp={toc:[]},Plp="wrapper";function Ilp(e){let{components:n,...t}=e;return(0,s.yg)(Plp,(0,p.A)({},zlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ilp.isMDXComponent=!0;const Rlp={toc:[]},Wlp="wrapper";function Slp(e){let{components:n,...t}=e;return(0,s.yg)(Wlp,(0,p.A)({},Rlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Slp.isMDXComponent=!0;const Blp={toc:[]},Glp="wrapper";function Elp(e){let{components:n,...t}=e;return(0,s.yg)(Glp,(0,p.A)({},Blp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Elp.isMDXComponent=!0;const Olp={toc:[]},Ulp="wrapper";function Flp(e){let{components:n,...t}=e;return(0,s.yg)(Ulp,(0,p.A)({},Olp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Flp.isMDXComponent=!0;const Vlp={toc:[]},qlp="wrapper";function jlp(e){let{components:n,...t}=e;return(0,s.yg)(qlp,(0,p.A)({},Vlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jlp.isMDXComponent=!0;const Hlp={toc:[]},Ylp="wrapper";function Qlp(e){let{components:n,...t}=e;return(0,s.yg)(Ylp,(0,p.A)({},Hlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Qlp.isMDXComponent=!0;const $lp={toc:[]},Klp="wrapper";function Jlp(e){let{components:n,...t}=e;return(0,s.yg)(Klp,(0,p.A)({},$lp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jlp.isMDXComponent=!0;const Zlp={toc:[]},eup="wrapper";function nup(e){let{components:n,...t}=e;return(0,s.yg)(eup,(0,p.A)({},Zlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}nup.isMDXComponent=!0;const tup={toc:[]},oup="wrapper";function pup(e){let{components:n,...t}=e;return(0,s.yg)(oup,(0,p.A)({},tup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pup.isMDXComponent=!0;const rup={toc:[]},sup="wrapper";function cup(e){let{components:n,...t}=e;return(0,s.yg)(sup,(0,p.A)({},rup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}cup.isMDXComponent=!0;const aup={toc:[]},iup="wrapper";function lup(e){let{components:n,...t}=e;return(0,s.yg)(iup,(0,p.A)({},aup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lup.isMDXComponent=!0;const uup={toc:[]},mup="wrapper";function yup(e){let{components:n,...t}=e;return(0,s.yg)(mup,(0,p.A)({},uup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}yup.isMDXComponent=!0;const dup={toc:[]},hup="wrapper";function gup(e){let{components:n,...t}=e;return(0,s.yg)(hup,(0,p.A)({},dup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gup.isMDXComponent=!0;const fup={toc:[]},Dup="wrapper";function Mup(e){let{components:n,...t}=e;return(0,s.yg)(Dup,(0,p.A)({},fup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mup.isMDXComponent=!0;const Xup={toc:[]},_up="wrapper";function wup(e){let{components:n,...t}=e;return(0,s.yg)(_up,(0,p.A)({},Xup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wup.isMDXComponent=!0;const Tup={toc:[]},Cup="wrapper";function xup(e){let{components:n,...t}=e;return(0,s.yg)(Cup,(0,p.A)({},Tup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}xup.isMDXComponent=!0;const Aup={toc:[]},vup="wrapper";function Lup(e){let{components:n,...t}=e;return(0,s.yg)(vup,(0,p.A)({},Aup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lup.isMDXComponent=!0;const bup={toc:[]},Nup="wrapper";function kup(e){let{components:n,...t}=e;return(0,s.yg)(Nup,(0,p.A)({},bup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kup.isMDXComponent=!0;const zup={toc:[]},Pup="wrapper";function Iup(e){let{components:n,...t}=e;return(0,s.yg)(Pup,(0,p.A)({},zup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Iup.isMDXComponent=!0;const Rup={toc:[]},Wup="wrapper";function Sup(e){let{components:n,...t}=e;return(0,s.yg)(Wup,(0,p.A)({},Rup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Sup.isMDXComponent=!0;const Bup={toc:[]},Gup="wrapper";function Eup(e){let{components:n,...t}=e;return(0,s.yg)(Gup,(0,p.A)({},Bup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Eup.isMDXComponent=!0;const Oup={toc:[]},Uup="wrapper";function Fup(e){let{components:n,...t}=e;return(0,s.yg)(Uup,(0,p.A)({},Oup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Fup.isMDXComponent=!0;const Vup={toc:[]},qup="wrapper";function jup(e){let{components:n,...t}=e;return(0,s.yg)(qup,(0,p.A)({},Vup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}jup.isMDXComponent=!0;const Hup={toc:[]},Yup="wrapper";function Qup(e){let{components:n,...t}=e;return(0,s.yg)(Yup,(0,p.A)({},Hup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Qup.isMDXComponent=!0;const $up={toc:[]},Kup="wrapper";function Jup(e){let{components:n,...t}=e;return(0,s.yg)(Kup,(0,p.A)({},$up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Jup.isMDXComponent=!0;const Zup={toc:[]},emp="wrapper";function nmp(e){let{components:n,...t}=e;return(0,s.yg)(emp,(0,p.A)({},Zup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}nmp.isMDXComponent=!0;const tmp={toc:[]},omp="wrapper";function pmp(e){let{components:n,...t}=e;return(0,s.yg)(omp,(0,p.A)({},tmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}pmp.isMDXComponent=!0;const rmp={toc:[]},smp="wrapper";function cmp(e){let{components:n,...t}=e;return(0,s.yg)(smp,(0,p.A)({},rmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cmp.isMDXComponent=!0;const amp={toc:[]},imp="wrapper";function lmp(e){let{components:n,...t}=e;return(0,s.yg)(imp,(0,p.A)({},amp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lmp.isMDXComponent=!0;const ump={toc:[]},mmp="wrapper";function ymp(e){let{components:n,...t}=e;return(0,s.yg)(mmp,(0,p.A)({},ump,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}ymp.isMDXComponent=!0;const dmp={toc:[]},hmp="wrapper";function gmp(e){let{components:n,...t}=e;return(0,s.yg)(hmp,(0,p.A)({},dmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}gmp.isMDXComponent=!0;const fmp={toc:[]},Dmp="wrapper";function Mmp(e){let{components:n,...t}=e;return(0,s.yg)(Dmp,(0,p.A)({},fmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Mmp.isMDXComponent=!0;const Xmp={toc:[]},_mp="wrapper";function wmp(e){let{components:n,...t}=e;return(0,s.yg)(_mp,(0,p.A)({},Xmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}wmp.isMDXComponent=!0;const Tmp={toc:[]},Cmp="wrapper";function xmp(e){let{components:n,...t}=e;return(0,s.yg)(Cmp,(0,p.A)({},Tmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}xmp.isMDXComponent=!0;const Amp={toc:[]},vmp="wrapper";function Lmp(e){let{components:n,...t}=e;return(0,s.yg)(vmp,(0,p.A)({},Amp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Lmp.isMDXComponent=!0;const bmp={toc:[]},Nmp="wrapper";function kmp(e){let{components:n,...t}=e;return(0,s.yg)(Nmp,(0,p.A)({},bmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}kmp.isMDXComponent=!0;const zmp={toc:[]},Pmp="wrapper";function Imp(e){let{components:n,...t}=e;return(0,s.yg)(Pmp,(0,p.A)({},zmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Imp.isMDXComponent=!0;const Rmp={toc:[]},Wmp="wrapper";function Smp(e){let{components:n,...t}=e;return(0,s.yg)(Wmp,(0,p.A)({},Rmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Smp.isMDXComponent=!0;const Bmp={toc:[]},Gmp="wrapper";function Emp(e){let{components:n,...t}=e;return(0,s.yg)(Gmp,(0,p.A)({},Bmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Emp.isMDXComponent=!0;const Omp={toc:[]},Ump="wrapper";function Fmp(e){let{components:n,...t}=e;return(0,s.yg)(Ump,(0,p.A)({},Omp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Fmp.isMDXComponent=!0;const Vmp={toc:[]},qmp="wrapper";function jmp(e){let{components:n,...t}=e;return(0,s.yg)(qmp,(0,p.A)({},Vmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jmp.isMDXComponent=!0;const Hmp={toc:[]},Ymp="wrapper";function Qmp(e){let{components:n,...t}=e;return(0,s.yg)(Ymp,(0,p.A)({},Hmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Qmp.isMDXComponent=!0;const $mp={toc:[]},Kmp="wrapper";function Jmp(e){let{components:n,...t}=e;return(0,s.yg)(Kmp,(0,p.A)({},$mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Jmp.isMDXComponent=!0;const Zmp={toc:[]},eyp="wrapper";function nyp(e){let{components:n,...t}=e;return(0,s.yg)(eyp,(0,p.A)({},Zmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nyp.isMDXComponent=!0;const typ={toc:[]},oyp="wrapper";function pyp(e){let{components:n,...t}=e;return(0,s.yg)(oyp,(0,p.A)({},typ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}pyp.isMDXComponent=!0;const ryp={toc:[]},syp="wrapper";function cyp(e){let{components:n,...t}=e;return(0,s.yg)(syp,(0,p.A)({},ryp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}cyp.isMDXComponent=!0;const ayp={toc:[]},iyp="wrapper";function lyp(e){let{components:n,...t}=e;return(0,s.yg)(iyp,(0,p.A)({},ayp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}lyp.isMDXComponent=!0;const uyp={toc:[]},myp="wrapper";function yyp(e){let{components:n,...t}=e;return(0,s.yg)(myp,(0,p.A)({},uyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}yyp.isMDXComponent=!0;const dyp={toc:[]},hyp="wrapper";function gyp(e){let{components:n,...t}=e;return(0,s.yg)(hyp,(0,p.A)({},dyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gyp.isMDXComponent=!0;const fyp={toc:[]},Dyp="wrapper";function Myp(e){let{components:n,...t}=e;return(0,s.yg)(Dyp,(0,p.A)({},fyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Myp.isMDXComponent=!0;const Xyp={toc:[]},_yp="wrapper";function wyp(e){let{components:n,...t}=e;return(0,s.yg)(_yp,(0,p.A)({},Xyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wyp.isMDXComponent=!0;const Typ={toc:[]},Cyp="wrapper";function xyp(e){let{components:n,...t}=e;return(0,s.yg)(Cyp,(0,p.A)({},Typ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}xyp.isMDXComponent=!0;const Ayp={toc:[]},vyp="wrapper";function Lyp(e){let{components:n,...t}=e;return(0,s.yg)(vyp,(0,p.A)({},Ayp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Lyp.isMDXComponent=!0;const byp={toc:[]},Nyp="wrapper";function kyp(e){let{components:n,...t}=e;return(0,s.yg)(Nyp,(0,p.A)({},byp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}kyp.isMDXComponent=!0;const zyp={toc:[]},Pyp="wrapper";function Iyp(e){let{components:n,...t}=e;return(0,s.yg)(Pyp,(0,p.A)({},zyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Iyp.isMDXComponent=!0;const Ryp={toc:[]},Wyp="wrapper";function Syp(e){let{components:n,...t}=e;return(0,s.yg)(Wyp,(0,p.A)({},Ryp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Syp.isMDXComponent=!0;const Byp={toc:[]},Gyp="wrapper";function Eyp(e){let{components:n,...t}=e;return(0,s.yg)(Gyp,(0,p.A)({},Byp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Eyp.isMDXComponent=!0;const Oyp={toc:[]},Uyp="wrapper";function Fyp(e){let{components:n,...t}=e;return(0,s.yg)(Uyp,(0,p.A)({},Oyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Fyp.isMDXComponent=!0;const Vyp={toc:[]},qyp="wrapper";function jyp(e){let{components:n,...t}=e;return(0,s.yg)(qyp,(0,p.A)({},Vyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}jyp.isMDXComponent=!0;const Hyp={toc:[]},Yyp="wrapper";function Qyp(e){let{components:n,...t}=e;return(0,s.yg)(Yyp,(0,p.A)({},Hyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Qyp.isMDXComponent=!0;const $yp={toc:[]},Kyp="wrapper";function Jyp(e){let{components:n,...t}=e;return(0,s.yg)(Kyp,(0,p.A)({},$yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Jyp.isMDXComponent=!0;const Zyp={toc:[]},edp="wrapper";function ndp(e){let{components:n,...t}=e;return(0,s.yg)(edp,(0,p.A)({},Zyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}ndp.isMDXComponent=!0;const tdp={toc:[]},odp="wrapper";function pdp(e){let{components:n,...t}=e;return(0,s.yg)(odp,(0,p.A)({},tdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}pdp.isMDXComponent=!0;const rdp={toc:[]},sdp="wrapper";function cdp(e){let{components:n,...t}=e;return(0,s.yg)(sdp,(0,p.A)({},rdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}cdp.isMDXComponent=!0;const adp={toc:[]},idp="wrapper";function ldp(e){let{components:n,...t}=e;return(0,s.yg)(idp,(0,p.A)({},adp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ldp.isMDXComponent=!0;const udp={toc:[]},mdp="wrapper";function ydp(e){let{components:n,...t}=e;return(0,s.yg)(mdp,(0,p.A)({},udp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}ydp.isMDXComponent=!0;const ddp={toc:[]},hdp="wrapper";function gdp(e){let{components:n,...t}=e;return(0,s.yg)(hdp,(0,p.A)({},ddp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}gdp.isMDXComponent=!0;const fdp={toc:[]},Ddp="wrapper";function Mdp(e){let{components:n,...t}=e;return(0,s.yg)(Ddp,(0,p.A)({},fdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Mdp.isMDXComponent=!0;const Xdp={toc:[]},_dp="wrapper";function wdp(e){let{components:n,...t}=e;return(0,s.yg)(_dp,(0,p.A)({},Xdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}wdp.isMDXComponent=!0;const Tdp={toc:[]},Cdp="wrapper";function xdp(e){let{components:n,...t}=e;return(0,s.yg)(Cdp,(0,p.A)({},Tdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}xdp.isMDXComponent=!0;const Adp={toc:[]},vdp="wrapper";function Ldp(e){let{components:n,...t}=e;return(0,s.yg)(vdp,(0,p.A)({},Adp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Ldp.isMDXComponent=!0;const bdp={toc:[]},Ndp="wrapper";function kdp(e){let{components:n,...t}=e;return(0,s.yg)(Ndp,(0,p.A)({},bdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}kdp.isMDXComponent=!0;const zdp={toc:[]},Pdp="wrapper";function Idp(e){let{components:n,...t}=e;return(0,s.yg)(Pdp,(0,p.A)({},zdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Idp.isMDXComponent=!0;const Rdp={toc:[]},Wdp="wrapper";function Sdp(e){let{components:n,...t}=e;return(0,s.yg)(Wdp,(0,p.A)({},Rdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Sdp.isMDXComponent=!0;const Bdp={toc:[]},Gdp="wrapper";function Edp(e){let{components:n,...t}=e;return(0,s.yg)(Gdp,(0,p.A)({},Bdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Edp.isMDXComponent=!0;const Odp={toc:[]},Udp="wrapper";function Fdp(e){let{components:n,...t}=e;return(0,s.yg)(Udp,(0,p.A)({},Odp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Fdp.isMDXComponent=!0;const Vdp={toc:[]},qdp="wrapper";function jdp(e){let{components:n,...t}=e;return(0,s.yg)(qdp,(0,p.A)({},Vdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}jdp.isMDXComponent=!0;const Hdp={toc:[]},Ydp="wrapper";function Qdp(e){let{components:n,...t}=e;return(0,s.yg)(Ydp,(0,p.A)({},Hdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Qdp.isMDXComponent=!0;const $dp={toc:[]},Kdp="wrapper";function Jdp(e){let{components:n,...t}=e;return(0,s.yg)(Kdp,(0,p.A)({},$dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Jdp.isMDXComponent=!0;const Zdp={toc:[]},ehp="wrapper";function nhp(e){let{components:n,...t}=e;return(0,s.yg)(ehp,(0,p.A)({},Zdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}nhp.isMDXComponent=!0;const thp={toc:[]},ohp="wrapper";function php(e){let{components:n,...t}=e;return(0,s.yg)(ohp,(0,p.A)({},thp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}php.isMDXComponent=!0;const rhp={toc:[]},shp="wrapper";function chp(e){let{components:n,...t}=e;return(0,s.yg)(shp,(0,p.A)({},rhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}chp.isMDXComponent=!0;const ahp={toc:[]},ihp="wrapper";function lhp(e){let{components:n,...t}=e;return(0,s.yg)(ihp,(0,p.A)({},ahp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}lhp.isMDXComponent=!0;const uhp={toc:[]},mhp="wrapper";function yhp(e){let{components:n,...t}=e;return(0,s.yg)(mhp,(0,p.A)({},uhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}yhp.isMDXComponent=!0;const dhp={toc:[]},hhp="wrapper";function ghp(e){let{components:n,...t}=e;return(0,s.yg)(hhp,(0,p.A)({},dhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ghp.isMDXComponent=!0;const fhp={toc:[]},Dhp="wrapper";function Mhp(e){let{components:n,...t}=e;return(0,s.yg)(Dhp,(0,p.A)({},fhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Mhp.isMDXComponent=!0;const Xhp={toc:[]},_hp="wrapper";function whp(e){let{components:n,...t}=e;return(0,s.yg)(_hp,(0,p.A)({},Xhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}whp.isMDXComponent=!0;const Thp={toc:[]},Chp="wrapper";function xhp(e){let{components:n,...t}=e;return(0,s.yg)(Chp,(0,p.A)({},Thp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xhp.isMDXComponent=!0;const Ahp={toc:[]},vhp="wrapper";function Lhp(e){let{components:n,...t}=e;return(0,s.yg)(vhp,(0,p.A)({},Ahp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Lhp.isMDXComponent=!0;const bhp={toc:[]},Nhp="wrapper";function khp(e){let{components:n,...t}=e;return(0,s.yg)(Nhp,(0,p.A)({},bhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}khp.isMDXComponent=!0;const zhp={toc:[]},Php="wrapper";function Ihp(e){let{components:n,...t}=e;return(0,s.yg)(Php,(0,p.A)({},zhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Ihp.isMDXComponent=!0;const Rhp={toc:[]},Whp="wrapper";function Shp(e){let{components:n,...t}=e;return(0,s.yg)(Whp,(0,p.A)({},Rhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Shp.isMDXComponent=!0;const Bhp={toc:[]},Ghp="wrapper";function Ehp(e){let{components:n,...t}=e;return(0,s.yg)(Ghp,(0,p.A)({},Bhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Ehp.isMDXComponent=!0;const Ohp={toc:[]},Uhp="wrapper";function Fhp(e){let{components:n,...t}=e;return(0,s.yg)(Uhp,(0,p.A)({},Ohp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Fhp.isMDXComponent=!0;const Vhp={toc:[]},qhp="wrapper";function jhp(e){let{components:n,...t}=e;return(0,s.yg)(qhp,(0,p.A)({},Vhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}jhp.isMDXComponent=!0;const Hhp={toc:[]},Yhp="wrapper";function Qhp(e){let{components:n,...t}=e;return(0,s.yg)(Yhp,(0,p.A)({},Hhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Qhp.isMDXComponent=!0;const $hp={toc:[]},Khp="wrapper";function Jhp(e){let{components:n,...t}=e;return(0,s.yg)(Khp,(0,p.A)({},$hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Jhp.isMDXComponent=!0;const Zhp={toc:[]},egp="wrapper";function ngp(e){let{components:n,...t}=e;return(0,s.yg)(egp,(0,p.A)({},Zhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}ngp.isMDXComponent=!0;const tgp={toc:[]},ogp="wrapper";function pgp(e){let{components:n,...t}=e;return(0,s.yg)(ogp,(0,p.A)({},tgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}pgp.isMDXComponent=!0;const rgp={toc:[]},sgp="wrapper";function cgp(e){let{components:n,...t}=e;return(0,s.yg)(sgp,(0,p.A)({},rgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cgp.isMDXComponent=!0;const agp={toc:[]},igp="wrapper";function lgp(e){let{components:n,...t}=e;return(0,s.yg)(igp,(0,p.A)({},agp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lgp.isMDXComponent=!0;const ugp={toc:[]},mgp="wrapper";function ygp(e){let{components:n,...t}=e;return(0,s.yg)(mgp,(0,p.A)({},ugp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}ygp.isMDXComponent=!0;const dgp={toc:[]},hgp="wrapper";function ggp(e){let{components:n,...t}=e;return(0,s.yg)(hgp,(0,p.A)({},dgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ggp.isMDXComponent=!0;const fgp={toc:[]},Dgp="wrapper";function Mgp(e){let{components:n,...t}=e;return(0,s.yg)(Dgp,(0,p.A)({},fgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Mgp.isMDXComponent=!0;const Xgp={toc:[]},_gp="wrapper";function wgp(e){let{components:n,...t}=e;return(0,s.yg)(_gp,(0,p.A)({},Xgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wgp.isMDXComponent=!0;const Tgp={toc:[]},Cgp="wrapper";function xgp(e){let{components:n,...t}=e;return(0,s.yg)(Cgp,(0,p.A)({},Tgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xgp.isMDXComponent=!0;const Agp={toc:[]},vgp="wrapper";function Lgp(e){let{components:n,...t}=e;return(0,s.yg)(vgp,(0,p.A)({},Agp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Lgp.isMDXComponent=!0;const bgp={toc:[]},Ngp="wrapper";function kgp(e){let{components:n,...t}=e;return(0,s.yg)(Ngp,(0,p.A)({},bgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kgp.isMDXComponent=!0;const zgp={toc:[]},Pgp="wrapper";function Igp(e){let{components:n,...t}=e;return(0,s.yg)(Pgp,(0,p.A)({},zgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Igp.isMDXComponent=!0;const Rgp={toc:[]},Wgp="wrapper";function Sgp(e){let{components:n,...t}=e;return(0,s.yg)(Wgp,(0,p.A)({},Rgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Sgp.isMDXComponent=!0;const Bgp={toc:[]},Ggp="wrapper";function Egp(e){let{components:n,...t}=e;return(0,s.yg)(Ggp,(0,p.A)({},Bgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Egp.isMDXComponent=!0;const Ogp={toc:[]},Ugp="wrapper";function Fgp(e){let{components:n,...t}=e;return(0,s.yg)(Ugp,(0,p.A)({},Ogp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Fgp.isMDXComponent=!0;const Vgp={toc:[]},qgp="wrapper";function jgp(e){let{components:n,...t}=e;return(0,s.yg)(qgp,(0,p.A)({},Vgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}jgp.isMDXComponent=!0;const Hgp={toc:[]},Ygp="wrapper";function Qgp(e){let{components:n,...t}=e;return(0,s.yg)(Ygp,(0,p.A)({},Hgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Qgp.isMDXComponent=!0;const $gp={toc:[]},Kgp="wrapper";function Jgp(e){let{components:n,...t}=e;return(0,s.yg)(Kgp,(0,p.A)({},$gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Jgp.isMDXComponent=!0;const Zgp={toc:[]},efp="wrapper";function nfp(e){let{components:n,...t}=e;return(0,s.yg)(efp,(0,p.A)({},Zgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}nfp.isMDXComponent=!0;const tfp={toc:[]},ofp="wrapper";function pfp(e){let{components:n,...t}=e;return(0,s.yg)(ofp,(0,p.A)({},tfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}pfp.isMDXComponent=!0;const rfp={toc:[]},sfp="wrapper";function cfp(e){let{components:n,...t}=e;return(0,s.yg)(sfp,(0,p.A)({},rfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}cfp.isMDXComponent=!0;const afp={toc:[]},ifp="wrapper";function lfp(e){let{components:n,...t}=e;return(0,s.yg)(ifp,(0,p.A)({},afp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}lfp.isMDXComponent=!0;const ufp={toc:[]},mfp="wrapper";function yfp(e){let{components:n,...t}=e;return(0,s.yg)(mfp,(0,p.A)({},ufp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}yfp.isMDXComponent=!0;const dfp={toc:[]},hfp="wrapper";function gfp(e){let{components:n,...t}=e;return(0,s.yg)(hfp,(0,p.A)({},dfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}gfp.isMDXComponent=!0;const ffp={toc:[]},Dfp="wrapper";function Mfp(e){let{components:n,...t}=e;return(0,s.yg)(Dfp,(0,p.A)({},ffp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Mfp.isMDXComponent=!0;const Xfp={toc:[]},_fp="wrapper";function wfp(e){let{components:n,...t}=e;return(0,s.yg)(_fp,(0,p.A)({},Xfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}wfp.isMDXComponent=!0;const Tfp={toc:[]},Cfp="wrapper";function xfp(e){let{components:n,...t}=e;return(0,s.yg)(Cfp,(0,p.A)({},Tfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xfp.isMDXComponent=!0;const Afp={toc:[]},vfp="wrapper";function Lfp(e){let{components:n,...t}=e;return(0,s.yg)(vfp,(0,p.A)({},Afp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Lfp.isMDXComponent=!0;const bfp={toc:[]},Nfp="wrapper";function kfp(e){let{components:n,...t}=e;return(0,s.yg)(Nfp,(0,p.A)({},bfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}kfp.isMDXComponent=!0;const zfp={toc:[]},Pfp="wrapper";function Ifp(e){let{components:n,...t}=e;return(0,s.yg)(Pfp,(0,p.A)({},zfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Ifp.isMDXComponent=!0;const Rfp={toc:[]},Wfp="wrapper";function Sfp(e){let{components:n,...t}=e;return(0,s.yg)(Wfp,(0,p.A)({},Rfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Sfp.isMDXComponent=!0;const Bfp={toc:[]},Gfp="wrapper";function Efp(e){let{components:n,...t}=e;return(0,s.yg)(Gfp,(0,p.A)({},Bfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Efp.isMDXComponent=!0;const Ofp={toc:[]},Ufp="wrapper";function Ffp(e){let{components:n,...t}=e;return(0,s.yg)(Ufp,(0,p.A)({},Ofp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Ffp.isMDXComponent=!0;const Vfp={toc:[]},qfp="wrapper";function jfp(e){let{components:n,...t}=e;return(0,s.yg)(qfp,(0,p.A)({},Vfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}jfp.isMDXComponent=!0;const Hfp={toc:[]},Yfp="wrapper";function Qfp(e){let{components:n,...t}=e;return(0,s.yg)(Yfp,(0,p.A)({},Hfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Qfp.isMDXComponent=!0;const $fp={toc:[]},Kfp="wrapper";function Jfp(e){let{components:n,...t}=e;return(0,s.yg)(Kfp,(0,p.A)({},$fp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Jfp.isMDXComponent=!0;const Zfp={toc:[]},eDp="wrapper";function nDp(e){let{components:n,...t}=e;return(0,s.yg)(eDp,(0,p.A)({},Zfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}nDp.isMDXComponent=!0;const tDp={toc:[]},oDp="wrapper";function pDp(e){let{components:n,...t}=e;return(0,s.yg)(oDp,(0,p.A)({},tDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pDp.isMDXComponent=!0;const rDp={toc:[]},sDp="wrapper";function cDp(e){let{components:n,...t}=e;return(0,s.yg)(sDp,(0,p.A)({},rDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}cDp.isMDXComponent=!0;const aDp={toc:[]},iDp="wrapper";function lDp(e){let{components:n,...t}=e;return(0,s.yg)(iDp,(0,p.A)({},aDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lDp.isMDXComponent=!0;const uDp={toc:[]},mDp="wrapper";function yDp(e){let{components:n,...t}=e;return(0,s.yg)(mDp,(0,p.A)({},uDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}yDp.isMDXComponent=!0;const dDp={toc:[]},hDp="wrapper";function gDp(e){let{components:n,...t}=e;return(0,s.yg)(hDp,(0,p.A)({},dDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}gDp.isMDXComponent=!0;const fDp={toc:[]},DDp="wrapper";function MDp(e){let{components:n,...t}=e;return(0,s.yg)(DDp,(0,p.A)({},fDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}MDp.isMDXComponent=!0;const XDp={toc:[]},_Dp="wrapper";function wDp(e){let{components:n,...t}=e;return(0,s.yg)(_Dp,(0,p.A)({},XDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wDp.isMDXComponent=!0;const TDp={toc:[]},CDp="wrapper";function xDp(e){let{components:n,...t}=e;return(0,s.yg)(CDp,(0,p.A)({},TDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}xDp.isMDXComponent=!0;const ADp={toc:[]},vDp="wrapper";function LDp(e){let{components:n,...t}=e;return(0,s.yg)(vDp,(0,p.A)({},ADp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}LDp.isMDXComponent=!0;const bDp={toc:[]},NDp="wrapper";function kDp(e){let{components:n,...t}=e;return(0,s.yg)(NDp,(0,p.A)({},bDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}kDp.isMDXComponent=!0;const zDp={toc:[]},PDp="wrapper";function IDp(e){let{components:n,...t}=e;return(0,s.yg)(PDp,(0,p.A)({},zDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}IDp.isMDXComponent=!0;const RDp={toc:[]},WDp="wrapper";function SDp(e){let{components:n,...t}=e;return(0,s.yg)(WDp,(0,p.A)({},RDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}SDp.isMDXComponent=!0;const BDp={toc:[]},GDp="wrapper";function EDp(e){let{components:n,...t}=e;return(0,s.yg)(GDp,(0,p.A)({},BDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}EDp.isMDXComponent=!0;const ODp={toc:[]},UDp="wrapper";function FDp(e){let{components:n,...t}=e;return(0,s.yg)(UDp,(0,p.A)({},ODp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}FDp.isMDXComponent=!0;const VDp={toc:[]},qDp="wrapper";function jDp(e){let{components:n,...t}=e;return(0,s.yg)(qDp,(0,p.A)({},VDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}jDp.isMDXComponent=!0;const HDp={toc:[]},YDp="wrapper";function QDp(e){let{components:n,...t}=e;return(0,s.yg)(YDp,(0,p.A)({},HDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}QDp.isMDXComponent=!0;const $Dp={toc:[]},KDp="wrapper";function JDp(e){let{components:n,...t}=e;return(0,s.yg)(KDp,(0,p.A)({},$Dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}JDp.isMDXComponent=!0;const ZDp={toc:[]},eMp="wrapper";function nMp(e){let{components:n,...t}=e;return(0,s.yg)(eMp,(0,p.A)({},ZDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}nMp.isMDXComponent=!0;const tMp={toc:[]},oMp="wrapper";function pMp(e){let{components:n,...t}=e;return(0,s.yg)(oMp,(0,p.A)({},tMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}pMp.isMDXComponent=!0;const rMp={toc:[]},sMp="wrapper";function cMp(e){let{components:n,...t}=e;return(0,s.yg)(sMp,(0,p.A)({},rMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cMp.isMDXComponent=!0;const aMp={toc:[]},iMp="wrapper";function lMp(e){let{components:n,...t}=e;return(0,s.yg)(iMp,(0,p.A)({},aMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}lMp.isMDXComponent=!0;const uMp={toc:[]},mMp="wrapper";function yMp(e){let{components:n,...t}=e;return(0,s.yg)(mMp,(0,p.A)({},uMp,t,{components:n,mdxType:"MDXLayout"}))}yMp.isMDXComponent=!0;const dMp={toc:[]},hMp="wrapper";function gMp(e){let{components:n,...t}=e;return(0,s.yg)(hMp,(0,p.A)({},dMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gMp.isMDXComponent=!0;const fMp={toc:[]},DMp="wrapper";function MMp(e){let{components:n,...t}=e;return(0,s.yg)(DMp,(0,p.A)({},fMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}MMp.isMDXComponent=!0;const XMp={toc:[]},_Mp="wrapper";function wMp(e){let{components:n,...t}=e;return(0,s.yg)(_Mp,(0,p.A)({},XMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}wMp.isMDXComponent=!0;const TMp={toc:[]},CMp="wrapper";function xMp(e){let{components:n,...t}=e;return(0,s.yg)(CMp,(0,p.A)({},TMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}xMp.isMDXComponent=!0;const AMp={toc:[]},vMp="wrapper";function LMp(e){let{components:n,...t}=e;return(0,s.yg)(vMp,(0,p.A)({},AMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}LMp.isMDXComponent=!0;const bMp={toc:[]},NMp="wrapper";function kMp(e){let{components:n,...t}=e;return(0,s.yg)(NMp,(0,p.A)({},bMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}kMp.isMDXComponent=!0;const zMp={toc:[]},PMp="wrapper";function IMp(e){let{components:n,...t}=e;return(0,s.yg)(PMp,(0,p.A)({},zMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}IMp.isMDXComponent=!0;const RMp={toc:[]},WMp="wrapper";function SMp(e){let{components:n,...t}=e;return(0,s.yg)(WMp,(0,p.A)({},RMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}SMp.isMDXComponent=!0;const BMp={toc:[]},GMp="wrapper";function EMp(e){let{components:n,...t}=e;return(0,s.yg)(GMp,(0,p.A)({},BMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}EMp.isMDXComponent=!0;const OMp={toc:[]},UMp="wrapper";function FMp(e){let{components:n,...t}=e;return(0,s.yg)(UMp,(0,p.A)({},OMp,t,{components:n,mdxType:"MDXLayout"}))}FMp.isMDXComponent=!0;const VMp={toc:[]},qMp="wrapper";function jMp(e){let{components:n,...t}=e;return(0,s.yg)(qMp,(0,p.A)({},VMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}jMp.isMDXComponent=!0;const HMp={toc:[]},YMp="wrapper";function QMp(e){let{components:n,...t}=e;return(0,s.yg)(YMp,(0,p.A)({},HMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}QMp.isMDXComponent=!0;const $Mp={toc:[]},KMp="wrapper";function JMp(e){let{components:n,...t}=e;return(0,s.yg)(KMp,(0,p.A)({},$Mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}JMp.isMDXComponent=!0;const ZMp={toc:[]},eXp="wrapper";function nXp(e){let{components:n,...t}=e;return(0,s.yg)(eXp,(0,p.A)({},ZMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}nXp.isMDXComponent=!0;const tXp={toc:[]},oXp="wrapper";function pXp(e){let{components:n,...t}=e;return(0,s.yg)(oXp,(0,p.A)({},tXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}pXp.isMDXComponent=!0;const rXp={toc:[]},sXp="wrapper";function cXp(e){let{components:n,...t}=e;return(0,s.yg)(sXp,(0,p.A)({},rXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}cXp.isMDXComponent=!0;const aXp={toc:[]},iXp="wrapper";function lXp(e){let{components:n,...t}=e;return(0,s.yg)(iXp,(0,p.A)({},aXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}lXp.isMDXComponent=!0;const uXp={toc:[]},mXp="wrapper";function yXp(e){let{components:n,...t}=e;return(0,s.yg)(mXp,(0,p.A)({},uXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}yXp.isMDXComponent=!0;const dXp={toc:[]},hXp="wrapper";function gXp(e){let{components:n,...t}=e;return(0,s.yg)(hXp,(0,p.A)({},dXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}gXp.isMDXComponent=!0;const fXp={toc:[]},DXp="wrapper";function MXp(e){let{components:n,...t}=e;return(0,s.yg)(DXp,(0,p.A)({},fXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}MXp.isMDXComponent=!0;const XXp={toc:[]},_Xp="wrapper";function wXp(e){let{components:n,...t}=e;return(0,s.yg)(_Xp,(0,p.A)({},XXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}wXp.isMDXComponent=!0;const TXp={toc:[]},CXp="wrapper";function xXp(e){let{components:n,...t}=e;return(0,s.yg)(CXp,(0,p.A)({},TXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}xXp.isMDXComponent=!0;const AXp={toc:[]},vXp="wrapper";function LXp(e){let{components:n,...t}=e;return(0,s.yg)(vXp,(0,p.A)({},AXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}LXp.isMDXComponent=!0;const bXp={toc:[]},NXp="wrapper";function kXp(e){let{components:n,...t}=e;return(0,s.yg)(NXp,(0,p.A)({},bXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kXp.isMDXComponent=!0;const zXp={toc:[]},PXp="wrapper";function IXp(e){let{components:n,...t}=e;return(0,s.yg)(PXp,(0,p.A)({},zXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}IXp.isMDXComponent=!0;const RXp={toc:[]},WXp="wrapper";function SXp(e){let{components:n,...t}=e;return(0,s.yg)(WXp,(0,p.A)({},RXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}SXp.isMDXComponent=!0;const BXp={toc:[]},GXp="wrapper";function EXp(e){let{components:n,...t}=e;return(0,s.yg)(GXp,(0,p.A)({},BXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}EXp.isMDXComponent=!0;const OXp={toc:[]},UXp="wrapper";function FXp(e){let{components:n,...t}=e;return(0,s.yg)(UXp,(0,p.A)({},OXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}FXp.isMDXComponent=!0;const VXp={toc:[]},qXp="wrapper";function jXp(e){let{components:n,...t}=e;return(0,s.yg)(qXp,(0,p.A)({},VXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}jXp.isMDXComponent=!0;const HXp={toc:[]},YXp="wrapper";function QXp(e){let{components:n,...t}=e;return(0,s.yg)(YXp,(0,p.A)({},HXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}QXp.isMDXComponent=!0;const $Xp={toc:[]},KXp="wrapper";function JXp(e){let{components:n,...t}=e;return(0,s.yg)(KXp,(0,p.A)({},$Xp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}JXp.isMDXComponent=!0;const ZXp={toc:[]},e_p="wrapper";function n_p(e){let{components:n,...t}=e;return(0,s.yg)(e_p,(0,p.A)({},ZXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}n_p.isMDXComponent=!0;const t_p={toc:[]},o_p="wrapper";function p_p(e){let{components:n,...t}=e;return(0,s.yg)(o_p,(0,p.A)({},t_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}p_p.isMDXComponent=!0;const r_p={toc:[]},s_p="wrapper";function c_p(e){let{components:n,...t}=e;return(0,s.yg)(s_p,(0,p.A)({},r_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}c_p.isMDXComponent=!0;const a_p={toc:[]},i_p="wrapper";function l_p(e){let{components:n,...t}=e;return(0,s.yg)(i_p,(0,p.A)({},a_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}l_p.isMDXComponent=!0;const u_p={toc:[]},m_p="wrapper";function y_p(e){let{components:n,...t}=e;return(0,s.yg)(m_p,(0,p.A)({},u_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}y_p.isMDXComponent=!0;const d_p={toc:[]},h_p="wrapper";function g_p(e){let{components:n,...t}=e;return(0,s.yg)(h_p,(0,p.A)({},d_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}g_p.isMDXComponent=!0;const f_p={toc:[]},D_p="wrapper";function M_p(e){let{components:n,...t}=e;return(0,s.yg)(D_p,(0,p.A)({},f_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}M_p.isMDXComponent=!0;const X_p={toc:[]},__p="wrapper";function w_p(e){let{components:n,...t}=e;return(0,s.yg)(__p,(0,p.A)({},X_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}w_p.isMDXComponent=!0;const T_p={toc:[]},C_p="wrapper";function x_p(e){let{components:n,...t}=e;return(0,s.yg)(C_p,(0,p.A)({},T_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}x_p.isMDXComponent=!0;const A_p={toc:[]},v_p="wrapper";function L_p(e){let{components:n,...t}=e;return(0,s.yg)(v_p,(0,p.A)({},A_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}L_p.isMDXComponent=!0;const b_p={toc:[]},N_p="wrapper";function k_p(e){let{components:n,...t}=e;return(0,s.yg)(N_p,(0,p.A)({},b_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}k_p.isMDXComponent=!0;const z_p={toc:[]},P_p="wrapper";function I_p(e){let{components:n,...t}=e;return(0,s.yg)(P_p,(0,p.A)({},z_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}I_p.isMDXComponent=!0;const R_p={toc:[]},W_p="wrapper";function S_p(e){let{components:n,...t}=e;return(0,s.yg)(W_p,(0,p.A)({},R_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}S_p.isMDXComponent=!0;const B_p={toc:[]},G_p="wrapper";function E_p(e){let{components:n,...t}=e;return(0,s.yg)(G_p,(0,p.A)({},B_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}E_p.isMDXComponent=!0;const O_p={toc:[]},U_p="wrapper";function F_p(e){let{components:n,...t}=e;return(0,s.yg)(U_p,(0,p.A)({},O_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}F_p.isMDXComponent=!0;const V_p={toc:[]},q_p="wrapper";function j_p(e){let{components:n,...t}=e;return(0,s.yg)(q_p,(0,p.A)({},V_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}j_p.isMDXComponent=!0;const H_p={toc:[]},Y_p="wrapper";function Q_p(e){let{components:n,...t}=e;return(0,s.yg)(Y_p,(0,p.A)({},H_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Q_p.isMDXComponent=!0;const $_p={toc:[]},K_p="wrapper";function J_p(e){let{components:n,...t}=e;return(0,s.yg)(K_p,(0,p.A)({},$_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}J_p.isMDXComponent=!0;const Z_p={toc:[]},ewp="wrapper";function nwp(e){let{components:n,...t}=e;return(0,s.yg)(ewp,(0,p.A)({},Z_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}nwp.isMDXComponent=!0;const twp={toc:[]},owp="wrapper";function pwp(e){let{components:n,...t}=e;return(0,s.yg)(owp,(0,p.A)({},twp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}pwp.isMDXComponent=!0;const rwp={toc:[]},swp="wrapper";function cwp(e){let{components:n,...t}=e;return(0,s.yg)(swp,(0,p.A)({},rwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}cwp.isMDXComponent=!0;const awp={toc:[]},iwp="wrapper";function lwp(e){let{components:n,...t}=e;return(0,s.yg)(iwp,(0,p.A)({},awp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}lwp.isMDXComponent=!0;const uwp={toc:[]},mwp="wrapper";function ywp(e){let{components:n,...t}=e;return(0,s.yg)(mwp,(0,p.A)({},uwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}ywp.isMDXComponent=!0;const dwp={toc:[]},hwp="wrapper";function gwp(e){let{components:n,...t}=e;return(0,s.yg)(hwp,(0,p.A)({},dwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}gwp.isMDXComponent=!0;const fwp={toc:[]},Dwp="wrapper";function Mwp(e){let{components:n,...t}=e;return(0,s.yg)(Dwp,(0,p.A)({},fwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Mwp.isMDXComponent=!0;const Xwp={toc:[]},_wp="wrapper";function wwp(e){let{components:n,...t}=e;return(0,s.yg)(_wp,(0,p.A)({},Xwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}wwp.isMDXComponent=!0;const Twp={toc:[]},Cwp="wrapper";function xwp(e){let{components:n,...t}=e;return(0,s.yg)(Cwp,(0,p.A)({},Twp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}xwp.isMDXComponent=!0;const Awp={toc:[]},vwp="wrapper";function Lwp(e){let{components:n,...t}=e;return(0,s.yg)(vwp,(0,p.A)({},Awp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Lwp.isMDXComponent=!0;const bwp={toc:[]},Nwp="wrapper";function kwp(e){let{components:n,...t}=e;return(0,s.yg)(Nwp,(0,p.A)({},bwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}kwp.isMDXComponent=!0;const zwp={toc:[]},Pwp="wrapper";function Iwp(e){let{components:n,...t}=e;return(0,s.yg)(Pwp,(0,p.A)({},zwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Iwp.isMDXComponent=!0;const Rwp={toc:[]},Wwp="wrapper";function Swp(e){let{components:n,...t}=e;return(0,s.yg)(Wwp,(0,p.A)({},Rwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Swp.isMDXComponent=!0;const Bwp={toc:[]},Gwp="wrapper";function Ewp(e){let{components:n,...t}=e;return(0,s.yg)(Gwp,(0,p.A)({},Bwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Ewp.isMDXComponent=!0;const Owp={toc:[]},Uwp="wrapper";function Fwp(e){let{components:n,...t}=e;return(0,s.yg)(Uwp,(0,p.A)({},Owp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fwp.isMDXComponent=!0;const Vwp={toc:[]},qwp="wrapper";function jwp(e){let{components:n,...t}=e;return(0,s.yg)(qwp,(0,p.A)({},Vwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}jwp.isMDXComponent=!0;const Hwp={toc:[]},Ywp="wrapper";function Qwp(e){let{components:n,...t}=e;return(0,s.yg)(Ywp,(0,p.A)({},Hwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qwp.isMDXComponent=!0;const $wp={toc:[]},Kwp="wrapper";function Jwp(e){let{components:n,...t}=e;return(0,s.yg)(Kwp,(0,p.A)({},$wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Jwp.isMDXComponent=!0;const Zwp={toc:[]},eTp="wrapper";function nTp(e){let{components:n,...t}=e;return(0,s.yg)(eTp,(0,p.A)({},Zwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nTp.isMDXComponent=!0;const tTp={toc:[]},oTp="wrapper";function pTp(e){let{components:n,...t}=e;return(0,s.yg)(oTp,(0,p.A)({},tTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}pTp.isMDXComponent=!0;const rTp={toc:[]},sTp="wrapper";function cTp(e){let{components:n,...t}=e;return(0,s.yg)(sTp,(0,p.A)({},rTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cTp.isMDXComponent=!0;const aTp={toc:[]},iTp="wrapper";function lTp(e){let{components:n,...t}=e;return(0,s.yg)(iTp,(0,p.A)({},aTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}lTp.isMDXComponent=!0;const uTp={toc:[]},mTp="wrapper";function yTp(e){let{components:n,...t}=e;return(0,s.yg)(mTp,(0,p.A)({},uTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yTp.isMDXComponent=!0;const dTp={toc:[]},hTp="wrapper";function gTp(e){let{components:n,...t}=e;return(0,s.yg)(hTp,(0,p.A)({},dTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}gTp.isMDXComponent=!0;const fTp={toc:[]},DTp="wrapper";function MTp(e){let{components:n,...t}=e;return(0,s.yg)(DTp,(0,p.A)({},fTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}MTp.isMDXComponent=!0;const XTp={toc:[]},_Tp="wrapper";function wTp(e){let{components:n,...t}=e;return(0,s.yg)(_Tp,(0,p.A)({},XTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find a node by its key."))}wTp.isMDXComponent=!0;const TTp={toc:[]},CTp="wrapper";function xTp(e){let{components:n,...t}=e;return(0,s.yg)(CTp,(0,p.A)({},TTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The key of the node."))}xTp.isMDXComponent=!0;const ATp={toc:[]},vTp="wrapper";function LTp(e){let{components:n,...t}=e;return(0,s.yg)(vTp,(0,p.A)({},ATp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}LTp.isMDXComponent=!0;const bTp={toc:[]},NTp="wrapper";function kTp(e){let{components:n,...t}=e;return(0,s.yg)(NTp,(0,p.A)({},bTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kTp.isMDXComponent=!0;const zTp={toc:[]},PTp="wrapper";function ITp(e){let{components:n,...t}=e;return(0,s.yg)(PTp,(0,p.A)({},zTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}ITp.isMDXComponent=!0;const RTp={toc:[]},WTp="wrapper";function STp(e){let{components:n,...t}=e;return(0,s.yg)(WTp,(0,p.A)({},RTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}STp.isMDXComponent=!0;const BTp={toc:[]},GTp="wrapper";function ETp(e){let{components:n,...t}=e;return(0,s.yg)(GTp,(0,p.A)({},BTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}ETp.isMDXComponent=!0;const OTp={toc:[]},UTp="wrapper";function FTp(e){let{components:n,...t}=e;return(0,s.yg)(UTp,(0,p.A)({},OTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}FTp.isMDXComponent=!0;const VTp={toc:[]},qTp="wrapper";function jTp(e){let{components:n,...t}=e;return(0,s.yg)(qTp,(0,p.A)({},VTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}jTp.isMDXComponent=!0;const HTp={toc:[]},YTp="wrapper";function QTp(e){let{components:n,...t}=e;return(0,s.yg)(YTp,(0,p.A)({},HTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}QTp.isMDXComponent=!0;const $Tp={toc:[]},KTp="wrapper";function JTp(e){let{components:n,...t}=e;return(0,s.yg)(KTp,(0,p.A)({},$Tp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}JTp.isMDXComponent=!0;const ZTp={toc:[]},eCp="wrapper";function nCp(e){let{components:n,...t}=e;return(0,s.yg)(eCp,(0,p.A)({},ZTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}nCp.isMDXComponent=!0;const tCp={toc:[]},oCp="wrapper";function pCp(e){let{components:n,...t}=e;return(0,s.yg)(oCp,(0,p.A)({},tCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}pCp.isMDXComponent=!0;const rCp={toc:[]},sCp="wrapper";function cCp(e){let{components:n,...t}=e;return(0,s.yg)(sCp,(0,p.A)({},rCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}cCp.isMDXComponent=!0;const aCp={toc:[]},iCp="wrapper";function lCp(e){let{components:n,...t}=e;return(0,s.yg)(iCp,(0,p.A)({},aCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lCp.isMDXComponent=!0;const uCp={toc:[]},mCp="wrapper";function yCp(e){let{components:n,...t}=e;return(0,s.yg)(mCp,(0,p.A)({},uCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}yCp.isMDXComponent=!0;const dCp={toc:[]},hCp="wrapper";function gCp(e){let{components:n,...t}=e;return(0,s.yg)(hCp,(0,p.A)({},dCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}gCp.isMDXComponent=!0;const fCp={toc:[]},DCp="wrapper";function MCp(e){let{components:n,...t}=e;return(0,s.yg)(DCp,(0,p.A)({},fCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}MCp.isMDXComponent=!0;const XCp={toc:[]},_Cp="wrapper";function wCp(e){let{components:n,...t}=e;return(0,s.yg)(_Cp,(0,p.A)({},XCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}wCp.isMDXComponent=!0;const TCp={toc:[]},CCp="wrapper";function xCp(e){let{components:n,...t}=e;return(0,s.yg)(CCp,(0,p.A)({},TCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}xCp.isMDXComponent=!0;const ACp={toc:[]},vCp="wrapper";function LCp(e){let{components:n,...t}=e;return(0,s.yg)(vCp,(0,p.A)({},ACp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LCp.isMDXComponent=!0;const bCp={toc:[]},NCp="wrapper";function kCp(e){let{components:n,...t}=e;return(0,s.yg)(NCp,(0,p.A)({},bCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}kCp.isMDXComponent=!0;const zCp={toc:[]},PCp="wrapper";function ICp(e){let{components:n,...t}=e;return(0,s.yg)(PCp,(0,p.A)({},zCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}ICp.isMDXComponent=!0;const RCp={toc:[]},WCp="wrapper";function SCp(e){let{components:n,...t}=e;return(0,s.yg)(WCp,(0,p.A)({},RCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}SCp.isMDXComponent=!0;const BCp={toc:[]},GCp="wrapper";function ECp(e){let{components:n,...t}=e;return(0,s.yg)(GCp,(0,p.A)({},BCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ECp.isMDXComponent=!0;const OCp={toc:[]},UCp="wrapper";function FCp(e){let{components:n,...t}=e;return(0,s.yg)(UCp,(0,p.A)({},OCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}FCp.isMDXComponent=!0;const VCp={toc:[]},qCp="wrapper";function jCp(e){let{components:n,...t}=e;return(0,s.yg)(qCp,(0,p.A)({},VCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}jCp.isMDXComponent=!0;const HCp={toc:[]},YCp="wrapper";function QCp(e){let{components:n,...t}=e;return(0,s.yg)(YCp,(0,p.A)({},HCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}QCp.isMDXComponent=!0;const $Cp={toc:[]},KCp="wrapper";function JCp(e){let{components:n,...t}=e;return(0,s.yg)(KCp,(0,p.A)({},$Cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}JCp.isMDXComponent=!0;const ZCp={toc:[]},exp="wrapper";function nxp(e){let{components:n,...t}=e;return(0,s.yg)(exp,(0,p.A)({},ZCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}nxp.isMDXComponent=!0;const txp={toc:[]},oxp="wrapper";function pxp(e){let{components:n,...t}=e;return(0,s.yg)(oxp,(0,p.A)({},txp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pxp.isMDXComponent=!0;const rxp={toc:[]},sxp="wrapper";function cxp(e){let{components:n,...t}=e;return(0,s.yg)(sxp,(0,p.A)({},rxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}cxp.isMDXComponent=!0;const axp={toc:[]},ixp="wrapper";function lxp(e){let{components:n,...t}=e;return(0,s.yg)(ixp,(0,p.A)({},axp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}lxp.isMDXComponent=!0;const uxp={toc:[]},mxp="wrapper";function yxp(e){let{components:n,...t}=e;return(0,s.yg)(mxp,(0,p.A)({},uxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}yxp.isMDXComponent=!0;const dxp={toc:[]},hxp="wrapper";function gxp(e){let{components:n,...t}=e;return(0,s.yg)(hxp,(0,p.A)({},dxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}gxp.isMDXComponent=!0;const fxp={toc:[]},Dxp="wrapper";function Mxp(e){let{components:n,...t}=e;return(0,s.yg)(Dxp,(0,p.A)({},fxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Mxp.isMDXComponent=!0;const Xxp={toc:[]},_xp="wrapper";function wxp(e){let{components:n,...t}=e;return(0,s.yg)(_xp,(0,p.A)({},Xxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}wxp.isMDXComponent=!0;const Txp={toc:[]},Cxp="wrapper";function xxp(e){let{components:n,...t}=e;return(0,s.yg)(Cxp,(0,p.A)({},Txp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}xxp.isMDXComponent=!0;const Axp={toc:[]},vxp="wrapper";function Lxp(e){let{components:n,...t}=e;return(0,s.yg)(vxp,(0,p.A)({},Axp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Lxp.isMDXComponent=!0;const bxp={toc:[]},Nxp="wrapper";function kxp(e){let{components:n,...t}=e;return(0,s.yg)(Nxp,(0,p.A)({},bxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}kxp.isMDXComponent=!0;const zxp={toc:[]},Pxp="wrapper";function Ixp(e){let{components:n,...t}=e;return(0,s.yg)(Pxp,(0,p.A)({},zxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ixp.isMDXComponent=!0;const Rxp={toc:[]},Wxp="wrapper";function Sxp(e){let{components:n,...t}=e;return(0,s.yg)(Wxp,(0,p.A)({},Rxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Sxp.isMDXComponent=!0;const Bxp={toc:[]},Gxp="wrapper";function Exp(e){let{components:n,...t}=e;return(0,s.yg)(Gxp,(0,p.A)({},Bxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Exp.isMDXComponent=!0;const Oxp={toc:[]},Uxp="wrapper";function Fxp(e){let{components:n,...t}=e;return(0,s.yg)(Uxp,(0,p.A)({},Oxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Fxp.isMDXComponent=!0;const Vxp={toc:[]},qxp="wrapper";function jxp(e){let{components:n,...t}=e;return(0,s.yg)(qxp,(0,p.A)({},Vxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}jxp.isMDXComponent=!0;const Hxp={toc:[]},Yxp="wrapper";function Qxp(e){let{components:n,...t}=e;return(0,s.yg)(Yxp,(0,p.A)({},Hxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Qxp.isMDXComponent=!0;const $xp={toc:[]},Kxp="wrapper";function Jxp(e){let{components:n,...t}=e;return(0,s.yg)(Kxp,(0,p.A)({},$xp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Jxp.isMDXComponent=!0;const Zxp={toc:[]},eAp="wrapper";function nAp(e){let{components:n,...t}=e;return(0,s.yg)(eAp,(0,p.A)({},Zxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}nAp.isMDXComponent=!0;const tAp={toc:[]},oAp="wrapper";function pAp(e){let{components:n,...t}=e;return(0,s.yg)(oAp,(0,p.A)({},tAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}pAp.isMDXComponent=!0;const rAp={toc:[]},sAp="wrapper";function cAp(e){let{components:n,...t}=e;return(0,s.yg)(sAp,(0,p.A)({},rAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}cAp.isMDXComponent=!0;const aAp={toc:[]},iAp="wrapper";function lAp(e){let{components:n,...t}=e;return(0,s.yg)(iAp,(0,p.A)({},aAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}lAp.isMDXComponent=!0;const uAp={toc:[]},mAp="wrapper";function yAp(e){let{components:n,...t}=e;return(0,s.yg)(mAp,(0,p.A)({},uAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}yAp.isMDXComponent=!0;const dAp={toc:[]},hAp="wrapper";function gAp(e){let{components:n,...t}=e;return(0,s.yg)(hAp,(0,p.A)({},dAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}gAp.isMDXComponent=!0;const fAp={toc:[]},DAp="wrapper";function MAp(e){let{components:n,...t}=e;return(0,s.yg)(DAp,(0,p.A)({},fAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}MAp.isMDXComponent=!0;const XAp={toc:[]},_Ap="wrapper";function wAp(e){let{components:n,...t}=e;return(0,s.yg)(_Ap,(0,p.A)({},XAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}wAp.isMDXComponent=!0;const TAp={toc:[]},CAp="wrapper";function xAp(e){let{components:n,...t}=e;return(0,s.yg)(CAp,(0,p.A)({},TAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}xAp.isMDXComponent=!0;const AAp={toc:[]},vAp="wrapper";function LAp(e){let{components:n,...t}=e;return(0,s.yg)(vAp,(0,p.A)({},AAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}LAp.isMDXComponent=!0;const bAp={toc:[]},NAp="wrapper";function kAp(e){let{components:n,...t}=e;return(0,s.yg)(NAp,(0,p.A)({},bAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}kAp.isMDXComponent=!0;const zAp={toc:[]},PAp="wrapper";function IAp(e){let{components:n,...t}=e;return(0,s.yg)(PAp,(0,p.A)({},zAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}IAp.isMDXComponent=!0;const RAp={toc:[]},WAp="wrapper";function SAp(e){let{components:n,...t}=e;return(0,s.yg)(WAp,(0,p.A)({},RAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}SAp.isMDXComponent=!0;const BAp={toc:[]},GAp="wrapper";function EAp(e){let{components:n,...t}=e;return(0,s.yg)(GAp,(0,p.A)({},BAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}EAp.isMDXComponent=!0;const OAp={toc:[]},UAp="wrapper";function FAp(e){let{components:n,...t}=e;return(0,s.yg)(UAp,(0,p.A)({},OAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}FAp.isMDXComponent=!0;const VAp={toc:[]},qAp="wrapper";function jAp(e){let{components:n,...t}=e;return(0,s.yg)(qAp,(0,p.A)({},VAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}jAp.isMDXComponent=!0;const HAp={toc:[]},YAp="wrapper";function QAp(e){let{components:n,...t}=e;return(0,s.yg)(YAp,(0,p.A)({},HAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}QAp.isMDXComponent=!0;const $Ap={toc:[]},KAp="wrapper";function JAp(e){let{components:n,...t}=e;return(0,s.yg)(KAp,(0,p.A)({},$Ap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}JAp.isMDXComponent=!0;const ZAp={toc:[]},evp="wrapper";function nvp(e){let{components:n,...t}=e;return(0,s.yg)(evp,(0,p.A)({},ZAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}nvp.isMDXComponent=!0;const tvp={toc:[]},ovp="wrapper";function pvp(e){let{components:n,...t}=e;return(0,s.yg)(ovp,(0,p.A)({},tvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}pvp.isMDXComponent=!0;const rvp={toc:[]},svp="wrapper";function cvp(e){let{components:n,...t}=e;return(0,s.yg)(svp,(0,p.A)({},rvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}cvp.isMDXComponent=!0;const avp={toc:[]},ivp="wrapper";function lvp(e){let{components:n,...t}=e;return(0,s.yg)(ivp,(0,p.A)({},avp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}lvp.isMDXComponent=!0;const uvp={toc:[]},mvp="wrapper";function yvp(e){let{components:n,...t}=e;return(0,s.yg)(mvp,(0,p.A)({},uvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}yvp.isMDXComponent=!0;const dvp={toc:[]},hvp="wrapper";function gvp(e){let{components:n,...t}=e;return(0,s.yg)(hvp,(0,p.A)({},dvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}gvp.isMDXComponent=!0;const fvp={toc:[]},Dvp="wrapper";function Mvp(e){let{components:n,...t}=e;return(0,s.yg)(Dvp,(0,p.A)({},fvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Mvp.isMDXComponent=!0;const Xvp={toc:[]},_vp="wrapper";function wvp(e){let{components:n,...t}=e;return(0,s.yg)(_vp,(0,p.A)({},Xvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wvp.isMDXComponent=!0;const Tvp={toc:[]},Cvp="wrapper";function xvp(e){let{components:n,...t}=e;return(0,s.yg)(Cvp,(0,p.A)({},Tvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}xvp.isMDXComponent=!0;const Avp={toc:[]},vvp="wrapper";function Lvp(e){let{components:n,...t}=e;return(0,s.yg)(vvp,(0,p.A)({},Avp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Lvp.isMDXComponent=!0;const bvp={toc:[]},Nvp="wrapper";function kvp(e){let{components:n,...t}=e;return(0,s.yg)(Nvp,(0,p.A)({},bvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}kvp.isMDXComponent=!0;const zvp={toc:[]},Pvp="wrapper";function Ivp(e){let{components:n,...t}=e;return(0,s.yg)(Pvp,(0,p.A)({},zvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Ivp.isMDXComponent=!0;const Rvp={toc:[]},Wvp="wrapper";function Svp(e){let{components:n,...t}=e;return(0,s.yg)(Wvp,(0,p.A)({},Rvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Svp.isMDXComponent=!0;const Bvp={toc:[]},Gvp="wrapper";function Evp(e){let{components:n,...t}=e;return(0,s.yg)(Gvp,(0,p.A)({},Bvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Evp.isMDXComponent=!0;const Ovp={toc:[]},Uvp="wrapper";function Fvp(e){let{components:n,...t}=e;return(0,s.yg)(Uvp,(0,p.A)({},Ovp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Fvp.isMDXComponent=!0;const Vvp={toc:[]},qvp="wrapper";function jvp(e){let{components:n,...t}=e;return(0,s.yg)(qvp,(0,p.A)({},Vvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}jvp.isMDXComponent=!0;const Hvp={toc:[]},Yvp="wrapper";function Qvp(e){let{components:n,...t}=e;return(0,s.yg)(Yvp,(0,p.A)({},Hvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Qvp.isMDXComponent=!0;const $vp={toc:[]},Kvp="wrapper";function Jvp(e){let{components:n,...t}=e;return(0,s.yg)(Kvp,(0,p.A)({},$vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Jvp.isMDXComponent=!0;const Zvp={toc:[]},eLp="wrapper";function nLp(e){let{components:n,...t}=e;return(0,s.yg)(eLp,(0,p.A)({},Zvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}nLp.isMDXComponent=!0;const tLp={toc:[]},oLp="wrapper";function pLp(e){let{components:n,...t}=e;return(0,s.yg)(oLp,(0,p.A)({},tLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}pLp.isMDXComponent=!0;const rLp={toc:[]},sLp="wrapper";function cLp(e){let{components:n,...t}=e;return(0,s.yg)(sLp,(0,p.A)({},rLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cLp.isMDXComponent=!0;const aLp={toc:[]},iLp="wrapper";function lLp(e){let{components:n,...t}=e;return(0,s.yg)(iLp,(0,p.A)({},aLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lLp.isMDXComponent=!0;const uLp={toc:[]},mLp="wrapper";function yLp(e){let{components:n,...t}=e;return(0,s.yg)(mLp,(0,p.A)({},uLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}yLp.isMDXComponent=!0;const dLp={toc:[]},hLp="wrapper";function gLp(e){let{components:n,...t}=e;return(0,s.yg)(hLp,(0,p.A)({},dLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}gLp.isMDXComponent=!0;const fLp={toc:[]},DLp="wrapper";function MLp(e){let{components:n,...t}=e;return(0,s.yg)(DLp,(0,p.A)({},fLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}MLp.isMDXComponent=!0;const XLp={toc:[]},_Lp="wrapper";function wLp(e){let{components:n,...t}=e;return(0,s.yg)(_Lp,(0,p.A)({},XLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wLp.isMDXComponent=!0;const TLp={toc:[]},CLp="wrapper";function xLp(e){let{components:n,...t}=e;return(0,s.yg)(CLp,(0,p.A)({},TLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}xLp.isMDXComponent=!0;const ALp={toc:[]},vLp="wrapper";function LLp(e){let{components:n,...t}=e;return(0,s.yg)(vLp,(0,p.A)({},ALp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}LLp.isMDXComponent=!0;const bLp={toc:[]},NLp="wrapper";function kLp(e){let{components:n,...t}=e;return(0,s.yg)(NLp,(0,p.A)({},bLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}kLp.isMDXComponent=!0;const zLp={toc:[]},PLp="wrapper";function ILp(e){let{components:n,...t}=e;return(0,s.yg)(PLp,(0,p.A)({},zLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}ILp.isMDXComponent=!0;const RLp={toc:[]},WLp="wrapper";function SLp(e){let{components:n,...t}=e;return(0,s.yg)(WLp,(0,p.A)({},RLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}SLp.isMDXComponent=!0;const BLp={toc:[]},GLp="wrapper";function ELp(e){let{components:n,...t}=e;return(0,s.yg)(GLp,(0,p.A)({},BLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ELp.isMDXComponent=!0;const OLp={toc:[]},ULp="wrapper";function FLp(e){let{components:n,...t}=e;return(0,s.yg)(ULp,(0,p.A)({},OLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}FLp.isMDXComponent=!0;const VLp={toc:[]},qLp="wrapper";function jLp(e){let{components:n,...t}=e;return(0,s.yg)(qLp,(0,p.A)({},VLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}jLp.isMDXComponent=!0;const HLp={toc:[]},YLp="wrapper";function QLp(e){let{components:n,...t}=e;return(0,s.yg)(YLp,(0,p.A)({},HLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}QLp.isMDXComponent=!0;const $Lp={toc:[]},KLp="wrapper";function JLp(e){let{components:n,...t}=e;return(0,s.yg)(KLp,(0,p.A)({},$Lp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}JLp.isMDXComponent=!0;const ZLp={toc:[]},ebp="wrapper";function nbp(e){let{components:n,...t}=e;return(0,s.yg)(ebp,(0,p.A)({},ZLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nbp.isMDXComponent=!0;const tbp={toc:[]},obp="wrapper";function pbp(e){let{components:n,...t}=e;return(0,s.yg)(obp,(0,p.A)({},tbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pbp.isMDXComponent=!0;const rbp={toc:[]},sbp="wrapper";function cbp(e){let{components:n,...t}=e;return(0,s.yg)(sbp,(0,p.A)({},rbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}cbp.isMDXComponent=!0;const abp={toc:[]},ibp="wrapper";function lbp(e){let{components:n,...t}=e;return(0,s.yg)(ibp,(0,p.A)({},abp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lbp.isMDXComponent=!0;const ubp={toc:[]},mbp="wrapper";function ybp(e){let{components:n,...t}=e;return(0,s.yg)(mbp,(0,p.A)({},ubp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}ybp.isMDXComponent=!0;const dbp={toc:[]},hbp="wrapper";function gbp(e){let{components:n,...t}=e;return(0,s.yg)(hbp,(0,p.A)({},dbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}gbp.isMDXComponent=!0;const fbp={toc:[]},Dbp="wrapper";function Mbp(e){let{components:n,...t}=e;return(0,s.yg)(Dbp,(0,p.A)({},fbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Mbp.isMDXComponent=!0;const Xbp={toc:[]},_bp="wrapper";function wbp(e){let{components:n,...t}=e;return(0,s.yg)(_bp,(0,p.A)({},Xbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wbp.isMDXComponent=!0;const Tbp={toc:[]},Cbp="wrapper";function xbp(e){let{components:n,...t}=e;return(0,s.yg)(Cbp,(0,p.A)({},Tbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}xbp.isMDXComponent=!0;const Abp={toc:[]},vbp="wrapper";function Lbp(e){let{components:n,...t}=e;return(0,s.yg)(vbp,(0,p.A)({},Abp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Lbp.isMDXComponent=!0;const bbp={toc:[]},Nbp="wrapper";function kbp(e){let{components:n,...t}=e;return(0,s.yg)(Nbp,(0,p.A)({},bbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}kbp.isMDXComponent=!0;const zbp={toc:[]},Pbp="wrapper";function Ibp(e){let{components:n,...t}=e;return(0,s.yg)(Pbp,(0,p.A)({},zbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ibp.isMDXComponent=!0;const Rbp={toc:[]},Wbp="wrapper";function Sbp(e){let{components:n,...t}=e;return(0,s.yg)(Wbp,(0,p.A)({},Rbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Sbp.isMDXComponent=!0;const Bbp={toc:[]},Gbp="wrapper";function Ebp(e){let{components:n,...t}=e;return(0,s.yg)(Gbp,(0,p.A)({},Bbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ebp.isMDXComponent=!0;const Obp={toc:[]},Ubp="wrapper";function Fbp(e){let{components:n,...t}=e;return(0,s.yg)(Ubp,(0,p.A)({},Obp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Fbp.isMDXComponent=!0;const Vbp={toc:[]},qbp="wrapper";function jbp(e){let{components:n,...t}=e;return(0,s.yg)(qbp,(0,p.A)({},Vbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jbp.isMDXComponent=!0;const Hbp={toc:[]},Ybp="wrapper";function Qbp(e){let{components:n,...t}=e;return(0,s.yg)(Ybp,(0,p.A)({},Hbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Qbp.isMDXComponent=!0;const $bp={toc:[]},Kbp="wrapper";function Jbp(e){let{components:n,...t}=e;return(0,s.yg)(Kbp,(0,p.A)({},$bp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Jbp.isMDXComponent=!0;const Zbp={toc:[]},eNp="wrapper";function nNp(e){let{components:n,...t}=e;return(0,s.yg)(eNp,(0,p.A)({},Zbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nNp.isMDXComponent=!0;const tNp={toc:[]},oNp="wrapper";function pNp(e){let{components:n,...t}=e;return(0,s.yg)(oNp,(0,p.A)({},tNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pNp.isMDXComponent=!0;const rNp={toc:[]},sNp="wrapper";function cNp(e){let{components:n,...t}=e;return(0,s.yg)(sNp,(0,p.A)({},rNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cNp.isMDXComponent=!0;const aNp={toc:[]},iNp="wrapper";function lNp(e){let{components:n,...t}=e;return(0,s.yg)(iNp,(0,p.A)({},aNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lNp.isMDXComponent=!0;const uNp={toc:[]},mNp="wrapper";function yNp(e){let{components:n,...t}=e;return(0,s.yg)(mNp,(0,p.A)({},uNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yNp.isMDXComponent=!0;const dNp={toc:[]},hNp="wrapper";function gNp(e){let{components:n,...t}=e;return(0,s.yg)(hNp,(0,p.A)({},dNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}gNp.isMDXComponent=!0;const fNp={toc:[]},DNp="wrapper";function MNp(e){let{components:n,...t}=e;return(0,s.yg)(DNp,(0,p.A)({},fNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the path of this circle should be closed."))}MNp.isMDXComponent=!0;const XNp={toc:[]},_Np="wrapper";function wNp(e){let{components:n,...t}=e;return(0,s.yg)(_Np,(0,p.A)({},XNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the circle begins at ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}wNp.isMDXComponent=!0;const TNp={toc:[]},CNp="wrapper";function xNp(e){let{components:n,...t}=e;return(0,s.yg)(CNp,(0,p.A)({},TNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the circle sector should be drawn counterclockwise."))}xNp.isMDXComponent=!0;const ANp={toc:[]},vNp="wrapper";function LNp(e){let{components:n,...t}=e;return(0,s.yg)(vNp,(0,p.A)({},ANp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}LNp.isMDXComponent=!0;const bNp={toc:[]},NNp="wrapper";function kNp(e){let{components:n,...t}=e;return(0,s.yg)(NNp,(0,p.A)({},bNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}kNp.isMDXComponent=!0;const zNp={toc:[]},PNp="wrapper";function INp(e){let{components:n,...t}=e;return(0,s.yg)(PNp,(0,p.A)({},zNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}INp.isMDXComponent=!0;const RNp={toc:[]},WNp="wrapper";function SNp(e){let{components:n,...t}=e;return(0,s.yg)(WNp,(0,p.A)({},RNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending angle in degrees for the circle sector."))}SNp.isMDXComponent=!0;const BNp={toc:[]},GNp="wrapper";function ENp(e){let{components:n,...t}=e;return(0,s.yg)(GNp,(0,p.A)({},BNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ENp.isMDXComponent=!0;const ONp={toc:[]},UNp="wrapper";function FNp(e){let{components:n,...t}=e;return(0,s.yg)(UNp,(0,p.A)({},ONp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}FNp.isMDXComponent=!0;const VNp={toc:[]},qNp="wrapper";function jNp(e){let{components:n,...t}=e;return(0,s.yg)(qNp,(0,p.A)({},VNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}jNp.isMDXComponent=!0;const HNp={toc:[]},YNp="wrapper";function QNp(e){let{components:n,...t}=e;return(0,s.yg)(YNp,(0,p.A)({},HNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}QNp.isMDXComponent=!0;const $Np={toc:[]},KNp="wrapper";function JNp(e){let{components:n,...t}=e;return(0,s.yg)(KNp,(0,p.A)({},$Np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JNp.isMDXComponent=!0;const ZNp={toc:[]},ekp="wrapper";function nkp(e){let{components:n,...t}=e;return(0,s.yg)(ekp,(0,p.A)({},ZNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}nkp.isMDXComponent=!0;const tkp={toc:[]},okp="wrapper";function pkp(e){let{components:n,...t}=e;return(0,s.yg)(okp,(0,p.A)({},tkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}pkp.isMDXComponent=!0;const rkp={toc:[]},skp="wrapper";function ckp(e){let{components:n,...t}=e;return(0,s.yg)(skp,(0,p.A)({},rkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}ckp.isMDXComponent=!0;const akp={toc:[]},ikp="wrapper";function lkp(e){let{components:n,...t}=e;return(0,s.yg)(ikp,(0,p.A)({},akp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lkp.isMDXComponent=!0;const ukp={toc:[]},mkp="wrapper";function ykp(e){let{components:n,...t}=e;return(0,s.yg)(mkp,(0,p.A)({},ukp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}ykp.isMDXComponent=!0;const dkp={toc:[]},hkp="wrapper";function gkp(e){let{components:n,...t}=e;return(0,s.yg)(hkp,(0,p.A)({},dkp,t,{components:n,mdxType:"MDXLayout"}))}gkp.isMDXComponent=!0;const fkp={toc:[]},Dkp="wrapper";function Mkp(e){let{components:n,...t}=e;return(0,s.yg)(Dkp,(0,p.A)({},fkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Mkp.isMDXComponent=!0;const Xkp={toc:[]},_kp="wrapper";function wkp(e){let{components:n,...t}=e;return(0,s.yg)(_kp,(0,p.A)({},Xkp,t,{components:n,mdxType:"MDXLayout"}))}wkp.isMDXComponent=!0;const Tkp={toc:[]},Ckp="wrapper";function xkp(e){let{components:n,...t}=e;return(0,s.yg)(Ckp,(0,p.A)({},Tkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}xkp.isMDXComponent=!0;const Akp={toc:[]},vkp="wrapper";function Lkp(e){let{components:n,...t}=e;return(0,s.yg)(vkp,(0,p.A)({},Akp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Lkp.isMDXComponent=!0;const bkp={toc:[]},Nkp="wrapper";function kkp(e){let{components:n,...t}=e;return(0,s.yg)(Nkp,(0,p.A)({},bkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}kkp.isMDXComponent=!0;const zkp={toc:[]},Pkp="wrapper";function Ikp(e){let{components:n,...t}=e;return(0,s.yg)(Pkp,(0,p.A)({},zkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting angle in degrees for the circle sector."))}Ikp.isMDXComponent=!0;const Rkp={toc:[]},Wkp="wrapper";function Skp(e){let{components:n,...t}=e;return(0,s.yg)(Wkp,(0,p.A)({},Rkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Skp.isMDXComponent=!0;const Bkp={toc:[]},Gkp="wrapper";function Ekp(e){let{components:n,...t}=e;return(0,s.yg)(Gkp,(0,p.A)({},Bkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Ekp.isMDXComponent=!0;const Okp={toc:[]},Ukp="wrapper";function Fkp(e){let{components:n,...t}=e;return(0,s.yg)(Ukp,(0,p.A)({},Okp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Fkp.isMDXComponent=!0;const Vkp={toc:[]},qkp="wrapper";function jkp(e){let{components:n,...t}=e;return(0,s.yg)(qkp,(0,p.A)({},Vkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}jkp.isMDXComponent=!0;const Hkp={toc:[]},Ykp="wrapper";function Qkp(e){let{components:n,...t}=e;return(0,s.yg)(Ykp,(0,p.A)({},Hkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Qkp.isMDXComponent=!0;const $kp={toc:[]},Kkp="wrapper";function Jkp(e){let{components:n,...t}=e;return(0,s.yg)(Kkp,(0,p.A)({},$kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Jkp.isMDXComponent=!0;const Zkp={toc:[]},ezp="wrapper";function nzp(e){let{components:n,...t}=e;return(0,s.yg)(ezp,(0,p.A)({},Zkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nzp.isMDXComponent=!0;const tzp={toc:[]},ozp="wrapper";function pzp(e){let{components:n,...t}=e;return(0,s.yg)(ozp,(0,p.A)({},tzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}pzp.isMDXComponent=!0;const rzp={toc:[]},szp="wrapper";function czp(e){let{components:n,...t}=e;return(0,s.yg)(szp,(0,p.A)({},rzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}czp.isMDXComponent=!0;const azp={toc:[]},izp="wrapper";function lzp(e){let{components:n,...t}=e;return(0,s.yg)(izp,(0,p.A)({},azp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}lzp.isMDXComponent=!0;const uzp={toc:[]},mzp="wrapper";function yzp(e){let{components:n,...t}=e;return(0,s.yg)(mzp,(0,p.A)({},uzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yzp.isMDXComponent=!0;const dzp={toc:[]},hzp="wrapper";function gzp(e){let{components:n,...t}=e;return(0,s.yg)(hzp,(0,p.A)({},dzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}gzp.isMDXComponent=!0;const fzp={toc:[]},Dzp="wrapper";function Mzp(e){let{components:n,...t}=e;return(0,s.yg)(Dzp,(0,p.A)({},fzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Mzp.isMDXComponent=!0;const Xzp={toc:[]},_zp="wrapper";function wzp(e){let{components:n,...t}=e;return(0,s.yg)(_zp,(0,p.A)({},Xzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}wzp.isMDXComponent=!0;const Tzp={toc:[]},Czp="wrapper";function xzp(e){let{components:n,...t}=e;return(0,s.yg)(Czp,(0,p.A)({},Tzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xzp.isMDXComponent=!0;const Azp={toc:[]},vzp="wrapper";function Lzp(e){let{components:n,...t}=e;return(0,s.yg)(vzp,(0,p.A)({},Azp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Lzp.isMDXComponent=!0;const bzp={toc:[]},Nzp="wrapper";function kzp(e){let{components:n,...t}=e;return(0,s.yg)(Nzp,(0,p.A)({},bzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kzp.isMDXComponent=!0;const zzp={toc:[]},Pzp="wrapper";function Izp(e){let{components:n,...t}=e;return(0,s.yg)(Pzp,(0,p.A)({},zzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Izp.isMDXComponent=!0;const Rzp={toc:[]},Wzp="wrapper";function Szp(e){let{components:n,...t}=e;return(0,s.yg)(Wzp,(0,p.A)({},Rzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Szp.isMDXComponent=!0;const Bzp={toc:[]},Gzp="wrapper";function Ezp(e){let{components:n,...t}=e;return(0,s.yg)(Gzp,(0,p.A)({},Bzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ezp.isMDXComponent=!0;const Ozp={toc:[]},Uzp="wrapper";function Fzp(e){let{components:n,...t}=e;return(0,s.yg)(Uzp,(0,p.A)({},Ozp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Fzp.isMDXComponent=!0;const Vzp={toc:[]},qzp="wrapper";function jzp(e){let{components:n,...t}=e;return(0,s.yg)(qzp,(0,p.A)({},Vzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jzp.isMDXComponent=!0;const Hzp={toc:[]},Yzp="wrapper";function Qzp(e){let{components:n,...t}=e;return(0,s.yg)(Yzp,(0,p.A)({},Hzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Qzp.isMDXComponent=!0;const $zp={toc:[]},Kzp="wrapper";function Jzp(e){let{components:n,...t}=e;return(0,s.yg)(Kzp,(0,p.A)({},$zp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Jzp.isMDXComponent=!0;const Zzp={toc:[]},ePp="wrapper";function nPp(e){let{components:n,...t}=e;return(0,s.yg)(ePp,(0,p.A)({},Zzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}nPp.isMDXComponent=!0;const tPp={toc:[]},oPp="wrapper";function pPp(e){let{components:n,...t}=e;return(0,s.yg)(oPp,(0,p.A)({},tPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}pPp.isMDXComponent=!0;const rPp={toc:[]},sPp="wrapper";function cPp(e){let{components:n,...t}=e;return(0,s.yg)(sPp,(0,p.A)({},rPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to display."))}cPp.isMDXComponent=!0;const aPp={toc:[]},iPp="wrapper";function lPp(e){let{components:n,...t}=e;return(0,s.yg)(iPp,(0,p.A)({},aPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This value will be passed to the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeHighlighter")),"\ndefined by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#highlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"highlighter"))," property. Different highlighters may use\nit differently."),(0,s.yg)("p",null,"The default ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter"))," uses it to select\nthe language parser to use. The parser for the given dialect can be\nregistered as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// Import the lezer parser:\nimport {parser} from '@lezer/javascript';\n\n// Register it in the highlighter:\nLezerHighlighter.registerParser(parser, 'js');\n\n// Use the dialect in a code node:\n<Code dialect=\"js\" code=\"const a = 7;\" />\n")),(0,s.yg)("p",null,"When no dialect is provided, the highlighter will use the default\nparser:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'// Register the default parser by omitting the dialect:\nLezerHighlighter.registerParser(parser);\n\n// Code nodes with no dialect will now use the default parser:\n<Code code="const a = 7;" />\n')))}lPp.isMDXComponent=!0;const uPp={toc:[]},mPp="wrapper";function yPp(e){let{components:n,...t}=e;return(0,s.yg)(mPp,(0,p.A)({},uPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The dialect to use for highlighting the code."))}yPp.isMDXComponent=!0;const dPp={toc:[]},hPp="wrapper";function gPp(e){let{components:n,...t}=e;return(0,s.yg)(hPp,(0,p.A)({},dPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check out ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.yg)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}gPp.isMDXComponent=!0;const fPp={toc:[]},DPp="wrapper";function MPp(e){let{components:n,...t}=e;return(0,s.yg)(DPp,(0,p.A)({},fPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for the code."))}MPp.isMDXComponent=!0;const XPp={toc:[]},_Pp="wrapper";function wPp(e){let{components:n,...t}=e;return(0,s.yg)(_Pp,(0,p.A)({},XPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defaults to a shared ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}wPp.isMDXComponent=!0;const TPp={toc:[]},CPp="wrapper";function xPp(e){let{components:n,...t}=e;return(0,s.yg)(CPp,(0,p.A)({},TPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code highlighter to use for this code node."))}xPp.isMDXComponent=!0;const APp={toc:[]},vPp="wrapper";function LPp(e){let{components:n,...t}=e;return(0,s.yg)(vPp,(0,p.A)({},APp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LPp.isMDXComponent=!0;const bPp={toc:[]},NPp="wrapper";function kPp(e){let{components:n,...t}=e;return(0,s.yg)(NPp,(0,p.A)({},bPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}kPp.isMDXComponent=!0;const zPp={toc:[]},PPp="wrapper";function IPp(e){let{components:n,...t}=e;return(0,s.yg)(PPp,(0,p.A)({},zPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}IPp.isMDXComponent=!0;const RPp={toc:[]},WPp="wrapper";function SPp(e){let{components:n,...t}=e;return(0,s.yg)(WPp,(0,p.A)({},RPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}SPp.isMDXComponent=!0;const BPp={toc:[]},GPp="wrapper";function EPp(e){let{components:n,...t}=e;return(0,s.yg)(GPp,(0,p.A)({},BPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EPp.isMDXComponent=!0;const OPp={toc:[]},UPp="wrapper";function FPp(e){let{components:n,...t}=e;return(0,s.yg)(UPp,(0,p.A)({},OPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}FPp.isMDXComponent=!0;const VPp={toc:[]},qPp="wrapper";function jPp(e){let{components:n,...t}=e;return(0,s.yg)(qPp,(0,p.A)({},VPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a single ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.yg)("p",null,"You can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.yg)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.yg)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}jPp.isMDXComponent=!0;const HPp={toc:[]},YPp="wrapper";function QPp(e){let{components:n,...t}=e;return(0,s.yg)(YPp,(0,p.A)({},HPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The currently selected code range."))}QPp.isMDXComponent=!0;const $Pp={toc:[]},KPp="wrapper";function JPp(e){let{components:n,...t}=e;return(0,s.yg)(KPp,(0,p.A)({},$Pp,t,{components:n,mdxType:"MDXLayout"}))}JPp.isMDXComponent=!0;const ZPp={toc:[]},eIp="wrapper";function nIp(e){let{components:n,...t}=e;return(0,s.yg)(eIp,(0,p.A)({},ZPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}nIp.isMDXComponent=!0;const tIp={toc:[]},oIp="wrapper";function pIp(e){let{components:n,...t}=e;return(0,s.yg)(oIp,(0,p.A)({},tIp,t,{components:n,mdxType:"MDXLayout"}))}pIp.isMDXComponent=!0;const rIp={toc:[]},sIp="wrapper";function cIp(e){let{components:n,...t}=e;return(0,s.yg)(sIp,(0,p.A)({},rIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cIp.isMDXComponent=!0;const aIp={toc:[]},iIp="wrapper";function lIp(e){let{components:n,...t}=e;return(0,s.yg)(iIp,(0,p.A)({},aIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}lIp.isMDXComponent=!0;const uIp={toc:[]},mIp="wrapper";function yIp(e){let{components:n,...t}=e;return(0,s.yg)(mIp,(0,p.A)({},uIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yIp.isMDXComponent=!0;const dIp={toc:[]},hIp="wrapper";function gIp(e){let{components:n,...t}=e;return(0,s.yg)(hIp,(0,p.A)({},dIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}gIp.isMDXComponent=!0;const fIp={toc:[]},DIp="wrapper";function MIp(e){let{components:n,...t}=e;return(0,s.yg)(DIp,(0,p.A)({},fIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MIp.isMDXComponent=!0;const XIp={toc:[]},_Ip="wrapper";function wIp(e){let{components:n,...t}=e;return(0,s.yg)(_Ip,(0,p.A)({},XIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}wIp.isMDXComponent=!0;const TIp={toc:[]},CIp="wrapper";function xIp(e){let{components:n,...t}=e;return(0,s.yg)(CIp,(0,p.A)({},TIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}xIp.isMDXComponent=!0;const AIp={toc:[]},vIp="wrapper";function LIp(e){let{components:n,...t}=e;return(0,s.yg)(vIp,(0,p.A)({},AIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}LIp.isMDXComponent=!0;const bIp={toc:[]},NIp="wrapper";function kIp(e){let{components:n,...t}=e;return(0,s.yg)(NIp,(0,p.A)({},bIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kIp.isMDXComponent=!0;const zIp={toc:[]},PIp="wrapper";function IIp(e){let{components:n,...t}=e;return(0,s.yg)(PIp,(0,p.A)({},zIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}IIp.isMDXComponent=!0;const RIp={toc:[]},WIp="wrapper";function SIp(e){let{components:n,...t}=e;return(0,s.yg)(WIp,(0,p.A)({},RIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SIp.isMDXComponent=!0;const BIp={toc:[]},GIp="wrapper";function EIp(e){let{components:n,...t}=e;return(0,s.yg)(GIp,(0,p.A)({},BIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}EIp.isMDXComponent=!0;const OIp={toc:[]},UIp="wrapper";function FIp(e){let{components:n,...t}=e;return(0,s.yg)(UIp,(0,p.A)({},OIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FIp.isMDXComponent=!0;const VIp={toc:[]},qIp="wrapper";function jIp(e){let{components:n,...t}=e;return(0,s.yg)(qIp,(0,p.A)({},VIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}jIp.isMDXComponent=!0;const HIp={toc:[]},YIp="wrapper";function QIp(e){let{components:n,...t}=e;return(0,s.yg)(YIp,(0,p.A)({},HIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}QIp.isMDXComponent=!0;const $Ip={toc:[]},KIp="wrapper";function JIp(e){let{components:n,...t}=e;return(0,s.yg)(KIp,(0,p.A)({},$Ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}JIp.isMDXComponent=!0;const ZIp={toc:[]},eRp="wrapper";function nRp(e){let{components:n,...t}=e;return(0,s.yg)(eRp,(0,p.A)({},ZIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}nRp.isMDXComponent=!0;const tRp={toc:[]},oRp="wrapper";function pRp(e){let{components:n,...t}=e;return(0,s.yg)(oRp,(0,p.A)({},tRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}pRp.isMDXComponent=!0;const rRp={toc:[]},sRp="wrapper";function cRp(e){let{components:n,...t}=e;return(0,s.yg)(sRp,(0,p.A)({},rRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cRp.isMDXComponent=!0;const aRp={toc:[]},iRp="wrapper";function lRp(e){let{components:n,...t}=e;return(0,s.yg)(iRp,(0,p.A)({},aRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lRp.isMDXComponent=!0;const uRp={toc:[]},mRp="wrapper";function yRp(e){let{components:n,...t}=e;return(0,s.yg)(mRp,(0,p.A)({},uRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yRp.isMDXComponent=!0;const dRp={toc:[]},hRp="wrapper";function gRp(e){let{components:n,...t}=e;return(0,s.yg)(hRp,(0,p.A)({},dRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gRp.isMDXComponent=!0;const fRp={toc:[]},DRp="wrapper";function MRp(e){let{components:n,...t}=e;return(0,s.yg)(DRp,(0,p.A)({},fRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}MRp.isMDXComponent=!0;const XRp={toc:[]},_Rp="wrapper";function wRp(e){let{components:n,...t}=e;return(0,s.yg)(_Rp,(0,p.A)({},XRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wRp.isMDXComponent=!0;const TRp={toc:[]},CRp="wrapper";function xRp(e){let{components:n,...t}=e;return(0,s.yg)(CRp,(0,p.A)({},TRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}xRp.isMDXComponent=!0;const ARp={toc:[]},vRp="wrapper";function LRp(e){let{components:n,...t}=e;return(0,s.yg)(vRp,(0,p.A)({},ARp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}LRp.isMDXComponent=!0;const bRp={toc:[]},NRp="wrapper";function kRp(e){let{components:n,...t}=e;return(0,s.yg)(NRp,(0,p.A)({},bRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}kRp.isMDXComponent=!0;const zRp={toc:[]},PRp="wrapper";function IRp(e){let{components:n,...t}=e;return(0,s.yg)(PRp,(0,p.A)({},zRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}IRp.isMDXComponent=!0;const RRp={toc:[]},WRp="wrapper";function SRp(e){let{components:n,...t}=e;return(0,s.yg)(WRp,(0,p.A)({},RRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}SRp.isMDXComponent=!0;const BRp={toc:[]},GRp="wrapper";function ERp(e){let{components:n,...t}=e;return(0,s.yg)(GRp,(0,p.A)({},BRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}ERp.isMDXComponent=!0;const ORp={toc:[]},URp="wrapper";function FRp(e){let{components:n,...t}=e;return(0,s.yg)(URp,(0,p.A)({},ORp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}FRp.isMDXComponent=!0;const VRp={toc:[]},qRp="wrapper";function jRp(e){let{components:n,...t}=e;return(0,s.yg)(qRp,(0,p.A)({},VRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}jRp.isMDXComponent=!0;const HRp={toc:[]},YRp="wrapper";function QRp(e){let{components:n,...t}=e;return(0,s.yg)(YRp,(0,p.A)({},HRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QRp.isMDXComponent=!0;const $Rp={toc:[]},KRp="wrapper";function JRp(e){let{components:n,...t}=e;return(0,s.yg)(KRp,(0,p.A)({},$Rp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}JRp.isMDXComponent=!0;const ZRp={toc:[]},eWp="wrapper";function nWp(e){let{components:n,...t}=e;return(0,s.yg)(eWp,(0,p.A)({},ZRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}nWp.isMDXComponent=!0;const tWp={toc:[]},oWp="wrapper";function pWp(e){let{components:n,...t}=e;return(0,s.yg)(oWp,(0,p.A)({},tWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}pWp.isMDXComponent=!0;const rWp={toc:[]},sWp="wrapper";function cWp(e){let{components:n,...t}=e;return(0,s.yg)(sWp,(0,p.A)({},rWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cWp.isMDXComponent=!0;const aWp={toc:[]},iWp="wrapper";function lWp(e){let{components:n,...t}=e;return(0,s.yg)(iWp,(0,p.A)({},aWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}lWp.isMDXComponent=!0;const uWp={toc:[]},mWp="wrapper";function yWp(e){let{components:n,...t}=e;return(0,s.yg)(mWp,(0,p.A)({},uWp,t,{components:n,mdxType:"MDXLayout"}))}yWp.isMDXComponent=!0;const dWp={toc:[]},hWp="wrapper";function gWp(e){let{components:n,...t}=e;return(0,s.yg)(hWp,(0,p.A)({},dWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}gWp.isMDXComponent=!0;const fWp={toc:[]},DWp="wrapper";function MWp(e){let{components:n,...t}=e;return(0,s.yg)(DWp,(0,p.A)({},fWp,t,{components:n,mdxType:"MDXLayout"}))}MWp.isMDXComponent=!0;const XWp={toc:[]},_Wp="wrapper";function wWp(e){let{components:n,...t}=e;return(0,s.yg)(_Wp,(0,p.A)({},XWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}wWp.isMDXComponent=!0;const TWp={toc:[]},CWp="wrapper";function xWp(e){let{components:n,...t}=e;return(0,s.yg)(CWp,(0,p.A)({},TWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}xWp.isMDXComponent=!0;const AWp={toc:[]},vWp="wrapper";function LWp(e){let{components:n,...t}=e;return(0,s.yg)(vWp,(0,p.A)({},AWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LWp.isMDXComponent=!0;const bWp={toc:[]},NWp="wrapper";function kWp(e){let{components:n,...t}=e;return(0,s.yg)(NWp,(0,p.A)({},bWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}kWp.isMDXComponent=!0;const zWp={toc:[]},PWp="wrapper";function IWp(e){let{components:n,...t}=e;return(0,s.yg)(PWp,(0,p.A)({},zWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}IWp.isMDXComponent=!0;const RWp={toc:[]},WWp="wrapper";function SWp(e){let{components:n,...t}=e;return(0,s.yg)(WWp,(0,p.A)({},RWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}SWp.isMDXComponent=!0;const BWp={toc:[]},GWp="wrapper";function EWp(e){let{components:n,...t}=e;return(0,s.yg)(GWp,(0,p.A)({},BWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EWp.isMDXComponent=!0;const OWp={toc:[]},UWp="wrapper";function FWp(e){let{components:n,...t}=e;return(0,s.yg)(UWp,(0,p.A)({},OWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}FWp.isMDXComponent=!0;const VWp={toc:[]},qWp="wrapper";function jWp(e){let{components:n,...t}=e;return(0,s.yg)(qWp,(0,p.A)({},VWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jWp.isMDXComponent=!0;const HWp={toc:[]},YWp="wrapper";function QWp(e){let{components:n,...t}=e;return(0,s.yg)(YWp,(0,p.A)({},HWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}QWp.isMDXComponent=!0;const $Wp={toc:[]},KWp="wrapper";function JWp(e){let{components:n,...t}=e;return(0,s.yg)(KWp,(0,p.A)({},$Wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JWp.isMDXComponent=!0;const ZWp={toc:[]},eSp="wrapper";function nSp(e){let{components:n,...t}=e;return(0,s.yg)(eSp,(0,p.A)({},ZWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}nSp.isMDXComponent=!0;const tSp={toc:[]},oSp="wrapper";function pSp(e){let{components:n,...t}=e;return(0,s.yg)(oSp,(0,p.A)({},tSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}pSp.isMDXComponent=!0;const rSp={toc:[]},sSp="wrapper";function cSp(e){let{components:n,...t}=e;return(0,s.yg)(sSp,(0,p.A)({},rSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}cSp.isMDXComponent=!0;const aSp={toc:[]},iSp="wrapper";function lSp(e){let{components:n,...t}=e;return(0,s.yg)(iSp,(0,p.A)({},aSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lSp.isMDXComponent=!0;const uSp={toc:[]},mSp="wrapper";function ySp(e){let{components:n,...t}=e;return(0,s.yg)(mSp,(0,p.A)({},uSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}ySp.isMDXComponent=!0;const dSp={toc:[]},hSp="wrapper";function gSp(e){let{components:n,...t}=e;return(0,s.yg)(hSp,(0,p.A)({},dSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gSp.isMDXComponent=!0;const fSp={toc:[]},DSp="wrapper";function MSp(e){let{components:n,...t}=e;return(0,s.yg)(DSp,(0,p.A)({},fSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}MSp.isMDXComponent=!0;const XSp={toc:[]},_Sp="wrapper";function wSp(e){let{components:n,...t}=e;return(0,s.yg)(_Sp,(0,p.A)({},XSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wSp.isMDXComponent=!0;const TSp={toc:[]},CSp="wrapper";function xSp(e){let{components:n,...t}=e;return(0,s.yg)(CSp,(0,p.A)({},TSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}xSp.isMDXComponent=!0;const ASp={toc:[]},vSp="wrapper";function LSp(e){let{components:n,...t}=e;return(0,s.yg)(vSp,(0,p.A)({},ASp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}LSp.isMDXComponent=!0;const bSp={toc:[]},NSp="wrapper";function kSp(e){let{components:n,...t}=e;return(0,s.yg)(NSp,(0,p.A)({},bSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kSp.isMDXComponent=!0;const zSp={toc:[]},PSp="wrapper";function ISp(e){let{components:n,...t}=e;return(0,s.yg)(PSp,(0,p.A)({},zSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ISp.isMDXComponent=!0;const RSp={toc:[]},WSp="wrapper";function SSp(e){let{components:n,...t}=e;return(0,s.yg)(WSp,(0,p.A)({},RSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SSp.isMDXComponent=!0;const BSp={toc:[]},GSp="wrapper";function ESp(e){let{components:n,...t}=e;return(0,s.yg)(GSp,(0,p.A)({},BSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ESp.isMDXComponent=!0;const OSp={toc:[]},USp="wrapper";function FSp(e){let{components:n,...t}=e;return(0,s.yg)(USp,(0,p.A)({},OSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}FSp.isMDXComponent=!0;const VSp={toc:[]},qSp="wrapper";function jSp(e){let{components:n,...t}=e;return(0,s.yg)(qSp,(0,p.A)({},VSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jSp.isMDXComponent=!0;const HSp={toc:[]},YSp="wrapper";function QSp(e){let{components:n,...t}=e;return(0,s.yg)(YSp,(0,p.A)({},HSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QSp.isMDXComponent=!0;const $Sp={toc:[]},KSp="wrapper";function JSp(e){let{components:n,...t}=e;return(0,s.yg)(KSp,(0,p.A)({},$Sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}JSp.isMDXComponent=!0;const ZSp={toc:[]},eBp="wrapper";function nBp(e){let{components:n,...t}=e;return(0,s.yg)(eBp,(0,p.A)({},ZSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nBp.isMDXComponent=!0;const tBp={toc:[]},oBp="wrapper";function pBp(e){let{components:n,...t}=e;return(0,s.yg)(oBp,(0,p.A)({},tBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}pBp.isMDXComponent=!0;const rBp={toc:[]},sBp="wrapper";function cBp(e){let{components:n,...t}=e;return(0,s.yg)(sBp,(0,p.A)({},rBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}cBp.isMDXComponent=!0;const aBp={toc:[]},iBp="wrapper";function lBp(e){let{components:n,...t}=e;return(0,s.yg)(iBp,(0,p.A)({},aBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}lBp.isMDXComponent=!0;const uBp={toc:[]},mBp="wrapper";function yBp(e){let{components:n,...t}=e;return(0,s.yg)(mBp,(0,p.A)({},uBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}yBp.isMDXComponent=!0;const dBp={toc:[]},hBp="wrapper";function gBp(e){let{components:n,...t}=e;return(0,s.yg)(hBp,(0,p.A)({},dBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gBp.isMDXComponent=!0;const fBp={toc:[]},DBp="wrapper";function MBp(e){let{components:n,...t}=e;return(0,s.yg)(DBp,(0,p.A)({},fBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}MBp.isMDXComponent=!0;const XBp={toc:[]},_Bp="wrapper";function wBp(e){let{components:n,...t}=e;return(0,s.yg)(_Bp,(0,p.A)({},XBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wBp.isMDXComponent=!0;const TBp={toc:[]},CBp="wrapper";function xBp(e){let{components:n,...t}=e;return(0,s.yg)(CBp,(0,p.A)({},TBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}xBp.isMDXComponent=!0;const ABp={toc:[]},vBp="wrapper";function LBp(e){let{components:n,...t}=e;return(0,s.yg)(vBp,(0,p.A)({},ABp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LBp.isMDXComponent=!0;const bBp={toc:[]},NBp="wrapper";function kBp(e){let{components:n,...t}=e;return(0,s.yg)(NBp,(0,p.A)({},bBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}kBp.isMDXComponent=!0;const zBp={toc:[]},PBp="wrapper";function IBp(e){let{components:n,...t}=e;return(0,s.yg)(PBp,(0,p.A)({},zBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}IBp.isMDXComponent=!0;const RBp={toc:[]},WBp="wrapper";function SBp(e){let{components:n,...t}=e;return(0,s.yg)(WBp,(0,p.A)({},RBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}SBp.isMDXComponent=!0;const BBp={toc:[]},GBp="wrapper";function EBp(e){let{components:n,...t}=e;return(0,s.yg)(GBp,(0,p.A)({},BBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EBp.isMDXComponent=!0;const OBp={toc:[]},UBp="wrapper";function FBp(e){let{components:n,...t}=e;return(0,s.yg)(UBp,(0,p.A)({},OBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}FBp.isMDXComponent=!0;const VBp={toc:[]},qBp="wrapper";function jBp(e){let{components:n,...t}=e;return(0,s.yg)(qBp,(0,p.A)({},VBp,t,{components:n,mdxType:"MDXLayout"}))}jBp.isMDXComponent=!0;const HBp={toc:[]},YBp="wrapper";function QBp(e){let{components:n,...t}=e;return(0,s.yg)(YBp,(0,p.A)({},HBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}QBp.isMDXComponent=!0;const $Bp={toc:[]},KBp="wrapper";function JBp(e){let{components:n,...t}=e;return(0,s.yg)(KBp,(0,p.A)({},$Bp,t,{components:n,mdxType:"MDXLayout"}))}JBp.isMDXComponent=!0;const ZBp={toc:[]},eGp="wrapper";function nGp(e){let{components:n,...t}=e;return(0,s.yg)(eGp,(0,p.A)({},ZBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}nGp.isMDXComponent=!0;const tGp={toc:[]},oGp="wrapper";function pGp(e){let{components:n,...t}=e;return(0,s.yg)(oGp,(0,p.A)({},tGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}pGp.isMDXComponent=!0;const rGp={toc:[]},sGp="wrapper";function cGp(e){let{components:n,...t}=e;return(0,s.yg)(sGp,(0,p.A)({},rGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cGp.isMDXComponent=!0;const aGp={toc:[]},iGp="wrapper";function lGp(e){let{components:n,...t}=e;return(0,s.yg)(iGp,(0,p.A)({},aGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}lGp.isMDXComponent=!0;const uGp={toc:[]},mGp="wrapper";function yGp(e){let{components:n,...t}=e;return(0,s.yg)(mGp,(0,p.A)({},uGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}yGp.isMDXComponent=!0;const dGp={toc:[]},hGp="wrapper";function gGp(e){let{components:n,...t}=e;return(0,s.yg)(hGp,(0,p.A)({},dGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}gGp.isMDXComponent=!0;const fGp={toc:[]},DGp="wrapper";function MGp(e){let{components:n,...t}=e;return(0,s.yg)(DGp,(0,p.A)({},fGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MGp.isMDXComponent=!0;const XGp={toc:[]},_Gp="wrapper";function wGp(e){let{components:n,...t}=e;return(0,s.yg)(_Gp,(0,p.A)({},XGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}wGp.isMDXComponent=!0;const TGp={toc:[]},CGp="wrapper";function xGp(e){let{components:n,...t}=e;return(0,s.yg)(CGp,(0,p.A)({},TGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xGp.isMDXComponent=!0;const AGp={toc:[]},vGp="wrapper";function LGp(e){let{components:n,...t}=e;return(0,s.yg)(vGp,(0,p.A)({},AGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}LGp.isMDXComponent=!0;const bGp={toc:[]},NGp="wrapper";function kGp(e){let{components:n,...t}=e;return(0,s.yg)(NGp,(0,p.A)({},bGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kGp.isMDXComponent=!0;const zGp={toc:[]},PGp="wrapper";function IGp(e){let{components:n,...t}=e;return(0,s.yg)(PGp,(0,p.A)({},zGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}IGp.isMDXComponent=!0;const RGp={toc:[]},WGp="wrapper";function SGp(e){let{components:n,...t}=e;return(0,s.yg)(WGp,(0,p.A)({},RGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom drawing logic used by the Code node."))}SGp.isMDXComponent=!0;const BGp={toc:[]},GGp="wrapper";function EGp(e){let{components:n,...t}=e;return(0,s.yg)(GGp,(0,p.A)({},BGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"token(ctx, text, position, color, selection) {\n  const blur = map(3, 0, selection);\n  const alpha = map(0.5, 1, selection);\n  ctx.globalAlpha *= alpha;\n  ctx.filter = `blur(${blur}px)`;\n  ctx.fillStyle = color;\n  ctx.fillText(text, position.x, position.y);\n}\n")))}EGp.isMDXComponent=!0;const OGp={toc:[]},UGp="wrapper";function FGp(e){let{components:n,...t}=e;return(0,s.yg)(UGp,(0,p.A)({},OGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for individual code tokens."))}FGp.isMDXComponent=!0;const VGp={toc:[]},qGp="wrapper";function jGp(e){let{components:n,...t}=e;return(0,s.yg)(qGp,(0,p.A)({},VGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jGp.isMDXComponent=!0;const HGp={toc:[]},YGp="wrapper";function QGp(e){let{components:n,...t}=e;return(0,s.yg)(YGp,(0,p.A)({},HGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}QGp.isMDXComponent=!0;const $Gp={toc:[]},KGp="wrapper";function JGp(e){let{components:n,...t}=e;return(0,s.yg)(KGp,(0,p.A)({},$Gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JGp.isMDXComponent=!0;const ZGp={toc:[]},eEp="wrapper";function nEp(e){let{components:n,...t}=e;return(0,s.yg)(eEp,(0,p.A)({},ZGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}nEp.isMDXComponent=!0;const tEp={toc:[]},oEp="wrapper";function pEp(e){let{components:n,...t}=e;return(0,s.yg)(oEp,(0,p.A)({},tEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pEp.isMDXComponent=!0;const rEp={toc:[]},sEp="wrapper";function cEp(e){let{components:n,...t}=e;return(0,s.yg)(sEp,(0,p.A)({},rEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}cEp.isMDXComponent=!0;const aEp={toc:[]},iEp="wrapper";function lEp(e){let{components:n,...t}=e;return(0,s.yg)(iEp,(0,p.A)({},aEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lEp.isMDXComponent=!0;const uEp={toc:[]},mEp="wrapper";function yEp(e){let{components:n,...t}=e;return(0,s.yg)(mEp,(0,p.A)({},uEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yEp.isMDXComponent=!0;const dEp={toc:[]},hEp="wrapper";function gEp(e){let{components:n,...t}=e;return(0,s.yg)(hEp,(0,p.A)({},dEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gEp.isMDXComponent=!0;const fEp={toc:[]},DEp="wrapper";function MEp(e){let{components:n,...t}=e;return(0,s.yg)(DEp,(0,p.A)({},fEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}MEp.isMDXComponent=!0;const XEp={toc:[]},_Ep="wrapper";function wEp(e){let{components:n,...t}=e;return(0,s.yg)(_Ep,(0,p.A)({},XEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wEp.isMDXComponent=!0;const TEp={toc:[]},CEp="wrapper";function xEp(e){let{components:n,...t}=e;return(0,s.yg)(CEp,(0,p.A)({},TEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xEp.isMDXComponent=!0;const AEp={toc:[]},vEp="wrapper";function LEp(e){let{components:n,...t}=e;return(0,s.yg)(vEp,(0,p.A)({},AEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}LEp.isMDXComponent=!0;const bEp={toc:[]},NEp="wrapper";function kEp(e){let{components:n,...t}=e;return(0,s.yg)(NEp,(0,p.A)({},bEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kEp.isMDXComponent=!0;const zEp={toc:[]},PEp="wrapper";function IEp(e){let{components:n,...t}=e;return(0,s.yg)(PEp,(0,p.A)({},zEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}IEp.isMDXComponent=!0;const REp={toc:[]},WEp="wrapper";function SEp(e){let{components:n,...t}=e;return(0,s.yg)(WEp,(0,p.A)({},REp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SEp.isMDXComponent=!0;const BEp={toc:[]},GEp="wrapper";function EEp(e){let{components:n,...t}=e;return(0,s.yg)(GEp,(0,p.A)({},BEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}EEp.isMDXComponent=!0;const OEp={toc:[]},UEp="wrapper";function FEp(e){let{components:n,...t}=e;return(0,s.yg)(UEp,(0,p.A)({},OEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the end of each grid line."))}FEp.isMDXComponent=!0;const VEp={toc:[]},qEp="wrapper";function jEp(e){let{components:n,...t}=e;return(0,s.yg)(qEp,(0,p.A)({},VEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jEp.isMDXComponent=!0;const HEp={toc:[]},YEp="wrapper";function QEp(e){let{components:n,...t}=e;return(0,s.yg)(YEp,(0,p.A)({},HEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}QEp.isMDXComponent=!0;const $Ep={toc:[]},KEp="wrapper";function JEp(e){let{components:n,...t}=e;return(0,s.yg)(KEp,(0,p.A)({},$Ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}JEp.isMDXComponent=!0;const ZEp={toc:[]},eOp="wrapper";function nOp(e){let{components:n,...t}=e;return(0,s.yg)(eOp,(0,p.A)({},ZEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}nOp.isMDXComponent=!0;const tOp={toc:[]},oOp="wrapper";function pOp(e){let{components:n,...t}=e;return(0,s.yg)(oOp,(0,p.A)({},tOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pOp.isMDXComponent=!0;const rOp={toc:[]},sOp="wrapper";function cOp(e){let{components:n,...t}=e;return(0,s.yg)(sOp,(0,p.A)({},rOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}cOp.isMDXComponent=!0;const aOp={toc:[]},iOp="wrapper";function lOp(e){let{components:n,...t}=e;return(0,s.yg)(iOp,(0,p.A)({},aOp,t,{components:n,mdxType:"MDXLayout"}))}lOp.isMDXComponent=!0;const uOp={toc:[]},mOp="wrapper";function yOp(e){let{components:n,...t}=e;return(0,s.yg)(mOp,(0,p.A)({},uOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The spacing between the grid lines."))}yOp.isMDXComponent=!0;const dOp={toc:[]},hOp="wrapper";function gOp(e){let{components:n,...t}=e;return(0,s.yg)(hOp,(0,p.A)({},dOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}gOp.isMDXComponent=!0;const fOp={toc:[]},DOp="wrapper";function MOp(e){let{components:n,...t}=e;return(0,s.yg)(DOp,(0,p.A)({},fOp,t,{components:n,mdxType:"MDXLayout"}))}MOp.isMDXComponent=!0;const XOp={toc:[]},_Op="wrapper";function wOp(e){let{components:n,...t}=e;return(0,s.yg)(_Op,(0,p.A)({},XOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}wOp.isMDXComponent=!0;const TOp={toc:[]},COp="wrapper";function xOp(e){let{components:n,...t}=e;return(0,s.yg)(COp,(0,p.A)({},TOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}xOp.isMDXComponent=!0;const AOp={toc:[]},vOp="wrapper";function LOp(e){let{components:n,...t}=e;return(0,s.yg)(vOp,(0,p.A)({},AOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LOp.isMDXComponent=!0;const bOp={toc:[]},NOp="wrapper";function kOp(e){let{components:n,...t}=e;return(0,s.yg)(NOp,(0,p.A)({},bOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}kOp.isMDXComponent=!0;const zOp={toc:[]},POp="wrapper";function IOp(e){let{components:n,...t}=e;return(0,s.yg)(POp,(0,p.A)({},zOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}IOp.isMDXComponent=!0;const ROp={toc:[]},WOp="wrapper";function SOp(e){let{components:n,...t}=e;return(0,s.yg)(WOp,(0,p.A)({},ROp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}SOp.isMDXComponent=!0;const BOp={toc:[]},GOp="wrapper";function EOp(e){let{components:n,...t}=e;return(0,s.yg)(GOp,(0,p.A)({},BOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EOp.isMDXComponent=!0;const OOp={toc:[]},UOp="wrapper";function FOp(e){let{components:n,...t}=e;return(0,s.yg)(UOp,(0,p.A)({},OOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}FOp.isMDXComponent=!0;const VOp={toc:[]},qOp="wrapper";function jOp(e){let{components:n,...t}=e;return(0,s.yg)(qOp,(0,p.A)({},VOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}jOp.isMDXComponent=!0;const HOp={toc:[]},YOp="wrapper";function QOp(e){let{components:n,...t}=e;return(0,s.yg)(YOp,(0,p.A)({},HOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}QOp.isMDXComponent=!0;const $Op={toc:[]},KOp="wrapper";function JOp(e){let{components:n,...t}=e;return(0,s.yg)(KOp,(0,p.A)({},$Op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}JOp.isMDXComponent=!0;const ZOp={toc:[]},eUp="wrapper";function nUp(e){let{components:n,...t}=e;return(0,s.yg)(eUp,(0,p.A)({},ZOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}nUp.isMDXComponent=!0;const tUp={toc:[]},oUp="wrapper";function pUp(e){let{components:n,...t}=e;return(0,s.yg)(oUp,(0,p.A)({},tUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pUp.isMDXComponent=!0;const rUp={toc:[]},sUp="wrapper";function cUp(e){let{components:n,...t}=e;return(0,s.yg)(sUp,(0,p.A)({},rUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}cUp.isMDXComponent=!0;const aUp={toc:[]},iUp="wrapper";function lUp(e){let{components:n,...t}=e;return(0,s.yg)(iUp,(0,p.A)({},aUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lUp.isMDXComponent=!0;const uUp={toc:[]},mUp="wrapper";function yUp(e){let{components:n,...t}=e;return(0,s.yg)(mUp,(0,p.A)({},uUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}yUp.isMDXComponent=!0;const dUp={toc:[]},hUp="wrapper";function gUp(e){let{components:n,...t}=e;return(0,s.yg)(hUp,(0,p.A)({},dUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gUp.isMDXComponent=!0;const fUp={toc:[]},DUp="wrapper";function MUp(e){let{components:n,...t}=e;return(0,s.yg)(DUp,(0,p.A)({},fUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}MUp.isMDXComponent=!0;const XUp={toc:[]},_Up="wrapper";function wUp(e){let{components:n,...t}=e;return(0,s.yg)(_Up,(0,p.A)({},XUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wUp.isMDXComponent=!0;const TUp={toc:[]},CUp="wrapper";function xUp(e){let{components:n,...t}=e;return(0,s.yg)(CUp,(0,p.A)({},TUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xUp.isMDXComponent=!0;const AUp={toc:[]},vUp="wrapper";function LUp(e){let{components:n,...t}=e;return(0,s.yg)(vUp,(0,p.A)({},AUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}LUp.isMDXComponent=!0;const bUp={toc:[]},NUp="wrapper";function kUp(e){let{components:n,...t}=e;return(0,s.yg)(NUp,(0,p.A)({},bUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kUp.isMDXComponent=!0;const zUp={toc:[]},PUp="wrapper";function IUp(e){let{components:n,...t}=e;return(0,s.yg)(PUp,(0,p.A)({},zUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}IUp.isMDXComponent=!0;const RUp={toc:[]},WUp="wrapper";function SUp(e){let{components:n,...t}=e;return(0,s.yg)(WUp,(0,p.A)({},RUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SUp.isMDXComponent=!0;const BUp={toc:[]},GUp="wrapper";function EUp(e){let{components:n,...t}=e;return(0,s.yg)(GUp,(0,p.A)({},BUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}EUp.isMDXComponent=!0;const OUp={toc:[]},UUp="wrapper";function FUp(e){let{components:n,...t}=e;return(0,s.yg)(UUp,(0,p.A)({},OUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}FUp.isMDXComponent=!0;const VUp={toc:[]},qUp="wrapper";function jUp(e){let{components:n,...t}=e;return(0,s.yg)(qUp,(0,p.A)({},VUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jUp.isMDXComponent=!0;const HUp={toc:[]},YUp="wrapper";function QUp(e){let{components:n,...t}=e;return(0,s.yg)(YUp,(0,p.A)({},HUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QUp.isMDXComponent=!0;const $Up={toc:[]},KUp="wrapper";function JUp(e){let{components:n,...t}=e;return(0,s.yg)(KUp,(0,p.A)({},$Up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}JUp.isMDXComponent=!0;const ZUp={toc:[]},eFp="wrapper";function nFp(e){let{components:n,...t}=e;return(0,s.yg)(eFp,(0,p.A)({},ZUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}nFp.isMDXComponent=!0;const tFp={toc:[]},oFp="wrapper";function pFp(e){let{components:n,...t}=e;return(0,s.yg)(oFp,(0,p.A)({},tFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide the color in one of the following formats:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"named color like ",(0,s.yg)("inlineCode",{parentName:"li"},"red"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.yg)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.yg)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}pFp.isMDXComponent=!0;const rFp={toc:[]},sFp="wrapper";function cFp(e){let{components:n,...t}=e;return(0,s.yg)(sFp,(0,p.A)({},rFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the icon"))}cFp.isMDXComponent=!0;const aFp={toc:[]},iFp="wrapper";function lFp(e){let{components:n,...t}=e;return(0,s.yg)(iFp,(0,p.A)({},aFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lFp.isMDXComponent=!0;const uFp={toc:[]},mFp="wrapper";function yFp(e){let{components:n,...t}=e;return(0,s.yg)(mFp,(0,p.A)({},uFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}yFp.isMDXComponent=!0;const dFp={toc:[]},hFp="wrapper";function gFp(e){let{components:n,...t}=e;return(0,s.yg)(hFp,(0,p.A)({},dFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}gFp.isMDXComponent=!0;const fFp={toc:[]},DFp="wrapper";function MFp(e){let{components:n,...t}=e;return(0,s.yg)(DFp,(0,p.A)({},fFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}MFp.isMDXComponent=!0;const XFp={toc:[]},_Fp="wrapper";function wFp(e){let{components:n,...t}=e;return(0,s.yg)(_Fp,(0,p.A)({},XFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wFp.isMDXComponent=!0;const TFp={toc:[]},CFp="wrapper";function xFp(e){let{components:n,...t}=e;return(0,s.yg)(CFp,(0,p.A)({},TFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}xFp.isMDXComponent=!0;const AFp={toc:[]},vFp="wrapper";function LFp(e){let{components:n,...t}=e;return(0,s.yg)(vFp,(0,p.A)({},AFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LFp.isMDXComponent=!0;const bFp={toc:[]},NFp="wrapper";function kFp(e){let{components:n,...t}=e;return(0,s.yg)(NFp,(0,p.A)({},bFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}kFp.isMDXComponent=!0;const zFp={toc:[]},PFp="wrapper";function IFp(e){let{components:n,...t}=e;return(0,s.yg)(PFp,(0,p.A)({},zFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can find identifiers on ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}IFp.isMDXComponent=!0;const RFp={toc:[]},WFp="wrapper";function SFp(e){let{components:n,...t}=e;return(0,s.yg)(WFp,(0,p.A)({},RFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The identifier of the icon."))}SFp.isMDXComponent=!0;const BFp={toc:[]},GFp="wrapper";function EFp(e){let{components:n,...t}=e;return(0,s.yg)(GFp,(0,p.A)({},BFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EFp.isMDXComponent=!0;const OFp={toc:[]},UFp="wrapper";function FFp(e){let{components:n,...t}=e;return(0,s.yg)(UFp,(0,p.A)({},OFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}FFp.isMDXComponent=!0;const VFp={toc:[]},qFp="wrapper";function jFp(e){let{components:n,...t}=e;return(0,s.yg)(qFp,(0,p.A)({},VFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}jFp.isMDXComponent=!0;const HFp={toc:[]},YFp="wrapper";function QFp(e){let{components:n,...t}=e;return(0,s.yg)(YFp,(0,p.A)({},HFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}QFp.isMDXComponent=!0;const $Fp={toc:[]},KFp="wrapper";function JFp(e){let{components:n,...t}=e;return(0,s.yg)(KFp,(0,p.A)({},$Fp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}JFp.isMDXComponent=!0;const ZFp={toc:[]},eVp="wrapper";function nVp(e){let{components:n,...t}=e;return(0,s.yg)(eVp,(0,p.A)({},ZFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}nVp.isMDXComponent=!0;const tVp={toc:[]},oVp="wrapper";function pVp(e){let{components:n,...t}=e;return(0,s.yg)(oVp,(0,p.A)({},tVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pVp.isMDXComponent=!0;const rVp={toc:[]},sVp="wrapper";function cVp(e){let{components:n,...t}=e;return(0,s.yg)(sVp,(0,p.A)({},rVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}cVp.isMDXComponent=!0;const aVp={toc:[]},iVp="wrapper";function lVp(e){let{components:n,...t}=e;return(0,s.yg)(iVp,(0,p.A)({},aVp,t,{components:n,mdxType:"MDXLayout"}))}lVp.isMDXComponent=!0;const uVp={toc:[]},mVp="wrapper";function yVp(e){let{components:n,...t}=e;return(0,s.yg)(mVp,(0,p.A)({},uVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}yVp.isMDXComponent=!0;const dVp={toc:[]},hVp="wrapper";function gVp(e){let{components:n,...t}=e;return(0,s.yg)(hVp,(0,p.A)({},dVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}gVp.isMDXComponent=!0;const fVp={toc:[]},DVp="wrapper";function MVp(e){let{components:n,...t}=e;return(0,s.yg)(DVp,(0,p.A)({},fVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}MVp.isMDXComponent=!0;const XVp={toc:[]},_Vp="wrapper";function wVp(e){let{components:n,...t}=e;return(0,s.yg)(_Vp,(0,p.A)({},XVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}wVp.isMDXComponent=!0;const TVp={toc:[]},CVp="wrapper";function xVp(e){let{components:n,...t}=e;return(0,s.yg)(CVp,(0,p.A)({},TVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}xVp.isMDXComponent=!0;const AVp={toc:[]},vVp="wrapper";function LVp(e){let{components:n,...t}=e;return(0,s.yg)(vVp,(0,p.A)({},AVp,t,{components:n,mdxType:"MDXLayout"}))}LVp.isMDXComponent=!0;const bVp={toc:[]},NVp="wrapper";function kVp(e){let{components:n,...t}=e;return(0,s.yg)(NVp,(0,p.A)({},bVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}kVp.isMDXComponent=!0;const zVp={toc:[]},PVp="wrapper";function IVp(e){let{components:n,...t}=e;return(0,s.yg)(PVp,(0,p.A)({},zVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}IVp.isMDXComponent=!0;const RVp={toc:[]},WVp="wrapper";function SVp(e){let{components:n,...t}=e;return(0,s.yg)(WVp,(0,p.A)({},RVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}SVp.isMDXComponent=!0;const BVp={toc:[]},GVp="wrapper";function EVp(e){let{components:n,...t}=e;return(0,s.yg)(GVp,(0,p.A)({},BVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}EVp.isMDXComponent=!0;const OVp={toc:[]},UVp="wrapper";function FVp(e){let{components:n,...t}=e;return(0,s.yg)(UVp,(0,p.A)({},OVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}FVp.isMDXComponent=!0;const VVp={toc:[]},qVp="wrapper";function jVp(e){let{components:n,...t}=e;return(0,s.yg)(qVp,(0,p.A)({},VVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jVp.isMDXComponent=!0;const HVp={toc:[]},YVp="wrapper";function QVp(e){let{components:n,...t}=e;return(0,s.yg)(YVp,(0,p.A)({},HVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}QVp.isMDXComponent=!0;const $Vp={toc:[]},KVp="wrapper";function JVp(e){let{components:n,...t}=e;return(0,s.yg)(KVp,(0,p.A)({},$Vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JVp.isMDXComponent=!0;const ZVp={toc:[]},eqp="wrapper";function nqp(e){let{components:n,...t}=e;return(0,s.yg)(eqp,(0,p.A)({},ZVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}nqp.isMDXComponent=!0;const tqp={toc:[]},oqp="wrapper";function pqp(e){let{components:n,...t}=e;return(0,s.yg)(oqp,(0,p.A)({},tqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pqp.isMDXComponent=!0;const rqp={toc:[]},sqp="wrapper";function cqp(e){let{components:n,...t}=e;return(0,s.yg)(sqp,(0,p.A)({},rqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}cqp.isMDXComponent=!0;const aqp={toc:[]},iqp="wrapper";function lqp(e){let{components:n,...t}=e;return(0,s.yg)(iqp,(0,p.A)({},aqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lqp.isMDXComponent=!0;const uqp={toc:[]},mqp="wrapper";function yqp(e){let{components:n,...t}=e;return(0,s.yg)(mqp,(0,p.A)({},uqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}yqp.isMDXComponent=!0;const dqp={toc:[]},hqp="wrapper";function gqp(e){let{components:n,...t}=e;return(0,s.yg)(hqp,(0,p.A)({},dqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}gqp.isMDXComponent=!0;const fqp={toc:[]},Dqp="wrapper";function Mqp(e){let{components:n,...t}=e;return(0,s.yg)(Dqp,(0,p.A)({},fqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}Mqp.isMDXComponent=!0;const Xqp={toc:[]},_qp="wrapper";function wqp(e){let{components:n,...t}=e;return(0,s.yg)(_qp,(0,p.A)({},Xqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}wqp.isMDXComponent=!0;const Tqp={toc:[]},Cqp="wrapper";function xqp(e){let{components:n,...t}=e;return(0,s.yg)(Cqp,(0,p.A)({},Tqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}xqp.isMDXComponent=!0;const Aqp={toc:[]},vqp="wrapper";function Lqp(e){let{components:n,...t}=e;return(0,s.yg)(vqp,(0,p.A)({},Aqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Lqp.isMDXComponent=!0;const bqp={toc:[]},Nqp="wrapper";function kqp(e){let{components:n,...t}=e;return(0,s.yg)(Nqp,(0,p.A)({},bqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}kqp.isMDXComponent=!0;const zqp={toc:[]},Pqp="wrapper";function Iqp(e){let{components:n,...t}=e;return(0,s.yg)(Pqp,(0,p.A)({},zqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Iqp.isMDXComponent=!0;const Rqp={toc:[]},Wqp="wrapper";function Sqp(e){let{components:n,...t}=e;return(0,s.yg)(Wqp,(0,p.A)({},Rqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Sqp.isMDXComponent=!0;const Bqp={toc:[]},Gqp="wrapper";function Eqp(e){let{components:n,...t}=e;return(0,s.yg)(Gqp,(0,p.A)({},Bqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Eqp.isMDXComponent=!0;const Oqp={toc:[]},Uqp="wrapper";function Fqp(e){let{components:n,...t}=e;return(0,s.yg)(Uqp,(0,p.A)({},Oqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Fqp.isMDXComponent=!0;const Vqp={toc:[]},qqp="wrapper";function jqp(e){let{components:n,...t}=e;return(0,s.yg)(qqp,(0,p.A)({},Vqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jqp.isMDXComponent=!0;const Hqp={toc:[]},Yqp="wrapper";function Qqp(e){let{components:n,...t}=e;return(0,s.yg)(Yqp,(0,p.A)({},Hqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Qqp.isMDXComponent=!0;const $qp={toc:[]},Kqp="wrapper";function Jqp(e){let{components:n,...t}=e;return(0,s.yg)(Kqp,(0,p.A)({},$qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Jqp.isMDXComponent=!0;const Zqp={toc:[]},ejp="wrapper";function njp(e){let{components:n,...t}=e;return(0,s.yg)(ejp,(0,p.A)({},Zqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}njp.isMDXComponent=!0;const tjp={toc:[]},ojp="wrapper";function pjp(e){let{components:n,...t}=e;return(0,s.yg)(ojp,(0,p.A)({},tjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pjp.isMDXComponent=!0;const rjp={toc:[]},sjp="wrapper";function cjp(e){let{components:n,...t}=e;return(0,s.yg)(sjp,(0,p.A)({},rjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cjp.isMDXComponent=!0;const ajp={toc:[]},ijp="wrapper";function ljp(e){let{components:n,...t}=e;return(0,s.yg)(ijp,(0,p.A)({},ajp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ljp.isMDXComponent=!0;const ujp={toc:[]},mjp="wrapper";function yjp(e){let{components:n,...t}=e;return(0,s.yg)(mjp,(0,p.A)({},ujp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yjp.isMDXComponent=!0;const djp={toc:[]},hjp="wrapper";function gjp(e){let{components:n,...t}=e;return(0,s.yg)(hjp,(0,p.A)({},djp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gjp.isMDXComponent=!0;const fjp={toc:[]},Djp="wrapper";function Mjp(e){let{components:n,...t}=e;return(0,s.yg)(Djp,(0,p.A)({},fjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Mjp.isMDXComponent=!0;const Xjp={toc:[]},_jp="wrapper";function wjp(e){let{components:n,...t}=e;return(0,s.yg)(_jp,(0,p.A)({},Xjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}wjp.isMDXComponent=!0;const Tjp={toc:[]},Cjp="wrapper";function xjp(e){let{components:n,...t}=e;return(0,s.yg)(Cjp,(0,p.A)({},Tjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}xjp.isMDXComponent=!0;const Ajp={toc:[]},vjp="wrapper";function Ljp(e){let{components:n,...t}=e;return(0,s.yg)(vjp,(0,p.A)({},Ajp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Ljp.isMDXComponent=!0;const bjp={toc:[]},Njp="wrapper";function kjp(e){let{components:n,...t}=e;return(0,s.yg)(Njp,(0,p.A)({},bjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}kjp.isMDXComponent=!0;const zjp={toc:[]},Pjp="wrapper";function Ijp(e){let{components:n,...t}=e;return(0,s.yg)(Pjp,(0,p.A)({},zjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ijp.isMDXComponent=!0;const Rjp={toc:[]},Wjp="wrapper";function Sjp(e){let{components:n,...t}=e;return(0,s.yg)(Wjp,(0,p.A)({},Rjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Sjp.isMDXComponent=!0;const Bjp={toc:[]},Gjp="wrapper";function Ejp(e){let{components:n,...t}=e;return(0,s.yg)(Gjp,(0,p.A)({},Bjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ejp.isMDXComponent=!0;const Ojp={toc:[]},Ujp="wrapper";function Fjp(e){let{components:n,...t}=e;return(0,s.yg)(Ujp,(0,p.A)({},Ojp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Fjp.isMDXComponent=!0;const Vjp={toc:[]},qjp="wrapper";function jjp(e){let{components:n,...t}=e;return(0,s.yg)(qjp,(0,p.A)({},Vjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}jjp.isMDXComponent=!0;const Hjp={toc:[]},Yjp="wrapper";function Qjp(e){let{components:n,...t}=e;return(0,s.yg)(Yjp,(0,p.A)({},Hjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Qjp.isMDXComponent=!0;const $jp={toc:[]},Kjp="wrapper";function Jjp(e){let{components:n,...t}=e;return(0,s.yg)(Kjp,(0,p.A)({},$jp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Jjp.isMDXComponent=!0;const Zjp={toc:[]},eHp="wrapper";function nHp(e){let{components:n,...t}=e;return(0,s.yg)(eHp,(0,p.A)({},Zjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}nHp.isMDXComponent=!0;const tHp={toc:[]},oHp="wrapper";function pHp(e){let{components:n,...t}=e;return(0,s.yg)(oHp,(0,p.A)({},tHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}pHp.isMDXComponent=!0;const rHp={toc:[]},sHp="wrapper";function cHp(e){let{components:n,...t}=e;return(0,s.yg)(sHp,(0,p.A)({},rHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}cHp.isMDXComponent=!0;const aHp={toc:[]},iHp="wrapper";function lHp(e){let{components:n,...t}=e;return(0,s.yg)(iHp,(0,p.A)({},aHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lHp.isMDXComponent=!0;const uHp={toc:[]},mHp="wrapper";function yHp(e){let{components:n,...t}=e;return(0,s.yg)(mHp,(0,p.A)({},uHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}yHp.isMDXComponent=!0;const dHp={toc:[]},hHp="wrapper";function gHp(e){let{components:n,...t}=e;return(0,s.yg)(hHp,(0,p.A)({},dHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gHp.isMDXComponent=!0;const fHp={toc:[]},DHp="wrapper";function MHp(e){let{components:n,...t}=e;return(0,s.yg)(DHp,(0,p.A)({},fHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}MHp.isMDXComponent=!0;const XHp={toc:[]},_Hp="wrapper";function wHp(e){let{components:n,...t}=e;return(0,s.yg)(_Hp,(0,p.A)({},XHp,t,{components:n,mdxType:"MDXLayout"}))}wHp.isMDXComponent=!0;const THp={toc:[]},CHp="wrapper";function xHp(e){let{components:n,...t}=e;return(0,s.yg)(CHp,(0,p.A)({},THp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}xHp.isMDXComponent=!0;const AHp={toc:[]},vHp="wrapper";function LHp(e){let{components:n,...t}=e;return(0,s.yg)(vHp,(0,p.A)({},AHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}LHp.isMDXComponent=!0;const bHp={toc:[]},NHp="wrapper";function kHp(e){let{components:n,...t}=e;return(0,s.yg)(NHp,(0,p.A)({},bHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}kHp.isMDXComponent=!0;const zHp={toc:[]},PHp="wrapper";function IHp(e){let{components:n,...t}=e;return(0,s.yg)(PHp,(0,p.A)({},zHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}IHp.isMDXComponent=!0;const RHp={toc:[]},WHp="wrapper";function SHp(e){let{components:n,...t}=e;return(0,s.yg)(WHp,(0,p.A)({},RHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}SHp.isMDXComponent=!0;const BHp={toc:[]},GHp="wrapper";function EHp(e){let{components:n,...t}=e;return(0,s.yg)(GHp,(0,p.A)({},BHp,t,{components:n,mdxType:"MDXLayout"}))}EHp.isMDXComponent=!0;const OHp={toc:[]},UHp="wrapper";function FHp(e){let{components:n,...t}=e;return(0,s.yg)(UHp,(0,p.A)({},OHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}FHp.isMDXComponent=!0;const VHp={toc:[]},qHp="wrapper";function jHp(e){let{components:n,...t}=e;return(0,s.yg)(qHp,(0,p.A)({},VHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}jHp.isMDXComponent=!0;const HHp={toc:[]},YHp="wrapper";function QHp(e){let{components:n,...t}=e;return(0,s.yg)(YHp,(0,p.A)({},HHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}QHp.isMDXComponent=!0;const $Hp={toc:[]},KHp="wrapper";function JHp(e){let{components:n,...t}=e;return(0,s.yg)(KHp,(0,p.A)({},$Hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}JHp.isMDXComponent=!0;const ZHp={toc:[]},eYp="wrapper";function nYp(e){let{components:n,...t}=e;return(0,s.yg)(eYp,(0,p.A)({},ZHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}nYp.isMDXComponent=!0;const tYp={toc:[]},oYp="wrapper";function pYp(e){let{components:n,...t}=e;return(0,s.yg)(oYp,(0,p.A)({},tYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}pYp.isMDXComponent=!0;const rYp={toc:[]},sYp="wrapper";function cYp(e){let{components:n,...t}=e;return(0,s.yg)(sYp,(0,p.A)({},rYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}cYp.isMDXComponent=!0;const aYp={toc:[]},iYp="wrapper";function lYp(e){let{components:n,...t}=e;return(0,s.yg)(iYp,(0,p.A)({},aYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lYp.isMDXComponent=!0;const uYp={toc:[]},mYp="wrapper";function yYp(e){let{components:n,...t}=e;return(0,s.yg)(mYp,(0,p.A)({},uYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}yYp.isMDXComponent=!0;const dYp={toc:[]},hYp="wrapper";function gYp(e){let{components:n,...t}=e;return(0,s.yg)(hYp,(0,p.A)({},dYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gYp.isMDXComponent=!0;const fYp={toc:[]},DYp="wrapper";function MYp(e){let{components:n,...t}=e;return(0,s.yg)(DYp,(0,p.A)({},fYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}MYp.isMDXComponent=!0;const XYp={toc:[]},_Yp="wrapper";function wYp(e){let{components:n,...t}=e;return(0,s.yg)(_Yp,(0,p.A)({},XYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wYp.isMDXComponent=!0;const TYp={toc:[]},CYp="wrapper";function xYp(e){let{components:n,...t}=e;return(0,s.yg)(CYp,(0,p.A)({},TYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}xYp.isMDXComponent=!0;const AYp={toc:[]},vYp="wrapper";function LYp(e){let{components:n,...t}=e;return(0,s.yg)(vYp,(0,p.A)({},AYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}LYp.isMDXComponent=!0;const bYp={toc:[]},NYp="wrapper";function kYp(e){let{components:n,...t}=e;return(0,s.yg)(NYp,(0,p.A)({},bYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}kYp.isMDXComponent=!0;const zYp={toc:[]},PYp="wrapper";function IYp(e){let{components:n,...t}=e;return(0,s.yg)(PYp,(0,p.A)({},zYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}IYp.isMDXComponent=!0;const RYp={toc:[]},WYp="wrapper";function SYp(e){let{components:n,...t}=e;return(0,s.yg)(WYp,(0,p.A)({},RYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SYp.isMDXComponent=!0;const BYp={toc:[]},GYp="wrapper";function EYp(e){let{components:n,...t}=e;return(0,s.yg)(GYp,(0,p.A)({},BYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}EYp.isMDXComponent=!0;const OYp={toc:[]},UYp="wrapper";function FYp(e){let{components:n,...t}=e;return(0,s.yg)(UYp,(0,p.A)({},OYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}FYp.isMDXComponent=!0;const VYp={toc:[]},qYp="wrapper";function jYp(e){let{components:n,...t}=e;return(0,s.yg)(qYp,(0,p.A)({},VYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jYp.isMDXComponent=!0;const HYp={toc:[]},YYp="wrapper";function QYp(e){let{components:n,...t}=e;return(0,s.yg)(YYp,(0,p.A)({},HYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QYp.isMDXComponent=!0;const $Yp={toc:[]},KYp="wrapper";function JYp(e){let{components:n,...t}=e;return(0,s.yg)(KYp,(0,p.A)({},$Yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}JYp.isMDXComponent=!0;const ZYp={toc:[]},eQp="wrapper";function nQp(e){let{components:n,...t}=e;return(0,s.yg)(eQp,(0,p.A)({},ZYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nQp.isMDXComponent=!0;const tQp={toc:[]},oQp="wrapper";function pQp(e){let{components:n,...t}=e;return(0,s.yg)(oQp,(0,p.A)({},tQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pQp.isMDXComponent=!0;const rQp={toc:[]},sQp="wrapper";function cQp(e){let{components:n,...t}=e;return(0,s.yg)(sQp,(0,p.A)({},rQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cQp.isMDXComponent=!0;const aQp={toc:[]},iQp="wrapper";function lQp(e){let{components:n,...t}=e;return(0,s.yg)(iQp,(0,p.A)({},aQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}lQp.isMDXComponent=!0;const uQp={toc:[]},mQp="wrapper";function yQp(e){let{components:n,...t}=e;return(0,s.yg)(mQp,(0,p.A)({},uQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}yQp.isMDXComponent=!0;const dQp={toc:[]},hQp="wrapper";function gQp(e){let{components:n,...t}=e;return(0,s.yg)(hQp,(0,p.A)({},dQp,t,{components:n,mdxType:"MDXLayout"}))}gQp.isMDXComponent=!0;const fQp={toc:[]},DQp="wrapper";function MQp(e){let{components:n,...t}=e;return(0,s.yg)(DQp,(0,p.A)({},fQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}MQp.isMDXComponent=!0;const XQp={toc:[]},_Qp="wrapper";function wQp(e){let{components:n,...t}=e;return(0,s.yg)(_Qp,(0,p.A)({},XQp,t,{components:n,mdxType:"MDXLayout"}))}wQp.isMDXComponent=!0;const TQp={toc:[]},CQp="wrapper";function xQp(e){let{components:n,...t}=e;return(0,s.yg)(CQp,(0,p.A)({},TQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}xQp.isMDXComponent=!0;const AQp={toc:[]},vQp="wrapper";function LQp(e){let{components:n,...t}=e;return(0,s.yg)(vQp,(0,p.A)({},AQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}LQp.isMDXComponent=!0;const bQp={toc:[]},NQp="wrapper";function kQp(e){let{components:n,...t}=e;return(0,s.yg)(NQp,(0,p.A)({},bQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}kQp.isMDXComponent=!0;const zQp={toc:[]},PQp="wrapper";function IQp(e){let{components:n,...t}=e;return(0,s.yg)(PQp,(0,p.A)({},zQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}IQp.isMDXComponent=!0;const RQp={toc:[]},WQp="wrapper";function SQp(e){let{components:n,...t}=e;return(0,s.yg)(WQp,(0,p.A)({},RQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}SQp.isMDXComponent=!0;const BQp={toc:[]},GQp="wrapper";function EQp(e){let{components:n,...t}=e;return(0,s.yg)(GQp,(0,p.A)({},BQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}EQp.isMDXComponent=!0;const OQp={toc:[]},UQp="wrapper";function FQp(e){let{components:n,...t}=e;return(0,s.yg)(UQp,(0,p.A)({},OQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FQp.isMDXComponent=!0;const VQp={toc:[]},qQp="wrapper";function jQp(e){let{components:n,...t}=e;return(0,s.yg)(qQp,(0,p.A)({},VQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}jQp.isMDXComponent=!0;const HQp={toc:[]},YQp="wrapper";function QQp(e){let{components:n,...t}=e;return(0,s.yg)(YQp,(0,p.A)({},HQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QQp.isMDXComponent=!0;const $Qp={toc:[]},KQp="wrapper";function JQp(e){let{components:n,...t}=e;return(0,s.yg)(KQp,(0,p.A)({},$Qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}JQp.isMDXComponent=!0;const ZQp={toc:[]},e$p="wrapper";function n$p(e){let{components:n,...t}=e;return(0,s.yg)(e$p,(0,p.A)({},ZQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}n$p.isMDXComponent=!0;const t$p={toc:[]},o$p="wrapper";function p$p(e){let{components:n,...t}=e;return(0,s.yg)(o$p,(0,p.A)({},t$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}p$p.isMDXComponent=!0;const r$p={toc:[]},s$p="wrapper";function c$p(e){let{components:n,...t}=e;return(0,s.yg)(s$p,(0,p.A)({},r$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}c$p.isMDXComponent=!0;const a$p={toc:[]},i$p="wrapper";function l$p(e){let{components:n,...t}=e;return(0,s.yg)(i$p,(0,p.A)({},a$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}l$p.isMDXComponent=!0;const u$p={toc:[]},m$p="wrapper";function y$p(e){let{components:n,...t}=e;return(0,s.yg)(m$p,(0,p.A)({},u$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}y$p.isMDXComponent=!0;const d$p={toc:[]},h$p="wrapper";function g$p(e){let{components:n,...t}=e;return(0,s.yg)(h$p,(0,p.A)({},d$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}g$p.isMDXComponent=!0;const f$p={toc:[]},D$p="wrapper";function M$p(e){let{components:n,...t}=e;return(0,s.yg)(D$p,(0,p.A)({},f$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}M$p.isMDXComponent=!0;const X$p={toc:[]},_$p="wrapper";function w$p(e){let{components:n,...t}=e;return(0,s.yg)(_$p,(0,p.A)({},X$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}w$p.isMDXComponent=!0;const T$p={toc:[]},C$p="wrapper";function x$p(e){let{components:n,...t}=e;return(0,s.yg)(C$p,(0,p.A)({},T$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}x$p.isMDXComponent=!0;const A$p={toc:[]},v$p="wrapper";function L$p(e){let{components:n,...t}=e;return(0,s.yg)(v$p,(0,p.A)({},A$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}L$p.isMDXComponent=!0;const b$p={toc:[]},N$p="wrapper";function k$p(e){let{components:n,...t}=e;return(0,s.yg)(N$p,(0,p.A)({},b$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}k$p.isMDXComponent=!0;const z$p={toc:[]},P$p="wrapper";function I$p(e){let{components:n,...t}=e;return(0,s.yg)(P$p,(0,p.A)({},z$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}I$p.isMDXComponent=!0;const R$p={toc:[]},W$p="wrapper";function S$p(e){let{components:n,...t}=e;return(0,s.yg)(W$p,(0,p.A)({},R$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}S$p.isMDXComponent=!0;const B$p={toc:[]},G$p="wrapper";function E$p(e){let{components:n,...t}=e;return(0,s.yg)(G$p,(0,p.A)({},B$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}E$p.isMDXComponent=!0;const O$p={toc:[]},U$p="wrapper";function F$p(e){let{components:n,...t}=e;return(0,s.yg)(U$p,(0,p.A)({},O$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}F$p.isMDXComponent=!0;const V$p={toc:[]},q$p="wrapper";function j$p(e){let{components:n,...t}=e;return(0,s.yg)(q$p,(0,p.A)({},V$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}j$p.isMDXComponent=!0;const H$p={toc:[]},Y$p="wrapper";function Q$p(e){let{components:n,...t}=e;return(0,s.yg)(Y$p,(0,p.A)({},H$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Q$p.isMDXComponent=!0;const $$p={toc:[]},K$p="wrapper";function J$p(e){let{components:n,...t}=e;return(0,s.yg)(K$p,(0,p.A)({},$$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}J$p.isMDXComponent=!0;const Z$p={toc:[]},eKp="wrapper";function nKp(e){let{components:n,...t}=e;return(0,s.yg)(eKp,(0,p.A)({},Z$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nKp.isMDXComponent=!0;const tKp={toc:[]},oKp="wrapper";function pKp(e){let{components:n,...t}=e;return(0,s.yg)(oKp,(0,p.A)({},tKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}pKp.isMDXComponent=!0;const rKp={toc:[]},sKp="wrapper";function cKp(e){let{components:n,...t}=e;return(0,s.yg)(sKp,(0,p.A)({},rKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}cKp.isMDXComponent=!0;const aKp={toc:[]},iKp="wrapper";function lKp(e){let{components:n,...t}=e;return(0,s.yg)(iKp,(0,p.A)({},aKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}lKp.isMDXComponent=!0;const uKp={toc:[]},mKp="wrapper";function yKp(e){let{components:n,...t}=e;return(0,s.yg)(mKp,(0,p.A)({},uKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yKp.isMDXComponent=!0;const dKp={toc:[]},hKp="wrapper";function gKp(e){let{components:n,...t}=e;return(0,s.yg)(hKp,(0,p.A)({},dKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}gKp.isMDXComponent=!0;const fKp={toc:[]},DKp="wrapper";function MKp(e){let{components:n,...t}=e;return(0,s.yg)(DKp,(0,p.A)({},fKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}MKp.isMDXComponent=!0;const XKp={toc:[]},_Kp="wrapper";function wKp(e){let{components:n,...t}=e;return(0,s.yg)(_Kp,(0,p.A)({},XKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}wKp.isMDXComponent=!0;const TKp={toc:[]},CKp="wrapper";function xKp(e){let{components:n,...t}=e;return(0,s.yg)(CKp,(0,p.A)({},TKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}xKp.isMDXComponent=!0;const AKp={toc:[]},vKp="wrapper";function LKp(e){let{components:n,...t}=e;return(0,s.yg)(vKp,(0,p.A)({},AKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}LKp.isMDXComponent=!0;const bKp={toc:[]},NKp="wrapper";function kKp(e){let{components:n,...t}=e;return(0,s.yg)(NKp,(0,p.A)({},bKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kKp.isMDXComponent=!0;const zKp={toc:[]},PKp="wrapper";function IKp(e){let{components:n,...t}=e;return(0,s.yg)(PKp,(0,p.A)({},zKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}IKp.isMDXComponent=!0;const RKp={toc:[]},WKp="wrapper";function SKp(e){let{components:n,...t}=e;return(0,s.yg)(WKp,(0,p.A)({},RKp,t,{components:n,mdxType:"MDXLayout"}))}SKp.isMDXComponent=!0;const BKp={toc:[]},GKp="wrapper";function EKp(e){let{components:n,...t}=e;return(0,s.yg)(GKp,(0,p.A)({},BKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}EKp.isMDXComponent=!0;const OKp={toc:[]},UKp="wrapper";function FKp(e){let{components:n,...t}=e;return(0,s.yg)(UKp,(0,p.A)({},OKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}FKp.isMDXComponent=!0;const VKp={toc:[]},qKp="wrapper";function jKp(e){let{components:n,...t}=e;return(0,s.yg)(qKp,(0,p.A)({},VKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}jKp.isMDXComponent=!0;const HKp={toc:[]},YKp="wrapper";function QKp(e){let{components:n,...t}=e;return(0,s.yg)(YKp,(0,p.A)({},HKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}QKp.isMDXComponent=!0;const $Kp={toc:[]},KKp="wrapper";function JKp(e){let{components:n,...t}=e;return(0,s.yg)(KKp,(0,p.A)({},$Kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}JKp.isMDXComponent=!0;const ZKp={toc:[]},eJp="wrapper";function nJp(e){let{components:n,...t}=e;return(0,s.yg)(eJp,(0,p.A)({},ZKp,t,{components:n,mdxType:"MDXLayout"}))}nJp.isMDXComponent=!0;const tJp={toc:[]},oJp="wrapper";function pJp(e){let{components:n,...t}=e;return(0,s.yg)(oJp,(0,p.A)({},tJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}pJp.isMDXComponent=!0;const rJp={toc:[]},sJp="wrapper";function cJp(e){let{components:n,...t}=e;return(0,s.yg)(sJp,(0,p.A)({},rJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}cJp.isMDXComponent=!0;const aJp={toc:[]},iJp="wrapper";function lJp(e){let{components:n,...t}=e;return(0,s.yg)(iJp,(0,p.A)({},aJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}lJp.isMDXComponent=!0;const uJp={toc:[]},mJp="wrapper";function yJp(e){let{components:n,...t}=e;return(0,s.yg)(mJp,(0,p.A)({},uJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yJp.isMDXComponent=!0;const dJp={toc:[]},hJp="wrapper";function gJp(e){let{components:n,...t}=e;return(0,s.yg)(hJp,(0,p.A)({},dJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}gJp.isMDXComponent=!0;const fJp={toc:[]},DJp="wrapper";function MJp(e){let{components:n,...t}=e;return(0,s.yg)(DJp,(0,p.A)({},fJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}MJp.isMDXComponent=!0;const XJp={toc:[]},_Jp="wrapper";function wJp(e){let{components:n,...t}=e;return(0,s.yg)(_Jp,(0,p.A)({},XJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}wJp.isMDXComponent=!0;const TJp={toc:[]},CJp="wrapper";function xJp(e){let{components:n,...t}=e;return(0,s.yg)(CJp,(0,p.A)({},TJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xJp.isMDXComponent=!0;const AJp={toc:[]},vJp="wrapper";function LJp(e){let{components:n,...t}=e;return(0,s.yg)(vJp,(0,p.A)({},AJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}LJp.isMDXComponent=!0;const bJp={toc:[]},NJp="wrapper";function kJp(e){let{components:n,...t}=e;return(0,s.yg)(NJp,(0,p.A)({},bJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kJp.isMDXComponent=!0;const zJp={toc:[]},PJp="wrapper";function IJp(e){let{components:n,...t}=e;return(0,s.yg)(PJp,(0,p.A)({},zJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}IJp.isMDXComponent=!0;const RJp={toc:[]},WJp="wrapper";function SJp(e){let{components:n,...t}=e;return(0,s.yg)(WJp,(0,p.A)({},RJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SJp.isMDXComponent=!0;const BJp={toc:[]},GJp="wrapper";function EJp(e){let{components:n,...t}=e;return(0,s.yg)(GJp,(0,p.A)({},BJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}EJp.isMDXComponent=!0;const OJp={toc:[]},UJp="wrapper";function FJp(e){let{components:n,...t}=e;return(0,s.yg)(UJp,(0,p.A)({},OJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FJp.isMDXComponent=!0;const VJp={toc:[]},qJp="wrapper";function jJp(e){let{components:n,...t}=e;return(0,s.yg)(qJp,(0,p.A)({},VJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}jJp.isMDXComponent=!0;const HJp={toc:[]},YJp="wrapper";function QJp(e){let{components:n,...t}=e;return(0,s.yg)(YJp,(0,p.A)({},HJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QJp.isMDXComponent=!0;const $Jp={toc:[]},KJp="wrapper";function JJp(e){let{components:n,...t}=e;return(0,s.yg)(KJp,(0,p.A)({},$Jp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}JJp.isMDXComponent=!0;const ZJp={toc:[]},eZp="wrapper";function nZp(e){let{components:n,...t}=e;return(0,s.yg)(eZp,(0,p.A)({},ZJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nZp.isMDXComponent=!0;const tZp={toc:[]},oZp="wrapper";function pZp(e){let{components:n,...t}=e;return(0,s.yg)(oZp,(0,p.A)({},tZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}pZp.isMDXComponent=!0;const rZp={toc:[]},sZp="wrapper";function cZp(e){let{components:n,...t}=e;return(0,s.yg)(sZp,(0,p.A)({},rZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cZp.isMDXComponent=!0;const aZp={toc:[]},iZp="wrapper";function lZp(e){let{components:n,...t}=e;return(0,s.yg)(iZp,(0,p.A)({},aZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lZp.isMDXComponent=!0;const uZp={toc:[]},mZp="wrapper";function yZp(e){let{components:n,...t}=e;return(0,s.yg)(mZp,(0,p.A)({},uZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yZp.isMDXComponent=!0;const dZp={toc:[]},hZp="wrapper";function gZp(e){let{components:n,...t}=e;return(0,s.yg)(hZp,(0,p.A)({},dZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gZp.isMDXComponent=!0;const fZp={toc:[]},DZp="wrapper";function MZp(e){let{components:n,...t}=e;return(0,s.yg)(DZp,(0,p.A)({},fZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}MZp.isMDXComponent=!0;const XZp={toc:[]},_Zp="wrapper";function wZp(e){let{components:n,...t}=e;return(0,s.yg)(_Zp,(0,p.A)({},XZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wZp.isMDXComponent=!0;const TZp={toc:[]},CZp="wrapper";function xZp(e){let{components:n,...t}=e;return(0,s.yg)(CZp,(0,p.A)({},TZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xZp.isMDXComponent=!0;const AZp={toc:[]},vZp="wrapper";function LZp(e){let{components:n,...t}=e;return(0,s.yg)(vZp,(0,p.A)({},AZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}LZp.isMDXComponent=!0;const bZp={toc:[]},NZp="wrapper";function kZp(e){let{components:n,...t}=e;return(0,s.yg)(NZp,(0,p.A)({},bZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kZp.isMDXComponent=!0;const zZp={toc:[]},PZp="wrapper";function IZp(e){let{components:n,...t}=e;return(0,s.yg)(PZp,(0,p.A)({},zZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IZp.isMDXComponent=!0;const RZp={toc:[]},WZp="wrapper";function SZp(e){let{components:n,...t}=e;return(0,s.yg)(WZp,(0,p.A)({},RZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SZp.isMDXComponent=!0;const BZp={toc:[]},GZp="wrapper";function EZp(e){let{components:n,...t}=e;return(0,s.yg)(GZp,(0,p.A)({},BZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}EZp.isMDXComponent=!0;const OZp={toc:[]},UZp="wrapper";function FZp(e){let{components:n,...t}=e;return(0,s.yg)(UZp,(0,p.A)({},OZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}FZp.isMDXComponent=!0;const VZp={toc:[]},qZp="wrapper";function jZp(e){let{components:n,...t}=e;return(0,s.yg)(qZp,(0,p.A)({},VZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}jZp.isMDXComponent=!0;const HZp={toc:[]},YZp="wrapper";function QZp(e){let{components:n,...t}=e;return(0,s.yg)(YZp,(0,p.A)({},HZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QZp.isMDXComponent=!0;const $Zp={toc:[]},KZp="wrapper";function JZp(e){let{components:n,...t}=e;return(0,s.yg)(KZp,(0,p.A)({},$Zp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}JZp.isMDXComponent=!0;const ZZp={toc:[]},e0p="wrapper";function n0p(e){let{components:n,...t}=e;return(0,s.yg)(e0p,(0,p.A)({},ZZp,t,{components:n,mdxType:"MDXLayout"}))}n0p.isMDXComponent=!0;const t0p={toc:[]},o0p="wrapper";function p0p(e){let{components:n,...t}=e;return(0,s.yg)(o0p,(0,p.A)({},t0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}p0p.isMDXComponent=!0;const r0p={toc:[]},s0p="wrapper";function c0p(e){let{components:n,...t}=e;return(0,s.yg)(s0p,(0,p.A)({},r0p,t,{components:n,mdxType:"MDXLayout"}))}c0p.isMDXComponent=!0;const a0p={toc:[]},i0p="wrapper";function l0p(e){let{components:n,...t}=e;return(0,s.yg)(i0p,(0,p.A)({},a0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}l0p.isMDXComponent=!0;const u0p={toc:[]},m0p="wrapper";function y0p(e){let{components:n,...t}=e;return(0,s.yg)(m0p,(0,p.A)({},u0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}y0p.isMDXComponent=!0;const d0p={toc:[]},h0p="wrapper";function g0p(e){let{components:n,...t}=e;return(0,s.yg)(h0p,(0,p.A)({},d0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}g0p.isMDXComponent=!0;const f0p={toc:[]},D0p="wrapper";function M0p(e){let{components:n,...t}=e;return(0,s.yg)(D0p,(0,p.A)({},f0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}M0p.isMDXComponent=!0;const X0p={toc:[]},_0p="wrapper";function w0p(e){let{components:n,...t}=e;return(0,s.yg)(_0p,(0,p.A)({},X0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w0p.isMDXComponent=!0;const T0p={toc:[]},C0p="wrapper";function x0p(e){let{components:n,...t}=e;return(0,s.yg)(C0p,(0,p.A)({},T0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}x0p.isMDXComponent=!0;const A0p={toc:[]},v0p="wrapper";function L0p(e){let{components:n,...t}=e;return(0,s.yg)(v0p,(0,p.A)({},A0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}L0p.isMDXComponent=!0;const b0p={toc:[]},N0p="wrapper";function k0p(e){let{components:n,...t}=e;return(0,s.yg)(N0p,(0,p.A)({},b0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}k0p.isMDXComponent=!0;const z0p={toc:[]},P0p="wrapper";function I0p(e){let{components:n,...t}=e;return(0,s.yg)(P0p,(0,p.A)({},z0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}I0p.isMDXComponent=!0;const R0p={toc:[]},W0p="wrapper";function S0p(e){let{components:n,...t}=e;return(0,s.yg)(W0p,(0,p.A)({},R0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}S0p.isMDXComponent=!0;const B0p={toc:[]},G0p="wrapper";function E0p(e){let{components:n,...t}=e;return(0,s.yg)(G0p,(0,p.A)({},B0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}E0p.isMDXComponent=!0;const O0p={toc:[]},U0p="wrapper";function F0p(e){let{components:n,...t}=e;return(0,s.yg)(U0p,(0,p.A)({},O0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}F0p.isMDXComponent=!0;const V0p={toc:[]},q0p="wrapper";function j0p(e){let{components:n,...t}=e;return(0,s.yg)(q0p,(0,p.A)({},V0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}j0p.isMDXComponent=!0;const H0p={toc:[]},Y0p="wrapper";function Q0p(e){let{components:n,...t}=e;return(0,s.yg)(Y0p,(0,p.A)({},H0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Q0p.isMDXComponent=!0;const $0p={toc:[]},K0p="wrapper";function J0p(e){let{components:n,...t}=e;return(0,s.yg)(K0p,(0,p.A)({},$0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}J0p.isMDXComponent=!0;const Z0p={toc:[]},e2p="wrapper";function n2p(e){let{components:n,...t}=e;return(0,s.yg)(e2p,(0,p.A)({},Z0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}n2p.isMDXComponent=!0;const t2p={toc:[]},o2p="wrapper";function p2p(e){let{components:n,...t}=e;return(0,s.yg)(o2p,(0,p.A)({},t2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}p2p.isMDXComponent=!0;const r2p={toc:[]},s2p="wrapper";function c2p(e){let{components:n,...t}=e;return(0,s.yg)(s2p,(0,p.A)({},r2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}c2p.isMDXComponent=!0;const a2p={toc:[]},i2p="wrapper";function l2p(e){let{components:n,...t}=e;return(0,s.yg)(i2p,(0,p.A)({},a2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}l2p.isMDXComponent=!0;const u2p={toc:[]},m2p="wrapper";function y2p(e){let{components:n,...t}=e;return(0,s.yg)(m2p,(0,p.A)({},u2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}y2p.isMDXComponent=!0;const d2p={toc:[]},h2p="wrapper";function g2p(e){let{components:n,...t}=e;return(0,s.yg)(h2p,(0,p.A)({},d2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}g2p.isMDXComponent=!0;const f2p={toc:[]},D2p="wrapper";function M2p(e){let{components:n,...t}=e;return(0,s.yg)(D2p,(0,p.A)({},f2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}M2p.isMDXComponent=!0;const X2p={toc:[]},_2p="wrapper";function w2p(e){let{components:n,...t}=e;return(0,s.yg)(_2p,(0,p.A)({},X2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}w2p.isMDXComponent=!0;const T2p={toc:[]},C2p="wrapper";function x2p(e){let{components:n,...t}=e;return(0,s.yg)(C2p,(0,p.A)({},T2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}x2p.isMDXComponent=!0;const A2p={toc:[]},v2p="wrapper";function L2p(e){let{components:n,...t}=e;return(0,s.yg)(v2p,(0,p.A)({},A2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}L2p.isMDXComponent=!0;const b2p={toc:[]},N2p="wrapper";function k2p(e){let{components:n,...t}=e;return(0,s.yg)(N2p,(0,p.A)({},b2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}k2p.isMDXComponent=!0;const z2p={toc:[]},P2p="wrapper";function I2p(e){let{components:n,...t}=e;return(0,s.yg)(P2p,(0,p.A)({},z2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}I2p.isMDXComponent=!0;const R2p={toc:[]},W2p="wrapper";function S2p(e){let{components:n,...t}=e;return(0,s.yg)(W2p,(0,p.A)({},R2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}S2p.isMDXComponent=!0;const B2p={toc:[]},G2p="wrapper";function E2p(e){let{components:n,...t}=e;return(0,s.yg)(G2p,(0,p.A)({},B2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}E2p.isMDXComponent=!0;const O2p={toc:[]},U2p="wrapper";function F2p(e){let{components:n,...t}=e;return(0,s.yg)(U2p,(0,p.A)({},O2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}F2p.isMDXComponent=!0;const V2p={toc:[]},q2p="wrapper";function j2p(e){let{components:n,...t}=e;return(0,s.yg)(q2p,(0,p.A)({},V2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}j2p.isMDXComponent=!0;const H2p={toc:[]},Y2p="wrapper";function Q2p(e){let{components:n,...t}=e;return(0,s.yg)(Y2p,(0,p.A)({},H2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Q2p.isMDXComponent=!0;const $2p={toc:[]},K2p="wrapper";function J2p(e){let{components:n,...t}=e;return(0,s.yg)(K2p,(0,p.A)({},$2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}J2p.isMDXComponent=!0;const Z2p={toc:[]},e4p="wrapper";function n4p(e){let{components:n,...t}=e;return(0,s.yg)(e4p,(0,p.A)({},Z2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}n4p.isMDXComponent=!0;const t4p={toc:[]},o4p="wrapper";function p4p(e){let{components:n,...t}=e;return(0,s.yg)(o4p,(0,p.A)({},t4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}p4p.isMDXComponent=!0;const r4p={toc:[]},s4p="wrapper";function c4p(e){let{components:n,...t}=e;return(0,s.yg)(s4p,(0,p.A)({},r4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}c4p.isMDXComponent=!0;const a4p={toc:[]},i4p="wrapper";function l4p(e){let{components:n,...t}=e;return(0,s.yg)(i4p,(0,p.A)({},a4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}l4p.isMDXComponent=!0;const u4p={toc:[]},m4p="wrapper";function y4p(e){let{components:n,...t}=e;return(0,s.yg)(m4p,(0,p.A)({},u4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The points of the line."))}y4p.isMDXComponent=!0;const d4p={toc:[]},h4p="wrapper";function g4p(e){let{components:n,...t}=e;return(0,s.yg)(h4p,(0,p.A)({},d4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the line's corners."))}g4p.isMDXComponent=!0;const f4p={toc:[]},D4p="wrapper";function M4p(e){let{components:n,...t}=e;return(0,s.yg)(D4p,(0,p.A)({},f4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}M4p.isMDXComponent=!0;const X4p={toc:[]},_4p="wrapper";function w4p(e){let{components:n,...t}=e;return(0,s.yg)(_4p,(0,p.A)({},X4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}w4p.isMDXComponent=!0;const T4p={toc:[]},C4p="wrapper";function x4p(e){let{components:n,...t}=e;return(0,s.yg)(C4p,(0,p.A)({},T4p,t,{components:n,mdxType:"MDXLayout"}))}x4p.isMDXComponent=!0;const A4p={toc:[]},v4p="wrapper";function L4p(e){let{components:n,...t}=e;return(0,s.yg)(v4p,(0,p.A)({},A4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}L4p.isMDXComponent=!0;const b4p={toc:[]},N4p="wrapper";function k4p(e){let{components:n,...t}=e;return(0,s.yg)(N4p,(0,p.A)({},b4p,t,{components:n,mdxType:"MDXLayout"}))}k4p.isMDXComponent=!0;const z4p={toc:[]},P4p="wrapper";function I4p(e){let{components:n,...t}=e;return(0,s.yg)(P4p,(0,p.A)({},z4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}I4p.isMDXComponent=!0;const R4p={toc:[]},W4p="wrapper";function S4p(e){let{components:n,...t}=e;return(0,s.yg)(W4p,(0,p.A)({},R4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}S4p.isMDXComponent=!0;const B4p={toc:[]},G4p="wrapper";function E4p(e){let{components:n,...t}=e;return(0,s.yg)(G4p,(0,p.A)({},B4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}E4p.isMDXComponent=!0;const O4p={toc:[]},U4p="wrapper";function F4p(e){let{components:n,...t}=e;return(0,s.yg)(U4p,(0,p.A)({},O4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}F4p.isMDXComponent=!0;const V4p={toc:[]},q4p="wrapper";function j4p(e){let{components:n,...t}=e;return(0,s.yg)(q4p,(0,p.A)({},V4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}j4p.isMDXComponent=!0;const H4p={toc:[]},Y4p="wrapper";function Q4p(e){let{components:n,...t}=e;return(0,s.yg)(Y4p,(0,p.A)({},H4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Q4p.isMDXComponent=!0;const $4p={toc:[]},K4p="wrapper";function J4p(e){let{components:n,...t}=e;return(0,s.yg)(K4p,(0,p.A)({},$4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}J4p.isMDXComponent=!0;const Z4p={toc:[]},e8p="wrapper";function n8p(e){let{components:n,...t}=e;return(0,s.yg)(e8p,(0,p.A)({},Z4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}n8p.isMDXComponent=!0;const t8p={toc:[]},o8p="wrapper";function p8p(e){let{components:n,...t}=e;return(0,s.yg)(o8p,(0,p.A)({},t8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}p8p.isMDXComponent=!0;const r8p={toc:[]},s8p="wrapper";function c8p(e){let{components:n,...t}=e;return(0,s.yg)(s8p,(0,p.A)({},r8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}c8p.isMDXComponent=!0;const a8p={toc:[]},i8p="wrapper";function l8p(e){let{components:n,...t}=e;return(0,s.yg)(i8p,(0,p.A)({},a8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}l8p.isMDXComponent=!0;const u8p={toc:[]},m8p="wrapper";function y8p(e){let{components:n,...t}=e;return(0,s.yg)(m8p,(0,p.A)({},u8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}y8p.isMDXComponent=!0;const d8p={toc:[]},h8p="wrapper";function g8p(e){let{components:n,...t}=e;return(0,s.yg)(h8p,(0,p.A)({},d8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}g8p.isMDXComponent=!0;const f8p={toc:[]},D8p="wrapper";function M8p(e){let{components:n,...t}=e;return(0,s.yg)(D8p,(0,p.A)({},f8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}M8p.isMDXComponent=!0;const X8p={toc:[]},_8p="wrapper";function w8p(e){let{components:n,...t}=e;return(0,s.yg)(_8p,(0,p.A)({},X8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}w8p.isMDXComponent=!0;const T8p={toc:[]},C8p="wrapper";function x8p(e){let{components:n,...t}=e;return(0,s.yg)(C8p,(0,p.A)({},T8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}x8p.isMDXComponent=!0;const A8p={toc:[]},v8p="wrapper";function L8p(e){let{components:n,...t}=e;return(0,s.yg)(v8p,(0,p.A)({},A8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}L8p.isMDXComponent=!0;const b8p={toc:[]},N8p="wrapper";function k8p(e){let{components:n,...t}=e;return(0,s.yg)(N8p,(0,p.A)({},b8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}k8p.isMDXComponent=!0;const z8p={toc:[]},P8p="wrapper";function I8p(e){let{components:n,...t}=e;return(0,s.yg)(P8p,(0,p.A)({},z8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}I8p.isMDXComponent=!0;const R8p={toc:[]},W8p="wrapper";function S8p(e){let{components:n,...t}=e;return(0,s.yg)(W8p,(0,p.A)({},R8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}S8p.isMDXComponent=!0;const B8p={toc:[]},G8p="wrapper";function E8p(e){let{components:n,...t}=e;return(0,s.yg)(G8p,(0,p.A)({},B8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}E8p.isMDXComponent=!0;const O8p={toc:[]},U8p="wrapper";function F8p(e){let{components:n,...t}=e;return(0,s.yg)(U8p,(0,p.A)({},O8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}F8p.isMDXComponent=!0;const V8p={toc:[]},q8p="wrapper";function j8p(e){let{components:n,...t}=e;return(0,s.yg)(q8p,(0,p.A)({},V8p,t,{components:n,mdxType:"MDXLayout"}))}j8p.isMDXComponent=!0;const H8p={toc:[]},Y8p="wrapper";function Q8p(e){let{components:n,...t}=e;return(0,s.yg)(Y8p,(0,p.A)({},H8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Q8p.isMDXComponent=!0;const $8p={toc:[]},K8p="wrapper";function J8p(e){let{components:n,...t}=e;return(0,s.yg)(K8p,(0,p.A)({},$8p,t,{components:n,mdxType:"MDXLayout"}))}J8p.isMDXComponent=!0;const Z8p={toc:[]},e3p="wrapper";function n3p(e){let{components:n,...t}=e;return(0,s.yg)(e3p,(0,p.A)({},Z8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}n3p.isMDXComponent=!0;const t3p={toc:[]},o3p="wrapper";function p3p(e){let{components:n,...t}=e;return(0,s.yg)(o3p,(0,p.A)({},t3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}p3p.isMDXComponent=!0;const r3p={toc:[]},s3p="wrapper";function c3p(e){let{components:n,...t}=e;return(0,s.yg)(s3p,(0,p.A)({},r3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}c3p.isMDXComponent=!0;const a3p={toc:[]},i3p="wrapper";function l3p(e){let{components:n,...t}=e;return(0,s.yg)(i3p,(0,p.A)({},a3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}l3p.isMDXComponent=!0;const u3p={toc:[]},m3p="wrapper";function y3p(e){let{components:n,...t}=e;return(0,s.yg)(m3p,(0,p.A)({},u3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}y3p.isMDXComponent=!0;const d3p={toc:[]},h3p="wrapper";function g3p(e){let{components:n,...t}=e;return(0,s.yg)(h3p,(0,p.A)({},d3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}g3p.isMDXComponent=!0;const f3p={toc:[]},D3p="wrapper";function M3p(e){let{components:n,...t}=e;return(0,s.yg)(D3p,(0,p.A)({},f3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}M3p.isMDXComponent=!0;const X3p={toc:[]},_3p="wrapper";function w3p(e){let{components:n,...t}=e;return(0,s.yg)(_3p,(0,p.A)({},X3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}w3p.isMDXComponent=!0;const T3p={toc:[]},C3p="wrapper";function x3p(e){let{components:n,...t}=e;return(0,s.yg)(C3p,(0,p.A)({},T3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}x3p.isMDXComponent=!0;const A3p={toc:[]},v3p="wrapper";function L3p(e){let{components:n,...t}=e;return(0,s.yg)(v3p,(0,p.A)({},A3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}L3p.isMDXComponent=!0;const b3p={toc:[]},N3p="wrapper";function k3p(e){let{components:n,...t}=e;return(0,s.yg)(N3p,(0,p.A)({},b3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}k3p.isMDXComponent=!0;const z3p={toc:[]},P3p="wrapper";function I3p(e){let{components:n,...t}=e;return(0,s.yg)(P3p,(0,p.A)({},z3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}I3p.isMDXComponent=!0;const R3p={toc:[]},W3p="wrapper";function S3p(e){let{components:n,...t}=e;return(0,s.yg)(W3p,(0,p.A)({},R3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}S3p.isMDXComponent=!0;const B3p={toc:[]},G3p="wrapper";function E3p(e){let{components:n,...t}=e;return(0,s.yg)(G3p,(0,p.A)({},B3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}E3p.isMDXComponent=!0;const O3p={toc:[]},U3p="wrapper";function F3p(e){let{components:n,...t}=e;return(0,s.yg)(U3p,(0,p.A)({},O3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}F3p.isMDXComponent=!0;const V3p={toc:[]},q3p="wrapper";function j3p(e){let{components:n,...t}=e;return(0,s.yg)(q3p,(0,p.A)({},V3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}j3p.isMDXComponent=!0;const H3p={toc:[]},Y3p="wrapper";function Q3p(e){let{components:n,...t}=e;return(0,s.yg)(Y3p,(0,p.A)({},H3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Q3p.isMDXComponent=!0;const $3p={toc:[]},K3p="wrapper";function J3p(e){let{components:n,...t}=e;return(0,s.yg)(K3p,(0,p.A)({},$3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}J3p.isMDXComponent=!0;const Z3p={toc:[]},e1p="wrapper";function n1p(e){let{components:n,...t}=e;return(0,s.yg)(e1p,(0,p.A)({},Z3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}n1p.isMDXComponent=!0;const t1p={toc:[]},o1p="wrapper";function p1p(e){let{components:n,...t}=e;return(0,s.yg)(o1p,(0,p.A)({},t1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}p1p.isMDXComponent=!0;const r1p={toc:[]},s1p="wrapper";function c1p(e){let{components:n,...t}=e;return(0,s.yg)(s1p,(0,p.A)({},r1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}c1p.isMDXComponent=!0;const a1p={toc:[]},i1p="wrapper";function l1p(e){let{components:n,...t}=e;return(0,s.yg)(i1p,(0,p.A)({},a1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}l1p.isMDXComponent=!0;const u1p={toc:[]},m1p="wrapper";function y1p(e){let{components:n,...t}=e;return(0,s.yg)(m1p,(0,p.A)({},u1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}y1p.isMDXComponent=!0;const d1p={toc:[]},h1p="wrapper";function g1p(e){let{components:n,...t}=e;return(0,s.yg)(h1p,(0,p.A)({},d1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}g1p.isMDXComponent=!0;const f1p={toc:[]},D1p="wrapper";function M1p(e){let{components:n,...t}=e;return(0,s.yg)(D1p,(0,p.A)({},f1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}M1p.isMDXComponent=!0;const X1p={toc:[]},_1p="wrapper";function w1p(e){let{components:n,...t}=e;return(0,s.yg)(_1p,(0,p.A)({},X1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}w1p.isMDXComponent=!0;const T1p={toc:[]},C1p="wrapper";function x1p(e){let{components:n,...t}=e;return(0,s.yg)(C1p,(0,p.A)({},T1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}x1p.isMDXComponent=!0;const A1p={toc:[]},v1p="wrapper";function L1p(e){let{components:n,...t}=e;return(0,s.yg)(v1p,(0,p.A)({},A1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}L1p.isMDXComponent=!0;const b1p={toc:[]},N1p="wrapper";function k1p(e){let{components:n,...t}=e;return(0,s.yg)(N1p,(0,p.A)({},b1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}k1p.isMDXComponent=!0;const z1p={toc:[]},P1p="wrapper";function I1p(e){let{components:n,...t}=e;return(0,s.yg)(P1p,(0,p.A)({},z1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}I1p.isMDXComponent=!0;const R1p={toc:[]},W1p="wrapper";function S1p(e){let{components:n,...t}=e;return(0,s.yg)(W1p,(0,p.A)({},R1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}S1p.isMDXComponent=!0;const B1p={toc:[]},G1p="wrapper";function E1p(e){let{components:n,...t}=e;return(0,s.yg)(G1p,(0,p.A)({},B1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}E1p.isMDXComponent=!0;const O1p={toc:[]},U1p="wrapper";function F1p(e){let{components:n,...t}=e;return(0,s.yg)(U1p,(0,p.A)({},O1p,t,{components:n,mdxType:"MDXLayout"}))}F1p.isMDXComponent=!0;const V1p={toc:[]},q1p="wrapper";function j1p(e){let{components:n,...t}=e;return(0,s.yg)(q1p,(0,p.A)({},V1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}j1p.isMDXComponent=!0;const H1p={toc:[]},Y1p="wrapper";function Q1p(e){let{components:n,...t}=e;return(0,s.yg)(Y1p,(0,p.A)({},H1p,t,{components:n,mdxType:"MDXLayout"}))}Q1p.isMDXComponent=!0;const $1p={toc:[]},K1p="wrapper";function J1p(e){let{components:n,...t}=e;return(0,s.yg)(K1p,(0,p.A)({},$1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}J1p.isMDXComponent=!0;const Z1p={toc:[]},e6p="wrapper";function n6p(e){let{components:n,...t}=e;return(0,s.yg)(e6p,(0,p.A)({},Z1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}n6p.isMDXComponent=!0;const t6p={toc:[]},o6p="wrapper";function p6p(e){let{components:n,...t}=e;return(0,s.yg)(o6p,(0,p.A)({},t6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}p6p.isMDXComponent=!0;const r6p={toc:[]},s6p="wrapper";function c6p(e){let{components:n,...t}=e;return(0,s.yg)(s6p,(0,p.A)({},r6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}c6p.isMDXComponent=!0;const a6p={toc:[]},i6p="wrapper";function l6p(e){let{components:n,...t}=e;return(0,s.yg)(i6p,(0,p.A)({},a6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}l6p.isMDXComponent=!0;const u6p={toc:[]},m6p="wrapper";function y6p(e){let{components:n,...t}=e;return(0,s.yg)(m6p,(0,p.A)({},u6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}y6p.isMDXComponent=!0;const d6p={toc:[]},h6p="wrapper";function g6p(e){let{components:n,...t}=e;return(0,s.yg)(h6p,(0,p.A)({},d6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}g6p.isMDXComponent=!0;const f6p={toc:[]},D6p="wrapper";function M6p(e){let{components:n,...t}=e;return(0,s.yg)(D6p,(0,p.A)({},f6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}M6p.isMDXComponent=!0;const X6p={toc:[]},_6p="wrapper";function w6p(e){let{components:n,...t}=e;return(0,s.yg)(_6p,(0,p.A)({},X6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w6p.isMDXComponent=!0;const T6p={toc:[]},C6p="wrapper";function x6p(e){let{components:n,...t}=e;return(0,s.yg)(C6p,(0,p.A)({},T6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}x6p.isMDXComponent=!0;const A6p={toc:[]},v6p="wrapper";function L6p(e){let{components:n,...t}=e;return(0,s.yg)(v6p,(0,p.A)({},A6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}L6p.isMDXComponent=!0;const b6p={toc:[]},N6p="wrapper";function k6p(e){let{components:n,...t}=e;return(0,s.yg)(N6p,(0,p.A)({},b6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}k6p.isMDXComponent=!0;const z6p={toc:[]},P6p="wrapper";function I6p(e){let{components:n,...t}=e;return(0,s.yg)(P6p,(0,p.A)({},z6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}I6p.isMDXComponent=!0;const R6p={toc:[]},W6p="wrapper";function S6p(e){let{components:n,...t}=e;return(0,s.yg)(W6p,(0,p.A)({},R6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}S6p.isMDXComponent=!0;const B6p={toc:[]},G6p="wrapper";function E6p(e){let{components:n,...t}=e;return(0,s.yg)(G6p,(0,p.A)({},B6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}E6p.isMDXComponent=!0;const O6p={toc:[]},U6p="wrapper";function F6p(e){let{components:n,...t}=e;return(0,s.yg)(U6p,(0,p.A)({},O6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}F6p.isMDXComponent=!0;const V6p={toc:[]},q6p="wrapper";function j6p(e){let{components:n,...t}=e;return(0,s.yg)(q6p,(0,p.A)({},V6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}j6p.isMDXComponent=!0;const H6p={toc:[]},Y6p="wrapper";function Q6p(e){let{components:n,...t}=e;return(0,s.yg)(Y6p,(0,p.A)({},H6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Q6p.isMDXComponent=!0;const $6p={toc:[]},K6p="wrapper";function J6p(e){let{components:n,...t}=e;return(0,s.yg)(K6p,(0,p.A)({},$6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}J6p.isMDXComponent=!0;const Z6p={toc:[]},e5p="wrapper";function n5p(e){let{components:n,...t}=e;return(0,s.yg)(e5p,(0,p.A)({},Z6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}n5p.isMDXComponent=!0;const t5p={toc:[]},o5p="wrapper";function p5p(e){let{components:n,...t}=e;return(0,s.yg)(o5p,(0,p.A)({},t5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}p5p.isMDXComponent=!0;const r5p={toc:[]},s5p="wrapper";function c5p(e){let{components:n,...t}=e;return(0,s.yg)(s5p,(0,p.A)({},r5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}c5p.isMDXComponent=!0;const a5p={toc:[]},i5p="wrapper";function l5p(e){let{components:n,...t}=e;return(0,s.yg)(i5p,(0,p.A)({},a5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}l5p.isMDXComponent=!0;const u5p={toc:[]},m5p="wrapper";function y5p(e){let{components:n,...t}=e;return(0,s.yg)(m5p,(0,p.A)({},u5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}y5p.isMDXComponent=!0;const d5p={toc:[]},h5p="wrapper";function g5p(e){let{components:n,...t}=e;return(0,s.yg)(h5p,(0,p.A)({},d5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}g5p.isMDXComponent=!0;const f5p={toc:[]},D5p="wrapper";function M5p(e){let{components:n,...t}=e;return(0,s.yg)(D5p,(0,p.A)({},f5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}M5p.isMDXComponent=!0;const X5p={toc:[]},_5p="wrapper";function w5p(e){let{components:n,...t}=e;return(0,s.yg)(_5p,(0,p.A)({},X5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}w5p.isMDXComponent=!0;const T5p={toc:[]},C5p="wrapper";function x5p(e){let{components:n,...t}=e;return(0,s.yg)(C5p,(0,p.A)({},T5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}x5p.isMDXComponent=!0;const A5p={toc:[]},v5p="wrapper";function L5p(e){let{components:n,...t}=e;return(0,s.yg)(v5p,(0,p.A)({},A5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}L5p.isMDXComponent=!0;const b5p={toc:[]},N5p="wrapper";function k5p(e){let{components:n,...t}=e;return(0,s.yg)(N5p,(0,p.A)({},b5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}k5p.isMDXComponent=!0;const z5p={toc:[]},P5p="wrapper";function I5p(e){let{components:n,...t}=e;return(0,s.yg)(P5p,(0,p.A)({},z5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}I5p.isMDXComponent=!0;const R5p={toc:[]},W5p="wrapper";function S5p(e){let{components:n,...t}=e;return(0,s.yg)(W5p,(0,p.A)({},R5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}S5p.isMDXComponent=!0;const B5p={toc:[]},G5p="wrapper";function E5p(e){let{components:n,...t}=e;return(0,s.yg)(G5p,(0,p.A)({},B5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}E5p.isMDXComponent=!0;const O5p={toc:[]},U5p="wrapper";function F5p(e){let{components:n,...t}=e;return(0,s.yg)(U5p,(0,p.A)({},O5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}F5p.isMDXComponent=!0;const V5p={toc:[]},q5p="wrapper";function j5p(e){let{components:n,...t}=e;return(0,s.yg)(q5p,(0,p.A)({},V5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}j5p.isMDXComponent=!0;const H5p={toc:[]},Y5p="wrapper";function Q5p(e){let{components:n,...t}=e;return(0,s.yg)(Y5p,(0,p.A)({},H5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Q5p.isMDXComponent=!0;const $5p={toc:[]},K5p="wrapper";function J5p(e){let{components:n,...t}=e;return(0,s.yg)(K5p,(0,p.A)({},$5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}J5p.isMDXComponent=!0;const Z5p={toc:[]},e7p="wrapper";function n7p(e){let{components:n,...t}=e;return(0,s.yg)(e7p,(0,p.A)({},Z5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}n7p.isMDXComponent=!0;const t7p={toc:[]},o7p="wrapper";function p7p(e){let{components:n,...t}=e;return(0,s.yg)(o7p,(0,p.A)({},t7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}p7p.isMDXComponent=!0;const r7p={toc:[]},s7p="wrapper";function c7p(e){let{components:n,...t}=e;return(0,s.yg)(s7p,(0,p.A)({},r7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}c7p.isMDXComponent=!0;const a7p={toc:[]},i7p="wrapper";function l7p(e){let{components:n,...t}=e;return(0,s.yg)(i7p,(0,p.A)({},a7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}l7p.isMDXComponent=!0;const u7p={toc:[]},m7p="wrapper";function y7p(e){let{components:n,...t}=e;return(0,s.yg)(m7p,(0,p.A)({},u7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}y7p.isMDXComponent=!0;const d7p={toc:[]},h7p="wrapper";function g7p(e){let{components:n,...t}=e;return(0,s.yg)(h7p,(0,p.A)({},d7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the polygon's corners."))}g7p.isMDXComponent=!0;const f7p={toc:[]},D7p="wrapper";function M7p(e){let{components:n,...t}=e;return(0,s.yg)(D7p,(0,p.A)({},f7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}M7p.isMDXComponent=!0;const X7p={toc:[]},_7p="wrapper";function w7p(e){let{components:n,...t}=e;return(0,s.yg)(_7p,(0,p.A)({},X7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}w7p.isMDXComponent=!0;const T7p={toc:[]},C7p="wrapper";function x7p(e){let{components:n,...t}=e;return(0,s.yg)(C7p,(0,p.A)({},T7p,t,{components:n,mdxType:"MDXLayout"}))}x7p.isMDXComponent=!0;const A7p={toc:[]},v7p="wrapper";function L7p(e){let{components:n,...t}=e;return(0,s.yg)(v7p,(0,p.A)({},A7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"For example, a value of 6 creates a hexagon."))}L7p.isMDXComponent=!0;const b7p={toc:[]},N7p="wrapper";function k7p(e){let{components:n,...t}=e;return(0,s.yg)(N7p,(0,p.A)({},b7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of sides of the polygon."))}k7p.isMDXComponent=!0;const z7p={toc:[]},P7p="wrapper";function I7p(e){let{components:n,...t}=e;return(0,s.yg)(P7p,(0,p.A)({},z7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}I7p.isMDXComponent=!0;const R7p={toc:[]},W7p="wrapper";function S7p(e){let{components:n,...t}=e;return(0,s.yg)(W7p,(0,p.A)({},R7p,t,{components:n,mdxType:"MDXLayout"}))}S7p.isMDXComponent=!0;const B7p={toc:[]},G7p="wrapper";function E7p(e){let{components:n,...t}=e;return(0,s.yg)(G7p,(0,p.A)({},B7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}E7p.isMDXComponent=!0;const O7p={toc:[]},U7p="wrapper";function F7p(e){let{components:n,...t}=e;return(0,s.yg)(U7p,(0,p.A)({},O7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}F7p.isMDXComponent=!0;const V7p={toc:[]},q7p="wrapper";function j7p(e){let{components:n,...t}=e;return(0,s.yg)(q7p,(0,p.A)({},V7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}j7p.isMDXComponent=!0;const H7p={toc:[]},Y7p="wrapper";function Q7p(e){let{components:n,...t}=e;return(0,s.yg)(Y7p,(0,p.A)({},H7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Q7p.isMDXComponent=!0;const $7p={toc:[]},K7p="wrapper";function J7p(e){let{components:n,...t}=e;return(0,s.yg)(K7p,(0,p.A)({},$7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}J7p.isMDXComponent=!0;const Z7p={toc:[]},e9p="wrapper";function n9p(e){let{components:n,...t}=e;return(0,s.yg)(e9p,(0,p.A)({},Z7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}n9p.isMDXComponent=!0;const t9p={toc:[]},o9p="wrapper";function p9p(e){let{components:n,...t}=e;return(0,s.yg)(o9p,(0,p.A)({},t9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}p9p.isMDXComponent=!0;const r9p={toc:[]},s9p="wrapper";function c9p(e){let{components:n,...t}=e;return(0,s.yg)(s9p,(0,p.A)({},r9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}c9p.isMDXComponent=!0;const a9p={toc:[]},i9p="wrapper";function l9p(e){let{components:n,...t}=e;return(0,s.yg)(i9p,(0,p.A)({},a9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}l9p.isMDXComponent=!0;const u9p={toc:[]},m9p="wrapper";function y9p(e){let{components:n,...t}=e;return(0,s.yg)(m9p,(0,p.A)({},u9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}y9p.isMDXComponent=!0;const d9p={toc:[]},h9p="wrapper";function g9p(e){let{components:n,...t}=e;return(0,s.yg)(h9p,(0,p.A)({},d9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}g9p.isMDXComponent=!0;const f9p={toc:[]},D9p="wrapper";function M9p(e){let{components:n,...t}=e;return(0,s.yg)(D9p,(0,p.A)({},f9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}M9p.isMDXComponent=!0;const X9p={toc:[]},_9p="wrapper";function w9p(e){let{components:n,...t}=e;return(0,s.yg)(_9p,(0,p.A)({},X9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}w9p.isMDXComponent=!0;const T9p={toc:[]},C9p="wrapper";function x9p(e){let{components:n,...t}=e;return(0,s.yg)(C9p,(0,p.A)({},T9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}x9p.isMDXComponent=!0;const A9p={toc:[]},v9p="wrapper";function L9p(e){let{components:n,...t}=e;return(0,s.yg)(v9p,(0,p.A)({},A9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}L9p.isMDXComponent=!0;const b9p={toc:[]},N9p="wrapper";function k9p(e){let{components:n,...t}=e;return(0,s.yg)(N9p,(0,p.A)({},b9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}k9p.isMDXComponent=!0;const z9p={toc:[]},P9p="wrapper";function I9p(e){let{components:n,...t}=e;return(0,s.yg)(P9p,(0,p.A)({},z9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}I9p.isMDXComponent=!0;const R9p={toc:[]},W9p="wrapper";function S9p(e){let{components:n,...t}=e;return(0,s.yg)(W9p,(0,p.A)({},R9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}S9p.isMDXComponent=!0;const B9p={toc:[]},G9p="wrapper";function E9p(e){let{components:n,...t}=e;return(0,s.yg)(G9p,(0,p.A)({},B9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}E9p.isMDXComponent=!0;const O9p={toc:[]},U9p="wrapper";function F9p(e){let{components:n,...t}=e;return(0,s.yg)(U9p,(0,p.A)({},O9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}F9p.isMDXComponent=!0;const V9p={toc:[]},q9p="wrapper";function j9p(e){let{components:n,...t}=e;return(0,s.yg)(q9p,(0,p.A)({},V9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}j9p.isMDXComponent=!0;const H9p={toc:[]},Y9p="wrapper";function Q9p(e){let{components:n,...t}=e;return(0,s.yg)(Y9p,(0,p.A)({},H9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Q9p.isMDXComponent=!0;const $9p={toc:[]},K9p="wrapper";function J9p(e){let{components:n,...t}=e;return(0,s.yg)(K9p,(0,p.A)({},$9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}J9p.isMDXComponent=!0;const Z9p={toc:[]},eer="wrapper";function ner(e){let{components:n,...t}=e;return(0,s.yg)(eer,(0,p.A)({},Z9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ner.isMDXComponent=!0;const ter={toc:[]},oer="wrapper";function per(e){let{components:n,...t}=e;return(0,s.yg)(oer,(0,p.A)({},ter,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}per.isMDXComponent=!0;const rer={toc:[]},ser="wrapper";function cer(e){let{components:n,...t}=e;return(0,s.yg)(ser,(0,p.A)({},rer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cer.isMDXComponent=!0;const aer={toc:[]},ier="wrapper";function ler(e){let{components:n,...t}=e;return(0,s.yg)(ier,(0,p.A)({},aer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ler.isMDXComponent=!0;const uer={toc:[]},mer="wrapper";function yer(e){let{components:n,...t}=e;return(0,s.yg)(mer,(0,p.A)({},uer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yer.isMDXComponent=!0;const der={toc:[]},her="wrapper";function ger(e){let{components:n,...t}=e;return(0,s.yg)(her,(0,p.A)({},der,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ger.isMDXComponent=!0;const fer={toc:[]},Der="wrapper";function Mer(e){let{components:n,...t}=e;return(0,s.yg)(Der,(0,p.A)({},fer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Mer.isMDXComponent=!0;const Xer={toc:[]},_er="wrapper";function wer(e){let{components:n,...t}=e;return(0,s.yg)(_er,(0,p.A)({},Xer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}wer.isMDXComponent=!0;const Ter={toc:[]},Cer="wrapper";function xer(e){let{components:n,...t}=e;return(0,s.yg)(Cer,(0,p.A)({},Ter,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}xer.isMDXComponent=!0;const Aer={toc:[]},ver="wrapper";function Ler(e){let{components:n,...t}=e;return(0,s.yg)(ver,(0,p.A)({},Aer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ler.isMDXComponent=!0;const ber={toc:[]},Ner="wrapper";function ker(e){let{components:n,...t}=e;return(0,s.yg)(Ner,(0,p.A)({},ber,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}ker.isMDXComponent=!0;const zer={toc:[]},Per="wrapper";function Ier(e){let{components:n,...t}=e;return(0,s.yg)(Per,(0,p.A)({},zer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ier.isMDXComponent=!0;const Rer={toc:[]},Wer="wrapper";function Ser(e){let{components:n,...t}=e;return(0,s.yg)(Wer,(0,p.A)({},Rer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Ser.isMDXComponent=!0;const Ber={toc:[]},Ger="wrapper";function Eer(e){let{components:n,...t}=e;return(0,s.yg)(Ger,(0,p.A)({},Ber,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Eer.isMDXComponent=!0;const Oer={toc:[]},Uer="wrapper";function Fer(e){let{components:n,...t}=e;return(0,s.yg)(Uer,(0,p.A)({},Oer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Fer.isMDXComponent=!0;const Ver={toc:[]},qer="wrapper";function jer(e){let{components:n,...t}=e;return(0,s.yg)(qer,(0,p.A)({},Ver,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jer.isMDXComponent=!0;const Her={toc:[]},Yer="wrapper";function Qer(e){let{components:n,...t}=e;return(0,s.yg)(Yer,(0,p.A)({},Her,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Qer.isMDXComponent=!0;const $er={toc:[]},Ker="wrapper";function Jer(e){let{components:n,...t}=e;return(0,s.yg)(Ker,(0,p.A)({},$er,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Jer.isMDXComponent=!0;const Zer={toc:[]},enr="wrapper";function nnr(e){let{components:n,...t}=e;return(0,s.yg)(enr,(0,p.A)({},Zer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}nnr.isMDXComponent=!0;const tnr={toc:[]},onr="wrapper";function pnr(e){let{components:n,...t}=e;return(0,s.yg)(onr,(0,p.A)({},tnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pnr.isMDXComponent=!0;const rnr={toc:[]},snr="wrapper";function cnr(e){let{components:n,...t}=e;return(0,s.yg)(snr,(0,p.A)({},rnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}cnr.isMDXComponent=!0;const anr={toc:[]},inr="wrapper";function lnr(e){let{components:n,...t}=e;return(0,s.yg)(inr,(0,p.A)({},anr,t,{components:n,mdxType:"MDXLayout"}))}lnr.isMDXComponent=!0;const unr={toc:[]},mnr="wrapper";function ynr(e){let{components:n,...t}=e;return(0,s.yg)(mnr,(0,p.A)({},unr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}ynr.isMDXComponent=!0;const dnr={toc:[]},hnr="wrapper";function gnr(e){let{components:n,...t}=e;return(0,s.yg)(hnr,(0,p.A)({},dnr,t,{components:n,mdxType:"MDXLayout"}))}gnr.isMDXComponent=!0;const fnr={toc:[]},Dnr="wrapper";function Mnr(e){let{components:n,...t}=e;return(0,s.yg)(Dnr,(0,p.A)({},fnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Mnr.isMDXComponent=!0;const Xnr={toc:[]},_nr="wrapper";function wnr(e){let{components:n,...t}=e;return(0,s.yg)(_nr,(0,p.A)({},Xnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}wnr.isMDXComponent=!0;const Tnr={toc:[]},Cnr="wrapper";function xnr(e){let{components:n,...t}=e;return(0,s.yg)(Cnr,(0,p.A)({},Tnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xnr.isMDXComponent=!0;const Anr={toc:[]},vnr="wrapper";function Lnr(e){let{components:n,...t}=e;return(0,s.yg)(vnr,(0,p.A)({},Anr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Lnr.isMDXComponent=!0;const bnr={toc:[]},Nnr="wrapper";function knr(e){let{components:n,...t}=e;return(0,s.yg)(Nnr,(0,p.A)({},bnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}knr.isMDXComponent=!0;const znr={toc:[]},Pnr="wrapper";function Inr(e){let{components:n,...t}=e;return(0,s.yg)(Pnr,(0,p.A)({},znr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Inr.isMDXComponent=!0;const Rnr={toc:[]},Wnr="wrapper";function Snr(e){let{components:n,...t}=e;return(0,s.yg)(Wnr,(0,p.A)({},Rnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Snr.isMDXComponent=!0;const Bnr={toc:[]},Gnr="wrapper";function Enr(e){let{components:n,...t}=e;return(0,s.yg)(Gnr,(0,p.A)({},Bnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Enr.isMDXComponent=!0;const Onr={toc:[]},Unr="wrapper";function Fnr(e){let{components:n,...t}=e;return(0,s.yg)(Unr,(0,p.A)({},Onr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Fnr.isMDXComponent=!0;const Vnr={toc:[]},qnr="wrapper";function jnr(e){let{components:n,...t}=e;return(0,s.yg)(qnr,(0,p.A)({},Vnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}jnr.isMDXComponent=!0;const Hnr={toc:[]},Ynr="wrapper";function Qnr(e){let{components:n,...t}=e;return(0,s.yg)(Ynr,(0,p.A)({},Hnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Qnr.isMDXComponent=!0;const $nr={toc:[]},Knr="wrapper";function Jnr(e){let{components:n,...t}=e;return(0,s.yg)(Knr,(0,p.A)({},$nr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Jnr.isMDXComponent=!0;const Znr={toc:[]},etr="wrapper";function ntr(e){let{components:n,...t}=e;return(0,s.yg)(etr,(0,p.A)({},Znr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}ntr.isMDXComponent=!0;const ttr={toc:[]},otr="wrapper";function ptr(e){let{components:n,...t}=e;return(0,s.yg)(otr,(0,p.A)({},ttr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ptr.isMDXComponent=!0;const rtr={toc:[]},str="wrapper";function ctr(e){let{components:n,...t}=e;return(0,s.yg)(str,(0,p.A)({},rtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ctr.isMDXComponent=!0;const atr={toc:[]},itr="wrapper";function ltr(e){let{components:n,...t}=e;return(0,s.yg)(itr,(0,p.A)({},atr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}ltr.isMDXComponent=!0;const utr={toc:[]},mtr="wrapper";function ytr(e){let{components:n,...t}=e;return(0,s.yg)(mtr,(0,p.A)({},utr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ytr.isMDXComponent=!0;const dtr={toc:[]},htr="wrapper";function gtr(e){let{components:n,...t}=e;return(0,s.yg)(htr,(0,p.A)({},dtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}gtr.isMDXComponent=!0;const ftr={toc:[]},Dtr="wrapper";function Mtr(e){let{components:n,...t}=e;return(0,s.yg)(Dtr,(0,p.A)({},ftr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Mtr.isMDXComponent=!0;const Xtr={toc:[]},_tr="wrapper";function wtr(e){let{components:n,...t}=e;return(0,s.yg)(_tr,(0,p.A)({},Xtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}wtr.isMDXComponent=!0;const Ttr={toc:[]},Ctr="wrapper";function xtr(e){let{components:n,...t}=e;return(0,s.yg)(Ctr,(0,p.A)({},Ttr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xtr.isMDXComponent=!0;const Atr={toc:[]},vtr="wrapper";function Ltr(e){let{components:n,...t}=e;return(0,s.yg)(vtr,(0,p.A)({},Atr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ltr.isMDXComponent=!0;const btr={toc:[]},Ntr="wrapper";function ktr(e){let{components:n,...t}=e;return(0,s.yg)(Ntr,(0,p.A)({},btr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ktr.isMDXComponent=!0;const ztr={toc:[]},Ptr="wrapper";function Itr(e){let{components:n,...t}=e;return(0,s.yg)(Ptr,(0,p.A)({},ztr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Itr.isMDXComponent=!0;const Rtr={toc:[]},Wtr="wrapper";function Str(e){let{components:n,...t}=e;return(0,s.yg)(Wtr,(0,p.A)({},Rtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Str.isMDXComponent=!0;const Btr={toc:[]},Gtr="wrapper";function Etr(e){let{components:n,...t}=e;return(0,s.yg)(Gtr,(0,p.A)({},Btr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Etr.isMDXComponent=!0;const Otr={toc:[]},Utr="wrapper";function Ftr(e){let{components:n,...t}=e;return(0,s.yg)(Utr,(0,p.A)({},Otr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ftr.isMDXComponent=!0;const Vtr={toc:[]},qtr="wrapper";function jtr(e){let{components:n,...t}=e;return(0,s.yg)(qtr,(0,p.A)({},Vtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jtr.isMDXComponent=!0;const Htr={toc:[]},Ytr="wrapper";function Qtr(e){let{components:n,...t}=e;return(0,s.yg)(Ytr,(0,p.A)({},Htr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Qtr.isMDXComponent=!0;const $tr={toc:[]},Ktr="wrapper";function Jtr(e){let{components:n,...t}=e;return(0,s.yg)(Ktr,(0,p.A)({},$tr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Jtr.isMDXComponent=!0;const Ztr={toc:[]},eor="wrapper";function nor(e){let{components:n,...t}=e;return(0,s.yg)(eor,(0,p.A)({},Ztr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}nor.isMDXComponent=!0;const tor={toc:[]},oor="wrapper";function por(e){let{components:n,...t}=e;return(0,s.yg)(oor,(0,p.A)({},tor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}por.isMDXComponent=!0;const ror={toc:[]},sor="wrapper";function cor(e){let{components:n,...t}=e;return(0,s.yg)(sor,(0,p.A)({},ror,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}cor.isMDXComponent=!0;const aor={toc:[]},ior="wrapper";function lor(e){let{components:n,...t}=e;return(0,s.yg)(ior,(0,p.A)({},aor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}lor.isMDXComponent=!0;const uor={toc:[]},mor="wrapper";function yor(e){let{components:n,...t}=e;return(0,s.yg)(mor,(0,p.A)({},uor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yor.isMDXComponent=!0;const dor={toc:[]},hor="wrapper";function gor(e){let{components:n,...t}=e;return(0,s.yg)(hor,(0,p.A)({},dor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}gor.isMDXComponent=!0;const Dor={toc:[]},Mor="wrapper";function Xor(e){let{components:n,...t}=e;return(0,s.yg)(Mor,(0,p.A)({},Dor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Xor.isMDXComponent=!0;const _or={toc:[]},wor="wrapper";function Tor(e){let{components:n,...t}=e;return(0,s.yg)(wor,(0,p.A)({},_or,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Tor.isMDXComponent=!0;const Cor={toc:[]},xor="wrapper";function Aor(e){let{components:n,...t}=e;return(0,s.yg)(xor,(0,p.A)({},Cor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting point of the ray."))}Aor.isMDXComponent=!0;const vor={toc:[]},Lor="wrapper";function bor(e){let{components:n,...t}=e;return(0,s.yg)(Lor,(0,p.A)({},vor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}bor.isMDXComponent=!0;const Nor={toc:[]},kor="wrapper";function zor(e){let{components:n,...t}=e;return(0,s.yg)(kor,(0,p.A)({},Nor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}zor.isMDXComponent=!0;const Por={toc:[]},Ior="wrapper";function Ror(e){let{components:n,...t}=e;return(0,s.yg)(Ior,(0,p.A)({},Por,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Ror.isMDXComponent=!0;const Wor={toc:[]},Sor="wrapper";function Bor(e){let{components:n,...t}=e;return(0,s.yg)(Sor,(0,p.A)({},Wor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Bor.isMDXComponent=!0;const Gor={toc:[]},Eor="wrapper";function Oor(e){let{components:n,...t}=e;return(0,s.yg)(Eor,(0,p.A)({},Gor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Oor.isMDXComponent=!0;const Uor={toc:[]},For="wrapper";function Vor(e){let{components:n,...t}=e;return(0,s.yg)(For,(0,p.A)({},Uor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Vor.isMDXComponent=!0;const qor={toc:[]},jor="wrapper";function Hor(e){let{components:n,...t}=e;return(0,s.yg)(jor,(0,p.A)({},qor,t,{components:n,mdxType:"MDXLayout"}))}Hor.isMDXComponent=!0;const Yor={toc:[]},Qor="wrapper";function $or(e){let{components:n,...t}=e;return(0,s.yg)(Qor,(0,p.A)({},Yor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}$or.isMDXComponent=!0;const Kor={toc:[]},Jor="wrapper";function Zor(e){let{components:n,...t}=e;return(0,s.yg)(Jor,(0,p.A)({},Kor,t,{components:n,mdxType:"MDXLayout"}))}Zor.isMDXComponent=!0;const epr={toc:[]},npr="wrapper";function tpr(e){let{components:n,...t}=e;return(0,s.yg)(npr,(0,p.A)({},epr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}tpr.isMDXComponent=!0;const opr={toc:[]},ppr="wrapper";function rpr(e){let{components:n,...t}=e;return(0,s.yg)(ppr,(0,p.A)({},opr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}rpr.isMDXComponent=!0;const spr={toc:[]},cpr="wrapper";function apr(e){let{components:n,...t}=e;return(0,s.yg)(cpr,(0,p.A)({},spr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}apr.isMDXComponent=!0;const ipr={toc:[]},lpr="wrapper";function upr(e){let{components:n,...t}=e;return(0,s.yg)(lpr,(0,p.A)({},ipr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}upr.isMDXComponent=!0;const mpr={toc:[]},ypr="wrapper";function dpr(e){let{components:n,...t}=e;return(0,s.yg)(ypr,(0,p.A)({},mpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}dpr.isMDXComponent=!0;const hpr={toc:[]},gpr="wrapper";function fpr(e){let{components:n,...t}=e;return(0,s.yg)(gpr,(0,p.A)({},hpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}fpr.isMDXComponent=!0;const Dpr={toc:[]},Mpr="wrapper";function Xpr(e){let{components:n,...t}=e;return(0,s.yg)(Mpr,(0,p.A)({},Dpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending point of the ray."))}Xpr.isMDXComponent=!0;const _pr={toc:[]},wpr="wrapper";function Tpr(e){let{components:n,...t}=e;return(0,s.yg)(wpr,(0,p.A)({},_pr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Tpr.isMDXComponent=!0;const Cpr={toc:[]},xpr="wrapper";function Apr(e){let{components:n,...t}=e;return(0,s.yg)(xpr,(0,p.A)({},Cpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Apr.isMDXComponent=!0;const vpr={toc:[]},Lpr="wrapper";function bpr(e){let{components:n,...t}=e;return(0,s.yg)(Lpr,(0,p.A)({},vpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}bpr.isMDXComponent=!0;const Npr={toc:[]},kpr="wrapper";function zpr(e){let{components:n,...t}=e;return(0,s.yg)(kpr,(0,p.A)({},Npr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}zpr.isMDXComponent=!0;const Ppr={toc:[]},Ipr="wrapper";function Rpr(e){let{components:n,...t}=e;return(0,s.yg)(Ipr,(0,p.A)({},Ppr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Rpr.isMDXComponent=!0;const Wpr={toc:[]},Spr="wrapper";function Bpr(e){let{components:n,...t}=e;return(0,s.yg)(Spr,(0,p.A)({},Wpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Bpr.isMDXComponent=!0;const Gpr={toc:[]},Epr="wrapper";function Opr(e){let{components:n,...t}=e;return(0,s.yg)(Epr,(0,p.A)({},Gpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Opr.isMDXComponent=!0;const Upr={toc:[]},Fpr="wrapper";function Vpr(e){let{components:n,...t}=e;return(0,s.yg)(Fpr,(0,p.A)({},Upr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Vpr.isMDXComponent=!0;const qpr={toc:[]},jpr="wrapper";function Hpr(e){let{components:n,...t}=e;return(0,s.yg)(jpr,(0,p.A)({},qpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Hpr.isMDXComponent=!0;const Ypr={toc:[]},Qpr="wrapper";function $pr(e){let{components:n,...t}=e;return(0,s.yg)(Qpr,(0,p.A)({},Ypr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}$pr.isMDXComponent=!0;const Kpr={toc:[]},Jpr="wrapper";function Zpr(e){let{components:n,...t}=e;return(0,s.yg)(Jpr,(0,p.A)({},Kpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Zpr.isMDXComponent=!0;const err={toc:[]},nrr="wrapper";function trr(e){let{components:n,...t}=e;return(0,s.yg)(nrr,(0,p.A)({},err,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}trr.isMDXComponent=!0;const orr={toc:[]},prr="wrapper";function rrr(e){let{components:n,...t}=e;return(0,s.yg)(prr,(0,p.A)({},orr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}rrr.isMDXComponent=!0;const srr={toc:[]},crr="wrapper";function arr(e){let{components:n,...t}=e;return(0,s.yg)(crr,(0,p.A)({},srr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}arr.isMDXComponent=!0;const irr={toc:[]},lrr="wrapper";function urr(e){let{components:n,...t}=e;return(0,s.yg)(lrr,(0,p.A)({},irr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}urr.isMDXComponent=!0;const mrr={toc:[]},yrr="wrapper";function drr(e){let{components:n,...t}=e;return(0,s.yg)(yrr,(0,p.A)({},mrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}drr.isMDXComponent=!0;const hrr={toc:[]},grr="wrapper";function frr(e){let{components:n,...t}=e;return(0,s.yg)(grr,(0,p.A)({},hrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}frr.isMDXComponent=!0;const Drr={toc:[]},Mrr="wrapper";function Xrr(e){let{components:n,...t}=e;return(0,s.yg)(Mrr,(0,p.A)({},Drr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Xrr.isMDXComponent=!0;const _rr={toc:[]},wrr="wrapper";function Trr(e){let{components:n,...t}=e;return(0,s.yg)(wrr,(0,p.A)({},_rr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Trr.isMDXComponent=!0;const Crr={toc:[]},xrr="wrapper";function Arr(e){let{components:n,...t}=e;return(0,s.yg)(xrr,(0,p.A)({},Crr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Arr.isMDXComponent=!0;const vrr={toc:[]},Lrr="wrapper";function brr(e){let{components:n,...t}=e;return(0,s.yg)(Lrr,(0,p.A)({},vrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}brr.isMDXComponent=!0;const Nrr={toc:[]},krr="wrapper";function zrr(e){let{components:n,...t}=e;return(0,s.yg)(krr,(0,p.A)({},Nrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}zrr.isMDXComponent=!0;const Prr={toc:[]},Irr="wrapper";function Rrr(e){let{components:n,...t}=e;return(0,s.yg)(Irr,(0,p.A)({},Prr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Rrr.isMDXComponent=!0;const Wrr={toc:[]},Srr="wrapper";function Brr(e){let{components:n,...t}=e;return(0,s.yg)(Srr,(0,p.A)({},Wrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Brr.isMDXComponent=!0;const Grr={toc:[]},Err="wrapper";function Orr(e){let{components:n,...t}=e;return(0,s.yg)(Err,(0,p.A)({},Grr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Orr.isMDXComponent=!0;const Urr={toc:[]},Frr="wrapper";function Vrr(e){let{components:n,...t}=e;return(0,s.yg)(Frr,(0,p.A)({},Urr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Vrr.isMDXComponent=!0;const qrr={toc:[]},jrr="wrapper";function Hrr(e){let{components:n,...t}=e;return(0,s.yg)(jrr,(0,p.A)({},qrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Hrr.isMDXComponent=!0;const Yrr={toc:[]},Qrr="wrapper";function $rr(e){let{components:n,...t}=e;return(0,s.yg)(Qrr,(0,p.A)({},Yrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}$rr.isMDXComponent=!0;const Krr={toc:[]},Jrr="wrapper";function Zrr(e){let{components:n,...t}=e;return(0,s.yg)(Jrr,(0,p.A)({},Krr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Zrr.isMDXComponent=!0;const esr={toc:[]},nsr="wrapper";function tsr(e){let{components:n,...t}=e;return(0,s.yg)(nsr,(0,p.A)({},esr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}tsr.isMDXComponent=!0;const osr={toc:[]},psr="wrapper";function rsr(e){let{components:n,...t}=e;return(0,s.yg)(psr,(0,p.A)({},osr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}rsr.isMDXComponent=!0;const ssr={toc:[]},csr="wrapper";function asr(e){let{components:n,...t}=e;return(0,s.yg)(csr,(0,p.A)({},ssr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}asr.isMDXComponent=!0;const isr={toc:[]},lsr="wrapper";function usr(e){let{components:n,...t}=e;return(0,s.yg)(lsr,(0,p.A)({},isr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}usr.isMDXComponent=!0;const msr={toc:[]},ysr="wrapper";function dsr(e){let{components:n,...t}=e;return(0,s.yg)(ysr,(0,p.A)({},msr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}dsr.isMDXComponent=!0;const hsr={toc:[]},gsr="wrapper";function fsr(e){let{components:n,...t}=e;return(0,s.yg)(gsr,(0,p.A)({},hsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}fsr.isMDXComponent=!0;const Dsr={toc:[]},Msr="wrapper";function Xsr(e){let{components:n,...t}=e;return(0,s.yg)(Msr,(0,p.A)({},Dsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Xsr.isMDXComponent=!0;const _sr={toc:[]},wsr="wrapper";function Tsr(e){let{components:n,...t}=e;return(0,s.yg)(wsr,(0,p.A)({},_sr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Tsr.isMDXComponent=!0;const Csr={toc:[]},xsr="wrapper";function Asr(e){let{components:n,...t}=e;return(0,s.yg)(xsr,(0,p.A)({},Csr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Asr.isMDXComponent=!0;const vsr={toc:[]},Lsr="wrapper";function bsr(e){let{components:n,...t}=e;return(0,s.yg)(Lsr,(0,p.A)({},vsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}bsr.isMDXComponent=!0;const Nsr={toc:[]},ksr="wrapper";function zsr(e){let{components:n,...t}=e;return(0,s.yg)(ksr,(0,p.A)({},Nsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}zsr.isMDXComponent=!0;const Psr={toc:[]},Isr="wrapper";function Rsr(e){let{components:n,...t}=e;return(0,s.yg)(Isr,(0,p.A)({},Psr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Rsr.isMDXComponent=!0;const Wsr={toc:[]},Ssr="wrapper";function Bsr(e){let{components:n,...t}=e;return(0,s.yg)(Ssr,(0,p.A)({},Wsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Bsr.isMDXComponent=!0;const Gsr={toc:[]},Esr="wrapper";function Osr(e){let{components:n,...t}=e;return(0,s.yg)(Esr,(0,p.A)({},Gsr,t,{components:n,mdxType:"MDXLayout"}))}Osr.isMDXComponent=!0;const Usr={toc:[]},Fsr="wrapper";function Vsr(e){let{components:n,...t}=e;return(0,s.yg)(Fsr,(0,p.A)({},Usr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Vsr.isMDXComponent=!0;const qsr={toc:[]},jsr="wrapper";function Hsr(e){let{components:n,...t}=e;return(0,s.yg)(jsr,(0,p.A)({},qsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}Hsr.isMDXComponent=!0;const Ysr={toc:[]},Qsr="wrapper";function $sr(e){let{components:n,...t}=e;return(0,s.yg)(Qsr,(0,p.A)({},Ysr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}$sr.isMDXComponent=!0;const Ksr={toc:[]},Jsr="wrapper";function Zsr(e){let{components:n,...t}=e;return(0,s.yg)(Jsr,(0,p.A)({},Ksr,t,{components:n,mdxType:"MDXLayout"}))}Zsr.isMDXComponent=!0;const ecr={toc:[]},ncr="wrapper";function tcr(e){let{components:n,...t}=e;return(0,s.yg)(ncr,(0,p.A)({},ecr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}tcr.isMDXComponent=!0;const ocr={toc:[]},pcr="wrapper";function rcr(e){let{components:n,...t}=e;return(0,s.yg)(pcr,(0,p.A)({},ocr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}rcr.isMDXComponent=!0;const scr={toc:[]},ccr="wrapper";function acr(e){let{components:n,...t}=e;return(0,s.yg)(ccr,(0,p.A)({},scr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}acr.isMDXComponent=!0;const icr={toc:[]},lcr="wrapper";function ucr(e){let{components:n,...t}=e;return(0,s.yg)(lcr,(0,p.A)({},icr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}ucr.isMDXComponent=!0;const mcr={toc:[]},ycr="wrapper";function dcr(e){let{components:n,...t}=e;return(0,s.yg)(ycr,(0,p.A)({},mcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}dcr.isMDXComponent=!0;const hcr={toc:[]},gcr="wrapper";function fcr(e){let{components:n,...t}=e;return(0,s.yg)(gcr,(0,p.A)({},hcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}fcr.isMDXComponent=!0;const Dcr={toc:[]},Mcr="wrapper";function Xcr(e){let{components:n,...t}=e;return(0,s.yg)(Mcr,(0,p.A)({},Dcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Xcr.isMDXComponent=!0;const _cr={toc:[]},wcr="wrapper";function Tcr(e){let{components:n,...t}=e;return(0,s.yg)(wcr,(0,p.A)({},_cr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Tcr.isMDXComponent=!0;const Ccr={toc:[]},xcr="wrapper";function Acr(e){let{components:n,...t}=e;return(0,s.yg)(xcr,(0,p.A)({},Ccr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Acr.isMDXComponent=!0;const vcr={toc:[]},Lcr="wrapper";function bcr(e){let{components:n,...t}=e;return(0,s.yg)(Lcr,(0,p.A)({},vcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}bcr.isMDXComponent=!0;const Ncr={toc:[]},kcr="wrapper";function zcr(e){let{components:n,...t}=e;return(0,s.yg)(kcr,(0,p.A)({},Ncr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}zcr.isMDXComponent=!0;const Pcr={toc:[]},Icr="wrapper";function Rcr(e){let{components:n,...t}=e;return(0,s.yg)(Icr,(0,p.A)({},Pcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Rcr.isMDXComponent=!0;const Wcr={toc:[]},Scr="wrapper";function Bcr(e){let{components:n,...t}=e;return(0,s.yg)(Scr,(0,p.A)({},Wcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represent SVG document that contains SVG shapes.\nThis only used single time because ",(0,s.yg)("inlineCode",{parentName:"p"},"nodes")," have reference to parent SVG renderer."))}Bcr.isMDXComponent=!0;const Gcr={toc:[]},Ecr="wrapper";function Ocr(e){let{components:n,...t}=e;return(0,s.yg)(Ecr,(0,p.A)({},Gcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Data of SVGDocument.\nThis can used many times because it do not reference parent SVG.\nThis must build into SVGDocument"))}Ocr.isMDXComponent=!0;const Ucr={toc:[]},Fcr="wrapper";function Vcr(e){let{components:n,...t}=e;return(0,s.yg)(Fcr,(0,p.A)({},Ucr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Vcr.isMDXComponent=!0;const qcr={toc:[]},jcr="wrapper";function Hcr(e){let{components:n,...t}=e;return(0,s.yg)(jcr,(0,p.A)({},qcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Hcr.isMDXComponent=!0;const Ycr={toc:[]},Qcr="wrapper";function $cr(e){let{components:n,...t}=e;return(0,s.yg)(Qcr,(0,p.A)({},Ycr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}$cr.isMDXComponent=!0;const Kcr={toc:[]},Jcr="wrapper";function Zcr(e){let{components:n,...t}=e;return(0,s.yg)(Jcr,(0,p.A)({},Kcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Zcr.isMDXComponent=!0;const ear={toc:[]},nar="wrapper";function tar(e){let{components:n,...t}=e;return(0,s.yg)(nar,(0,p.A)({},ear,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}tar.isMDXComponent=!0;const oar={toc:[]},par="wrapper";function rar(e){let{components:n,...t}=e;return(0,s.yg)(par,(0,p.A)({},oar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}rar.isMDXComponent=!0;const sar={toc:[]},car="wrapper";function aar(e){let{components:n,...t}=e;return(0,s.yg)(car,(0,p.A)({},sar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}aar.isMDXComponent=!0;const iar={toc:[]},lar="wrapper";function uar(e){let{components:n,...t}=e;return(0,s.yg)(lar,(0,p.A)({},iar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}uar.isMDXComponent=!0;const mar={toc:[]},yar="wrapper";function dar(e){let{components:n,...t}=e;return(0,s.yg)(yar,(0,p.A)({},mar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}dar.isMDXComponent=!0;const har={toc:[]},gar="wrapper";function far(e){let{components:n,...t}=e;return(0,s.yg)(gar,(0,p.A)({},har,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}far.isMDXComponent=!0;const Dar={toc:[]},Mar="wrapper";function Xar(e){let{components:n,...t}=e;return(0,s.yg)(Mar,(0,p.A)({},Dar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Xar.isMDXComponent=!0;const _ar={toc:[]},war="wrapper";function Tar(e){let{components:n,...t}=e;return(0,s.yg)(war,(0,p.A)({},_ar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Tar.isMDXComponent=!0;const Car={toc:[]},xar="wrapper";function Aar(e){let{components:n,...t}=e;return(0,s.yg)(xar,(0,p.A)({},Car,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Aar.isMDXComponent=!0;const Lar={toc:[]},bar="wrapper";function Nar(e){let{components:n,...t}=e;return(0,s.yg)(bar,(0,p.A)({},Lar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Nar.isMDXComponent=!0;const kar={toc:[]},zar="wrapper";function Par(e){let{components:n,...t}=e;return(0,s.yg)(zar,(0,p.A)({},kar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Par.isMDXComponent=!0;const Iar={toc:[]},Rar="wrapper";function War(e){let{components:n,...t}=e;return(0,s.yg)(Rar,(0,p.A)({},Iar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}War.isMDXComponent=!0;const Sar={toc:[]},Bar="wrapper";function Gar(e){let{components:n,...t}=e;return(0,s.yg)(Bar,(0,p.A)({},Sar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Gar.isMDXComponent=!0;const Ear={toc:[]},Oar="wrapper";function Uar(e){let{components:n,...t}=e;return(0,s.yg)(Oar,(0,p.A)({},Ear,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Uar.isMDXComponent=!0;const Far={toc:[]},Var="wrapper";function qar(e){let{components:n,...t}=e;return(0,s.yg)(Var,(0,p.A)({},Far,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}qar.isMDXComponent=!0;const jar={toc:[]},Har="wrapper";function Yar(e){let{components:n,...t}=e;return(0,s.yg)(Har,(0,p.A)({},jar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Yar.isMDXComponent=!0;const Qar={toc:[]},$ar="wrapper";function Kar(e){let{components:n,...t}=e;return(0,s.yg)($ar,(0,p.A)({},Qar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Kar.isMDXComponent=!0;const Jar={toc:[]},Zar="wrapper";function eir(e){let{components:n,...t}=e;return(0,s.yg)(Zar,(0,p.A)({},Jar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}eir.isMDXComponent=!0;const nir={toc:[]},tir="wrapper";function oir(e){let{components:n,...t}=e;return(0,s.yg)(tir,(0,p.A)({},nir,t,{components:n,mdxType:"MDXLayout"}))}oir.isMDXComponent=!0;const pir={toc:[]},rir="wrapper";function sir(e){let{components:n,...t}=e;return(0,s.yg)(rir,(0,p.A)({},pir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}sir.isMDXComponent=!0;const cir={toc:[]},air="wrapper";function iir(e){let{components:n,...t}=e;return(0,s.yg)(air,(0,p.A)({},cir,t,{components:n,mdxType:"MDXLayout"}))}iir.isMDXComponent=!0;const lir={toc:[]},uir="wrapper";function mir(e){let{components:n,...t}=e;return(0,s.yg)(uir,(0,p.A)({},lir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}mir.isMDXComponent=!0;const yir={toc:[]},dir="wrapper";function hir(e){let{components:n,...t}=e;return(0,s.yg)(dir,(0,p.A)({},yir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}hir.isMDXComponent=!0;const gir={toc:[]},fir="wrapper";function Dir(e){let{components:n,...t}=e;return(0,s.yg)(fir,(0,p.A)({},gir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dir.isMDXComponent=!0;const Mir={toc:[]},Xir="wrapper";function _ir(e){let{components:n,...t}=e;return(0,s.yg)(Xir,(0,p.A)({},Mir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}_ir.isMDXComponent=!0;const wir={toc:[]},Tir="wrapper";function Cir(e){let{components:n,...t}=e;return(0,s.yg)(Tir,(0,p.A)({},wir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Cir.isMDXComponent=!0;const xir={toc:[]},Air="wrapper";function vir(e){let{components:n,...t}=e;return(0,s.yg)(Air,(0,p.A)({},xir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}vir.isMDXComponent=!0;const Lir={toc:[]},bir="wrapper";function Nir(e){let{components:n,...t}=e;return(0,s.yg)(bir,(0,p.A)({},Lir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represent SVG shape.\nThis only used single time because ",(0,s.yg)("inlineCode",{parentName:"p"},"node")," may have reference to parent SVG renderer."))}Nir.isMDXComponent=!0;const kir={toc:[]},zir="wrapper";function Pir(e){let{components:n,...t}=e;return(0,s.yg)(zir,(0,p.A)({},kir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Data of SVGShape.\nThis can used many times  because it do not reference parent SVG.\nThis must build into SVGShape"))}Pir.isMDXComponent=!0;const Iir={toc:[]},Rir="wrapper";function Wir(e){let{components:n,...t}=e;return(0,s.yg)(Rir,(0,p.A)({},Iir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Wir.isMDXComponent=!0;const Sir={toc:[]},Bir="wrapper";function Gir(e){let{components:n,...t}=e;return(0,s.yg)(Bir,(0,p.A)({},Sir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Gir.isMDXComponent=!0;const Eir={toc:[]},Oir="wrapper";function Uir(e){let{components:n,...t}=e;return(0,s.yg)(Oir,(0,p.A)({},Eir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Uir.isMDXComponent=!0;const Fir={toc:[]},Vir="wrapper";function qir(e){let{components:n,...t}=e;return(0,s.yg)(Vir,(0,p.A)({},Fir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}qir.isMDXComponent=!0;const jir={toc:[]},Hir="wrapper";function Yir(e){let{components:n,...t}=e;return(0,s.yg)(Hir,(0,p.A)({},jir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Yir.isMDXComponent=!0;const Qir={toc:[]},$ir="wrapper";function Kir(e){let{components:n,...t}=e;return(0,s.yg)($ir,(0,p.A)({},Qir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Kir.isMDXComponent=!0;const Jir={toc:[]},Zir="wrapper";function elr(e){let{components:n,...t}=e;return(0,s.yg)(Zir,(0,p.A)({},Jir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}elr.isMDXComponent=!0;const nlr={toc:[]},tlr="wrapper";function olr(e){let{components:n,...t}=e;return(0,s.yg)(tlr,(0,p.A)({},nlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}olr.isMDXComponent=!0;const plr={toc:[]},rlr="wrapper";function slr(e){let{components:n,...t}=e;return(0,s.yg)(rlr,(0,p.A)({},plr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}slr.isMDXComponent=!0;const clr={toc:[]},alr="wrapper";function ilr(e){let{components:n,...t}=e;return(0,s.yg)(alr,(0,p.A)({},clr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ilr.isMDXComponent=!0;const llr={toc:[]},ulr="wrapper";function mlr(e){let{components:n,...t}=e;return(0,s.yg)(ulr,(0,p.A)({},llr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}mlr.isMDXComponent=!0;const ylr={toc:[]},dlr="wrapper";function hlr(e){let{components:n,...t}=e;return(0,s.yg)(dlr,(0,p.A)({},ylr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}hlr.isMDXComponent=!0;const glr={toc:[]},flr="wrapper";function Dlr(e){let{components:n,...t}=e;return(0,s.yg)(flr,(0,p.A)({},glr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Dlr.isMDXComponent=!0;const Mlr={toc:[]},Xlr="wrapper";function _lr(e){let{components:n,...t}=e;return(0,s.yg)(Xlr,(0,p.A)({},Mlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}_lr.isMDXComponent=!0;const wlr={toc:[]},Tlr="wrapper";function Clr(e){let{components:n,...t}=e;return(0,s.yg)(Tlr,(0,p.A)({},wlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Clr.isMDXComponent=!0;const xlr={toc:[]},Alr="wrapper";function vlr(e){let{components:n,...t}=e;return(0,s.yg)(Alr,(0,p.A)({},xlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}vlr.isMDXComponent=!0;const Llr={toc:[]},blr="wrapper";function Nlr(e){let{components:n,...t}=e;return(0,s.yg)(blr,(0,p.A)({},Llr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Nlr.isMDXComponent=!0;const klr={toc:[]},zlr="wrapper";function Plr(e){let{components:n,...t}=e;return(0,s.yg)(zlr,(0,p.A)({},klr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Plr.isMDXComponent=!0;const Ilr={toc:[]},Rlr="wrapper";function Wlr(e){let{components:n,...t}=e;return(0,s.yg)(Rlr,(0,p.A)({},Ilr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Wlr.isMDXComponent=!0;const Slr={toc:[]},Blr="wrapper";function Glr(e){let{components:n,...t}=e;return(0,s.yg)(Blr,(0,p.A)({},Slr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Glr.isMDXComponent=!0;const Elr={toc:[]},Olr="wrapper";function Ulr(e){let{components:n,...t}=e;return(0,s.yg)(Olr,(0,p.A)({},Elr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ulr.isMDXComponent=!0;const Flr={toc:[]},Vlr="wrapper";function qlr(e){let{components:n,...t}=e;return(0,s.yg)(Vlr,(0,p.A)({},Flr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}qlr.isMDXComponent=!0;const jlr={toc:[]},Hlr="wrapper";function Ylr(e){let{components:n,...t}=e;return(0,s.yg)(Hlr,(0,p.A)({},jlr,t,{components:n,mdxType:"MDXLayout"}))}Ylr.isMDXComponent=!0;const Qlr={toc:[]},$lr="wrapper";function Klr(e){let{components:n,...t}=e;return(0,s.yg)($lr,(0,p.A)({},Qlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Klr.isMDXComponent=!0;const Jlr={toc:[]},Zlr="wrapper";function eur(e){let{components:n,...t}=e;return(0,s.yg)(Zlr,(0,p.A)({},Jlr,t,{components:n,mdxType:"MDXLayout"}))}eur.isMDXComponent=!0;const nur={toc:[]},tur="wrapper";function our(e){let{components:n,...t}=e;return(0,s.yg)(tur,(0,p.A)({},nur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}our.isMDXComponent=!0;const pur={toc:[]},rur="wrapper";function sur(e){let{components:n,...t}=e;return(0,s.yg)(rur,(0,p.A)({},pur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}sur.isMDXComponent=!0;const cur={toc:[]},aur="wrapper";function iur(e){let{components:n,...t}=e;return(0,s.yg)(aur,(0,p.A)({},cur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}iur.isMDXComponent=!0;const lur={toc:[]},uur="wrapper";function mur(e){let{components:n,...t}=e;return(0,s.yg)(uur,(0,p.A)({},lur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}mur.isMDXComponent=!0;const yur={toc:[]},dur="wrapper";function hur(e){let{components:n,...t}=e;return(0,s.yg)(dur,(0,p.A)({},yur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hur.isMDXComponent=!0;const gur={toc:[]},fur="wrapper";function Dur(e){let{components:n,...t}=e;return(0,s.yg)(fur,(0,p.A)({},gur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Dur.isMDXComponent=!0;const Mur={toc:[]},Xur="wrapper";function _ur(e){let{components:n,...t}=e;return(0,s.yg)(Xur,(0,p.A)({},Mur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}_ur.isMDXComponent=!0;const wur={toc:[]},Tur="wrapper";function Cur(e){let{components:n,...t}=e;return(0,s.yg)(Tur,(0,p.A)({},wur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Cur.isMDXComponent=!0;const xur={toc:[]},Aur="wrapper";function vur(e){let{components:n,...t}=e;return(0,s.yg)(Aur,(0,p.A)({},xur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}vur.isMDXComponent=!0;const Lur={toc:[]},bur="wrapper";function Nur(e){let{components:n,...t}=e;return(0,s.yg)(bur,(0,p.A)({},Lur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Nur.isMDXComponent=!0;const kur={toc:[]},zur="wrapper";function Pur(e){let{components:n,...t}=e;return(0,s.yg)(zur,(0,p.A)({},kur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Pur.isMDXComponent=!0;const Iur={toc:[]},Rur="wrapper";function Wur(e){let{components:n,...t}=e;return(0,s.yg)(Rur,(0,p.A)({},Iur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Wur.isMDXComponent=!0;const Sur={toc:[]},Bur="wrapper";function Gur(e){let{components:n,...t}=e;return(0,s.yg)(Bur,(0,p.A)({},Sur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Gur.isMDXComponent=!0;const Eur={toc:[]},Our="wrapper";function Uur(e){let{components:n,...t}=e;return(0,s.yg)(Our,(0,p.A)({},Eur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Uur.isMDXComponent=!0;const Fur={toc:[]},Vur="wrapper";function qur(e){let{components:n,...t}=e;return(0,s.yg)(Vur,(0,p.A)({},Fur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}qur.isMDXComponent=!0;const jur={toc:[]},Hur="wrapper";function Yur(e){let{components:n,...t}=e;return(0,s.yg)(Hur,(0,p.A)({},jur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Yur.isMDXComponent=!0;const Qur={toc:[]},$ur="wrapper";function Kur(e){let{components:n,...t}=e;return(0,s.yg)($ur,(0,p.A)({},Qur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Kur.isMDXComponent=!0;const Jur={toc:[]},Zur="wrapper";function emr(e){let{components:n,...t}=e;return(0,s.yg)(Zur,(0,p.A)({},Jur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}emr.isMDXComponent=!0;const nmr={toc:[]},tmr="wrapper";function omr(e){let{components:n,...t}=e;return(0,s.yg)(tmr,(0,p.A)({},nmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}omr.isMDXComponent=!0;const pmr={toc:[]},rmr="wrapper";function smr(e){let{components:n,...t}=e;return(0,s.yg)(rmr,(0,p.A)({},pmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}smr.isMDXComponent=!0;const cmr={toc:[]},amr="wrapper";function imr(e){let{components:n,...t}=e;return(0,s.yg)(amr,(0,p.A)({},cmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}imr.isMDXComponent=!0;const lmr={toc:[]},umr="wrapper";function mmr(e){let{components:n,...t}=e;return(0,s.yg)(umr,(0,p.A)({},lmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}mmr.isMDXComponent=!0;const ymr={toc:[]},dmr="wrapper";function hmr(e){let{components:n,...t}=e;return(0,s.yg)(dmr,(0,p.A)({},ymr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}hmr.isMDXComponent=!0;const gmr={toc:[]},fmr="wrapper";function Dmr(e){let{components:n,...t}=e;return(0,s.yg)(fmr,(0,p.A)({},gmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Dmr.isMDXComponent=!0;const Mmr={toc:[]},Xmr="wrapper";function _mr(e){let{components:n,...t}=e;return(0,s.yg)(Xmr,(0,p.A)({},Mmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}_mr.isMDXComponent=!0;const wmr={toc:[]},Tmr="wrapper";function Cmr(e){let{components:n,...t}=e;return(0,s.yg)(Tmr,(0,p.A)({},wmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Cmr.isMDXComponent=!0;const xmr={toc:[]},Amr="wrapper";function vmr(e){let{components:n,...t}=e;return(0,s.yg)(Amr,(0,p.A)({},xmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}vmr.isMDXComponent=!0;const Lmr={toc:[]},bmr="wrapper";function Nmr(e){let{components:n,...t}=e;return(0,s.yg)(bmr,(0,p.A)({},Lmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Nmr.isMDXComponent=!0;const kmr={toc:[]},zmr="wrapper";function Pmr(e){let{components:n,...t}=e;return(0,s.yg)(zmr,(0,p.A)({},kmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Pmr.isMDXComponent=!0;const Imr={toc:[]},Rmr="wrapper";function Wmr(e){let{components:n,...t}=e;return(0,s.yg)(Rmr,(0,p.A)({},Imr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Wmr.isMDXComponent=!0;const Smr={toc:[]},Bmr="wrapper";function Gmr(e){let{components:n,...t}=e;return(0,s.yg)(Bmr,(0,p.A)({},Smr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Gmr.isMDXComponent=!0;const Emr={toc:[]},Omr="wrapper";function Umr(e){let{components:n,...t}=e;return(0,s.yg)(Omr,(0,p.A)({},Emr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Umr.isMDXComponent=!0;const Fmr={toc:[]},Vmr="wrapper";function qmr(e){let{components:n,...t}=e;return(0,s.yg)(Vmr,(0,p.A)({},Fmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qmr.isMDXComponent=!0;const jmr={toc:[]},Hmr="wrapper";function Ymr(e){let{components:n,...t}=e;return(0,s.yg)(Hmr,(0,p.A)({},jmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ymr.isMDXComponent=!0;const Qmr={toc:[]},$mr="wrapper";function Kmr(e){let{components:n,...t}=e;return(0,s.yg)($mr,(0,p.A)({},Qmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Kmr.isMDXComponent=!0;const Jmr={toc:[]},Zmr="wrapper";function eyr(e){let{components:n,...t}=e;return(0,s.yg)(Zmr,(0,p.A)({},Jmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}eyr.isMDXComponent=!0;const nyr={toc:[]},tyr="wrapper";function oyr(e){let{components:n,...t}=e;return(0,s.yg)(tyr,(0,p.A)({},nyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."))}oyr.isMDXComponent=!0;const pyr={toc:[]},ryr="wrapper";function syr(e){let{components:n,...t}=e;return(0,s.yg)(ryr,(0,p.A)({},pyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}syr.isMDXComponent=!0;const cyr={toc:[]},ayr="wrapper";function iyr(e){let{components:n,...t}=e;return(0,s.yg)(ayr,(0,p.A)({},cyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}iyr.isMDXComponent=!0;const lyr={toc:[]},uyr="wrapper";function myr(e){let{components:n,...t}=e;return(0,s.yg)(uyr,(0,p.A)({},lyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}myr.isMDXComponent=!0;const yyr={toc:[]},dyr="wrapper";function hyr(e){let{components:n,...t}=e;return(0,s.yg)(dyr,(0,p.A)({},yyr,t,{components:n,mdxType:"MDXLayout"}))}hyr.isMDXComponent=!0;const gyr={toc:[]},fyr="wrapper";function Dyr(e){let{components:n,...t}=e;return(0,s.yg)(fyr,(0,p.A)({},gyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property is only applied to knots that don't use explicit handles."))}Dyr.isMDXComponent=!0;const Myr={toc:[]},Xyr="wrapper";function _yr(e){let{components:n,...t}=e;return(0,s.yg)(Xyr,(0,p.A)({},Myr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The smoothness of the spline when using auto-calculated handles."))}_yr.isMDXComponent=!0;const wyr={toc:[]},Tyr="wrapper";function Cyr(e){let{components:n,...t}=e;return(0,s.yg)(Tyr,(0,p.A)({},wyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Cyr.isMDXComponent=!0;const xyr={toc:[]},Ayr="wrapper";function vyr(e){let{components:n,...t}=e;return(0,s.yg)(Ayr,(0,p.A)({},xyr,t,{components:n,mdxType:"MDXLayout"}))}vyr.isMDXComponent=!0;const Lyr={toc:[]},byr="wrapper";function Nyr(e){let{components:n,...t}=e;return(0,s.yg)(byr,(0,p.A)({},Lyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nyr.isMDXComponent=!0;const kyr={toc:[]},zyr="wrapper";function Pyr(e){let{components:n,...t}=e;return(0,s.yg)(zyr,(0,p.A)({},kyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Pyr.isMDXComponent=!0;const Iyr={toc:[]},Ryr="wrapper";function Wyr(e){let{components:n,...t}=e;return(0,s.yg)(Ryr,(0,p.A)({},Iyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wyr.isMDXComponent=!0;const Syr={toc:[]},Byr="wrapper";function Gyr(e){let{components:n,...t}=e;return(0,s.yg)(Byr,(0,p.A)({},Syr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Gyr.isMDXComponent=!0;const Eyr={toc:[]},Oyr="wrapper";function Uyr(e){let{components:n,...t}=e;return(0,s.yg)(Oyr,(0,p.A)({},Eyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Uyr.isMDXComponent=!0;const Fyr={toc:[]},Vyr="wrapper";function qyr(e){let{components:n,...t}=e;return(0,s.yg)(Vyr,(0,p.A)({},Fyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}qyr.isMDXComponent=!0;const jyr={toc:[]},Hyr="wrapper";function Yyr(e){let{components:n,...t}=e;return(0,s.yg)(Hyr,(0,p.A)({},jyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Yyr.isMDXComponent=!0;const Qyr={toc:[]},$yr="wrapper";function Kyr(e){let{components:n,...t}=e;return(0,s.yg)($yr,(0,p.A)({},Qyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Kyr.isMDXComponent=!0;const Jyr={toc:[]},Zyr="wrapper";function edr(e){let{components:n,...t}=e;return(0,s.yg)(Zyr,(0,p.A)({},Jyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}edr.isMDXComponent=!0;const ndr={toc:[]},tdr="wrapper";function odr(e){let{components:n,...t}=e;return(0,s.yg)(tdr,(0,p.A)({},ndr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}odr.isMDXComponent=!0;const pdr={toc:[]},rdr="wrapper";function sdr(e){let{components:n,...t}=e;return(0,s.yg)(rdr,(0,p.A)({},pdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}sdr.isMDXComponent=!0;const cdr={toc:[]},adr="wrapper";function idr(e){let{components:n,...t}=e;return(0,s.yg)(adr,(0,p.A)({},cdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}idr.isMDXComponent=!0;const ldr={toc:[]},udr="wrapper";function mdr(e){let{components:n,...t}=e;return(0,s.yg)(udr,(0,p.A)({},ldr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}mdr.isMDXComponent=!0;const ydr={toc:[]},ddr="wrapper";function hdr(e){let{components:n,...t}=e;return(0,s.yg)(ddr,(0,p.A)({},ydr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}hdr.isMDXComponent=!0;const gdr={toc:[]},fdr="wrapper";function Ddr(e){let{components:n,...t}=e;return(0,s.yg)(fdr,(0,p.A)({},gdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ddr.isMDXComponent=!0;const Mdr={toc:[]},Xdr="wrapper";function _dr(e){let{components:n,...t}=e;return(0,s.yg)(Xdr,(0,p.A)({},Mdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}_dr.isMDXComponent=!0;const wdr={toc:[]},Tdr="wrapper";function Cdr(e){let{components:n,...t}=e;return(0,s.yg)(Tdr,(0,p.A)({},wdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Cdr.isMDXComponent=!0;const xdr={toc:[]},Adr="wrapper";function vdr(e){let{components:n,...t}=e;return(0,s.yg)(Adr,(0,p.A)({},xdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}vdr.isMDXComponent=!0;const Ldr={toc:[]},bdr="wrapper";function Ndr(e){let{components:n,...t}=e;return(0,s.yg)(bdr,(0,p.A)({},Ldr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ndr.isMDXComponent=!0;const kdr={toc:[]},zdr="wrapper";function Pdr(e){let{components:n,...t}=e;return(0,s.yg)(zdr,(0,p.A)({},kdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Pdr.isMDXComponent=!0;const Idr={toc:[]},Rdr="wrapper";function Wdr(e){let{components:n,...t}=e;return(0,s.yg)(Rdr,(0,p.A)({},Idr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Wdr.isMDXComponent=!0;const Sdr={toc:[]},Bdr="wrapper";function Gdr(e){let{components:n,...t}=e;return(0,s.yg)(Bdr,(0,p.A)({},Sdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Gdr.isMDXComponent=!0;const Edr={toc:[]},Odr="wrapper";function Udr(e){let{components:n,...t}=e;return(0,s.yg)(Odr,(0,p.A)({},Edr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Udr.isMDXComponent=!0;const Fdr={toc:[]},Vdr="wrapper";function qdr(e){let{components:n,...t}=e;return(0,s.yg)(Vdr,(0,p.A)({},Fdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}qdr.isMDXComponent=!0;const jdr={toc:[]},Hdr="wrapper";function Ydr(e){let{components:n,...t}=e;return(0,s.yg)(Hdr,(0,p.A)({},jdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ydr.isMDXComponent=!0;const Qdr={toc:[]},$dr="wrapper";function Kdr(e){let{components:n,...t}=e;return(0,s.yg)($dr,(0,p.A)({},Qdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Kdr.isMDXComponent=!0;const Jdr={toc:[]},Zdr="wrapper";function ehr(e){let{components:n,...t}=e;return(0,s.yg)(Zdr,(0,p.A)({},Jdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ehr.isMDXComponent=!0;const nhr={toc:[]},thr="wrapper";function ohr(e){let{components:n,...t}=e;return(0,s.yg)(thr,(0,p.A)({},nhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ohr.isMDXComponent=!0;const phr={toc:[]},rhr="wrapper";function shr(e){let{components:n,...t}=e;return(0,s.yg)(rhr,(0,p.A)({},phr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}shr.isMDXComponent=!0;const chr={toc:[]},ahr="wrapper";function ihr(e){let{components:n,...t}=e;return(0,s.yg)(ahr,(0,p.A)({},chr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}ihr.isMDXComponent=!0;const lhr={toc:[]},uhr="wrapper";function mhr(e){let{components:n,...t}=e;return(0,s.yg)(uhr,(0,p.A)({},lhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}mhr.isMDXComponent=!0;const yhr={toc:[]},dhr="wrapper";function hhr(e){let{components:n,...t}=e;return(0,s.yg)(dhr,(0,p.A)({},yhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}hhr.isMDXComponent=!0;const ghr={toc:[]},fhr="wrapper";function Dhr(e){let{components:n,...t}=e;return(0,s.yg)(fhr,(0,p.A)({},ghr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dhr.isMDXComponent=!0;const Mhr={toc:[]},Xhr="wrapper";function _hr(e){let{components:n,...t}=e;return(0,s.yg)(Xhr,(0,p.A)({},Mhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}_hr.isMDXComponent=!0;const whr={toc:[]},Thr="wrapper";function Chr(e){let{components:n,...t}=e;return(0,s.yg)(Thr,(0,p.A)({},whr,t,{components:n,mdxType:"MDXLayout"}))}Chr.isMDXComponent=!0;const xhr={toc:[]},Ahr="wrapper";function vhr(e){let{components:n,...t}=e;return(0,s.yg)(Ahr,(0,p.A)({},xhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}vhr.isMDXComponent=!0;const Lhr={toc:[]},bhr="wrapper";function Nhr(e){let{components:n,...t}=e;return(0,s.yg)(bhr,(0,p.A)({},Lhr,t,{components:n,mdxType:"MDXLayout"}))}Nhr.isMDXComponent=!0;const khr={toc:[]},zhr="wrapper";function Phr(e){let{components:n,...t}=e;return(0,s.yg)(zhr,(0,p.A)({},khr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Phr.isMDXComponent=!0;const Ihr={toc:[]},Rhr="wrapper";function Whr(e){let{components:n,...t}=e;return(0,s.yg)(Rhr,(0,p.A)({},Ihr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Whr.isMDXComponent=!0;const Shr={toc:[]},Bhr="wrapper";function Ghr(e){let{components:n,...t}=e;return(0,s.yg)(Bhr,(0,p.A)({},Shr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ghr.isMDXComponent=!0;const Ehr={toc:[]},Ohr="wrapper";function Uhr(e){let{components:n,...t}=e;return(0,s.yg)(Ohr,(0,p.A)({},Ehr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Uhr.isMDXComponent=!0;const Fhr={toc:[]},Vhr="wrapper";function qhr(e){let{components:n,...t}=e;return(0,s.yg)(Vhr,(0,p.A)({},Fhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qhr.isMDXComponent=!0;const jhr={toc:[]},Hhr="wrapper";function Yhr(e){let{components:n,...t}=e;return(0,s.yg)(Hhr,(0,p.A)({},jhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Yhr.isMDXComponent=!0;const Qhr={toc:[]},$hr="wrapper";function Khr(e){let{components:n,...t}=e;return(0,s.yg)($hr,(0,p.A)({},Qhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Khr.isMDXComponent=!0;const Jhr={toc:[]},Zhr="wrapper";function egr(e){let{components:n,...t}=e;return(0,s.yg)(Zhr,(0,p.A)({},Jhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this video."))}egr.isMDXComponent=!0;const ngr={toc:[]},tgr="wrapper";function ogr(e){let{components:n,...t}=e;return(0,s.yg)(tgr,(0,p.A)({},ngr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}ogr.isMDXComponent=!0;const pgr={toc:[]},rgr="wrapper";function sgr(e){let{components:n,...t}=e;return(0,s.yg)(rgr,(0,p.A)({},pgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}sgr.isMDXComponent=!0;const cgr={toc:[]},agr="wrapper";function igr(e){let{components:n,...t}=e;return(0,s.yg)(agr,(0,p.A)({},cgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}igr.isMDXComponent=!0;const lgr={toc:[]},ugr="wrapper";function mgr(e){let{components:n,...t}=e;return(0,s.yg)(ugr,(0,p.A)({},lgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}mgr.isMDXComponent=!0;const ygr={toc:[]},dgr="wrapper";function hgr(e){let{components:n,...t}=e;return(0,s.yg)(dgr,(0,p.A)({},ygr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hgr.isMDXComponent=!0;const ggr={toc:[]},fgr="wrapper";function Dgr(e){let{components:n,...t}=e;return(0,s.yg)(fgr,(0,p.A)({},ggr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Dgr.isMDXComponent=!0;const Mgr={toc:[]},Xgr="wrapper";function _gr(e){let{components:n,...t}=e;return(0,s.yg)(Xgr,(0,p.A)({},Mgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_gr.isMDXComponent=!0;const wgr={toc:[]},Tgr="wrapper";function Cgr(e){let{components:n,...t}=e;return(0,s.yg)(Tgr,(0,p.A)({},wgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Cgr.isMDXComponent=!0;const xgr={toc:[]},Agr="wrapper";function vgr(e){let{components:n,...t}=e;return(0,s.yg)(Agr,(0,p.A)({},xgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}vgr.isMDXComponent=!0;const Lgr={toc:[]},bgr="wrapper";function Ngr(e){let{components:n,...t}=e;return(0,s.yg)(bgr,(0,p.A)({},Lgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ngr.isMDXComponent=!0;const kgr={toc:[]},zgr="wrapper";function Pgr(e){let{components:n,...t}=e;return(0,s.yg)(zgr,(0,p.A)({},kgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Pgr.isMDXComponent=!0;const Igr={toc:[]},Rgr="wrapper";function Wgr(e){let{components:n,...t}=e;return(0,s.yg)(Rgr,(0,p.A)({},Igr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Wgr.isMDXComponent=!0;const Sgr={toc:[]},Bgr="wrapper";function Ggr(e){let{components:n,...t}=e;return(0,s.yg)(Bgr,(0,p.A)({},Sgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ggr.isMDXComponent=!0;const Egr={toc:[]},Ogr="wrapper";function Ugr(e){let{components:n,...t}=e;return(0,s.yg)(Ogr,(0,p.A)({},Egr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ugr.isMDXComponent=!0;const Fgr={toc:[]},Vgr="wrapper";function qgr(e){let{components:n,...t}=e;return(0,s.yg)(Vgr,(0,p.A)({},Fgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}qgr.isMDXComponent=!0;const jgr={toc:[]},Hgr="wrapper";function Ygr(e){let{components:n,...t}=e;return(0,s.yg)(Hgr,(0,p.A)({},jgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ygr.isMDXComponent=!0;const Qgr={toc:[]},$gr="wrapper";function Kgr(e){let{components:n,...t}=e;return(0,s.yg)($gr,(0,p.A)({},Qgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Kgr.isMDXComponent=!0;const Jgr={toc:[]},Zgr="wrapper";function efr(e){let{components:n,...t}=e;return(0,s.yg)(Zgr,(0,p.A)({},Jgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}efr.isMDXComponent=!0;const nfr={toc:[]},tfr="wrapper";function ofr(e){let{components:n,...t}=e;return(0,s.yg)(tfr,(0,p.A)({},nfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}ofr.isMDXComponent=!0;const pfr={toc:[]},rfr="wrapper";function sfr(e){let{components:n,...t}=e;return(0,s.yg)(rfr,(0,p.A)({},pfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}sfr.isMDXComponent=!0;const cfr={toc:[]},afr="wrapper";function ifr(e){let{components:n,...t}=e;return(0,s.yg)(afr,(0,p.A)({},cfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ifr.isMDXComponent=!0;const lfr={toc:[]},ufr="wrapper";function mfr(e){let{components:n,...t}=e;return(0,s.yg)(ufr,(0,p.A)({},lfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mfr.isMDXComponent=!0;const yfr={toc:[]},dfr="wrapper";function hfr(e){let{components:n,...t}=e;return(0,s.yg)(dfr,(0,p.A)({},yfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}hfr.isMDXComponent=!0;const gfr={toc:[]},ffr="wrapper";function Dfr(e){let{components:n,...t}=e;return(0,s.yg)(ffr,(0,p.A)({},gfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Dfr.isMDXComponent=!0;const Mfr={toc:[]},Xfr="wrapper";function _fr(e){let{components:n,...t}=e;return(0,s.yg)(Xfr,(0,p.A)({},Mfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_fr.isMDXComponent=!0;const wfr={toc:[]},Tfr="wrapper";function Cfr(e){let{components:n,...t}=e;return(0,s.yg)(Tfr,(0,p.A)({},wfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Cfr.isMDXComponent=!0;const xfr={toc:[]},Afr="wrapper";function vfr(e){let{components:n,...t}=e;return(0,s.yg)(Afr,(0,p.A)({},xfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}vfr.isMDXComponent=!0;const Lfr={toc:[]},bfr="wrapper";function Nfr(e){let{components:n,...t}=e;return(0,s.yg)(bfr,(0,p.A)({},Lfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Nfr.isMDXComponent=!0;const kfr={toc:[]},zfr="wrapper";function Pfr(e){let{components:n,...t}=e;return(0,s.yg)(zfr,(0,p.A)({},kfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Pfr.isMDXComponent=!0;const Ifr={toc:[]},Rfr="wrapper";function Wfr(e){let{components:n,...t}=e;return(0,s.yg)(Rfr,(0,p.A)({},Ifr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Wfr.isMDXComponent=!0;const Sfr={toc:[]},Bfr="wrapper";function Gfr(e){let{components:n,...t}=e;return(0,s.yg)(Bfr,(0,p.A)({},Sfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Gfr.isMDXComponent=!0;const Efr={toc:[]},Ofr="wrapper";function Ufr(e){let{components:n,...t}=e;return(0,s.yg)(Ofr,(0,p.A)({},Efr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Ufr.isMDXComponent=!0;const Ffr={toc:[]},Vfr="wrapper";function qfr(e){let{components:n,...t}=e;return(0,s.yg)(Vfr,(0,p.A)({},Ffr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}qfr.isMDXComponent=!0;const jfr={toc:[]},Hfr="wrapper";function Yfr(e){let{components:n,...t}=e;return(0,s.yg)(Hfr,(0,p.A)({},jfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Yfr.isMDXComponent=!0;const Qfr={toc:[]},$fr="wrapper";function Kfr(e){let{components:n,...t}=e;return(0,s.yg)($fr,(0,p.A)({},Qfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Kfr.isMDXComponent=!0;const Jfr={toc:[]},Zfr="wrapper";function eDr(e){let{components:n,...t}=e;return(0,s.yg)(Zfr,(0,p.A)({},Jfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}eDr.isMDXComponent=!0;const nDr={toc:[]},tDr="wrapper";function oDr(e){let{components:n,...t}=e;return(0,s.yg)(tDr,(0,p.A)({},nDr,t,{components:n,mdxType:"MDXLayout"}))}oDr.isMDXComponent=!0;const pDr={toc:[]},rDr="wrapper";function sDr(e){let{components:n,...t}=e;return(0,s.yg)(rDr,(0,p.A)({},pDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}sDr.isMDXComponent=!0;const cDr={toc:[]},aDr="wrapper";function iDr(e){let{components:n,...t}=e;return(0,s.yg)(aDr,(0,p.A)({},cDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}iDr.isMDXComponent=!0;const lDr={toc:[]},uDr="wrapper";function mDr(e){let{components:n,...t}=e;return(0,s.yg)(uDr,(0,p.A)({},lDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}mDr.isMDXComponent=!0;const yDr={toc:[]},dDr="wrapper";function hDr(e){let{components:n,...t}=e;return(0,s.yg)(dDr,(0,p.A)({},yDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video should be smoothed."))}hDr.isMDXComponent=!0;const gDr={toc:[]},fDr="wrapper";function DDr(e){let{components:n,...t}=e;return(0,s.yg)(fDr,(0,p.A)({},gDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}DDr.isMDXComponent=!0;const MDr={toc:[]},XDr="wrapper";function _Dr(e){let{components:n,...t}=e;return(0,s.yg)(XDr,(0,p.A)({},MDr,t,{components:n,mdxType:"MDXLayout"}))}_Dr.isMDXComponent=!0;const wDr={toc:[]},TDr="wrapper";function CDr(e){let{components:n,...t}=e;return(0,s.yg)(TDr,(0,p.A)({},wDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}CDr.isMDXComponent=!0;const xDr={toc:[]},ADr="wrapper";function vDr(e){let{components:n,...t}=e;return(0,s.yg)(ADr,(0,p.A)({},xDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}vDr.isMDXComponent=!0;const LDr={toc:[]},bDr="wrapper";function NDr(e){let{components:n,...t}=e;return(0,s.yg)(bDr,(0,p.A)({},LDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NDr.isMDXComponent=!0;const kDr={toc:[]},zDr="wrapper";function PDr(e){let{components:n,...t}=e;return(0,s.yg)(zDr,(0,p.A)({},kDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}PDr.isMDXComponent=!0;const IDr={toc:[]},RDr="wrapper";function WDr(e){let{components:n,...t}=e;return(0,s.yg)(RDr,(0,p.A)({},IDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}WDr.isMDXComponent=!0;const SDr={toc:[]},BDr="wrapper";function GDr(e){let{components:n,...t}=e;return(0,s.yg)(BDr,(0,p.A)({},SDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}GDr.isMDXComponent=!0;const EDr={toc:[]},ODr="wrapper";function UDr(e){let{components:n,...t}=e;return(0,s.yg)(ODr,(0,p.A)({},EDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}UDr.isMDXComponent=!0;const FDr={toc:[]},VDr="wrapper";function qDr(e){let{components:n,...t}=e;return(0,s.yg)(VDr,(0,p.A)({},FDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}qDr.isMDXComponent=!0;const jDr={toc:[]},HDr="wrapper";function YDr(e){let{components:n,...t}=e;return(0,s.yg)(HDr,(0,p.A)({},jDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}YDr.isMDXComponent=!0;const QDr={toc:[]},$Dr="wrapper";function KDr(e){let{components:n,...t}=e;return(0,s.yg)($Dr,(0,p.A)({},QDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}KDr.isMDXComponent=!0;const JDr={toc:[]},ZDr="wrapper";function eMr(e){let{components:n,...t}=e;return(0,s.yg)(ZDr,(0,p.A)({},JDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}eMr.isMDXComponent=!0;const nMr={toc:[]},tMr="wrapper";function oMr(e){let{components:n,...t}=e;return(0,s.yg)(tMr,(0,p.A)({},nMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}oMr.isMDXComponent=!0;const pMr={toc:[]},rMr="wrapper";function sMr(e){let{components:n,...t}=e;return(0,s.yg)(rMr,(0,p.A)({},pMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}sMr.isMDXComponent=!0;const cMr={toc:[]},aMr="wrapper";function iMr(e){let{components:n,...t}=e;return(0,s.yg)(aMr,(0,p.A)({},cMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}iMr.isMDXComponent=!0;const lMr={toc:[]},uMr="wrapper";function mMr(e){let{components:n,...t}=e;return(0,s.yg)(uMr,(0,p.A)({},lMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}mMr.isMDXComponent=!0;const yMr={toc:[]},dMr="wrapper";function hMr(e){let{components:n,...t}=e;return(0,s.yg)(dMr,(0,p.A)({},yMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}hMr.isMDXComponent=!0;const gMr={toc:[]},fMr="wrapper";function DMr(e){let{components:n,...t}=e;return(0,s.yg)(fMr,(0,p.A)({},gMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}DMr.isMDXComponent=!0;const MMr={toc:[]},XMr="wrapper";function _Mr(e){let{components:n,...t}=e;return(0,s.yg)(XMr,(0,p.A)({},MMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}_Mr.isMDXComponent=!0;const wMr={toc:[]},TMr="wrapper";function CMr(e){let{components:n,...t}=e;return(0,s.yg)(TMr,(0,p.A)({},wMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}CMr.isMDXComponent=!0;const xMr={toc:[]},AMr="wrapper";function vMr(e){let{components:n,...t}=e;return(0,s.yg)(AMr,(0,p.A)({},xMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}vMr.isMDXComponent=!0;const LMr={toc:[]},bMr="wrapper";function NMr(e){let{components:n,...t}=e;return(0,s.yg)(bMr,(0,p.A)({},LMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}NMr.isMDXComponent=!0;const kMr={toc:[]},zMr="wrapper";function PMr(e){let{components:n,...t}=e;return(0,s.yg)(zMr,(0,p.A)({},kMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}PMr.isMDXComponent=!0;const IMr={toc:[]},RMr="wrapper";function WMr(e){let{components:n,...t}=e;return(0,s.yg)(RMr,(0,p.A)({},IMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}WMr.isMDXComponent=!0;const SMr={toc:[]},BMr="wrapper";function GMr(e){let{components:n,...t}=e;return(0,s.yg)(BMr,(0,p.A)({},SMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}GMr.isMDXComponent=!0;const EMr={toc:[]},OMr="wrapper";function UMr(e){let{components:n,...t}=e;return(0,s.yg)(OMr,(0,p.A)({},EMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}UMr.isMDXComponent=!0;const FMr={toc:[]},VMr="wrapper";function qMr(e){let{components:n,...t}=e;return(0,s.yg)(VMr,(0,p.A)({},FMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}qMr.isMDXComponent=!0;const jMr={toc:[]},HMr="wrapper";function YMr(e){let{components:n,...t}=e;return(0,s.yg)(HMr,(0,p.A)({},jMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}YMr.isMDXComponent=!0;const QMr={toc:[]},$Mr="wrapper";function KMr(e){let{components:n,...t}=e;return(0,s.yg)($Mr,(0,p.A)({},QMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}KMr.isMDXComponent=!0;const JMr={toc:[]},ZMr="wrapper";function eXr(e){let{components:n,...t}=e;return(0,s.yg)(ZMr,(0,p.A)({},JMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}eXr.isMDXComponent=!0;const nXr={toc:[]},tXr="wrapper";function oXr(e){let{components:n,...t}=e;return(0,s.yg)(tXr,(0,p.A)({},nXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}oXr.isMDXComponent=!0;const pXr={toc:[]},rXr="wrapper";function sXr(e){let{components:n,...t}=e;return(0,s.yg)(rXr,(0,p.A)({},pXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}sXr.isMDXComponent=!0;const cXr={toc:[]},aXr="wrapper";function iXr(e){let{components:n,...t}=e;return(0,s.yg)(aXr,(0,p.A)({},cXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}iXr.isMDXComponent=!0;const lXr={toc:[]},uXr="wrapper";function mXr(e){let{components:n,...t}=e;return(0,s.yg)(uXr,(0,p.A)({},lXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}mXr.isMDXComponent=!0;const yXr={toc:[]},dXr="wrapper";function hXr(e){let{components:n,...t}=e;return(0,s.yg)(dXr,(0,p.A)({},yXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}hXr.isMDXComponent=!0;const gXr={toc:[]},fXr="wrapper";function DXr(e){let{components:n,...t}=e;return(0,s.yg)(fXr,(0,p.A)({},gXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}DXr.isMDXComponent=!0;const MXr={toc:[]},XXr="wrapper";function _Xr(e){let{components:n,...t}=e;return(0,s.yg)(XXr,(0,p.A)({},MXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}_Xr.isMDXComponent=!0;const wXr={toc:[]},TXr="wrapper";function CXr(e){let{components:n,...t}=e;return(0,s.yg)(TXr,(0,p.A)({},wXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}CXr.isMDXComponent=!0;const xXr={toc:[]},AXr="wrapper";function vXr(e){let{components:n,...t}=e;return(0,s.yg)(AXr,(0,p.A)({},xXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}vXr.isMDXComponent=!0;const LXr={toc:[]},bXr="wrapper";function NXr(e){let{components:n,...t}=e;return(0,s.yg)(bXr,(0,p.A)({},LXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}NXr.isMDXComponent=!0;const kXr={toc:[]},zXr="wrapper";function PXr(e){let{components:n,...t}=e;return(0,s.yg)(zXr,(0,p.A)({},kXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}PXr.isMDXComponent=!0;const IXr={toc:[]},RXr="wrapper";function WXr(e){let{components:n,...t}=e;return(0,s.yg)(RXr,(0,p.A)({},IXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}WXr.isMDXComponent=!0;const SXr={toc:[]},BXr="wrapper";function GXr(e){let{components:n,...t}=e;return(0,s.yg)(BXr,(0,p.A)({},SXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}GXr.isMDXComponent=!0;const EXr={toc:[]},OXr="wrapper";function UXr(e){let{components:n,...t}=e;return(0,s.yg)(OXr,(0,p.A)({},EXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}UXr.isMDXComponent=!0;const FXr={toc:[]},VXr="wrapper";function qXr(e){let{components:n,...t}=e;return(0,s.yg)(VXr,(0,p.A)({},FXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}qXr.isMDXComponent=!0;const jXr={toc:[]},HXr="wrapper";function YXr(e){let{components:n,...t}=e;return(0,s.yg)(HXr,(0,p.A)({},jXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}YXr.isMDXComponent=!0;const QXr={toc:[]},$Xr="wrapper";function KXr(e){let{components:n,...t}=e;return(0,s.yg)($Xr,(0,p.A)({},QXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}KXr.isMDXComponent=!0;const JXr={toc:[]},ZXr="wrapper";function e_r(e){let{components:n,...t}=e;return(0,s.yg)(ZXr,(0,p.A)({},JXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}e_r.isMDXComponent=!0;const n_r={toc:[]},t_r="wrapper";function o_r(e){let{components:n,...t}=e;return(0,s.yg)(t_r,(0,p.A)({},n_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}o_r.isMDXComponent=!0;const p_r={toc:[]},r_r="wrapper";function s_r(e){let{components:n,...t}=e;return(0,s.yg)(r_r,(0,p.A)({},p_r,t,{components:n,mdxType:"MDXLayout"}))}s_r.isMDXComponent=!0;const c_r={toc:[]},a_r="wrapper";function i_r(e){let{components:n,...t}=e;return(0,s.yg)(a_r,(0,p.A)({},c_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}i_r.isMDXComponent=!0;const l_r={toc:[]},u_r="wrapper";function m_r(e){let{components:n,...t}=e;return(0,s.yg)(u_r,(0,p.A)({},l_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}m_r.isMDXComponent=!0;const y_r={toc:[]},d_r="wrapper";function h_r(e){let{components:n,...t}=e;return(0,s.yg)(d_r,(0,p.A)({},y_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}h_r.isMDXComponent=!0;const g_r={toc:[]},f_r="wrapper";function D_r(e){let{components:n,...t}=e;return(0,s.yg)(f_r,(0,p.A)({},g_r,t,{components:n,mdxType:"MDXLayout"}))}D_r.isMDXComponent=!0;const M_r={toc:[]},X_r="wrapper";function __r(e){let{components:n,...t}=e;return(0,s.yg)(X_r,(0,p.A)({},M_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}__r.isMDXComponent=!0;const w_r={toc:[]},T_r="wrapper";function C_r(e){let{components:n,...t}=e;return(0,s.yg)(T_r,(0,p.A)({},w_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}C_r.isMDXComponent=!0;const x_r={toc:[]},A_r="wrapper";function v_r(e){let{components:n,...t}=e;return(0,s.yg)(A_r,(0,p.A)({},x_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}v_r.isMDXComponent=!0;const L_r={toc:[]},b_r="wrapper";function N_r(e){let{components:n,...t}=e;return(0,s.yg)(b_r,(0,p.A)({},L_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}N_r.isMDXComponent=!0;const k_r={toc:[]},z_r="wrapper";function P_r(e){let{components:n,...t}=e;return(0,s.yg)(z_r,(0,p.A)({},k_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}P_r.isMDXComponent=!0;const I_r={toc:[]},R_r="wrapper";function W_r(e){let{components:n,...t}=e;return(0,s.yg)(R_r,(0,p.A)({},I_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}W_r.isMDXComponent=!0;const S_r={toc:[]},B_r="wrapper";function G_r(e){let{components:n,...t}=e;return(0,s.yg)(B_r,(0,p.A)({},S_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}G_r.isMDXComponent=!0;const E_r={toc:[]},O_r="wrapper";function U_r(e){let{components:n,...t}=e;return(0,s.yg)(O_r,(0,p.A)({},E_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}U_r.isMDXComponent=!0;const F_r={toc:[]},V_r="wrapper";function q_r(e){let{components:n,...t}=e;return(0,s.yg)(V_r,(0,p.A)({},F_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}q_r.isMDXComponent=!0;const j_r={toc:[]},H_r="wrapper";function Y_r(e){let{components:n,...t}=e;return(0,s.yg)(H_r,(0,p.A)({},j_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Y_r.isMDXComponent=!0;const Q_r={toc:[]},$_r="wrapper";function K_r(e){let{components:n,...t}=e;return(0,s.yg)($_r,(0,p.A)({},Q_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}K_r.isMDXComponent=!0;const J_r={toc:[]},Z_r="wrapper";function ewr(e){let{components:n,...t}=e;return(0,s.yg)(Z_r,(0,p.A)({},J_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ewr.isMDXComponent=!0;const nwr={toc:[]},twr="wrapper";function owr(e){let{components:n,...t}=e;return(0,s.yg)(twr,(0,p.A)({},nwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}owr.isMDXComponent=!0;const pwr={toc:[]},rwr="wrapper";function swr(e){let{components:n,...t}=e;return(0,s.yg)(rwr,(0,p.A)({},pwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given t value."))}swr.isMDXComponent=!0;const cwr={toc:[]},awr="wrapper";function iwr(e){let{components:n,...t}=e;return(0,s.yg)(awr,(0,p.A)({},cwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}iwr.isMDXComponent=!0;const lwr={toc:[]},uwr="wrapper";function mwr(e){let{components:n,...t}=e;return(0,s.yg)(uwr,(0,p.A)({},lwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}mwr.isMDXComponent=!0;const ywr={toc:[]},dwr="wrapper";function hwr(e){let{components:n,...t}=e;return(0,s.yg)(dwr,(0,p.A)({},ywr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}hwr.isMDXComponent=!0;const gwr={toc:[]},fwr="wrapper";function Dwr(e){let{components:n,...t}=e;return(0,s.yg)(fwr,(0,p.A)({},gwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.yg)("p",null,"Source code liberally taken from:\n",(0,s.yg)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}Dwr.isMDXComponent=!0;const Mwr={toc:[]},Xwr="wrapper";function _wr(e){let{components:n,...t}=e;return(0,s.yg)(Xwr,(0,p.A)({},Mwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}_wr.isMDXComponent=!0;const wwr={toc:[]},Twr="wrapper";function Cwr(e){let{components:n,...t}=e;return(0,s.yg)(Twr,(0,p.A)({},wwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Cwr.isMDXComponent=!0;const xwr={toc:[]},Awr="wrapper";function vwr(e){let{components:n,...t}=e;return(0,s.yg)(Awr,(0,p.A)({},xwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}vwr.isMDXComponent=!0;const Lwr={toc:[]},bwr="wrapper";function Nwr(e){let{components:n,...t}=e;return(0,s.yg)(bwr,(0,p.A)({},Lwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Nwr.isMDXComponent=!0;const kwr={toc:[]},zwr="wrapper";function Pwr(e){let{components:n,...t}=e;return(0,s.yg)(zwr,(0,p.A)({},kwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}Pwr.isMDXComponent=!0;const Iwr={toc:[]},Rwr="wrapper";function Wwr(e){let{components:n,...t}=e;return(0,s.yg)(Rwr,(0,p.A)({},Iwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}Wwr.isMDXComponent=!0;const Swr={toc:[]},Bwr="wrapper";function Gwr(e){let{components:n,...t}=e;return(0,s.yg)(Bwr,(0,p.A)({},Swr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Gwr.isMDXComponent=!0;const Ewr={toc:[]},Owr="wrapper";function Uwr(e){let{components:n,...t}=e;return(0,s.yg)(Owr,(0,p.A)({},Ewr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}Uwr.isMDXComponent=!0;const Fwr={toc:[]},Vwr="wrapper";function qwr(e){let{components:n,...t}=e;return(0,s.yg)(Vwr,(0,p.A)({},Fwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}qwr.isMDXComponent=!0;const jwr={toc:[]},Hwr="wrapper";function Ywr(e){let{components:n,...t}=e;return(0,s.yg)(Hwr,(0,p.A)({},jwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The cubic coefficient"))}Ywr.isMDXComponent=!0;const Qwr={toc:[]},$wr="wrapper";function Kwr(e){let{components:n,...t}=e;return(0,s.yg)($wr,(0,p.A)({},Qwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The degree of the polynomial"))}Kwr.isMDXComponent=!0;const Jwr={toc:[]},Zwr="wrapper";function eTr(e){let{components:n,...t}=e;return(0,s.yg)(Zwr,(0,p.A)({},Jwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the nth derivative of the polynomial."))}eTr.isMDXComponent=!0;const nTr={toc:[]},tTr="wrapper";function oTr(e){let{components:n,...t}=e;return(0,s.yg)(tTr,(0,p.A)({},nTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of times to differentiate the polynomial."))}oTr.isMDXComponent=!0;const pTr={toc:[]},rTr="wrapper";function sTr(e){let{components:n,...t}=e;return(0,s.yg)(rTr,(0,p.A)({},pTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given value t."))}sTr.isMDXComponent=!0;const cTr={toc:[]},aTr="wrapper";function iTr(e){let{components:n,...t}=e;return(0,s.yg)(aTr,(0,p.A)({},cTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to sample at"))}iTr.isMDXComponent=!0;const lTr={toc:[]},uTr="wrapper";function mTr(e){let{components:n,...t}=e;return(0,s.yg)(uTr,(0,p.A)({},lTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}mTr.isMDXComponent=!0;const yTr={toc:[]},dTr="wrapper";function hTr(e){let{components:n,...t}=e;return(0,s.yg)(dTr,(0,p.A)({},yTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to sample at"))}hTr.isMDXComponent=!0;const gTr={toc:[]},fTr="wrapper";function DTr(e){let{components:n,...t}=e;return(0,s.yg)(fTr,(0,p.A)({},gTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The derivative of the polynomial to sample from"))}DTr.isMDXComponent=!0;const MTr={toc:[]},XTr="wrapper";function _Tr(e){let{components:n,...t}=e;return(0,s.yg)(XTr,(0,p.A)({},MTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the local extrema of the polynomial."))}_Tr.isMDXComponent=!0;const wTr={toc:[]},TTr="wrapper";function CTr(e){let{components:n,...t}=e;return(0,s.yg)(TTr,(0,p.A)({},wTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}CTr.isMDXComponent=!0;const xTr={toc:[]},ATr="wrapper";function vTr(e){let{components:n,...t}=e;return(0,s.yg)(ATr,(0,p.A)({},xTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the output value range within the unit interval."))}vTr.isMDXComponent=!0;const LTr={toc:[]},bTr="wrapper";function NTr(e){let{components:n,...t}=e;return(0,s.yg)(bTr,(0,p.A)({},LTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}NTr.isMDXComponent=!0;const kTr={toc:[]},zTr="wrapper";function PTr(e){let{components:n,...t}=e;return(0,s.yg)(zTr,(0,p.A)({},kTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the roots (values where this polynomial = 0)."))}PTr.isMDXComponent=!0;const ITr={toc:[]},RTr="wrapper";function WTr(e){let{components:n,...t}=e;return(0,s.yg)(RTr,(0,p.A)({},ITr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}WTr.isMDXComponent=!0;const STr={toc:[]},BTr="wrapper";function GTr(e){let{components:n,...t}=e;return(0,s.yg)(BTr,(0,p.A)({},STr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The point at which to split the polynomial."))}GTr.isMDXComponent=!0;const ETr={toc:[]},OTr="wrapper";function UTr(e){let{components:n,...t}=e;return(0,s.yg)(OTr,(0,p.A)({},ETr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a constant polynomial"))}UTr.isMDXComponent=!0;const FTr={toc:[]},VTr="wrapper";function qTr(e){let{components:n,...t}=e;return(0,s.yg)(VTr,(0,p.A)({},FTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}qTr.isMDXComponent=!0;const jTr={toc:[]},HTr="wrapper";function YTr(e){let{components:n,...t}=e;return(0,s.yg)(HTr,(0,p.A)({},jTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a cubic polynomial"))}YTr.isMDXComponent=!0;const QTr={toc:[]},$Tr="wrapper";function KTr(e){let{components:n,...t}=e;return(0,s.yg)($Tr,(0,p.A)({},QTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}KTr.isMDXComponent=!0;const JTr={toc:[]},ZTr="wrapper";function eCr(e){let{components:n,...t}=e;return(0,s.yg)(ZTr,(0,p.A)({},JTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}eCr.isMDXComponent=!0;const nCr={toc:[]},tCr="wrapper";function oCr(e){let{components:n,...t}=e;return(0,s.yg)(tCr,(0,p.A)({},nCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}oCr.isMDXComponent=!0;const pCr={toc:[]},rCr="wrapper";function sCr(e){let{components:n,...t}=e;return(0,s.yg)(rCr,(0,p.A)({},pCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The cubic coefficient"))}sCr.isMDXComponent=!0;const cCr={toc:[]},aCr="wrapper";function iCr(e){let{components:n,...t}=e;return(0,s.yg)(aCr,(0,p.A)({},cCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a linear polynomial"))}iCr.isMDXComponent=!0;const lCr={toc:[]},uCr="wrapper";function mCr(e){let{components:n,...t}=e;return(0,s.yg)(uCr,(0,p.A)({},lCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}mCr.isMDXComponent=!0;const yCr={toc:[]},dCr="wrapper";function hCr(e){let{components:n,...t}=e;return(0,s.yg)(dCr,(0,p.A)({},yCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}hCr.isMDXComponent=!0;const gCr={toc:[]},fCr="wrapper";function DCr(e){let{components:n,...t}=e;return(0,s.yg)(fCr,(0,p.A)({},gCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a quadratic polynomial"))}DCr.isMDXComponent=!0;const MCr={toc:[]},XCr="wrapper";function _Cr(e){let{components:n,...t}=e;return(0,s.yg)(XCr,(0,p.A)({},MCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}_Cr.isMDXComponent=!0;const wCr={toc:[]},TCr="wrapper";function CCr(e){let{components:n,...t}=e;return(0,s.yg)(TCr,(0,p.A)({},wCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}CCr.isMDXComponent=!0;const xCr={toc:[]},ACr="wrapper";function vCr(e){let{components:n,...t}=e;return(0,s.yg)(ACr,(0,p.A)({},xCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}vCr.isMDXComponent=!0;const LCr={toc:[]},bCr="wrapper";function NCr(e){let{components:n,...t}=e;return(0,s.yg)(bCr,(0,p.A)({},LCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}NCr.isMDXComponent=!0;const kCr={toc:[]},zCr="wrapper";function PCr(e){let{components:n,...t}=e;return(0,s.yg)(zCr,(0,p.A)({},kCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}PCr.isMDXComponent=!0;const ICr={toc:[]},RCr="wrapper";function WCr(e){let{components:n,...t}=e;return(0,s.yg)(RCr,(0,p.A)({},ICr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given t value."))}WCr.isMDXComponent=!0;const SCr={toc:[]},BCr="wrapper";function GCr(e){let{components:n,...t}=e;return(0,s.yg)(BCr,(0,p.A)({},SCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}GCr.isMDXComponent=!0;const ECr={toc:[]},OCr="wrapper";function UCr(e){let{components:n,...t}=e;return(0,s.yg)(OCr,(0,p.A)({},ECr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}UCr.isMDXComponent=!0;const FCr={toc:[]},VCr="wrapper";function qCr(e){let{components:n,...t}=e;return(0,s.yg)(VCr,(0,p.A)({},FCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}qCr.isMDXComponent=!0;const jCr={toc:[]},HCr="wrapper";function YCr(e){let{components:n,...t}=e;return(0,s.yg)(HCr,(0,p.A)({},jCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.yg)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}YCr.isMDXComponent=!0;const QCr={toc:[]},$Cr="wrapper";function KCr(e){let{components:n,...t}=e;return(0,s.yg)($Cr,(0,p.A)({},QCr,t,{components:n,mdxType:"MDXLayout"}))}KCr.isMDXComponent=!0;const JCr={toc:[]},ZCr="wrapper";function exr(e){let{components:n,...t}=e;return(0,s.yg)(ZCr,(0,p.A)({},JCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}exr.isMDXComponent=!0;const nxr={toc:[]},txr="wrapper";function oxr(e){let{components:n,...t}=e;return(0,s.yg)(txr,(0,p.A)({},nxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots defining the spline"))}oxr.isMDXComponent=!0;const pxr={toc:[]},rxr="wrapper";function sxr(e){let{components:n,...t}=e;return(0,s.yg)(rxr,(0,p.A)({},pxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the spline should be closed or not"))}sxr.isMDXComponent=!0;const cxr={toc:[]},axr="wrapper";function ixr(e){let{components:n,...t}=e;return(0,s.yg)(axr,(0,p.A)({},cxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}ixr.isMDXComponent=!0;const lxr={toc:[]},uxr="wrapper";function mxr(e){let{components:n,...t}=e;return(0,s.yg)(uxr,(0,p.A)({},lxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}mxr.isMDXComponent=!0;const yxr={toc:[]},dxr="wrapper";function hxr(e){let{components:n,...t}=e;return(0,s.yg)(dxr,(0,p.A)({},yxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}hxr.isMDXComponent=!0;const gxr={toc:[]},fxr="wrapper";function Dxr(e){let{components:n,...t}=e;return(0,s.yg)(fxr,(0,p.A)({},gxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}Dxr.isMDXComponent=!0;const Mxr={toc:[]},Xxr="wrapper";function _xr(e){let{components:n,...t}=e;return(0,s.yg)(Xxr,(0,p.A)({},Mxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}_xr.isMDXComponent=!0;const wxr={toc:[]},Txr="wrapper";function Cxr(e){let{components:n,...t}=e;return(0,s.yg)(Txr,(0,p.A)({},wxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}Cxr.isMDXComponent=!0;const xxr={toc:[]},Axr="wrapper";function vxr(e){let{components:n,...t}=e;return(0,s.yg)(Axr,(0,p.A)({},xxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}vxr.isMDXComponent=!0;const Lxr={toc:[]},bxr="wrapper";function Nxr(e){let{components:n,...t}=e;return(0,s.yg)(bxr,(0,p.A)({},Lxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}Nxr.isMDXComponent=!0;const kxr={toc:[]},zxr="wrapper";function Pxr(e){let{components:n,...t}=e;return(0,s.yg)(zxr,(0,p.A)({},kxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Pxr.isMDXComponent=!0;const Ixr={toc:[]},Rxr="wrapper";function Wxr(e){let{components:n,...t}=e;return(0,s.yg)(Rxr,(0,p.A)({},Ixr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}Wxr.isMDXComponent=!0;const Sxr={toc:[]},Bxr="wrapper";function Gxr(e){let{components:n,...t}=e;return(0,s.yg)(Bxr,(0,p.A)({},Sxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Gxr.isMDXComponent=!0;const Exr={toc:[]},Oxr="wrapper";function Uxr(e){let{components:n,...t}=e;return(0,s.yg)(Oxr,(0,p.A)({},Exr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Uxr.isMDXComponent=!0;const Fxr={toc:[]},Vxr="wrapper";function qxr(e){let{components:n,...t}=e;return(0,s.yg)(Vxr,(0,p.A)({},Fxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}qxr.isMDXComponent=!0;const jxr={toc:[]},Hxr="wrapper";function Yxr(e){let{components:n,...t}=e;return(0,s.yg)(Hxr,(0,p.A)({},jxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.yg)("p",null,"By default, any property is cloneable."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Yxr.isMDXComponent=!0;const Qxr={toc:[]},$xr="wrapper";function Kxr(e){let{components:n,...t}=e;return(0,s.yg)($xr,(0,p.A)({},Qxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Kxr.isMDXComponent=!0;const Jxr={toc:[]},Zxr="wrapper";function eAr(e){let{components:n,...t}=e;return(0,s.yg)(Zxr,(0,p.A)({},Jxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a cloneable property decorator."))}eAr.isMDXComponent=!0;const nAr={toc:[]},tAr="wrapper";function oAr(e){let{components:n,...t}=e;return(0,s.yg)(tAr,(0,p.A)({},nAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the property should be cloneable."))}oAr.isMDXComponent=!0;const pAr={toc:[]},rAr="wrapper";function sAr(e){let{components:n,...t}=e;return(0,s.yg)(rAr,(0,p.A)({},pAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}sAr.isMDXComponent=!0;const cAr={toc:[]},aAr="wrapper";function iAr(e){let{components:n,...t}=e;return(0,s.yg)(aAr,(0,p.A)({},cAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}iAr.isMDXComponent=!0;const lAr={toc:[]},uAr="wrapper";function mAr(e){let{components:n,...t}=e;return(0,s.yg)(uAr,(0,p.A)({},lAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a compound property decorator."))}mAr.isMDXComponent=!0;const yAr={toc:[]},dAr="wrapper";function hAr(e){let{components:n,...t}=e;return(0,s.yg)(dAr,(0,p.A)({},yAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}hAr.isMDXComponent=!0;const gAr={toc:[]},fAr="wrapper";function DAr(e){let{components:n,...t}=e;return(0,s.yg)(fAr,(0,p.A)({},gAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.yg)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}DAr.isMDXComponent=!0;const MAr={toc:[]},XAr="wrapper";function _Ar(e){let{components:n,...t}=e;return(0,s.yg)(XAr,(0,p.A)({},MAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a computed method decorator."))}_Ar.isMDXComponent=!0;const wAr={toc:[]},TAr="wrapper";function CAr(e){let{components:n,...t}=e;return(0,s.yg)(TAr,(0,p.A)({},wAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the initial value of a property."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}CAr.isMDXComponent=!0;const xAr={toc:[]},AAr="wrapper";function vAr(e){let{components:n,...t}=e;return(0,s.yg)(AAr,(0,p.A)({},xAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}vAr.isMDXComponent=!0;const LAr={toc:[]},bAr="wrapper";function NAr(e){let{components:n,...t}=e;return(0,s.yg)(bAr,(0,p.A)({},LAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an initial signal value decorator."))}NAr.isMDXComponent=!0;const kAr={toc:[]},zAr="wrapper";function PAr(e){let{components:n,...t}=e;return(0,s.yg)(zAr,(0,p.A)({},kAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of the property."))}PAr.isMDXComponent=!0;const IAr={toc:[]},RAr="wrapper";function WAr(e){let{components:n,...t}=e;return(0,s.yg)(RAr,(0,p.A)({},IAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.yg)("p",null,"By default, any property is inspectable."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}WAr.isMDXComponent=!0;const SAr={toc:[]},BAr="wrapper";function GAr(e){let{components:n,...t}=e;return(0,s.yg)(BAr,(0,p.A)({},SAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}GAr.isMDXComponent=!0;const EAr={toc:[]},OAr="wrapper";function UAr(e){let{components:n,...t}=e;return(0,s.yg)(OAr,(0,p.A)({},EAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an inspectable property decorator."))}UAr.isMDXComponent=!0;const FAr={toc:[]},VAr="wrapper";function qAr(e){let{components:n,...t}=e;return(0,s.yg)(VAr,(0,p.A)({},FAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the property should be inspectable."))}qAr.isMDXComponent=!0;const jAr={toc:[]},HAr="wrapper";function YAr(e){let{components:n,...t}=e;return(0,s.yg)(HAr,(0,p.A)({},jAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}YAr.isMDXComponent=!0;const QAr={toc:[]},$Ar="wrapper";function KAr(e){let{components:n,...t}=e;return(0,s.yg)($Ar,(0,p.A)({},QAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}KAr.isMDXComponent=!0;const JAr={toc:[]},ZAr="wrapper";function evr(e){let{components:n,...t}=e;return(0,s.yg)(ZAr,(0,p.A)({},JAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal interpolation function decorator."))}evr.isMDXComponent=!0;const nvr={toc:[]},tvr="wrapper";function ovr(e){let{components:n,...t}=e;return(0,s.yg)(tvr,(0,p.A)({},nvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interpolation function for the property."))}ovr.isMDXComponent=!0;const pvr={toc:[]},rvr="wrapper";function svr(e){let{components:n,...t}=e;return(0,s.yg)(rvr,(0,p.A)({},pvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.yg)("p",null,"If the wrapper class has a method called ",(0,s.yg)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}svr.isMDXComponent=!0;const cvr={toc:[]},avr="wrapper";function ivr(e){let{components:n,...t}=e;return(0,s.yg)(avr,(0,p.A)({},cvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}ivr.isMDXComponent=!0;const lvr={toc:[]},uvr="wrapper";function mvr(e){let{components:n,...t}=e;return(0,s.yg)(uvr,(0,p.A)({},lvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal parser decorator."))}mvr.isMDXComponent=!0;const yvr={toc:[]},dvr="wrapper";function hvr(e){let{components:n,...t}=e;return(0,s.yg)(dvr,(0,p.A)({},yvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The wrapper class for the property."))}hvr.isMDXComponent=!0;const gvr={toc:[]},fvr="wrapper";function Dvr(e){let{components:n,...t}=e;return(0,s.yg)(fvr,(0,p.A)({},gvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns the given property into a signal."),(0,s.yg)("p",null,"The class using this decorator can implement the following methods:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}Dvr.isMDXComponent=!0;const Mvr={toc:[]},Xvr="wrapper";function _vr(e){let{components:n,...t}=e;return(0,s.yg)(Xvr,(0,p.A)({},Mvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}_vr.isMDXComponent=!0;const wvr={toc:[]},Tvr="wrapper";function Cvr(e){let{components:n,...t}=e;return(0,s.yg)(Tvr,(0,p.A)({},wvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal decorator."))}Cvr.isMDXComponent=!0;const xvr={toc:[]},Avr="wrapper";function vvr(e){let{components:n,...t}=e;return(0,s.yg)(Avr,(0,p.A)({},xvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut decorator for setting both the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.yg)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.yg)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.yg)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.yg)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}vvr.isMDXComponent=!0;const Lvr={toc:[]},bvr="wrapper";function Nvr(e){let{components:n,...t}=e;return(0,s.yg)(bvr,(0,p.A)({},Lvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Nvr.isMDXComponent=!0;const kvr={toc:[]},zvr="wrapper";function Pvr(e){let{components:n,...t}=e;return(0,s.yg)(zvr,(0,p.A)({},kvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal wrapper decorator."))}Pvr.isMDXComponent=!0;const Ivr={toc:[]},Rvr="wrapper";function Wvr(e){let{components:n,...t}=e;return(0,s.yg)(Rvr,(0,p.A)({},Ivr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The wrapper class for the property."))}Wvr.isMDXComponent=!0;const Svr={toc:[]},Bvr="wrapper";function Gvr(e){let{components:n,...t}=e;return(0,s.yg)(Bvr,(0,p.A)({},Svr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A unified abstraction for all CSS filters."))}Gvr.isMDXComponent=!0;const Evr={toc:[]},Ovr="wrapper";function Uvr(e){let{components:n,...t}=e;return(0,s.yg)(Ovr,(0,p.A)({},Evr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the desired length is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}Uvr.isMDXComponent=!0;const Fvr={toc:[]},Vvr="wrapper";function qvr(e){let{components:n,...t}=e;return(0,s.yg)(Vvr,(0,p.A)({},Fvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a desired length used internally by layout Nodes."))}qvr.isMDXComponent=!0;const jvr={toc:[]},Hvr="wrapper";function Yvr(e){let{components:n,...t}=e;return(0,s.yg)(Hvr,(0,p.A)({},jvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value can be either:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'"))))}Yvr.isMDXComponent=!0;const Qvr={toc:[]},$vr="wrapper";function Kvr(e){let{components:n,...t}=e;return(0,s.yg)($vr,(0,p.A)({},Qvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a length used by most layout properties."))}Kvr.isMDXComponent=!0;const Jvr={toc:[]},Zvr="wrapper";function eLr(e){let{components:n,...t}=e;return(0,s.yg)(Zvr,(0,p.A)({},Jvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a length limit used by layout properties such as ",(0,s.yg)("inlineCode",{parentName:"p"},"max-width"),"."))}eLr.isMDXComponent=!0;const nLr={toc:[]},tLr="wrapper";function oLr(e){let{components:n,...t}=e;return(0,s.yg)(tLr,(0,p.A)({},nLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.yg)("inlineCode",{parentName:"a"},"blur"))," filter."))}oLr.isMDXComponent=!0;const pLr={toc:[]},rLr="wrapper";function sLr(e){let{components:n,...t}=e;return(0,s.yg)(rLr,(0,p.A)({},pLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter in pixels."))}sLr.isMDXComponent=!0;const cLr={toc:[]},aLr="wrapper";function iLr(e){let{components:n,...t}=e;return(0,s.yg)(aLr,(0,p.A)({},cLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.yg)("inlineCode",{parentName:"a"},"brightness"))," filter."))}iLr.isMDXComponent=!0;const lLr={toc:[]},uLr="wrapper";function mLr(e){let{components:n,...t}=e;return(0,s.yg)(uLr,(0,p.A)({},lLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}mLr.isMDXComponent=!0;const yLr={toc:[]},dLr="wrapper";function hLr(e){let{components:n,...t}=e;return(0,s.yg)(dLr,(0,p.A)({},yLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.yg)("inlineCode",{parentName:"a"},"contrast"))," filter."))}hLr.isMDXComponent=!0;const gLr={toc:[]},fLr="wrapper";function DLr(e){let{components:n,...t}=e;return(0,s.yg)(fLr,(0,p.A)({},gLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}DLr.isMDXComponent=!0;const MLr={toc:[]},XLr="wrapper";function _Lr(e){let{components:n,...t}=e;return(0,s.yg)(XLr,(0,p.A)({},MLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.yg)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}_Lr.isMDXComponent=!0;const wLr={toc:[]},TLr="wrapper";function CLr(e){let{components:n,...t}=e;return(0,s.yg)(TLr,(0,p.A)({},wLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}CLr.isMDXComponent=!0;const xLr={toc:[]},ALr="wrapper";function vLr(e){let{components:n,...t}=e;return(0,s.yg)(ALr,(0,p.A)({},xLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.yg)("inlineCode",{parentName:"a"},"hue"))," filter."))}vLr.isMDXComponent=!0;const LLr={toc:[]},bLr="wrapper";function NLr(e){let{components:n,...t}=e;return(0,s.yg)(bLr,(0,p.A)({},LLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter in degrees."))}NLr.isMDXComponent=!0;const kLr={toc:[]},zLr="wrapper";function PLr(e){let{components:n,...t}=e;return(0,s.yg)(zLr,(0,p.A)({},kLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.yg)("inlineCode",{parentName:"a"},"invert"))," filter."))}PLr.isMDXComponent=!0;const ILr={toc:[]},RLr="wrapper";function WLr(e){let{components:n,...t}=e;return(0,s.yg)(RLr,(0,p.A)({},ILr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}WLr.isMDXComponent=!0;const SLr={toc:[]},BLr="wrapper";function GLr(e){let{components:n,...t}=e;return(0,s.yg)(BLr,(0,p.A)({},SLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.yg)("inlineCode",{parentName:"a"},"saturate"))," filter."))}GLr.isMDXComponent=!0;const ELr={toc:[]},OLr="wrapper";function ULr(e){let{components:n,...t}=e;return(0,s.yg)(OLr,(0,p.A)({},ELr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}ULr.isMDXComponent=!0;const FLr={toc:[]},VLr="wrapper";function qLr(e){let{components:n,...t}=e;return(0,s.yg)(VLr,(0,p.A)({},FLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.yg)("inlineCode",{parentName:"a"},"sepia"))," filter."))}qLr.isMDXComponent=!0;const jLr={toc:[]},HLr="wrapper";function YLr(e){let{components:n,...t}=e;return(0,s.yg)(HLr,(0,p.A)({},jLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}YLr.isMDXComponent=!0;const QLr={toc:[]},$Lr="wrapper";function KLr(e){let{components:n,...t}=e;return(0,s.yg)($Lr,(0,p.A)({},QLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}KLr.isMDXComponent=!0;const JLr={toc:[]},ZLr="wrapper";function ebr(e){let{components:n,...t}=e;return(0,s.yg)(ZLr,(0,p.A)({},JLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback in the context of this scene."))}ebr.isMDXComponent=!0;const nbr={toc:[]},tbr="wrapper";function obr(e){let{components:n,...t}=e;return(0,s.yg)(tbr,(0,p.A)({},nbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}obr.isMDXComponent=!0;const pbr={toc:[]},rbr="wrapper";function sbr(e){let{components:n,...t}=e;return(0,s.yg)(rbr,(0,p.A)({},pbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the view."),(0,s.yg)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.yg)("p",null,"Can modify the state of the view."))}sbr.isMDXComponent=!0;const cbr={toc:[]},abr="wrapper";function ibr(e){let{components:n,...t}=e;return(0,s.yg)(abr,(0,p.A)({},cbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a predicate that checks if the given object is an instance of the\ngiven class."))}ibr.isMDXComponent=!0;const lbr={toc:[]},ubr="wrapper";function mbr(e){let{components:n,...t}=e;return(0,s.yg)(ubr,(0,p.A)({},lbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class to check against."))}function ybr(e){let{id:n}=e;const t=o[n]??r.Fragment;return r.createElement(t,null)}mbr.isMDXComponent=!0},5063:(e,n,t)=>{t.d(n,{A:()=>i});var o=t(6476),p=t(3443),r=t(7576),s=t(53),c=t(4041);const a={toggle:"toggle_S_IX",collapsed:"collapsed_wdUB",collapse:"collapse_TjTN",inverse:"inverse_g6vW",clearFix:"clearFix_HQ1T"};function i(e){let{comment:n,full:t=!0}=e;const o=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@remarks"===n}))),[n]);return c.createElement(c.Fragment,null,t&&c.createElement(l,{comment:n}),c.createElement(p.A,{id:n?.summaryId}),c.createElement(p.A,{id:o?.contentId}),t&&c.createElement(u,{comment:n}))}function l(e){let{comment:n}=e;return(0,c.useMemo)((()=>n?.modifierTags?.includes("@experimental")),[n])?c.createElement(r.A,null):null}function u(e){let{comment:n}=e;const[t,r]=(0,c.useState)(!0),i=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@preview"===n}))),[n]),l=(0,c.useMemo)((()=>n?.blockTags?.filter((e=>{let{tag:n}=e;return"@example"===n}))??[]),[n]),u=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@defaultValue"===n}))),[n]),m=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@deprecated"===n}))),[n]),y=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@see"===n}))),[n]);return c.createElement(c.Fragment,null,c.createElement(p.A,{id:i?.contentId}),l.length>0&&c.createElement(c.Fragment,null,c.createElement("h4",null,c.createElement("a",{className:(0,s.A)(a.toggle,t&&a.collapsed),onClick:e=>{e.preventDefault(),r(!t)},href:"#"},"Examples")),c.createElement(o.N,{lazy:!0,as:"div",collapsed:t},c.createElement("div",{className:a.collapse},l.map((e=>c.createElement(p.A,{key:e.contentId,id:e.contentId})))),c.createElement("div",{className:a.clearFix})),c.createElement("div",{className:(0,s.A)(a.clearFix,a.inverse)})),u&&c.createElement(c.Fragment,null,"Default Value:"," ",c.createElement("code",null,u.content.map((e=>e.text)).join(""))),m&&c.createElement(c.Fragment,null,c.createElement("h4",null,"Deprecated"),c.createElement(p.A,{id:m.contentId})),y&&c.createElement(c.Fragment,null,c.createElement("h4",null,"See also"),c.createElement(p.A,{id:y.contentId})))}},1125:(e,n,t)=>{t.d(n,{A:()=>Be});var o=t(1282),p=t(4905),r=t(9575),s=t(4041);function c(e){let{width:n=24,height:t=24,...o}=e;return s.createElement("svg",(0,r.A)({width:n,height:t,"aria-hidden":"true",viewBox:"0 0 24 24"},o),s.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=t(4593),l=t(53);function u(e){let{children:n,highlight:t,onClick:r,link:u}=e;const m=(0,p.f)(),y=(0,i.o0)();return s.createElement("div",{className:(0,l.A)(o.A.codeBlockContent,a.codeBlock,t&&a.highlight,r&&a.pointer)},s.createElement("pre",{onClick:r,onKeyDown:e=>{"Enter"===e.key&&r?.()},tabIndex:0,ref:m.codeBlockRef,className:(0,l.A)(o.A.codeBlock,"thin-scrollbar")},s.createElement("code",{className:o.A.codeBlockLines,style:y},n)),u&&s.createElement("div",{className:o.A.buttonGroup},s.createElement("button",{title:"Go to source",className:"clean-btn",onClick:e=>{e.preventDefault(),window.open(u,"_blank")}},s.createElement(c,{width:18,height:18}))))}var m=t(6333);function y(e){let{children:n}=e;return s.createElement(m.A,{as:"div",className:(0,l.A)(a.codeBlockContainer,"language-typescript")},n)}function d(e){let{children:n}=e;const t=(0,s.useRef)();return(0,s.useLayoutEffect)((()=>{if(!t.current)return;const e=t.current.closest("pre");if(e.scrollWidth>e.clientWidth){const n=Array.from(t.current.querySelectorAll(`.${a.elements}`)).sort(((e,n)=>function(e,n){return e>n?1:e<n?-1:0}(n.innerText.length,e.innerText.length)));for(;e.scrollWidth>e.clientWidth&&n.length>0;)n.shift().classList.add(a.wrap)}})),s.createElement(s.Fragment,null,n&&s.createElement("span",{ref:t,className:(0,l.A)(a.line,"token-line")},n),s.createElement("br",null))}var h=t(5063),g=t(9659);function f(e){let{width:n=24,height:t=24,...o}=e;return s.createElement("svg",(0,r.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0},o),s.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}var D=t(6382);const M={header:"header_nSmr",filters:"filters_z1iC",icon:"icon_ROIU"};function X(){const e=(0,s.useRef)(null),[n,t]=(0,s.useState)(!1),[o,p]=(0,D.R7)();return(0,s.useEffect)((()=>{const n=n=>{e.current&&!e.current.contains(n.target)&&t(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[e]),s.createElement(s.Fragment,null,s.createElement("div",{ref:e,className:(0,l.A)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},s.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:e=>{e.preventDefault(),t(!n)},onKeyDown:e=>{"Enter"===e.key&&(e.preventDefault(),t(!n))}},"Filters",s.createElement(f,{className:M.icon})),s.createElement("ul",{className:"dropdown__menu"},s.createElement("li",null,s.createElement("label",{htmlFor:"private",className:(0,l.A)("dropdown__link",o.private&&"dropdown__link--active")},s.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:o.private,onChange:e=>{p({...o,private:e.target.checked})}}),"Protected members")),s.createElement("li",{onKeyDown:e=>{"Tab"===e.key&&t(!1)}},s.createElement("label",{htmlFor:"inherited",className:(0,l.A)("dropdown__link",o.inherited&&"dropdown__link--active")},s.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:o.inherited,onChange:e=>{p({...o,inherited:e.target.checked})}}),"Inherited members")))))}function _(e){let{children:n,kind:t}=e;return t===g.k.Class||t===g.k.Interface?s.createElement("div",{className:(0,l.A)("row",M.header)},s.createElement("div",{className:(0,l.A)("col",M.filters)},s.createElement(X,null)),s.createElement("div",{className:"col"},n)):s.createElement(s.Fragment,null,n)}var w=t(6090),T=t(9631);function C(e){let{children:n,type:t,to:o,id:p,tooltip:c}=e;const a=(0,i.J2)(t);return o?s.createElement(T.A,(0,r.A)({id:p,to:o,"data-tooltip":c},a),n):s.createElement("span",(0,r.A)({id:p},a),n)}let x=function(e){return e[e.None=0]="None",e[e.Angle=1]="Angle",e[e.Curly=2]="Curly",e[e.Square=3]="Square",e[e.Parentheses=4]="Parentheses",e}({}),A=function(e){return e.Comma=", ",e.Pipe=" | ",e.Ampersand=" & ",e}({});const v={[x.None]:a.none,[x.Angle]:a.angle,[x.Curly]:a.curly,[x.Square]:a.square,[x.Parentheses]:a.parentheses};function L(e){let{children:n,type:t,separator:o=A.Comma}=e;return s.createElement("span",{className:(0,l.A)(a.list,v[t??x.None])},s.createElement("span",{className:(0,l.A)(a.elements,o!==A.Comma&&a.left)},(Array.isArray(n)?n:[n]).flatMap(((e,n)=>s.createElement("span",{"data-separator":o,key:n,className:a.element},e)))))}function b(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.elementType}),"[]")}function N(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.checkType}),s.createElement(C,{type:"keyword"}," extends "),s.createElement(oe,{type:n.extendsType})," ? ",s.createElement(oe,{type:n.trueType})," : ",s.createElement(oe,{type:n.falseType}))}function k(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.objectType}),"[",s.createElement(oe,{type:n.indexType}),"]")}function z(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"infer "),s.createElement(C,{type:"constant"},n.name))}function P(e){let{type:n}=e;return s.createElement(L,{type:x.Parentheses,separator:A.Ampersand},n.types.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))}function I(e){let{type:n}=e;return s.createElement(C,{type:"keyword"},n.name)}function R(e){let{type:n}=e;const[t,o]=(0,s.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return s.createElement(C,{type:o},t)}function W(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(L,{type:x.Curly},s.createElement(s.Fragment,null,"[",s.createElement(C,{type:"class"},n.parameter),s.createElement(C,{type:"keyword"}," in "),s.createElement(oe,{type:n.parameterType}),"]: ",s.createElement(oe,{type:n.templateType}))))}function S(e){let{type:n}=e;return s.createElement(s.Fragment,null,n.name,": ",s.createElement(oe,{type:n.element}))}function B(e){let{type:n}=e;return n.asserts?s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"asserts "),s.createElement(C,null,n.name," ")):s.createElement(s.Fragment,null,s.createElement(C,null,n.name," "),s.createElement(C,{type:"keyword"},"is "),s.createElement(oe,{type:n.targetType}))}function G(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"typeof "),s.createElement(oe,{type:n.queryType}))}function E(e){let{flags:n,explicitAccessModifier:t}=e;const o=[];return n?.isAbstract&&o.push("abstract"),n?.isStatic&&o.push("static"),n?.isConst&&o.push("const"),n?.isReadonly&&o.push("readonly"),n?.isPrivate&&o.push("private"),n?.isProtected&&o.push("protected"),(n?.isPublic||t&&!n?.isProtected&&!n?.isPrivate)&&o.push("public"),s.createElement(s.Fragment,null,o.map((e=>s.createElement(C,{key:e,type:"keyword"},e," "))))}function O(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),n.varianceModifier&&s.createElement(C,{type:"keyword"},n.varianceModifier," "),s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&s.createElement(s.Fragment,null," extends ",s.createElement(oe,{type:n.type})),n.default&&s.createElement(s.Fragment,null," = ",s.createElement(oe,{type:n.default})))}var U=t(8675);const F={[g.k.Namespace]:"namespace",[g.k.Enum]:"enum",[g.k.Class]:"class",[g.k.Interface]:"interface"};function V(e){let{reflection:n}=e;const t=(0,U.as)();return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),s.createElement(C,{type:"keyword"},F[n.kind]," "),s.createElement(C,{type:"class-name"},n.name),!!n.typeParameters?.length&&s.createElement(L,{type:x.Angle},n.typeParameters.map((e=>s.createElement(O,{key:e.id,reflection:t(e)}))))," ",!!n.extendedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"extends "),s.createElement(L,null,n.extendedTypes.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))),!!n.implementedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"implements "),s.createElement(L,null,n.implementedTypes.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))))}function q(e){let{reflection:n}=e;const t="__namedParameters"===n.name?"{...}":n.name;return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),n.flags.isRest&&"...",s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},t),n.flags.isOptional&&"?",": ",n.type&&s.createElement(oe,{type:n.type}),n.defaultValue&&s.createElement(s.Fragment,null," = ",s.createElement(C,{type:"plain"},n.defaultValue)))}function j(e){let{reflection:n,flags:t}=e;const o=(0,U.as)(),p="__type"===n.name;return s.createElement(s.Fragment,null,s.createElement(E,{flags:t??n.flags,explicitAccessModifier:!p}),n.kind===g.k.GetSignature&&s.createElement(C,{type:"keyword"},"get "),n.kind===g.k.SetSignature&&s.createElement(C,{type:"keyword"},"set "),n.overwrites&&s.createElement(s.Fragment,null,s.createElement(C,{to:n.overwrites.externalUrl??(0,U.ID)(o(n.overwrites.id)),type:"keyword"},"override")," "),n.kind===g.k.ConstructorSignature?s.createElement(s.Fragment,null,s.createElement(C,{to:"#",type:"keyword"},"new")," ",s.createElement(C,{type:"plain"},n.type.name)):p?"":s.createElement(C,{type:"function"},n.name),!!n.typeParameter?.length&&s.createElement(L,{type:x.Angle},n.typeParameter.map((e=>s.createElement(O,{key:e.id,reflection:o(e)})))),n.parameters?.length?s.createElement(L,{type:x.Parentheses},n.parameters.map((e=>s.createElement(q,{key:e,reflection:o(e)})))):"()",n.type&&s.createElement(s.Fragment,null,p?" => ":": ",s.createElement(oe,{type:n.type})))}function H(e){let{reflection:n}=e;const t=n.signatures?.[0]??n.getSignature??n.setSignature??n.indexSignature;return s.createElement(j,{reflection:t})}function Y(e){let{reflection:n}=e;return s.createElement(q,{reflection:n})}function Q(e){let{reflection:n}=e;const t=(0,U.as)();return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),s.createElement(C,{type:"keyword"},"type "),s.createElement(C,{type:"class-name"},n.name),n.typeParameters&&s.createElement(L,{type:x.Angle},n.typeParameters.map((e=>s.createElement(O,{key:e.id,reflection:t(e)}))))," = ",s.createElement(oe,{type:n.type}))}function $(e){let{reflection:n}=e;const t=(0,U.as)();if(n.signatures){let e=n.signatures[0];if(e?.kind||(e=t(e)),e)return s.createElement(j,{reflection:e})}return n.children?s.createElement(L,{type:x.Curly},n.children.map((e=>s.createElement(K,{key:e.id,reflection:t(e)})))):s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"unknown"))}function K(e){let{reflection:n}=e;const t=(0,s.useMemo)((()=>{switch(n.kind){case g.k.Project:case g.k.Module:case g.k.EnumMember:case g.k.Variable:case g.k.Function:break;case g.k.Namespace:case g.k.Enum:case g.k.Class:case g.k.Interface:return V;case g.k.Constructor:return j;case g.k.Property:return Y;case g.k.Method:return H;case g.k.CallSignature:case g.k.IndexSignature:case g.k.ConstructorSignature:case g.k.Parameter:break;case g.k.TypeLiteral:return $;case g.k.TypeParameter:return O;case g.k.Accessor:case g.k.GetSignature:case g.k.SetSignature:case g.k.ObjectLiteral:break;case g.k.TypeAlias:return Q;case g.k.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return s.createElement(t,{reflection:n})}function J(e){let{type:n}=e;const t=(0,U.as)();return s.createElement(K,{reflection:t(n.declaration)})}function Z(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"string"},"`",n.head),n.tail.map(((e,n)=>{let[t,o]=e;return s.createElement(s.Fragment,null,"${",s.createElement(oe,{key:n,type:t}),"}",s.createElement(C,{type:"string"},o))})),s.createElement(C,{type:"string"},"`"))}function ee(e){let{type:n}=e;return n.elements?s.createElement(L,{type:x.Square},n.elements.map(((e,n)=>s.createElement(oe,{key:n,type:e})))):s.createElement(s.Fragment,null,"[]")}function ne(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},n.operator," "),s.createElement(oe,{type:n.target}))}function te(e){let{type:n}=e;return s.createElement(L,{type:x.Parentheses,separator:A.Pipe},n.types.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))}function oe(e){const n=(0,s.useMemo)((()=>{switch(e.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return ne;case"conditional":return N;case"reflection":return J;case"query":return G;case"named-tuple-member":return S;case"union":return te;case"intrinsic":return I;case"literal":return R;case"reference":return pe;case"predicate":return B;case"tuple":return ee;case"array":return b;case"intersection":return P;case"inferred":return z;case"mapped":return W;case"template-literal":return Z;case"indexedAccess":return k}throw new Error(`Missing component for type: ${e.type.type}`)}),[e.type]);return s.createElement(n,e)}function pe(e){let{type:n}=e;const t=(0,U.gG)(n.project),o=t?.[n.id],p=n.externalUrl??(0,U.ID)(o);return s.createElement(s.Fragment,null,s.createElement(C,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!!n.typeArguments?.length&&s.createElement(L,{type:x.Angle},n.typeArguments.map(((e,n)=>s.createElement(oe,{key:n,type:e})))))}function re(e){let{group:n}=e;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?s.createElement(Be,{reflection:n.nested[0]}):s.createElement(s.Fragment,null,n.external.length>0&&s.createElement("ul",null,n.external.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e})))))),n.nested.length>0&&n.nested.map(((e,n)=>s.createElement(s.Fragment,{key:e.id},n>0&&s.createElement("hr",null),s.createElement(Be,{reflection:e})))))}var se=t(4441),ce=t(2663);const ae={tabItem:"tabItem_OMyP"};function ie(e){let{children:n,hidden:t,className:o}=e;return s.createElement("div",{role:"tabpanel",className:(0,ce.A)(ae.tabItem,o),hidden:t},n)}var le=t(1034),ue=t(6703),me=t(6004),ye=t(2096);function de(e){return function(e){return s.Children.map(e,(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:o,default:p}}=e;return{value:n,label:t,attributes:o,default:p}}))}function he(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??de(t);return function(e){const n=(0,me.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function ge(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function fe(e){let{queryString:n=!1,groupId:t}=e;const o=(0,w.W6)(),p=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,ue.aZ)(p),(0,s.useCallback)((e=>{if(!p)return;const n=new URLSearchParams(o.location.search);n.set(p,e),o.replace({...o.location,search:n.toString()})}),[p,o])]}function De(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,p=he(e),[r,c]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!ge({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=t.find((e=>e.default))??t[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:p}))),[a,i]=fe({queryString:t,groupId:o}),[l,u]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[o,p]=(0,ye.Dv)(t);return[o,(0,s.useCallback)((e=>{t&&p.set(e)}),[t,p])]}({groupId:o}),m=(()=>{const e=a??l;return ge({value:e,tabValues:p})?e:null})();(0,s.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!ge({value:e,tabValues:p}))throw new Error(`Can't select invalid tab value=${e}`);c(e),i(e),u(e)}),[i,u,p]),tabValues:p}}var Me=t(213);const Xe={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};function _e(e){let{className:n,block:t,selectedValue:o,selectValue:p,tabValues:c}=e;const a=[],{blockElementScrollPositionUntilNextRender:i}=(0,le.a_)(),l=e=>{const n=e.currentTarget,t=a.indexOf(n),r=c[t].value;r!==o&&(i(n),p(r))},u=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;n=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;n=a[t]??a[a.length-1];break}}n?.focus()};return s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,ce.A)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:p}=e;return s.createElement("li",(0,r.A)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:e=>a.push(e),onKeyDown:u,onClick:l},p,{className:(0,ce.A)("tabs__item",Xe.tabItem,p?.className,{"tabs__item--active":o===n})}),t??n)})))}function we(e){let{lazy:n,children:t,selectedValue:o}=e;const p=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=p.find((e=>e.props.value===o));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return s.createElement("div",{className:"margin-top--md"},p.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==o}))))}function Te(e){const n=De(e);return s.createElement("div",{className:(0,ce.A)("tabs-container",Xe.tabList)},s.createElement(_e,(0,r.A)({},e,n)),s.createElement(we,(0,r.A)({},e,n)))}function Ce(e){const n=(0,Me.A)();return s.createElement(Te,(0,r.A)({key:String(n)},e))}function xe(e){let{group:n,project:t}=e;const o=(0,w.zy)(),p=(0,U.gG)(t),r=o.hash.split("-")[0].slice(1),[c]=(0,D.R7)(),a=(0,s.useMemo)((()=>(n.categories??[n]).map((e=>function(e,n,t){const o=[],p=[],r=[];for(const s of e.children){const e=n[s];e&&(0,D.XN)(t,e)&&(r.push(e.anchor),e.hasOwnPage?o.push(e):p.push(e))}if(o.length>0||p.length>0)return{title:e.title,external:o,nested:p,anchors:r}}(e,p,c))).filter((e=>!!e))),[n,p,c]);return(0,s.useEffect)((()=>{if(1===a.length)return;const e=o.hash.split("-")[0].slice(1);for(const n of a)if(n.anchors.includes(e))return}),[o.hash,a]),0===a.length?s.createElement(s.Fragment,null):s.createElement(s.Fragment,null,s.createElement(se.A,{as:"h2",id:n.title},n.title),a.length>1?s.createElement(Ce,{groupId:n.title},a.map((e=>s.createElement(ie,{default:e.anchors.includes(r),value:e.title,label:e.title,className:"margin-top--lg"},s.createElement(re,{group:e}))))):s.createElement(re,{group:a[0]}))}var Ae=t(3443);function ve(e){let{parameters:n}=e;const t=(0,U.as)(),o=(0,s.useMemo)((()=>n?.map(t)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Parameters"),s.createElement("ul",null,o.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(q,{reflection:e})),s.createElement(Ae.A,{id:e.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function Le(e){let{parameters:n}=e;const t=(0,U.as)(),o=(0,s.useMemo)((()=>n?.map(t)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Type Parameters"),s.createElement("ul",null,o.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(O,{reflection:e})),s.createElement(Ae.A,{id:e.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function be(e){let{signatures:n,flags:t,source:o}=e;const p=(0,U.as)(),r=(0,s.useMemo)((()=>n.map(p)),[n]),[c,a]=(0,s.useState)(r[0]);return s.createElement(s.Fragment,null,s.createElement(y,null,r.map((e=>s.createElement(u,{link:o?.url,key:e.id,highlight:n.length>1&&e.id===c.id,onClick:n.length>1?()=>a(e):void 0},s.createElement(d,null,s.createElement(j,{reflection:e,flags:t})))))),s.createElement(h.A,{comment:c.comment}),s.createElement(Le,{parameters:c.typeParameter}),s.createElement(ve,{parameters:c.parameters}))}function Ne(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(K,{reflection:n})))),s.createElement(_,{kind:n.kind},s.createElement(h.A,{comment:n.comment})),s.createElement(Le,{parameters:n.typeParameters}),n.implementedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Implemented by"),s.createElement("ul",null,n.implementedBy.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e}))))))),n.extendedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Extended by"),s.createElement("ul",null,n.extendedBy.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e}))))))),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(be,{signatures:n.signatures})),n.groups?.map((e=>s.createElement(xe,{group:e,key:e.title,project:n.project}))))}function ke(e){let{reflection:n,headless:t}=e;const o=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((e=>!!e));return s.createElement(s.Fragment,null,!t&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(be,{signatures:o,flags:n.flags,source:n.sources?.[0]}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pe,{type:n.inheritedFrom}))),n.overwrites&&s.createElement("small",null,"Overwrites"," ",s.createElement("code",null,s.createElement(pe,{type:n.overwrites}))))}var ze=t(154);function Pe(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(ze.A,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),s.createElement(_,{kind:n.kind},s.createElement(h.A,{comment:n.comment})),n.groups?.map((e=>s.createElement(xe,{group:e,key:e.title,project:n.project}))))}const Ie={cardContainer:"cardContainer_ybwo",cardTitle:"cardTitle_Ehd1",cardDescription:"cardDescription_b6wr"};function Re(e){let{reflection:n}=e;const t=(0,U.gG)(n.project),o=n.groups[0].children.map((e=>t[e])).filter((e=>!!e));return s.createElement("article",{className:"margin-top--lg"},s.createElement("section",{className:(0,l.A)("row")},o.map((e=>s.createElement("article",{key:e.id,className:"col col--6 margin-bottom--lg"},s.createElement(T.A,{href:e.href,className:(0,l.A)("card padding--lg",Ie.cardContainer)},s.createElement("h2",{className:(0,l.A)("text--truncate",Ie.cardTitle)},s.createElement("code",null,e.name)),s.createElement("div",{className:(0,l.A)("text--truncate",Ie.cardDescription)},e.comment?.summaryText??"\xa0")))))))}function We(e){let{reflection:n,headless:t}=e;return s.createElement(s.Fragment,null,!t&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(Y,{reflection:n})))),s.createElement(h.A,{comment:n.comment}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pe,{type:n.inheritedFrom}))))}function Se(e){let{reflection:n}=e;const t=(0,U.gG)(n.project);return s.createElement(s.Fragment,null,s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name)),s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(K,{reflection:n})))),s.createElement(h.A,{comment:n.comment}),s.createElement(Le,{parameters:n.typeParameters}),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(be,{signatures:n.signatures})),n.groups?.map((e=>s.createElement(s.Fragment,{key:e.title},s.createElement("h2",null,e.title),e.children.map((e=>t[e])).filter((e=>e&&(e.flags.isPublic||!e.flags.isProtected&&!e.flags.isPrivate))).map((e=>s.createElement(Be,{key:e.id,reflection:e})))))))}function Be(e){let{reflection:n,headless:t=!1}=e;const o=(0,s.useMemo)((()=>{switch(n.kind){case g.k.Project:return Re;case g.k.Module:return Pe;case g.k.Namespace:case g.k.Enum:case g.k.Class:case g.k.Interface:return Ne;case g.k.Function:case g.k.Accessor:case g.k.Constructor:case g.k.Method:return ke;case g.k.Variable:case g.k.Property:case g.k.EnumMember:return We;case g.k.CallSignature:case g.k.IndexSignature:case g.k.ConstructorSignature:case g.k.Parameter:case g.k.TypeLiteral:case g.k.TypeParameter:case g.k.GetSignature:case g.k.SetSignature:case g.k.ObjectLiteral:break;case g.k.TypeAlias:return Se;case g.k.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return s.createElement(o,{reflection:n,headless:t})}},9659:(e,n,t)=>{t.d(n,{k:()=>o});let o=function(e){return e[e.Project=1]="Project",e[e.Module=2]="Module",e[e.Namespace=4]="Namespace",e[e.Enum=8]="Enum",e[e.EnumMember=16]="EnumMember",e[e.Variable=32]="Variable",e[e.Function=64]="Function",e[e.Class=128]="Class",e[e.Interface=256]="Interface",e[e.Constructor=512]="Constructor",e[e.Property=1024]="Property",e[e.Method=2048]="Method",e[e.CallSignature=4096]="CallSignature",e[e.IndexSignature=8192]="IndexSignature",e[e.ConstructorSignature=16384]="ConstructorSignature",e[e.Parameter=32768]="Parameter",e[e.TypeLiteral=65536]="TypeLiteral",e[e.TypeParameter=131072]="TypeParameter",e[e.Accessor=262144]="Accessor",e[e.GetSignature=524288]="GetSignature",e[e.SetSignature=1048576]="SetSignature",e[e.ObjectLiteral=2097152]="ObjectLiteral",e[e.TypeAlias=4194304]="TypeAlias",e[e.Reference=8388608]="Reference",e}({})},7576:(e,n,t)=>{t.d(n,{A:()=>s});var o=t(9631),p=t(9996),r=t(4041);function s(){return r.createElement(p.A,{type:"experimental"},"This is an ",r.createElement(o.A,{to:"/experimental"},"experimental feature"),". The behavior and API may change drastically between minor releases.")}},8675:(e,n,t)=>{t.d(n,{Fx:()=>a,ID:()=>i,Kv:()=>r,as:()=>c,gG:()=>s});var o=t(4041);const p=o.createContext({lookup:{},urlLookup:{}});function r(e){let{children:n,lookup:t,urlLookup:r}=e;return o.createElement(p.Provider,{value:{lookup:t,urlLookup:r}},n)}function s(e){const{lookup:n}=(0,o.useContext)(p);return n[e]}function c(){const{lookup:e}=(0,o.useContext)(p);return n=>{if("number"==typeof n?.project)return e[n.project][n.id]}}function a(){const{urlLookup:e,lookup:n}=(0,o.useContext)(p);return t=>{const o=e[t];return o?n[o.projectId]?.[o.id]??null:null}}function i(e){if(e)return e.href}},4593:(e,n,t)=>{t.d(n,{J2:()=>c,d5:()=>s,o0:()=>a});var o=t(8408),p=t(4041);const r=p.createContext(null);function s(e){let{children:n}=e;const t=(0,o.A)(),s=(0,p.useMemo)((()=>function(e,n){const{plain:t}=e,o=Object.create(null),p=e.styles.reduce(((e,t)=>{const{languages:o,style:p}=t;return o&&!o.includes(n)||t.types.forEach((n=>{e[n]={...e[n],...p}})),e}),o);return p.root=t,p.plain={...t,backgroundColor:null},p}(t,"typescript")),[t]);return p.createElement(r.Provider,{value:s},n)}function c(e){void 0===e&&(e="plain");const n=(0,p.useContext)(r);return{className:`token ${e}`,style:n[e]??n.plain}}function a(e){void 0===e&&(e="plain");const n=(0,p.useContext)(r);return n[e]??n.plain}},6382:(e,n,t)=>{t.d(n,{B4:()=>l,R7:()=>u,XN:()=>m});var o=t(9531),p=t(213),r=t(4041);const s="api-filters",c=o.A.canUseDOM?localStorage.getItem(s):null,a=c?JSON.parse(c):{inherited:!0,private:!1},i=r.createContext([a,()=>{}]);function l(e){let{children:n}=e;const[t,o]=(0,r.useState)(a),c=(0,p.A)();return r.createElement(i.Provider,{value:[t,e=>{c&&localStorage.setItem(s,JSON.stringify(e)),o(e)}]},n)}function u(){return(0,r.useContext)(i)}function m(e,n){const t=n.flags?.isPrivate||n.flags?.isProtected;if(!e.private&&t)return!1;const o=!!n.inheritedFrom;return!(!e.inherited&&o)}},9996:(e,n,t)=>{t.d(n,{A:()=>m});var o=t(9575),p=t(4041);function r(e){let{width:n=24,height:t=24,...r}=e;return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0,fill:"currentColor"},r),p.createElement("path",{d:"M19.8,18.4L14,10.67V6.5l1.35-1.69C15.61,4.48,15.38,4,14.96,4H9.04C8.62,4,8.39,4.48,8.65,4.81L10,6.5v4.17L4.2,18.4 C3.71,19.06,4.18,20,5,20h14C19.82,20,20.29,19.06,19.8,18.4z"}))}function s(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function c(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function i(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}var l=t(8621);const u={icon:"icon_Fw4I"};function m(e){let{title:n,type:t,...m}=e;const y=(0,p.useMemo)((()=>{switch(t){case"tip":return a;case"caution":return i;case"danger":return s;case"experimental":return r;default:return c}}),[t]);return"experimental"===t&&(n??="Experimental",t="caution"),p.createElement(p.Fragment,null,p.createElement(l.A,(0,o.A)({icon:p.createElement(y,{className:u.icon}),title:n,type:t},m)))}},482:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>y,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var o=t(9575),p=(t(4041),t(2247)),r=t(9987);const s={sidebar_position:2,slug:"/flow"},c="Animation flow",a={unversionedId:"guide/flow",id:"guide/flow",title:"Animation flow",description:"_Note: These docs were adopted from the original",source:"@site/docs/guide/flow.mdx",sourceDirName:"guide",slug:"/flow",permalink:"/flow",draft:!1,editUrl:"https://github.com/havenhq/revideo/blob/main/packages/docs/docs/guide/flow.mdx",tags:[],version:"current",lastUpdatedBy:"Justus Mattern",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"/flow"},sidebar:"docs",previous:{title:"Guide",permalink:"/category/guide"},next:{title:"Scene hierarchy",permalink:"/hierarchy"}},i={},l=[{value:"Flow Generators",id:"flow-generators",level:2},{value:"<code>all</code>",id:"all",level:3},{value:"<code>any</code>",id:"any",level:3},{value:"<code>chain</code>",id:"chain",level:3},{value:"<code>delay</code>",id:"delay",level:3},{value:"<code>sequence</code>",id:"sequence",level:3},{value:"<code>loop</code>",id:"loop",level:3},{value:"Looping",id:"looping",level:2},{value:"Using <code>Array.map</code> and <code>all</code>",id:"using-arraymap-and-all",level:3},{value:"Using a <code>for</code> loop and <code>all</code>",id:"using-a-for-loop-and-all",level:3},{value:"Using a <code>for</code> loop",id:"using-a-for-loop",level:3}],u={toc:l},m="wrapper";function y(e){let{components:n,...t}=e;return(0,p.yg)(m,(0,o.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,p.yg)("h1",{id:"animation-flow"},"Animation flow"),(0,p.yg)("p",null,(0,p.yg)("em",{parentName:"p"},"Note: These docs were adopted from the original\n",(0,p.yg)("a",{parentName:"em",href:"https://motioncanvas.io/docs/"},"Motion Canvas")," docs")),(0,p.yg)("p",null,"Motion Canvas uses generator functions to describe animations."),(0,p.yg)("p",null,"A generator function is a function that can return multiple values:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-ts"},"function* example() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst generator = example();\n\nconsole.log(generator.next().value); // 1;\nconsole.log(generator.next().value); // 2;\nconsole.log(generator.next().value); // 3;\n")),(0,p.yg)("p",null,"When the ",(0,p.yg)("inlineCode",{parentName:"p"},"yield")," keyword is encountered, the execution of the function pauses,\nand resumes only when the caller requests another value. This is particularly\nuseful when declaring animations - usually we want to change the things on the\nscreen in incremental steps to create an illusion of movement. We also want to\nwait a constant amount of time between these updates so that our eyes can\nregister what's happening. With generators, we can update things in-between the\n",(0,p.yg)("inlineCode",{parentName:"p"},"yield")," keywords, and then wait for a bit whenever the function yields."),(0,p.yg)("p",null,"This is the fundamental idea of Motion Canvas. ",(0,p.yg)("inlineCode",{parentName:"p"},"yield"),' means: "The current frame\nis ready, display it on the screen and come back to me later."'),(0,p.yg)("p",null,"With that in mind, we can make a circle flicker on the screen using the\nfollowing code:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  circle().fill('red');\n  yield;\n  circle().fill('blue');\n  yield;\n  circle().fill('red');\n  yield;\n});\n")),(0,p.yg)("p",null,"Needless to say, it would be extremely cumbersome if we had to write all\nanimations like that. Fortunately, JavaScript has another keyword for use within\ngenerators - ",(0,p.yg)("inlineCode",{parentName:"p"},"yield*"),". It allows us to delegate the yielding to another\ngenerator."),(0,p.yg)("p",null,"For instance, we could extract the flickering code from the above example to a\nseparate generator and delegate our scene function to it:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"import {ThreadGenerator} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  yield* flicker(circle());\n});\n\nfunction* flicker(circle: Circle): ThreadGenerator {\n  circle.fill('red');\n  yield;\n  circle.fill('blue');\n  yield;\n  circle.fill('red');\n  yield;\n}\n")),(0,p.yg)("p",null,"The resulting animation is exactly the same, but now we have a reusable function\nthat we can use whenever we need some flickering."),(0,p.yg)("p",null,"Motion Canvas provides a lot of useful generators like this. You may remember\nthis snippet:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-ts"},"yield * myCircle().fill('#e6a700', 1);\n")),(0,p.yg)("p",null,"It animates the fill color of the circle from its current value to ",(0,p.yg)("inlineCode",{parentName:"p"},"#e6a700"),"\nover a span of one second. As you may guess, the result of calling\n",(0,p.yg)("inlineCode",{parentName:"p"},"fill('#e6a700', 1)")," is another generator to which we can redirect our scene\nfunction. Generators like this are called tweens, because they animate\nbe",(0,p.yg)("strong",{parentName:"p"},"tween")," two values. You can read more about them in the\n",(0,p.yg)("a",{parentName:"p",href:"/tweening"},"tweening")," section."),(0,p.yg)("h2",{id:"flow-generators"},"Flow Generators"),(0,p.yg)("p",null,"Another kind of generators are ",(0,p.yg)("em",{parentName:"p"},"flow generators"),". They take one or more\ngenerators as their input and combine them together. We've mentioned the ",(0,p.yg)("inlineCode",{parentName:"p"},"all()"),"\ngenerator in the quickstart section, there's a few more:"),(0,p.yg)("h3",{id:"all"},(0,p.yg)("inlineCode",{parentName:"h3"},"all")),(0,p.yg)(r.A,{url:"/api/core/flow#all",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"any"},(0,p.yg)("inlineCode",{parentName:"h3"},"any")),(0,p.yg)(r.A,{url:"/api/core/flow#any",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"chain"},(0,p.yg)("inlineCode",{parentName:"h3"},"chain")),(0,p.yg)(r.A,{url:"/api/core/flow#chain",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"delay"},(0,p.yg)("inlineCode",{parentName:"h3"},"delay")),(0,p.yg)(r.A,{url:"/api/core/flow#delay",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"sequence"},(0,p.yg)("inlineCode",{parentName:"h3"},"sequence")),(0,p.yg)(r.A,{url:"/api/core/flow#sequence",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"loop"},(0,p.yg)("inlineCode",{parentName:"h3"},"loop")),(0,p.yg)(r.A,{url:"/api/core/flow#loop",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h2",{id:"looping"},"Looping"),(0,p.yg)("p",null,"There are many ways to animate multiple objects. Here are some examples. Try\nusing them in the below editor."),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor ratio=2",editor:!0,ratio:"2"},"import {makeScene2D, Rect} from '@revideo/2d';\nimport {all, waitFor, makeRef, range} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const rects: Rect[] = [];\n\n  // Create some rects\n  view.add(\n    range(5).map(i => (\n      <Rect\n        ref={makeRef(rects, i)}\n        width={100}\n        height={100}\n        x={-250 + 125 * i}\n        fill=\"#88C0D0\"\n        radius={10}\n      />\n    )),\n  );\n\n  yield* waitFor(1);\n\n  // Animate them\n  yield* all(\n    ...rects.map(rect => rect.position.y(100, 1).to(-100, 2).to(0, 1)),\n  );\n});\n")),(0,p.yg)("h3",{id:"using-arraymap-and-all"},"Using ",(0,p.yg)("inlineCode",{parentName:"h3"},"Array.map")," and ",(0,p.yg)("inlineCode",{parentName:"h3"},"all")),(0,p.yg)("p",null,"This is one of the most elegant ways to do simple tweens, but requires nesting\n",(0,p.yg)("inlineCode",{parentName:"p"},"all")," to do multiple tweens on an object since the ",(0,p.yg)("inlineCode",{parentName:"p"},"map")," callback must return a\n",(0,p.yg)("inlineCode",{parentName:"p"},"ThreadGenerator"),"."),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"yield *\n  all(\n    ...rects.map(rect =>\n      // No yield or anything; we return this generator and deal with it outside\n      rect.position.y(100, 1).to(-100, 2).to(0, 1),\n    ),\n  );\n")),(0,p.yg)("h3",{id:"using-a-for-loop-and-all"},"Using a ",(0,p.yg)("inlineCode",{parentName:"h3"},"for")," loop and ",(0,p.yg)("inlineCode",{parentName:"h3"},"all")),(0,p.yg)("p",null,"This is similar to above, but uses a ",(0,p.yg)("inlineCode",{parentName:"p"},"for")," loop and an array of generators."),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"const generators = [];\nfor (const rect of rects) {\n  // No yield here, just store the generators.\n  generators.push(rect.position.y(100, 1).to(-100, 2).to(0, 1));\n}\n\n// Run all of the generators.\nyield * all(...generators);\n")),(0,p.yg)("h3",{id:"using-a-for-loop"},"Using a ",(0,p.yg)("inlineCode",{parentName:"h3"},"for")," loop"),(0,p.yg)("p",null,"This is a bit of a cumbersome option because you have to figure out how long it\nwould take for the generator in the loop to complete, but is useful in some\nsituations."),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"for (const rect of rects) {\n  // Note the absence of a * after this yield\n  yield rect.position.y(100, 1).to(-100, 2).to(0, 1);\n}\n\n// Wait for the duration of the above generators\nyield * waitFor(4);\n")))}y.isMDXComponent=!0}}]);
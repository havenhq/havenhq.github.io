"use strict";(self.webpackChunk_revideo_docs=self.webpackChunk_revideo_docs||[]).push([[9891],{8621:(e,n,t)=>{t.d(n,{A:()=>u});var o=t(4041),p=t(2663),r=t(7473),s=t(9082);const c={admonition:"admonition_qNG0",admonitionHeading:"admonitionHeading_l909",admonitionIcon:"admonitionIcon_UNbs",admonitionContent:"admonitionContent_oUmQ"};const a={note:{infimaClassName:"secondary",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 14 16"},o.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))},label:o.createElement(s.A,{id:"theme.admonition.note",description:"The default label used for the Note admonition (:::note)"},"note")},tip:{infimaClassName:"success",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 12 16"},o.createElement("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))},label:o.createElement(s.A,{id:"theme.admonition.tip",description:"The default label used for the Tip admonition (:::tip)"},"tip")},danger:{infimaClassName:"danger",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 12 16"},o.createElement("path",{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))},label:o.createElement(s.A,{id:"theme.admonition.danger",description:"The default label used for the Danger admonition (:::danger)"},"danger")},info:{infimaClassName:"info",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 14 16"},o.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))},label:o.createElement(s.A,{id:"theme.admonition.info",description:"The default label used for the Info admonition (:::info)"},"info")},caution:{infimaClassName:"warning",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 16 16"},o.createElement("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))},label:o.createElement(s.A,{id:"theme.admonition.caution",description:"The default label used for the Caution admonition (:::caution)"},"caution")}},i={secondary:"note",important:"info",success:"tip",warning:"danger"};function l(e){const{mdxAdmonitionTitle:n,rest:t}=function(e){const n=o.Children.toArray(e),t=n.find((e=>o.isValidElement(e)&&"mdxAdmonitionTitle"===e.props?.mdxType)),p=o.createElement(o.Fragment,null,n.filter((e=>e!==t)));return{mdxAdmonitionTitle:t,rest:p}}(e.children);return{...e,title:e.title??n,children:t}}function u(e){const{children:n,type:t,title:s,icon:u}=l(e),m=function(e){const n=i[e]??e,t=a[n];return t||(console.warn(`No admonition config found for admonition type "${n}". Using Info as fallback.`),a.info)}(t),y=s??m.label,{iconComponent:d}=m,h=u??o.createElement(d,null);return o.createElement("div",{className:(0,p.A)(r.G.common.admonition,r.G.common.admonitionType(e.type),"alert",`alert--${m.infimaClassName}`,c.admonition)},o.createElement("div",{className:c.admonitionHeading},o.createElement("span",{className:c.admonitionIcon},h),y),o.createElement("div",{className:c.admonitionContent},n))}},4441:(e,n,t)=>{t.d(n,{A:()=>l});var o=t(9575),p=t(4041),r=t(2663),s=t(9082),c=t(2520),a=t(9631);const i={anchorWithStickyNavbar:"anchorWithStickyNavbar_fF9Z",anchorWithHideOnScrollNavbar:"anchorWithHideOnScrollNavbar_Yh18"};function l(e){let{as:n,id:t,...l}=e;const{navbar:{hideOnScroll:u}}=(0,c.p)();if("h1"===n||!t)return p.createElement(n,(0,o.A)({},l,{id:void 0}));const m=(0,s.T)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof l.children?l.children:t});return p.createElement(n,(0,o.A)({},l,{className:(0,r.A)("anchor",u?i.anchorWithHideOnScrollNavbar:i.anchorWithStickyNavbar,l.className),id:t}),l.children,p.createElement(a.A,{className:"hash-link",to:`#${t}`,"aria-label":m,title:m},"\u200b"))}},9987:(e,n,t)=>{t.d(n,{A:()=>s});var o=t(1125),p=t(8675),r=t(4041);function s(e){let{url:n}=e;const t=(0,p.Fx)()(n);return r.createElement(o.A,{reflection:t,headless:!0})}},5396:(e,n,t)=>{t.d(n,{A:()=>kNr});var o={};t.r(o),t.d(o,{content_0_0:()=>i,content_0_10:()=>C,content_0_100:()=>Jn,content_0_1000:()=>ev,content_0_1002:()=>ov,content_0_1004:()=>sv,content_0_1006:()=>iv,content_0_1008:()=>mv,content_0_1010:()=>hv,content_0_1012:()=>Dv,content_0_1014:()=>_v,content_0_1016:()=>Cv,content_0_1018:()=>vv,content_0_102:()=>nt,content_0_1020:()=>Nv,content_0_1022:()=>Pv,content_0_1024:()=>Wv,content_0_1026:()=>Gv,content_0_1028:()=>Uv,content_0_1030:()=>qv,content_0_1032:()=>Yv,content_0_1034:()=>Kv,content_0_1036:()=>eL,content_0_1038:()=>oL,content_0_104:()=>pt,content_0_1040:()=>sL,content_0_1042:()=>iL,content_0_1044:()=>mL,content_0_1046:()=>hL,content_0_1048:()=>DL,content_0_1050:()=>_L,content_0_1052:()=>CL,content_0_1054:()=>vL,content_0_1056:()=>NL,content_0_1058:()=>PL,content_0_106:()=>ct,content_0_1060:()=>WL,content_0_1062:()=>GL,content_0_1064:()=>UL,content_0_1066:()=>qL,content_0_1068:()=>YL,content_0_1070:()=>KL,content_0_1072:()=>eb,content_0_1074:()=>ob,content_0_1076:()=>sb,content_0_1078:()=>ib,content_0_108:()=>lt,content_0_1080:()=>mb,content_0_1082:()=>hb,content_0_1084:()=>Db,content_0_1086:()=>_b,content_0_1088:()=>Cb,content_0_1090:()=>vb,content_0_1092:()=>Nb,content_0_1094:()=>Pb,content_0_1096:()=>Wb,content_0_1098:()=>Gb,content_0_110:()=>yt,content_0_1100:()=>Ub,content_0_1102:()=>qb,content_0_1104:()=>Yb,content_0_1106:()=>Kb,content_0_1108:()=>eN,content_0_1110:()=>oN,content_0_1112:()=>sN,content_0_1114:()=>iN,content_0_1116:()=>mN,content_0_1118:()=>hN,content_0_112:()=>gt,content_0_1120:()=>DN,content_0_1122:()=>_N,content_0_1124:()=>CN,content_0_1126:()=>vN,content_0_1128:()=>NN,content_0_1130:()=>PN,content_0_1132:()=>WN,content_0_1134:()=>GN,content_0_1136:()=>UN,content_0_1138:()=>qN,content_0_114:()=>Mt,content_0_1140:()=>YN,content_0_1142:()=>KN,content_0_1144:()=>ek,content_0_1146:()=>ok,content_0_1148:()=>sk,content_0_1150:()=>ik,content_0_1152:()=>mk,content_0_1154:()=>hk,content_0_1156:()=>Dk,content_0_1158:()=>_k,content_0_116:()=>wt,content_0_1160:()=>Ck,content_0_1162:()=>vk,content_0_1164:()=>Nk,content_0_1166:()=>Pk,content_0_1168:()=>Wk,content_0_1170:()=>Gk,content_0_1172:()=>Uk,content_0_1174:()=>qk,content_0_1176:()=>Yk,content_0_1178:()=>Kk,content_0_118:()=>xt,content_0_1180:()=>ez,content_0_1182:()=>oz,content_0_1184:()=>sz,content_0_1186:()=>iz,content_0_1188:()=>mz,content_0_1190:()=>hz,content_0_1192:()=>Dz,content_0_1194:()=>_z,content_0_1196:()=>Cz,content_0_1198:()=>vz,content_0_12:()=>v,content_0_120:()=>Lt,content_0_1200:()=>Nz,content_0_1202:()=>Pz,content_0_1204:()=>Wz,content_0_1206:()=>Gz,content_0_1208:()=>Uz,content_0_1210:()=>qz,content_0_1212:()=>Yz,content_0_1214:()=>Kz,content_0_1216:()=>eP,content_0_1218:()=>oP,content_0_122:()=>kt,content_0_1220:()=>sP,content_0_1222:()=>iP,content_0_1224:()=>mP,content_0_1226:()=>hP,content_0_1228:()=>DP,content_0_1230:()=>_P,content_0_1232:()=>CP,content_0_1234:()=>vP,content_0_1236:()=>NP,content_0_1238:()=>PP,content_0_124:()=>It,content_0_1240:()=>WP,content_0_1242:()=>GP,content_0_1244:()=>UP,content_0_1246:()=>qP,content_0_1248:()=>YP,content_0_1250:()=>KP,content_0_1252:()=>eI,content_0_1254:()=>oI,content_0_1256:()=>sI,content_0_1258:()=>iI,content_0_126:()=>St,content_0_1260:()=>mI,content_0_1262:()=>hI,content_0_1264:()=>DI,content_0_1266:()=>_I,content_0_1268:()=>CI,content_0_1270:()=>vI,content_0_1272:()=>NI,content_0_1274:()=>PI,content_0_1276:()=>WI,content_0_1278:()=>GI,content_0_128:()=>Et,content_0_1280:()=>UI,content_0_1282:()=>qI,content_0_1284:()=>YI,content_0_1286:()=>KI,content_0_1288:()=>eR,content_0_1290:()=>oR,content_0_1292:()=>sR,content_0_1294:()=>iR,content_0_1296:()=>mR,content_0_1298:()=>hR,content_0_130:()=>Ft,content_0_1300:()=>DR,content_0_1302:()=>_R,content_0_1304:()=>CR,content_0_1306:()=>vR,content_0_1308:()=>NR,content_0_1310:()=>PR,content_0_1312:()=>WR,content_0_1314:()=>GR,content_0_1316:()=>UR,content_0_1318:()=>qR,content_0_132:()=>jt,content_0_1320:()=>YR,content_0_1322:()=>KR,content_0_1324:()=>eW,content_0_1326:()=>oW,content_0_1328:()=>sW,content_0_1330:()=>iW,content_0_1332:()=>mW,content_0_1334:()=>hW,content_0_1336:()=>DW,content_0_1338:()=>_W,content_0_134:()=>Qt,content_0_1340:()=>CW,content_0_1342:()=>vW,content_0_1344:()=>NW,content_0_1346:()=>PW,content_0_1348:()=>WW,content_0_1350:()=>GW,content_0_1352:()=>UW,content_0_1354:()=>qW,content_0_1356:()=>YW,content_0_1358:()=>KW,content_0_136:()=>Jt,content_0_1360:()=>eS,content_0_1362:()=>oS,content_0_1364:()=>sS,content_0_1366:()=>iS,content_0_1368:()=>mS,content_0_1370:()=>hS,content_0_1372:()=>DS,content_0_1374:()=>_S,content_0_1376:()=>CS,content_0_1378:()=>vS,content_0_138:()=>no,content_0_1380:()=>NS,content_0_1382:()=>PS,content_0_1384:()=>WS,content_0_1386:()=>GS,content_0_1388:()=>US,content_0_1390:()=>qS,content_0_1392:()=>YS,content_0_1394:()=>KS,content_0_1396:()=>eB,content_0_1398:()=>oB,content_0_14:()=>N,content_0_140:()=>po,content_0_1400:()=>sB,content_0_1402:()=>iB,content_0_1404:()=>mB,content_0_1406:()=>hB,content_0_1408:()=>DB,content_0_1410:()=>_B,content_0_1412:()=>CB,content_0_1414:()=>vB,content_0_1416:()=>NB,content_0_1418:()=>PB,content_0_142:()=>co,content_0_1420:()=>WB,content_0_1422:()=>GB,content_0_1424:()=>UB,content_0_1426:()=>qB,content_0_1428:()=>YB,content_0_1430:()=>KB,content_0_1432:()=>eG,content_0_1434:()=>oG,content_0_1436:()=>sG,content_0_1438:()=>iG,content_0_144:()=>lo,content_0_1440:()=>mG,content_0_1442:()=>hG,content_0_1444:()=>DG,content_0_1446:()=>_G,content_0_1448:()=>CG,content_0_1450:()=>vG,content_0_1452:()=>NG,content_0_1454:()=>PG,content_0_1456:()=>WG,content_0_1458:()=>GG,content_0_146:()=>yo,content_0_1460:()=>UG,content_0_1462:()=>qG,content_0_1464:()=>YG,content_0_1466:()=>KG,content_0_1468:()=>eE,content_0_1470:()=>oE,content_0_1472:()=>sE,content_0_1474:()=>iE,content_0_1476:()=>mE,content_0_1478:()=>hE,content_0_148:()=>fo,content_0_1480:()=>DE,content_0_1482:()=>_E,content_0_1484:()=>CE,content_0_1486:()=>vE,content_0_1488:()=>NE,content_0_1490:()=>PE,content_0_1492:()=>WE,content_0_1494:()=>GE,content_0_1496:()=>UE,content_0_1498:()=>qE,content_0_150:()=>Xo,content_0_1500:()=>YE,content_0_1502:()=>KE,content_0_1504:()=>eO,content_0_1506:()=>oO,content_0_1508:()=>sO,content_0_1510:()=>iO,content_0_1512:()=>mO,content_0_1514:()=>hO,content_0_1516:()=>DO,content_0_1518:()=>_O,content_0_152:()=>To,content_0_1520:()=>CO,content_0_1522:()=>vO,content_0_1524:()=>NO,content_0_1526:()=>PO,content_0_1528:()=>WO,content_0_1530:()=>GO,content_0_1532:()=>UO,content_0_1534:()=>qO,content_0_1536:()=>YO,content_0_1538:()=>KO,content_0_154:()=>Ao,content_0_1540:()=>eU,content_0_1542:()=>oU,content_0_1544:()=>sU,content_0_1546:()=>iU,content_0_1548:()=>mU,content_0_1550:()=>hU,content_0_1552:()=>DU,content_0_1554:()=>_U,content_0_1556:()=>CU,content_0_1558:()=>vU,content_0_156:()=>bo,content_0_1560:()=>NU,content_0_1562:()=>PU,content_0_1564:()=>WU,content_0_1566:()=>GU,content_0_1568:()=>UU,content_0_1570:()=>qU,content_0_1572:()=>YU,content_0_1574:()=>KU,content_0_1576:()=>eF,content_0_1578:()=>oF,content_0_158:()=>zo,content_0_1580:()=>sF,content_0_1582:()=>iF,content_0_1584:()=>mF,content_0_1586:()=>hF,content_0_1588:()=>DF,content_0_1590:()=>_F,content_0_1592:()=>CF,content_0_1594:()=>vF,content_0_1596:()=>NF,content_0_1598:()=>PF,content_0_16:()=>P,content_0_160:()=>Ro,content_0_1600:()=>WF,content_0_1602:()=>GF,content_0_1604:()=>UF,content_0_1606:()=>qF,content_0_1608:()=>YF,content_0_1610:()=>KF,content_0_1612:()=>eV,content_0_1614:()=>oV,content_0_1616:()=>sV,content_0_1618:()=>iV,content_0_162:()=>Bo,content_0_1620:()=>mV,content_0_1622:()=>hV,content_0_1624:()=>DV,content_0_1626:()=>_V,content_0_1628:()=>CV,content_0_1630:()=>vV,content_0_1632:()=>NV,content_0_1634:()=>PV,content_0_1636:()=>WV,content_0_1638:()=>GV,content_0_164:()=>Oo,content_0_1640:()=>UV,content_0_1642:()=>qV,content_0_1644:()=>YV,content_0_1646:()=>KV,content_0_1648:()=>eq,content_0_1650:()=>oq,content_0_1652:()=>sq,content_0_1654:()=>iq,content_0_1656:()=>mq,content_0_1658:()=>hq,content_0_166:()=>Vo,content_0_1660:()=>Dq,content_0_1662:()=>_q,content_0_1664:()=>Cq,content_0_1666:()=>vq,content_0_1668:()=>Nq,content_0_1670:()=>Pq,content_0_1672:()=>Wq,content_0_1674:()=>Gq,content_0_1676:()=>Uq,content_0_1678:()=>qq,content_0_168:()=>Ho,content_0_1680:()=>Yq,content_0_1682:()=>Kq,content_0_1684:()=>ej,content_0_1686:()=>oj,content_0_1688:()=>sj,content_0_1690:()=>ij,content_0_1692:()=>mj,content_0_1694:()=>hj,content_0_1696:()=>Dj,content_0_1698:()=>_j,content_0_170:()=>$o,content_0_1700:()=>Cj,content_0_1702:()=>vj,content_0_1704:()=>Nj,content_0_1706:()=>Pj,content_0_1708:()=>Wj,content_0_1710:()=>Gj,content_0_1712:()=>Uj,content_0_1714:()=>qj,content_0_1716:()=>Yj,content_0_1718:()=>Kj,content_0_172:()=>Zo,content_0_1720:()=>eH,content_0_1722:()=>oH,content_0_1724:()=>sH,content_0_1726:()=>iH,content_0_1728:()=>mH,content_0_1730:()=>hH,content_0_1732:()=>DH,content_0_1734:()=>_H,content_0_1736:()=>CH,content_0_1738:()=>vH,content_0_174:()=>tp,content_0_1740:()=>NH,content_0_1742:()=>PH,content_0_1744:()=>WH,content_0_1746:()=>GH,content_0_1748:()=>UH,content_0_1750:()=>qH,content_0_1752:()=>YH,content_0_1754:()=>KH,content_0_1756:()=>eY,content_0_1758:()=>oY,content_0_176:()=>rp,content_0_1760:()=>sY,content_0_1762:()=>iY,content_0_1764:()=>mY,content_0_1766:()=>hY,content_0_1768:()=>DY,content_0_1770:()=>_Y,content_0_1772:()=>CY,content_0_1774:()=>vY,content_0_1776:()=>NY,content_0_1778:()=>PY,content_0_178:()=>ap,content_0_1780:()=>WY,content_0_1782:()=>GY,content_0_1784:()=>UY,content_0_1786:()=>qY,content_0_1788:()=>YY,content_0_1790:()=>KY,content_0_1792:()=>eQ,content_0_1794:()=>oQ,content_0_1796:()=>sQ,content_0_1798:()=>iQ,content_0_18:()=>W,content_0_180:()=>up,content_0_1800:()=>mQ,content_0_1802:()=>hQ,content_0_1804:()=>DQ,content_0_1806:()=>_Q,content_0_1808:()=>CQ,content_0_1810:()=>vQ,content_0_1812:()=>NQ,content_0_1814:()=>PQ,content_0_1816:()=>WQ,content_0_1818:()=>GQ,content_0_182:()=>dp,content_0_1820:()=>UQ,content_0_1822:()=>qQ,content_0_1824:()=>YQ,content_0_1826:()=>KQ,content_0_1828:()=>e$,content_0_1830:()=>o$,content_0_1832:()=>s$,content_0_1834:()=>i$,content_0_1836:()=>m$,content_0_1838:()=>h$,content_0_184:()=>fp,content_0_1840:()=>D$,content_0_1842:()=>_$,content_0_1844:()=>C$,content_0_1846:()=>v$,content_0_1848:()=>N$,content_0_1850:()=>P$,content_0_1852:()=>W$,content_0_1854:()=>G$,content_0_1856:()=>U$,content_0_1858:()=>q$,content_0_186:()=>Xp,content_0_1860:()=>Y$,content_0_1862:()=>K$,content_0_1864:()=>eK,content_0_1866:()=>oK,content_0_1868:()=>sK,content_0_1870:()=>iK,content_0_1872:()=>mK,content_0_1874:()=>hK,content_0_1876:()=>DK,content_0_1878:()=>_K,content_0_188:()=>Tp,content_0_1880:()=>CK,content_0_1882:()=>vK,content_0_1884:()=>NK,content_0_1886:()=>PK,content_0_1888:()=>WK,content_0_1890:()=>GK,content_0_1892:()=>UK,content_0_1894:()=>qK,content_0_1896:()=>YK,content_0_1898:()=>KK,content_0_190:()=>Ap,content_0_1900:()=>eJ,content_0_1902:()=>oJ,content_0_1904:()=>sJ,content_0_1906:()=>iJ,content_0_1908:()=>mJ,content_0_1910:()=>hJ,content_0_1912:()=>DJ,content_0_1914:()=>_J,content_0_1916:()=>CJ,content_0_1918:()=>vJ,content_0_192:()=>bp,content_0_1920:()=>NJ,content_0_1922:()=>PJ,content_0_1924:()=>WJ,content_0_194:()=>zp,content_0_196:()=>Rp,content_0_198:()=>Bp,content_0_2:()=>m,content_0_20:()=>G,content_0_200:()=>Op,content_0_202:()=>Vp,content_0_204:()=>Hp,content_0_206:()=>$p,content_0_208:()=>Zp,content_0_210:()=>tr,content_0_212:()=>rr,content_0_214:()=>ar,content_0_216:()=>ur,content_0_218:()=>dr,content_0_22:()=>U,content_0_220:()=>fr,content_0_222:()=>Xr,content_0_224:()=>Tr,content_0_226:()=>Ar,content_0_228:()=>br,content_0_230:()=>zr,content_0_232:()=>Rr,content_0_234:()=>Br,content_0_236:()=>Or,content_0_238:()=>Vr,content_0_24:()=>q,content_0_240:()=>Hr,content_0_242:()=>$r,content_0_244:()=>Zr,content_0_246:()=>ts,content_0_248:()=>rs,content_0_250:()=>as,content_0_252:()=>us,content_0_254:()=>ds,content_0_256:()=>fs,content_0_258:()=>Xs,content_0_26:()=>Y,content_0_260:()=>Ts,content_0_262:()=>As,content_0_264:()=>bs,content_0_266:()=>zs,content_0_268:()=>Rs,content_0_270:()=>Bs,content_0_272:()=>Os,content_0_274:()=>Vs,content_0_276:()=>Hs,content_0_278:()=>$s,content_0_28:()=>K,content_0_280:()=>Zs,content_0_282:()=>tc,content_0_284:()=>rc,content_0_286:()=>ac,content_0_288:()=>uc,content_0_290:()=>dc,content_0_292:()=>fc,content_0_294:()=>Xc,content_0_296:()=>Tc,content_0_298:()=>Ac,content_0_30:()=>ee,content_0_300:()=>bc,content_0_302:()=>zc,content_0_304:()=>Rc,content_0_306:()=>Bc,content_0_308:()=>Oc,content_0_310:()=>Vc,content_0_312:()=>Hc,content_0_314:()=>$c,content_0_316:()=>Zc,content_0_318:()=>ta,content_0_32:()=>oe,content_0_320:()=>ra,content_0_322:()=>aa,content_0_324:()=>ua,content_0_326:()=>da,content_0_328:()=>fa,content_0_330:()=>Xa,content_0_332:()=>Ta,content_0_334:()=>Aa,content_0_336:()=>ba,content_0_338:()=>za,content_0_34:()=>se,content_0_340:()=>Ra,content_0_342:()=>Ba,content_0_344:()=>Oa,content_0_346:()=>Va,content_0_348:()=>Ha,content_0_350:()=>$a,content_0_352:()=>Za,content_0_354:()=>ti,content_0_356:()=>ri,content_0_358:()=>ai,content_0_36:()=>ie,content_0_360:()=>ui,content_0_362:()=>di,content_0_364:()=>fi,content_0_366:()=>Xi,content_0_368:()=>Ti,content_0_370:()=>Ai,content_0_372:()=>bi,content_0_374:()=>zi,content_0_376:()=>Ri,content_0_378:()=>Bi,content_0_38:()=>me,content_0_380:()=>Oi,content_0_382:()=>Vi,content_0_384:()=>Hi,content_0_386:()=>$i,content_0_388:()=>Zi,content_0_390:()=>tl,content_0_392:()=>rl,content_0_394:()=>al,content_0_396:()=>ul,content_0_398:()=>dl,content_0_4:()=>h,content_0_40:()=>he,content_0_400:()=>fl,content_0_402:()=>Xl,content_0_404:()=>Tl,content_0_406:()=>Al,content_0_408:()=>bl,content_0_410:()=>zl,content_0_412:()=>Rl,content_0_414:()=>Bl,content_0_416:()=>Ol,content_0_418:()=>Vl,content_0_42:()=>De,content_0_420:()=>Hl,content_0_422:()=>$l,content_0_424:()=>Zl,content_0_426:()=>tu,content_0_428:()=>ru,content_0_430:()=>au,content_0_432:()=>uu,content_0_434:()=>du,content_0_436:()=>fu,content_0_438:()=>Xu,content_0_44:()=>_e,content_0_440:()=>Tu,content_0_442:()=>Au,content_0_444:()=>bu,content_0_446:()=>zu,content_0_448:()=>Ru,content_0_450:()=>Bu,content_0_452:()=>Ou,content_0_454:()=>Vu,content_0_456:()=>Hu,content_0_458:()=>$u,content_0_46:()=>Ce,content_0_460:()=>Zu,content_0_462:()=>tm,content_0_464:()=>rm,content_0_466:()=>am,content_0_468:()=>um,content_0_470:()=>dm,content_0_472:()=>fm,content_0_474:()=>Xm,content_0_476:()=>Tm,content_0_478:()=>Am,content_0_48:()=>ve,content_0_480:()=>bm,content_0_482:()=>zm,content_0_484:()=>Rm,content_0_486:()=>Bm,content_0_488:()=>Om,content_0_490:()=>Vm,content_0_492:()=>Hm,content_0_494:()=>$m,content_0_496:()=>Zm,content_0_498:()=>ty,content_0_50:()=>Ne,content_0_500:()=>ry,content_0_502:()=>ay,content_0_504:()=>uy,content_0_506:()=>dy,content_0_508:()=>fy,content_0_510:()=>Xy,content_0_512:()=>Ty,content_0_514:()=>Ay,content_0_516:()=>by,content_0_518:()=>zy,content_0_52:()=>Pe,content_0_520:()=>Ry,content_0_522:()=>By,content_0_524:()=>Oy,content_0_526:()=>Vy,content_0_528:()=>Hy,content_0_530:()=>$y,content_0_532:()=>Zy,content_0_534:()=>td,content_0_536:()=>rd,content_0_538:()=>ad,content_0_54:()=>We,content_0_540:()=>ud,content_0_542:()=>dd,content_0_544:()=>fd,content_0_546:()=>Xd,content_0_548:()=>Td,content_0_550:()=>Ad,content_0_552:()=>bd,content_0_554:()=>zd,content_0_556:()=>Rd,content_0_558:()=>Bd,content_0_56:()=>Ge,content_0_560:()=>Od,content_0_562:()=>Vd,content_0_564:()=>Hd,content_0_566:()=>$d,content_0_568:()=>Zd,content_0_570:()=>th,content_0_572:()=>rh,content_0_574:()=>ah,content_0_576:()=>uh,content_0_578:()=>dh,content_0_58:()=>Ue,content_0_580:()=>fh,content_0_582:()=>Xh,content_0_584:()=>Th,content_0_586:()=>Ah,content_0_588:()=>bh,content_0_590:()=>zh,content_0_592:()=>Rh,content_0_594:()=>Bh,content_0_596:()=>Oh,content_0_598:()=>Vh,content_0_6:()=>D,content_0_60:()=>qe,content_0_600:()=>Hh,content_0_602:()=>$h,content_0_604:()=>Zh,content_0_606:()=>tg,content_0_608:()=>rg,content_0_610:()=>ag,content_0_612:()=>ug,content_0_614:()=>dg,content_0_616:()=>fg,content_0_618:()=>Xg,content_0_62:()=>Ye,content_0_620:()=>Tg,content_0_622:()=>Ag,content_0_624:()=>bg,content_0_626:()=>zg,content_0_628:()=>Rg,content_0_630:()=>Bg,content_0_632:()=>Og,content_0_634:()=>Vg,content_0_636:()=>Hg,content_0_638:()=>$g,content_0_64:()=>Ke,content_0_640:()=>Zg,content_0_642:()=>tf,content_0_644:()=>rf,content_0_646:()=>af,content_0_648:()=>mf,content_0_650:()=>hf,content_0_652:()=>Df,content_0_654:()=>_f,content_0_656:()=>Cf,content_0_658:()=>vf,content_0_66:()=>en,content_0_660:()=>Nf,content_0_662:()=>Pf,content_0_664:()=>Wf,content_0_666:()=>Gf,content_0_668:()=>Uf,content_0_670:()=>qf,content_0_672:()=>Yf,content_0_674:()=>Kf,content_0_676:()=>eD,content_0_678:()=>oD,content_0_68:()=>on,content_0_680:()=>sD,content_0_682:()=>iD,content_0_684:()=>mD,content_0_686:()=>hD,content_0_688:()=>DD,content_0_690:()=>_D,content_0_692:()=>CD,content_0_694:()=>vD,content_0_696:()=>ND,content_0_698:()=>PD,content_0_70:()=>sn,content_0_700:()=>WD,content_0_702:()=>GD,content_0_704:()=>UD,content_0_706:()=>qD,content_0_708:()=>YD,content_0_710:()=>KD,content_0_712:()=>eM,content_0_714:()=>oM,content_0_716:()=>sM,content_0_718:()=>iM,content_0_72:()=>ln,content_0_720:()=>mM,content_0_722:()=>hM,content_0_724:()=>DM,content_0_726:()=>_M,content_0_728:()=>CM,content_0_730:()=>vM,content_0_732:()=>NM,content_0_734:()=>PM,content_0_736:()=>WM,content_0_738:()=>GM,content_0_74:()=>yn,content_0_740:()=>UM,content_0_742:()=>qM,content_0_744:()=>YM,content_0_746:()=>KM,content_0_748:()=>eX,content_0_750:()=>oX,content_0_752:()=>sX,content_0_754:()=>iX,content_0_756:()=>mX,content_0_758:()=>hX,content_0_76:()=>gn,content_0_760:()=>DX,content_0_762:()=>_X,content_0_764:()=>CX,content_0_766:()=>vX,content_0_768:()=>NX,content_0_770:()=>PX,content_0_772:()=>WX,content_0_774:()=>GX,content_0_776:()=>UX,content_0_778:()=>qX,content_0_78:()=>Mn,content_0_780:()=>YX,content_0_782:()=>KX,content_0_784:()=>e_,content_0_786:()=>o_,content_0_788:()=>s_,content_0_790:()=>i_,content_0_792:()=>m_,content_0_794:()=>h_,content_0_796:()=>D_,content_0_798:()=>__,content_0_8:()=>_,content_0_80:()=>wn,content_0_800:()=>C_,content_0_802:()=>v_,content_0_804:()=>N_,content_0_806:()=>P_,content_0_808:()=>W_,content_0_810:()=>G_,content_0_812:()=>U_,content_0_814:()=>q_,content_0_816:()=>Y_,content_0_818:()=>K_,content_0_82:()=>xn,content_0_820:()=>ew,content_0_822:()=>ow,content_0_824:()=>sw,content_0_826:()=>iw,content_0_828:()=>mw,content_0_830:()=>hw,content_0_832:()=>Dw,content_0_834:()=>_w,content_0_836:()=>Cw,content_0_838:()=>vw,content_0_84:()=>Ln,content_0_840:()=>Nw,content_0_842:()=>Pw,content_0_844:()=>Ww,content_0_846:()=>Gw,content_0_848:()=>Uw,content_0_850:()=>qw,content_0_852:()=>Yw,content_0_854:()=>Kw,content_0_856:()=>eT,content_0_858:()=>oT,content_0_86:()=>kn,content_0_860:()=>sT,content_0_862:()=>iT,content_0_864:()=>mT,content_0_866:()=>hT,content_0_868:()=>DT,content_0_870:()=>_T,content_0_872:()=>CT,content_0_874:()=>vT,content_0_876:()=>NT,content_0_878:()=>PT,content_0_88:()=>In,content_0_880:()=>WT,content_0_882:()=>GT,content_0_884:()=>UT,content_0_886:()=>qT,content_0_888:()=>YT,content_0_890:()=>KT,content_0_892:()=>eC,content_0_894:()=>oC,content_0_896:()=>sC,content_0_898:()=>iC,content_0_90:()=>Sn,content_0_900:()=>mC,content_0_902:()=>hC,content_0_904:()=>DC,content_0_906:()=>_C,content_0_908:()=>CC,content_0_910:()=>vC,content_0_912:()=>NC,content_0_914:()=>PC,content_0_916:()=>WC,content_0_918:()=>GC,content_0_92:()=>En,content_0_920:()=>UC,content_0_922:()=>qC,content_0_924:()=>YC,content_0_926:()=>KC,content_0_928:()=>ex,content_0_930:()=>ox,content_0_932:()=>sx,content_0_934:()=>ix,content_0_936:()=>mx,content_0_938:()=>hx,content_0_94:()=>Fn,content_0_940:()=>Dx,content_0_942:()=>_x,content_0_944:()=>Cx,content_0_946:()=>vx,content_0_948:()=>Nx,content_0_950:()=>Px,content_0_952:()=>Wx,content_0_954:()=>Gx,content_0_956:()=>Ux,content_0_958:()=>qx,content_0_96:()=>jn,content_0_960:()=>Yx,content_0_962:()=>Kx,content_0_964:()=>eA,content_0_966:()=>oA,content_0_968:()=>sA,content_0_970:()=>iA,content_0_972:()=>mA,content_0_974:()=>hA,content_0_976:()=>DA,content_0_978:()=>_A,content_0_98:()=>Qn,content_0_980:()=>CA,content_0_982:()=>vA,content_0_984:()=>NA,content_0_986:()=>PA,content_0_988:()=>WA,content_0_990:()=>GA,content_0_992:()=>UA,content_0_994:()=>qA,content_0_996:()=>YA,content_0_998:()=>KA,content_3882_0:()=>GJ,content_3882_10:()=>eZ,content_3882_100:()=>v8,content_3882_1000:()=>vge,content_3882_10000:()=>Llp,content_3882_10002:()=>klp,content_3882_10004:()=>Ilp,content_3882_10006:()=>Slp,content_3882_10008:()=>Elp,content_3882_10010:()=>Flp,content_3882_10012:()=>jlp,content_3882_10014:()=>Qlp,content_3882_10016:()=>Jlp,content_3882_10018:()=>nup,content_3882_1002:()=>Nge,content_3882_10020:()=>pup,content_3882_10022:()=>cup,content_3882_10024:()=>lup,content_3882_10026:()=>yup,content_3882_10028:()=>gup,content_3882_10030:()=>Mup,content_3882_10032:()=>wup,content_3882_10034:()=>xup,content_3882_10036:()=>Lup,content_3882_10038:()=>kup,content_3882_1004:()=>Pge,content_3882_10040:()=>Iup,content_3882_10042:()=>Sup,content_3882_10044:()=>Eup,content_3882_10046:()=>Fup,content_3882_10048:()=>jup,content_3882_10050:()=>Qup,content_3882_10052:()=>Jup,content_3882_10054:()=>nmp,content_3882_10056:()=>pmp,content_3882_10058:()=>cmp,content_3882_1006:()=>Wge,content_3882_10060:()=>lmp,content_3882_10062:()=>ymp,content_3882_10064:()=>gmp,content_3882_10066:()=>Mmp,content_3882_10068:()=>wmp,content_3882_10070:()=>xmp,content_3882_10072:()=>Lmp,content_3882_10074:()=>kmp,content_3882_10076:()=>Imp,content_3882_10078:()=>Smp,content_3882_1008:()=>Gge,content_3882_10080:()=>Emp,content_3882_10082:()=>Fmp,content_3882_10084:()=>jmp,content_3882_10086:()=>Qmp,content_3882_10088:()=>Jmp,content_3882_10090:()=>nyp,content_3882_10092:()=>pyp,content_3882_10094:()=>cyp,content_3882_10096:()=>lyp,content_3882_10098:()=>yyp,content_3882_1010:()=>Uge,content_3882_10100:()=>gyp,content_3882_10102:()=>Myp,content_3882_10104:()=>wyp,content_3882_10106:()=>xyp,content_3882_10108:()=>Lyp,content_3882_10110:()=>kyp,content_3882_10112:()=>Iyp,content_3882_10114:()=>Syp,content_3882_10116:()=>Eyp,content_3882_10118:()=>Fyp,content_3882_1012:()=>qge,content_3882_10120:()=>jyp,content_3882_10122:()=>Qyp,content_3882_10124:()=>Jyp,content_3882_10126:()=>ndp,content_3882_10128:()=>pdp,content_3882_10130:()=>cdp,content_3882_10132:()=>ldp,content_3882_10134:()=>ydp,content_3882_10136:()=>gdp,content_3882_10138:()=>Mdp,content_3882_1014:()=>Yge,content_3882_10140:()=>wdp,content_3882_10142:()=>xdp,content_3882_10144:()=>Ldp,content_3882_10146:()=>kdp,content_3882_10148:()=>Idp,content_3882_10150:()=>Sdp,content_3882_10152:()=>Edp,content_3882_10154:()=>Fdp,content_3882_10156:()=>jdp,content_3882_10158:()=>Qdp,content_3882_1016:()=>Kge,content_3882_10160:()=>Jdp,content_3882_10162:()=>nhp,content_3882_10164:()=>php,content_3882_10166:()=>chp,content_3882_10168:()=>lhp,content_3882_10170:()=>yhp,content_3882_10172:()=>ghp,content_3882_10174:()=>Mhp,content_3882_10176:()=>whp,content_3882_10178:()=>xhp,content_3882_1018:()=>efe,content_3882_10180:()=>Lhp,content_3882_10182:()=>khp,content_3882_10184:()=>Ihp,content_3882_10186:()=>Shp,content_3882_10188:()=>Ehp,content_3882_10190:()=>Fhp,content_3882_10192:()=>jhp,content_3882_10194:()=>Qhp,content_3882_10196:()=>Jhp,content_3882_10198:()=>ngp,content_3882_102:()=>N8,content_3882_1020:()=>ofe,content_3882_10200:()=>pgp,content_3882_10202:()=>cgp,content_3882_10204:()=>lgp,content_3882_10206:()=>ygp,content_3882_10208:()=>ggp,content_3882_10210:()=>Mgp,content_3882_10212:()=>wgp,content_3882_10214:()=>xgp,content_3882_10216:()=>Lgp,content_3882_10218:()=>kgp,content_3882_1022:()=>sfe,content_3882_10220:()=>Igp,content_3882_10222:()=>Sgp,content_3882_10224:()=>Egp,content_3882_10226:()=>Fgp,content_3882_10228:()=>jgp,content_3882_10230:()=>Qgp,content_3882_10232:()=>Jgp,content_3882_10234:()=>nfp,content_3882_10236:()=>pfp,content_3882_10238:()=>cfp,content_3882_1024:()=>ife,content_3882_10240:()=>lfp,content_3882_10242:()=>yfp,content_3882_10244:()=>gfp,content_3882_10246:()=>Mfp,content_3882_10248:()=>wfp,content_3882_10250:()=>xfp,content_3882_10252:()=>Lfp,content_3882_10254:()=>kfp,content_3882_10256:()=>Ifp,content_3882_10258:()=>Sfp,content_3882_1026:()=>mfe,content_3882_10260:()=>Efp,content_3882_10262:()=>Ffp,content_3882_10264:()=>jfp,content_3882_10266:()=>Qfp,content_3882_10268:()=>Jfp,content_3882_10270:()=>nDp,content_3882_10272:()=>pDp,content_3882_10274:()=>cDp,content_3882_10276:()=>lDp,content_3882_10278:()=>yDp,content_3882_1028:()=>hfe,content_3882_10280:()=>gDp,content_3882_10282:()=>MDp,content_3882_10284:()=>wDp,content_3882_10286:()=>xDp,content_3882_10288:()=>LDp,content_3882_10290:()=>kDp,content_3882_10292:()=>IDp,content_3882_10294:()=>SDp,content_3882_10296:()=>EDp,content_3882_10298:()=>FDp,content_3882_1030:()=>Dfe,content_3882_10300:()=>jDp,content_3882_10302:()=>QDp,content_3882_10304:()=>JDp,content_3882_10306:()=>nMp,content_3882_10308:()=>pMp,content_3882_10310:()=>cMp,content_3882_10312:()=>lMp,content_3882_10314:()=>yMp,content_3882_10316:()=>gMp,content_3882_10318:()=>MMp,content_3882_1032:()=>_fe,content_3882_10320:()=>wMp,content_3882_10322:()=>xMp,content_3882_10324:()=>LMp,content_3882_10326:()=>kMp,content_3882_10328:()=>IMp,content_3882_10330:()=>SMp,content_3882_10332:()=>EMp,content_3882_10334:()=>FMp,content_3882_10336:()=>jMp,content_3882_10338:()=>QMp,content_3882_1034:()=>Cfe,content_3882_10340:()=>JMp,content_3882_10342:()=>nXp,content_3882_10344:()=>pXp,content_3882_10346:()=>cXp,content_3882_10348:()=>lXp,content_3882_10350:()=>yXp,content_3882_10352:()=>gXp,content_3882_10354:()=>MXp,content_3882_10356:()=>wXp,content_3882_10358:()=>xXp,content_3882_1036:()=>vfe,content_3882_10360:()=>LXp,content_3882_10362:()=>kXp,content_3882_10364:()=>IXp,content_3882_10366:()=>SXp,content_3882_10368:()=>EXp,content_3882_10370:()=>FXp,content_3882_10372:()=>jXp,content_3882_10374:()=>QXp,content_3882_10376:()=>JXp,content_3882_10378:()=>n_p,content_3882_1038:()=>Nfe,content_3882_10380:()=>p_p,content_3882_10382:()=>c_p,content_3882_10384:()=>l_p,content_3882_10386:()=>y_p,content_3882_10388:()=>g_p,content_3882_10390:()=>M_p,content_3882_10392:()=>w_p,content_3882_10394:()=>x_p,content_3882_10396:()=>L_p,content_3882_10398:()=>k_p,content_3882_104:()=>P8,content_3882_1040:()=>Pfe,content_3882_10400:()=>I_p,content_3882_10402:()=>S_p,content_3882_10404:()=>E_p,content_3882_10406:()=>F_p,content_3882_10408:()=>j_p,content_3882_10410:()=>Q_p,content_3882_10412:()=>J_p,content_3882_10414:()=>nwp,content_3882_10416:()=>pwp,content_3882_10418:()=>cwp,content_3882_1042:()=>Wfe,content_3882_10420:()=>lwp,content_3882_10422:()=>ywp,content_3882_10424:()=>gwp,content_3882_10426:()=>Mwp,content_3882_10428:()=>wwp,content_3882_10430:()=>xwp,content_3882_10432:()=>Lwp,content_3882_10434:()=>kwp,content_3882_10436:()=>Iwp,content_3882_10438:()=>Swp,content_3882_1044:()=>Gfe,content_3882_10440:()=>Ewp,content_3882_10442:()=>Fwp,content_3882_10444:()=>jwp,content_3882_10446:()=>Qwp,content_3882_10448:()=>Jwp,content_3882_10450:()=>nTp,content_3882_10452:()=>pTp,content_3882_10454:()=>cTp,content_3882_10456:()=>lTp,content_3882_10458:()=>yTp,content_3882_1046:()=>Ufe,content_3882_10460:()=>gTp,content_3882_10462:()=>MTp,content_3882_10464:()=>wTp,content_3882_10466:()=>xTp,content_3882_10468:()=>LTp,content_3882_10470:()=>kTp,content_3882_10472:()=>ITp,content_3882_10474:()=>STp,content_3882_10476:()=>ETp,content_3882_10478:()=>FTp,content_3882_1048:()=>qfe,content_3882_10480:()=>jTp,content_3882_10482:()=>QTp,content_3882_10484:()=>JTp,content_3882_10486:()=>nCp,content_3882_10488:()=>pCp,content_3882_10490:()=>cCp,content_3882_10492:()=>lCp,content_3882_10494:()=>yCp,content_3882_10496:()=>gCp,content_3882_10498:()=>MCp,content_3882_1050:()=>Yfe,content_3882_10500:()=>wCp,content_3882_10502:()=>xCp,content_3882_10504:()=>LCp,content_3882_10506:()=>kCp,content_3882_10508:()=>ICp,content_3882_10510:()=>SCp,content_3882_10512:()=>ECp,content_3882_10514:()=>FCp,content_3882_10516:()=>jCp,content_3882_10518:()=>QCp,content_3882_1052:()=>Kfe,content_3882_10520:()=>JCp,content_3882_10522:()=>nxp,content_3882_10524:()=>pxp,content_3882_10526:()=>cxp,content_3882_10528:()=>lxp,content_3882_10530:()=>yxp,content_3882_10532:()=>gxp,content_3882_10534:()=>Mxp,content_3882_10536:()=>wxp,content_3882_10538:()=>xxp,content_3882_1054:()=>eDe,content_3882_10540:()=>Lxp,content_3882_10542:()=>kxp,content_3882_10544:()=>Ixp,content_3882_10546:()=>Sxp,content_3882_10548:()=>Exp,content_3882_10550:()=>Fxp,content_3882_10552:()=>jxp,content_3882_10554:()=>Qxp,content_3882_10556:()=>Jxp,content_3882_10558:()=>nAp,content_3882_1056:()=>oDe,content_3882_10560:()=>pAp,content_3882_10562:()=>cAp,content_3882_10564:()=>lAp,content_3882_10566:()=>yAp,content_3882_10568:()=>gAp,content_3882_10570:()=>MAp,content_3882_10572:()=>wAp,content_3882_10574:()=>xAp,content_3882_10576:()=>LAp,content_3882_10578:()=>kAp,content_3882_1058:()=>sDe,content_3882_10580:()=>IAp,content_3882_10582:()=>SAp,content_3882_10584:()=>EAp,content_3882_10586:()=>FAp,content_3882_10588:()=>jAp,content_3882_10590:()=>QAp,content_3882_10592:()=>JAp,content_3882_10594:()=>nvp,content_3882_10596:()=>pvp,content_3882_10598:()=>cvp,content_3882_106:()=>W8,content_3882_1060:()=>iDe,content_3882_10600:()=>lvp,content_3882_10602:()=>yvp,content_3882_10604:()=>gvp,content_3882_10606:()=>Mvp,content_3882_10608:()=>wvp,content_3882_10610:()=>xvp,content_3882_10612:()=>Lvp,content_3882_10614:()=>kvp,content_3882_10616:()=>Ivp,content_3882_10618:()=>Svp,content_3882_1062:()=>mDe,content_3882_10620:()=>Evp,content_3882_10622:()=>Fvp,content_3882_10624:()=>jvp,content_3882_10626:()=>Qvp,content_3882_10628:()=>Jvp,content_3882_10630:()=>nLp,content_3882_10632:()=>pLp,content_3882_10634:()=>cLp,content_3882_10636:()=>lLp,content_3882_10638:()=>yLp,content_3882_1064:()=>hDe,content_3882_10640:()=>gLp,content_3882_10642:()=>MLp,content_3882_10644:()=>wLp,content_3882_10646:()=>xLp,content_3882_10648:()=>LLp,content_3882_10650:()=>kLp,content_3882_10652:()=>ILp,content_3882_10654:()=>SLp,content_3882_10656:()=>ELp,content_3882_10658:()=>FLp,content_3882_1066:()=>DDe,content_3882_10660:()=>jLp,content_3882_10662:()=>QLp,content_3882_10664:()=>JLp,content_3882_10666:()=>nbp,content_3882_10668:()=>pbp,content_3882_10670:()=>cbp,content_3882_10672:()=>lbp,content_3882_10674:()=>ybp,content_3882_10676:()=>gbp,content_3882_10678:()=>Mbp,content_3882_1068:()=>_De,content_3882_10680:()=>wbp,content_3882_10682:()=>xbp,content_3882_10684:()=>Lbp,content_3882_10686:()=>kbp,content_3882_10688:()=>Ibp,content_3882_10690:()=>Sbp,content_3882_10692:()=>Ebp,content_3882_10694:()=>Fbp,content_3882_10696:()=>jbp,content_3882_10698:()=>Qbp,content_3882_1070:()=>CDe,content_3882_10700:()=>Jbp,content_3882_10702:()=>nNp,content_3882_10704:()=>pNp,content_3882_10706:()=>cNp,content_3882_10708:()=>lNp,content_3882_10710:()=>yNp,content_3882_10712:()=>gNp,content_3882_10714:()=>MNp,content_3882_10716:()=>wNp,content_3882_10718:()=>xNp,content_3882_1072:()=>vDe,content_3882_10720:()=>LNp,content_3882_10722:()=>kNp,content_3882_10724:()=>INp,content_3882_10726:()=>SNp,content_3882_10728:()=>ENp,content_3882_10730:()=>FNp,content_3882_10732:()=>jNp,content_3882_10734:()=>QNp,content_3882_10736:()=>JNp,content_3882_10738:()=>nkp,content_3882_1074:()=>NDe,content_3882_10740:()=>pkp,content_3882_10742:()=>ckp,content_3882_10744:()=>lkp,content_3882_10746:()=>ykp,content_3882_10748:()=>gkp,content_3882_10750:()=>Mkp,content_3882_10752:()=>wkp,content_3882_10754:()=>xkp,content_3882_10756:()=>Lkp,content_3882_10758:()=>kkp,content_3882_1076:()=>PDe,content_3882_10760:()=>Ikp,content_3882_10762:()=>Skp,content_3882_10764:()=>Ekp,content_3882_10766:()=>Fkp,content_3882_10768:()=>jkp,content_3882_10770:()=>Qkp,content_3882_10772:()=>Jkp,content_3882_10774:()=>nzp,content_3882_10776:()=>pzp,content_3882_10778:()=>czp,content_3882_1078:()=>WDe,content_3882_10780:()=>lzp,content_3882_10782:()=>yzp,content_3882_10784:()=>gzp,content_3882_10786:()=>Mzp,content_3882_10788:()=>wzp,content_3882_10790:()=>xzp,content_3882_10792:()=>Lzp,content_3882_10794:()=>kzp,content_3882_10796:()=>Izp,content_3882_10798:()=>Szp,content_3882_108:()=>G8,content_3882_1080:()=>GDe,content_3882_10800:()=>Ezp,content_3882_10802:()=>Fzp,content_3882_10804:()=>jzp,content_3882_10806:()=>Qzp,content_3882_10808:()=>Jzp,content_3882_10810:()=>nPp,content_3882_10812:()=>pPp,content_3882_10814:()=>cPp,content_3882_10816:()=>lPp,content_3882_10818:()=>yPp,content_3882_1082:()=>UDe,content_3882_10820:()=>gPp,content_3882_10822:()=>MPp,content_3882_10824:()=>wPp,content_3882_10826:()=>xPp,content_3882_10828:()=>LPp,content_3882_10830:()=>kPp,content_3882_10832:()=>IPp,content_3882_10834:()=>SPp,content_3882_10836:()=>EPp,content_3882_10838:()=>FPp,content_3882_1084:()=>qDe,content_3882_10840:()=>jPp,content_3882_10842:()=>QPp,content_3882_10844:()=>JPp,content_3882_10846:()=>nIp,content_3882_10848:()=>pIp,content_3882_10850:()=>cIp,content_3882_10852:()=>lIp,content_3882_10854:()=>yIp,content_3882_10856:()=>gIp,content_3882_10858:()=>MIp,content_3882_1086:()=>YDe,content_3882_10860:()=>wIp,content_3882_10862:()=>xIp,content_3882_10864:()=>LIp,content_3882_10866:()=>kIp,content_3882_10868:()=>IIp,content_3882_10870:()=>SIp,content_3882_10872:()=>EIp,content_3882_10874:()=>FIp,content_3882_10876:()=>jIp,content_3882_10878:()=>QIp,content_3882_1088:()=>KDe,content_3882_10880:()=>JIp,content_3882_10882:()=>nRp,content_3882_10884:()=>pRp,content_3882_10886:()=>cRp,content_3882_10888:()=>lRp,content_3882_10890:()=>yRp,content_3882_10892:()=>gRp,content_3882_10894:()=>MRp,content_3882_10896:()=>wRp,content_3882_10898:()=>xRp,content_3882_1090:()=>eMe,content_3882_10900:()=>LRp,content_3882_10902:()=>kRp,content_3882_10904:()=>IRp,content_3882_10906:()=>SRp,content_3882_10908:()=>ERp,content_3882_10910:()=>FRp,content_3882_10912:()=>jRp,content_3882_10914:()=>QRp,content_3882_10916:()=>JRp,content_3882_10918:()=>nWp,content_3882_1092:()=>oMe,content_3882_10920:()=>pWp,content_3882_10922:()=>cWp,content_3882_10924:()=>lWp,content_3882_10926:()=>yWp,content_3882_10928:()=>gWp,content_3882_10930:()=>MWp,content_3882_10932:()=>wWp,content_3882_10934:()=>xWp,content_3882_10936:()=>LWp,content_3882_10938:()=>kWp,content_3882_1094:()=>sMe,content_3882_10940:()=>IWp,content_3882_10942:()=>SWp,content_3882_10944:()=>EWp,content_3882_10946:()=>FWp,content_3882_10948:()=>jWp,content_3882_10950:()=>QWp,content_3882_10952:()=>JWp,content_3882_10954:()=>nSp,content_3882_10956:()=>pSp,content_3882_10958:()=>cSp,content_3882_1096:()=>iMe,content_3882_10960:()=>lSp,content_3882_10962:()=>ySp,content_3882_10964:()=>gSp,content_3882_10966:()=>MSp,content_3882_10968:()=>wSp,content_3882_10970:()=>xSp,content_3882_10972:()=>LSp,content_3882_10974:()=>kSp,content_3882_10976:()=>ISp,content_3882_10978:()=>SSp,content_3882_1098:()=>mMe,content_3882_10980:()=>ESp,content_3882_10982:()=>FSp,content_3882_10984:()=>jSp,content_3882_10986:()=>QSp,content_3882_10988:()=>JSp,content_3882_10990:()=>nBp,content_3882_10992:()=>pBp,content_3882_10994:()=>cBp,content_3882_10996:()=>lBp,content_3882_10998:()=>yBp,content_3882_110:()=>U8,content_3882_1100:()=>hMe,content_3882_11000:()=>gBp,content_3882_11002:()=>MBp,content_3882_11004:()=>wBp,content_3882_11006:()=>xBp,content_3882_11008:()=>LBp,content_3882_11010:()=>kBp,content_3882_11012:()=>IBp,content_3882_11014:()=>SBp,content_3882_11016:()=>EBp,content_3882_11018:()=>FBp,content_3882_1102:()=>DMe,content_3882_11020:()=>jBp,content_3882_11022:()=>QBp,content_3882_11024:()=>JBp,content_3882_11026:()=>nGp,content_3882_11028:()=>pGp,content_3882_11030:()=>cGp,content_3882_11032:()=>lGp,content_3882_11034:()=>yGp,content_3882_11036:()=>gGp,content_3882_11038:()=>MGp,content_3882_1104:()=>_Me,content_3882_11040:()=>wGp,content_3882_11042:()=>xGp,content_3882_11044:()=>LGp,content_3882_11046:()=>kGp,content_3882_11048:()=>IGp,content_3882_11050:()=>SGp,content_3882_11052:()=>EGp,content_3882_11054:()=>FGp,content_3882_11056:()=>jGp,content_3882_11058:()=>QGp,content_3882_1106:()=>CMe,content_3882_11060:()=>JGp,content_3882_11062:()=>nEp,content_3882_11064:()=>pEp,content_3882_11066:()=>cEp,content_3882_11068:()=>lEp,content_3882_11070:()=>yEp,content_3882_11072:()=>gEp,content_3882_11074:()=>MEp,content_3882_11076:()=>wEp,content_3882_11078:()=>xEp,content_3882_1108:()=>vMe,content_3882_11080:()=>LEp,content_3882_11082:()=>kEp,content_3882_11084:()=>IEp,content_3882_11086:()=>SEp,content_3882_11088:()=>EEp,content_3882_11090:()=>FEp,content_3882_11092:()=>jEp,content_3882_11094:()=>QEp,content_3882_11096:()=>JEp,content_3882_11098:()=>nOp,content_3882_1110:()=>NMe,content_3882_11100:()=>pOp,content_3882_11102:()=>cOp,content_3882_11104:()=>lOp,content_3882_11106:()=>yOp,content_3882_11108:()=>gOp,content_3882_11110:()=>MOp,content_3882_11112:()=>wOp,content_3882_11114:()=>xOp,content_3882_11116:()=>LOp,content_3882_11118:()=>kOp,content_3882_1112:()=>PMe,content_3882_11120:()=>IOp,content_3882_11122:()=>SOp,content_3882_11124:()=>EOp,content_3882_11126:()=>FOp,content_3882_11128:()=>jOp,content_3882_11130:()=>QOp,content_3882_11132:()=>JOp,content_3882_11134:()=>nUp,content_3882_11136:()=>pUp,content_3882_11138:()=>cUp,content_3882_1114:()=>WMe,content_3882_11140:()=>lUp,content_3882_11142:()=>yUp,content_3882_11144:()=>gUp,content_3882_11146:()=>MUp,content_3882_11148:()=>wUp,content_3882_11150:()=>xUp,content_3882_11152:()=>LUp,content_3882_11154:()=>kUp,content_3882_11156:()=>IUp,content_3882_11158:()=>SUp,content_3882_1116:()=>GMe,content_3882_11160:()=>EUp,content_3882_11162:()=>FUp,content_3882_11164:()=>jUp,content_3882_11166:()=>QUp,content_3882_11168:()=>JUp,content_3882_11170:()=>nFp,content_3882_11172:()=>pFp,content_3882_11174:()=>cFp,content_3882_11176:()=>lFp,content_3882_11178:()=>yFp,content_3882_1118:()=>UMe,content_3882_11180:()=>gFp,content_3882_11182:()=>MFp,content_3882_11184:()=>wFp,content_3882_11186:()=>xFp,content_3882_11188:()=>LFp,content_3882_11190:()=>kFp,content_3882_11192:()=>IFp,content_3882_11194:()=>SFp,content_3882_11196:()=>EFp,content_3882_11198:()=>FFp,content_3882_112:()=>q8,content_3882_1120:()=>qMe,content_3882_11200:()=>jFp,content_3882_11202:()=>QFp,content_3882_11204:()=>JFp,content_3882_11206:()=>nVp,content_3882_11208:()=>pVp,content_3882_11210:()=>cVp,content_3882_11212:()=>lVp,content_3882_11214:()=>yVp,content_3882_11216:()=>gVp,content_3882_11218:()=>MVp,content_3882_1122:()=>YMe,content_3882_11220:()=>wVp,content_3882_11222:()=>xVp,content_3882_11224:()=>LVp,content_3882_11226:()=>kVp,content_3882_11228:()=>IVp,content_3882_11230:()=>SVp,content_3882_11232:()=>EVp,content_3882_11234:()=>FVp,content_3882_11236:()=>jVp,content_3882_11238:()=>QVp,content_3882_1124:()=>KMe,content_3882_11240:()=>JVp,content_3882_11242:()=>nqp,content_3882_11244:()=>pqp,content_3882_11246:()=>cqp,content_3882_11248:()=>lqp,content_3882_11250:()=>yqp,content_3882_11252:()=>gqp,content_3882_11254:()=>Mqp,content_3882_11256:()=>wqp,content_3882_11258:()=>xqp,content_3882_1126:()=>eXe,content_3882_11260:()=>Lqp,content_3882_11262:()=>kqp,content_3882_11264:()=>Iqp,content_3882_11266:()=>Sqp,content_3882_11268:()=>Eqp,content_3882_11270:()=>Fqp,content_3882_11272:()=>jqp,content_3882_11274:()=>Qqp,content_3882_11276:()=>Jqp,content_3882_11278:()=>njp,content_3882_1128:()=>oXe,content_3882_11280:()=>pjp,content_3882_11282:()=>cjp,content_3882_11284:()=>ljp,content_3882_11286:()=>yjp,content_3882_11288:()=>gjp,content_3882_11290:()=>Mjp,content_3882_11292:()=>wjp,content_3882_11294:()=>xjp,content_3882_11296:()=>Ljp,content_3882_11298:()=>kjp,content_3882_1130:()=>sXe,content_3882_11300:()=>Ijp,content_3882_11302:()=>Sjp,content_3882_11304:()=>Ejp,content_3882_11306:()=>Fjp,content_3882_11308:()=>jjp,content_3882_11310:()=>Qjp,content_3882_11312:()=>Jjp,content_3882_11314:()=>nHp,content_3882_11316:()=>pHp,content_3882_11318:()=>cHp,content_3882_1132:()=>iXe,content_3882_11320:()=>lHp,content_3882_11322:()=>yHp,content_3882_11324:()=>gHp,content_3882_11326:()=>MHp,content_3882_11328:()=>wHp,content_3882_11330:()=>xHp,content_3882_11332:()=>LHp,content_3882_11334:()=>kHp,content_3882_11336:()=>IHp,content_3882_11338:()=>SHp,content_3882_1134:()=>mXe,content_3882_11340:()=>EHp,content_3882_11342:()=>FHp,content_3882_11344:()=>jHp,content_3882_11346:()=>QHp,content_3882_11348:()=>JHp,content_3882_11350:()=>nYp,content_3882_11352:()=>pYp,content_3882_11354:()=>cYp,content_3882_11356:()=>lYp,content_3882_11358:()=>yYp,content_3882_1136:()=>hXe,content_3882_11360:()=>gYp,content_3882_11362:()=>MYp,content_3882_11364:()=>wYp,content_3882_11366:()=>xYp,content_3882_11368:()=>LYp,content_3882_11370:()=>kYp,content_3882_11372:()=>IYp,content_3882_11374:()=>SYp,content_3882_11376:()=>EYp,content_3882_11378:()=>FYp,content_3882_1138:()=>DXe,content_3882_11380:()=>jYp,content_3882_11382:()=>QYp,content_3882_11384:()=>JYp,content_3882_11386:()=>nQp,content_3882_11388:()=>pQp,content_3882_11390:()=>cQp,content_3882_11392:()=>lQp,content_3882_11394:()=>yQp,content_3882_11396:()=>gQp,content_3882_11398:()=>MQp,content_3882_114:()=>Y8,content_3882_1140:()=>_Xe,content_3882_11400:()=>wQp,content_3882_11402:()=>xQp,content_3882_11404:()=>LQp,content_3882_11406:()=>kQp,content_3882_11408:()=>IQp,content_3882_11410:()=>SQp,content_3882_11412:()=>EQp,content_3882_11414:()=>FQp,content_3882_11416:()=>jQp,content_3882_11418:()=>QQp,content_3882_1142:()=>CXe,content_3882_11420:()=>JQp,content_3882_11422:()=>n$p,content_3882_11424:()=>p$p,content_3882_11426:()=>c$p,content_3882_11428:()=>l$p,content_3882_11430:()=>y$p,content_3882_11432:()=>g$p,content_3882_11434:()=>M$p,content_3882_11436:()=>w$p,content_3882_11438:()=>x$p,content_3882_1144:()=>vXe,content_3882_11440:()=>L$p,content_3882_11442:()=>k$p,content_3882_11444:()=>I$p,content_3882_11446:()=>S$p,content_3882_11448:()=>E$p,content_3882_11450:()=>F$p,content_3882_11452:()=>j$p,content_3882_11454:()=>Q$p,content_3882_11456:()=>J$p,content_3882_11458:()=>nKp,content_3882_1146:()=>NXe,content_3882_11460:()=>pKp,content_3882_11462:()=>cKp,content_3882_11464:()=>lKp,content_3882_11466:()=>yKp,content_3882_11468:()=>gKp,content_3882_11470:()=>MKp,content_3882_11472:()=>wKp,content_3882_11474:()=>xKp,content_3882_11476:()=>LKp,content_3882_11478:()=>kKp,content_3882_1148:()=>PXe,content_3882_11480:()=>IKp,content_3882_11482:()=>SKp,content_3882_11484:()=>EKp,content_3882_11486:()=>FKp,content_3882_11488:()=>jKp,content_3882_11490:()=>QKp,content_3882_11492:()=>JKp,content_3882_11494:()=>nJp,content_3882_11496:()=>pJp,content_3882_11498:()=>cJp,content_3882_1150:()=>WXe,content_3882_11500:()=>lJp,content_3882_11502:()=>yJp,content_3882_11504:()=>gJp,content_3882_11506:()=>MJp,content_3882_11508:()=>wJp,content_3882_11510:()=>xJp,content_3882_11512:()=>LJp,content_3882_11514:()=>kJp,content_3882_11516:()=>IJp,content_3882_11518:()=>SJp,content_3882_1152:()=>GXe,content_3882_11520:()=>EJp,content_3882_11522:()=>FJp,content_3882_11524:()=>jJp,content_3882_11526:()=>QJp,content_3882_11528:()=>JJp,content_3882_11530:()=>nZp,content_3882_11532:()=>pZp,content_3882_11534:()=>cZp,content_3882_11536:()=>lZp,content_3882_11538:()=>yZp,content_3882_1154:()=>UXe,content_3882_11540:()=>gZp,content_3882_11542:()=>MZp,content_3882_11544:()=>wZp,content_3882_11546:()=>xZp,content_3882_11548:()=>LZp,content_3882_11550:()=>kZp,content_3882_11552:()=>IZp,content_3882_11554:()=>SZp,content_3882_11556:()=>EZp,content_3882_11558:()=>FZp,content_3882_1156:()=>qXe,content_3882_11560:()=>jZp,content_3882_11562:()=>QZp,content_3882_11564:()=>JZp,content_3882_11566:()=>n0p,content_3882_11568:()=>p0p,content_3882_11570:()=>c0p,content_3882_11572:()=>l0p,content_3882_11574:()=>y0p,content_3882_11576:()=>g0p,content_3882_11578:()=>M0p,content_3882_1158:()=>YXe,content_3882_11580:()=>w0p,content_3882_11582:()=>x0p,content_3882_11584:()=>L0p,content_3882_11586:()=>k0p,content_3882_11588:()=>I0p,content_3882_11590:()=>S0p,content_3882_11592:()=>E0p,content_3882_11594:()=>F0p,content_3882_11596:()=>j0p,content_3882_11598:()=>Q0p,content_3882_116:()=>K8,content_3882_1160:()=>KXe,content_3882_11600:()=>J0p,content_3882_11602:()=>n8p,content_3882_11604:()=>p8p,content_3882_11606:()=>c8p,content_3882_11608:()=>l8p,content_3882_11610:()=>y8p,content_3882_11612:()=>g8p,content_3882_11614:()=>M8p,content_3882_11616:()=>w8p,content_3882_11618:()=>x8p,content_3882_1162:()=>e_e,content_3882_11620:()=>L8p,content_3882_11622:()=>k8p,content_3882_11624:()=>I8p,content_3882_11626:()=>S8p,content_3882_11628:()=>E8p,content_3882_11630:()=>F8p,content_3882_11632:()=>j8p,content_3882_11634:()=>Q8p,content_3882_11636:()=>J8p,content_3882_11638:()=>n2p,content_3882_1164:()=>o_e,content_3882_11640:()=>p2p,content_3882_11642:()=>c2p,content_3882_11644:()=>l2p,content_3882_11646:()=>y2p,content_3882_11648:()=>g2p,content_3882_11650:()=>M2p,content_3882_11652:()=>w2p,content_3882_11654:()=>x2p,content_3882_11656:()=>L2p,content_3882_11658:()=>k2p,content_3882_1166:()=>s_e,content_3882_11660:()=>I2p,content_3882_11662:()=>S2p,content_3882_11664:()=>E2p,content_3882_11666:()=>F2p,content_3882_11668:()=>j2p,content_3882_11670:()=>Q2p,content_3882_11672:()=>J2p,content_3882_11674:()=>n3p,content_3882_11676:()=>p3p,content_3882_11678:()=>c3p,content_3882_1168:()=>i_e,content_3882_11680:()=>l3p,content_3882_11682:()=>y3p,content_3882_11684:()=>g3p,content_3882_11686:()=>M3p,content_3882_11688:()=>w3p,content_3882_11690:()=>x3p,content_3882_11692:()=>L3p,content_3882_11694:()=>k3p,content_3882_11696:()=>I3p,content_3882_11698:()=>S3p,content_3882_1170:()=>m_e,content_3882_11700:()=>E3p,content_3882_11702:()=>F3p,content_3882_11704:()=>j3p,content_3882_11706:()=>Q3p,content_3882_11708:()=>J3p,content_3882_11710:()=>n1p,content_3882_11712:()=>p1p,content_3882_11714:()=>c1p,content_3882_11716:()=>l1p,content_3882_11718:()=>y1p,content_3882_1172:()=>h_e,content_3882_11720:()=>g1p,content_3882_11722:()=>M1p,content_3882_11724:()=>w1p,content_3882_11726:()=>x1p,content_3882_11728:()=>L1p,content_3882_11730:()=>k1p,content_3882_11732:()=>I1p,content_3882_11734:()=>S1p,content_3882_11736:()=>E1p,content_3882_11738:()=>F1p,content_3882_1174:()=>D_e,content_3882_11740:()=>j1p,content_3882_11742:()=>Q1p,content_3882_11744:()=>J1p,content_3882_11746:()=>n4p,content_3882_11748:()=>p4p,content_3882_11750:()=>c4p,content_3882_11752:()=>l4p,content_3882_11754:()=>y4p,content_3882_11756:()=>g4p,content_3882_11758:()=>M4p,content_3882_1176:()=>__e,content_3882_11760:()=>w4p,content_3882_11762:()=>x4p,content_3882_11764:()=>L4p,content_3882_11766:()=>k4p,content_3882_11768:()=>I4p,content_3882_11770:()=>S4p,content_3882_11772:()=>E4p,content_3882_11774:()=>F4p,content_3882_11776:()=>j4p,content_3882_11778:()=>Q4p,content_3882_1178:()=>C_e,content_3882_11780:()=>J4p,content_3882_11782:()=>n6p,content_3882_11784:()=>p6p,content_3882_11786:()=>c6p,content_3882_11788:()=>l6p,content_3882_11790:()=>y6p,content_3882_11792:()=>g6p,content_3882_11794:()=>M6p,content_3882_11796:()=>w6p,content_3882_11798:()=>x6p,content_3882_118:()=>e2,content_3882_1180:()=>v_e,content_3882_11800:()=>L6p,content_3882_11802:()=>k6p,content_3882_11804:()=>I6p,content_3882_11806:()=>S6p,content_3882_11808:()=>E6p,content_3882_11810:()=>F6p,content_3882_11812:()=>j6p,content_3882_11814:()=>Q6p,content_3882_11816:()=>J6p,content_3882_11818:()=>n5p,content_3882_1182:()=>N_e,content_3882_11820:()=>p5p,content_3882_11822:()=>c5p,content_3882_11824:()=>l5p,content_3882_11826:()=>y5p,content_3882_11828:()=>g5p,content_3882_11830:()=>M5p,content_3882_11832:()=>w5p,content_3882_11834:()=>x5p,content_3882_11836:()=>L5p,content_3882_11838:()=>k5p,content_3882_1184:()=>P_e,content_3882_11840:()=>I5p,content_3882_11842:()=>S5p,content_3882_11844:()=>E5p,content_3882_11846:()=>F5p,content_3882_11848:()=>j5p,content_3882_11850:()=>Q5p,content_3882_11852:()=>J5p,content_3882_11854:()=>n7p,content_3882_11856:()=>p7p,content_3882_11858:()=>c7p,content_3882_1186:()=>W_e,content_3882_11860:()=>l7p,content_3882_11862:()=>y7p,content_3882_11864:()=>g7p,content_3882_11866:()=>M7p,content_3882_11868:()=>w7p,content_3882_11870:()=>x7p,content_3882_11872:()=>L7p,content_3882_11874:()=>k7p,content_3882_11876:()=>I7p,content_3882_11878:()=>S7p,content_3882_1188:()=>G_e,content_3882_11880:()=>E7p,content_3882_11882:()=>F7p,content_3882_11884:()=>j7p,content_3882_11886:()=>Q7p,content_3882_11888:()=>J7p,content_3882_11890:()=>n9p,content_3882_11892:()=>p9p,content_3882_11894:()=>c9p,content_3882_11896:()=>l9p,content_3882_11898:()=>y9p,content_3882_1190:()=>U_e,content_3882_11900:()=>g9p,content_3882_11902:()=>M9p,content_3882_11904:()=>w9p,content_3882_11906:()=>x9p,content_3882_11908:()=>L9p,content_3882_11910:()=>k9p,content_3882_11912:()=>I9p,content_3882_11914:()=>S9p,content_3882_11916:()=>E9p,content_3882_11918:()=>F9p,content_3882_1192:()=>q_e,content_3882_11920:()=>j9p,content_3882_11922:()=>Q9p,content_3882_11924:()=>J9p,content_3882_11926:()=>ner,content_3882_11928:()=>per,content_3882_11930:()=>cer,content_3882_11932:()=>ler,content_3882_11934:()=>yer,content_3882_11936:()=>ger,content_3882_11938:()=>Mer,content_3882_1194:()=>Y_e,content_3882_11940:()=>wer,content_3882_11942:()=>xer,content_3882_11944:()=>Ler,content_3882_11946:()=>ker,content_3882_11948:()=>Ier,content_3882_11950:()=>Ser,content_3882_11952:()=>Eer,content_3882_11954:()=>Fer,content_3882_11956:()=>jer,content_3882_11958:()=>Qer,content_3882_1196:()=>K_e,content_3882_11960:()=>Jer,content_3882_11962:()=>nnr,content_3882_11964:()=>pnr,content_3882_11966:()=>cnr,content_3882_11968:()=>lnr,content_3882_11970:()=>ynr,content_3882_11972:()=>gnr,content_3882_11974:()=>Mnr,content_3882_11976:()=>wnr,content_3882_11978:()=>xnr,content_3882_1198:()=>ewe,content_3882_11980:()=>Lnr,content_3882_11982:()=>knr,content_3882_11984:()=>Inr,content_3882_11986:()=>Snr,content_3882_11988:()=>Enr,content_3882_11990:()=>Fnr,content_3882_11992:()=>jnr,content_3882_11994:()=>Qnr,content_3882_11996:()=>Jnr,content_3882_11998:()=>ntr,content_3882_12:()=>oZ,content_3882_120:()=>o2,content_3882_1200:()=>owe,content_3882_12000:()=>ptr,content_3882_12002:()=>ctr,content_3882_12004:()=>ltr,content_3882_12006:()=>ytr,content_3882_12008:()=>gtr,content_3882_12010:()=>Mtr,content_3882_12012:()=>wtr,content_3882_12014:()=>xtr,content_3882_12016:()=>Ltr,content_3882_12018:()=>ktr,content_3882_1202:()=>swe,content_3882_12020:()=>Itr,content_3882_12022:()=>Str,content_3882_12024:()=>Etr,content_3882_12026:()=>Ftr,content_3882_12028:()=>jtr,content_3882_12030:()=>Qtr,content_3882_12032:()=>Jtr,content_3882_12034:()=>nor,content_3882_12036:()=>por,content_3882_12038:()=>cor,content_3882_1204:()=>iwe,content_3882_12040:()=>lor,content_3882_12042:()=>yor,content_3882_12044:()=>gor,content_3882_12046:()=>Xor,content_3882_12048:()=>Tor,content_3882_12050:()=>Aor,content_3882_12052:()=>bor,content_3882_12054:()=>zor,content_3882_12056:()=>Ror,content_3882_12058:()=>Bor,content_3882_1206:()=>mwe,content_3882_12060:()=>Oor,content_3882_12062:()=>Vor,content_3882_12064:()=>Hor,content_3882_12066:()=>$or,content_3882_12068:()=>Zor,content_3882_12070:()=>tpr,content_3882_12072:()=>rpr,content_3882_12074:()=>apr,content_3882_12076:()=>upr,content_3882_12078:()=>dpr,content_3882_1208:()=>hwe,content_3882_12080:()=>fpr,content_3882_12082:()=>Xpr,content_3882_12084:()=>Tpr,content_3882_12086:()=>Apr,content_3882_12088:()=>bpr,content_3882_12090:()=>zpr,content_3882_12092:()=>Rpr,content_3882_12094:()=>Bpr,content_3882_12096:()=>Opr,content_3882_12098:()=>Vpr,content_3882_1210:()=>Dwe,content_3882_12100:()=>Hpr,content_3882_12102:()=>$pr,content_3882_12104:()=>Zpr,content_3882_12106:()=>trr,content_3882_12108:()=>rrr,content_3882_12110:()=>arr,content_3882_12112:()=>urr,content_3882_12114:()=>drr,content_3882_12116:()=>frr,content_3882_12118:()=>Xrr,content_3882_1212:()=>_we,content_3882_12120:()=>Trr,content_3882_12122:()=>Arr,content_3882_12124:()=>brr,content_3882_12126:()=>zrr,content_3882_12128:()=>Rrr,content_3882_12130:()=>Brr,content_3882_12132:()=>Orr,content_3882_12134:()=>Vrr,content_3882_12136:()=>Hrr,content_3882_12138:()=>$rr,content_3882_1214:()=>Cwe,content_3882_12140:()=>Zrr,content_3882_12142:()=>tsr,content_3882_12144:()=>rsr,content_3882_12146:()=>asr,content_3882_12148:()=>usr,content_3882_12150:()=>dsr,content_3882_12152:()=>fsr,content_3882_12154:()=>Xsr,content_3882_12156:()=>Tsr,content_3882_12158:()=>Asr,content_3882_1216:()=>vwe,content_3882_12160:()=>bsr,content_3882_12162:()=>zsr,content_3882_12164:()=>Rsr,content_3882_12166:()=>Bsr,content_3882_12168:()=>Osr,content_3882_12170:()=>Vsr,content_3882_12172:()=>Hsr,content_3882_12174:()=>$sr,content_3882_12176:()=>Zsr,content_3882_12178:()=>tcr,content_3882_1218:()=>Nwe,content_3882_12180:()=>rcr,content_3882_12182:()=>acr,content_3882_12184:()=>ucr,content_3882_12186:()=>dcr,content_3882_12188:()=>fcr,content_3882_12190:()=>Xcr,content_3882_12192:()=>Tcr,content_3882_12194:()=>Acr,content_3882_12196:()=>bcr,content_3882_12198:()=>zcr,content_3882_122:()=>s2,content_3882_1220:()=>Pwe,content_3882_12200:()=>Rcr,content_3882_12202:()=>Bcr,content_3882_12204:()=>Ocr,content_3882_12206:()=>Vcr,content_3882_12208:()=>Hcr,content_3882_12210:()=>$cr,content_3882_12212:()=>Zcr,content_3882_12214:()=>tar,content_3882_12216:()=>rar,content_3882_12218:()=>aar,content_3882_1222:()=>Wwe,content_3882_12220:()=>uar,content_3882_12222:()=>dar,content_3882_12224:()=>far,content_3882_12226:()=>Xar,content_3882_12228:()=>Tar,content_3882_12230:()=>Aar,content_3882_12232:()=>Nar,content_3882_12234:()=>Par,content_3882_12236:()=>War,content_3882_12238:()=>Gar,content_3882_1224:()=>Gwe,content_3882_12240:()=>Uar,content_3882_12242:()=>qar,content_3882_12244:()=>Yar,content_3882_12246:()=>Kar,content_3882_12248:()=>eir,content_3882_12250:()=>oir,content_3882_12252:()=>sir,content_3882_12254:()=>iir,content_3882_12256:()=>mir,content_3882_12258:()=>hir,content_3882_1226:()=>Uwe,content_3882_12260:()=>Dir,content_3882_12262:()=>_ir,content_3882_12264:()=>Cir,content_3882_12266:()=>vir,content_3882_12268:()=>Nir,content_3882_12270:()=>Pir,content_3882_12272:()=>Wir,content_3882_12274:()=>Gir,content_3882_12276:()=>Uir,content_3882_12278:()=>qir,content_3882_1228:()=>qwe,content_3882_12280:()=>Yir,content_3882_12282:()=>Kir,content_3882_12284:()=>elr,content_3882_12286:()=>olr,content_3882_12288:()=>slr,content_3882_12290:()=>ilr,content_3882_12292:()=>mlr,content_3882_12294:()=>hlr,content_3882_12296:()=>Dlr,content_3882_12298:()=>_lr,content_3882_1230:()=>Ywe,content_3882_12300:()=>Clr,content_3882_12302:()=>vlr,content_3882_12304:()=>Nlr,content_3882_12306:()=>Plr,content_3882_12308:()=>Wlr,content_3882_12310:()=>Glr,content_3882_12312:()=>Ulr,content_3882_12314:()=>qlr,content_3882_12316:()=>Ylr,content_3882_12318:()=>Klr,content_3882_1232:()=>Kwe,content_3882_12320:()=>eur,content_3882_12322:()=>our,content_3882_12324:()=>sur,content_3882_12326:()=>iur,content_3882_12328:()=>mur,content_3882_12330:()=>hur,content_3882_12332:()=>Dur,content_3882_12334:()=>_ur,content_3882_12336:()=>Cur,content_3882_12338:()=>vur,content_3882_1234:()=>eTe,content_3882_12340:()=>Nur,content_3882_12342:()=>Pur,content_3882_12344:()=>Wur,content_3882_12346:()=>Gur,content_3882_12348:()=>Uur,content_3882_12350:()=>qur,content_3882_12352:()=>Yur,content_3882_12354:()=>Kur,content_3882_12356:()=>emr,content_3882_12358:()=>omr,content_3882_1236:()=>oTe,content_3882_12360:()=>smr,content_3882_12362:()=>imr,content_3882_12364:()=>mmr,content_3882_12366:()=>hmr,content_3882_12368:()=>Dmr,content_3882_12370:()=>_mr,content_3882_12372:()=>Cmr,content_3882_12374:()=>vmr,content_3882_12376:()=>Nmr,content_3882_12378:()=>Pmr,content_3882_1238:()=>sTe,content_3882_12380:()=>Wmr,content_3882_12382:()=>Gmr,content_3882_12384:()=>Umr,content_3882_12386:()=>qmr,content_3882_12388:()=>Ymr,content_3882_12390:()=>Kmr,content_3882_12392:()=>eyr,content_3882_12394:()=>oyr,content_3882_12396:()=>syr,content_3882_12398:()=>iyr,content_3882_124:()=>i2,content_3882_1240:()=>iTe,content_3882_12400:()=>myr,content_3882_12402:()=>hyr,content_3882_12404:()=>Dyr,content_3882_12406:()=>_yr,content_3882_12408:()=>Cyr,content_3882_12410:()=>vyr,content_3882_12412:()=>Nyr,content_3882_12414:()=>Pyr,content_3882_12416:()=>Wyr,content_3882_12418:()=>Gyr,content_3882_1242:()=>mTe,content_3882_12420:()=>Uyr,content_3882_12422:()=>qyr,content_3882_12424:()=>Yyr,content_3882_12426:()=>Kyr,content_3882_12428:()=>edr,content_3882_12430:()=>odr,content_3882_12432:()=>sdr,content_3882_12434:()=>idr,content_3882_12436:()=>mdr,content_3882_12438:()=>hdr,content_3882_1244:()=>hTe,content_3882_12440:()=>Ddr,content_3882_12442:()=>_dr,content_3882_12444:()=>Cdr,content_3882_12446:()=>vdr,content_3882_12448:()=>Ndr,content_3882_12450:()=>Pdr,content_3882_12452:()=>Wdr,content_3882_12454:()=>Gdr,content_3882_12456:()=>Udr,content_3882_12458:()=>qdr,content_3882_1246:()=>DTe,content_3882_12460:()=>Ydr,content_3882_12462:()=>Kdr,content_3882_12464:()=>ehr,content_3882_12466:()=>ohr,content_3882_12468:()=>shr,content_3882_12470:()=>ihr,content_3882_12472:()=>mhr,content_3882_12474:()=>hhr,content_3882_12476:()=>Dhr,content_3882_12478:()=>_hr,content_3882_1248:()=>_Te,content_3882_12480:()=>Chr,content_3882_12482:()=>vhr,content_3882_12484:()=>Nhr,content_3882_12486:()=>Phr,content_3882_12488:()=>Whr,content_3882_12490:()=>Ghr,content_3882_12492:()=>Uhr,content_3882_12494:()=>qhr,content_3882_12496:()=>Yhr,content_3882_12498:()=>Khr,content_3882_1250:()=>CTe,content_3882_12500:()=>egr,content_3882_12502:()=>ogr,content_3882_12504:()=>sgr,content_3882_12506:()=>igr,content_3882_12508:()=>mgr,content_3882_12510:()=>hgr,content_3882_12512:()=>Dgr,content_3882_12514:()=>_gr,content_3882_12516:()=>Cgr,content_3882_12518:()=>vgr,content_3882_1252:()=>vTe,content_3882_12520:()=>Ngr,content_3882_12522:()=>Pgr,content_3882_12524:()=>Wgr,content_3882_12526:()=>Ggr,content_3882_12528:()=>Ugr,content_3882_12530:()=>qgr,content_3882_12532:()=>Ygr,content_3882_12534:()=>Kgr,content_3882_12536:()=>efr,content_3882_12538:()=>ofr,content_3882_1254:()=>NTe,content_3882_12540:()=>sfr,content_3882_12542:()=>ifr,content_3882_12544:()=>mfr,content_3882_12546:()=>hfr,content_3882_12548:()=>Dfr,content_3882_12550:()=>_fr,content_3882_12552:()=>Cfr,content_3882_12554:()=>vfr,content_3882_12556:()=>Nfr,content_3882_12558:()=>Pfr,content_3882_1256:()=>PTe,content_3882_12560:()=>Wfr,content_3882_12562:()=>Gfr,content_3882_12564:()=>Ufr,content_3882_12566:()=>qfr,content_3882_12568:()=>Yfr,content_3882_12570:()=>Kfr,content_3882_12572:()=>eDr,content_3882_12574:()=>oDr,content_3882_12576:()=>sDr,content_3882_12578:()=>iDr,content_3882_1258:()=>WTe,content_3882_12580:()=>mDr,content_3882_12582:()=>hDr,content_3882_12584:()=>DDr,content_3882_12586:()=>_Dr,content_3882_12588:()=>CDr,content_3882_12590:()=>vDr,content_3882_12592:()=>NDr,content_3882_12594:()=>PDr,content_3882_12596:()=>WDr,content_3882_12598:()=>GDr,content_3882_126:()=>m2,content_3882_1260:()=>GTe,content_3882_12600:()=>UDr,content_3882_12602:()=>qDr,content_3882_12604:()=>YDr,content_3882_12606:()=>KDr,content_3882_12608:()=>eMr,content_3882_12610:()=>oMr,content_3882_12612:()=>sMr,content_3882_12614:()=>iMr,content_3882_12616:()=>mMr,content_3882_12618:()=>hMr,content_3882_1262:()=>UTe,content_3882_12620:()=>DMr,content_3882_12622:()=>_Mr,content_3882_12624:()=>CMr,content_3882_12626:()=>vMr,content_3882_12628:()=>NMr,content_3882_12630:()=>PMr,content_3882_12632:()=>WMr,content_3882_12634:()=>GMr,content_3882_12636:()=>UMr,content_3882_12638:()=>qMr,content_3882_1264:()=>qTe,content_3882_12640:()=>YMr,content_3882_12642:()=>KMr,content_3882_12644:()=>eXr,content_3882_12646:()=>oXr,content_3882_12648:()=>sXr,content_3882_12650:()=>iXr,content_3882_12652:()=>mXr,content_3882_12654:()=>hXr,content_3882_12656:()=>DXr,content_3882_12658:()=>_Xr,content_3882_1266:()=>YTe,content_3882_12660:()=>CXr,content_3882_12662:()=>vXr,content_3882_12664:()=>NXr,content_3882_12666:()=>PXr,content_3882_12668:()=>WXr,content_3882_12670:()=>GXr,content_3882_12672:()=>UXr,content_3882_12674:()=>qXr,content_3882_12676:()=>YXr,content_3882_12678:()=>KXr,content_3882_1268:()=>KTe,content_3882_12680:()=>e_r,content_3882_12682:()=>o_r,content_3882_12684:()=>s_r,content_3882_12686:()=>i_r,content_3882_12688:()=>m_r,content_3882_12690:()=>h_r,content_3882_12692:()=>D_r,content_3882_12694:()=>__r,content_3882_12696:()=>C_r,content_3882_12698:()=>v_r,content_3882_1270:()=>eCe,content_3882_12700:()=>N_r,content_3882_12702:()=>P_r,content_3882_12704:()=>W_r,content_3882_12706:()=>G_r,content_3882_12708:()=>U_r,content_3882_12710:()=>q_r,content_3882_12712:()=>Y_r,content_3882_12714:()=>K_r,content_3882_12716:()=>ewr,content_3882_12718:()=>owr,content_3882_1272:()=>oCe,content_3882_12720:()=>swr,content_3882_12722:()=>iwr,content_3882_12724:()=>mwr,content_3882_12726:()=>hwr,content_3882_12728:()=>Dwr,content_3882_12730:()=>_wr,content_3882_12732:()=>Cwr,content_3882_12734:()=>vwr,content_3882_12736:()=>Nwr,content_3882_12738:()=>Pwr,content_3882_1274:()=>sCe,content_3882_12740:()=>Wwr,content_3882_12742:()=>Gwr,content_3882_12744:()=>Uwr,content_3882_12746:()=>qwr,content_3882_12748:()=>Ywr,content_3882_12750:()=>Kwr,content_3882_12752:()=>eTr,content_3882_12754:()=>oTr,content_3882_12756:()=>sTr,content_3882_12758:()=>iTr,content_3882_1276:()=>iCe,content_3882_12760:()=>mTr,content_3882_12762:()=>hTr,content_3882_12764:()=>DTr,content_3882_12766:()=>_Tr,content_3882_12768:()=>CTr,content_3882_12770:()=>vTr,content_3882_12772:()=>NTr,content_3882_12774:()=>PTr,content_3882_12776:()=>WTr,content_3882_12778:()=>GTr,content_3882_1278:()=>mCe,content_3882_12780:()=>UTr,content_3882_12782:()=>qTr,content_3882_12784:()=>YTr,content_3882_12786:()=>KTr,content_3882_12788:()=>eCr,content_3882_12790:()=>oCr,content_3882_12792:()=>sCr,content_3882_12794:()=>iCr,content_3882_12796:()=>mCr,content_3882_12798:()=>hCr,content_3882_128:()=>h2,content_3882_1280:()=>hCe,content_3882_12800:()=>DCr,content_3882_12802:()=>_Cr,content_3882_12804:()=>CCr,content_3882_12806:()=>vCr,content_3882_12808:()=>NCr,content_3882_12810:()=>PCr,content_3882_12812:()=>WCr,content_3882_12814:()=>GCr,content_3882_12816:()=>UCr,content_3882_12818:()=>qCr,content_3882_1282:()=>DCe,content_3882_12820:()=>YCr,content_3882_12822:()=>KCr,content_3882_12824:()=>exr,content_3882_12826:()=>oxr,content_3882_12828:()=>sxr,content_3882_12830:()=>ixr,content_3882_12832:()=>mxr,content_3882_12834:()=>hxr,content_3882_12836:()=>Dxr,content_3882_12838:()=>_xr,content_3882_1284:()=>_Ce,content_3882_12840:()=>Cxr,content_3882_12842:()=>vxr,content_3882_12844:()=>Nxr,content_3882_12846:()=>Pxr,content_3882_12848:()=>Wxr,content_3882_12850:()=>Gxr,content_3882_12852:()=>Uxr,content_3882_12854:()=>qxr,content_3882_12856:()=>Yxr,content_3882_12858:()=>Kxr,content_3882_1286:()=>CCe,content_3882_12860:()=>eAr,content_3882_12862:()=>oAr,content_3882_12864:()=>sAr,content_3882_12866:()=>iAr,content_3882_12868:()=>mAr,content_3882_12870:()=>hAr,content_3882_12872:()=>DAr,content_3882_12874:()=>_Ar,content_3882_12876:()=>CAr,content_3882_12878:()=>vAr,content_3882_1288:()=>vCe,content_3882_12880:()=>NAr,content_3882_12882:()=>PAr,content_3882_12884:()=>WAr,content_3882_12886:()=>GAr,content_3882_12888:()=>UAr,content_3882_12890:()=>qAr,content_3882_12892:()=>YAr,content_3882_12894:()=>KAr,content_3882_12896:()=>evr,content_3882_12898:()=>ovr,content_3882_1290:()=>NCe,content_3882_12900:()=>svr,content_3882_12902:()=>ivr,content_3882_12904:()=>mvr,content_3882_12906:()=>hvr,content_3882_12908:()=>Dvr,content_3882_12910:()=>_vr,content_3882_12912:()=>Cvr,content_3882_12914:()=>vvr,content_3882_12916:()=>Nvr,content_3882_12918:()=>Pvr,content_3882_1292:()=>PCe,content_3882_12920:()=>Wvr,content_3882_12922:()=>Gvr,content_3882_12924:()=>Uvr,content_3882_12926:()=>qvr,content_3882_12928:()=>Yvr,content_3882_12930:()=>Kvr,content_3882_12932:()=>eLr,content_3882_12934:()=>oLr,content_3882_12936:()=>sLr,content_3882_12938:()=>iLr,content_3882_1294:()=>WCe,content_3882_12940:()=>mLr,content_3882_12942:()=>hLr,content_3882_12944:()=>DLr,content_3882_12946:()=>_Lr,content_3882_12948:()=>CLr,content_3882_12950:()=>vLr,content_3882_12952:()=>NLr,content_3882_12954:()=>PLr,content_3882_12956:()=>WLr,content_3882_12958:()=>GLr,content_3882_1296:()=>GCe,content_3882_12960:()=>ULr,content_3882_12962:()=>qLr,content_3882_12964:()=>YLr,content_3882_12966:()=>KLr,content_3882_12968:()=>ebr,content_3882_12970:()=>obr,content_3882_12972:()=>sbr,content_3882_12974:()=>ibr,content_3882_12976:()=>mbr,content_3882_12978:()=>hbr,content_3882_1298:()=>UCe,content_3882_12980:()=>Dbr,content_3882_12982:()=>_br,content_3882_12984:()=>Cbr,content_3882_12986:()=>vbr,content_3882_12988:()=>Nbr,content_3882_12990:()=>Pbr,content_3882_12992:()=>Wbr,content_3882_12994:()=>Gbr,content_3882_12996:()=>Ubr,content_3882_12998:()=>qbr,content_3882_130:()=>D2,content_3882_1300:()=>qCe,content_3882_13000:()=>Ybr,content_3882_13002:()=>Kbr,content_3882_13004:()=>eNr,content_3882_13006:()=>oNr,content_3882_13008:()=>sNr,content_3882_13010:()=>iNr,content_3882_13012:()=>mNr,content_3882_13014:()=>hNr,content_3882_13016:()=>DNr,content_3882_13018:()=>_Nr,content_3882_1302:()=>YCe,content_3882_13020:()=>CNr,content_3882_13022:()=>vNr,content_3882_13024:()=>NNr,content_3882_1304:()=>KCe,content_3882_1306:()=>exe,content_3882_1308:()=>oxe,content_3882_1310:()=>sxe,content_3882_1312:()=>ixe,content_3882_1314:()=>mxe,content_3882_1316:()=>hxe,content_3882_1318:()=>Dxe,content_3882_132:()=>_2,content_3882_1320:()=>_xe,content_3882_1322:()=>Cxe,content_3882_1324:()=>vxe,content_3882_1326:()=>Nxe,content_3882_1328:()=>Pxe,content_3882_1330:()=>Wxe,content_3882_1332:()=>Gxe,content_3882_1334:()=>Uxe,content_3882_1336:()=>qxe,content_3882_1338:()=>Yxe,content_3882_134:()=>C2,content_3882_1340:()=>Kxe,content_3882_1342:()=>eAe,content_3882_1344:()=>oAe,content_3882_1346:()=>sAe,content_3882_1348:()=>iAe,content_3882_1350:()=>mAe,content_3882_1352:()=>hAe,content_3882_1354:()=>DAe,content_3882_1356:()=>_Ae,content_3882_1358:()=>CAe,content_3882_136:()=>v2,content_3882_1360:()=>vAe,content_3882_1362:()=>NAe,content_3882_1364:()=>PAe,content_3882_1366:()=>WAe,content_3882_1368:()=>GAe,content_3882_1370:()=>UAe,content_3882_1372:()=>qAe,content_3882_1374:()=>YAe,content_3882_1376:()=>KAe,content_3882_1378:()=>eve,content_3882_138:()=>N2,content_3882_1380:()=>ove,content_3882_1382:()=>sve,content_3882_1384:()=>ive,content_3882_1386:()=>mve,content_3882_1388:()=>hve,content_3882_1390:()=>Dve,content_3882_1392:()=>_ve,content_3882_1394:()=>Cve,content_3882_1396:()=>vve,content_3882_1398:()=>Nve,content_3882_14:()=>sZ,content_3882_140:()=>P2,content_3882_1400:()=>Pve,content_3882_1402:()=>Wve,content_3882_1404:()=>Gve,content_3882_1406:()=>Uve,content_3882_1408:()=>qve,content_3882_1410:()=>Yve,content_3882_1412:()=>Kve,content_3882_1414:()=>eLe,content_3882_1416:()=>oLe,content_3882_1418:()=>sLe,content_3882_142:()=>W2,content_3882_1420:()=>iLe,content_3882_1422:()=>mLe,content_3882_1424:()=>hLe,content_3882_1426:()=>DLe,content_3882_1428:()=>_Le,content_3882_1430:()=>CLe,content_3882_1432:()=>vLe,content_3882_1434:()=>NLe,content_3882_1436:()=>PLe,content_3882_1438:()=>WLe,content_3882_144:()=>G2,content_3882_1440:()=>GLe,content_3882_1442:()=>ULe,content_3882_1444:()=>qLe,content_3882_1446:()=>YLe,content_3882_1448:()=>KLe,content_3882_1450:()=>ebe,content_3882_1452:()=>obe,content_3882_1454:()=>sbe,content_3882_1456:()=>ibe,content_3882_1458:()=>mbe,content_3882_146:()=>U2,content_3882_1460:()=>hbe,content_3882_1462:()=>Dbe,content_3882_1464:()=>_be,content_3882_1466:()=>Cbe,content_3882_1468:()=>vbe,content_3882_1470:()=>Nbe,content_3882_1472:()=>Pbe,content_3882_1474:()=>Wbe,content_3882_1476:()=>Gbe,content_3882_1478:()=>Ube,content_3882_148:()=>q2,content_3882_1480:()=>qbe,content_3882_1482:()=>Ybe,content_3882_1484:()=>Kbe,content_3882_1486:()=>eNe,content_3882_1488:()=>oNe,content_3882_1490:()=>sNe,content_3882_1492:()=>iNe,content_3882_1494:()=>mNe,content_3882_1496:()=>hNe,content_3882_1498:()=>DNe,content_3882_150:()=>Y2,content_3882_1500:()=>_Ne,content_3882_1502:()=>CNe,content_3882_1504:()=>vNe,content_3882_1506:()=>NNe,content_3882_1508:()=>PNe,content_3882_1510:()=>WNe,content_3882_1512:()=>GNe,content_3882_1514:()=>UNe,content_3882_1516:()=>qNe,content_3882_1518:()=>YNe,content_3882_152:()=>K2,content_3882_1520:()=>KNe,content_3882_1522:()=>eke,content_3882_1524:()=>oke,content_3882_1526:()=>ske,content_3882_1528:()=>ike,content_3882_1530:()=>mke,content_3882_1532:()=>hke,content_3882_1534:()=>Dke,content_3882_1536:()=>_ke,content_3882_1538:()=>Cke,content_3882_154:()=>e3,content_3882_1540:()=>vke,content_3882_1542:()=>Nke,content_3882_1544:()=>Pke,content_3882_1546:()=>Wke,content_3882_1548:()=>Gke,content_3882_1550:()=>Uke,content_3882_1552:()=>qke,content_3882_1554:()=>Yke,content_3882_1556:()=>Kke,content_3882_1558:()=>eze,content_3882_156:()=>o3,content_3882_1560:()=>oze,content_3882_1562:()=>sze,content_3882_1564:()=>ize,content_3882_1566:()=>mze,content_3882_1568:()=>hze,content_3882_1570:()=>Dze,content_3882_1572:()=>_ze,content_3882_1574:()=>Cze,content_3882_1576:()=>vze,content_3882_1578:()=>Nze,content_3882_158:()=>s3,content_3882_1580:()=>Pze,content_3882_1582:()=>Wze,content_3882_1584:()=>Gze,content_3882_1586:()=>Uze,content_3882_1588:()=>qze,content_3882_1590:()=>Yze,content_3882_1592:()=>Kze,content_3882_1594:()=>ePe,content_3882_1596:()=>oPe,content_3882_1598:()=>sPe,content_3882_16:()=>iZ,content_3882_160:()=>i3,content_3882_1600:()=>iPe,content_3882_1602:()=>mPe,content_3882_1604:()=>hPe,content_3882_1606:()=>DPe,content_3882_1608:()=>_Pe,content_3882_1610:()=>CPe,content_3882_1612:()=>vPe,content_3882_1614:()=>NPe,content_3882_1616:()=>PPe,content_3882_1618:()=>WPe,content_3882_162:()=>m3,content_3882_1620:()=>GPe,content_3882_1622:()=>UPe,content_3882_1624:()=>qPe,content_3882_1626:()=>YPe,content_3882_1628:()=>KPe,content_3882_1630:()=>eIe,content_3882_1632:()=>oIe,content_3882_1634:()=>sIe,content_3882_1636:()=>iIe,content_3882_1638:()=>mIe,content_3882_164:()=>h3,content_3882_1640:()=>hIe,content_3882_1642:()=>DIe,content_3882_1644:()=>_Ie,content_3882_1646:()=>CIe,content_3882_1648:()=>vIe,content_3882_1650:()=>NIe,content_3882_1652:()=>PIe,content_3882_1654:()=>WIe,content_3882_1656:()=>GIe,content_3882_1658:()=>UIe,content_3882_166:()=>D3,content_3882_1660:()=>qIe,content_3882_1662:()=>YIe,content_3882_1664:()=>KIe,content_3882_1666:()=>eRe,content_3882_1668:()=>oRe,content_3882_1670:()=>sRe,content_3882_1672:()=>iRe,content_3882_1674:()=>mRe,content_3882_1676:()=>hRe,content_3882_1678:()=>DRe,content_3882_168:()=>_3,content_3882_1680:()=>_Re,content_3882_1682:()=>CRe,content_3882_1684:()=>vRe,content_3882_1686:()=>NRe,content_3882_1688:()=>PRe,content_3882_1690:()=>WRe,content_3882_1692:()=>GRe,content_3882_1694:()=>URe,content_3882_1696:()=>qRe,content_3882_1698:()=>YRe,content_3882_170:()=>C3,content_3882_1700:()=>KRe,content_3882_1702:()=>eWe,content_3882_1704:()=>oWe,content_3882_1706:()=>sWe,content_3882_1708:()=>iWe,content_3882_1710:()=>mWe,content_3882_1712:()=>hWe,content_3882_1714:()=>DWe,content_3882_1716:()=>_We,content_3882_1718:()=>CWe,content_3882_172:()=>v3,content_3882_1720:()=>vWe,content_3882_1722:()=>NWe,content_3882_1724:()=>PWe,content_3882_1726:()=>WWe,content_3882_1728:()=>GWe,content_3882_1730:()=>UWe,content_3882_1732:()=>qWe,content_3882_1734:()=>YWe,content_3882_1736:()=>KWe,content_3882_1738:()=>eSe,content_3882_174:()=>N3,content_3882_1740:()=>oSe,content_3882_1742:()=>sSe,content_3882_1744:()=>iSe,content_3882_1746:()=>mSe,content_3882_1748:()=>hSe,content_3882_1750:()=>DSe,content_3882_1752:()=>_Se,content_3882_1754:()=>CSe,content_3882_1756:()=>vSe,content_3882_1758:()=>NSe,content_3882_176:()=>P3,content_3882_1760:()=>PSe,content_3882_1762:()=>WSe,content_3882_1764:()=>GSe,content_3882_1766:()=>USe,content_3882_1768:()=>qSe,content_3882_1770:()=>YSe,content_3882_1772:()=>KSe,content_3882_1774:()=>eBe,content_3882_1776:()=>oBe,content_3882_1778:()=>sBe,content_3882_178:()=>W3,content_3882_1780:()=>iBe,content_3882_1782:()=>mBe,content_3882_1784:()=>hBe,content_3882_1786:()=>DBe,content_3882_1788:()=>_Be,content_3882_1790:()=>CBe,content_3882_1792:()=>vBe,content_3882_1794:()=>NBe,content_3882_1796:()=>PBe,content_3882_1798:()=>WBe,content_3882_18:()=>mZ,content_3882_180:()=>G3,content_3882_1800:()=>GBe,content_3882_1802:()=>UBe,content_3882_1804:()=>qBe,content_3882_1806:()=>YBe,content_3882_1808:()=>KBe,content_3882_1810:()=>eGe,content_3882_1812:()=>oGe,content_3882_1814:()=>sGe,content_3882_1816:()=>iGe,content_3882_1818:()=>mGe,content_3882_182:()=>U3,content_3882_1820:()=>hGe,content_3882_1822:()=>DGe,content_3882_1824:()=>_Ge,content_3882_1826:()=>CGe,content_3882_1828:()=>vGe,content_3882_1830:()=>NGe,content_3882_1832:()=>PGe,content_3882_1834:()=>WGe,content_3882_1836:()=>GGe,content_3882_1838:()=>UGe,content_3882_184:()=>q3,content_3882_1840:()=>qGe,content_3882_1842:()=>YGe,content_3882_1844:()=>KGe,content_3882_1846:()=>eEe,content_3882_1848:()=>oEe,content_3882_1850:()=>sEe,content_3882_1852:()=>iEe,content_3882_1854:()=>mEe,content_3882_1856:()=>hEe,content_3882_1858:()=>DEe,content_3882_186:()=>Y3,content_3882_1860:()=>_Ee,content_3882_1862:()=>CEe,content_3882_1864:()=>vEe,content_3882_1866:()=>NEe,content_3882_1868:()=>PEe,content_3882_1870:()=>WEe,content_3882_1872:()=>GEe,content_3882_1874:()=>UEe,content_3882_1876:()=>qEe,content_3882_1878:()=>YEe,content_3882_188:()=>K3,content_3882_1880:()=>KEe,content_3882_1882:()=>eOe,content_3882_1884:()=>oOe,content_3882_1886:()=>sOe,content_3882_1888:()=>iOe,content_3882_1890:()=>mOe,content_3882_1892:()=>hOe,content_3882_1894:()=>DOe,content_3882_1896:()=>_Oe,content_3882_1898:()=>COe,content_3882_190:()=>e1,content_3882_1900:()=>vOe,content_3882_1902:()=>NOe,content_3882_1904:()=>POe,content_3882_1906:()=>WOe,content_3882_1908:()=>GOe,content_3882_1910:()=>UOe,content_3882_1912:()=>qOe,content_3882_1914:()=>YOe,content_3882_1916:()=>KOe,content_3882_1918:()=>eUe,content_3882_192:()=>o1,content_3882_1920:()=>oUe,content_3882_1922:()=>sUe,content_3882_1924:()=>iUe,content_3882_1926:()=>mUe,content_3882_1928:()=>hUe,content_3882_1930:()=>DUe,content_3882_1932:()=>_Ue,content_3882_1934:()=>CUe,content_3882_1936:()=>vUe,content_3882_1938:()=>NUe,content_3882_194:()=>s1,content_3882_1940:()=>PUe,content_3882_1942:()=>WUe,content_3882_1944:()=>GUe,content_3882_1946:()=>UUe,content_3882_1948:()=>qUe,content_3882_1950:()=>YUe,content_3882_1952:()=>KUe,content_3882_1954:()=>eFe,content_3882_1956:()=>oFe,content_3882_1958:()=>sFe,content_3882_196:()=>i1,content_3882_1960:()=>iFe,content_3882_1962:()=>mFe,content_3882_1964:()=>hFe,content_3882_1966:()=>DFe,content_3882_1968:()=>_Fe,content_3882_1970:()=>CFe,content_3882_1972:()=>vFe,content_3882_1974:()=>NFe,content_3882_1976:()=>PFe,content_3882_1978:()=>WFe,content_3882_198:()=>m1,content_3882_1980:()=>GFe,content_3882_1982:()=>UFe,content_3882_1984:()=>qFe,content_3882_1986:()=>YFe,content_3882_1988:()=>KFe,content_3882_1990:()=>eVe,content_3882_1992:()=>oVe,content_3882_1994:()=>sVe,content_3882_1996:()=>iVe,content_3882_1998:()=>mVe,content_3882_2:()=>UJ,content_3882_20:()=>hZ,content_3882_200:()=>h1,content_3882_2000:()=>hVe,content_3882_2002:()=>DVe,content_3882_2004:()=>_Ve,content_3882_2006:()=>CVe,content_3882_2008:()=>vVe,content_3882_2010:()=>NVe,content_3882_2012:()=>PVe,content_3882_2014:()=>WVe,content_3882_2016:()=>GVe,content_3882_2018:()=>UVe,content_3882_202:()=>D1,content_3882_2020:()=>qVe,content_3882_2022:()=>YVe,content_3882_2024:()=>KVe,content_3882_2026:()=>eqe,content_3882_2028:()=>oqe,content_3882_2030:()=>sqe,content_3882_2032:()=>iqe,content_3882_2034:()=>mqe,content_3882_2036:()=>hqe,content_3882_2038:()=>Dqe,content_3882_204:()=>_1,content_3882_2040:()=>_qe,content_3882_2042:()=>Cqe,content_3882_2044:()=>vqe,content_3882_2046:()=>Nqe,content_3882_2048:()=>Pqe,content_3882_2050:()=>Wqe,content_3882_2052:()=>Gqe,content_3882_2054:()=>Uqe,content_3882_2056:()=>qqe,content_3882_2058:()=>Yqe,content_3882_206:()=>C1,content_3882_2060:()=>Kqe,content_3882_2062:()=>eje,content_3882_2064:()=>oje,content_3882_2066:()=>sje,content_3882_2068:()=>ije,content_3882_2070:()=>mje,content_3882_2072:()=>hje,content_3882_2074:()=>Dje,content_3882_2076:()=>_je,content_3882_2078:()=>Cje,content_3882_208:()=>v1,content_3882_2080:()=>vje,content_3882_2082:()=>Nje,content_3882_2084:()=>Pje,content_3882_2086:()=>Wje,content_3882_2088:()=>Gje,content_3882_2090:()=>Uje,content_3882_2092:()=>qje,content_3882_2094:()=>Yje,content_3882_2096:()=>Kje,content_3882_2098:()=>eHe,content_3882_210:()=>N1,content_3882_2100:()=>oHe,content_3882_2102:()=>sHe,content_3882_2104:()=>iHe,content_3882_2106:()=>mHe,content_3882_2108:()=>hHe,content_3882_2110:()=>DHe,content_3882_2112:()=>_He,content_3882_2114:()=>CHe,content_3882_2116:()=>vHe,content_3882_2118:()=>NHe,content_3882_212:()=>P1,content_3882_2120:()=>PHe,content_3882_2122:()=>WHe,content_3882_2124:()=>GHe,content_3882_2126:()=>UHe,content_3882_2128:()=>qHe,content_3882_2130:()=>YHe,content_3882_2132:()=>KHe,content_3882_2134:()=>eYe,content_3882_2136:()=>oYe,content_3882_2138:()=>sYe,content_3882_214:()=>W1,content_3882_2140:()=>iYe,content_3882_2142:()=>mYe,content_3882_2144:()=>hYe,content_3882_2146:()=>DYe,content_3882_2148:()=>_Ye,content_3882_2150:()=>CYe,content_3882_2152:()=>vYe,content_3882_2154:()=>NYe,content_3882_2156:()=>PYe,content_3882_2158:()=>WYe,content_3882_216:()=>G1,content_3882_2160:()=>GYe,content_3882_2162:()=>UYe,content_3882_2164:()=>qYe,content_3882_2166:()=>YYe,content_3882_2168:()=>KYe,content_3882_2170:()=>eQe,content_3882_2172:()=>oQe,content_3882_2174:()=>sQe,content_3882_2176:()=>iQe,content_3882_2178:()=>mQe,content_3882_218:()=>U1,content_3882_2180:()=>hQe,content_3882_2182:()=>DQe,content_3882_2184:()=>_Qe,content_3882_2186:()=>CQe,content_3882_2188:()=>vQe,content_3882_2190:()=>NQe,content_3882_2192:()=>PQe,content_3882_2194:()=>WQe,content_3882_2196:()=>GQe,content_3882_2198:()=>UQe,content_3882_22:()=>DZ,content_3882_220:()=>q1,content_3882_2200:()=>qQe,content_3882_2202:()=>YQe,content_3882_2204:()=>KQe,content_3882_2206:()=>e$e,content_3882_2208:()=>o$e,content_3882_2210:()=>s$e,content_3882_2212:()=>i$e,content_3882_2214:()=>m$e,content_3882_2216:()=>h$e,content_3882_2218:()=>D$e,content_3882_222:()=>Y1,content_3882_2220:()=>_$e,content_3882_2222:()=>C$e,content_3882_2224:()=>v$e,content_3882_2226:()=>N$e,content_3882_2228:()=>P$e,content_3882_2230:()=>W$e,content_3882_2232:()=>G$e,content_3882_2234:()=>U$e,content_3882_2236:()=>q$e,content_3882_2238:()=>Y$e,content_3882_224:()=>K1,content_3882_2240:()=>K$e,content_3882_2242:()=>eKe,content_3882_2244:()=>oKe,content_3882_2246:()=>sKe,content_3882_2248:()=>iKe,content_3882_2250:()=>mKe,content_3882_2252:()=>hKe,content_3882_2254:()=>DKe,content_3882_2256:()=>_Ke,content_3882_2258:()=>CKe,content_3882_226:()=>e4,content_3882_2260:()=>vKe,content_3882_2262:()=>NKe,content_3882_2264:()=>PKe,content_3882_2266:()=>WKe,content_3882_2268:()=>GKe,content_3882_2270:()=>UKe,content_3882_2272:()=>qKe,content_3882_2274:()=>YKe,content_3882_2276:()=>KKe,content_3882_2278:()=>eJe,content_3882_228:()=>o4,content_3882_2280:()=>oJe,content_3882_2282:()=>sJe,content_3882_2284:()=>iJe,content_3882_2286:()=>mJe,content_3882_2288:()=>hJe,content_3882_2290:()=>DJe,content_3882_2292:()=>_Je,content_3882_2294:()=>CJe,content_3882_2296:()=>vJe,content_3882_2298:()=>NJe,content_3882_230:()=>s4,content_3882_2300:()=>PJe,content_3882_2302:()=>WJe,content_3882_2304:()=>GJe,content_3882_2306:()=>UJe,content_3882_2308:()=>qJe,content_3882_2310:()=>YJe,content_3882_2312:()=>KJe,content_3882_2314:()=>eZe,content_3882_2316:()=>oZe,content_3882_2318:()=>sZe,content_3882_232:()=>i4,content_3882_2320:()=>iZe,content_3882_2322:()=>mZe,content_3882_2324:()=>hZe,content_3882_2326:()=>DZe,content_3882_2328:()=>_Ze,content_3882_2330:()=>CZe,content_3882_2332:()=>vZe,content_3882_2334:()=>NZe,content_3882_2336:()=>PZe,content_3882_2338:()=>WZe,content_3882_234:()=>m4,content_3882_2340:()=>GZe,content_3882_2342:()=>UZe,content_3882_2344:()=>qZe,content_3882_2346:()=>YZe,content_3882_2348:()=>KZe,content_3882_2350:()=>e0e,content_3882_2352:()=>o0e,content_3882_2354:()=>s0e,content_3882_2356:()=>i0e,content_3882_2358:()=>m0e,content_3882_236:()=>h4,content_3882_2360:()=>h0e,content_3882_2362:()=>D0e,content_3882_2364:()=>_0e,content_3882_2366:()=>C0e,content_3882_2368:()=>v0e,content_3882_2370:()=>N0e,content_3882_2372:()=>P0e,content_3882_2374:()=>W0e,content_3882_2376:()=>G0e,content_3882_2378:()=>U0e,content_3882_238:()=>D4,content_3882_2380:()=>q0e,content_3882_2382:()=>Y0e,content_3882_2384:()=>K0e,content_3882_2386:()=>e8e,content_3882_2388:()=>o8e,content_3882_2390:()=>s8e,content_3882_2392:()=>i8e,content_3882_2394:()=>m8e,content_3882_2396:()=>h8e,content_3882_2398:()=>D8e,content_3882_24:()=>_Z,content_3882_240:()=>_4,content_3882_2400:()=>_8e,content_3882_2402:()=>C8e,content_3882_2404:()=>v8e,content_3882_2406:()=>N8e,content_3882_2408:()=>P8e,content_3882_2410:()=>W8e,content_3882_2412:()=>G8e,content_3882_2414:()=>U8e,content_3882_2416:()=>q8e,content_3882_2418:()=>Y8e,content_3882_242:()=>C4,content_3882_2420:()=>K8e,content_3882_2422:()=>e2e,content_3882_2424:()=>o2e,content_3882_2426:()=>s2e,content_3882_2428:()=>i2e,content_3882_2430:()=>m2e,content_3882_2432:()=>h2e,content_3882_2434:()=>D2e,content_3882_2436:()=>_2e,content_3882_2438:()=>C2e,content_3882_244:()=>v4,content_3882_2440:()=>v2e,content_3882_2442:()=>N2e,content_3882_2444:()=>P2e,content_3882_2446:()=>W2e,content_3882_2448:()=>G2e,content_3882_2450:()=>U2e,content_3882_2452:()=>q2e,content_3882_2454:()=>Y2e,content_3882_2456:()=>K2e,content_3882_2458:()=>e3e,content_3882_246:()=>N4,content_3882_2460:()=>o3e,content_3882_2462:()=>s3e,content_3882_2464:()=>i3e,content_3882_2466:()=>m3e,content_3882_2468:()=>h3e,content_3882_2470:()=>D3e,content_3882_2472:()=>_3e,content_3882_2474:()=>C3e,content_3882_2476:()=>v3e,content_3882_2478:()=>N3e,content_3882_248:()=>P4,content_3882_2480:()=>P3e,content_3882_2482:()=>W3e,content_3882_2484:()=>G3e,content_3882_2486:()=>U3e,content_3882_2488:()=>q3e,content_3882_2490:()=>Y3e,content_3882_2492:()=>K3e,content_3882_2494:()=>e1e,content_3882_2496:()=>o1e,content_3882_2498:()=>s1e,content_3882_250:()=>W4,content_3882_2500:()=>i1e,content_3882_2502:()=>m1e,content_3882_2504:()=>h1e,content_3882_2506:()=>D1e,content_3882_2508:()=>_1e,content_3882_2510:()=>C1e,content_3882_2512:()=>v1e,content_3882_2514:()=>N1e,content_3882_2516:()=>P1e,content_3882_2518:()=>W1e,content_3882_252:()=>G4,content_3882_2520:()=>G1e,content_3882_2522:()=>U1e,content_3882_2524:()=>q1e,content_3882_2526:()=>Y1e,content_3882_2528:()=>K1e,content_3882_2530:()=>e4e,content_3882_2532:()=>o4e,content_3882_2534:()=>s4e,content_3882_2536:()=>i4e,content_3882_2538:()=>m4e,content_3882_254:()=>U4,content_3882_2540:()=>h4e,content_3882_2542:()=>D4e,content_3882_2544:()=>_4e,content_3882_2546:()=>C4e,content_3882_2548:()=>v4e,content_3882_2550:()=>N4e,content_3882_2552:()=>P4e,content_3882_2554:()=>W4e,content_3882_2556:()=>G4e,content_3882_2558:()=>U4e,content_3882_256:()=>q4,content_3882_2560:()=>q4e,content_3882_2562:()=>Y4e,content_3882_2564:()=>K4e,content_3882_2566:()=>e6e,content_3882_2568:()=>o6e,content_3882_2570:()=>s6e,content_3882_2572:()=>i6e,content_3882_2574:()=>m6e,content_3882_2576:()=>h6e,content_3882_2578:()=>D6e,content_3882_258:()=>Y4,content_3882_2580:()=>_6e,content_3882_2582:()=>C6e,content_3882_2584:()=>v6e,content_3882_2586:()=>N6e,content_3882_2588:()=>P6e,content_3882_2590:()=>W6e,content_3882_2592:()=>G6e,content_3882_2594:()=>U6e,content_3882_2596:()=>q6e,content_3882_2598:()=>Y6e,content_3882_26:()=>CZ,content_3882_260:()=>K4,content_3882_2600:()=>K6e,content_3882_2602:()=>e5e,content_3882_2604:()=>o5e,content_3882_2606:()=>s5e,content_3882_2608:()=>i5e,content_3882_2610:()=>m5e,content_3882_2612:()=>h5e,content_3882_2614:()=>D5e,content_3882_2616:()=>_5e,content_3882_2618:()=>C5e,content_3882_262:()=>e6,content_3882_2620:()=>v5e,content_3882_2622:()=>N5e,content_3882_2624:()=>P5e,content_3882_2626:()=>W5e,content_3882_2628:()=>G5e,content_3882_2630:()=>U5e,content_3882_2632:()=>q5e,content_3882_2634:()=>Y5e,content_3882_2636:()=>K5e,content_3882_2638:()=>e7e,content_3882_264:()=>o6,content_3882_2640:()=>o7e,content_3882_2642:()=>s7e,content_3882_2644:()=>i7e,content_3882_2646:()=>m7e,content_3882_2648:()=>h7e,content_3882_2650:()=>D7e,content_3882_2652:()=>_7e,content_3882_2654:()=>C7e,content_3882_2656:()=>v7e,content_3882_2658:()=>N7e,content_3882_266:()=>s6,content_3882_2660:()=>P7e,content_3882_2662:()=>W7e,content_3882_2664:()=>G7e,content_3882_2666:()=>U7e,content_3882_2668:()=>q7e,content_3882_2670:()=>Y7e,content_3882_2672:()=>K7e,content_3882_2674:()=>e9e,content_3882_2676:()=>o9e,content_3882_2678:()=>s9e,content_3882_268:()=>i6,content_3882_2680:()=>i9e,content_3882_2682:()=>m9e,content_3882_2684:()=>h9e,content_3882_2686:()=>D9e,content_3882_2688:()=>_9e,content_3882_2690:()=>C9e,content_3882_2692:()=>v9e,content_3882_2694:()=>N9e,content_3882_2696:()=>P9e,content_3882_2698:()=>W9e,content_3882_270:()=>m6,content_3882_2700:()=>G9e,content_3882_2702:()=>U9e,content_3882_2704:()=>q9e,content_3882_2706:()=>Y9e,content_3882_2708:()=>K9e,content_3882_2710:()=>een,content_3882_2712:()=>oen,content_3882_2714:()=>sen,content_3882_2716:()=>ien,content_3882_2718:()=>men,content_3882_272:()=>h6,content_3882_2720:()=>hen,content_3882_2722:()=>Den,content_3882_2724:()=>_en,content_3882_2726:()=>Cen,content_3882_2728:()=>ven,content_3882_2730:()=>Nen,content_3882_2732:()=>Pen,content_3882_2734:()=>Wen,content_3882_2736:()=>Gen,content_3882_2738:()=>Uen,content_3882_274:()=>D6,content_3882_2740:()=>qen,content_3882_2742:()=>Yen,content_3882_2744:()=>Ken,content_3882_2746:()=>enn,content_3882_2748:()=>onn,content_3882_2750:()=>snn,content_3882_2752:()=>inn,content_3882_2754:()=>mnn,content_3882_2756:()=>hnn,content_3882_2758:()=>Dnn,content_3882_276:()=>_6,content_3882_2760:()=>_nn,content_3882_2762:()=>Cnn,content_3882_2764:()=>vnn,content_3882_2766:()=>Nnn,content_3882_2768:()=>Pnn,content_3882_2770:()=>Wnn,content_3882_2772:()=>Gnn,content_3882_2774:()=>Unn,content_3882_2776:()=>qnn,content_3882_2778:()=>Ynn,content_3882_278:()=>C6,content_3882_2780:()=>Knn,content_3882_2782:()=>etn,content_3882_2784:()=>otn,content_3882_2786:()=>stn,content_3882_2788:()=>itn,content_3882_2790:()=>mtn,content_3882_2792:()=>htn,content_3882_2794:()=>Dtn,content_3882_2796:()=>_tn,content_3882_2798:()=>Ctn,content_3882_28:()=>vZ,content_3882_280:()=>v6,content_3882_2800:()=>vtn,content_3882_2802:()=>Ntn,content_3882_2804:()=>Ptn,content_3882_2806:()=>Wtn,content_3882_2808:()=>Gtn,content_3882_2810:()=>Utn,content_3882_2812:()=>qtn,content_3882_2814:()=>Ytn,content_3882_2816:()=>Ktn,content_3882_2818:()=>eon,content_3882_282:()=>N6,content_3882_2820:()=>oon,content_3882_2822:()=>son,content_3882_2824:()=>ion,content_3882_2826:()=>mon,content_3882_2828:()=>hon,content_3882_2830:()=>Don,content_3882_2832:()=>_on,content_3882_2834:()=>Con,content_3882_2836:()=>von,content_3882_2838:()=>Non,content_3882_284:()=>P6,content_3882_2840:()=>Pon,content_3882_2842:()=>Won,content_3882_2844:()=>Gon,content_3882_2846:()=>Uon,content_3882_2848:()=>qon,content_3882_2850:()=>Yon,content_3882_2852:()=>Kon,content_3882_2854:()=>epn,content_3882_2856:()=>opn,content_3882_2858:()=>spn,content_3882_286:()=>W6,content_3882_2860:()=>ipn,content_3882_2862:()=>mpn,content_3882_2864:()=>hpn,content_3882_2866:()=>Dpn,content_3882_2868:()=>_pn,content_3882_2870:()=>Cpn,content_3882_2872:()=>vpn,content_3882_2874:()=>Npn,content_3882_2876:()=>Ppn,content_3882_2878:()=>Wpn,content_3882_288:()=>G6,content_3882_2880:()=>Gpn,content_3882_2882:()=>Upn,content_3882_2884:()=>qpn,content_3882_2886:()=>Ypn,content_3882_2888:()=>Kpn,content_3882_2890:()=>ern,content_3882_2892:()=>orn,content_3882_2894:()=>srn,content_3882_2896:()=>irn,content_3882_2898:()=>mrn,content_3882_290:()=>U6,content_3882_2900:()=>hrn,content_3882_2902:()=>Drn,content_3882_2904:()=>_rn,content_3882_2906:()=>Crn,content_3882_2908:()=>vrn,content_3882_2910:()=>Nrn,content_3882_2912:()=>Prn,content_3882_2914:()=>Wrn,content_3882_2916:()=>Grn,content_3882_2918:()=>Urn,content_3882_292:()=>q6,content_3882_2920:()=>qrn,content_3882_2922:()=>Yrn,content_3882_2924:()=>Krn,content_3882_2926:()=>esn,content_3882_2928:()=>osn,content_3882_2930:()=>ssn,content_3882_2932:()=>isn,content_3882_2934:()=>msn,content_3882_2936:()=>hsn,content_3882_2938:()=>Dsn,content_3882_294:()=>Y6,content_3882_2940:()=>_sn,content_3882_2942:()=>Csn,content_3882_2944:()=>vsn,content_3882_2946:()=>Nsn,content_3882_2948:()=>Psn,content_3882_2950:()=>Wsn,content_3882_2952:()=>Gsn,content_3882_2954:()=>Usn,content_3882_2956:()=>qsn,content_3882_2958:()=>Ysn,content_3882_296:()=>K6,content_3882_2960:()=>Ksn,content_3882_2962:()=>ecn,content_3882_2964:()=>ocn,content_3882_2966:()=>scn,content_3882_2968:()=>icn,content_3882_2970:()=>mcn,content_3882_2972:()=>hcn,content_3882_2974:()=>Dcn,content_3882_2976:()=>_cn,content_3882_2978:()=>Ccn,content_3882_298:()=>e5,content_3882_2980:()=>vcn,content_3882_2982:()=>Ncn,content_3882_2984:()=>Pcn,content_3882_2986:()=>Wcn,content_3882_2988:()=>Gcn,content_3882_2990:()=>Ucn,content_3882_2992:()=>qcn,content_3882_2994:()=>Ycn,content_3882_2996:()=>Kcn,content_3882_2998:()=>ean,content_3882_30:()=>NZ,content_3882_300:()=>o5,content_3882_3000:()=>oan,content_3882_3002:()=>san,content_3882_3004:()=>ian,content_3882_3006:()=>man,content_3882_3008:()=>han,content_3882_3010:()=>Dan,content_3882_3012:()=>_an,content_3882_3014:()=>Can,content_3882_3016:()=>van,content_3882_3018:()=>Nan,content_3882_302:()=>s5,content_3882_3020:()=>Pan,content_3882_3022:()=>Wan,content_3882_3024:()=>Gan,content_3882_3026:()=>Uan,content_3882_3028:()=>qan,content_3882_3030:()=>Yan,content_3882_3032:()=>Kan,content_3882_3034:()=>ein,content_3882_3036:()=>oin,content_3882_3038:()=>sin,content_3882_304:()=>i5,content_3882_3040:()=>iin,content_3882_3042:()=>min,content_3882_3044:()=>hin,content_3882_3046:()=>Din,content_3882_3048:()=>_in,content_3882_3050:()=>Cin,content_3882_3052:()=>vin,content_3882_3054:()=>Nin,content_3882_3056:()=>Pin,content_3882_3058:()=>Win,content_3882_306:()=>m5,content_3882_3060:()=>Gin,content_3882_3062:()=>Uin,content_3882_3064:()=>qin,content_3882_3066:()=>Yin,content_3882_3068:()=>Kin,content_3882_3070:()=>eln,content_3882_3072:()=>oln,content_3882_3074:()=>sln,content_3882_3076:()=>iln,content_3882_3078:()=>mln,content_3882_308:()=>h5,content_3882_3080:()=>hln,content_3882_3082:()=>Dln,content_3882_3084:()=>_ln,content_3882_3086:()=>Cln,content_3882_3088:()=>vln,content_3882_3090:()=>Nln,content_3882_3092:()=>Pln,content_3882_3094:()=>Wln,content_3882_3096:()=>Gln,content_3882_3098:()=>Uln,content_3882_310:()=>D5,content_3882_3100:()=>qln,content_3882_3102:()=>Yln,content_3882_3104:()=>Kln,content_3882_3106:()=>eun,content_3882_3108:()=>oun,content_3882_3110:()=>sun,content_3882_3112:()=>iun,content_3882_3114:()=>mun,content_3882_3116:()=>hun,content_3882_3118:()=>Dun,content_3882_312:()=>_5,content_3882_3120:()=>_un,content_3882_3122:()=>Cun,content_3882_3124:()=>vun,content_3882_3126:()=>Nun,content_3882_3128:()=>Pun,content_3882_3130:()=>Wun,content_3882_3132:()=>Gun,content_3882_3134:()=>Uun,content_3882_3136:()=>qun,content_3882_3138:()=>Yun,content_3882_314:()=>C5,content_3882_3140:()=>Kun,content_3882_3142:()=>emn,content_3882_3144:()=>omn,content_3882_3146:()=>smn,content_3882_3148:()=>imn,content_3882_3150:()=>mmn,content_3882_3152:()=>hmn,content_3882_3154:()=>Dmn,content_3882_3156:()=>_mn,content_3882_3158:()=>Cmn,content_3882_316:()=>v5,content_3882_3160:()=>vmn,content_3882_3162:()=>Nmn,content_3882_3164:()=>Pmn,content_3882_3166:()=>Wmn,content_3882_3168:()=>Gmn,content_3882_3170:()=>Umn,content_3882_3172:()=>qmn,content_3882_3174:()=>Ymn,content_3882_3176:()=>Kmn,content_3882_3178:()=>eyn,content_3882_318:()=>N5,content_3882_3180:()=>oyn,content_3882_3182:()=>syn,content_3882_3184:()=>iyn,content_3882_3186:()=>myn,content_3882_3188:()=>hyn,content_3882_3190:()=>Dyn,content_3882_3192:()=>_yn,content_3882_3194:()=>Cyn,content_3882_3196:()=>vyn,content_3882_3198:()=>Nyn,content_3882_32:()=>PZ,content_3882_320:()=>P5,content_3882_3200:()=>Pyn,content_3882_3202:()=>Wyn,content_3882_3204:()=>Gyn,content_3882_3206:()=>Uyn,content_3882_3208:()=>qyn,content_3882_3210:()=>Yyn,content_3882_3212:()=>Kyn,content_3882_3214:()=>edn,content_3882_3216:()=>odn,content_3882_3218:()=>sdn,content_3882_322:()=>W5,content_3882_3220:()=>idn,content_3882_3222:()=>mdn,content_3882_3224:()=>hdn,content_3882_3226:()=>Ddn,content_3882_3228:()=>_dn,content_3882_3230:()=>Cdn,content_3882_3232:()=>vdn,content_3882_3234:()=>Ndn,content_3882_3236:()=>Pdn,content_3882_3238:()=>Wdn,content_3882_324:()=>G5,content_3882_3240:()=>Gdn,content_3882_3242:()=>Udn,content_3882_3244:()=>qdn,content_3882_3246:()=>Ydn,content_3882_3248:()=>Kdn,content_3882_3250:()=>ehn,content_3882_3252:()=>ohn,content_3882_3254:()=>shn,content_3882_3256:()=>ihn,content_3882_3258:()=>mhn,content_3882_326:()=>U5,content_3882_3260:()=>hhn,content_3882_3262:()=>Dhn,content_3882_3264:()=>_hn,content_3882_3266:()=>Chn,content_3882_3268:()=>vhn,content_3882_3270:()=>Nhn,content_3882_3272:()=>Phn,content_3882_3274:()=>Whn,content_3882_3276:()=>Ghn,content_3882_3278:()=>Uhn,content_3882_328:()=>q5,content_3882_3280:()=>qhn,content_3882_3282:()=>Yhn,content_3882_3284:()=>Khn,content_3882_3286:()=>egn,content_3882_3288:()=>ogn,content_3882_3290:()=>sgn,content_3882_3292:()=>ign,content_3882_3294:()=>mgn,content_3882_3296:()=>hgn,content_3882_3298:()=>Dgn,content_3882_330:()=>Y5,content_3882_3300:()=>_gn,content_3882_3302:()=>Cgn,content_3882_3304:()=>vgn,content_3882_3306:()=>Ngn,content_3882_3308:()=>Pgn,content_3882_3310:()=>Wgn,content_3882_3312:()=>Ggn,content_3882_3314:()=>Ugn,content_3882_3316:()=>qgn,content_3882_3318:()=>Ygn,content_3882_332:()=>K5,content_3882_3320:()=>Kgn,content_3882_3322:()=>efn,content_3882_3324:()=>ofn,content_3882_3326:()=>sfn,content_3882_3328:()=>ifn,content_3882_3330:()=>mfn,content_3882_3332:()=>hfn,content_3882_3334:()=>Dfn,content_3882_3336:()=>_fn,content_3882_3338:()=>Cfn,content_3882_334:()=>e7,content_3882_3340:()=>vfn,content_3882_3342:()=>Nfn,content_3882_3344:()=>Pfn,content_3882_3346:()=>Wfn,content_3882_3348:()=>Gfn,content_3882_3350:()=>Ufn,content_3882_3352:()=>qfn,content_3882_3354:()=>Yfn,content_3882_3356:()=>Kfn,content_3882_3358:()=>eDn,content_3882_336:()=>o7,content_3882_3360:()=>oDn,content_3882_3362:()=>sDn,content_3882_3364:()=>iDn,content_3882_3366:()=>mDn,content_3882_3368:()=>hDn,content_3882_3370:()=>DDn,content_3882_3372:()=>_Dn,content_3882_3374:()=>CDn,content_3882_3376:()=>vDn,content_3882_3378:()=>NDn,content_3882_338:()=>s7,content_3882_3380:()=>PDn,content_3882_3382:()=>WDn,content_3882_3384:()=>GDn,content_3882_3386:()=>UDn,content_3882_3388:()=>qDn,content_3882_3390:()=>YDn,content_3882_3392:()=>KDn,content_3882_3394:()=>eMn,content_3882_3396:()=>oMn,content_3882_3398:()=>sMn,content_3882_34:()=>WZ,content_3882_340:()=>i7,content_3882_3400:()=>iMn,content_3882_3402:()=>mMn,content_3882_3404:()=>hMn,content_3882_3406:()=>DMn,content_3882_3408:()=>_Mn,content_3882_3410:()=>CMn,content_3882_3412:()=>vMn,content_3882_3414:()=>NMn,content_3882_3416:()=>PMn,content_3882_3418:()=>WMn,content_3882_342:()=>m7,content_3882_3420:()=>GMn,content_3882_3422:()=>UMn,content_3882_3424:()=>qMn,content_3882_3426:()=>YMn,content_3882_3428:()=>KMn,content_3882_3430:()=>eXn,content_3882_3432:()=>oXn,content_3882_3434:()=>sXn,content_3882_3436:()=>iXn,content_3882_3438:()=>mXn,content_3882_344:()=>h7,content_3882_3440:()=>hXn,content_3882_3442:()=>DXn,content_3882_3444:()=>_Xn,content_3882_3446:()=>CXn,content_3882_3448:()=>vXn,content_3882_3450:()=>NXn,content_3882_3452:()=>PXn,content_3882_3454:()=>WXn,content_3882_3456:()=>GXn,content_3882_3458:()=>UXn,content_3882_346:()=>D7,content_3882_3460:()=>qXn,content_3882_3462:()=>YXn,content_3882_3464:()=>KXn,content_3882_3466:()=>e_n,content_3882_3468:()=>o_n,content_3882_3470:()=>s_n,content_3882_3472:()=>i_n,content_3882_3474:()=>m_n,content_3882_3476:()=>h_n,content_3882_3478:()=>D_n,content_3882_348:()=>_7,content_3882_3480:()=>__n,content_3882_3482:()=>C_n,content_3882_3484:()=>v_n,content_3882_3486:()=>N_n,content_3882_3488:()=>P_n,content_3882_3490:()=>W_n,content_3882_3492:()=>G_n,content_3882_3494:()=>U_n,content_3882_3496:()=>q_n,content_3882_3498:()=>Y_n,content_3882_350:()=>C7,content_3882_3500:()=>K_n,content_3882_3502:()=>ewn,content_3882_3504:()=>own,content_3882_3506:()=>swn,content_3882_3508:()=>iwn,content_3882_3510:()=>mwn,content_3882_3512:()=>hwn,content_3882_3514:()=>Dwn,content_3882_3516:()=>_wn,content_3882_3518:()=>Cwn,content_3882_352:()=>v7,content_3882_3520:()=>vwn,content_3882_3522:()=>Nwn,content_3882_3524:()=>Pwn,content_3882_3526:()=>Wwn,content_3882_3528:()=>Gwn,content_3882_3530:()=>Uwn,content_3882_3532:()=>qwn,content_3882_3534:()=>Ywn,content_3882_3536:()=>Kwn,content_3882_3538:()=>eTn,content_3882_354:()=>N7,content_3882_3540:()=>oTn,content_3882_3542:()=>sTn,content_3882_3544:()=>iTn,content_3882_3546:()=>mTn,content_3882_3548:()=>hTn,content_3882_3550:()=>DTn,content_3882_3552:()=>_Tn,content_3882_3554:()=>CTn,content_3882_3556:()=>vTn,content_3882_3558:()=>NTn,content_3882_356:()=>P7,content_3882_3560:()=>PTn,content_3882_3562:()=>WTn,content_3882_3564:()=>GTn,content_3882_3566:()=>UTn,content_3882_3568:()=>qTn,content_3882_3570:()=>YTn,content_3882_3572:()=>KTn,content_3882_3574:()=>eCn,content_3882_3576:()=>oCn,content_3882_3578:()=>sCn,content_3882_358:()=>W7,content_3882_3580:()=>iCn,content_3882_3582:()=>mCn,content_3882_3584:()=>hCn,content_3882_3586:()=>DCn,content_3882_3588:()=>_Cn,content_3882_3590:()=>CCn,content_3882_3592:()=>vCn,content_3882_3594:()=>NCn,content_3882_3596:()=>PCn,content_3882_3598:()=>WCn,content_3882_36:()=>GZ,content_3882_360:()=>G7,content_3882_3600:()=>GCn,content_3882_3602:()=>UCn,content_3882_3604:()=>qCn,content_3882_3606:()=>YCn,content_3882_3608:()=>KCn,content_3882_3610:()=>exn,content_3882_3612:()=>oxn,content_3882_3614:()=>sxn,content_3882_3616:()=>ixn,content_3882_3618:()=>mxn,content_3882_362:()=>U7,content_3882_3620:()=>hxn,content_3882_3622:()=>Dxn,content_3882_3624:()=>_xn,content_3882_3626:()=>Cxn,content_3882_3628:()=>vxn,content_3882_3630:()=>Nxn,content_3882_3632:()=>Pxn,content_3882_3634:()=>Wxn,content_3882_3636:()=>Gxn,content_3882_3638:()=>Uxn,content_3882_364:()=>q7,content_3882_3640:()=>qxn,content_3882_3642:()=>Yxn,content_3882_3644:()=>Kxn,content_3882_3646:()=>eAn,content_3882_3648:()=>oAn,content_3882_3650:()=>sAn,content_3882_3652:()=>iAn,content_3882_3654:()=>mAn,content_3882_3656:()=>hAn,content_3882_3658:()=>DAn,content_3882_366:()=>Y7,content_3882_3660:()=>_An,content_3882_3662:()=>CAn,content_3882_3664:()=>vAn,content_3882_3666:()=>NAn,content_3882_3668:()=>PAn,content_3882_3670:()=>WAn,content_3882_3672:()=>GAn,content_3882_3674:()=>UAn,content_3882_3676:()=>qAn,content_3882_3678:()=>YAn,content_3882_368:()=>K7,content_3882_3680:()=>KAn,content_3882_3682:()=>evn,content_3882_3684:()=>ovn,content_3882_3686:()=>svn,content_3882_3688:()=>ivn,content_3882_3690:()=>mvn,content_3882_3692:()=>hvn,content_3882_3694:()=>Dvn,content_3882_3696:()=>_vn,content_3882_3698:()=>Cvn,content_3882_370:()=>e9,content_3882_3700:()=>vvn,content_3882_3702:()=>Nvn,content_3882_3704:()=>Pvn,content_3882_3706:()=>Wvn,content_3882_3708:()=>Gvn,content_3882_3710:()=>Uvn,content_3882_3712:()=>qvn,content_3882_3714:()=>Yvn,content_3882_3716:()=>Kvn,content_3882_3718:()=>eLn,content_3882_372:()=>o9,content_3882_3720:()=>oLn,content_3882_3722:()=>sLn,content_3882_3724:()=>iLn,content_3882_3726:()=>mLn,content_3882_3728:()=>hLn,content_3882_3730:()=>DLn,content_3882_3732:()=>_Ln,content_3882_3734:()=>CLn,content_3882_3736:()=>vLn,content_3882_3738:()=>NLn,content_3882_374:()=>s9,content_3882_3740:()=>PLn,content_3882_3742:()=>WLn,content_3882_3744:()=>GLn,content_3882_3746:()=>ULn,content_3882_3748:()=>qLn,content_3882_3750:()=>YLn,content_3882_3752:()=>KLn,content_3882_3754:()=>ebn,content_3882_3756:()=>obn,content_3882_3758:()=>sbn,content_3882_376:()=>i9,content_3882_3760:()=>ibn,content_3882_3762:()=>mbn,content_3882_3764:()=>hbn,content_3882_3766:()=>Dbn,content_3882_3768:()=>_bn,content_3882_3770:()=>Cbn,content_3882_3772:()=>vbn,content_3882_3774:()=>Nbn,content_3882_3776:()=>Pbn,content_3882_3778:()=>Wbn,content_3882_378:()=>m9,content_3882_3780:()=>Gbn,content_3882_3782:()=>Ubn,content_3882_3784:()=>qbn,content_3882_3786:()=>Ybn,content_3882_3788:()=>Kbn,content_3882_3790:()=>eNn,content_3882_3792:()=>oNn,content_3882_3794:()=>sNn,content_3882_3796:()=>iNn,content_3882_3798:()=>mNn,content_3882_38:()=>UZ,content_3882_380:()=>h9,content_3882_3800:()=>hNn,content_3882_3802:()=>DNn,content_3882_3804:()=>_Nn,content_3882_3806:()=>CNn,content_3882_3808:()=>vNn,content_3882_3810:()=>NNn,content_3882_3812:()=>PNn,content_3882_3814:()=>WNn,content_3882_3816:()=>GNn,content_3882_3818:()=>UNn,content_3882_382:()=>D9,content_3882_3820:()=>qNn,content_3882_3822:()=>YNn,content_3882_3824:()=>KNn,content_3882_3826:()=>ekn,content_3882_3828:()=>okn,content_3882_3830:()=>skn,content_3882_3832:()=>ikn,content_3882_3834:()=>mkn,content_3882_3836:()=>hkn,content_3882_3838:()=>Dkn,content_3882_384:()=>_9,content_3882_3840:()=>_kn,content_3882_3842:()=>Ckn,content_3882_3844:()=>vkn,content_3882_3846:()=>Nkn,content_3882_3848:()=>Pkn,content_3882_3850:()=>Wkn,content_3882_3852:()=>Gkn,content_3882_3854:()=>Ukn,content_3882_3856:()=>qkn,content_3882_3858:()=>Ykn,content_3882_386:()=>C9,content_3882_3860:()=>Kkn,content_3882_3862:()=>ezn,content_3882_3864:()=>ozn,content_3882_3866:()=>szn,content_3882_3868:()=>izn,content_3882_3870:()=>mzn,content_3882_3872:()=>hzn,content_3882_3874:()=>Dzn,content_3882_3876:()=>_zn,content_3882_3878:()=>Czn,content_3882_388:()=>v9,content_3882_3880:()=>vzn,content_3882_3882:()=>Nzn,content_3882_3884:()=>Pzn,content_3882_3886:()=>Wzn,content_3882_3888:()=>Gzn,content_3882_3890:()=>Uzn,content_3882_3892:()=>qzn,content_3882_3894:()=>Yzn,content_3882_3896:()=>Kzn,content_3882_3898:()=>ePn,content_3882_390:()=>N9,content_3882_3900:()=>oPn,content_3882_3902:()=>sPn,content_3882_3904:()=>iPn,content_3882_3906:()=>mPn,content_3882_3908:()=>hPn,content_3882_3910:()=>DPn,content_3882_3912:()=>_Pn,content_3882_3914:()=>CPn,content_3882_3916:()=>vPn,content_3882_3918:()=>NPn,content_3882_392:()=>P9,content_3882_3920:()=>PPn,content_3882_3922:()=>WPn,content_3882_3924:()=>GPn,content_3882_3926:()=>UPn,content_3882_3928:()=>qPn,content_3882_3930:()=>YPn,content_3882_3932:()=>KPn,content_3882_3934:()=>eIn,content_3882_3936:()=>oIn,content_3882_3938:()=>sIn,content_3882_394:()=>W9,content_3882_3940:()=>iIn,content_3882_3942:()=>mIn,content_3882_3944:()=>hIn,content_3882_3946:()=>DIn,content_3882_3948:()=>_In,content_3882_3950:()=>CIn,content_3882_3952:()=>vIn,content_3882_3954:()=>NIn,content_3882_3956:()=>PIn,content_3882_3958:()=>WIn,content_3882_396:()=>G9,content_3882_3960:()=>GIn,content_3882_3962:()=>UIn,content_3882_3964:()=>qIn,content_3882_3966:()=>YIn,content_3882_3968:()=>KIn,content_3882_3970:()=>eRn,content_3882_3972:()=>oRn,content_3882_3974:()=>sRn,content_3882_3976:()=>iRn,content_3882_3978:()=>mRn,content_3882_398:()=>U9,content_3882_3980:()=>hRn,content_3882_3982:()=>DRn,content_3882_3984:()=>_Rn,content_3882_3986:()=>CRn,content_3882_3988:()=>vRn,content_3882_3990:()=>NRn,content_3882_3992:()=>PRn,content_3882_3994:()=>WRn,content_3882_3996:()=>GRn,content_3882_3998:()=>URn,content_3882_4:()=>qJ,content_3882_40:()=>qZ,content_3882_400:()=>q9,content_3882_4000:()=>qRn,content_3882_4002:()=>YRn,content_3882_4004:()=>KRn,content_3882_4006:()=>eWn,content_3882_4008:()=>oWn,content_3882_4010:()=>sWn,content_3882_4012:()=>iWn,content_3882_4014:()=>mWn,content_3882_4016:()=>hWn,content_3882_4018:()=>DWn,content_3882_402:()=>Y9,content_3882_4020:()=>_Wn,content_3882_4022:()=>CWn,content_3882_4024:()=>vWn,content_3882_4026:()=>NWn,content_3882_4028:()=>PWn,content_3882_4030:()=>WWn,content_3882_4032:()=>GWn,content_3882_4034:()=>UWn,content_3882_4036:()=>qWn,content_3882_4038:()=>YWn,content_3882_404:()=>K9,content_3882_4040:()=>KWn,content_3882_4042:()=>eSn,content_3882_4044:()=>oSn,content_3882_4046:()=>sSn,content_3882_4048:()=>iSn,content_3882_4050:()=>mSn,content_3882_4052:()=>hSn,content_3882_4054:()=>DSn,content_3882_4056:()=>_Sn,content_3882_4058:()=>CSn,content_3882_406:()=>eee,content_3882_4060:()=>vSn,content_3882_4062:()=>NSn,content_3882_4064:()=>PSn,content_3882_4066:()=>WSn,content_3882_4068:()=>GSn,content_3882_4070:()=>USn,content_3882_4072:()=>qSn,content_3882_4074:()=>YSn,content_3882_4076:()=>KSn,content_3882_4078:()=>eBn,content_3882_408:()=>oee,content_3882_4080:()=>oBn,content_3882_4082:()=>sBn,content_3882_4084:()=>iBn,content_3882_4086:()=>mBn,content_3882_4088:()=>hBn,content_3882_4090:()=>DBn,content_3882_4092:()=>_Bn,content_3882_4094:()=>CBn,content_3882_4096:()=>vBn,content_3882_4098:()=>NBn,content_3882_410:()=>see,content_3882_4100:()=>PBn,content_3882_4102:()=>WBn,content_3882_4104:()=>GBn,content_3882_4106:()=>UBn,content_3882_4108:()=>qBn,content_3882_4110:()=>YBn,content_3882_4112:()=>KBn,content_3882_4114:()=>eGn,content_3882_4116:()=>oGn,content_3882_4118:()=>sGn,content_3882_412:()=>iee,content_3882_4120:()=>iGn,content_3882_4122:()=>mGn,content_3882_4124:()=>hGn,content_3882_4126:()=>DGn,content_3882_4128:()=>_Gn,content_3882_4130:()=>CGn,content_3882_4132:()=>vGn,content_3882_4134:()=>NGn,content_3882_4136:()=>PGn,content_3882_4138:()=>WGn,content_3882_414:()=>mee,content_3882_4140:()=>GGn,content_3882_4142:()=>UGn,content_3882_4144:()=>qGn,content_3882_4146:()=>YGn,content_3882_4148:()=>KGn,content_3882_4150:()=>eEn,content_3882_4152:()=>oEn,content_3882_4154:()=>sEn,content_3882_4156:()=>iEn,content_3882_4158:()=>mEn,content_3882_416:()=>hee,content_3882_4160:()=>hEn,content_3882_4162:()=>DEn,content_3882_4164:()=>_En,content_3882_4166:()=>CEn,content_3882_4168:()=>vEn,content_3882_4170:()=>NEn,content_3882_4172:()=>PEn,content_3882_4174:()=>WEn,content_3882_4176:()=>GEn,content_3882_4178:()=>UEn,content_3882_418:()=>Dee,content_3882_4180:()=>qEn,content_3882_4182:()=>YEn,content_3882_4184:()=>KEn,content_3882_4186:()=>eOn,content_3882_4188:()=>oOn,content_3882_4190:()=>sOn,content_3882_4192:()=>iOn,content_3882_4194:()=>mOn,content_3882_4196:()=>hOn,content_3882_4198:()=>DOn,content_3882_42:()=>YZ,content_3882_420:()=>_ee,content_3882_4200:()=>_On,content_3882_4202:()=>COn,content_3882_4204:()=>vOn,content_3882_4206:()=>NOn,content_3882_4208:()=>POn,content_3882_4210:()=>WOn,content_3882_4212:()=>GOn,content_3882_4214:()=>UOn,content_3882_4216:()=>qOn,content_3882_4218:()=>YOn,content_3882_422:()=>Cee,content_3882_4220:()=>KOn,content_3882_4222:()=>eUn,content_3882_4224:()=>oUn,content_3882_4226:()=>sUn,content_3882_4228:()=>iUn,content_3882_4230:()=>mUn,content_3882_4232:()=>hUn,content_3882_4234:()=>DUn,content_3882_4236:()=>_Un,content_3882_4238:()=>CUn,content_3882_424:()=>vee,content_3882_4240:()=>vUn,content_3882_4242:()=>NUn,content_3882_4244:()=>PUn,content_3882_4246:()=>WUn,content_3882_4248:()=>GUn,content_3882_4250:()=>UUn,content_3882_4252:()=>qUn,content_3882_4254:()=>YUn,content_3882_4256:()=>KUn,content_3882_4258:()=>eFn,content_3882_426:()=>Nee,content_3882_4260:()=>oFn,content_3882_4262:()=>sFn,content_3882_4264:()=>iFn,content_3882_4266:()=>mFn,content_3882_4268:()=>hFn,content_3882_4270:()=>DFn,content_3882_4272:()=>_Fn,content_3882_4274:()=>CFn,content_3882_4276:()=>vFn,content_3882_4278:()=>NFn,content_3882_428:()=>Pee,content_3882_4280:()=>PFn,content_3882_4282:()=>WFn,content_3882_4284:()=>GFn,content_3882_4286:()=>UFn,content_3882_4288:()=>qFn,content_3882_4290:()=>YFn,content_3882_4292:()=>KFn,content_3882_4294:()=>eVn,content_3882_4296:()=>oVn,content_3882_4298:()=>sVn,content_3882_430:()=>Wee,content_3882_4300:()=>iVn,content_3882_4302:()=>mVn,content_3882_4304:()=>hVn,content_3882_4306:()=>DVn,content_3882_4308:()=>_Vn,content_3882_4310:()=>CVn,content_3882_4312:()=>vVn,content_3882_4314:()=>NVn,content_3882_4316:()=>PVn,content_3882_4318:()=>WVn,content_3882_432:()=>Gee,content_3882_4320:()=>GVn,content_3882_4322:()=>UVn,content_3882_4324:()=>qVn,content_3882_4326:()=>YVn,content_3882_4328:()=>KVn,content_3882_4330:()=>eqn,content_3882_4332:()=>oqn,content_3882_4334:()=>sqn,content_3882_4336:()=>iqn,content_3882_4338:()=>mqn,content_3882_434:()=>Uee,content_3882_4340:()=>hqn,content_3882_4342:()=>Dqn,content_3882_4344:()=>_qn,content_3882_4346:()=>Cqn,content_3882_4348:()=>vqn,content_3882_4350:()=>Nqn,content_3882_4352:()=>Pqn,content_3882_4354:()=>Wqn,content_3882_4356:()=>Gqn,content_3882_4358:()=>Uqn,content_3882_436:()=>qee,content_3882_4360:()=>qqn,content_3882_4362:()=>Yqn,content_3882_4364:()=>Kqn,content_3882_4366:()=>ejn,content_3882_4368:()=>ojn,content_3882_4370:()=>sjn,content_3882_4372:()=>ijn,content_3882_4374:()=>mjn,content_3882_4376:()=>hjn,content_3882_4378:()=>Djn,content_3882_438:()=>Yee,content_3882_4380:()=>_jn,content_3882_4382:()=>Cjn,content_3882_4384:()=>vjn,content_3882_4386:()=>Njn,content_3882_4388:()=>Pjn,content_3882_4390:()=>Wjn,content_3882_4392:()=>Gjn,content_3882_4394:()=>Ujn,content_3882_4396:()=>qjn,content_3882_4398:()=>Yjn,content_3882_44:()=>KZ,content_3882_440:()=>Kee,content_3882_4400:()=>Kjn,content_3882_4402:()=>eHn,content_3882_4404:()=>oHn,content_3882_4406:()=>sHn,content_3882_4408:()=>iHn,content_3882_4410:()=>mHn,content_3882_4412:()=>hHn,content_3882_4414:()=>DHn,content_3882_4416:()=>_Hn,content_3882_4418:()=>CHn,content_3882_442:()=>ene,content_3882_4420:()=>vHn,content_3882_4422:()=>NHn,content_3882_4424:()=>PHn,content_3882_4426:()=>WHn,content_3882_4428:()=>GHn,content_3882_4430:()=>UHn,content_3882_4432:()=>qHn,content_3882_4434:()=>YHn,content_3882_4436:()=>KHn,content_3882_4438:()=>eYn,content_3882_444:()=>one,content_3882_4440:()=>oYn,content_3882_4442:()=>sYn,content_3882_4444:()=>iYn,content_3882_4446:()=>mYn,content_3882_4448:()=>hYn,content_3882_4450:()=>DYn,content_3882_4452:()=>_Yn,content_3882_4454:()=>CYn,content_3882_4456:()=>vYn,content_3882_4458:()=>NYn,content_3882_446:()=>sne,content_3882_4460:()=>PYn,content_3882_4462:()=>WYn,content_3882_4464:()=>GYn,content_3882_4466:()=>UYn,content_3882_4468:()=>qYn,content_3882_4470:()=>YYn,content_3882_4472:()=>KYn,content_3882_4474:()=>eQn,content_3882_4476:()=>oQn,content_3882_4478:()=>sQn,content_3882_448:()=>ine,content_3882_4480:()=>iQn,content_3882_4482:()=>mQn,content_3882_4484:()=>hQn,content_3882_4486:()=>DQn,content_3882_4488:()=>_Qn,content_3882_4490:()=>CQn,content_3882_4492:()=>vQn,content_3882_4494:()=>NQn,content_3882_4496:()=>PQn,content_3882_4498:()=>WQn,content_3882_450:()=>mne,content_3882_4500:()=>GQn,content_3882_4502:()=>UQn,content_3882_4504:()=>qQn,content_3882_4506:()=>YQn,content_3882_4508:()=>KQn,content_3882_4510:()=>e$n,content_3882_4512:()=>o$n,content_3882_4514:()=>s$n,content_3882_4516:()=>i$n,content_3882_4518:()=>m$n,content_3882_452:()=>hne,content_3882_4520:()=>h$n,content_3882_4522:()=>D$n,content_3882_4524:()=>_$n,content_3882_4526:()=>C$n,content_3882_4528:()=>v$n,content_3882_4530:()=>N$n,content_3882_4532:()=>P$n,content_3882_4534:()=>W$n,content_3882_4536:()=>G$n,content_3882_4538:()=>U$n,content_3882_454:()=>Dne,content_3882_4540:()=>q$n,content_3882_4542:()=>Y$n,content_3882_4544:()=>K$n,content_3882_4546:()=>eKn,content_3882_4548:()=>oKn,content_3882_4550:()=>sKn,content_3882_4552:()=>iKn,content_3882_4554:()=>mKn,content_3882_4556:()=>hKn,content_3882_4558:()=>DKn,content_3882_456:()=>_ne,content_3882_4560:()=>_Kn,content_3882_4562:()=>CKn,content_3882_4564:()=>vKn,content_3882_4566:()=>NKn,content_3882_4568:()=>PKn,content_3882_4570:()=>WKn,content_3882_4572:()=>GKn,content_3882_4574:()=>UKn,content_3882_4576:()=>qKn,content_3882_4578:()=>YKn,content_3882_458:()=>Cne,content_3882_4580:()=>KKn,content_3882_4582:()=>eJn,content_3882_4584:()=>oJn,content_3882_4586:()=>sJn,content_3882_4588:()=>iJn,content_3882_4590:()=>mJn,content_3882_4592:()=>hJn,content_3882_4594:()=>DJn,content_3882_4596:()=>_Jn,content_3882_4598:()=>CJn,content_3882_46:()=>e0,content_3882_460:()=>vne,content_3882_4600:()=>vJn,content_3882_4602:()=>NJn,content_3882_4604:()=>PJn,content_3882_4606:()=>WJn,content_3882_4608:()=>GJn,content_3882_4610:()=>UJn,content_3882_4612:()=>qJn,content_3882_4614:()=>YJn,content_3882_4616:()=>KJn,content_3882_4618:()=>eZn,content_3882_462:()=>Nne,content_3882_4620:()=>oZn,content_3882_4622:()=>sZn,content_3882_4624:()=>iZn,content_3882_4626:()=>mZn,content_3882_4628:()=>hZn,content_3882_4630:()=>DZn,content_3882_4632:()=>_Zn,content_3882_4634:()=>CZn,content_3882_4636:()=>vZn,content_3882_4638:()=>NZn,content_3882_464:()=>Pne,content_3882_4640:()=>PZn,content_3882_4642:()=>WZn,content_3882_4644:()=>GZn,content_3882_4646:()=>UZn,content_3882_4648:()=>qZn,content_3882_4650:()=>YZn,content_3882_4652:()=>KZn,content_3882_4654:()=>e0n,content_3882_4656:()=>o0n,content_3882_4658:()=>s0n,content_3882_466:()=>Wne,content_3882_4660:()=>i0n,content_3882_4662:()=>m0n,content_3882_4664:()=>h0n,content_3882_4666:()=>D0n,content_3882_4668:()=>_0n,content_3882_4670:()=>C0n,content_3882_4672:()=>v0n,content_3882_4674:()=>N0n,content_3882_4676:()=>P0n,content_3882_4678:()=>W0n,content_3882_468:()=>Gne,content_3882_4680:()=>G0n,content_3882_4682:()=>U0n,content_3882_4684:()=>q0n,content_3882_4686:()=>Y0n,content_3882_4688:()=>K0n,content_3882_4690:()=>e8n,content_3882_4692:()=>o8n,content_3882_4694:()=>s8n,content_3882_4696:()=>i8n,content_3882_4698:()=>m8n,content_3882_470:()=>Une,content_3882_4700:()=>h8n,content_3882_4702:()=>D8n,content_3882_4704:()=>_8n,content_3882_4706:()=>C8n,content_3882_4708:()=>v8n,content_3882_4710:()=>N8n,content_3882_4712:()=>P8n,content_3882_4714:()=>W8n,content_3882_4716:()=>G8n,content_3882_4718:()=>U8n,content_3882_472:()=>qne,content_3882_4720:()=>q8n,content_3882_4722:()=>Y8n,content_3882_4724:()=>K8n,content_3882_4726:()=>e2n,content_3882_4728:()=>o2n,content_3882_4730:()=>s2n,content_3882_4732:()=>i2n,content_3882_4734:()=>m2n,content_3882_4736:()=>h2n,content_3882_4738:()=>D2n,content_3882_474:()=>Yne,content_3882_4740:()=>_2n,content_3882_4742:()=>C2n,content_3882_4744:()=>v2n,content_3882_4746:()=>N2n,content_3882_4748:()=>P2n,content_3882_4750:()=>W2n,content_3882_4752:()=>G2n,content_3882_4754:()=>U2n,content_3882_4756:()=>q2n,content_3882_4758:()=>Y2n,content_3882_476:()=>Kne,content_3882_4760:()=>K2n,content_3882_4762:()=>e3n,content_3882_4764:()=>o3n,content_3882_4766:()=>s3n,content_3882_4768:()=>i3n,content_3882_4770:()=>m3n,content_3882_4772:()=>h3n,content_3882_4774:()=>D3n,content_3882_4776:()=>_3n,content_3882_4778:()=>C3n,content_3882_478:()=>ete,content_3882_4780:()=>v3n,content_3882_4782:()=>N3n,content_3882_4784:()=>P3n,content_3882_4786:()=>W3n,content_3882_4788:()=>G3n,content_3882_4790:()=>U3n,content_3882_4792:()=>q3n,content_3882_4794:()=>Y3n,content_3882_4796:()=>K3n,content_3882_4798:()=>e1n,content_3882_48:()=>o0,content_3882_480:()=>ote,content_3882_4800:()=>o1n,content_3882_4802:()=>s1n,content_3882_4804:()=>i1n,content_3882_4806:()=>m1n,content_3882_4808:()=>h1n,content_3882_4810:()=>D1n,content_3882_4812:()=>_1n,content_3882_4814:()=>C1n,content_3882_4816:()=>v1n,content_3882_4818:()=>N1n,content_3882_482:()=>ste,content_3882_4820:()=>P1n,content_3882_4822:()=>W1n,content_3882_4824:()=>G1n,content_3882_4826:()=>U1n,content_3882_4828:()=>q1n,content_3882_4830:()=>Y1n,content_3882_4832:()=>K1n,content_3882_4834:()=>e4n,content_3882_4836:()=>o4n,content_3882_4838:()=>s4n,content_3882_484:()=>ite,content_3882_4840:()=>i4n,content_3882_4842:()=>m4n,content_3882_4844:()=>h4n,content_3882_4846:()=>D4n,content_3882_4848:()=>_4n,content_3882_4850:()=>C4n,content_3882_4852:()=>v4n,content_3882_4854:()=>N4n,content_3882_4856:()=>P4n,content_3882_4858:()=>W4n,content_3882_486:()=>mte,content_3882_4860:()=>G4n,content_3882_4862:()=>U4n,content_3882_4864:()=>q4n,content_3882_4866:()=>Y4n,content_3882_4868:()=>K4n,content_3882_4870:()=>e6n,content_3882_4872:()=>o6n,content_3882_4874:()=>s6n,content_3882_4876:()=>i6n,content_3882_4878:()=>m6n,content_3882_488:()=>hte,content_3882_4880:()=>h6n,content_3882_4882:()=>D6n,content_3882_4884:()=>_6n,content_3882_4886:()=>C6n,content_3882_4888:()=>v6n,content_3882_4890:()=>N6n,content_3882_4892:()=>P6n,content_3882_4894:()=>W6n,content_3882_4896:()=>G6n,content_3882_4898:()=>U6n,content_3882_490:()=>Dte,content_3882_4900:()=>q6n,content_3882_4902:()=>Y6n,content_3882_4904:()=>K6n,content_3882_4906:()=>e5n,content_3882_4908:()=>o5n,content_3882_4910:()=>s5n,content_3882_4912:()=>i5n,content_3882_4914:()=>m5n,content_3882_4916:()=>h5n,content_3882_4918:()=>D5n,content_3882_492:()=>_te,content_3882_4920:()=>_5n,content_3882_4922:()=>C5n,content_3882_4924:()=>v5n,content_3882_4926:()=>N5n,content_3882_4928:()=>P5n,content_3882_4930:()=>W5n,content_3882_4932:()=>G5n,content_3882_4934:()=>U5n,content_3882_4936:()=>q5n,content_3882_4938:()=>Y5n,content_3882_494:()=>Cte,content_3882_4940:()=>K5n,content_3882_4942:()=>e7n,content_3882_4944:()=>o7n,content_3882_4946:()=>s7n,content_3882_4948:()=>i7n,content_3882_4950:()=>m7n,content_3882_4952:()=>h7n,content_3882_4954:()=>D7n,content_3882_4956:()=>_7n,content_3882_4958:()=>C7n,content_3882_496:()=>vte,content_3882_4960:()=>v7n,content_3882_4962:()=>N7n,content_3882_4964:()=>P7n,content_3882_4966:()=>W7n,content_3882_4968:()=>G7n,content_3882_4970:()=>U7n,content_3882_4972:()=>q7n,content_3882_4974:()=>Y7n,content_3882_4976:()=>K7n,content_3882_4978:()=>e9n,content_3882_498:()=>Nte,content_3882_4980:()=>o9n,content_3882_4982:()=>s9n,content_3882_4984:()=>i9n,content_3882_4986:()=>m9n,content_3882_4988:()=>h9n,content_3882_4990:()=>D9n,content_3882_4992:()=>_9n,content_3882_4994:()=>C9n,content_3882_4996:()=>v9n,content_3882_4998:()=>N9n,content_3882_50:()=>s0,content_3882_500:()=>Pte,content_3882_5000:()=>P9n,content_3882_5002:()=>W9n,content_3882_5004:()=>G9n,content_3882_5006:()=>U9n,content_3882_5008:()=>q9n,content_3882_5010:()=>Y9n,content_3882_5012:()=>K9n,content_3882_5014:()=>eet,content_3882_5016:()=>oet,content_3882_5018:()=>set,content_3882_502:()=>Wte,content_3882_5020:()=>iet,content_3882_5022:()=>yet,content_3882_5024:()=>get,content_3882_5026:()=>Met,content_3882_5028:()=>wet,content_3882_5030:()=>xet,content_3882_5032:()=>Let,content_3882_5034:()=>ket,content_3882_5036:()=>Iet,content_3882_5038:()=>Set,content_3882_504:()=>Gte,content_3882_5040:()=>Eet,content_3882_5042:()=>Fet,content_3882_5044:()=>jet,content_3882_5046:()=>Qet,content_3882_5048:()=>Jet,content_3882_5050:()=>nnt,content_3882_5052:()=>pnt,content_3882_5054:()=>cnt,content_3882_5056:()=>lnt,content_3882_5058:()=>ynt,content_3882_506:()=>Ute,content_3882_5060:()=>gnt,content_3882_5062:()=>Mnt,content_3882_5064:()=>wnt,content_3882_5066:()=>xnt,content_3882_5068:()=>Lnt,content_3882_5070:()=>knt,content_3882_5072:()=>Int,content_3882_5074:()=>Snt,content_3882_5076:()=>Ent,content_3882_5078:()=>Fnt,content_3882_508:()=>qte,content_3882_5080:()=>jnt,content_3882_5082:()=>Qnt,content_3882_5084:()=>Jnt,content_3882_5086:()=>ntt,content_3882_5088:()=>ptt,content_3882_5090:()=>ctt,content_3882_5092:()=>ltt,content_3882_5094:()=>ytt,content_3882_5096:()=>gtt,content_3882_5098:()=>Mtt,content_3882_510:()=>Yte,content_3882_5100:()=>wtt,content_3882_5102:()=>xtt,content_3882_5104:()=>Ltt,content_3882_5106:()=>ktt,content_3882_5108:()=>Itt,content_3882_5110:()=>Stt,content_3882_5112:()=>Ett,content_3882_5114:()=>Ftt,content_3882_5116:()=>jtt,content_3882_5118:()=>Qtt,content_3882_512:()=>Kte,content_3882_5120:()=>Jtt,content_3882_5122:()=>not,content_3882_5124:()=>pot,content_3882_5126:()=>cot,content_3882_5128:()=>lot,content_3882_5130:()=>yot,content_3882_5132:()=>got,content_3882_5134:()=>Mot,content_3882_5136:()=>wot,content_3882_5138:()=>xot,content_3882_514:()=>eoe,content_3882_5140:()=>Lot,content_3882_5142:()=>kot,content_3882_5144:()=>Iot,content_3882_5146:()=>Sot,content_3882_5148:()=>Eot,content_3882_5150:()=>Fot,content_3882_5152:()=>jot,content_3882_5154:()=>Qot,content_3882_5156:()=>Jot,content_3882_5158:()=>npt,content_3882_516:()=>ooe,content_3882_5160:()=>ppt,content_3882_5162:()=>cpt,content_3882_5164:()=>lpt,content_3882_5166:()=>ypt,content_3882_5168:()=>gpt,content_3882_5170:()=>Mpt,content_3882_5172:()=>wpt,content_3882_5174:()=>xpt,content_3882_5176:()=>Lpt,content_3882_5178:()=>kpt,content_3882_518:()=>soe,content_3882_5180:()=>Ipt,content_3882_5182:()=>Spt,content_3882_5184:()=>Ept,content_3882_5186:()=>Fpt,content_3882_5188:()=>jpt,content_3882_5190:()=>Qpt,content_3882_5192:()=>Jpt,content_3882_5194:()=>nrt,content_3882_5196:()=>prt,content_3882_5198:()=>crt,content_3882_52:()=>i0,content_3882_520:()=>ioe,content_3882_5200:()=>lrt,content_3882_5202:()=>yrt,content_3882_5204:()=>grt,content_3882_5206:()=>Mrt,content_3882_5208:()=>wrt,content_3882_5210:()=>xrt,content_3882_5212:()=>Lrt,content_3882_5214:()=>krt,content_3882_5216:()=>Irt,content_3882_5218:()=>Srt,content_3882_522:()=>moe,content_3882_5220:()=>Ert,content_3882_5222:()=>Frt,content_3882_5224:()=>jrt,content_3882_5226:()=>Qrt,content_3882_5228:()=>Jrt,content_3882_5230:()=>nst,content_3882_5232:()=>pst,content_3882_5234:()=>cst,content_3882_5236:()=>lst,content_3882_5238:()=>yst,content_3882_524:()=>hoe,content_3882_5240:()=>gst,content_3882_5242:()=>Mst,content_3882_5244:()=>wst,content_3882_5246:()=>xst,content_3882_5248:()=>Lst,content_3882_5250:()=>kst,content_3882_5252:()=>Ist,content_3882_5254:()=>Sst,content_3882_5256:()=>Est,content_3882_5258:()=>Fst,content_3882_526:()=>Doe,content_3882_5260:()=>jst,content_3882_5262:()=>Qst,content_3882_5264:()=>Jst,content_3882_5266:()=>nct,content_3882_5268:()=>pct,content_3882_5270:()=>cct,content_3882_5272:()=>lct,content_3882_5274:()=>yct,content_3882_5276:()=>gct,content_3882_5278:()=>Mct,content_3882_528:()=>_oe,content_3882_5280:()=>wct,content_3882_5282:()=>xct,content_3882_5284:()=>Lct,content_3882_5286:()=>kct,content_3882_5288:()=>Ict,content_3882_5290:()=>Sct,content_3882_5292:()=>Ect,content_3882_5294:()=>Fct,content_3882_5296:()=>jct,content_3882_5298:()=>Qct,content_3882_530:()=>Coe,content_3882_5300:()=>Jct,content_3882_5302:()=>nat,content_3882_5304:()=>pat,content_3882_5306:()=>cat,content_3882_5308:()=>lat,content_3882_5310:()=>yat,content_3882_5312:()=>gat,content_3882_5314:()=>Mat,content_3882_5316:()=>wat,content_3882_5318:()=>xat,content_3882_532:()=>voe,content_3882_5320:()=>Lat,content_3882_5322:()=>kat,content_3882_5324:()=>Iat,content_3882_5326:()=>Sat,content_3882_5328:()=>Eat,content_3882_5330:()=>Fat,content_3882_5332:()=>jat,content_3882_5334:()=>Qat,content_3882_5336:()=>Jat,content_3882_5338:()=>nit,content_3882_534:()=>Noe,content_3882_5340:()=>pit,content_3882_5342:()=>cit,content_3882_5344:()=>lit,content_3882_5346:()=>yit,content_3882_5348:()=>git,content_3882_5350:()=>Mit,content_3882_5352:()=>wit,content_3882_5354:()=>xit,content_3882_5356:()=>Lit,content_3882_5358:()=>kit,content_3882_536:()=>Poe,content_3882_5360:()=>Iit,content_3882_5362:()=>Sit,content_3882_5364:()=>Eit,content_3882_5366:()=>Fit,content_3882_5368:()=>jit,content_3882_5370:()=>Qit,content_3882_5372:()=>Jit,content_3882_5374:()=>nlt,content_3882_5376:()=>plt,content_3882_5378:()=>clt,content_3882_538:()=>Woe,content_3882_5380:()=>llt,content_3882_5382:()=>ylt,content_3882_5384:()=>glt,content_3882_5386:()=>Mlt,content_3882_5388:()=>wlt,content_3882_5390:()=>xlt,content_3882_5392:()=>Llt,content_3882_5394:()=>klt,content_3882_5396:()=>Ilt,content_3882_5398:()=>Slt,content_3882_54:()=>m0,content_3882_540:()=>Goe,content_3882_5400:()=>Elt,content_3882_5402:()=>Flt,content_3882_5404:()=>jlt,content_3882_5406:()=>Qlt,content_3882_5408:()=>Jlt,content_3882_5410:()=>nut,content_3882_5412:()=>put,content_3882_5414:()=>cut,content_3882_5416:()=>lut,content_3882_5418:()=>yut,content_3882_542:()=>Uoe,content_3882_5420:()=>gut,content_3882_5422:()=>Mut,content_3882_5424:()=>wut,content_3882_5426:()=>xut,content_3882_5428:()=>Lut,content_3882_5430:()=>kut,content_3882_5432:()=>Iut,content_3882_5434:()=>Sut,content_3882_5436:()=>Eut,content_3882_5438:()=>Fut,content_3882_544:()=>qoe,content_3882_5440:()=>jut,content_3882_5442:()=>Qut,content_3882_5444:()=>Jut,content_3882_5446:()=>nmt,content_3882_5448:()=>pmt,content_3882_5450:()=>cmt,content_3882_5452:()=>lmt,content_3882_5454:()=>ymt,content_3882_5456:()=>gmt,content_3882_5458:()=>Mmt,content_3882_546:()=>Yoe,content_3882_5460:()=>wmt,content_3882_5462:()=>xmt,content_3882_5464:()=>Lmt,content_3882_5466:()=>kmt,content_3882_5468:()=>Imt,content_3882_5470:()=>Smt,content_3882_5472:()=>Emt,content_3882_5474:()=>Fmt,content_3882_5476:()=>jmt,content_3882_5478:()=>Qmt,content_3882_548:()=>Koe,content_3882_5480:()=>Jmt,content_3882_5482:()=>nyt,content_3882_5484:()=>pyt,content_3882_5486:()=>cyt,content_3882_5488:()=>lyt,content_3882_5490:()=>yyt,content_3882_5492:()=>gyt,content_3882_5494:()=>Myt,content_3882_5496:()=>wyt,content_3882_5498:()=>xyt,content_3882_550:()=>epe,content_3882_5500:()=>Lyt,content_3882_5502:()=>kyt,content_3882_5504:()=>Iyt,content_3882_5506:()=>Syt,content_3882_5508:()=>Eyt,content_3882_5510:()=>Fyt,content_3882_5512:()=>jyt,content_3882_5514:()=>Qyt,content_3882_5516:()=>Jyt,content_3882_5518:()=>ndt,content_3882_552:()=>ope,content_3882_5520:()=>pdt,content_3882_5522:()=>cdt,content_3882_5524:()=>ldt,content_3882_5526:()=>ydt,content_3882_5528:()=>gdt,content_3882_5530:()=>Mdt,content_3882_5532:()=>wdt,content_3882_5534:()=>xdt,content_3882_5536:()=>Ldt,content_3882_5538:()=>kdt,content_3882_554:()=>spe,content_3882_5540:()=>Idt,content_3882_5542:()=>Sdt,content_3882_5544:()=>Edt,content_3882_5546:()=>Fdt,content_3882_5548:()=>jdt,content_3882_5550:()=>Qdt,content_3882_5552:()=>Jdt,content_3882_5554:()=>nht,content_3882_5556:()=>pht,content_3882_5558:()=>cht,content_3882_556:()=>ipe,content_3882_5560:()=>lht,content_3882_5562:()=>yht,content_3882_5564:()=>ght,content_3882_5566:()=>Mht,content_3882_5568:()=>wht,content_3882_5570:()=>xht,content_3882_5572:()=>Lht,content_3882_5574:()=>kht,content_3882_5576:()=>Iht,content_3882_5578:()=>Sht,content_3882_558:()=>mpe,content_3882_5580:()=>Eht,content_3882_5582:()=>Fht,content_3882_5584:()=>jht,content_3882_5586:()=>Qht,content_3882_5588:()=>Jht,content_3882_5590:()=>ngt,content_3882_5592:()=>pgt,content_3882_5594:()=>cgt,content_3882_5596:()=>lgt,content_3882_5598:()=>ygt,content_3882_56:()=>h0,content_3882_560:()=>hpe,content_3882_5600:()=>ggt,content_3882_5602:()=>Mgt,content_3882_5604:()=>wgt,content_3882_5606:()=>xgt,content_3882_5608:()=>Lgt,content_3882_5610:()=>kgt,content_3882_5612:()=>Igt,content_3882_5614:()=>Sgt,content_3882_5616:()=>Egt,content_3882_5618:()=>Fgt,content_3882_562:()=>Dpe,content_3882_5620:()=>jgt,content_3882_5622:()=>Qgt,content_3882_5624:()=>Jgt,content_3882_5626:()=>nft,content_3882_5628:()=>pft,content_3882_5630:()=>cft,content_3882_5632:()=>lft,content_3882_5634:()=>yft,content_3882_5636:()=>gft,content_3882_5638:()=>Mft,content_3882_564:()=>_pe,content_3882_5640:()=>wft,content_3882_5642:()=>xft,content_3882_5644:()=>Lft,content_3882_5646:()=>kft,content_3882_5648:()=>Ift,content_3882_5650:()=>Sft,content_3882_5652:()=>Eft,content_3882_5654:()=>Fft,content_3882_5656:()=>jft,content_3882_5658:()=>Qft,content_3882_566:()=>Cpe,content_3882_5660:()=>Jft,content_3882_5662:()=>nDt,content_3882_5664:()=>pDt,content_3882_5666:()=>cDt,content_3882_5668:()=>lDt,content_3882_5670:()=>yDt,content_3882_5672:()=>gDt,content_3882_5674:()=>MDt,content_3882_5676:()=>wDt,content_3882_5678:()=>xDt,content_3882_568:()=>vpe,content_3882_5680:()=>LDt,content_3882_5682:()=>kDt,content_3882_5684:()=>IDt,content_3882_5686:()=>SDt,content_3882_5688:()=>EDt,content_3882_5690:()=>FDt,content_3882_5692:()=>jDt,content_3882_5694:()=>QDt,content_3882_5696:()=>JDt,content_3882_5698:()=>nMt,content_3882_570:()=>Npe,content_3882_5700:()=>pMt,content_3882_5702:()=>cMt,content_3882_5704:()=>lMt,content_3882_5706:()=>yMt,content_3882_5708:()=>gMt,content_3882_5710:()=>MMt,content_3882_5712:()=>wMt,content_3882_5714:()=>xMt,content_3882_5716:()=>LMt,content_3882_5718:()=>kMt,content_3882_572:()=>Ppe,content_3882_5720:()=>IMt,content_3882_5722:()=>SMt,content_3882_5724:()=>EMt,content_3882_5726:()=>FMt,content_3882_5728:()=>jMt,content_3882_5730:()=>QMt,content_3882_5732:()=>JMt,content_3882_5734:()=>nXt,content_3882_5736:()=>pXt,content_3882_5738:()=>cXt,content_3882_574:()=>Wpe,content_3882_5740:()=>lXt,content_3882_5742:()=>yXt,content_3882_5744:()=>gXt,content_3882_5746:()=>MXt,content_3882_5748:()=>wXt,content_3882_5750:()=>xXt,content_3882_5752:()=>LXt,content_3882_5754:()=>kXt,content_3882_5756:()=>IXt,content_3882_5758:()=>SXt,content_3882_576:()=>Gpe,content_3882_5760:()=>EXt,content_3882_5762:()=>FXt,content_3882_5764:()=>jXt,content_3882_5766:()=>QXt,content_3882_5768:()=>JXt,content_3882_5770:()=>n_t,content_3882_5772:()=>p_t,content_3882_5774:()=>c_t,content_3882_5776:()=>l_t,content_3882_5778:()=>y_t,content_3882_578:()=>Upe,content_3882_5780:()=>g_t,content_3882_5782:()=>M_t,content_3882_5784:()=>w_t,content_3882_5786:()=>x_t,content_3882_5788:()=>L_t,content_3882_5790:()=>k_t,content_3882_5792:()=>I_t,content_3882_5794:()=>S_t,content_3882_5796:()=>E_t,content_3882_5798:()=>F_t,content_3882_58:()=>D0,content_3882_580:()=>qpe,content_3882_5800:()=>j_t,content_3882_5802:()=>Q_t,content_3882_5804:()=>J_t,content_3882_5806:()=>nwt,content_3882_5808:()=>pwt,content_3882_5810:()=>cwt,content_3882_5812:()=>lwt,content_3882_5814:()=>ywt,content_3882_5816:()=>gwt,content_3882_5818:()=>Mwt,content_3882_582:()=>Ype,content_3882_5820:()=>wwt,content_3882_5822:()=>xwt,content_3882_5824:()=>Lwt,content_3882_5826:()=>kwt,content_3882_5828:()=>Iwt,content_3882_5830:()=>Swt,content_3882_5832:()=>Ewt,content_3882_5834:()=>Fwt,content_3882_5836:()=>jwt,content_3882_5838:()=>Qwt,content_3882_584:()=>Kpe,content_3882_5840:()=>Jwt,content_3882_5842:()=>nTt,content_3882_5844:()=>pTt,content_3882_5846:()=>cTt,content_3882_5848:()=>lTt,content_3882_5850:()=>yTt,content_3882_5852:()=>gTt,content_3882_5854:()=>MTt,content_3882_5856:()=>wTt,content_3882_5858:()=>xTt,content_3882_586:()=>ere,content_3882_5860:()=>LTt,content_3882_5862:()=>kTt,content_3882_5864:()=>ITt,content_3882_5866:()=>STt,content_3882_5868:()=>ETt,content_3882_5870:()=>FTt,content_3882_5872:()=>jTt,content_3882_5874:()=>QTt,content_3882_5876:()=>JTt,content_3882_5878:()=>nCt,content_3882_588:()=>ore,content_3882_5880:()=>pCt,content_3882_5882:()=>cCt,content_3882_5884:()=>lCt,content_3882_5886:()=>yCt,content_3882_5888:()=>gCt,content_3882_5890:()=>MCt,content_3882_5892:()=>wCt,content_3882_5894:()=>xCt,content_3882_5896:()=>LCt,content_3882_5898:()=>kCt,content_3882_590:()=>sre,content_3882_5900:()=>ICt,content_3882_5902:()=>SCt,content_3882_5904:()=>ECt,content_3882_5906:()=>FCt,content_3882_5908:()=>jCt,content_3882_5910:()=>QCt,content_3882_5912:()=>JCt,content_3882_5914:()=>nxt,content_3882_5916:()=>pxt,content_3882_5918:()=>cxt,content_3882_592:()=>ire,content_3882_5920:()=>lxt,content_3882_5922:()=>yxt,content_3882_5924:()=>gxt,content_3882_5926:()=>Mxt,content_3882_5928:()=>wxt,content_3882_5930:()=>xxt,content_3882_5932:()=>Lxt,content_3882_5934:()=>kxt,content_3882_5936:()=>Ixt,content_3882_5938:()=>Sxt,content_3882_594:()=>mre,content_3882_5940:()=>Ext,content_3882_5942:()=>Fxt,content_3882_5944:()=>jxt,content_3882_5946:()=>Qxt,content_3882_5948:()=>Jxt,content_3882_5950:()=>nAt,content_3882_5952:()=>pAt,content_3882_5954:()=>cAt,content_3882_5956:()=>lAt,content_3882_5958:()=>yAt,content_3882_596:()=>hre,content_3882_5960:()=>gAt,content_3882_5962:()=>MAt,content_3882_5964:()=>wAt,content_3882_5966:()=>xAt,content_3882_5968:()=>LAt,content_3882_5970:()=>kAt,content_3882_5972:()=>IAt,content_3882_5974:()=>SAt,content_3882_5976:()=>EAt,content_3882_5978:()=>FAt,content_3882_598:()=>Dre,content_3882_5980:()=>jAt,content_3882_5982:()=>QAt,content_3882_5984:()=>JAt,content_3882_5986:()=>nvt,content_3882_5988:()=>pvt,content_3882_5990:()=>cvt,content_3882_5992:()=>lvt,content_3882_5994:()=>yvt,content_3882_5996:()=>gvt,content_3882_5998:()=>Mvt,content_3882_6:()=>YJ,content_3882_60:()=>_0,content_3882_600:()=>_re,content_3882_6000:()=>wvt,content_3882_6002:()=>xvt,content_3882_6004:()=>Lvt,content_3882_6006:()=>kvt,content_3882_6008:()=>Ivt,content_3882_6010:()=>Svt,content_3882_6012:()=>Evt,content_3882_6014:()=>Fvt,content_3882_6016:()=>jvt,content_3882_6018:()=>Qvt,content_3882_602:()=>Cre,content_3882_6020:()=>Jvt,content_3882_6022:()=>nLt,content_3882_6024:()=>pLt,content_3882_6026:()=>cLt,content_3882_6028:()=>lLt,content_3882_6030:()=>yLt,content_3882_6032:()=>gLt,content_3882_6034:()=>MLt,content_3882_6036:()=>wLt,content_3882_6038:()=>xLt,content_3882_604:()=>vre,content_3882_6040:()=>LLt,content_3882_6042:()=>kLt,content_3882_6044:()=>ILt,content_3882_6046:()=>SLt,content_3882_6048:()=>ELt,content_3882_6050:()=>FLt,content_3882_6052:()=>jLt,content_3882_6054:()=>QLt,content_3882_6056:()=>JLt,content_3882_6058:()=>nbt,content_3882_606:()=>Nre,content_3882_6060:()=>pbt,content_3882_6062:()=>cbt,content_3882_6064:()=>lbt,content_3882_6066:()=>ybt,content_3882_6068:()=>gbt,content_3882_6070:()=>Mbt,content_3882_6072:()=>wbt,content_3882_6074:()=>xbt,content_3882_6076:()=>Lbt,content_3882_6078:()=>kbt,content_3882_608:()=>Pre,content_3882_6080:()=>Ibt,content_3882_6082:()=>Sbt,content_3882_6084:()=>Ebt,content_3882_6086:()=>Fbt,content_3882_6088:()=>jbt,content_3882_6090:()=>Qbt,content_3882_6092:()=>Jbt,content_3882_6094:()=>nNt,content_3882_6096:()=>pNt,content_3882_6098:()=>cNt,content_3882_610:()=>Wre,content_3882_6100:()=>lNt,content_3882_6102:()=>yNt,content_3882_6104:()=>gNt,content_3882_6106:()=>MNt,content_3882_6108:()=>wNt,content_3882_6110:()=>xNt,content_3882_6112:()=>LNt,content_3882_6114:()=>kNt,content_3882_6116:()=>INt,content_3882_6118:()=>SNt,content_3882_612:()=>Gre,content_3882_6120:()=>ENt,content_3882_6122:()=>FNt,content_3882_6124:()=>jNt,content_3882_6126:()=>QNt,content_3882_6128:()=>JNt,content_3882_6130:()=>nkt,content_3882_6132:()=>pkt,content_3882_6134:()=>ckt,content_3882_6136:()=>lkt,content_3882_6138:()=>ykt,content_3882_614:()=>Ure,content_3882_6140:()=>gkt,content_3882_6142:()=>Mkt,content_3882_6144:()=>wkt,content_3882_6146:()=>xkt,content_3882_6148:()=>Lkt,content_3882_6150:()=>kkt,content_3882_6152:()=>Ikt,content_3882_6154:()=>Skt,content_3882_6156:()=>Ekt,content_3882_6158:()=>Fkt,content_3882_616:()=>qre,content_3882_6160:()=>jkt,content_3882_6162:()=>Qkt,content_3882_6164:()=>Jkt,content_3882_6166:()=>nzt,content_3882_6168:()=>pzt,content_3882_6170:()=>czt,content_3882_6172:()=>lzt,content_3882_6174:()=>yzt,content_3882_6176:()=>gzt,content_3882_6178:()=>Mzt,content_3882_618:()=>Yre,content_3882_6180:()=>wzt,content_3882_6182:()=>xzt,content_3882_6184:()=>Lzt,content_3882_6186:()=>kzt,content_3882_6188:()=>Izt,content_3882_6190:()=>Szt,content_3882_6192:()=>Ezt,content_3882_6194:()=>Fzt,content_3882_6196:()=>jzt,content_3882_6198:()=>Qzt,content_3882_62:()=>C0,content_3882_620:()=>Kre,content_3882_6200:()=>Jzt,content_3882_6202:()=>nPt,content_3882_6204:()=>pPt,content_3882_6206:()=>cPt,content_3882_6208:()=>lPt,content_3882_6210:()=>yPt,content_3882_6212:()=>gPt,content_3882_6214:()=>MPt,content_3882_6216:()=>wPt,content_3882_6218:()=>xPt,content_3882_622:()=>ese,content_3882_6220:()=>LPt,content_3882_6222:()=>kPt,content_3882_6224:()=>IPt,content_3882_6226:()=>SPt,content_3882_6228:()=>EPt,content_3882_6230:()=>FPt,content_3882_6232:()=>jPt,content_3882_6234:()=>QPt,content_3882_6236:()=>JPt,content_3882_6238:()=>nIt,content_3882_624:()=>ose,content_3882_6240:()=>pIt,content_3882_6242:()=>cIt,content_3882_6244:()=>lIt,content_3882_6246:()=>yIt,content_3882_6248:()=>gIt,content_3882_6250:()=>MIt,content_3882_6252:()=>wIt,content_3882_6254:()=>xIt,content_3882_6256:()=>LIt,content_3882_6258:()=>kIt,content_3882_626:()=>sse,content_3882_6260:()=>IIt,content_3882_6262:()=>SIt,content_3882_6264:()=>EIt,content_3882_6266:()=>FIt,content_3882_6268:()=>jIt,content_3882_6270:()=>QIt,content_3882_6272:()=>JIt,content_3882_6274:()=>nRt,content_3882_6276:()=>pRt,content_3882_6278:()=>cRt,content_3882_628:()=>ise,content_3882_6280:()=>lRt,content_3882_6282:()=>yRt,content_3882_6284:()=>gRt,content_3882_6286:()=>MRt,content_3882_6288:()=>wRt,content_3882_6290:()=>xRt,content_3882_6292:()=>LRt,content_3882_6294:()=>kRt,content_3882_6296:()=>IRt,content_3882_6298:()=>SRt,content_3882_630:()=>mse,content_3882_6300:()=>ERt,content_3882_6302:()=>FRt,content_3882_6304:()=>jRt,content_3882_6306:()=>QRt,content_3882_6308:()=>JRt,content_3882_6310:()=>nWt,content_3882_6312:()=>pWt,content_3882_6314:()=>cWt,content_3882_6316:()=>lWt,content_3882_6318:()=>yWt,content_3882_632:()=>hse,content_3882_6320:()=>gWt,content_3882_6322:()=>MWt,content_3882_6324:()=>wWt,content_3882_6326:()=>xWt,content_3882_6328:()=>LWt,content_3882_6330:()=>kWt,content_3882_6332:()=>IWt,content_3882_6334:()=>SWt,content_3882_6336:()=>EWt,content_3882_6338:()=>FWt,content_3882_634:()=>Dse,content_3882_6340:()=>jWt,content_3882_6342:()=>QWt,content_3882_6344:()=>JWt,content_3882_6346:()=>nSt,content_3882_6348:()=>pSt,content_3882_6350:()=>cSt,content_3882_6352:()=>lSt,content_3882_6354:()=>ySt,content_3882_6356:()=>gSt,content_3882_6358:()=>MSt,content_3882_636:()=>_se,content_3882_6360:()=>wSt,content_3882_6362:()=>xSt,content_3882_6364:()=>LSt,content_3882_6366:()=>kSt,content_3882_6368:()=>ISt,content_3882_6370:()=>SSt,content_3882_6372:()=>ESt,content_3882_6374:()=>FSt,content_3882_6376:()=>jSt,content_3882_6378:()=>QSt,content_3882_638:()=>Cse,content_3882_6380:()=>JSt,content_3882_6382:()=>nBt,content_3882_6384:()=>pBt,content_3882_6386:()=>cBt,content_3882_6388:()=>lBt,content_3882_6390:()=>yBt,content_3882_6392:()=>gBt,content_3882_6394:()=>MBt,content_3882_6396:()=>wBt,content_3882_6398:()=>xBt,content_3882_64:()=>v0,content_3882_640:()=>vse,content_3882_6400:()=>LBt,content_3882_6402:()=>kBt,content_3882_6404:()=>IBt,content_3882_6406:()=>SBt,content_3882_6408:()=>EBt,content_3882_6410:()=>FBt,content_3882_6412:()=>jBt,content_3882_6414:()=>QBt,content_3882_6416:()=>JBt,content_3882_6418:()=>nGt,content_3882_642:()=>Nse,content_3882_6420:()=>pGt,content_3882_6422:()=>cGt,content_3882_6424:()=>lGt,content_3882_6426:()=>yGt,content_3882_6428:()=>gGt,content_3882_6430:()=>MGt,content_3882_6432:()=>wGt,content_3882_6434:()=>xGt,content_3882_6436:()=>LGt,content_3882_6438:()=>kGt,content_3882_644:()=>Pse,content_3882_6440:()=>IGt,content_3882_6442:()=>SGt,content_3882_6444:()=>EGt,content_3882_6446:()=>FGt,content_3882_6448:()=>jGt,content_3882_6450:()=>QGt,content_3882_6452:()=>JGt,content_3882_6454:()=>nEt,content_3882_6456:()=>pEt,content_3882_6458:()=>cEt,content_3882_646:()=>Wse,content_3882_6460:()=>lEt,content_3882_6462:()=>yEt,content_3882_6464:()=>gEt,content_3882_6466:()=>MEt,content_3882_6468:()=>wEt,content_3882_6470:()=>xEt,content_3882_6472:()=>LEt,content_3882_6474:()=>kEt,content_3882_6476:()=>IEt,content_3882_6478:()=>SEt,content_3882_648:()=>Gse,content_3882_6480:()=>EEt,content_3882_6482:()=>FEt,content_3882_6484:()=>jEt,content_3882_6486:()=>QEt,content_3882_6488:()=>JEt,content_3882_6490:()=>nOt,content_3882_6492:()=>pOt,content_3882_6494:()=>cOt,content_3882_6496:()=>lOt,content_3882_6498:()=>yOt,content_3882_650:()=>Use,content_3882_6500:()=>gOt,content_3882_6502:()=>MOt,content_3882_6504:()=>wOt,content_3882_6506:()=>xOt,content_3882_6508:()=>LOt,content_3882_6510:()=>kOt,content_3882_6512:()=>IOt,content_3882_6514:()=>SOt,content_3882_6516:()=>EOt,content_3882_6518:()=>FOt,content_3882_652:()=>qse,content_3882_6520:()=>jOt,content_3882_6522:()=>QOt,content_3882_6524:()=>JOt,content_3882_6526:()=>nUt,content_3882_6528:()=>pUt,content_3882_6530:()=>cUt,content_3882_6532:()=>lUt,content_3882_6534:()=>yUt,content_3882_6536:()=>gUt,content_3882_6538:()=>MUt,content_3882_654:()=>Yse,content_3882_6540:()=>wUt,content_3882_6542:()=>xUt,content_3882_6544:()=>LUt,content_3882_6546:()=>kUt,content_3882_6548:()=>IUt,content_3882_6550:()=>SUt,content_3882_6552:()=>EUt,content_3882_6554:()=>FUt,content_3882_6556:()=>jUt,content_3882_6558:()=>QUt,content_3882_656:()=>Kse,content_3882_6560:()=>JUt,content_3882_6562:()=>nFt,content_3882_6564:()=>pFt,content_3882_6566:()=>cFt,content_3882_6568:()=>lFt,content_3882_6570:()=>yFt,content_3882_6572:()=>gFt,content_3882_6574:()=>MFt,content_3882_6576:()=>wFt,content_3882_6578:()=>xFt,content_3882_658:()=>ece,content_3882_6580:()=>LFt,content_3882_6582:()=>kFt,content_3882_6584:()=>IFt,content_3882_6586:()=>SFt,content_3882_6588:()=>EFt,content_3882_6590:()=>FFt,content_3882_6592:()=>jFt,content_3882_6594:()=>QFt,content_3882_6596:()=>JFt,content_3882_6598:()=>nVt,content_3882_66:()=>N0,content_3882_660:()=>oce,content_3882_6600:()=>pVt,content_3882_6602:()=>cVt,content_3882_6604:()=>lVt,content_3882_6606:()=>yVt,content_3882_6608:()=>gVt,content_3882_6610:()=>MVt,content_3882_6612:()=>wVt,content_3882_6614:()=>xVt,content_3882_6616:()=>LVt,content_3882_6618:()=>kVt,content_3882_662:()=>sce,content_3882_6620:()=>IVt,content_3882_6622:()=>SVt,content_3882_6624:()=>EVt,content_3882_6626:()=>FVt,content_3882_6628:()=>jVt,content_3882_6630:()=>QVt,content_3882_6632:()=>JVt,content_3882_6634:()=>nqt,content_3882_6636:()=>pqt,content_3882_6638:()=>cqt,content_3882_664:()=>ice,content_3882_6640:()=>lqt,content_3882_6642:()=>yqt,content_3882_6644:()=>gqt,content_3882_6646:()=>Mqt,content_3882_6648:()=>wqt,content_3882_6650:()=>xqt,content_3882_6652:()=>Lqt,content_3882_6654:()=>kqt,content_3882_6656:()=>Iqt,content_3882_6658:()=>Sqt,content_3882_666:()=>mce,content_3882_6660:()=>Eqt,content_3882_6662:()=>Fqt,content_3882_6664:()=>jqt,content_3882_6666:()=>Qqt,content_3882_6668:()=>Jqt,content_3882_6670:()=>njt,content_3882_6672:()=>pjt,content_3882_6674:()=>cjt,content_3882_6676:()=>ljt,content_3882_6678:()=>yjt,content_3882_668:()=>hce,content_3882_6680:()=>gjt,content_3882_6682:()=>Mjt,content_3882_6684:()=>wjt,content_3882_6686:()=>xjt,content_3882_6688:()=>Ljt,content_3882_6690:()=>kjt,content_3882_6692:()=>Ijt,content_3882_6694:()=>Sjt,content_3882_6696:()=>Ejt,content_3882_6698:()=>Fjt,content_3882_670:()=>Dce,content_3882_6700:()=>jjt,content_3882_6702:()=>Qjt,content_3882_6704:()=>Jjt,content_3882_6706:()=>nHt,content_3882_6708:()=>pHt,content_3882_6710:()=>cHt,content_3882_6712:()=>lHt,content_3882_6714:()=>yHt,content_3882_6716:()=>gHt,content_3882_6718:()=>MHt,content_3882_672:()=>_ce,content_3882_6720:()=>wHt,content_3882_6722:()=>xHt,content_3882_6724:()=>LHt,content_3882_6726:()=>kHt,content_3882_6728:()=>IHt,content_3882_6730:()=>SHt,content_3882_6732:()=>EHt,content_3882_6734:()=>FHt,content_3882_6736:()=>jHt,content_3882_6738:()=>QHt,content_3882_674:()=>Cce,content_3882_6740:()=>JHt,content_3882_6742:()=>nYt,content_3882_6744:()=>pYt,content_3882_6746:()=>cYt,content_3882_6748:()=>lYt,content_3882_6750:()=>yYt,content_3882_6752:()=>gYt,content_3882_6754:()=>MYt,content_3882_6756:()=>wYt,content_3882_6758:()=>xYt,content_3882_676:()=>vce,content_3882_6760:()=>LYt,content_3882_6762:()=>kYt,content_3882_6764:()=>IYt,content_3882_6766:()=>SYt,content_3882_6768:()=>EYt,content_3882_6770:()=>FYt,content_3882_6772:()=>jYt,content_3882_6774:()=>QYt,content_3882_6776:()=>JYt,content_3882_6778:()=>nQt,content_3882_678:()=>Nce,content_3882_6780:()=>pQt,content_3882_6782:()=>cQt,content_3882_6784:()=>lQt,content_3882_6786:()=>yQt,content_3882_6788:()=>gQt,content_3882_6790:()=>MQt,content_3882_6792:()=>wQt,content_3882_6794:()=>xQt,content_3882_6796:()=>LQt,content_3882_6798:()=>kQt,content_3882_68:()=>P0,content_3882_680:()=>Pce,content_3882_6800:()=>IQt,content_3882_6802:()=>SQt,content_3882_6804:()=>EQt,content_3882_6806:()=>FQt,content_3882_6808:()=>jQt,content_3882_6810:()=>QQt,content_3882_6812:()=>JQt,content_3882_6814:()=>n$t,content_3882_6816:()=>p$t,content_3882_6818:()=>c$t,content_3882_682:()=>Wce,content_3882_6820:()=>l$t,content_3882_6822:()=>y$t,content_3882_6824:()=>g$t,content_3882_6826:()=>M$t,content_3882_6828:()=>w$t,content_3882_6830:()=>x$t,content_3882_6832:()=>L$t,content_3882_6834:()=>k$t,content_3882_6836:()=>I$t,content_3882_6838:()=>S$t,content_3882_684:()=>Gce,content_3882_6840:()=>E$t,content_3882_6842:()=>F$t,content_3882_6844:()=>j$t,content_3882_6846:()=>Q$t,content_3882_6848:()=>J$t,content_3882_6850:()=>nKt,content_3882_6852:()=>pKt,content_3882_6854:()=>cKt,content_3882_6856:()=>lKt,content_3882_6858:()=>yKt,content_3882_686:()=>Uce,content_3882_6860:()=>gKt,content_3882_6862:()=>MKt,content_3882_6864:()=>wKt,content_3882_6866:()=>xKt,content_3882_6868:()=>LKt,content_3882_6870:()=>kKt,content_3882_6872:()=>IKt,content_3882_6874:()=>SKt,content_3882_6876:()=>EKt,content_3882_6878:()=>FKt,content_3882_688:()=>qce,content_3882_6880:()=>jKt,content_3882_6882:()=>QKt,content_3882_6884:()=>JKt,content_3882_6886:()=>nJt,content_3882_6888:()=>pJt,content_3882_6890:()=>cJt,content_3882_6892:()=>lJt,content_3882_6894:()=>yJt,content_3882_6896:()=>gJt,content_3882_6898:()=>MJt,content_3882_690:()=>Yce,content_3882_6900:()=>wJt,content_3882_6902:()=>xJt,content_3882_6904:()=>LJt,content_3882_6906:()=>kJt,content_3882_6908:()=>IJt,content_3882_6910:()=>SJt,content_3882_6912:()=>EJt,content_3882_6914:()=>FJt,content_3882_6916:()=>jJt,content_3882_6918:()=>QJt,content_3882_692:()=>Kce,content_3882_6920:()=>JJt,content_3882_6922:()=>nZt,content_3882_6924:()=>pZt,content_3882_6926:()=>cZt,content_3882_6928:()=>lZt,content_3882_6930:()=>yZt,content_3882_6932:()=>gZt,content_3882_6934:()=>MZt,content_3882_6936:()=>wZt,content_3882_6938:()=>xZt,content_3882_694:()=>eae,content_3882_6940:()=>LZt,content_3882_6942:()=>kZt,content_3882_6944:()=>IZt,content_3882_6946:()=>SZt,content_3882_6948:()=>EZt,content_3882_6950:()=>FZt,content_3882_6952:()=>jZt,content_3882_6954:()=>QZt,content_3882_6956:()=>JZt,content_3882_6958:()=>n0t,content_3882_696:()=>oae,content_3882_6960:()=>p0t,content_3882_6962:()=>c0t,content_3882_6964:()=>l0t,content_3882_6966:()=>y0t,content_3882_6968:()=>g0t,content_3882_6970:()=>M0t,content_3882_6972:()=>w0t,content_3882_6974:()=>x0t,content_3882_6976:()=>L0t,content_3882_6978:()=>k0t,content_3882_698:()=>sae,content_3882_6980:()=>I0t,content_3882_6982:()=>S0t,content_3882_6984:()=>E0t,content_3882_6986:()=>F0t,content_3882_6988:()=>j0t,content_3882_6990:()=>Q0t,content_3882_6992:()=>J0t,content_3882_6994:()=>n8t,content_3882_6996:()=>p8t,content_3882_6998:()=>c8t,content_3882_70:()=>W0,content_3882_700:()=>iae,content_3882_7000:()=>l8t,content_3882_7002:()=>y8t,content_3882_7004:()=>g8t,content_3882_7006:()=>M8t,content_3882_7008:()=>w8t,content_3882_7010:()=>x8t,content_3882_7012:()=>L8t,content_3882_7014:()=>k8t,content_3882_7016:()=>I8t,content_3882_7018:()=>S8t,content_3882_702:()=>mae,content_3882_7020:()=>E8t,content_3882_7022:()=>F8t,content_3882_7024:()=>j8t,content_3882_7026:()=>Q8t,content_3882_7028:()=>J8t,content_3882_7030:()=>n2t,content_3882_7032:()=>p2t,content_3882_7034:()=>c2t,content_3882_7036:()=>l2t,content_3882_7038:()=>y2t,content_3882_704:()=>hae,content_3882_7040:()=>g2t,content_3882_7042:()=>M2t,content_3882_7044:()=>w2t,content_3882_7046:()=>x2t,content_3882_7048:()=>L2t,content_3882_7050:()=>k2t,content_3882_7052:()=>I2t,content_3882_7054:()=>S2t,content_3882_7056:()=>E2t,content_3882_7058:()=>F2t,content_3882_706:()=>Dae,content_3882_7060:()=>j2t,content_3882_7062:()=>Q2t,content_3882_7064:()=>J2t,content_3882_7066:()=>n3t,content_3882_7068:()=>p3t,content_3882_7070:()=>c3t,content_3882_7072:()=>l3t,content_3882_7074:()=>y3t,content_3882_7076:()=>g3t,content_3882_7078:()=>M3t,content_3882_708:()=>_ae,content_3882_7080:()=>w3t,content_3882_7082:()=>x3t,content_3882_7084:()=>L3t,content_3882_7086:()=>k3t,content_3882_7088:()=>I3t,content_3882_7090:()=>S3t,content_3882_7092:()=>E3t,content_3882_7094:()=>F3t,content_3882_7096:()=>j3t,content_3882_7098:()=>Q3t,content_3882_710:()=>Cae,content_3882_7100:()=>J3t,content_3882_7102:()=>n1t,content_3882_7104:()=>p1t,content_3882_7106:()=>c1t,content_3882_7108:()=>l1t,content_3882_7110:()=>y1t,content_3882_7112:()=>g1t,content_3882_7114:()=>M1t,content_3882_7116:()=>w1t,content_3882_7118:()=>x1t,content_3882_712:()=>vae,content_3882_7120:()=>L1t,content_3882_7122:()=>k1t,content_3882_7124:()=>I1t,content_3882_7126:()=>S1t,content_3882_7128:()=>E1t,content_3882_7130:()=>F1t,content_3882_7132:()=>j1t,content_3882_7134:()=>Q1t,content_3882_7136:()=>J1t,content_3882_7138:()=>n4t,content_3882_714:()=>Nae,content_3882_7140:()=>p4t,content_3882_7142:()=>c4t,content_3882_7144:()=>l4t,content_3882_7146:()=>y4t,content_3882_7148:()=>g4t,content_3882_7150:()=>M4t,content_3882_7152:()=>w4t,content_3882_7154:()=>x4t,content_3882_7156:()=>L4t,content_3882_7158:()=>k4t,content_3882_716:()=>Pae,content_3882_7160:()=>I4t,content_3882_7162:()=>S4t,content_3882_7164:()=>E4t,content_3882_7166:()=>F4t,content_3882_7168:()=>j4t,content_3882_7170:()=>Q4t,content_3882_7172:()=>J4t,content_3882_7174:()=>n6t,content_3882_7176:()=>p6t,content_3882_7178:()=>c6t,content_3882_718:()=>Wae,content_3882_7180:()=>l6t,content_3882_7182:()=>y6t,content_3882_7184:()=>g6t,content_3882_7186:()=>M6t,content_3882_7188:()=>w6t,content_3882_7190:()=>x6t,content_3882_7192:()=>L6t,content_3882_7194:()=>k6t,content_3882_7196:()=>I6t,content_3882_7198:()=>S6t,content_3882_72:()=>G0,content_3882_720:()=>Gae,content_3882_7200:()=>E6t,content_3882_7202:()=>F6t,content_3882_7204:()=>j6t,content_3882_7206:()=>Q6t,content_3882_7208:()=>J6t,content_3882_7210:()=>n5t,content_3882_7212:()=>p5t,content_3882_7214:()=>c5t,content_3882_7216:()=>l5t,content_3882_7218:()=>y5t,content_3882_722:()=>Uae,content_3882_7220:()=>g5t,content_3882_7222:()=>M5t,content_3882_7224:()=>w5t,content_3882_7226:()=>x5t,content_3882_7228:()=>L5t,content_3882_7230:()=>k5t,content_3882_7232:()=>I5t,content_3882_7234:()=>S5t,content_3882_7236:()=>E5t,content_3882_7238:()=>F5t,content_3882_724:()=>qae,content_3882_7240:()=>j5t,content_3882_7242:()=>Q5t,content_3882_7244:()=>J5t,content_3882_7246:()=>n7t,content_3882_7248:()=>p7t,content_3882_7250:()=>c7t,content_3882_7252:()=>l7t,content_3882_7254:()=>y7t,content_3882_7256:()=>g7t,content_3882_7258:()=>M7t,content_3882_726:()=>Yae,content_3882_7260:()=>w7t,content_3882_7262:()=>x7t,content_3882_7264:()=>L7t,content_3882_7266:()=>k7t,content_3882_7268:()=>I7t,content_3882_7270:()=>S7t,content_3882_7272:()=>E7t,content_3882_7274:()=>F7t,content_3882_7276:()=>j7t,content_3882_7278:()=>Q7t,content_3882_728:()=>Kae,content_3882_7280:()=>J7t,content_3882_7282:()=>n9t,content_3882_7284:()=>p9t,content_3882_7286:()=>c9t,content_3882_7288:()=>l9t,content_3882_7290:()=>y9t,content_3882_7292:()=>g9t,content_3882_7294:()=>M9t,content_3882_7296:()=>w9t,content_3882_7298:()=>x9t,content_3882_730:()=>eie,content_3882_7300:()=>L9t,content_3882_7302:()=>k9t,content_3882_7304:()=>I9t,content_3882_7306:()=>S9t,content_3882_7308:()=>E9t,content_3882_7310:()=>F9t,content_3882_7312:()=>j9t,content_3882_7314:()=>Q9t,content_3882_7316:()=>J9t,content_3882_7318:()=>neo,content_3882_732:()=>oie,content_3882_7320:()=>peo,content_3882_7322:()=>ceo,content_3882_7324:()=>leo,content_3882_7326:()=>yeo,content_3882_7328:()=>geo,content_3882_7330:()=>Meo,content_3882_7332:()=>weo,content_3882_7334:()=>xeo,content_3882_7336:()=>Leo,content_3882_7338:()=>keo,content_3882_734:()=>sie,content_3882_7340:()=>Ieo,content_3882_7342:()=>Seo,content_3882_7344:()=>Eeo,content_3882_7346:()=>Feo,content_3882_7348:()=>jeo,content_3882_7350:()=>Qeo,content_3882_7352:()=>Jeo,content_3882_7354:()=>nno,content_3882_7356:()=>pno,content_3882_7358:()=>cno,content_3882_736:()=>iie,content_3882_7360:()=>lno,content_3882_7362:()=>yno,content_3882_7364:()=>gno,content_3882_7366:()=>Mno,content_3882_7368:()=>wno,content_3882_7370:()=>xno,content_3882_7372:()=>Lno,content_3882_7374:()=>kno,content_3882_7376:()=>Ino,content_3882_7378:()=>Sno,content_3882_738:()=>mie,content_3882_7380:()=>Eno,content_3882_7382:()=>Fno,content_3882_7384:()=>jno,content_3882_7386:()=>Qno,content_3882_7388:()=>Jno,content_3882_7390:()=>nto,content_3882_7392:()=>pto,content_3882_7394:()=>cto,content_3882_7396:()=>lto,content_3882_7398:()=>yto,content_3882_74:()=>U0,content_3882_740:()=>hie,content_3882_7400:()=>gto,content_3882_7402:()=>Mto,content_3882_7404:()=>wto,content_3882_7406:()=>xto,content_3882_7408:()=>Lto,content_3882_7410:()=>kto,content_3882_7412:()=>Ito,content_3882_7414:()=>Sto,content_3882_7416:()=>Eto,content_3882_7418:()=>Fto,content_3882_742:()=>Die,content_3882_7420:()=>jto,content_3882_7422:()=>Qto,content_3882_7424:()=>Jto,content_3882_7426:()=>noo,content_3882_7428:()=>poo,content_3882_7430:()=>coo,content_3882_7432:()=>loo,content_3882_7434:()=>yoo,content_3882_7436:()=>goo,content_3882_7438:()=>Moo,content_3882_744:()=>_ie,content_3882_7440:()=>woo,content_3882_7442:()=>xoo,content_3882_7444:()=>Loo,content_3882_7446:()=>koo,content_3882_7448:()=>Ioo,content_3882_7450:()=>Soo,content_3882_7452:()=>Eoo,content_3882_7454:()=>Foo,content_3882_7456:()=>joo,content_3882_7458:()=>Qoo,content_3882_746:()=>Cie,content_3882_7460:()=>Joo,content_3882_7462:()=>npo,content_3882_7464:()=>ppo,content_3882_7466:()=>cpo,content_3882_7468:()=>lpo,content_3882_7470:()=>ypo,content_3882_7472:()=>gpo,content_3882_7474:()=>Mpo,content_3882_7476:()=>wpo,content_3882_7478:()=>xpo,content_3882_748:()=>vie,content_3882_7480:()=>Lpo,content_3882_7482:()=>kpo,content_3882_7484:()=>Ipo,content_3882_7486:()=>Spo,content_3882_7488:()=>Epo,content_3882_7490:()=>Fpo,content_3882_7492:()=>jpo,content_3882_7494:()=>Qpo,content_3882_7496:()=>Jpo,content_3882_7498:()=>nro,content_3882_750:()=>Nie,content_3882_7500:()=>pro,content_3882_7502:()=>cro,content_3882_7504:()=>lro,content_3882_7506:()=>yro,content_3882_7508:()=>gro,content_3882_7510:()=>Mro,content_3882_7512:()=>wro,content_3882_7514:()=>xro,content_3882_7516:()=>Lro,content_3882_7518:()=>kro,content_3882_752:()=>Pie,content_3882_7520:()=>Iro,content_3882_7522:()=>Sro,content_3882_7524:()=>Ero,content_3882_7526:()=>Fro,content_3882_7528:()=>jro,content_3882_7530:()=>Qro,content_3882_7532:()=>Jro,content_3882_7534:()=>nso,content_3882_7536:()=>pso,content_3882_7538:()=>cso,content_3882_754:()=>Wie,content_3882_7540:()=>lso,content_3882_7542:()=>yso,content_3882_7544:()=>gso,content_3882_7546:()=>Mso,content_3882_7548:()=>wso,content_3882_7550:()=>xso,content_3882_7552:()=>Lso,content_3882_7554:()=>kso,content_3882_7556:()=>Iso,content_3882_7558:()=>Sso,content_3882_756:()=>Gie,content_3882_7560:()=>Eso,content_3882_7562:()=>Fso,content_3882_7564:()=>jso,content_3882_7566:()=>Qso,content_3882_7568:()=>Jso,content_3882_7570:()=>nco,content_3882_7572:()=>pco,content_3882_7574:()=>cco,content_3882_7576:()=>lco,content_3882_7578:()=>yco,content_3882_758:()=>Uie,content_3882_7580:()=>gco,content_3882_7582:()=>Mco,content_3882_7584:()=>wco,content_3882_7586:()=>xco,content_3882_7588:()=>Lco,content_3882_7590:()=>kco,content_3882_7592:()=>Ico,content_3882_7594:()=>Sco,content_3882_7596:()=>Eco,content_3882_7598:()=>Fco,content_3882_76:()=>q0,content_3882_760:()=>qie,content_3882_7600:()=>jco,content_3882_7602:()=>Qco,content_3882_7604:()=>Jco,content_3882_7606:()=>nao,content_3882_7608:()=>pao,content_3882_7610:()=>cao,content_3882_7612:()=>lao,content_3882_7614:()=>yao,content_3882_7616:()=>gao,content_3882_7618:()=>Mao,content_3882_762:()=>Yie,content_3882_7620:()=>wao,content_3882_7622:()=>xao,content_3882_7624:()=>Lao,content_3882_7626:()=>kao,content_3882_7628:()=>Iao,content_3882_7630:()=>Sao,content_3882_7632:()=>Eao,content_3882_7634:()=>Fao,content_3882_7636:()=>jao,content_3882_7638:()=>Qao,content_3882_764:()=>Kie,content_3882_7640:()=>Jao,content_3882_7642:()=>nio,content_3882_7644:()=>pio,content_3882_7646:()=>cio,content_3882_7648:()=>lio,content_3882_7650:()=>yio,content_3882_7652:()=>gio,content_3882_7654:()=>Mio,content_3882_7656:()=>wio,content_3882_7658:()=>xio,content_3882_766:()=>ele,content_3882_7660:()=>Lio,content_3882_7662:()=>kio,content_3882_7664:()=>Iio,content_3882_7666:()=>Sio,content_3882_7668:()=>Eio,content_3882_7670:()=>Fio,content_3882_7672:()=>jio,content_3882_7674:()=>Qio,content_3882_7676:()=>Jio,content_3882_7678:()=>nlo,content_3882_768:()=>ole,content_3882_7680:()=>plo,content_3882_7682:()=>clo,content_3882_7684:()=>llo,content_3882_7686:()=>ylo,content_3882_7688:()=>glo,content_3882_7690:()=>Mlo,content_3882_7692:()=>wlo,content_3882_7694:()=>xlo,content_3882_7696:()=>Llo,content_3882_7698:()=>klo,content_3882_770:()=>sle,content_3882_7700:()=>Ilo,content_3882_7702:()=>Slo,content_3882_7704:()=>Elo,content_3882_7706:()=>Flo,content_3882_7708:()=>jlo,content_3882_7710:()=>Qlo,content_3882_7712:()=>Jlo,content_3882_7714:()=>nuo,content_3882_7716:()=>puo,content_3882_7718:()=>cuo,content_3882_772:()=>ile,content_3882_7720:()=>luo,content_3882_7722:()=>yuo,content_3882_7724:()=>guo,content_3882_7726:()=>Muo,content_3882_7728:()=>wuo,content_3882_7730:()=>xuo,content_3882_7732:()=>Luo,content_3882_7734:()=>kuo,content_3882_7736:()=>Iuo,content_3882_7738:()=>Suo,content_3882_774:()=>mle,content_3882_7740:()=>Euo,content_3882_7742:()=>Fuo,content_3882_7744:()=>juo,content_3882_7746:()=>Quo,content_3882_7748:()=>Juo,content_3882_7750:()=>nmo,content_3882_7752:()=>pmo,content_3882_7754:()=>cmo,content_3882_7756:()=>lmo,content_3882_7758:()=>ymo,content_3882_776:()=>hle,content_3882_7760:()=>gmo,content_3882_7762:()=>Mmo,content_3882_7764:()=>wmo,content_3882_7766:()=>xmo,content_3882_7768:()=>Lmo,content_3882_7770:()=>kmo,content_3882_7772:()=>Imo,content_3882_7774:()=>Smo,content_3882_7776:()=>Emo,content_3882_7778:()=>Fmo,content_3882_778:()=>Dle,content_3882_7780:()=>jmo,content_3882_7782:()=>Qmo,content_3882_7784:()=>Jmo,content_3882_7786:()=>nyo,content_3882_7788:()=>pyo,content_3882_7790:()=>cyo,content_3882_7792:()=>lyo,content_3882_7794:()=>yyo,content_3882_7796:()=>gyo,content_3882_7798:()=>Myo,content_3882_78:()=>Y0,content_3882_780:()=>_le,content_3882_7800:()=>wyo,content_3882_7802:()=>xyo,content_3882_7804:()=>Lyo,content_3882_7806:()=>kyo,content_3882_7808:()=>Iyo,content_3882_7810:()=>Syo,content_3882_7812:()=>Eyo,content_3882_7814:()=>Fyo,content_3882_7816:()=>jyo,content_3882_7818:()=>Qyo,content_3882_782:()=>Cle,content_3882_7820:()=>Jyo,content_3882_7822:()=>ndo,content_3882_7824:()=>pdo,content_3882_7826:()=>cdo,content_3882_7828:()=>ldo,content_3882_7830:()=>ydo,content_3882_7832:()=>gdo,content_3882_7834:()=>Mdo,content_3882_7836:()=>wdo,content_3882_7838:()=>xdo,content_3882_784:()=>vle,content_3882_7840:()=>Ldo,content_3882_7842:()=>kdo,content_3882_7844:()=>Ido,content_3882_7846:()=>Sdo,content_3882_7848:()=>Edo,content_3882_7850:()=>Fdo,content_3882_7852:()=>jdo,content_3882_7854:()=>Qdo,content_3882_7856:()=>Jdo,content_3882_7858:()=>nho,content_3882_786:()=>Nle,content_3882_7860:()=>pho,content_3882_7862:()=>cho,content_3882_7864:()=>lho,content_3882_7866:()=>yho,content_3882_7868:()=>gho,content_3882_7870:()=>Mho,content_3882_7872:()=>who,content_3882_7874:()=>xho,content_3882_7876:()=>Lho,content_3882_7878:()=>kho,content_3882_788:()=>Ple,content_3882_7880:()=>Iho,content_3882_7882:()=>Sho,content_3882_7884:()=>Eho,content_3882_7886:()=>Fho,content_3882_7888:()=>jho,content_3882_7890:()=>Qho,content_3882_7892:()=>Jho,content_3882_7894:()=>ngo,content_3882_7896:()=>pgo,content_3882_7898:()=>cgo,content_3882_790:()=>Wle,content_3882_7900:()=>lgo,content_3882_7902:()=>ygo,content_3882_7904:()=>ggo,content_3882_7906:()=>Mgo,content_3882_7908:()=>wgo,content_3882_7910:()=>xgo,content_3882_7912:()=>Lgo,content_3882_7914:()=>kgo,content_3882_7916:()=>Igo,content_3882_7918:()=>Sgo,content_3882_792:()=>Gle,content_3882_7920:()=>Ego,content_3882_7922:()=>Fgo,content_3882_7924:()=>jgo,content_3882_7926:()=>Qgo,content_3882_7928:()=>Jgo,content_3882_7930:()=>nfo,content_3882_7932:()=>pfo,content_3882_7934:()=>cfo,content_3882_7936:()=>lfo,content_3882_7938:()=>yfo,content_3882_794:()=>Ule,content_3882_7940:()=>gfo,content_3882_7942:()=>Mfo,content_3882_7944:()=>wfo,content_3882_7946:()=>xfo,content_3882_7948:()=>Lfo,content_3882_7950:()=>kfo,content_3882_7952:()=>Ifo,content_3882_7954:()=>Sfo,content_3882_7956:()=>Efo,content_3882_7958:()=>Ffo,content_3882_796:()=>qle,content_3882_7960:()=>jfo,content_3882_7962:()=>Qfo,content_3882_7964:()=>Jfo,content_3882_7966:()=>nDo,content_3882_7968:()=>pDo,content_3882_7970:()=>cDo,content_3882_7972:()=>lDo,content_3882_7974:()=>yDo,content_3882_7976:()=>gDo,content_3882_7978:()=>MDo,content_3882_798:()=>Yle,content_3882_7980:()=>wDo,content_3882_7982:()=>xDo,content_3882_7984:()=>LDo,content_3882_7986:()=>kDo,content_3882_7988:()=>IDo,content_3882_7990:()=>SDo,content_3882_7992:()=>EDo,content_3882_7994:()=>FDo,content_3882_7996:()=>jDo,content_3882_7998:()=>QDo,content_3882_8:()=>KJ,content_3882_80:()=>K0,content_3882_800:()=>Kle,content_3882_8000:()=>JDo,content_3882_8002:()=>nMo,content_3882_8004:()=>pMo,content_3882_8006:()=>cMo,content_3882_8008:()=>lMo,content_3882_8010:()=>yMo,content_3882_8012:()=>gMo,content_3882_8014:()=>MMo,content_3882_8016:()=>wMo,content_3882_8018:()=>xMo,content_3882_802:()=>eue,content_3882_8020:()=>LMo,content_3882_8022:()=>kMo,content_3882_8024:()=>IMo,content_3882_8026:()=>SMo,content_3882_8028:()=>EMo,content_3882_8030:()=>FMo,content_3882_8032:()=>jMo,content_3882_8034:()=>QMo,content_3882_8036:()=>JMo,content_3882_8038:()=>nXo,content_3882_804:()=>oue,content_3882_8040:()=>pXo,content_3882_8042:()=>cXo,content_3882_8044:()=>lXo,content_3882_8046:()=>yXo,content_3882_8048:()=>gXo,content_3882_8050:()=>MXo,content_3882_8052:()=>wXo,content_3882_8054:()=>xXo,content_3882_8056:()=>LXo,content_3882_8058:()=>kXo,content_3882_806:()=>sue,content_3882_8060:()=>IXo,content_3882_8062:()=>SXo,content_3882_8064:()=>EXo,content_3882_8066:()=>FXo,content_3882_8068:()=>jXo,content_3882_8070:()=>QXo,content_3882_8072:()=>JXo,content_3882_8074:()=>n_o,content_3882_8076:()=>p_o,content_3882_8078:()=>c_o,content_3882_808:()=>iue,content_3882_8080:()=>l_o,content_3882_8082:()=>y_o,content_3882_8084:()=>g_o,content_3882_8086:()=>M_o,content_3882_8088:()=>w_o,content_3882_8090:()=>x_o,content_3882_8092:()=>L_o,content_3882_8094:()=>k_o,content_3882_8096:()=>I_o,content_3882_8098:()=>S_o,content_3882_810:()=>mue,content_3882_8100:()=>E_o,content_3882_8102:()=>F_o,content_3882_8104:()=>j_o,content_3882_8106:()=>Q_o,content_3882_8108:()=>J_o,content_3882_8110:()=>nwo,content_3882_8112:()=>pwo,content_3882_8114:()=>cwo,content_3882_8116:()=>lwo,content_3882_8118:()=>ywo,content_3882_812:()=>hue,content_3882_8120:()=>gwo,content_3882_8122:()=>Mwo,content_3882_8124:()=>wwo,content_3882_8126:()=>xwo,content_3882_8128:()=>Lwo,content_3882_8130:()=>kwo,content_3882_8132:()=>Iwo,content_3882_8134:()=>Swo,content_3882_8136:()=>Ewo,content_3882_8138:()=>Fwo,content_3882_814:()=>Due,content_3882_8140:()=>jwo,content_3882_8142:()=>Qwo,content_3882_8144:()=>Jwo,content_3882_8146:()=>nTo,content_3882_8148:()=>pTo,content_3882_8150:()=>cTo,content_3882_8152:()=>lTo,content_3882_8154:()=>yTo,content_3882_8156:()=>gTo,content_3882_8158:()=>MTo,content_3882_816:()=>_ue,content_3882_8160:()=>wTo,content_3882_8162:()=>xTo,content_3882_8164:()=>LTo,content_3882_8166:()=>kTo,content_3882_8168:()=>ITo,content_3882_8170:()=>STo,content_3882_8172:()=>ETo,content_3882_8174:()=>FTo,content_3882_8176:()=>jTo,content_3882_8178:()=>QTo,content_3882_818:()=>Cue,content_3882_8180:()=>JTo,content_3882_8182:()=>nCo,content_3882_8184:()=>pCo,content_3882_8186:()=>cCo,content_3882_8188:()=>lCo,content_3882_8190:()=>yCo,content_3882_8192:()=>gCo,content_3882_8194:()=>MCo,content_3882_8196:()=>wCo,content_3882_8198:()=>xCo,content_3882_82:()=>e8,content_3882_820:()=>vue,content_3882_8200:()=>LCo,content_3882_8202:()=>kCo,content_3882_8204:()=>ICo,content_3882_8206:()=>SCo,content_3882_8208:()=>ECo,content_3882_8210:()=>FCo,content_3882_8212:()=>jCo,content_3882_8214:()=>QCo,content_3882_8216:()=>JCo,content_3882_8218:()=>nxo,content_3882_822:()=>Nue,content_3882_8220:()=>pxo,content_3882_8222:()=>cxo,content_3882_8224:()=>lxo,content_3882_8226:()=>yxo,content_3882_8228:()=>gxo,content_3882_8230:()=>Mxo,content_3882_8232:()=>wxo,content_3882_8234:()=>xxo,content_3882_8236:()=>Lxo,content_3882_8238:()=>kxo,content_3882_824:()=>Pue,content_3882_8240:()=>Ixo,content_3882_8242:()=>Sxo,content_3882_8244:()=>Exo,content_3882_8246:()=>Fxo,content_3882_8248:()=>jxo,content_3882_8250:()=>Qxo,content_3882_8252:()=>Jxo,content_3882_8254:()=>nAo,content_3882_8256:()=>pAo,content_3882_8258:()=>cAo,content_3882_826:()=>Wue,content_3882_8260:()=>lAo,content_3882_8262:()=>yAo,content_3882_8264:()=>gAo,content_3882_8266:()=>MAo,content_3882_8268:()=>wAo,content_3882_8270:()=>xAo,content_3882_8272:()=>LAo,content_3882_8274:()=>kAo,content_3882_8276:()=>IAo,content_3882_8278:()=>SAo,content_3882_828:()=>Gue,content_3882_8280:()=>EAo,content_3882_8282:()=>FAo,content_3882_8284:()=>jAo,content_3882_8286:()=>QAo,content_3882_8288:()=>JAo,content_3882_8290:()=>nvo,content_3882_8292:()=>pvo,content_3882_8294:()=>cvo,content_3882_8296:()=>lvo,content_3882_8298:()=>yvo,content_3882_830:()=>Uue,content_3882_8300:()=>gvo,content_3882_8302:()=>Mvo,content_3882_8304:()=>wvo,content_3882_8306:()=>xvo,content_3882_8308:()=>Lvo,content_3882_8310:()=>kvo,content_3882_8312:()=>Ivo,content_3882_8314:()=>Svo,content_3882_8316:()=>Evo,content_3882_8318:()=>Fvo,content_3882_832:()=>que,content_3882_8320:()=>jvo,content_3882_8322:()=>Qvo,content_3882_8324:()=>Jvo,content_3882_8326:()=>nLo,content_3882_8328:()=>pLo,content_3882_8330:()=>cLo,content_3882_8332:()=>lLo,content_3882_8334:()=>yLo,content_3882_8336:()=>gLo,content_3882_8338:()=>MLo,content_3882_834:()=>Yue,content_3882_8340:()=>wLo,content_3882_8342:()=>xLo,content_3882_8344:()=>LLo,content_3882_8346:()=>kLo,content_3882_8348:()=>ILo,content_3882_8350:()=>SLo,content_3882_8352:()=>ELo,content_3882_8354:()=>FLo,content_3882_8356:()=>jLo,content_3882_8358:()=>QLo,content_3882_836:()=>Kue,content_3882_8360:()=>JLo,content_3882_8362:()=>nbo,content_3882_8364:()=>pbo,content_3882_8366:()=>cbo,content_3882_8368:()=>lbo,content_3882_8370:()=>ybo,content_3882_8372:()=>gbo,content_3882_8374:()=>Mbo,content_3882_8376:()=>wbo,content_3882_8378:()=>xbo,content_3882_838:()=>eme,content_3882_8380:()=>Lbo,content_3882_8382:()=>kbo,content_3882_8384:()=>Ibo,content_3882_8386:()=>Sbo,content_3882_8388:()=>Ebo,content_3882_8390:()=>Fbo,content_3882_8392:()=>jbo,content_3882_8394:()=>Qbo,content_3882_8396:()=>Jbo,content_3882_8398:()=>nNo,content_3882_84:()=>o8,content_3882_840:()=>ome,content_3882_8400:()=>pNo,content_3882_8402:()=>cNo,content_3882_8404:()=>lNo,content_3882_8406:()=>yNo,content_3882_8408:()=>gNo,content_3882_8410:()=>MNo,content_3882_8412:()=>wNo,content_3882_8414:()=>xNo,content_3882_8416:()=>LNo,content_3882_8418:()=>kNo,content_3882_842:()=>sme,content_3882_8420:()=>INo,content_3882_8422:()=>SNo,content_3882_8424:()=>ENo,content_3882_8426:()=>FNo,content_3882_8428:()=>jNo,content_3882_8430:()=>QNo,content_3882_8432:()=>JNo,content_3882_8434:()=>nko,content_3882_8436:()=>pko,content_3882_8438:()=>cko,content_3882_844:()=>ime,content_3882_8440:()=>lko,content_3882_8442:()=>yko,content_3882_8444:()=>gko,content_3882_8446:()=>Mko,content_3882_8448:()=>wko,content_3882_8450:()=>xko,content_3882_8452:()=>Lko,content_3882_8454:()=>kko,content_3882_8456:()=>Iko,content_3882_8458:()=>Sko,content_3882_846:()=>mme,content_3882_8460:()=>Eko,content_3882_8462:()=>Fko,content_3882_8464:()=>jko,content_3882_8466:()=>Qko,content_3882_8468:()=>Jko,content_3882_8470:()=>nzo,content_3882_8472:()=>pzo,content_3882_8474:()=>czo,content_3882_8476:()=>lzo,content_3882_8478:()=>yzo,content_3882_848:()=>hme,content_3882_8480:()=>gzo,content_3882_8482:()=>Mzo,content_3882_8484:()=>wzo,content_3882_8486:()=>xzo,content_3882_8488:()=>Lzo,content_3882_8490:()=>kzo,content_3882_8492:()=>Izo,content_3882_8494:()=>Szo,content_3882_8496:()=>Ezo,content_3882_8498:()=>Fzo,content_3882_850:()=>Dme,content_3882_8500:()=>jzo,content_3882_8502:()=>Qzo,content_3882_8504:()=>Jzo,content_3882_8506:()=>nPo,content_3882_8508:()=>pPo,content_3882_8510:()=>cPo,content_3882_8512:()=>lPo,content_3882_8514:()=>yPo,content_3882_8516:()=>gPo,content_3882_8518:()=>MPo,content_3882_852:()=>_me,content_3882_8520:()=>wPo,content_3882_8522:()=>xPo,content_3882_8524:()=>LPo,content_3882_8526:()=>kPo,content_3882_8528:()=>IPo,content_3882_8530:()=>SPo,content_3882_8532:()=>EPo,content_3882_8534:()=>FPo,content_3882_8536:()=>jPo,content_3882_8538:()=>QPo,content_3882_854:()=>Cme,content_3882_8540:()=>JPo,content_3882_8542:()=>nIo,content_3882_8544:()=>pIo,content_3882_8546:()=>cIo,content_3882_8548:()=>lIo,content_3882_8550:()=>yIo,content_3882_8552:()=>gIo,content_3882_8554:()=>MIo,content_3882_8556:()=>wIo,content_3882_8558:()=>xIo,content_3882_856:()=>vme,content_3882_8560:()=>LIo,content_3882_8562:()=>kIo,content_3882_8564:()=>IIo,content_3882_8566:()=>SIo,content_3882_8568:()=>EIo,content_3882_8570:()=>FIo,content_3882_8572:()=>jIo,content_3882_8574:()=>QIo,content_3882_8576:()=>JIo,content_3882_8578:()=>nRo,content_3882_858:()=>Nme,content_3882_8580:()=>pRo,content_3882_8582:()=>cRo,content_3882_8584:()=>lRo,content_3882_8586:()=>yRo,content_3882_8588:()=>gRo,content_3882_8590:()=>MRo,content_3882_8592:()=>wRo,content_3882_8594:()=>xRo,content_3882_8596:()=>LRo,content_3882_8598:()=>kRo,content_3882_86:()=>s8,content_3882_860:()=>Pme,content_3882_8600:()=>IRo,content_3882_8602:()=>SRo,content_3882_8604:()=>ERo,content_3882_8606:()=>FRo,content_3882_8608:()=>jRo,content_3882_8610:()=>QRo,content_3882_8612:()=>JRo,content_3882_8614:()=>nWo,content_3882_8616:()=>pWo,content_3882_8618:()=>cWo,content_3882_862:()=>Wme,content_3882_8620:()=>lWo,content_3882_8622:()=>yWo,content_3882_8624:()=>gWo,content_3882_8626:()=>MWo,content_3882_8628:()=>wWo,content_3882_8630:()=>xWo,content_3882_8632:()=>LWo,content_3882_8634:()=>kWo,content_3882_8636:()=>IWo,content_3882_8638:()=>SWo,content_3882_864:()=>Gme,content_3882_8640:()=>EWo,content_3882_8642:()=>FWo,content_3882_8644:()=>jWo,content_3882_8646:()=>QWo,content_3882_8648:()=>JWo,content_3882_8650:()=>nSo,content_3882_8652:()=>pSo,content_3882_8654:()=>cSo,content_3882_8656:()=>lSo,content_3882_8658:()=>ySo,content_3882_866:()=>Ume,content_3882_8660:()=>gSo,content_3882_8662:()=>MSo,content_3882_8664:()=>wSo,content_3882_8666:()=>xSo,content_3882_8668:()=>LSo,content_3882_8670:()=>kSo,content_3882_8672:()=>ISo,content_3882_8674:()=>SSo,content_3882_8676:()=>ESo,content_3882_8678:()=>FSo,content_3882_868:()=>qme,content_3882_8680:()=>jSo,content_3882_8682:()=>QSo,content_3882_8684:()=>JSo,content_3882_8686:()=>nBo,content_3882_8688:()=>pBo,content_3882_8690:()=>cBo,content_3882_8692:()=>lBo,content_3882_8694:()=>yBo,content_3882_8696:()=>gBo,content_3882_8698:()=>MBo,content_3882_870:()=>Yme,content_3882_8700:()=>wBo,content_3882_8702:()=>xBo,content_3882_8704:()=>LBo,content_3882_8706:()=>kBo,content_3882_8708:()=>IBo,content_3882_8710:()=>SBo,content_3882_8712:()=>EBo,content_3882_8714:()=>FBo,content_3882_8716:()=>jBo,content_3882_8718:()=>QBo,content_3882_872:()=>Kme,content_3882_8720:()=>JBo,content_3882_8722:()=>nGo,content_3882_8724:()=>pGo,content_3882_8726:()=>cGo,content_3882_8728:()=>lGo,content_3882_8730:()=>yGo,content_3882_8732:()=>gGo,content_3882_8734:()=>MGo,content_3882_8736:()=>wGo,content_3882_8738:()=>xGo,content_3882_874:()=>eye,content_3882_8740:()=>LGo,content_3882_8742:()=>kGo,content_3882_8744:()=>IGo,content_3882_8746:()=>SGo,content_3882_8748:()=>EGo,content_3882_8750:()=>FGo,content_3882_8752:()=>jGo,content_3882_8754:()=>QGo,content_3882_8756:()=>JGo,content_3882_8758:()=>nEo,content_3882_876:()=>oye,content_3882_8760:()=>pEo,content_3882_8762:()=>cEo,content_3882_8764:()=>lEo,content_3882_8766:()=>yEo,content_3882_8768:()=>gEo,content_3882_8770:()=>MEo,content_3882_8772:()=>wEo,content_3882_8774:()=>xEo,content_3882_8776:()=>LEo,content_3882_8778:()=>kEo,content_3882_878:()=>sye,content_3882_8780:()=>IEo,content_3882_8782:()=>SEo,content_3882_8784:()=>EEo,content_3882_8786:()=>FEo,content_3882_8788:()=>jEo,content_3882_8790:()=>QEo,content_3882_8792:()=>JEo,content_3882_8794:()=>nOo,content_3882_8796:()=>pOo,content_3882_8798:()=>cOo,content_3882_88:()=>i8,content_3882_880:()=>iye,content_3882_8800:()=>lOo,content_3882_8802:()=>yOo,content_3882_8804:()=>gOo,content_3882_8806:()=>MOo,content_3882_8808:()=>wOo,content_3882_8810:()=>xOo,content_3882_8812:()=>LOo,content_3882_8814:()=>kOo,content_3882_8816:()=>IOo,content_3882_8818:()=>SOo,content_3882_882:()=>mye,content_3882_8820:()=>EOo,content_3882_8822:()=>FOo,content_3882_8824:()=>jOo,content_3882_8826:()=>QOo,content_3882_8828:()=>JOo,content_3882_8830:()=>nUo,content_3882_8832:()=>pUo,content_3882_8834:()=>cUo,content_3882_8836:()=>lUo,content_3882_8838:()=>yUo,content_3882_884:()=>hye,content_3882_8840:()=>gUo,content_3882_8842:()=>MUo,content_3882_8844:()=>wUo,content_3882_8846:()=>xUo,content_3882_8848:()=>LUo,content_3882_8850:()=>kUo,content_3882_8852:()=>IUo,content_3882_8854:()=>SUo,content_3882_8856:()=>EUo,content_3882_8858:()=>FUo,content_3882_886:()=>Dye,content_3882_8860:()=>jUo,content_3882_8862:()=>QUo,content_3882_8864:()=>JUo,content_3882_8866:()=>nFo,content_3882_8868:()=>pFo,content_3882_8870:()=>cFo,content_3882_8872:()=>lFo,content_3882_8874:()=>yFo,content_3882_8876:()=>gFo,content_3882_8878:()=>MFo,content_3882_888:()=>_ye,content_3882_8880:()=>wFo,content_3882_8882:()=>xFo,content_3882_8884:()=>LFo,content_3882_8886:()=>kFo,content_3882_8888:()=>IFo,content_3882_8890:()=>SFo,content_3882_8892:()=>EFo,content_3882_8894:()=>FFo,content_3882_8896:()=>jFo,content_3882_8898:()=>QFo,content_3882_890:()=>Cye,content_3882_8900:()=>JFo,content_3882_8902:()=>nVo,content_3882_8904:()=>pVo,content_3882_8906:()=>cVo,content_3882_8908:()=>lVo,content_3882_8910:()=>yVo,content_3882_8912:()=>gVo,content_3882_8914:()=>MVo,content_3882_8916:()=>wVo,content_3882_8918:()=>xVo,content_3882_892:()=>vye,content_3882_8920:()=>LVo,content_3882_8922:()=>kVo,content_3882_8924:()=>IVo,content_3882_8926:()=>SVo,content_3882_8928:()=>EVo,content_3882_8930:()=>FVo,content_3882_8932:()=>jVo,content_3882_8934:()=>QVo,content_3882_8936:()=>JVo,content_3882_8938:()=>nqo,content_3882_894:()=>Nye,content_3882_8940:()=>pqo,content_3882_8942:()=>cqo,content_3882_8944:()=>lqo,content_3882_8946:()=>yqo,content_3882_8948:()=>gqo,content_3882_8950:()=>Mqo,content_3882_8952:()=>wqo,content_3882_8954:()=>xqo,content_3882_8956:()=>Lqo,content_3882_8958:()=>kqo,content_3882_896:()=>Pye,content_3882_8960:()=>Iqo,content_3882_8962:()=>Sqo,content_3882_8964:()=>Eqo,content_3882_8966:()=>Fqo,content_3882_8968:()=>jqo,content_3882_8970:()=>Qqo,content_3882_8972:()=>Jqo,content_3882_8974:()=>njo,content_3882_8976:()=>pjo,content_3882_8978:()=>cjo,content_3882_898:()=>Wye,content_3882_8980:()=>ljo,content_3882_8982:()=>yjo,content_3882_8984:()=>gjo,content_3882_8986:()=>Mjo,content_3882_8988:()=>wjo,content_3882_8990:()=>xjo,content_3882_8992:()=>Ljo,content_3882_8994:()=>kjo,content_3882_8996:()=>Ijo,content_3882_8998:()=>Sjo,content_3882_90:()=>m8,content_3882_900:()=>Gye,content_3882_9000:()=>Ejo,content_3882_9002:()=>Fjo,content_3882_9004:()=>jjo,content_3882_9006:()=>Qjo,content_3882_9008:()=>Jjo,content_3882_9010:()=>nHo,content_3882_9012:()=>pHo,content_3882_9014:()=>cHo,content_3882_9016:()=>lHo,content_3882_9018:()=>yHo,content_3882_902:()=>Uye,content_3882_9020:()=>gHo,content_3882_9022:()=>MHo,content_3882_9024:()=>wHo,content_3882_9026:()=>xHo,content_3882_9028:()=>LHo,content_3882_9030:()=>kHo,content_3882_9032:()=>IHo,content_3882_9034:()=>SHo,content_3882_9036:()=>EHo,content_3882_9038:()=>FHo,content_3882_904:()=>qye,content_3882_9040:()=>jHo,content_3882_9042:()=>QHo,content_3882_9044:()=>JHo,content_3882_9046:()=>nYo,content_3882_9048:()=>pYo,content_3882_9050:()=>cYo,content_3882_9052:()=>lYo,content_3882_9054:()=>yYo,content_3882_9056:()=>gYo,content_3882_9058:()=>MYo,content_3882_906:()=>Yye,content_3882_9060:()=>wYo,content_3882_9062:()=>xYo,content_3882_9064:()=>LYo,content_3882_9066:()=>kYo,content_3882_9068:()=>IYo,content_3882_9070:()=>SYo,content_3882_9072:()=>EYo,content_3882_9074:()=>FYo,content_3882_9076:()=>jYo,content_3882_9078:()=>QYo,content_3882_908:()=>Kye,content_3882_9080:()=>JYo,content_3882_9082:()=>nQo,content_3882_9084:()=>pQo,content_3882_9086:()=>cQo,content_3882_9088:()=>lQo,content_3882_9090:()=>yQo,content_3882_9092:()=>gQo,content_3882_9094:()=>MQo,content_3882_9096:()=>wQo,content_3882_9098:()=>xQo,content_3882_910:()=>ede,content_3882_9100:()=>LQo,content_3882_9102:()=>kQo,content_3882_9104:()=>IQo,content_3882_9106:()=>SQo,content_3882_9108:()=>EQo,content_3882_9110:()=>FQo,content_3882_9112:()=>jQo,content_3882_9114:()=>QQo,content_3882_9116:()=>JQo,content_3882_9118:()=>n$o,content_3882_912:()=>ode,content_3882_9120:()=>p$o,content_3882_9122:()=>c$o,content_3882_9124:()=>l$o,content_3882_9126:()=>y$o,content_3882_9128:()=>g$o,content_3882_9130:()=>M$o,content_3882_9132:()=>w$o,content_3882_9134:()=>x$o,content_3882_9136:()=>L$o,content_3882_9138:()=>k$o,content_3882_914:()=>sde,content_3882_9140:()=>I$o,content_3882_9142:()=>S$o,content_3882_9144:()=>E$o,content_3882_9146:()=>F$o,content_3882_9148:()=>j$o,content_3882_9150:()=>Q$o,content_3882_9152:()=>J$o,content_3882_9154:()=>nKo,content_3882_9156:()=>pKo,content_3882_9158:()=>cKo,content_3882_916:()=>ide,content_3882_9160:()=>lKo,content_3882_9162:()=>yKo,content_3882_9164:()=>gKo,content_3882_9166:()=>MKo,content_3882_9168:()=>wKo,content_3882_9170:()=>xKo,content_3882_9172:()=>LKo,content_3882_9174:()=>kKo,content_3882_9176:()=>IKo,content_3882_9178:()=>SKo,content_3882_918:()=>mde,content_3882_9180:()=>EKo,content_3882_9182:()=>FKo,content_3882_9184:()=>jKo,content_3882_9186:()=>QKo,content_3882_9188:()=>JKo,content_3882_9190:()=>nJo,content_3882_9192:()=>pJo,content_3882_9194:()=>cJo,content_3882_9196:()=>lJo,content_3882_9198:()=>yJo,content_3882_92:()=>h8,content_3882_920:()=>hde,content_3882_9200:()=>gJo,content_3882_9202:()=>MJo,content_3882_9204:()=>wJo,content_3882_9206:()=>xJo,content_3882_9208:()=>LJo,content_3882_9210:()=>kJo,content_3882_9212:()=>IJo,content_3882_9214:()=>SJo,content_3882_9216:()=>EJo,content_3882_9218:()=>FJo,content_3882_922:()=>Dde,content_3882_9220:()=>jJo,content_3882_9222:()=>QJo,content_3882_9224:()=>JJo,content_3882_9226:()=>nZo,content_3882_9228:()=>pZo,content_3882_9230:()=>cZo,content_3882_9232:()=>lZo,content_3882_9234:()=>yZo,content_3882_9236:()=>gZo,content_3882_9238:()=>MZo,content_3882_924:()=>_de,content_3882_9240:()=>wZo,content_3882_9242:()=>xZo,content_3882_9244:()=>LZo,content_3882_9246:()=>kZo,content_3882_9248:()=>IZo,content_3882_9250:()=>SZo,content_3882_9252:()=>EZo,content_3882_9254:()=>FZo,content_3882_9256:()=>jZo,content_3882_9258:()=>QZo,content_3882_926:()=>Cde,content_3882_9260:()=>JZo,content_3882_9262:()=>n0o,content_3882_9264:()=>p0o,content_3882_9266:()=>c0o,content_3882_9268:()=>l0o,content_3882_9270:()=>y0o,content_3882_9272:()=>g0o,content_3882_9274:()=>M0o,content_3882_9276:()=>w0o,content_3882_9278:()=>x0o,content_3882_928:()=>vde,content_3882_9280:()=>L0o,content_3882_9282:()=>k0o,content_3882_9284:()=>I0o,content_3882_9286:()=>S0o,content_3882_9288:()=>E0o,content_3882_9290:()=>F0o,content_3882_9292:()=>j0o,content_3882_9294:()=>Q0o,content_3882_9296:()=>J0o,content_3882_9298:()=>n8o,content_3882_930:()=>Nde,content_3882_9300:()=>p8o,content_3882_9302:()=>c8o,content_3882_9304:()=>l8o,content_3882_9306:()=>y8o,content_3882_9308:()=>g8o,content_3882_9310:()=>M8o,content_3882_9312:()=>w8o,content_3882_9314:()=>x8o,content_3882_9316:()=>L8o,content_3882_9318:()=>k8o,content_3882_932:()=>Pde,content_3882_9320:()=>I8o,content_3882_9322:()=>S8o,content_3882_9324:()=>E8o,content_3882_9326:()=>F8o,content_3882_9328:()=>j8o,content_3882_9330:()=>Q8o,content_3882_9332:()=>J8o,content_3882_9334:()=>n2o,content_3882_9336:()=>p2o,content_3882_9338:()=>c2o,content_3882_934:()=>Wde,content_3882_9340:()=>l2o,content_3882_9342:()=>y2o,content_3882_9344:()=>g2o,content_3882_9346:()=>M2o,content_3882_9348:()=>w2o,content_3882_9350:()=>x2o,content_3882_9352:()=>L2o,content_3882_9354:()=>k2o,content_3882_9356:()=>I2o,content_3882_9358:()=>S2o,content_3882_936:()=>Gde,content_3882_9360:()=>E2o,content_3882_9362:()=>F2o,content_3882_9364:()=>j2o,content_3882_9366:()=>Q2o,content_3882_9368:()=>J2o,content_3882_9370:()=>n3o,content_3882_9372:()=>p3o,content_3882_9374:()=>c3o,content_3882_9376:()=>l3o,content_3882_9378:()=>y3o,content_3882_938:()=>Ude,content_3882_9380:()=>g3o,content_3882_9382:()=>M3o,content_3882_9384:()=>w3o,content_3882_9386:()=>x3o,content_3882_9388:()=>L3o,content_3882_9390:()=>k3o,content_3882_9392:()=>I3o,content_3882_9394:()=>S3o,content_3882_9396:()=>E3o,content_3882_9398:()=>F3o,content_3882_94:()=>D8,content_3882_940:()=>qde,content_3882_9400:()=>j3o,content_3882_9402:()=>Q3o,content_3882_9404:()=>J3o,content_3882_9406:()=>n1o,content_3882_9408:()=>p1o,content_3882_9410:()=>c1o,content_3882_9412:()=>l1o,content_3882_9414:()=>y1o,content_3882_9416:()=>g1o,content_3882_9418:()=>M1o,content_3882_942:()=>Yde,content_3882_9420:()=>w1o,content_3882_9422:()=>x1o,content_3882_9424:()=>L1o,content_3882_9426:()=>k1o,content_3882_9428:()=>I1o,content_3882_9430:()=>S1o,content_3882_9432:()=>E1o,content_3882_9434:()=>F1o,content_3882_9436:()=>j1o,content_3882_9438:()=>Q1o,content_3882_944:()=>Kde,content_3882_9440:()=>J1o,content_3882_9442:()=>n4o,content_3882_9444:()=>p4o,content_3882_9446:()=>c4o,content_3882_9448:()=>l4o,content_3882_9450:()=>y4o,content_3882_9452:()=>g4o,content_3882_9454:()=>M4o,content_3882_9456:()=>w4o,content_3882_9458:()=>x4o,content_3882_946:()=>ehe,content_3882_9460:()=>L4o,content_3882_9462:()=>k4o,content_3882_9464:()=>I4o,content_3882_9466:()=>S4o,content_3882_9468:()=>E4o,content_3882_9470:()=>F4o,content_3882_9472:()=>j4o,content_3882_9474:()=>Q4o,content_3882_9476:()=>J4o,content_3882_9478:()=>n6o,content_3882_948:()=>ohe,content_3882_9480:()=>p6o,content_3882_9482:()=>c6o,content_3882_9484:()=>l6o,content_3882_9486:()=>y6o,content_3882_9488:()=>g6o,content_3882_9490:()=>M6o,content_3882_9492:()=>w6o,content_3882_9494:()=>x6o,content_3882_9496:()=>L6o,content_3882_9498:()=>k6o,content_3882_950:()=>she,content_3882_9500:()=>I6o,content_3882_9502:()=>S6o,content_3882_9504:()=>E6o,content_3882_9506:()=>F6o,content_3882_9508:()=>j6o,content_3882_9510:()=>Q6o,content_3882_9512:()=>J6o,content_3882_9514:()=>n5o,content_3882_9516:()=>p5o,content_3882_9518:()=>c5o,content_3882_952:()=>ihe,content_3882_9520:()=>l5o,content_3882_9522:()=>y5o,content_3882_9524:()=>g5o,content_3882_9526:()=>M5o,content_3882_9528:()=>w5o,content_3882_9530:()=>x5o,content_3882_9532:()=>L5o,content_3882_9534:()=>k5o,content_3882_9536:()=>I5o,content_3882_9538:()=>S5o,content_3882_954:()=>mhe,content_3882_9540:()=>E5o,content_3882_9542:()=>F5o,content_3882_9544:()=>j5o,content_3882_9546:()=>Q5o,content_3882_9548:()=>J5o,content_3882_9550:()=>n7o,content_3882_9552:()=>p7o,content_3882_9554:()=>c7o,content_3882_9556:()=>l7o,content_3882_9558:()=>y7o,content_3882_956:()=>hhe,content_3882_9560:()=>g7o,content_3882_9562:()=>M7o,content_3882_9564:()=>w7o,content_3882_9566:()=>x7o,content_3882_9568:()=>L7o,content_3882_9570:()=>k7o,content_3882_9572:()=>I7o,content_3882_9574:()=>S7o,content_3882_9576:()=>E7o,content_3882_9578:()=>F7o,content_3882_958:()=>Dhe,content_3882_9580:()=>j7o,content_3882_9582:()=>Q7o,content_3882_9584:()=>J7o,content_3882_9586:()=>n9o,content_3882_9588:()=>p9o,content_3882_9590:()=>c9o,content_3882_9592:()=>l9o,content_3882_9594:()=>y9o,content_3882_9596:()=>g9o,content_3882_9598:()=>M9o,content_3882_96:()=>_8,content_3882_960:()=>_he,content_3882_9600:()=>w9o,content_3882_9602:()=>x9o,content_3882_9604:()=>L9o,content_3882_9606:()=>k9o,content_3882_9608:()=>I9o,content_3882_9610:()=>S9o,content_3882_9612:()=>E9o,content_3882_9614:()=>F9o,content_3882_9616:()=>j9o,content_3882_9618:()=>Q9o,content_3882_962:()=>Che,content_3882_9620:()=>J9o,content_3882_9622:()=>nep,content_3882_9624:()=>pep,content_3882_9626:()=>cep,content_3882_9628:()=>lep,content_3882_9630:()=>yep,content_3882_9632:()=>gep,content_3882_9634:()=>Mep,content_3882_9636:()=>wep,content_3882_9638:()=>xep,content_3882_964:()=>vhe,content_3882_9640:()=>Lep,content_3882_9642:()=>kep,content_3882_9644:()=>Iep,content_3882_9646:()=>Sep,content_3882_9648:()=>Eep,content_3882_9650:()=>Fep,content_3882_9652:()=>jep,content_3882_9654:()=>Qep,content_3882_9656:()=>Jep,content_3882_9658:()=>nnp,content_3882_966:()=>Nhe,content_3882_9660:()=>pnp,content_3882_9662:()=>cnp,content_3882_9664:()=>lnp,content_3882_9666:()=>ynp,content_3882_9668:()=>gnp,content_3882_9670:()=>Mnp,content_3882_9672:()=>wnp,content_3882_9674:()=>xnp,content_3882_9676:()=>Lnp,content_3882_9678:()=>knp,content_3882_968:()=>Phe,content_3882_9680:()=>Inp,content_3882_9682:()=>Snp,content_3882_9684:()=>Enp,content_3882_9686:()=>Fnp,content_3882_9688:()=>jnp,content_3882_9690:()=>Qnp,content_3882_9692:()=>Jnp,content_3882_9694:()=>ntp,content_3882_9696:()=>ptp,content_3882_9698:()=>ctp,content_3882_970:()=>Whe,content_3882_9700:()=>ltp,content_3882_9702:()=>ytp,content_3882_9704:()=>gtp,content_3882_9706:()=>Mtp,content_3882_9708:()=>wtp,content_3882_9710:()=>xtp,content_3882_9712:()=>Ltp,content_3882_9714:()=>ktp,content_3882_9716:()=>Itp,content_3882_9718:()=>Stp,content_3882_972:()=>Ghe,content_3882_9720:()=>Etp,content_3882_9722:()=>Ftp,content_3882_9724:()=>jtp,content_3882_9726:()=>Qtp,content_3882_9728:()=>Jtp,content_3882_9730:()=>nop,content_3882_9732:()=>pop,content_3882_9734:()=>cop,content_3882_9736:()=>lop,content_3882_9738:()=>yop,content_3882_974:()=>Uhe,content_3882_9740:()=>gop,content_3882_9742:()=>Mop,content_3882_9744:()=>wop,content_3882_9746:()=>xop,content_3882_9748:()=>Lop,content_3882_9750:()=>kop,content_3882_9752:()=>Iop,content_3882_9754:()=>Sop,content_3882_9756:()=>Eop,content_3882_9758:()=>Fop,content_3882_976:()=>qhe,content_3882_9760:()=>jop,content_3882_9762:()=>Qop,content_3882_9764:()=>Jop,content_3882_9766:()=>npp,content_3882_9768:()=>ppp,content_3882_9770:()=>cpp,content_3882_9772:()=>lpp,content_3882_9774:()=>ypp,content_3882_9776:()=>gpp,content_3882_9778:()=>Mpp,content_3882_978:()=>Yhe,content_3882_9780:()=>wpp,content_3882_9782:()=>xpp,content_3882_9784:()=>Lpp,content_3882_9786:()=>kpp,content_3882_9788:()=>Ipp,content_3882_9790:()=>Spp,content_3882_9792:()=>Epp,content_3882_9794:()=>Fpp,content_3882_9796:()=>jpp,content_3882_9798:()=>Qpp,content_3882_98:()=>C8,content_3882_980:()=>Khe,content_3882_9800:()=>Jpp,content_3882_9802:()=>nrp,content_3882_9804:()=>prp,content_3882_9806:()=>crp,content_3882_9808:()=>lrp,content_3882_9810:()=>yrp,content_3882_9812:()=>grp,content_3882_9814:()=>Mrp,content_3882_9816:()=>wrp,content_3882_9818:()=>xrp,content_3882_982:()=>ege,content_3882_9820:()=>Lrp,content_3882_9822:()=>krp,content_3882_9824:()=>Irp,content_3882_9826:()=>Srp,content_3882_9828:()=>Erp,content_3882_9830:()=>Frp,content_3882_9832:()=>jrp,content_3882_9834:()=>Qrp,content_3882_9836:()=>Jrp,content_3882_9838:()=>nsp,content_3882_984:()=>oge,content_3882_9840:()=>psp,content_3882_9842:()=>csp,content_3882_9844:()=>lsp,content_3882_9846:()=>ysp,content_3882_9848:()=>gsp,content_3882_9850:()=>Msp,content_3882_9852:()=>wsp,content_3882_9854:()=>xsp,content_3882_9856:()=>Lsp,content_3882_9858:()=>ksp,content_3882_986:()=>sge,content_3882_9860:()=>Isp,content_3882_9862:()=>Ssp,content_3882_9864:()=>Esp,content_3882_9866:()=>Fsp,content_3882_9868:()=>jsp,content_3882_9870:()=>Qsp,content_3882_9872:()=>Jsp,content_3882_9874:()=>ncp,content_3882_9876:()=>pcp,content_3882_9878:()=>ccp,content_3882_988:()=>ige,content_3882_9880:()=>lcp,content_3882_9882:()=>ycp,content_3882_9884:()=>gcp,content_3882_9886:()=>Mcp,content_3882_9888:()=>wcp,content_3882_9890:()=>xcp,content_3882_9892:()=>Lcp,content_3882_9894:()=>kcp,content_3882_9896:()=>Icp,content_3882_9898:()=>Scp,content_3882_990:()=>mge,content_3882_9900:()=>Ecp,content_3882_9902:()=>Fcp,content_3882_9904:()=>jcp,content_3882_9906:()=>Qcp,content_3882_9908:()=>Jcp,content_3882_9910:()=>nap,content_3882_9912:()=>pap,content_3882_9914:()=>cap,content_3882_9916:()=>lap,content_3882_9918:()=>yap,content_3882_992:()=>hge,content_3882_9920:()=>gap,content_3882_9922:()=>Map,content_3882_9924:()=>wap,content_3882_9926:()=>xap,content_3882_9928:()=>Lap,content_3882_9930:()=>kap,content_3882_9932:()=>Iap,content_3882_9934:()=>Sap,content_3882_9936:()=>Eap,content_3882_9938:()=>Fap,content_3882_994:()=>Dge,content_3882_9940:()=>jap,content_3882_9942:()=>Qap,content_3882_9944:()=>Jap,content_3882_9946:()=>nip,content_3882_9948:()=>pip,content_3882_9950:()=>cip,content_3882_9952:()=>lip,content_3882_9954:()=>yip,content_3882_9956:()=>gip,content_3882_9958:()=>Mip,content_3882_996:()=>_ge,content_3882_9960:()=>wip,content_3882_9962:()=>xip,content_3882_9964:()=>Lip,content_3882_9966:()=>kip,content_3882_9968:()=>Iip,content_3882_9970:()=>Sip,content_3882_9972:()=>Eip,content_3882_9974:()=>Fip,content_3882_9976:()=>jip,content_3882_9978:()=>Qip,content_3882_998:()=>Cge,content_3882_9980:()=>Jip,content_3882_9982:()=>nlp,content_3882_9984:()=>plp,content_3882_9986:()=>clp,content_3882_9988:()=>llp,content_3882_9990:()=>ylp,content_3882_9992:()=>glp,content_3882_9994:()=>Mlp,content_3882_9996:()=>wlp,content_3882_9998:()=>xlp});var p=t(9575),r=t(4041),s=t(2247);const c={toc:[]},a="wrapper";function i(e){let{components:n,...t}=e;return(0,s.yg)(a,(0,p.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const l={toc:[]},u="wrapper";function m(e){let{components:n,...t}=e;return(0,s.yg)(u,(0,p.A)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Most of the export logic is handled on the server. This class communicates\nwith the FFmpegBridge through a WebSocket connection which lets it invoke\nmethods on the FFmpegExporterServer class."),(0,s.yg)("p",null,"For example, calling the following method:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"async this.invoke('process', 7);\n")),(0,s.yg)("p",null,"Will invoke the ",(0,s.yg)("inlineCode",{parentName:"p"},"process")," method on the FFmpegExporterServer class with ",(0,s.yg)("inlineCode",{parentName:"p"},"7"),"\nas the argument. The result of the method will be returned as a Promise."),(0,s.yg)("p",null,"Before any methods can be invoked, the FFmpegExporterServer class must be\ninitialized by invoking ",(0,s.yg)("inlineCode",{parentName:"p"},"start"),"."))}m.isMDXComponent=!0;const y={toc:[]},d="wrapper";function h(e){let{components:n,...t}=e;return(0,s.yg)(d,(0,p.A)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"FFmpeg video exporter."))}h.isMDXComponent=!0;const g={toc:[]},f="wrapper";function D(e){let{components:n,...t}=e;return(0,s.yg)(f,(0,p.A)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Take in media assets per frame and generate audio track for the video."))}D.isMDXComponent=!0;const M={toc:[]},X="wrapper";function _(e){let{components:n,...t}=e;return(0,s.yg)(X,(0,p.A)({},M,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called each time after a frame is rendered."))}_.isMDXComponent=!0;const w={toc:[]},T="wrapper";function C(e){let{components:n,...t}=e;return(0,s.yg)(T,(0,p.A)({},w,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export a frame."))}C.isMDXComponent=!0;const x={toc:[]},A="wrapper";function v(e){let{components:n,...t}=e;return(0,s.yg)(A,(0,p.A)({},x,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A canvas containing the rendered frame."))}v.isMDXComponent=!0;const L={toc:[]},b="wrapper";function N(e){let{components:n,...t}=e;return(0,s.yg)(b,(0,p.A)({},L,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Performs clean-up."))}N.isMDXComponent=!0;const k={toc:[]},z="wrapper";function P(e){let{components:n,...t}=e;return(0,s.yg)(z,(0,p.A)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}P.isMDXComponent=!0;const I={toc:[]},R="wrapper";function W(e){let{components:n,...t}=e;return(0,s.yg)(R,(0,p.A)({},I,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"after processing the image stream and generating an audio file, merge the video and audio stream as the final video"))}W.isMDXComponent=!0;const S={toc:[]},B="wrapper";function G(e){let{components:n,...t}=e;return(0,s.yg)(B,(0,p.A)({},S,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.yg)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.yg)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}G.isMDXComponent=!0;const E={toc:[]},O="wrapper";function U(e){let{components:n,...t}=e;return(0,s.yg)(O,(0,p.A)({},E,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Begin the rendering process."))}U.isMDXComponent=!0;const F={toc:[]},V="wrapper";function q(e){let{components:n,...t}=e;return(0,s.yg)(V,(0,p.A)({},F,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after rendering the visual elements has finished and audio so that audio track can be merged."))}q.isMDXComponent=!0;const j={toc:[]},H="wrapper";function Y(e){let{components:n,...t}=e;return(0,s.yg)(H,(0,p.A)({},j,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}Y.isMDXComponent=!0;const Q={toc:[]},$="wrapper";function K(e){let{components:n,...t}=e;return(0,s.yg)($,(0,p.A)({},Q,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of the rendering."))}K.isMDXComponent=!0;const J={toc:[]},Z="wrapper";function ee(e){let{components:n,...t}=e;return(0,s.yg)(Z,(0,p.A)({},J,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when a new message is logged."))}ee.isMDXComponent=!0;const ne={toc:[]},te="wrapper";function oe(e){let{components:n,...t}=e;return(0,s.yg)(te,(0,p.A)({},ne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A read-only representation of the playback."))}oe.isMDXComponent=!0;const pe={toc:[]},re="wrapper";function se(e){let{components:n,...t}=e;return(0,s.yg)(re,(0,p.A)({},pe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The time passed since the last frame in seconds."))}se.isMDXComponent=!0;const ce={toc:[]},ae="wrapper";function ie(e){let{components:n,...t}=e;return(0,s.yg)(ae,(0,p.A)({},ce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert frames to seconds using the current framerate."))}ie.isMDXComponent=!0;const le={toc:[]},ue="wrapper";function me(e){let{components:n,...t}=e;return(0,s.yg)(ue,(0,p.A)({},le,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frames to convert."))}me.isMDXComponent=!0;const ye={toc:[]},de="wrapper";function he(e){let{components:n,...t}=e;return(0,s.yg)(de,(0,p.A)({},ye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert seconds to frames using the current framerate."))}he.isMDXComponent=!0;const ge={toc:[]},fe="wrapper";function De(e){let{components:n,...t}=e;return(0,s.yg)(fe,(0,p.A)({},ge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The seconds to convert."))}De.isMDXComponent=!0;const Me={toc:[]},Xe="wrapper";function _e(e){let{components:n,...t}=e;return(0,s.yg)(Xe,(0,p.A)({},Me,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This class builds on top of the ",(0,s.yg)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}_e.isMDXComponent=!0;const we={toc:[]},Te="wrapper";function Ce(e){let{components:n,...t}=e;return(0,s.yg)(Te,(0,p.A)({},we,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The player logic used by the editor and embeddable player."))}Ce.isMDXComponent=!0;const xe={toc:[]},Ae="wrapper";function ve(e){let{components:n,...t}=e;return(0,s.yg)(Ae,(0,p.A)({},xe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to provide visual feedback."))}ve.isMDXComponent=!0;const Le={toc:[]},be="wrapper";function Ne(e){let{components:n,...t}=e;return(0,s.yg)(be,(0,p.A)({},Le,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered right after recalculation finishes."))}Ne.isMDXComponent=!0;const ke={toc:[]},ze="wrapper";function Pe(e){let{components:n,...t}=e;return(0,s.yg)(ze,(0,p.A)({},ke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.yg)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.yg)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}Pe.isMDXComponent=!0;const Ie={toc:[]},Re="wrapper";function We(e){let{components:n,...t}=e;return(0,s.yg)(Re,(0,p.A)({},Ie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}We.isMDXComponent=!0;const Se={toc:[]},Be="wrapper";function Ge(e){let{components:n,...t}=e;return(0,s.yg)(Be,(0,p.A)({},Se,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}Ge.isMDXComponent=!0;const Ee={toc:[]},Oe="wrapper";function Ue(e){let{components:n,...t}=e;return(0,s.yg)(Oe,(0,p.A)({},Ee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Activate the player."))}Ue.isMDXComponent=!0;const Fe={toc:[]},Ve="wrapper";function qe(e){let{components:n,...t}=e;return(0,s.yg)(Ve,(0,p.A)({},Fe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.yg)("p",null,"Just pausing the player does not stop the loop."))}qe.isMDXComponent=!0;const je={toc:[]},He="wrapper";function Ye(e){let{components:n,...t}=e;return(0,s.yg)(He,(0,p.A)({},je,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Deactivate the player."))}Ye.isMDXComponent=!0;const Qe={toc:[]},$e="wrapper";function Ke(e){let{components:n,...t}=e;return(0,s.yg)($e,(0,p.A)({},Qe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the given frame is inside the animation range."))}Ke.isMDXComponent=!0;const Je={toc:[]},Ze="wrapper";function en(e){let{components:n,...t}=e;return(0,s.yg)(Ze,(0,p.A)({},Je,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame to check."))}en.isMDXComponent=!0;const nn={toc:[]},tn="wrapper";function on(e){let{components:n,...t}=e;return(0,s.yg)(tn,(0,p.A)({},nn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the given frame is inside the user-defined range."))}on.isMDXComponent=!0;const pn={toc:[]},rn="wrapper";function sn(e){let{components:n,...t}=e;return(0,s.yg)(rn,(0,p.A)({},pn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame to check."))}sn.isMDXComponent=!0;const cn={toc:[]},an="wrapper";function ln(e){let{components:n,...t}=e;return(0,s.yg)(an,(0,p.A)({},cn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the root of all assets that use relative paths."),(0,s.yg)("p",null,"e.g. /video.mp4 becomes ",(0,s.yg)("a",{parentName:"p",href:"https://example.com/video.mp4"},"https://example.com/video.mp4")))}ln.isMDXComponent=!0;const un={toc:[]},mn="wrapper";function yn(e){let{components:n,...t}=e;return(0,s.yg)(mn,(0,p.A)({},un,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The root URL. Including the trailing slash."))}yn.isMDXComponent=!0;const dn={toc:[]},hn="wrapper";function gn(e){let{components:n,...t}=e;return(0,s.yg)(hn,(0,p.A)({},dn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abort the ongoing presentation process."))}gn.isMDXComponent=!0;const fn={toc:[]},Dn="wrapper";function Mn(e){let{components:n,...t}=e;return(0,s.yg)(Dn,(0,p.A)({},fn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Present the animation."))}Mn.isMDXComponent=!0;const Xn={toc:[]},_n="wrapper";function wn(e){let{components:n,...t}=e;return(0,s.yg)(_n,(0,p.A)({},Xn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The presentation settings."))}wn.isMDXComponent=!0;const Tn={toc:[]},Cn="wrapper";function xn(e){let{components:n,...t}=e;return(0,s.yg)(Cn,(0,p.A)({},Tn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Resume the presentation if waiting for the next slide."))}xn.isMDXComponent=!0;const An={toc:[]},vn="wrapper";function Ln(e){let{components:n,...t}=e;return(0,s.yg)(vn,(0,p.A)({},An,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Ln.isMDXComponent=!0;const bn={toc:[]},Nn="wrapper";function kn(e){let{components:n,...t}=e;return(0,s.yg)(Nn,(0,p.A)({},bn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}kn.isMDXComponent=!0;const zn={toc:[]},Pn="wrapper";function In(e){let{components:n,...t}=e;return(0,s.yg)(Pn,(0,p.A)({},zn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}In.isMDXComponent=!0;const Rn={toc:[]},Wn="wrapper";function Sn(e){let{components:n,...t}=e;return(0,s.yg)(Wn,(0,p.A)({},Rn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}Sn.isMDXComponent=!0;const Bn={toc:[]},Gn="wrapper";function En(e){let{components:n,...t}=e;return(0,s.yg)(Gn,(0,p.A)({},Bn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the nested fields change."))}En.isMDXComponent=!0;const On={toc:[]},Un="wrapper";function Fn(e){let{components:n,...t}=e;return(0,s.yg)(Un,(0,p.A)({},On,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}Fn.isMDXComponent=!0;const Vn={toc:[]},qn="wrapper";function jn(e){let{components:n,...t}=e;return(0,s.yg)(qn,(0,p.A)({},Vn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}jn.isMDXComponent=!0;const Hn={toc:[]},Yn="wrapper";function Qn(e){let{components:n,...t}=e;return(0,s.yg)(Yn,(0,p.A)({},Hn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}Qn.isMDXComponent=!0;const $n={toc:[]},Kn="wrapper";function Jn(e){let{components:n,...t}=e;return(0,s.yg)(Kn,(0,p.A)({},$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Jn.isMDXComponent=!0;const Zn={toc:[]},et="wrapper";function nt(e){let{components:n,...t}=e;return(0,s.yg)(et,(0,p.A)({},Zn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}nt.isMDXComponent=!0;const tt={toc:[]},ot="wrapper";function pt(e){let{components:n,...t}=e;return(0,s.yg)(ot,(0,p.A)({},tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}pt.isMDXComponent=!0;const rt={toc:[]},st="wrapper";function ct(e){let{components:n,...t}=e;return(0,s.yg)(st,(0,p.A)({},rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}ct.isMDXComponent=!0;const at={toc:[]},it="wrapper";function lt(e){let{components:n,...t}=e;return(0,s.yg)(it,(0,p.A)({},at,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}lt.isMDXComponent=!0;const ut={toc:[]},mt="wrapper";function yt(e){let{components:n,...t}=e;return(0,s.yg)(mt,(0,p.A)({},ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}yt.isMDXComponent=!0;const dt={toc:[]},ht="wrapper";function gt(e){let{components:n,...t}=e;return(0,s.yg)(ht,(0,p.A)({},dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This class uses the ",(0,s.yg)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.yg)("p",null,"The actual exporting is outsourced to an ",(0,s.yg)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.yg)("inlineCode",{parentName:"a"},"Exporter")),"."))}gt.isMDXComponent=!0;const ft={toc:[]},Dt="wrapper";function Mt(e){let{components:n,...t}=e;return(0,s.yg)(Dt,(0,p.A)({},ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering logic used by the editor to export animations."))}Mt.isMDXComponent=!0;const Xt={toc:[]},_t="wrapper";function wt(e){let{components:n,...t}=e;return(0,s.yg)(_t,(0,p.A)({},Xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abort the ongoing render process."))}wt.isMDXComponent=!0;const Tt={toc:[]},Ct="wrapper";function xt(e){let{components:n,...t}=e;return(0,s.yg)(Ct,(0,p.A)({},Tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns number of frames that a project will have."))}xt.isMDXComponent=!0;const At={toc:[]},vt="wrapper";function Lt(e){let{components:n,...t}=e;return(0,s.yg)(vt,(0,p.A)({},At,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the animation using the provided settings."))}Lt.isMDXComponent=!0;const bt={toc:[]},Nt="wrapper";function kt(e){let{components:n,...t}=e;return(0,s.yg)(Nt,(0,p.A)({},bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}kt.isMDXComponent=!0;const zt={toc:[]},Pt="wrapper";function It(e){let{components:n,...t}=e;return(0,s.yg)(Pt,(0,p.A)({},zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method always uses the default ",(0,s.yg)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}It.isMDXComponent=!0;const Rt={toc:[]},Wt="wrapper";function St(e){let{components:n,...t}=e;return(0,s.yg)(Wt,(0,p.A)({},Rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export an individual frame."))}St.isMDXComponent=!0;const Bt={toc:[]},Gt="wrapper";function Et(e){let{components:n,...t}=e;return(0,s.yg)(Gt,(0,p.A)({},Bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}Et.isMDXComponent=!0;const Ot={toc:[]},Ut="wrapper";function Ft(e){let{components:n,...t}=e;return(0,s.yg)(Ut,(0,p.A)({},Ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timestamp to export."))}Ft.isMDXComponent=!0;const Vt={toc:[]},qt="wrapper";function jt(e){let{components:n,...t}=e;return(0,s.yg)(qt,(0,p.A)({},Vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispose the WebGL context to free up resources."))}jt.isMDXComponent=!0;const Ht={toc:[]},Yt="wrapper";function Qt(e){let{components:n,...t}=e;return(0,s.yg)(Yt,(0,p.A)({},Ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Manages canvases on which an animation can be displayed."))}Qt.isMDXComponent=!0;const $t={toc:[]},Kt="wrapper";function Jt(e){let{components:n,...t}=e;return(0,s.yg)(Kt,(0,p.A)({},$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main interface for implementing custom exporters."))}Jt.isMDXComponent=!0;const Zt={toc:[]},eo="wrapper";function no(e){let{components:n,...t}=e;return(0,s.yg)(eo,(0,p.A)({},Zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}no.isMDXComponent=!0;const to={toc:[]},oo="wrapper";function po(e){let{components:n,...t}=e;return(0,s.yg)(oo,(0,p.A)({},to,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the rendering configuration."))}po.isMDXComponent=!0;const ro={toc:[]},so="wrapper";function co(e){let{components:n,...t}=e;return(0,s.yg)(so,(0,p.A)({},ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Take in media assets per frame and generate audio track for the video."))}co.isMDXComponent=!0;const ao={toc:[]},io="wrapper";function lo(e){let{components:n,...t}=e;return(0,s.yg)(io,(0,p.A)({},ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called each time after a frame is rendered."))}lo.isMDXComponent=!0;const uo={toc:[]},mo="wrapper";function yo(e){let{components:n,...t}=e;return(0,s.yg)(mo,(0,p.A)({},uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export a frame."))}yo.isMDXComponent=!0;const ho={toc:[]},go="wrapper";function fo(e){let{components:n,...t}=e;return(0,s.yg)(go,(0,p.A)({},ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A canvas containing the rendered frame."))}fo.isMDXComponent=!0;const Do={toc:[]},Mo="wrapper";function Xo(e){let{components:n,...t}=e;return(0,s.yg)(Mo,(0,p.A)({},Do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame number."))}Xo.isMDXComponent=!0;const _o={toc:[]},wo="wrapper";function To(e){let{components:n,...t}=e;return(0,s.yg)(wo,(0,p.A)({},_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame number within the scene."))}To.isMDXComponent=!0;const Co={toc:[]},xo="wrapper";function Ao(e){let{components:n,...t}=e;return(0,s.yg)(xo,(0,p.A)({},Co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the scene with which the frame is associated."))}Ao.isMDXComponent=!0;const vo={toc:[]},Lo="wrapper";function bo(e){let{components:n,...t}=e;return(0,s.yg)(Lo,(0,p.A)({},vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An abort signal triggered if the user aborts the rendering."))}bo.isMDXComponent=!0;const No={toc:[]},ko="wrapper";function zo(e){let{components:n,...t}=e;return(0,s.yg)(ko,(0,p.A)({},No,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Performs clean-up."))}zo.isMDXComponent=!0;const Po={toc:[]},Io="wrapper";function Ro(e){let{components:n,...t}=e;return(0,s.yg)(Io,(0,p.A)({},Po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}Ro.isMDXComponent=!0;const Wo={toc:[]},So="wrapper";function Bo(e){let{components:n,...t}=e;return(0,s.yg)(So,(0,p.A)({},Wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"after processing the image stream and generating an audio file, merge the video and audio stream as the final video"))}Bo.isMDXComponent=!0;const Go={toc:[]},Eo="wrapper";function Oo(e){let{components:n,...t}=e;return(0,s.yg)(Eo,(0,p.A)({},Go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.yg)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.yg)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}Oo.isMDXComponent=!0;const Uo={toc:[]},Fo="wrapper";function Vo(e){let{components:n,...t}=e;return(0,s.yg)(Fo,(0,p.A)({},Uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Begin the rendering process."))}Vo.isMDXComponent=!0;const qo={toc:[]},jo="wrapper";function Ho(e){let{components:n,...t}=e;return(0,s.yg)(jo,(0,p.A)({},qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after rendering the visual elements has finished and audio so that audio track can be merged."))}Ho.isMDXComponent=!0;const Yo={toc:[]},Qo="wrapper";function $o(e){let{components:n,...t}=e;return(0,s.yg)(Qo,(0,p.A)({},Yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}$o.isMDXComponent=!0;const Ko={toc:[]},Jo="wrapper";function Zo(e){let{components:n,...t}=e;return(0,s.yg)(Jo,(0,p.A)({},Ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of the rendering."))}Zo.isMDXComponent=!0;const ep={toc:[]},np="wrapper";function tp(e){let{components:n,...t}=e;return(0,s.yg)(np,(0,p.A)({},ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The static interface for exporters."))}tp.isMDXComponent=!0;const op={toc:[]},pp="wrapper";function rp(e){let{components:n,...t}=e;return(0,s.yg)(pp,(0,p.A)({},op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This name will be displayed in the editor."))}rp.isMDXComponent=!0;const sp={toc:[]},cp="wrapper";function ap(e){let{components:n,...t}=e;return(0,s.yg)(cp,(0,p.A)({},sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this exporter."))}ap.isMDXComponent=!0;const ip={toc:[]},lp="wrapper";function up(e){let{components:n,...t}=e;return(0,s.yg)(lp,(0,p.A)({},ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}up.isMDXComponent=!0;const mp={toc:[]},yp="wrapper";function dp(e){let{components:n,...t}=e;return(0,s.yg)(yp,(0,p.A)({},mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The unique identifier of this exporter."))}dp.isMDXComponent=!0;const hp={toc:[]},gp="wrapper";function fp(e){let{components:n,...t}=e;return(0,s.yg)(gp,(0,p.A)({},hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}fp.isMDXComponent=!0;const Dp={toc:[]},Mp="wrapper";function Xp(e){let{components:n,...t}=e;return(0,s.yg)(Mp,(0,p.A)({},Dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this exporter."))}Xp.isMDXComponent=!0;const _p={toc:[]},wp="wrapper";function Tp(e){let{components:n,...t}=e;return(0,s.yg)(wp,(0,p.A)({},_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current project."))}Tp.isMDXComponent=!0;const Cp={toc:[]},xp="wrapper";function Ap(e){let{components:n,...t}=e;return(0,s.yg)(xp,(0,p.A)({},Cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}Ap.isMDXComponent=!0;const vp={toc:[]},Lp="wrapper";function bp(e){let{components:n,...t}=e;return(0,s.yg)(Lp,(0,p.A)({},vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a meta field representing the options of this exporter."))}bp.isMDXComponent=!0;const Np={toc:[]},kp="wrapper";function zp(e){let{components:n,...t}=e;return(0,s.yg)(kp,(0,p.A)({},Np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When displayed in the editor, the log entry will have the following format:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},"                             inspect node \u2510\n  \u250c expand more          duration \u2510       \u2502\n  \u25bc                               \u25bc       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u25b6 message                       300 ms (+) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 remarks                                    \u2502\n\u2502 object                                     \u2502\n\u2502 stacktrace                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))}zp.isMDXComponent=!0;const Pp={toc:[]},Ip="wrapper";function Rp(e){let{components:n,...t}=e;return(0,s.yg)(Ip,(0,p.A)({},Pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an individual log entry."))}Rp.isMDXComponent=!0;const Wp={toc:[]},Sp="wrapper";function Bp(e){let{components:n,...t}=e;return(0,s.yg)(Sp,(0,p.A)({},Wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}Bp.isMDXComponent=!0;const Gp={toc:[]},Ep="wrapper";function Op(e){let{components:n,...t}=e;return(0,s.yg)(Ep,(0,p.A)({},Gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}Op.isMDXComponent=!0;const Up={toc:[]},Fp="wrapper";function Vp(e){let{components:n,...t}=e;return(0,s.yg)(Fp,(0,p.A)({},Up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}Vp.isMDXComponent=!0;const qp={toc:[]},jp="wrapper";function Hp(e){let{components:n,...t}=e;return(0,s.yg)(jp,(0,p.A)({},qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}Hp.isMDXComponent=!0;const Yp={toc:[]},Qp="wrapper";function $p(e){let{components:n,...t}=e;return(0,s.yg)(Qp,(0,p.A)({},Yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The log level."))}$p.isMDXComponent=!0;const Kp={toc:[]},Jp="wrapper";function Zp(e){let{components:n,...t}=e;return(0,s.yg)(Jp,(0,p.A)({},Kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}Zp.isMDXComponent=!0;const er={toc:[]},nr="wrapper";function tr(e){let{components:n,...t}=e;return(0,s.yg)(nr,(0,p.A)({},er,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}tr.isMDXComponent=!0;const or={toc:[]},pr="wrapper";function rr(e){let{components:n,...t}=e;return(0,s.yg)(pr,(0,p.A)({},or,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}rr.isMDXComponent=!0;const sr={toc:[]},cr="wrapper";function ar(e){let{components:n,...t}=e;return(0,s.yg)(cr,(0,p.A)({},sr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}ar.isMDXComponent=!0;const ir={toc:[]},lr="wrapper";function ur(e){let{components:n,...t}=e;return(0,s.yg)(lr,(0,p.A)({},ir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}ur.isMDXComponent=!0;const mr={toc:[]},yr="wrapper";function dr(e){let{components:n,...t}=e;return(0,s.yg)(yr,(0,p.A)({},mr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional information about the log."))}dr.isMDXComponent=!0;const hr={toc:[]},gr="wrapper";function fr(e){let{components:n,...t}=e;return(0,s.yg)(gr,(0,p.A)({},hr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded.\nThe current stack trace can be obtained using ",(0,s.yg)("inlineCode",{parentName:"p"},"new Error().stack"),".\nBoth Chromium and Firefox stack traces are supported."))}fr.isMDXComponent=!0;const Dr={toc:[]},Mr="wrapper";function Xr(e){let{components:n,...t}=e;return(0,s.yg)(Mr,(0,p.A)({},Dr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace of the log."))}Xr.isMDXComponent=!0;const _r={toc:[]},wr="wrapper";function Tr(e){let{components:n,...t}=e;return(0,s.yg)(wr,(0,p.A)({},_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/media#audio"},"https://motioncanvas.io/docs/media#audio")))}Tr.isMDXComponent=!0;const Cr={toc:[]},xr="wrapper";function Ar(e){let{components:n,...t}=e;return(0,s.yg)(xr,(0,p.A)({},Cr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An url for the audio track to play alongside the animation."))}Ar.isMDXComponent=!0;const vr={toc:[]},Lr="wrapper";function br(e){let{components:n,...t}=e;return(0,s.yg)(Lr,(0,p.A)({},vr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configure the offset in the Video Settings tab of th editor."))}br.isMDXComponent=!0;const Nr={toc:[]},kr="wrapper";function zr(e){let{components:n,...t}=e;return(0,s.yg)(kr,(0,p.A)({},Nr,t,{components:n,mdxType:"MDXLayout"}))}zr.isMDXComponent=!0;const Pr={toc:[]},Ir="wrapper";function Rr(e){let{components:n,...t}=e;return(0,s.yg)(Ir,(0,p.A)({},Pr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/experimental"},"https://motioncanvas.io/docs/experimental")))}Rr.isMDXComponent=!0;const Wr={toc:[]},Sr="wrapper";function Br(e){let{components:n,...t}=e;return(0,s.yg)(Sr,(0,p.A)({},Wr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enable experimental features."))}Br.isMDXComponent=!0;const Gr={toc:[]},Er="wrapper";function Or(e){let{components:n,...t}=e;return(0,s.yg)(Er,(0,p.A)({},Gr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A custom logger instance to use."))}Or.isMDXComponent=!0;const Ur={toc:[]},Fr="wrapper";function Vr(e){let{components:n,...t}=e;return(0,s.yg)(Fr,(0,p.A)({},Ur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the project."))}Vr.isMDXComponent=!0;const qr={toc:[]},jr="wrapper";function Hr(e){let{components:n,...t}=e;return(0,s.yg)(jr,(0,p.A)({},qr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When a string is provided, the plugin will be imported dynamically using\nthe string as the module specifier. This is the preferred way to include\neditor plugins because it makes sure that the plugin's source code gets\nexcluded from the production build."))}Hr.isMDXComponent=!0;const Yr={toc:[]},Qr="wrapper";function $r(e){let{components:n,...t}=e;return(0,s.yg)(Qr,(0,p.A)({},Yr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}$r.isMDXComponent=!0;const Kr={toc:[]},Jr="wrapper";function Zr(e){let{components:n,...t}=e;return(0,s.yg)(Jr,(0,p.A)({},Kr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A full scene description can be obtained by loading a scene module with a\n",(0,s.yg)("inlineCode",{parentName:"p"},"?scene")," query parameter."))}Zr.isMDXComponent=!0;const es={toc:[]},ns="wrapper";function ts(e){let{components:n,...t}=e;return(0,s.yg)(ns,(0,p.A)({},es,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"import exampleScene from './example?scene';\n\nexport default makeProject({\n  scenes: [exampleScene],\n});\n")))}ts.isMDXComponent=!0;const os={toc:[]},ps="wrapper";function rs(e){let{components:n,...t}=e;return(0,s.yg)(ps,(0,p.A)({},os,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of scene descriptions that make up the project."))}rs.isMDXComponent=!0;const ss={toc:[]},cs="wrapper";function as(e){let{components:n,...t}=e;return(0,s.yg)(cs,(0,p.A)({},ss,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/project-variables"},"https://motioncanvas.io/docs/project-variables")))}as.isMDXComponent=!0;const is={toc:[]},ls="wrapper";function us(e){let{components:n,...t}=e;return(0,s.yg)(ls,(0,p.A)({},is,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default values for project variables."))}us.isMDXComponent=!0;const ms={toc:[]},ys="wrapper";function ds(e){let{components:n,...t}=e;return(0,s.yg)(ys,(0,p.A)({},ms,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A runtime representation of the settings metadata."))}ds.isMDXComponent=!0;const hs={toc:[]},gs="wrapper";function fs(e){let{components:n,...t}=e;return(0,s.yg)(gs,(0,p.A)({},hs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a runtime representation of the settings metadata."))}fs.isMDXComponent=!0;const Ds={toc:[]},Ms="wrapper";function Xs(e){let{components:n,...t}=e;return(0,s.yg)(Ms,(0,p.A)({},Ds,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Property decorators."))}Xs.isMDXComponent=!0;const _s={toc:[]},ws="wrapper";function Ts(e){let{components:n,...t}=e;return(0,s.yg)(ws,(0,p.A)({},_s,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.yg)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}Ts.isMDXComponent=!0;const Cs={toc:[]},xs="wrapper";function As(e){let{components:n,...t}=e;return(0,s.yg)(xs,(0,p.A)({},Cs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a lazy decorator."))}As.isMDXComponent=!0;const vs={toc:[]},Ls="wrapper";function bs(e){let{components:n,...t}=e;return(0,s.yg)(Ls,(0,p.A)({},vs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns the value of this property."))}bs.isMDXComponent=!0;const Ns={toc:[]},ks="wrapper";function zs(e){let{components:n,...t}=e;return(0,s.yg)(ks,(0,p.A)({},Ns,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscriptions and triggering of events."))}zs.isMDXComponent=!0;const Ps={toc:[]},Is="wrapper";function Rs(e){let{components:n,...t}=e;return(0,s.yg)(Is,(0,p.A)({},Ps,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.yg)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}Rs.isMDXComponent=!0;const Ws={toc:[]},Ss="wrapper";function Bs(e){let{components:n,...t}=e;return(0,s.yg)(Ss,(0,p.A)({},Ws,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}Bs.isMDXComponent=!0;const Gs={toc:[]},Es="wrapper";function Os(e){let{components:n,...t}=e;return(0,s.yg)(Es,(0,p.A)({},Gs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches an asynchronous ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Os.isMDXComponent=!0;const Us={toc:[]},Fs="wrapper";function Vs(e){let{components:n,...t}=e;return(0,s.yg)(Fs,(0,p.A)({},Us,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Vs.isMDXComponent=!0;const qs={toc:[]},js="wrapper";function Hs(e){let{components:n,...t}=e;return(0,s.yg)(js,(0,p.A)({},qs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Hs.isMDXComponent=!0;const Ys={toc:[]},Qs="wrapper";function $s(e){let{components:n,...t}=e;return(0,s.yg)(Qs,(0,p.A)({},Ys,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}$s.isMDXComponent=!0;const Ks={toc:[]},Js="wrapper";function Zs(e){let{components:n,...t}=e;return(0,s.yg)(Js,(0,p.A)({},Ks,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Zs.isMDXComponent=!0;const ec={toc:[]},nc="wrapper";function tc(e){let{components:n,...t}=e;return(0,s.yg)(nc,(0,p.A)({},ec,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}tc.isMDXComponent=!0;const oc={toc:[]},pc="wrapper";function rc(e){let{components:n,...t}=e;return(0,s.yg)(pc,(0,p.A)({},oc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}rc.isMDXComponent=!0;const sc={toc:[]},cc="wrapper";function ac(e){let{components:n,...t}=e;return(0,s.yg)(cc,(0,p.A)({},sc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}ac.isMDXComponent=!0;const ic={toc:[]},lc="wrapper";function uc(e){let{components:n,...t}=e;return(0,s.yg)(lc,(0,p.A)({},ic,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}uc.isMDXComponent=!0;const mc={toc:[]},yc="wrapper";function dc(e){let{components:n,...t}=e;return(0,s.yg)(yc,(0,p.A)({},mc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}dc.isMDXComponent=!0;const hc={toc:[]},gc="wrapper";function fc(e){let{components:n,...t}=e;return(0,s.yg)(gc,(0,p.A)({},hc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}fc.isMDXComponent=!0;const Dc={toc:[]},Mc="wrapper";function Xc(e){let{components:n,...t}=e;return(0,s.yg)(Mc,(0,p.A)({},Dc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Xc.isMDXComponent=!0;const _c={toc:[]},wc="wrapper";function Tc(e){let{components:n,...t}=e;return(0,s.yg)(wc,(0,p.A)({},_c,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}Tc.isMDXComponent=!0;const Cc={toc:[]},xc="wrapper";function Ac(e){let{components:n,...t}=e;return(0,s.yg)(xc,(0,p.A)({},Cc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Ac.isMDXComponent=!0;const vc={toc:[]},Lc="wrapper";function bc(e){let{components:n,...t}=e;return(0,s.yg)(Lc,(0,p.A)({},vc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}bc.isMDXComponent=!0;const Nc={toc:[]},kc="wrapper";function zc(e){let{components:n,...t}=e;return(0,s.yg)(kc,(0,p.A)({},Nc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}zc.isMDXComponent=!0;const Pc={toc:[]},Ic="wrapper";function Rc(e){let{components:n,...t}=e;return(0,s.yg)(Ic,(0,p.A)({},Pc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value argument to subscribers."))}Rc.isMDXComponent=!0;const Wc={toc:[]},Sc="wrapper";function Bc(e){let{components:n,...t}=e;return(0,s.yg)(Sc,(0,p.A)({},Wc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A base for dispatching ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.yg)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Bc.isMDXComponent=!0;const Gc={toc:[]},Ec="wrapper";function Oc(e){let{components:n,...t}=e;return(0,s.yg)(Ec,(0,p.A)({},Gc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Oc.isMDXComponent=!0;const Uc={toc:[]},Fc="wrapper";function Vc(e){let{components:n,...t}=e;return(0,s.yg)(Fc,(0,p.A)({},Uc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Vc.isMDXComponent=!0;const qc={toc:[]},jc="wrapper";function Hc(e){let{components:n,...t}=e;return(0,s.yg)(jc,(0,p.A)({},qc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}Hc.isMDXComponent=!0;const Yc={toc:[]},Qc="wrapper";function $c(e){let{components:n,...t}=e;return(0,s.yg)(Qc,(0,p.A)({},Yc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}$c.isMDXComponent=!0;const Kc={toc:[]},Jc="wrapper";function Zc(e){let{components:n,...t}=e;return(0,s.yg)(Jc,(0,p.A)({},Kc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Zc.isMDXComponent=!0;const ea={toc:[]},na="wrapper";function ta(e){let{components:n,...t}=e;return(0,s.yg)(na,(0,p.A)({},ea,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}ta.isMDXComponent=!0;const oa={toc:[]},pa="wrapper";function ra(e){let{components:n,...t}=e;return(0,s.yg)(pa,(0,p.A)({},oa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}ra.isMDXComponent=!0;const sa={toc:[]},ca="wrapper";function aa(e){let{components:n,...t}=e;return(0,s.yg)(ca,(0,p.A)({},sa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the callback function."))}aa.isMDXComponent=!0;const ia={toc:[]},la="wrapper";function ua(e){let{components:n,...t}=e;return(0,s.yg)(la,(0,p.A)({},ia,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.yg)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.yg)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}ua.isMDXComponent=!0;const ma={toc:[]},ya="wrapper";function da(e){let{components:n,...t}=e;return(0,s.yg)(ya,(0,p.A)({},ma,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}da.isMDXComponent=!0;const ha={toc:[]},ga="wrapper";function fa(e){let{components:n,...t}=e;return(0,s.yg)(ga,(0,p.A)({},ha,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}fa.isMDXComponent=!0;const Da={toc:[]},Ma="wrapper";function Xa(e){let{components:n,...t}=e;return(0,s.yg)(Ma,(0,p.A)({},Da,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Xa.isMDXComponent=!0;const _a={toc:[]},wa="wrapper";function Ta(e){let{components:n,...t}=e;return(0,s.yg)(wa,(0,p.A)({},_a,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Are subscribers being notified?"))}Ta.isMDXComponent=!0;const Ca={toc:[]},xa="wrapper";function Aa(e){let{components:n,...t}=e;return(0,s.yg)(xa,(0,p.A)({},Ca,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Notify all current and future subscribers."))}Aa.isMDXComponent=!0;const va={toc:[]},La="wrapper";function ba(e){let{components:n,...t}=e;return(0,s.yg)(La,(0,p.A)({},va,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Stop notifying future subscribers."))}ba.isMDXComponent=!0;const Na={toc:[]},ka="wrapper";function za(e){let{components:n,...t}=e;return(0,s.yg)(ka,(0,p.A)({},Na,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}za.isMDXComponent=!0;const Pa={toc:[]},Ia="wrapper";function Ra(e){let{components:n,...t}=e;return(0,s.yg)(Ia,(0,p.A)({},Pa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}Ra.isMDXComponent=!0;const Wa={toc:[]},Sa="wrapper";function Ba(e){let{components:n,...t}=e;return(0,s.yg)(Sa,(0,p.A)({},Wa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Ba.isMDXComponent=!0;const Ga={toc:[]},Ea="wrapper";function Oa(e){let{components:n,...t}=e;return(0,s.yg)(Ea,(0,p.A)({},Ga,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Oa.isMDXComponent=!0;const Ua={toc:[]},Fa="wrapper";function Va(e){let{components:n,...t}=e;return(0,s.yg)(Fa,(0,p.A)({},Ua,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Va.isMDXComponent=!0;const qa={toc:[]},ja="wrapper";function Ha(e){let{components:n,...t}=e;return(0,s.yg)(ja,(0,p.A)({},qa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ha.isMDXComponent=!0;const Ya={toc:[]},Qa="wrapper";function $a(e){let{components:n,...t}=e;return(0,s.yg)(Qa,(0,p.A)({},Ya,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.yg)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}$a.isMDXComponent=!0;const Ka={toc:[]},Ja="wrapper";function Za(e){let{components:n,...t}=e;return(0,s.yg)(Ja,(0,p.A)({},Ka,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Za.isMDXComponent=!0;const ei={toc:[]},ni="wrapper";function ti(e){let{components:n,...t}=e;return(0,s.yg)(ni,(0,p.A)({},ei,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}ti.isMDXComponent=!0;const oi={toc:[]},pi="wrapper";function ri(e){let{components:n,...t}=e;return(0,s.yg)(pi,(0,p.A)({},oi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}ri.isMDXComponent=!0;const si={toc:[]},ci="wrapper";function ai(e){let{components:n,...t}=e;return(0,s.yg)(ci,(0,p.A)({},si,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}ai.isMDXComponent=!0;const ii={toc:[]},li="wrapper";function ui(e){let{components:n,...t}=e;return(0,s.yg)(li,(0,p.A)({},ii,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}ui.isMDXComponent=!0;const mi={toc:[]},yi="wrapper";function di(e){let{components:n,...t}=e;return(0,s.yg)(yi,(0,p.A)({},mi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}di.isMDXComponent=!0;const hi={toc:[]},gi="wrapper";function fi(e){let{components:n,...t}=e;return(0,s.yg)(gi,(0,p.A)({},hi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the callback function."))}fi.isMDXComponent=!0;const Di={toc:[]},Mi="wrapper";function Xi(e){let{components:n,...t}=e;return(0,s.yg)(Mi,(0,p.A)({},Di,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Xi.isMDXComponent=!0;const _i={toc:[]},wi="wrapper";function Ti(e){let{components:n,...t}=e;return(0,s.yg)(wi,(0,p.A)({},_i,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Ti.isMDXComponent=!0;const Ci={toc:[]},xi="wrapper";function Ai(e){let{components:n,...t}=e;return(0,s.yg)(xi,(0,p.A)({},Ci,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the most recent value of this dispatcher."))}Ai.isMDXComponent=!0;const vi={toc:[]},Li="wrapper";function bi(e){let{components:n,...t}=e;return(0,s.yg)(Li,(0,p.A)({},vi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}bi.isMDXComponent=!0;const Ni={toc:[]},ki="wrapper";function zi(e){let{components:n,...t}=e;return(0,s.yg)(ki,(0,p.A)({},Ni,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}zi.isMDXComponent=!0;const Pi={toc:[]},Ii="wrapper";function Ri(e){let{components:n,...t}=e;return(0,s.yg)(Ii,(0,p.A)({},Pi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Ri.isMDXComponent=!0;const Wi={toc:[]},Si="wrapper";function Bi(e){let{components:n,...t}=e;return(0,s.yg)(Si,(0,p.A)({},Wi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Bi.isMDXComponent=!0;const Gi={toc:[]},Ei="wrapper";function Oi(e){let{components:n,...t}=e;return(0,s.yg)(Ei,(0,p.A)({},Gi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}Oi.isMDXComponent=!0;const Ui={toc:[]},Fi="wrapper";function Vi(e){let{components:n,...t}=e;return(0,s.yg)(Fi,(0,p.A)({},Ui,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Vi.isMDXComponent=!0;const qi={toc:[]},ji="wrapper";function Hi(e){let{components:n,...t}=e;return(0,s.yg)(ji,(0,p.A)({},qi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Hi.isMDXComponent=!0;const Yi={toc:[]},Qi="wrapper";function $i(e){let{components:n,...t}=e;return(0,s.yg)(Qi,(0,p.A)({},Yi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}$i.isMDXComponent=!0;const Ki={toc:[]},Ji="wrapper";function Zi(e){let{components:n,...t}=e;return(0,s.yg)(Ji,(0,p.A)({},Ki,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value passed to subscribers."))}Zi.isMDXComponent=!0;const el={toc:[]},nl="wrapper";function tl(e){let{components:n,...t}=e;return(0,s.yg)(nl,(0,p.A)({},el,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}tl.isMDXComponent=!0;const ol={toc:[]},pl="wrapper";function rl(e){let{components:n,...t}=e;return(0,s.yg)(pl,(0,p.A)({},ol,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}rl.isMDXComponent=!0;const sl={toc:[]},cl="wrapper";function al(e){let{components:n,...t}=e;return(0,s.yg)(cl,(0,p.A)({},sl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}al.isMDXComponent=!0;const il={toc:[]},ll="wrapper";function ul(e){let{components:n,...t}=e;return(0,s.yg)(ll,(0,p.A)({},il,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value."))}ul.isMDXComponent=!0;const ml={toc:[]},yl="wrapper";function dl(e){let{components:n,...t}=e;return(0,s.yg)(yl,(0,p.A)({},ml,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the most recent value of this dispatcher."))}dl.isMDXComponent=!0;const hl={toc:[]},gl="wrapper";function fl(e){let{components:n,...t}=e;return(0,s.yg)(gl,(0,p.A)({},hl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Setting the value will immediately notify all subscribers."))}fl.isMDXComponent=!0;const Dl={toc:[]},Ml="wrapper";function Xl(e){let{components:n,...t}=e;return(0,s.yg)(Ml,(0,p.A)({},Dl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value of this dispatcher."))}Xl.isMDXComponent=!0;const _l={toc:[]},wl="wrapper";function Tl(e){let{components:n,...t}=e;return(0,s.yg)(wl,(0,p.A)({},_l,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Tl.isMDXComponent=!0;const Cl={toc:[]},xl="wrapper";function Al(e){let{components:n,...t}=e;return(0,s.yg)(xl,(0,p.A)({},Cl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Al.isMDXComponent=!0;const vl={toc:[]},Ll="wrapper";function bl(e){let{components:n,...t}=e;return(0,s.yg)(Ll,(0,p.A)({},vl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}bl.isMDXComponent=!0;const Nl={toc:[]},kl="wrapper";function zl(e){let{components:n,...t}=e;return(0,s.yg)(kl,(0,p.A)({},Nl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}zl.isMDXComponent=!0;const Pl={toc:[]},Il="wrapper";function Rl(e){let{components:n,...t}=e;return(0,s.yg)(Il,(0,p.A)({},Pl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Rl.isMDXComponent=!0;const Wl={toc:[]},Sl="wrapper";function Bl(e){let{components:n,...t}=e;return(0,s.yg)(Sl,(0,p.A)({},Wl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Bl.isMDXComponent=!0;const Gl={toc:[]},El="wrapper";function Ol(e){let{components:n,...t}=e;return(0,s.yg)(El,(0,p.A)({},Gl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Ol.isMDXComponent=!0;const Ul={toc:[]},Fl="wrapper";function Vl(e){let{components:n,...t}=e;return(0,s.yg)(Fl,(0,p.A)({},Ul,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Vl.isMDXComponent=!0;const ql={toc:[]},jl="wrapper";function Hl(e){let{components:n,...t}=e;return(0,s.yg)(jl,(0,p.A)({},ql,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value passed to subscribers."))}Hl.isMDXComponent=!0;const Yl={toc:[]},Ql="wrapper";function $l(e){let{components:n,...t}=e;return(0,s.yg)(Ql,(0,p.A)({},Yl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}$l.isMDXComponent=!0;const Kl={toc:[]},Jl="wrapper";function Zl(e){let{components:n,...t}=e;return(0,s.yg)(Jl,(0,p.A)({},Kl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}Zl.isMDXComponent=!0;const eu={toc:[]},nu="wrapper";function tu(e){let{components:n,...t}=e;return(0,s.yg)(nu,(0,p.A)({},eu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}tu.isMDXComponent=!0;const ou={toc:[]},pu="wrapper";function ru(e){let{components:n,...t}=e;return(0,s.yg)(pu,(0,p.A)({},ou,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ru.isMDXComponent=!0;const su={toc:[]},cu="wrapper";function au(e){let{components:n,...t}=e;return(0,s.yg)(cu,(0,p.A)({},su,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}au.isMDXComponent=!0;const iu={toc:[]},lu="wrapper";function uu(e){let{components:n,...t}=e;return(0,s.yg)(lu,(0,p.A)({},iu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}uu.isMDXComponent=!0;const mu={toc:[]},yu="wrapper";function du(e){let{components:n,...t}=e;return(0,s.yg)(yu,(0,p.A)({},mu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}du.isMDXComponent=!0;const hu={toc:[]},gu="wrapper";function fu(e){let{components:n,...t}=e;return(0,s.yg)(gu,(0,p.A)({},hu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}fu.isMDXComponent=!0;const Du={toc:[]},Mu="wrapper";function Xu(e){let{components:n,...t}=e;return(0,s.yg)(Mu,(0,p.A)({},Du,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Utilities for controlling the flow and timing of an animation."))}Xu.isMDXComponent=!0;const _u={toc:[]},wu="wrapper";function Tu(e){let{components:n,...t}=e;return(0,s.yg)(wu,(0,p.A)({},_u,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback called by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow/EveryTimer"},(0,s.yg)("inlineCode",{parentName:"a"},"EveryTimer"))," every N seconds."))}Tu.isMDXComponent=!0;const Cu={toc:[]},xu="wrapper";function Au(e){let{components:n,...t}=e;return(0,s.yg)(xu,(0,p.A)({},Cu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The amount of times the timer has ticked."))}Au.isMDXComponent=!0;const vu={toc:[]},Lu="wrapper";function bu(e){let{components:n,...t}=e;return(0,s.yg)(Lu,(0,p.A)({},vu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator responsible for running this timer."))}bu.isMDXComponent=!0;const Nu={toc:[]},ku="wrapper";function zu(e){let{components:n,...t}=e;return(0,s.yg)(ku,(0,p.A)({},Nu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait until the timer ticks."))}zu.isMDXComponent=!0;const Pu={toc:[]},Iu="wrapper";function Ru(e){let{components:n,...t}=e;return(0,s.yg)(Iu,(0,p.A)({},Pu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback called by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#loop"},(0,s.yg)("inlineCode",{parentName:"a"},"loop"))," during each iteration."))}Ru.isMDXComponent=!0;const Wu={toc:[]},Su="wrapper";function Bu(e){let{components:n,...t}=e;return(0,s.yg)(Su,(0,p.A)({},Wu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current iteration index."))}Bu.isMDXComponent=!0;const Gu={toc:[]},Eu="wrapper";function Ou(e){let{components:n,...t}=e;return(0,s.yg)(Eu,(0,p.A)({},Gu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Ou.isMDXComponent=!0;const Uu={toc:[]},Fu="wrapper";function Vu(e){let{components:n,...t}=e;return(0,s.yg)(Fu,(0,p.A)({},Uu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Vu.isMDXComponent=!0;const qu={toc:[]},ju="wrapper";function Hu(e){let{components:n,...t}=e;return(0,s.yg)(ju,(0,p.A)({},qu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}Hu.isMDXComponent=!0;const Yu={toc:[]},Qu="wrapper";function $u(e){let{components:n,...t}=e;return(0,s.yg)(Qu,(0,p.A)({},Yu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}$u.isMDXComponent=!0;const Ku={toc:[]},Ju="wrapper";function Zu(e){let{components:n,...t}=e;return(0,s.yg)(Ju,(0,p.A)({},Ku,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Zu.isMDXComponent=!0;const em={toc:[]},nm="wrapper";function tm(e){let{components:n,...t}=e;return(0,s.yg)(nm,(0,p.A)({},em,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}tm.isMDXComponent=!0;const om={toc:[]},pm="wrapper";function rm(e){let{components:n,...t}=e;return(0,s.yg)(pm,(0,p.A)({},om,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.yg)("p",null,"Note that the same animation can be written as:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.yg)("p",null,"The reason ",(0,s.yg)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}rm.isMDXComponent=!0;const sm={toc:[]},cm="wrapper";function am(e){let{components:n,...t}=e;return(0,s.yg)(cm,(0,p.A)({},sm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run tasks one after another."))}am.isMDXComponent=!0;const im={toc:[]},lm="wrapper";function um(e){let{components:n,...t}=e;return(0,s.yg)(lm,(0,p.A)({},im,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}um.isMDXComponent=!0;const mm={toc:[]},ym="wrapper";function dm(e){let{components:n,...t}=e;return(0,s.yg)(ym,(0,p.A)({},mm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.yg)("p",null,"Note that the same animation can be written as:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.yg)("p",null,"The reason ",(0,s.yg)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}dm.isMDXComponent=!0;const hm={toc:[]},gm="wrapper";function fm(e){let{components:n,...t}=e;return(0,s.yg)(gm,(0,p.A)({},hm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator or callback after a specific amount of time."))}fm.isMDXComponent=!0;const Dm={toc:[]},Mm="wrapper";function Xm(e){let{components:n,...t}=e;return(0,s.yg)(Mm,(0,p.A)({},Dm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delay in seconds"))}Xm.isMDXComponent=!0;const _m={toc:[]},wm="wrapper";function Tm(e){let{components:n,...t}=e;return(0,s.yg)(wm,(0,p.A)({},_m,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task or callback to run after the delay."))}Tm.isMDXComponent=!0;const Cm={toc:[]},xm="wrapper";function Am(e){let{components:n,...t}=e;return(0,s.yg)(xm,(0,p.A)({},Cm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}Am.isMDXComponent=!0;const vm={toc:[]},Lm="wrapper";function bm(e){let{components:n,...t}=e;return(0,s.yg)(Lm,(0,p.A)({},vm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Call the given callback every N seconds."))}bm.isMDXComponent=!0;const Nm={toc:[]},km="wrapper";function zm(e){let{components:n,...t}=e;return(0,s.yg)(km,(0,p.A)({},Nm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interval between subsequent calls."))}zm.isMDXComponent=!0;const Pm={toc:[]},Im="wrapper";function Rm(e){let{components:n,...t}=e;return(0,s.yg)(Im,(0,p.A)({},Pm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to be called."))}Rm.isMDXComponent=!0;const Wm={toc:[]},Sm="wrapper";function Bm(e){let{components:n,...t}=e;return(0,s.yg)(Sm,(0,p.A)({},Wm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each iteration waits until the previous one is completed.\nBecause this loop never finishes it cannot be used in the main thread.\nInstead, use ",(0,s.yg)("inlineCode",{parentName:"p"},"yield")," or ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," to run the loop concurrently."))}Bm.isMDXComponent=!0;const Gm={toc:[]},Em="wrapper";function Om(e){let{components:n,...t}=e;return(0,s.yg)(Em,(0,p.A)({},Gm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotate the ",(0,s.yg)("inlineCode",{parentName:"p"},"rect")," indefinitely:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield loop(\n  () => rect.rotation(0).rotation(360, 2, linear),\n);\n")))}Om.isMDXComponent=!0;const Um={toc:[]},Fm="wrapper";function Vm(e){let{components:n,...t}=e;return(0,s.yg)(Fm,(0,p.A)({},Um,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator in a loop."))}Vm.isMDXComponent=!0;const qm={toc:[]},jm="wrapper";function Hm(e){let{components:n,...t}=e;return(0,s.yg)(jm,(0,p.A)({},qm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Hm.isMDXComponent=!0;const Ym={toc:[]},Qm="wrapper";function $m(e){let{components:n,...t}=e;return(0,s.yg)(Qm,(0,p.A)({},Ym,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each iteration waits until the previous one is completed."))}$m.isMDXComponent=!0;const Km={toc:[]},Jm="wrapper";function Zm(e){let{components:n,...t}=e;return(0,s.yg)(Jm,(0,p.A)({},Km,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}Zm.isMDXComponent=!0;const ey={toc:[]},ny="wrapper";function ty(e){let{components:n,...t}=e;return(0,s.yg)(ny,(0,p.A)({},ey,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator N times."))}ty.isMDXComponent=!0;const oy={toc:[]},py="wrapper";function ry(e){let{components:n,...t}=e;return(0,s.yg)(py,(0,p.A)({},oy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of iterations."))}ry.isMDXComponent=!0;const sy={toc:[]},cy="wrapper";function ay(e){let{components:n,...t}=e;return(0,s.yg)(cy,(0,p.A)({},sy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ay.isMDXComponent=!0;const iy={toc:[]},ly="wrapper";function uy(e){let{components:n,...t}=e;return(0,s.yg)(ly,(0,p.A)({},iy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}uy.isMDXComponent=!0;const my={toc:[]},yy="wrapper";function dy(e){let{components:n,...t}=e;return(0,s.yg)(yy,(0,p.A)({},my,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}dy.isMDXComponent=!0;const hy={toc:[]},gy="wrapper";function fy(e){let{components:n,...t}=e;return(0,s.yg)(gy,(0,p.A)({},hy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run a generator in a loop for the given amount of time."))}fy.isMDXComponent=!0;const Dy={toc:[]},My="wrapper";function Xy(e){let{components:n,...t}=e;return(0,s.yg)(My,(0,p.A)({},Dy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration in seconds."))}Xy.isMDXComponent=!0;const _y={toc:[]},wy="wrapper";function Ty(e){let{components:n,...t}=e;return(0,s.yg)(wy,(0,p.A)({},_y,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Ty.isMDXComponent=!0;const Cy={toc:[]},xy="wrapper";function Ay(e){let{components:n,...t}=e;return(0,s.yg)(xy,(0,p.A)({},Cy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Ay.isMDXComponent=!0;const vy={toc:[]},Ly="wrapper";function by(e){let{components:n,...t}=e;return(0,s.yg)(Ly,(0,p.A)({},vy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}by.isMDXComponent=!0;const Ny={toc:[]},ky="wrapper";function zy(e){let{components:n,...t}=e;return(0,s.yg)(ky,(0,p.A)({},Ny,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run a generator in a loop until the given time event."))}zy.isMDXComponent=!0;const Py={toc:[]},Iy="wrapper";function Ry(e){let{components:n,...t}=e;return(0,s.yg)(Iy,(0,p.A)({},Py,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The event."))}Ry.isMDXComponent=!0;const Wy={toc:[]},Sy="wrapper";function By(e){let{components:n,...t}=e;return(0,s.yg)(Sy,(0,p.A)({},Wy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}By.isMDXComponent=!0;const Gy={toc:[]},Ey="wrapper";function Oy(e){let{components:n,...t}=e;return(0,s.yg)(Ey,(0,p.A)({},Gy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Do nothing."))}Oy.isMDXComponent=!0;const Uy={toc:[]},Fy="wrapper";function Vy(e){let{components:n,...t}=e;return(0,s.yg)(Fy,(0,p.A)({},Uy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}Vy.isMDXComponent=!0;const qy={toc:[]},jy="wrapper";function Hy(e){let{components:n,...t}=e;return(0,s.yg)(jy,(0,p.A)({},qy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}Hy.isMDXComponent=!0;const Yy={toc:[]},Qy="wrapper";function $y(e){let{components:n,...t}=e;return(0,s.yg)(Qy,(0,p.A)({},Yy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Turn the given generator function into a task."))}$y.isMDXComponent=!0;const Ky={toc:[]},Jy="wrapper";function Zy(e){let{components:n,...t}=e;return(0,s.yg)(Jy,(0,p.A)({},Ky,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a factory that creates the generator."))}Zy.isMDXComponent=!0;const ed={toc:[]},nd="wrapper";function td(e){let{components:n,...t}=e;return(0,s.yg)(nd,(0,p.A)({},ed,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}td.isMDXComponent=!0;const od={toc:[]},pd="wrapper";function rd(e){let{components:n,...t}=e;return(0,s.yg)(pd,(0,p.A)({},od,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}rd.isMDXComponent=!0;const sd={toc:[]},cd="wrapper";function ad(e){let{components:n,...t}=e;return(0,s.yg)(cd,(0,p.A)({},sd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Turn the given generator function into a task."))}ad.isMDXComponent=!0;const id={toc:[]},ld="wrapper";function ud(e){let{components:n,...t}=e;return(0,s.yg)(ld,(0,p.A)({},id,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional name used when displaying this generator in the UI."))}ud.isMDXComponent=!0;const md={toc:[]},yd="wrapper";function dd(e){let{components:n,...t}=e;return(0,s.yg)(yd,(0,p.A)({},md,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a factory that creates the generator."))}dd.isMDXComponent=!0;const hd={toc:[]},gd="wrapper";function fd(e){let{components:n,...t}=e;return(0,s.yg)(gd,(0,p.A)({},hd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}fd.isMDXComponent=!0;const Dd={toc:[]},Md="wrapper";function Xd(e){let{components:n,...t}=e;return(0,s.yg)(Md,(0,p.A)({},Dd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Xd.isMDXComponent=!0;const _d={toc:[]},wd="wrapper";function Td(e){let{components:n,...t}=e;return(0,s.yg)(wd,(0,p.A)({},_d,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Start all tasks one after another with a constant delay between."))}Td.isMDXComponent=!0;const Cd={toc:[]},xd="wrapper";function Ad(e){let{components:n,...t}=e;return(0,s.yg)(xd,(0,p.A)({},Cd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delay between each of the tasks."))}Ad.isMDXComponent=!0;const vd={toc:[]},Ld="wrapper";function bd(e){let{components:n,...t}=e;return(0,s.yg)(Ld,(0,p.A)({},vd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to be run in a sequence."))}bd.isMDXComponent=!0;const Nd={toc:[]},kd="wrapper";function zd(e){let{components:n,...t}=e;return(0,s.yg)(kd,(0,p.A)({},Nd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}zd.isMDXComponent=!0;const Pd={toc:[]},Id="wrapper";function Rd(e){let{components:n,...t}=e;return(0,s.yg)(Id,(0,p.A)({},Pd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for the given amount of time."))}Rd.isMDXComponent=!0;const Wd={toc:[]},Sd="wrapper";function Bd(e){let{components:n,...t}=e;return(0,s.yg)(Sd,(0,p.A)({},Wd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The relative time in seconds."))}Bd.isMDXComponent=!0;const Gd={toc:[]},Ed="wrapper";function Od(e){let{components:n,...t}=e;return(0,s.yg)(Ed,(0,p.A)({},Gd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional task to be run after the function completes."))}Od.isMDXComponent=!0;const Ud={toc:[]},Fd="wrapper";function Vd(e){let{components:n,...t}=e;return(0,s.yg)(Fd,(0,p.A)({},Ud,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}Vd.isMDXComponent=!0;const qd={toc:[]},jd="wrapper";function Hd(e){let{components:n,...t}=e;return(0,s.yg)(jd,(0,p.A)({},qd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}Hd.isMDXComponent=!0;const Yd={toc:[]},Qd="wrapper";function $d(e){let{components:n,...t}=e;return(0,s.yg)(Qd,(0,p.A)({},Yd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait until the given time event."))}$d.isMDXComponent=!0;const Kd={toc:[]},Jd="wrapper";function Zd(e){let{components:n,...t}=e;return(0,s.yg)(Jd,(0,p.A)({},Kd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the time event."))}Zd.isMDXComponent=!0;const eh={toc:[]},nh="wrapper";function th(e){let{components:n,...t}=e;return(0,s.yg)(nh,(0,p.A)({},eh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional task to be run after the function completes."))}th.isMDXComponent=!0;const oh={toc:[]},ph="wrapper";function rh(e){let{components:n,...t}=e;return(0,s.yg)(ph,(0,p.A)({},oh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Multi-media management."))}rh.isMDXComponent=!0;const sh={toc:[]},ch="wrapper";function ah(e){let{components:n,...t}=e;return(0,s.yg)(ch,(0,p.A)({},sh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}ah.isMDXComponent=!0;const ih={toc:[]},lh="wrapper";function uh(e){let{components:n,...t}=e;return(0,s.yg)(lh,(0,p.A)({},ih,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause/resume the audio."))}uh.isMDXComponent=!0;const mh={toc:[]},yh="wrapper";function dh(e){let{components:n,...t}=e;return(0,s.yg)(yh,(0,p.A)({},mh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the audio should be paused or resumed."))}dh.isMDXComponent=!0;const hh={toc:[]},gh="wrapper";function fh(e){let{components:n,...t}=e;return(0,s.yg)(gh,(0,p.A)({},hh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The absolute biggest value from the peaks array."))}fh.isMDXComponent=!0;const Dh={toc:[]},Mh="wrapper";function Xh(e){let{components:n,...t}=e;return(0,s.yg)(Mh,(0,p.A)({},Dh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The amount of samples taken."))}Xh.isMDXComponent=!0;const _h={toc:[]},wh="wrapper";function Th(e){let{components:n,...t}=e;return(0,s.yg)(wh,(0,p.A)({},_h,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Th.isMDXComponent=!0;const Ch={toc:[]},xh="wrapper";function Ah(e){let{components:n,...t}=e;return(0,s.yg)(xh,(0,p.A)({},Ch,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Samples per seconds."))}Ah.isMDXComponent=!0;const vh={toc:[]},Lh="wrapper";function bh(e){let{components:n,...t}=e;return(0,s.yg)(Lh,(0,p.A)({},vh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The runtime representation of meta files."))}bh.isMDXComponent=!0;const Nh={toc:[]},kh="wrapper";function zh(e){let{components:n,...t}=e;return(0,s.yg)(kh,(0,p.A)({},Nh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a boolean value stored in a meta file."))}zh.isMDXComponent=!0;const Ph={toc:[]},Ih="wrapper";function Rh(e){let{components:n,...t}=e;return(0,s.yg)(Ih,(0,p.A)({},Ph,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Rh.isMDXComponent=!0;const Wh={toc:[]},Sh="wrapper";function Bh(e){let{components:n,...t}=e;return(0,s.yg)(Sh,(0,p.A)({},Wh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Bh.isMDXComponent=!0;const Gh={toc:[]},Eh="wrapper";function Oh(e){let{components:n,...t}=e;return(0,s.yg)(Eh,(0,p.A)({},Gh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Oh.isMDXComponent=!0;const Uh={toc:[]},Fh="wrapper";function Vh(e){let{components:n,...t}=e;return(0,s.yg)(Fh,(0,p.A)({},Uh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Vh.isMDXComponent=!0;const qh={toc:[]},jh="wrapper";function Hh(e){let{components:n,...t}=e;return(0,s.yg)(jh,(0,p.A)({},qh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}Hh.isMDXComponent=!0;const Yh={toc:[]},Qh="wrapper";function $h(e){let{components:n,...t}=e;return(0,s.yg)(Qh,(0,p.A)({},Yh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}$h.isMDXComponent=!0;const Kh={toc:[]},Jh="wrapper";function Zh(e){let{components:n,...t}=e;return(0,s.yg)(Jh,(0,p.A)({},Kh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}Zh.isMDXComponent=!0;const eg={toc:[]},ng="wrapper";function tg(e){let{components:n,...t}=e;return(0,s.yg)(ng,(0,p.A)({},eg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}tg.isMDXComponent=!0;const og={toc:[]},pg="wrapper";function rg(e){let{components:n,...t}=e;return(0,s.yg)(pg,(0,p.A)({},og,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}rg.isMDXComponent=!0;const sg={toc:[]},cg="wrapper";function ag(e){let{components:n,...t}=e;return(0,s.yg)(cg,(0,p.A)({},sg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}ag.isMDXComponent=!0;const ig={toc:[]},lg="wrapper";function ug(e){let{components:n,...t}=e;return(0,s.yg)(lg,(0,p.A)({},ig,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}ug.isMDXComponent=!0;const mg={toc:[]},yg="wrapper";function dg(e){let{components:n,...t}=e;return(0,s.yg)(yg,(0,p.A)({},mg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}dg.isMDXComponent=!0;const hg={toc:[]},gg="wrapper";function fg(e){let{components:n,...t}=e;return(0,s.yg)(gg,(0,p.A)({},hg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}fg.isMDXComponent=!0;const Dg={toc:[]},Mg="wrapper";function Xg(e){let{components:n,...t}=e;return(0,s.yg)(Mg,(0,p.A)({},Dg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Xg.isMDXComponent=!0;const _g={toc:[]},wg="wrapper";function Tg(e){let{components:n,...t}=e;return(0,s.yg)(wg,(0,p.A)({},_g,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Tg.isMDXComponent=!0;const Cg={toc:[]},xg="wrapper";function Ag(e){let{components:n,...t}=e;return(0,s.yg)(xg,(0,p.A)({},Cg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}Ag.isMDXComponent=!0;const vg={toc:[]},Lg="wrapper";function bg(e){let{components:n,...t}=e;return(0,s.yg)(Lg,(0,p.A)({},vg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}bg.isMDXComponent=!0;const Ng={toc:[]},kg="wrapper";function zg(e){let{components:n,...t}=e;return(0,s.yg)(kg,(0,p.A)({},Ng,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}zg.isMDXComponent=!0;const Pg={toc:[]},Ig="wrapper";function Rg(e){let{components:n,...t}=e;return(0,s.yg)(Ig,(0,p.A)({},Pg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Rg.isMDXComponent=!0;const Wg={toc:[]},Sg="wrapper";function Bg(e){let{components:n,...t}=e;return(0,s.yg)(Sg,(0,p.A)({},Wg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Bg.isMDXComponent=!0;const Gg={toc:[]},Eg="wrapper";function Og(e){let{components:n,...t}=e;return(0,s.yg)(Eg,(0,p.A)({},Gg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a color stored in a meta file."))}Og.isMDXComponent=!0;const Ug={toc:[]},Fg="wrapper";function Vg(e){let{components:n,...t}=e;return(0,s.yg)(Fg,(0,p.A)({},Ug,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Vg.isMDXComponent=!0;const qg={toc:[]},jg="wrapper";function Hg(e){let{components:n,...t}=e;return(0,s.yg)(jg,(0,p.A)({},qg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Hg.isMDXComponent=!0;const Yg={toc:[]},Qg="wrapper";function $g(e){let{components:n,...t}=e;return(0,s.yg)(Qg,(0,p.A)({},Yg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}$g.isMDXComponent=!0;const Kg={toc:[]},Jg="wrapper";function Zg(e){let{components:n,...t}=e;return(0,s.yg)(Jg,(0,p.A)({},Kg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Zg.isMDXComponent=!0;const ef={toc:[]},nf="wrapper";function tf(e){let{components:n,...t}=e;return(0,s.yg)(nf,(0,p.A)({},ef,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}tf.isMDXComponent=!0;const of={toc:[]},pf="wrapper";function rf(e){let{components:n,...t}=e;return(0,s.yg)(pf,(0,p.A)({},of,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}rf.isMDXComponent=!0;const sf={toc:[]},cf="wrapper";function af(e){let{components:n,...t}=e;return(0,s.yg)(cf,(0,p.A)({},sf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}af.isMDXComponent=!0;const lf={toc:[]},uf="wrapper";function mf(e){let{components:n,...t}=e;return(0,s.yg)(uf,(0,p.A)({},lf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}mf.isMDXComponent=!0;const yf={toc:[]},df="wrapper";function hf(e){let{components:n,...t}=e;return(0,s.yg)(df,(0,p.A)({},yf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}hf.isMDXComponent=!0;const gf={toc:[]},ff="wrapper";function Df(e){let{components:n,...t}=e;return(0,s.yg)(ff,(0,p.A)({},gf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}Df.isMDXComponent=!0;const Mf={toc:[]},Xf="wrapper";function _f(e){let{components:n,...t}=e;return(0,s.yg)(Xf,(0,p.A)({},Mf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}_f.isMDXComponent=!0;const wf={toc:[]},Tf="wrapper";function Cf(e){let{components:n,...t}=e;return(0,s.yg)(Tf,(0,p.A)({},wf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Cf.isMDXComponent=!0;const xf={toc:[]},Af="wrapper";function vf(e){let{components:n,...t}=e;return(0,s.yg)(Af,(0,p.A)({},xf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}vf.isMDXComponent=!0;const Lf={toc:[]},bf="wrapper";function Nf(e){let{components:n,...t}=e;return(0,s.yg)(bf,(0,p.A)({},Lf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Nf.isMDXComponent=!0;const kf={toc:[]},zf="wrapper";function Pf(e){let{components:n,...t}=e;return(0,s.yg)(zf,(0,p.A)({},kf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Pf.isMDXComponent=!0;const If={toc:[]},Rf="wrapper";function Wf(e){let{components:n,...t}=e;return(0,s.yg)(Rf,(0,p.A)({},If,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}Wf.isMDXComponent=!0;const Sf={toc:[]},Bf="wrapper";function Gf(e){let{components:n,...t}=e;return(0,s.yg)(Bf,(0,p.A)({},Sf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Gf.isMDXComponent=!0;const Ef={toc:[]},Of="wrapper";function Uf(e){let{components:n,...t}=e;return(0,s.yg)(Of,(0,p.A)({},Ef,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Uf.isMDXComponent=!0;const Ff={toc:[]},Vf="wrapper";function qf(e){let{components:n,...t}=e;return(0,s.yg)(Vf,(0,p.A)({},Ff,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}qf.isMDXComponent=!0;const jf={toc:[]},Hf="wrapper";function Yf(e){let{components:n,...t}=e;return(0,s.yg)(Hf,(0,p.A)({},jf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Yf.isMDXComponent=!0;const Qf={toc:[]},$f="wrapper";function Kf(e){let{components:n,...t}=e;return(0,s.yg)($f,(0,p.A)({},Qf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an enum value stored in a meta file."))}Kf.isMDXComponent=!0;const Jf={toc:[]},Zf="wrapper";function eD(e){let{components:n,...t}=e;return(0,s.yg)(Zf,(0,p.A)({},Jf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}eD.isMDXComponent=!0;const nD={toc:[]},tD="wrapper";function oD(e){let{components:n,...t}=e;return(0,s.yg)(tD,(0,p.A)({},nD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}oD.isMDXComponent=!0;const pD={toc:[]},rD="wrapper";function sD(e){let{components:n,...t}=e;return(0,s.yg)(rD,(0,p.A)({},pD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}sD.isMDXComponent=!0;const cD={toc:[]},aD="wrapper";function iD(e){let{components:n,...t}=e;return(0,s.yg)(aD,(0,p.A)({},cD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}iD.isMDXComponent=!0;const lD={toc:[]},uD="wrapper";function mD(e){let{components:n,...t}=e;return(0,s.yg)(uD,(0,p.A)({},lD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}mD.isMDXComponent=!0;const yD={toc:[]},dD="wrapper";function hD(e){let{components:n,...t}=e;return(0,s.yg)(dD,(0,p.A)({},yD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}hD.isMDXComponent=!0;const gD={toc:[]},fD="wrapper";function DD(e){let{components:n,...t}=e;return(0,s.yg)(fD,(0,p.A)({},gD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}DD.isMDXComponent=!0;const MD={toc:[]},XD="wrapper";function _D(e){let{components:n,...t}=e;return(0,s.yg)(XD,(0,p.A)({},MD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}_D.isMDXComponent=!0;const wD={toc:[]},TD="wrapper";function CD(e){let{components:n,...t}=e;return(0,s.yg)(TD,(0,p.A)({},wD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}CD.isMDXComponent=!0;const xD={toc:[]},AD="wrapper";function vD(e){let{components:n,...t}=e;return(0,s.yg)(AD,(0,p.A)({},xD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}vD.isMDXComponent=!0;const LD={toc:[]},bD="wrapper";function ND(e){let{components:n,...t}=e;return(0,s.yg)(bD,(0,p.A)({},LD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}ND.isMDXComponent=!0;const kD={toc:[]},zD="wrapper";function PD(e){let{components:n,...t}=e;return(0,s.yg)(zD,(0,p.A)({},kD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}PD.isMDXComponent=!0;const ID={toc:[]},RD="wrapper";function WD(e){let{components:n,...t}=e;return(0,s.yg)(RD,(0,p.A)({},ID,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}WD.isMDXComponent=!0;const SD={toc:[]},BD="wrapper";function GD(e){let{components:n,...t}=e;return(0,s.yg)(BD,(0,p.A)({},SD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}GD.isMDXComponent=!0;const ED={toc:[]},OD="wrapper";function UD(e){let{components:n,...t}=e;return(0,s.yg)(OD,(0,p.A)({},ED,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}UD.isMDXComponent=!0;const FD={toc:[]},VD="wrapper";function qD(e){let{components:n,...t}=e;return(0,s.yg)(VD,(0,p.A)({},FD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}qD.isMDXComponent=!0;const jD={toc:[]},HD="wrapper";function YD(e){let{components:n,...t}=e;return(0,s.yg)(HD,(0,p.A)({},jD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}YD.isMDXComponent=!0;const QD={toc:[]},$D="wrapper";function KD(e){let{components:n,...t}=e;return(0,s.yg)($D,(0,p.A)({},QD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}KD.isMDXComponent=!0;const JD={toc:[]},ZD="wrapper";function eM(e){let{components:n,...t}=e;return(0,s.yg)(ZD,(0,p.A)({},JD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the exporter configuration."))}eM.isMDXComponent=!0;const nM={toc:[]},tM="wrapper";function oM(e){let{components:n,...t}=e;return(0,s.yg)(tM,(0,p.A)({},nM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}oM.isMDXComponent=!0;const pM={toc:[]},rM="wrapper";function sM(e){let{components:n,...t}=e;return(0,s.yg)(rM,(0,p.A)({},pM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}sM.isMDXComponent=!0;const cM={toc:[]},aM="wrapper";function iM(e){let{components:n,...t}=e;return(0,s.yg)(aM,(0,p.A)({},cM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}iM.isMDXComponent=!0;const lM={toc:[]},uM="wrapper";function mM(e){let{components:n,...t}=e;return(0,s.yg)(uM,(0,p.A)({},lM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}mM.isMDXComponent=!0;const yM={toc:[]},dM="wrapper";function hM(e){let{components:n,...t}=e;return(0,s.yg)(dM,(0,p.A)({},yM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}hM.isMDXComponent=!0;const gM={toc:[]},fM="wrapper";function DM(e){let{components:n,...t}=e;return(0,s.yg)(fM,(0,p.A)({},gM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the nested fields change."))}DM.isMDXComponent=!0;const MM={toc:[]},XM="wrapper";function _M(e){let{components:n,...t}=e;return(0,s.yg)(XM,(0,p.A)({},MM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}_M.isMDXComponent=!0;const wM={toc:[]},TM="wrapper";function CM(e){let{components:n,...t}=e;return(0,s.yg)(TM,(0,p.A)({},wM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}CM.isMDXComponent=!0;const xM={toc:[]},AM="wrapper";function vM(e){let{components:n,...t}=e;return(0,s.yg)(AM,(0,p.A)({},xM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}vM.isMDXComponent=!0;const LM={toc:[]},bM="wrapper";function NM(e){let{components:n,...t}=e;return(0,s.yg)(bM,(0,p.A)({},LM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}NM.isMDXComponent=!0;const kM={toc:[]},zM="wrapper";function PM(e){let{components:n,...t}=e;return(0,s.yg)(zM,(0,p.A)({},kM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}PM.isMDXComponent=!0;const IM={toc:[]},RM="wrapper";function WM(e){let{components:n,...t}=e;return(0,s.yg)(RM,(0,p.A)({},IM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}WM.isMDXComponent=!0;const SM={toc:[]},BM="wrapper";function GM(e){let{components:n,...t}=e;return(0,s.yg)(BM,(0,p.A)({},SM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}GM.isMDXComponent=!0;const EM={toc:[]},OM="wrapper";function UM(e){let{components:n,...t}=e;return(0,s.yg)(OM,(0,p.A)({},EM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}UM.isMDXComponent=!0;const FM={toc:[]},VM="wrapper";function qM(e){let{components:n,...t}=e;return(0,s.yg)(VM,(0,p.A)({},FM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}qM.isMDXComponent=!0;const jM={toc:[]},HM="wrapper";function YM(e){let{components:n,...t}=e;return(0,s.yg)(HM,(0,p.A)({},jM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}YM.isMDXComponent=!0;const QM={toc:[]},$M="wrapper";function KM(e){let{components:n,...t}=e;return(0,s.yg)($M,(0,p.A)({},QM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}KM.isMDXComponent=!0;const JM={toc:[]},ZM="wrapper";function eX(e){let{components:n,...t}=e;return(0,s.yg)(ZM,(0,p.A)({},JM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}eX.isMDXComponent=!0;const nX={toc:[]},tX="wrapper";function oX(e){let{components:n,...t}=e;return(0,s.yg)(tX,(0,p.A)({},nX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}oX.isMDXComponent=!0;const pX={toc:[]},rX="wrapper";function sX(e){let{components:n,...t}=e;return(0,s.yg)(rX,(0,p.A)({},pX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an entry in the meta file."))}sX.isMDXComponent=!0;const cX={toc:[]},aX="wrapper";function iX(e){let{components:n,...t}=e;return(0,s.yg)(aX,(0,p.A)({},cX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}iX.isMDXComponent=!0;const lX={toc:[]},uX="wrapper";function mX(e){let{components:n,...t}=e;return(0,s.yg)(uX,(0,p.A)({},lX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}mX.isMDXComponent=!0;const yX={toc:[]},dX="wrapper";function hX(e){let{components:n,...t}=e;return(0,s.yg)(dX,(0,p.A)({},yX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}hX.isMDXComponent=!0;const gX={toc:[]},fX="wrapper";function DX(e){let{components:n,...t}=e;return(0,s.yg)(fX,(0,p.A)({},gX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}DX.isMDXComponent=!0;const MX={toc:[]},XX="wrapper";function _X(e){let{components:n,...t}=e;return(0,s.yg)(XX,(0,p.A)({},MX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}_X.isMDXComponent=!0;const wX={toc:[]},TX="wrapper";function CX(e){let{components:n,...t}=e;return(0,s.yg)(TX,(0,p.A)({},wX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}CX.isMDXComponent=!0;const xX={toc:[]},AX="wrapper";function vX(e){let{components:n,...t}=e;return(0,s.yg)(AX,(0,p.A)({},xX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}vX.isMDXComponent=!0;const LX={toc:[]},bX="wrapper";function NX(e){let{components:n,...t}=e;return(0,s.yg)(bX,(0,p.A)({},LX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}NX.isMDXComponent=!0;const kX={toc:[]},zX="wrapper";function PX(e){let{components:n,...t}=e;return(0,s.yg)(zX,(0,p.A)({},kX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}PX.isMDXComponent=!0;const IX={toc:[]},RX="wrapper";function WX(e){let{components:n,...t}=e;return(0,s.yg)(RX,(0,p.A)({},IX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}WX.isMDXComponent=!0;const SX={toc:[]},BX="wrapper";function GX(e){let{components:n,...t}=e;return(0,s.yg)(BX,(0,p.A)({},SX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}GX.isMDXComponent=!0;const EX={toc:[]},OX="wrapper";function UX(e){let{components:n,...t}=e;return(0,s.yg)(OX,(0,p.A)({},EX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}UX.isMDXComponent=!0;const FX={toc:[]},VX="wrapper";function qX(e){let{components:n,...t}=e;return(0,s.yg)(VX,(0,p.A)({},FX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}qX.isMDXComponent=!0;const jX={toc:[]},HX="wrapper";function YX(e){let{components:n,...t}=e;return(0,s.yg)(HX,(0,p.A)({},jX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}YX.isMDXComponent=!0;const QX={toc:[]},$X="wrapper";function KX(e){let{components:n,...t}=e;return(0,s.yg)($X,(0,p.A)({},QX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}KX.isMDXComponent=!0;const JX={toc:[]},ZX="wrapper";function e_(e){let{components:n,...t}=e;return(0,s.yg)(ZX,(0,p.A)({},JX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}e_.isMDXComponent=!0;const n_={toc:[]},t_="wrapper";function o_(e){let{components:n,...t}=e;return(0,s.yg)(t_,(0,p.A)({},n_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}o_.isMDXComponent=!0;const p_={toc:[]},r_="wrapper";function s_(e){let{components:n,...t}=e;return(0,s.yg)(r_,(0,p.A)({},p_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}s_.isMDXComponent=!0;const c_={toc:[]},a_="wrapper";function i_(e){let{components:n,...t}=e;return(0,s.yg)(a_,(0,p.A)({},c_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}i_.isMDXComponent=!0;const l_={toc:[]},u_="wrapper";function m_(e){let{components:n,...t}=e;return(0,s.yg)(u_,(0,p.A)({},l_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}m_.isMDXComponent=!0;const y_={toc:[]},d_="wrapper";function h_(e){let{components:n,...t}=e;return(0,s.yg)(d_,(0,p.A)({},y_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type used to store this field in the meta\nfile."))}h_.isMDXComponent=!0;const g_={toc:[]},f_="wrapper";function D_(e){let{components:n,...t}=e;return(0,s.yg)(f_,(0,p.A)({},g_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The runtime type of this field."))}D_.isMDXComponent=!0;const M_={toc:[]},X_="wrapper";function __(e){let{components:n,...t}=e;return(0,s.yg)(X_,(0,p.A)({},M_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a number stored in a meta file."))}__.isMDXComponent=!0;const w_={toc:[]},T_="wrapper";function C_(e){let{components:n,...t}=e;return(0,s.yg)(T_,(0,p.A)({},w_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}C_.isMDXComponent=!0;const x_={toc:[]},A_="wrapper";function v_(e){let{components:n,...t}=e;return(0,s.yg)(A_,(0,p.A)({},x_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}v_.isMDXComponent=!0;const L_={toc:[]},b_="wrapper";function N_(e){let{components:n,...t}=e;return(0,s.yg)(b_,(0,p.A)({},L_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}N_.isMDXComponent=!0;const k_={toc:[]},z_="wrapper";function P_(e){let{components:n,...t}=e;return(0,s.yg)(z_,(0,p.A)({},k_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}P_.isMDXComponent=!0;const I_={toc:[]},R_="wrapper";function W_(e){let{components:n,...t}=e;return(0,s.yg)(R_,(0,p.A)({},I_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}W_.isMDXComponent=!0;const S_={toc:[]},B_="wrapper";function G_(e){let{components:n,...t}=e;return(0,s.yg)(B_,(0,p.A)({},S_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}G_.isMDXComponent=!0;const E_={toc:[]},O_="wrapper";function U_(e){let{components:n,...t}=e;return(0,s.yg)(O_,(0,p.A)({},E_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}U_.isMDXComponent=!0;const F_={toc:[]},V_="wrapper";function q_(e){let{components:n,...t}=e;return(0,s.yg)(V_,(0,p.A)({},F_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}q_.isMDXComponent=!0;const j_={toc:[]},H_="wrapper";function Y_(e){let{components:n,...t}=e;return(0,s.yg)(H_,(0,p.A)({},j_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}Y_.isMDXComponent=!0;const Q_={toc:[]},$_="wrapper";function K_(e){let{components:n,...t}=e;return(0,s.yg)($_,(0,p.A)({},Q_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}K_.isMDXComponent=!0;const J_={toc:[]},Z_="wrapper";function ew(e){let{components:n,...t}=e;return(0,s.yg)(Z_,(0,p.A)({},J_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}ew.isMDXComponent=!0;const nw={toc:[]},tw="wrapper";function ow(e){let{components:n,...t}=e;return(0,s.yg)(tw,(0,p.A)({},nw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}ow.isMDXComponent=!0;const pw={toc:[]},rw="wrapper";function sw(e){let{components:n,...t}=e;return(0,s.yg)(rw,(0,p.A)({},pw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}sw.isMDXComponent=!0;const cw={toc:[]},aw="wrapper";function iw(e){let{components:n,...t}=e;return(0,s.yg)(aw,(0,p.A)({},cw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}iw.isMDXComponent=!0;const lw={toc:[]},uw="wrapper";function mw(e){let{components:n,...t}=e;return(0,s.yg)(uw,(0,p.A)({},lw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}mw.isMDXComponent=!0;const yw={toc:[]},dw="wrapper";function hw(e){let{components:n,...t}=e;return(0,s.yg)(dw,(0,p.A)({},yw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}hw.isMDXComponent=!0;const gw={toc:[]},fw="wrapper";function Dw(e){let{components:n,...t}=e;return(0,s.yg)(fw,(0,p.A)({},gw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Dw.isMDXComponent=!0;const Mw={toc:[]},Xw="wrapper";function _w(e){let{components:n,...t}=e;return(0,s.yg)(Xw,(0,p.A)({},Mw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}_w.isMDXComponent=!0;const ww={toc:[]},Tw="wrapper";function Cw(e){let{components:n,...t}=e;return(0,s.yg)(Tw,(0,p.A)({},ww,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Cw.isMDXComponent=!0;const xw={toc:[]},Aw="wrapper";function vw(e){let{components:n,...t}=e;return(0,s.yg)(Aw,(0,p.A)({},xw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}vw.isMDXComponent=!0;const Lw={toc:[]},bw="wrapper";function Nw(e){let{components:n,...t}=e;return(0,s.yg)(bw,(0,p.A)({},Lw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}Nw.isMDXComponent=!0;const kw={toc:[]},zw="wrapper";function Pw(e){let{components:n,...t}=e;return(0,s.yg)(zw,(0,p.A)({},kw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a range stored in a meta file."))}Pw.isMDXComponent=!0;const Iw={toc:[]},Rw="wrapper";function Ww(e){let{components:n,...t}=e;return(0,s.yg)(Rw,(0,p.A)({},Iw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Ww.isMDXComponent=!0;const Sw={toc:[]},Bw="wrapper";function Gw(e){let{components:n,...t}=e;return(0,s.yg)(Bw,(0,p.A)({},Sw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Gw.isMDXComponent=!0;const Ew={toc:[]},Ow="wrapper";function Uw(e){let{components:n,...t}=e;return(0,s.yg)(Ow,(0,p.A)({},Ew,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Uw.isMDXComponent=!0;const Fw={toc:[]},Vw="wrapper";function qw(e){let{components:n,...t}=e;return(0,s.yg)(Vw,(0,p.A)({},Fw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}qw.isMDXComponent=!0;const jw={toc:[]},Hw="wrapper";function Yw(e){let{components:n,...t}=e;return(0,s.yg)(Hw,(0,p.A)({},jw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}Yw.isMDXComponent=!0;const Qw={toc:[]},$w="wrapper";function Kw(e){let{components:n,...t}=e;return(0,s.yg)($w,(0,p.A)({},Qw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}Kw.isMDXComponent=!0;const Jw={toc:[]},Zw="wrapper";function eT(e){let{components:n,...t}=e;return(0,s.yg)(Zw,(0,p.A)({},Jw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}eT.isMDXComponent=!0;const nT={toc:[]},tT="wrapper";function oT(e){let{components:n,...t}=e;return(0,s.yg)(tT,(0,p.A)({},nT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}oT.isMDXComponent=!0;const pT={toc:[]},rT="wrapper";function sT(e){let{components:n,...t}=e;return(0,s.yg)(rT,(0,p.A)({},pT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}sT.isMDXComponent=!0;const cT={toc:[]},aT="wrapper";function iT(e){let{components:n,...t}=e;return(0,s.yg)(aT,(0,p.A)({},cT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}iT.isMDXComponent=!0;const lT={toc:[]},uT="wrapper";function mT(e){let{components:n,...t}=e;return(0,s.yg)(uT,(0,p.A)({},lT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}mT.isMDXComponent=!0;const yT={toc:[]},dT="wrapper";function hT(e){let{components:n,...t}=e;return(0,s.yg)(dT,(0,p.A)({},yT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}hT.isMDXComponent=!0;const gT={toc:[]},fT="wrapper";function DT(e){let{components:n,...t}=e;return(0,s.yg)(fT,(0,p.A)({},gT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}DT.isMDXComponent=!0;const MT={toc:[]},XT="wrapper";function _T(e){let{components:n,...t}=e;return(0,s.yg)(XT,(0,p.A)({},MT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}_T.isMDXComponent=!0;const wT={toc:[]},TT="wrapper";function CT(e){let{components:n,...t}=e;return(0,s.yg)(TT,(0,p.A)({},wT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}CT.isMDXComponent=!0;const xT={toc:[]},AT="wrapper";function vT(e){let{components:n,...t}=e;return(0,s.yg)(AT,(0,p.A)({},xT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}vT.isMDXComponent=!0;const LT={toc:[]},bT="wrapper";function NT(e){let{components:n,...t}=e;return(0,s.yg)(bT,(0,p.A)({},LT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}NT.isMDXComponent=!0;const kT={toc:[]},zT="wrapper";function PT(e){let{components:n,...t}=e;return(0,s.yg)(zT,(0,p.A)({},kT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}PT.isMDXComponent=!0;const IT={toc:[]},RT="wrapper";function WT(e){let{components:n,...t}=e;return(0,s.yg)(RT,(0,p.A)({},IT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}WT.isMDXComponent=!0;const ST={toc:[]},BT="wrapper";function GT(e){let{components:n,...t}=e;return(0,s.yg)(BT,(0,p.A)({},ST,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}GT.isMDXComponent=!0;const ET={toc:[]},OT="wrapper";function UT(e){let{components:n,...t}=e;return(0,s.yg)(OT,(0,p.A)({},ET,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}UT.isMDXComponent=!0;const FT={toc:[]},VT="wrapper";function qT(e){let{components:n,...t}=e;return(0,s.yg)(VT,(0,p.A)({},FT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert the given range from frames to seconds and update this field."))}qT.isMDXComponent=!0;const jT={toc:[]},HT="wrapper";function YT(e){let{components:n,...t}=e;return(0,s.yg)(HT,(0,p.A)({},jT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The beginning of the range."))}YT.isMDXComponent=!0;const QT={toc:[]},$T="wrapper";function KT(e){let{components:n,...t}=e;return(0,s.yg)($T,(0,p.A)({},QT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}KT.isMDXComponent=!0;const JT={toc:[]},ZT="wrapper";function eC(e){let{components:n,...t}=e;return(0,s.yg)(ZT,(0,p.A)({},JT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current duration in frames."))}eC.isMDXComponent=!0;const nC={toc:[]},tC="wrapper";function oC(e){let{components:n,...t}=e;return(0,s.yg)(tC,(0,p.A)({},nC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current framerate."))}oC.isMDXComponent=!0;const pC={toc:[]},rC="wrapper";function sC(e){let{components:n,...t}=e;return(0,s.yg)(rC,(0,p.A)({},pC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a string stored in a meta file."))}sC.isMDXComponent=!0;const cC={toc:[]},aC="wrapper";function iC(e){let{components:n,...t}=e;return(0,s.yg)(aC,(0,p.A)({},cC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}iC.isMDXComponent=!0;const lC={toc:[]},uC="wrapper";function mC(e){let{components:n,...t}=e;return(0,s.yg)(uC,(0,p.A)({},lC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}mC.isMDXComponent=!0;const yC={toc:[]},dC="wrapper";function hC(e){let{components:n,...t}=e;return(0,s.yg)(dC,(0,p.A)({},yC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}hC.isMDXComponent=!0;const gC={toc:[]},fC="wrapper";function DC(e){let{components:n,...t}=e;return(0,s.yg)(fC,(0,p.A)({},gC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}DC.isMDXComponent=!0;const MC={toc:[]},XC="wrapper";function _C(e){let{components:n,...t}=e;return(0,s.yg)(XC,(0,p.A)({},MC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}_C.isMDXComponent=!0;const wC={toc:[]},TC="wrapper";function CC(e){let{components:n,...t}=e;return(0,s.yg)(TC,(0,p.A)({},wC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}CC.isMDXComponent=!0;const xC={toc:[]},AC="wrapper";function vC(e){let{components:n,...t}=e;return(0,s.yg)(AC,(0,p.A)({},xC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}vC.isMDXComponent=!0;const LC={toc:[]},bC="wrapper";function NC(e){let{components:n,...t}=e;return(0,s.yg)(bC,(0,p.A)({},LC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}NC.isMDXComponent=!0;const kC={toc:[]},zC="wrapper";function PC(e){let{components:n,...t}=e;return(0,s.yg)(zC,(0,p.A)({},kC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}PC.isMDXComponent=!0;const IC={toc:[]},RC="wrapper";function WC(e){let{components:n,...t}=e;return(0,s.yg)(RC,(0,p.A)({},IC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}WC.isMDXComponent=!0;const SC={toc:[]},BC="wrapper";function GC(e){let{components:n,...t}=e;return(0,s.yg)(BC,(0,p.A)({},SC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}GC.isMDXComponent=!0;const EC={toc:[]},OC="wrapper";function UC(e){let{components:n,...t}=e;return(0,s.yg)(OC,(0,p.A)({},EC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}UC.isMDXComponent=!0;const FC={toc:[]},VC="wrapper";function qC(e){let{components:n,...t}=e;return(0,s.yg)(VC,(0,p.A)({},FC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}qC.isMDXComponent=!0;const jC={toc:[]},HC="wrapper";function YC(e){let{components:n,...t}=e;return(0,s.yg)(HC,(0,p.A)({},jC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}YC.isMDXComponent=!0;const QC={toc:[]},$C="wrapper";function KC(e){let{components:n,...t}=e;return(0,s.yg)($C,(0,p.A)({},QC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}KC.isMDXComponent=!0;const JC={toc:[]},ZC="wrapper";function ex(e){let{components:n,...t}=e;return(0,s.yg)(ZC,(0,p.A)({},JC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}ex.isMDXComponent=!0;const nx={toc:[]},tx="wrapper";function ox(e){let{components:n,...t}=e;return(0,s.yg)(tx,(0,p.A)({},nx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}ox.isMDXComponent=!0;const px={toc:[]},rx="wrapper";function sx(e){let{components:n,...t}=e;return(0,s.yg)(rx,(0,p.A)({},px,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}sx.isMDXComponent=!0;const cx={toc:[]},ax="wrapper";function ix(e){let{components:n,...t}=e;return(0,s.yg)(ax,(0,p.A)({},cx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}ix.isMDXComponent=!0;const lx={toc:[]},ux="wrapper";function mx(e){let{components:n,...t}=e;return(0,s.yg)(ux,(0,p.A)({},lx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}mx.isMDXComponent=!0;const yx={toc:[]},dx="wrapper";function hx(e){let{components:n,...t}=e;return(0,s.yg)(dx,(0,p.A)({},yx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a two-dimensional vector stored in a meta file."))}hx.isMDXComponent=!0;const gx={toc:[]},fx="wrapper";function Dx(e){let{components:n,...t}=e;return(0,s.yg)(fx,(0,p.A)({},gx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Dx.isMDXComponent=!0;const Mx={toc:[]},Xx="wrapper";function _x(e){let{components:n,...t}=e;return(0,s.yg)(Xx,(0,p.A)({},Mx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}_x.isMDXComponent=!0;const wx={toc:[]},Tx="wrapper";function Cx(e){let{components:n,...t}=e;return(0,s.yg)(Tx,(0,p.A)({},wx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Cx.isMDXComponent=!0;const xx={toc:[]},Ax="wrapper";function vx(e){let{components:n,...t}=e;return(0,s.yg)(Ax,(0,p.A)({},xx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}vx.isMDXComponent=!0;const Lx={toc:[]},bx="wrapper";function Nx(e){let{components:n,...t}=e;return(0,s.yg)(bx,(0,p.A)({},Lx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}Nx.isMDXComponent=!0;const kx={toc:[]},zx="wrapper";function Px(e){let{components:n,...t}=e;return(0,s.yg)(zx,(0,p.A)({},kx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}Px.isMDXComponent=!0;const Ix={toc:[]},Rx="wrapper";function Wx(e){let{components:n,...t}=e;return(0,s.yg)(Rx,(0,p.A)({},Ix,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}Wx.isMDXComponent=!0;const Sx={toc:[]},Bx="wrapper";function Gx(e){let{components:n,...t}=e;return(0,s.yg)(Bx,(0,p.A)({},Sx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}Gx.isMDXComponent=!0;const Ex={toc:[]},Ox="wrapper";function Ux(e){let{components:n,...t}=e;return(0,s.yg)(Ox,(0,p.A)({},Ex,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}Ux.isMDXComponent=!0;const Fx={toc:[]},Vx="wrapper";function qx(e){let{components:n,...t}=e;return(0,s.yg)(Vx,(0,p.A)({},Fx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}qx.isMDXComponent=!0;const jx={toc:[]},Hx="wrapper";function Yx(e){let{components:n,...t}=e;return(0,s.yg)(Hx,(0,p.A)({},jx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}Yx.isMDXComponent=!0;const Qx={toc:[]},$x="wrapper";function Kx(e){let{components:n,...t}=e;return(0,s.yg)($x,(0,p.A)({},Qx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Kx.isMDXComponent=!0;const Jx={toc:[]},Zx="wrapper";function eA(e){let{components:n,...t}=e;return(0,s.yg)(Zx,(0,p.A)({},Jx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}eA.isMDXComponent=!0;const nA={toc:[]},tA="wrapper";function oA(e){let{components:n,...t}=e;return(0,s.yg)(tA,(0,p.A)({},nA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}oA.isMDXComponent=!0;const pA={toc:[]},rA="wrapper";function sA(e){let{components:n,...t}=e;return(0,s.yg)(rA,(0,p.A)({},pA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}sA.isMDXComponent=!0;const cA={toc:[]},aA="wrapper";function iA(e){let{components:n,...t}=e;return(0,s.yg)(aA,(0,p.A)({},cA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}iA.isMDXComponent=!0;const lA={toc:[]},uA="wrapper";function mA(e){let{components:n,...t}=e;return(0,s.yg)(uA,(0,p.A)({},lA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}mA.isMDXComponent=!0;const yA={toc:[]},dA="wrapper";function hA(e){let{components:n,...t}=e;return(0,s.yg)(dA,(0,p.A)({},yA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}hA.isMDXComponent=!0;const gA={toc:[]},fA="wrapper";function DA(e){let{components:n,...t}=e;return(0,s.yg)(fA,(0,p.A)({},gA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}DA.isMDXComponent=!0;const MA={toc:[]},XA="wrapper";function _A(e){let{components:n,...t}=e;return(0,s.yg)(XA,(0,p.A)({},MA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}_A.isMDXComponent=!0;const wA={toc:[]},TA="wrapper";function CA(e){let{components:n,...t}=e;return(0,s.yg)(TA,(0,p.A)({},wA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an object with nested meta-fields."))}CA.isMDXComponent=!0;const xA={toc:[]},AA="wrapper";function vA(e){let{components:n,...t}=e;return(0,s.yg)(AA,(0,p.A)({},xA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an object with nested meta-fields."))}vA.isMDXComponent=!0;const LA={toc:[]},bA="wrapper";function NA(e){let{components:n,...t}=e;return(0,s.yg)(bA,(0,p.A)({},LA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a runtime Motion Canvas plugin."))}NA.isMDXComponent=!0;const kA={toc:[]},zA="wrapper";function PA(e){let{components:n,...t}=e;return(0,s.yg)(zA,(0,p.A)({},kA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name should be unique across the entire ecosystem of Motion Canvas.\nIf a plugin with the same name has already been registered, this plugin\nwill be ignored."),(0,s.yg)("p",null,"If you intend to publish your plugin to npm, it is recommended to prefix\nthis name with the name of your npm package."),(0,s.yg)("p",null,"Other identifiers defined by the plugin, such as a tab id, will be\nautomatically prefixed with this name and as such don't have to be unique."))}PA.isMDXComponent=!0;const IA={toc:[]},RA="wrapper";function WA(e){let{components:n,...t}=e;return(0,s.yg)(RA,(0,p.A)({},IA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A unique name of the plugin."))}WA.isMDXComponent=!0;const SA={toc:[]},BA="wrapper";function GA(e){let{components:n,...t}=e;return(0,s.yg)(BA,(0,p.A)({},SA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide custom exporters for the project."))}GA.isMDXComponent=!0;const EA={toc:[]},OA="wrapper";function UA(e){let{components:n,...t}=e;return(0,s.yg)(OA,(0,p.A)({},EA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project instance."))}UA.isMDXComponent=!0;const FA={toc:[]},VA="wrapper";function qA(e){let{components:n,...t}=e;return(0,s.yg)(VA,(0,p.A)({},FA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the player instance right after it is initialized."))}qA.isMDXComponent=!0;const jA={toc:[]},HA="wrapper";function YA(e){let{components:n,...t}=e;return(0,s.yg)(HA,(0,p.A)({},jA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The player instance."))}YA.isMDXComponent=!0;const QA={toc:[]},$A="wrapper";function KA(e){let{components:n,...t}=e;return(0,s.yg)($A,(0,p.A)({},QA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the presenter instance right after it is initialized."))}KA.isMDXComponent=!0;const JA={toc:[]},ZA="wrapper";function ev(e){let{components:n,...t}=e;return(0,s.yg)(ZA,(0,p.A)({},JA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The presenter instance."))}ev.isMDXComponent=!0;const nv={toc:[]},tv="wrapper";function ov(e){let{components:n,...t}=e;return(0,s.yg)(tv,(0,p.A)({},nv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the project instance right after it is initialized."))}ov.isMDXComponent=!0;const pv={toc:[]},rv="wrapper";function sv(e){let{components:n,...t}=e;return(0,s.yg)(rv,(0,p.A)({},pv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project instance."))}sv.isMDXComponent=!0;const cv={toc:[]},av="wrapper";function iv(e){let{components:n,...t}=e;return(0,s.yg)(av,(0,p.A)({},cv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the renderer instance right after it is initialized."))}iv.isMDXComponent=!0;const lv={toc:[]},uv="wrapper";function mv(e){let{components:n,...t}=e;return(0,s.yg)(uv,(0,p.A)({},lv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The renderer instance."))}mv.isMDXComponent=!0;const yv={toc:[]},dv="wrapper";function hv(e){let{components:n,...t}=e;return(0,s.yg)(dv,(0,p.A)({},yv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Modify the project settings before the project is initialized."))}hv.isMDXComponent=!0;const gv={toc:[]},fv="wrapper";function Dv(e){let{components:n,...t}=e;return(0,s.yg)(fv,(0,p.A)({},gv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project settings."))}Dv.isMDXComponent=!0;const Mv={toc:[]},Xv="wrapper";function _v(e){let{components:n,...t}=e;return(0,s.yg)(Xv,(0,p.A)({},Mv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}_v.isMDXComponent=!0;const wv={toc:[]},Tv="wrapper";function Cv(e){let{components:n,...t}=e;return(0,s.yg)(Tv,(0,p.A)({},wv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper function for exporting Motion Canvas plugins."))}Cv.isMDXComponent=!0;const xv={toc:[]},Av="wrapper";function vv(e){let{components:n,...t}=e;return(0,s.yg)(Av,(0,p.A)({},xv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The plugin configuration."))}vv.isMDXComponent=!0;const Lv={toc:[]},bv="wrapper";function Nv(e){let{components:n,...t}=e;return(0,s.yg)(bv,(0,p.A)({},Lv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abstract scene representations and related utilities."))}Nv.isMDXComponent=!0;const kv={toc:[]},zv="wrapper";function Pv(e){let{components:n,...t}=e;return(0,s.yg)(zv,(0,p.A)({},kv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Signifies the various stages of a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Pv.isMDXComponent=!0;const Iv={toc:[]},Rv="wrapper";function Wv(e){let{components:n,...t}=e;return(0,s.yg)(Rv,(0,p.A)({},Iv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs after a render ends."))}Wv.isMDXComponent=!0;const Sv={toc:[]},Bv="wrapper";function Gv(e){let{components:n,...t}=e;return(0,s.yg)(Bv,(0,p.A)({},Sv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Gv.isMDXComponent=!0;const Ev={toc:[]},Ov="wrapper";function Uv(e){let{components:n,...t}=e;return(0,s.yg)(Ov,(0,p.A)({},Ev,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.yg)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Uv.isMDXComponent=!0;const Fv={toc:[]},Vv="wrapper";function qv(e){let{components:n,...t}=e;return(0,s.yg)(Vv,(0,p.A)({},Fv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.yg)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}qv.isMDXComponent=!0;const jv={toc:[]},Hv="wrapper";function Yv(e){let{components:n,...t}=e;return(0,s.yg)(Hv,(0,p.A)({},jv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes the state of a scene."))}Yv.isMDXComponent=!0;const Qv={toc:[]},$v="wrapper";function Kv(e){let{components:n,...t}=e;return(0,s.yg)($v,(0,p.A)({},Qv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Kv.isMDXComponent=!0;const Jv={toc:[]},Zv="wrapper";function eL(e){let{components:n,...t}=e;return(0,s.yg)(Zv,(0,p.A)({},Jv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has finished transitioning in."))}eL.isMDXComponent=!0;const nL={toc:[]},tL="wrapper";function oL(e){let{components:n,...t}=e;return(0,s.yg)(tL,(0,p.A)({},nL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.yg)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}oL.isMDXComponent=!0;const pL={toc:[]},rL="wrapper";function sL(e){let{components:n,...t}=e;return(0,s.yg)(rL,(0,p.A)({},pL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene is ready to transition out."))}sL.isMDXComponent=!0;const cL={toc:[]},aL="wrapper";function iL(e){let{components:n,...t}=e;return(0,s.yg)(aL,(0,p.A)({},cL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoking ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.yg)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}iL.isMDXComponent=!0;const lL={toc:[]},uL="wrapper";function mL(e){let{components:n,...t}=e;return(0,s.yg)(uL,(0,p.A)({},lL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has finished."))}mL.isMDXComponent=!0;const yL={toc:[]},dL="wrapper";function hL(e){let{components:n,...t}=e;return(0,s.yg)(dL,(0,p.A)({},yL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has just been created/reset."))}hL.isMDXComponent=!0;const gL={toc:[]},fL="wrapper";function DL(e){let{components:n,...t}=e;return(0,s.yg)(fL,(0,p.A)({},gL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The default implementation of the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.yg)("p",null,"Uses generators to control the animation."))}DL.isMDXComponent=!0;const ML={toc:[]},XL="wrapper";function _L(e){let{components:n,...t}=e;return(0,s.yg)(XL,(0,p.A)({},ML,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The root path of the assets. Prefix for all relative paths."))}_L.isMDXComponent=!0;const wL={toc:[]},TL="wrapper";function CL(e){let{components:n,...t}=e;return(0,s.yg)(TL,(0,p.A)({},wL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Will be passed as the second argument to the constructor."))}CL.isMDXComponent=!0;const xL={toc:[]},AL="wrapper";function vL(e){let{components:n,...t}=e;return(0,s.yg)(AL,(0,p.A)({},xL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Name of the scene."))}vL.isMDXComponent=!0;const LL={toc:[]},bL="wrapper";function NL(e){let{components:n,...t}=e;return(0,s.yg)(bL,(0,p.A)({},LL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reference to the project."))}NL.isMDXComponent=!0;const kL={toc:[]},zL="wrapper";function PL(e){let{components:n,...t}=e;return(0,s.yg)(zL,(0,p.A)({},kL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}PL.isMDXComponent=!0;const IL={toc:[]},RL="wrapper";function WL(e){let{components:n,...t}=e;return(0,s.yg)(RL,(0,p.A)({},IL,t,{components:n,mdxType:"MDXLayout"}))}WL.isMDXComponent=!0;const SL={toc:[]},BL="wrapper";function GL(e){let{components:n,...t}=e;return(0,s.yg)(BL,(0,p.A)({},SL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}GL.isMDXComponent=!0;const EL={toc:[]},OL="wrapper";function UL(e){let{components:n,...t}=e;return(0,s.yg)(OL,(0,p.A)({},EL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}UL.isMDXComponent=!0;const FL={toc:[]},VL="wrapper";function qL(e){let{components:n,...t}=e;return(0,s.yg)(VL,(0,p.A)({},FL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene starts."))}qL.isMDXComponent=!0;const jL={toc:[]},HL="wrapper";function YL(e){let{components:n,...t}=e;return(0,s.yg)(HL,(0,p.A)({},jL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene ends."))}YL.isMDXComponent=!0;const QL={toc:[]},$L="wrapper";function KL(e){let{components:n,...t}=e;return(0,s.yg)($L,(0,p.A)({},QL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the cached data changes."))}KL.isMDXComponent=!0;const JL={toc:[]},ZL="wrapper";function eb(e){let{components:n,...t}=e;return(0,s.yg)(ZL,(0,p.A)({},JL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered after scene is recalculated."))}eb.isMDXComponent=!0;const nb={toc:[]},tb="wrapper";function ob(e){let{components:n,...t}=e;return(0,s.yg)(tb,(0,p.A)({},nb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reloaded."))}ob.isMDXComponent=!0;const pb={toc:[]},rb="wrapper";function sb(e){let{components:n,...t}=e;return(0,s.yg)(rb,(0,p.A)({},pb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}sb.isMDXComponent=!0;const cb={toc:[]},ab="wrapper";function ib(e){let{components:n,...t}=e;return(0,s.yg)(ab,(0,p.A)({},cb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reset."))}ib.isMDXComponent=!0;const lb={toc:[]},ub="wrapper";function mb(e){let{components:n,...t}=e;return(0,s.yg)(ub,(0,p.A)({},lb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the main thread changes."))}mb.isMDXComponent=!0;const yb={toc:[]},db="wrapper";function hb(e){let{components:n,...t}=e;return(0,s.yg)(db,(0,p.A)({},yb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene directly before this scene, or null if omitted for performance."))}hb.isMDXComponent=!0;const gb={toc:[]},fb="wrapper";function Db(e){let{components:n,...t}=e;return(0,s.yg)(fb,(0,p.A)({},gb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Db.isMDXComponent=!0;const Mb={toc:[]},Xb="wrapper";function _b(e){let{components:n,...t}=e;return(0,s.yg)(Xb,(0,p.A)({},Mb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}_b.isMDXComponent=!0;const wb={toc:[]},Tb="wrapper";function Cb(e){let{components:n,...t}=e;return(0,s.yg)(Tb,(0,p.A)({},wb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Cb.isMDXComponent=!0;const xb={toc:[]},Ab="wrapper";function vb(e){let{components:n,...t}=e;return(0,s.yg)(Ab,(0,p.A)({},xb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.yg)("inlineCode",{parentName:"a"},"Initial"))," state."))}vb.isMDXComponent=!0;const Lb={toc:[]},bb="wrapper";function Nb(e){let{components:n,...t}=e;return(0,s.yg)(bb,(0,p.A)({},Lb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Nb.isMDXComponent=!0;const kb={toc:[]},zb="wrapper";function Pb(e){let{components:n,...t}=e;return(0,s.yg)(zb,(0,p.A)({},kb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback in the context of this scene."))}Pb.isMDXComponent=!0;const Ib={toc:[]},Rb="wrapper";function Wb(e){let{components:n,...t}=e;return(0,s.yg)(Rb,(0,p.A)({},Ib,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}Wb.isMDXComponent=!0;const Sb={toc:[]},Bb="wrapper";function Gb(e){let{components:n,...t}=e;return(0,s.yg)(Bb,(0,p.A)({},Sb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all media assets"))}Gb.isMDXComponent=!0;const Eb={toc:[]},Ob="wrapper";function Ub(e){let{components:n,...t}=e;return(0,s.yg)(Ob,(0,p.A)({},Eb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}Ub.isMDXComponent=!0;const Fb={toc:[]},Vb="wrapper";function qb(e){let{components:n,...t}=e;return(0,s.yg)(Vb,(0,p.A)({},Fb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real size of this scene."))}qb.isMDXComponent=!0;const jb={toc:[]},Hb="wrapper";function Yb(e){let{components:n,...t}=e;return(0,s.yg)(Hb,(0,p.A)({},jb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually returns ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Yb.isMDXComponent=!0;const Qb={toc:[]},$b="wrapper";function Kb(e){let{components:n,...t}=e;return(0,s.yg)($b,(0,p.A)({},Qb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the size of this scene."))}Kb.isMDXComponent=!0;const Jb={toc:[]},Zb="wrapper";function eN(e){let{components:n,...t}=e;return(0,s.yg)(Zb,(0,p.A)({},Jb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}eN.isMDXComponent=!0;const nN={toc:[]},tN="wrapper";function oN(e){let{components:n,...t}=e;return(0,s.yg)(tN,(0,p.A)({},nN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used only by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.yg)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.yg)("p",null,"Should always return ",(0,s.yg)("inlineCode",{parentName:"p"},"true"),"."))}oN.isMDXComponent=!0;const pN={toc:[]},rN="wrapper";function sN(e){let{components:n,...t}=e;return(0,s.yg)(rN,(0,p.A)({},pN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene cached?"))}sN.isMDXComponent=!0;const cN={toc:[]},aN="wrapper";function iN(e){let{components:n,...t}=e;return(0,s.yg)(aN,(0,p.A)({},cN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.yg)("inlineCode",{parentName:"a"},"Finished"))," state?"))}iN.isMDXComponent=!0;const lN={toc:[]},uN="wrapper";function mN(e){let{components:n,...t}=e;return(0,s.yg)(uN,(0,p.A)({},lN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress this scene one frame forward."))}mN.isMDXComponent=!0;const yN={toc:[]},dN="wrapper";function hN(e){let{components:n,...t}=e;return(0,s.yg)(dN,(0,p.A)({},yN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.yg)("p",null,"At the end of execution, this method should set ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.yg)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}hN.isMDXComponent=!0;const gN={toc:[]},fN="wrapper";function DN(e){let{components:n,...t}=e;return(0,s.yg)(fN,(0,p.A)({},gN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Recalculate the scene."))}DN.isMDXComponent=!0;const MN={toc:[]},XN="wrapper";function _N(e){let{components:n,...t}=e;return(0,s.yg)(XN,(0,p.A)({},MN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.yg)("inlineCode",{parentName:"a"},"onReloaded")),"."))}_N.isMDXComponent=!0;const wN={toc:[]},TN="wrapper";function CN(e){let{components:n,...t}=e;return(0,s.yg)(TN,(0,p.A)({},wN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reload the scene."))}CN.isMDXComponent=!0;const xN={toc:[]},AN="wrapper";function vN(e){let{components:n,...t}=e;return(0,s.yg)(AN,(0,p.A)({},xN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, an updated version of the description."))}vN.isMDXComponent=!0;const LN={toc:[]},bN="wrapper";function NN(e){let{components:n,...t}=e;return(0,s.yg)(bN,(0,p.A)({},LN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the scene onto a canvas."))}NN.isMDXComponent=!0;const kN={toc:[]},zN="wrapper";function PN(e){let{components:n,...t}=e;return(0,s.yg)(zN,(0,p.A)({},kN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to used when rendering."))}PN.isMDXComponent=!0;const IN={toc:[]},RN="wrapper";function WN(e){let{components:n,...t}=e;return(0,s.yg)(RN,(0,p.A)({},IN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset this scene to its initial state."))}WN.isMDXComponent=!0;const SN={toc:[]},BN="wrapper";function GN(e){let{components:n,...t}=e;return(0,s.yg)(BN,(0,p.A)({},SN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, the previous scene."))}GN.isMDXComponent=!0;const EN={toc:[]},ON="wrapper";function UN(e){let{components:n,...t}=e;return(0,s.yg)(ON,(0,p.A)({},EN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the view."),(0,s.yg)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.yg)("p",null,"Can modify the state of the view."))}UN.isMDXComponent=!0;const FN={toc:[]},VN="wrapper";function qN(e){let{components:n,...t}=e;return(0,s.yg)(VN,(0,p.A)({},FN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Lifecycle events for ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}qN.isMDXComponent=!0;const jN={toc:[]},HN="wrapper";function YN(e){let{components:n,...t}=e;return(0,s.yg)(HN,(0,p.A)({},jN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A random number generator based on\n",(0,s.yg)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.yg)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}YN.isMDXComponent=!0;const QN={toc:[]},$N="wrapper";function KN(e){let{components:n,...t}=e;return(0,s.yg)($N,(0,p.A)({},QN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get an array filled with random floats in the given range."))}KN.isMDXComponent=!0;const JN={toc:[]},ZN="wrapper";function ek(e){let{components:n,...t}=e;return(0,s.yg)(ZN,(0,p.A)({},JN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The size of the array."))}ek.isMDXComponent=!0;const nk={toc:[]},tk="wrapper";function ok(e){let{components:n,...t}=e;return(0,s.yg)(tk,(0,p.A)({},nk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}ok.isMDXComponent=!0;const pk={toc:[]},rk="wrapper";function sk(e){let{components:n,...t}=e;return(0,s.yg)(rk,(0,p.A)({},pk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}sk.isMDXComponent=!0;const ck={toc:[]},ak="wrapper";function ik(e){let{components:n,...t}=e;return(0,s.yg)(ak,(0,p.A)({},ck,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a random float from a gaussian distribution."))}ik.isMDXComponent=!0;const lk={toc:[]},uk="wrapper";function mk(e){let{components:n,...t}=e;return(0,s.yg)(uk,(0,p.A)({},lk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The mean of the distribution."))}mk.isMDXComponent=!0;const yk={toc:[]},dk="wrapper";function hk(e){let{components:n,...t}=e;return(0,s.yg)(dk,(0,p.A)({},yk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The standard deviation of the distribution."))}hk.isMDXComponent=!0;const gk={toc:[]},fk="wrapper";function Dk(e){let{components:n,...t}=e;return(0,s.yg)(fk,(0,p.A)({},gk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get an array filled with random integers in the given range."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"}),(0,s.yg)("li",{parentName:"ul"})))}Dk.isMDXComponent=!0;const Mk={toc:[]},Xk="wrapper";function _k(e){let{components:n,...t}=e;return(0,s.yg)(Xk,(0,p.A)({},Mk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The size of the array."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}_k.isMDXComponent=!0;const wk={toc:[]},Tk="wrapper";function Ck(e){let{components:n,...t}=e;return(0,s.yg)(Tk,(0,p.A)({},wk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}Ck.isMDXComponent=!0;const xk={toc:[]},Ak="wrapper";function vk(e){let{components:n,...t}=e;return(0,s.yg)(Ak,(0,p.A)({},xk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. Exclusive."))}vk.isMDXComponent=!0;const Lk={toc:[]},bk="wrapper";function Nk(e){let{components:n,...t}=e;return(0,s.yg)(bk,(0,p.A)({},Lk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the next random float in the given range."))}Nk.isMDXComponent=!0;const kk={toc:[]},zk="wrapper";function Pk(e){let{components:n,...t}=e;return(0,s.yg)(zk,(0,p.A)({},kk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}Pk.isMDXComponent=!0;const Ik={toc:[]},Rk="wrapper";function Wk(e){let{components:n,...t}=e;return(0,s.yg)(Rk,(0,p.A)({},Ik,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}Wk.isMDXComponent=!0;const Sk={toc:[]},Bk="wrapper";function Gk(e){let{components:n,...t}=e;return(0,s.yg)(Bk,(0,p.A)({},Sk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the next random integer in the given range."))}Gk.isMDXComponent=!0;const Ek={toc:[]},Ok="wrapper";function Uk(e){let{components:n,...t}=e;return(0,s.yg)(Ok,(0,p.A)({},Ek,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}Uk.isMDXComponent=!0;const Fk={toc:[]},Vk="wrapper";function qk(e){let{components:n,...t}=e;return(0,s.yg)(Vk,(0,p.A)({},Fk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. Exclusive."))}qk.isMDXComponent=!0;const jk={toc:[]},Hk="wrapper";function Yk(e){let{components:n,...t}=e;return(0,s.yg)(Hk,(0,p.A)({},jk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a new independent generator."))}Yk.isMDXComponent=!0;const Qk={toc:[]},$k="wrapper";function Kk(e){let{components:n,...t}=e;return(0,s.yg)($k,(0,p.A)({},Qk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get variable signal if exists or create signal if not"))}Kk.isMDXComponent=!0;const Jk={toc:[]},Zk="wrapper";function ez(e){let{components:n,...t}=e;return(0,s.yg)(Zk,(0,p.A)({},Jk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the variable."))}ez.isMDXComponent=!0;const nz={toc:[]},tz="wrapper";function oz(e){let{components:n,...t}=e;return(0,s.yg)(tz,(0,p.A)({},nz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}oz.isMDXComponent=!0;const pz={toc:[]},rz="wrapper";function sz(e){let{components:n,...t}=e;return(0,s.yg)(rz,(0,p.A)({},pz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get variable signal if exists or create signal if not"))}sz.isMDXComponent=!0;const cz={toc:[]},az="wrapper";function iz(e){let{components:n,...t}=e;return(0,s.yg)(az,(0,p.A)({},cz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset all stored signals."))}iz.isMDXComponent=!0;const lz={toc:[]},uz="wrapper";function mz(e){let{components:n,...t}=e;return(0,s.yg)(uz,(0,p.A)({},lz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update all signals with new project variable values."))}mz.isMDXComponent=!0;const yz={toc:[]},dz="wrapper";function hz(e){let{components:n,...t}=e;return(0,s.yg)(dz,(0,p.A)({},yz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes cached information about the timing of a scene."))}hz.isMDXComponent=!0;const gz={toc:[]},fz="wrapper";function Dz(e){let{components:n,...t}=e;return(0,s.yg)(fz,(0,p.A)({},gz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes a complete scene together with the meta file."))}Dz.isMDXComponent=!0;const Mz={toc:[]},Xz="wrapper";function _z(e){let{components:n,...t}=e;return(0,s.yg)(Xz,(0,p.A)({},Mz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configuration object."))}_z.isMDXComponent=!0;const wz={toc:[]},Tz="wrapper";function Cz(e){let{components:n,...t}=e;return(0,s.yg)(Tz,(0,p.A)({},wz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class used to instantiate the scene."))}Cz.isMDXComponent=!0;const xz={toc:[]},Az="wrapper";function vz(e){let{components:n,...t}=e;return(0,s.yg)(Az,(0,p.A)({},xz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}vz.isMDXComponent=!0;const Lz={toc:[]},bz="wrapper";function Nz(e){let{components:n,...t}=e;return(0,s.yg)(bz,(0,p.A)({},Lz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace at the moment of creation."))}Nz.isMDXComponent=!0;const kz={toc:[]},zz="wrapper";function Pz(e){let{components:n,...t}=e;return(0,s.yg)(zz,(0,p.A)({},kz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}Pz.isMDXComponent=!0;const Iz={toc:[]},Rz="wrapper";function Wz(e){let{components:n,...t}=e;return(0,s.yg)(Rz,(0,p.A)({},Iz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Wz.isMDXComponent=!0;const Sz={toc:[]},Bz="wrapper";function Gz(e){let{components:n,...t}=e;return(0,s.yg)(Bz,(0,p.A)({},Sz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Gz.isMDXComponent=!0;const Ez={toc:[]},Oz="wrapper";function Uz(e){let{components:n,...t}=e;return(0,s.yg)(Oz,(0,p.A)({},Ez,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for the inspected element."))}Uz.isMDXComponent=!0;const Fz={toc:[]},Vz="wrapper";function qz(e){let{components:n,...t}=e;return(0,s.yg)(Vz,(0,p.A)({},Fz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element for which to draw an overlay."))}qz.isMDXComponent=!0;const jz={toc:[]},Hz="wrapper";function Yz(e){let{components:n,...t}=e;return(0,s.yg)(Hz,(0,p.A)({},jz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Yz.isMDXComponent=!0;const Qz={toc:[]},$z="wrapper";function Kz(e){let{components:n,...t}=e;return(0,s.yg)($z,(0,p.A)({},Qz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Kz.isMDXComponent=!0;const Jz={toc:[]},Zz="wrapper";function eP(e){let{components:n,...t}=e;return(0,s.yg)(Zz,(0,p.A)({},Jz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,'This information will be displayed in the "Properties" panel.'))}eP.isMDXComponent=!0;const nP={toc:[]},tP="wrapper";function oP(e){let{components:n,...t}=e;return(0,s.yg)(tP,(0,p.A)({},nP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the attributes of the inspected element."))}oP.isMDXComponent=!0;const pP={toc:[]},rP="wrapper";function sP(e){let{components:n,...t}=e;return(0,s.yg)(rP,(0,p.A)({},pP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element to inspect."))}sP.isMDXComponent=!0;const cP={toc:[]},aP="wrapper";function iP(e){let{components:n,...t}=e;return(0,s.yg)(aP,(0,p.A)({},cP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a possible element to inspect at a given position."))}iP.isMDXComponent=!0;const lP={toc:[]},uP="wrapper";function mP(e){let{components:n,...t}=e;return(0,s.yg)(uP,(0,p.A)({},lP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x coordinate."))}mP.isMDXComponent=!0;const yP={toc:[]},dP="wrapper";function hP(e){let{components:n,...t}=e;return(0,s.yg)(dP,(0,p.A)({},yP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y coordinate."))}hP.isMDXComponent=!0;const gP={toc:[]},fP="wrapper";function DP(e){let{components:n,...t}=e;return(0,s.yg)(fP,(0,p.A)({},gP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}DP.isMDXComponent=!0;const MP={toc:[]},XP="wrapper";function _P(e){let{components:n,...t}=e;return(0,s.yg)(XP,(0,p.A)({},MP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x coordinate."))}_P.isMDXComponent=!0;const wP={toc:[]},TP="wrapper";function CP(e){let{components:n,...t}=e;return(0,s.yg)(TP,(0,p.A)({},wP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y coordinate."))}CP.isMDXComponent=!0;const xP={toc:[]},AP="wrapper";function vP(e){let{components:n,...t}=e;return(0,s.yg)(AP,(0,p.A)({},xP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}vP.isMDXComponent=!0;const LP={toc:[]},bP="wrapper";function NP(e){let{components:n,...t}=e;return(0,s.yg)(bP,(0,p.A)({},LP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the inspected element is still valid."))}NP.isMDXComponent=!0;const kP={toc:[]},zP="wrapper";function PP(e){let{components:n,...t}=e;return(0,s.yg)(zP,(0,p.A)({},kP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element to validate."))}PP.isMDXComponent=!0;const IP={toc:[]},RP="wrapper";function WP(e){let{components:n,...t}=e;return(0,s.yg)(RP,(0,p.A)({},IP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.yg)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}WP.isMDXComponent=!0;const SP={toc:[]},BP="wrapper";function GP(e){let{components:n,...t}=e;return(0,s.yg)(BP,(0,p.A)({},SP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main interface for scenes."))}GP.isMDXComponent=!0;const EP={toc:[]},OP="wrapper";function UP(e){let{components:n,...t}=e;return(0,s.yg)(OP,(0,p.A)({},EP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The root path of the assets. Prefix for all relative paths."))}UP.isMDXComponent=!0;const FP={toc:[]},VP="wrapper";function qP(e){let{components:n,...t}=e;return(0,s.yg)(VP,(0,p.A)({},FP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Will be passed as the second argument to the constructor."))}qP.isMDXComponent=!0;const jP={toc:[]},HP="wrapper";function YP(e){let{components:n,...t}=e;return(0,s.yg)(HP,(0,p.A)({},jP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Name of the scene."))}YP.isMDXComponent=!0;const QP={toc:[]},$P="wrapper";function KP(e){let{components:n,...t}=e;return(0,s.yg)($P,(0,p.A)({},QP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reference to the project."))}KP.isMDXComponent=!0;const JP={toc:[]},ZP="wrapper";function eI(e){let{components:n,...t}=e;return(0,s.yg)(ZP,(0,p.A)({},JP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}eI.isMDXComponent=!0;const nI={toc:[]},tI="wrapper";function oI(e){let{components:n,...t}=e;return(0,s.yg)(tI,(0,p.A)({},nI,t,{components:n,mdxType:"MDXLayout"}))}oI.isMDXComponent=!0;const pI={toc:[]},rI="wrapper";function sI(e){let{components:n,...t}=e;return(0,s.yg)(rI,(0,p.A)({},pI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}sI.isMDXComponent=!0;const cI={toc:[]},aI="wrapper";function iI(e){let{components:n,...t}=e;return(0,s.yg)(aI,(0,p.A)({},cI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}iI.isMDXComponent=!0;const lI={toc:[]},uI="wrapper";function mI(e){let{components:n,...t}=e;return(0,s.yg)(uI,(0,p.A)({},lI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether experimental features are enabled."))}mI.isMDXComponent=!0;const yI={toc:[]},dI="wrapper";function hI(e){let{components:n,...t}=e;return(0,s.yg)(dI,(0,p.A)({},yI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene starts."))}hI.isMDXComponent=!0;const gI={toc:[]},fI="wrapper";function DI(e){let{components:n,...t}=e;return(0,s.yg)(fI,(0,p.A)({},gI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene ends."))}DI.isMDXComponent=!0;const MI={toc:[]},XI="wrapper";function _I(e){let{components:n,...t}=e;return(0,s.yg)(XI,(0,p.A)({},MI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_I.isMDXComponent=!0;const wI={toc:[]},TI="wrapper";function CI(e){let{components:n,...t}=e;return(0,s.yg)(TI,(0,p.A)({},wI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the cached data changes."))}CI.isMDXComponent=!0;const xI={toc:[]},AI="wrapper";function vI(e){let{components:n,...t}=e;return(0,s.yg)(AI,(0,p.A)({},xI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered after scene is recalculated."))}vI.isMDXComponent=!0;const LI={toc:[]},bI="wrapper";function NI(e){let{components:n,...t}=e;return(0,s.yg)(bI,(0,p.A)({},LI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reloaded."))}NI.isMDXComponent=!0;const kI={toc:[]},zI="wrapper";function PI(e){let{components:n,...t}=e;return(0,s.yg)(zI,(0,p.A)({},kI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}PI.isMDXComponent=!0;const II={toc:[]},RI="wrapper";function WI(e){let{components:n,...t}=e;return(0,s.yg)(RI,(0,p.A)({},II,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reset."))}WI.isMDXComponent=!0;const SI={toc:[]},BI="wrapper";function GI(e){let{components:n,...t}=e;return(0,s.yg)(BI,(0,p.A)({},SI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene directly before this scene, or null if omitted for performance."))}GI.isMDXComponent=!0;const EI={toc:[]},OI="wrapper";function UI(e){let{components:n,...t}=e;return(0,s.yg)(OI,(0,p.A)({},EI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}UI.isMDXComponent=!0;const FI={toc:[]},VI="wrapper";function qI(e){let{components:n,...t}=e;return(0,s.yg)(VI,(0,p.A)({},FI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}qI.isMDXComponent=!0;const jI={toc:[]},HI="wrapper";function YI(e){let{components:n,...t}=e;return(0,s.yg)(HI,(0,p.A)({},jI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}YI.isMDXComponent=!0;const QI={toc:[]},$I="wrapper";function KI(e){let{components:n,...t}=e;return(0,s.yg)($I,(0,p.A)({},QI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.yg)("inlineCode",{parentName:"a"},"Initial"))," state."))}KI.isMDXComponent=!0;const JI={toc:[]},ZI="wrapper";function eR(e){let{components:n,...t}=e;return(0,s.yg)(ZI,(0,p.A)({},JI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all media assets"))}eR.isMDXComponent=!0;const nR={toc:[]},tR="wrapper";function oR(e){let{components:n,...t}=e;return(0,s.yg)(tR,(0,p.A)({},nR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}oR.isMDXComponent=!0;const pR={toc:[]},rR="wrapper";function sR(e){let{components:n,...t}=e;return(0,s.yg)(rR,(0,p.A)({},pR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real size of this scene."))}sR.isMDXComponent=!0;const cR={toc:[]},aR="wrapper";function iR(e){let{components:n,...t}=e;return(0,s.yg)(aR,(0,p.A)({},cR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually returns ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}iR.isMDXComponent=!0;const lR={toc:[]},uR="wrapper";function mR(e){let{components:n,...t}=e;return(0,s.yg)(uR,(0,p.A)({},lR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the size of this scene."))}mR.isMDXComponent=!0;const yR={toc:[]},dR="wrapper";function hR(e){let{components:n,...t}=e;return(0,s.yg)(dR,(0,p.A)({},yR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}hR.isMDXComponent=!0;const gR={toc:[]},fR="wrapper";function DR(e){let{components:n,...t}=e;return(0,s.yg)(fR,(0,p.A)({},gR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used only by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.yg)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.yg)("p",null,"Should always return ",(0,s.yg)("inlineCode",{parentName:"p"},"true"),"."))}DR.isMDXComponent=!0;const MR={toc:[]},XR="wrapper";function _R(e){let{components:n,...t}=e;return(0,s.yg)(XR,(0,p.A)({},MR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene cached?"))}_R.isMDXComponent=!0;const wR={toc:[]},TR="wrapper";function CR(e){let{components:n,...t}=e;return(0,s.yg)(TR,(0,p.A)({},wR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.yg)("inlineCode",{parentName:"a"},"Finished"))," state?"))}CR.isMDXComponent=!0;const xR={toc:[]},AR="wrapper";function vR(e){let{components:n,...t}=e;return(0,s.yg)(AR,(0,p.A)({},xR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress this scene one frame forward."))}vR.isMDXComponent=!0;const LR={toc:[]},bR="wrapper";function NR(e){let{components:n,...t}=e;return(0,s.yg)(bR,(0,p.A)({},LR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.yg)("p",null,"At the end of execution, this method should set ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.yg)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}NR.isMDXComponent=!0;const kR={toc:[]},zR="wrapper";function PR(e){let{components:n,...t}=e;return(0,s.yg)(zR,(0,p.A)({},kR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Recalculate the scene."))}PR.isMDXComponent=!0;const IR={toc:[]},RR="wrapper";function WR(e){let{components:n,...t}=e;return(0,s.yg)(RR,(0,p.A)({},IR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.yg)("inlineCode",{parentName:"a"},"onReloaded")),"."))}WR.isMDXComponent=!0;const SR={toc:[]},BR="wrapper";function GR(e){let{components:n,...t}=e;return(0,s.yg)(BR,(0,p.A)({},SR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reload the scene."))}GR.isMDXComponent=!0;const ER={toc:[]},OR="wrapper";function UR(e){let{components:n,...t}=e;return(0,s.yg)(OR,(0,p.A)({},ER,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, an updated version of the description."))}UR.isMDXComponent=!0;const FR={toc:[]},VR="wrapper";function qR(e){let{components:n,...t}=e;return(0,s.yg)(VR,(0,p.A)({},FR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the scene onto a canvas."))}qR.isMDXComponent=!0;const jR={toc:[]},HR="wrapper";function YR(e){let{components:n,...t}=e;return(0,s.yg)(HR,(0,p.A)({},jR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to used when rendering."))}YR.isMDXComponent=!0;const QR={toc:[]},$R="wrapper";function KR(e){let{components:n,...t}=e;return(0,s.yg)($R,(0,p.A)({},QR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset this scene to its initial state."))}KR.isMDXComponent=!0;const JR={toc:[]},ZR="wrapper";function eW(e){let{components:n,...t}=e;return(0,s.yg)(ZR,(0,p.A)({},JR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, the previous scene."))}eW.isMDXComponent=!0;const nW={toc:[]},tW="wrapper";function oW(e){let{components:n,...t}=e;return(0,s.yg)(tW,(0,p.A)({},nW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}oW.isMDXComponent=!0;const pW={toc:[]},rW="wrapper";function sW(e){let{components:n,...t}=e;return(0,s.yg)(rW,(0,p.A)({},pW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each class implementing the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}sW.isMDXComponent=!0;const cW={toc:[]},aW="wrapper";function iW(e){let{components:n,...t}=e;return(0,s.yg)(aW,(0,p.A)({},cW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constructor used when creating new scenes."))}iW.isMDXComponent=!0;const lW={toc:[]},uW="wrapper";function mW(e){let{components:n,...t}=e;return(0,s.yg)(uW,(0,p.A)({},lW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.yg)("inlineCode",{parentName:"a"},"config")),"."))}mW.isMDXComponent=!0;const yW={toc:[]},dW="wrapper";function hW(e){let{components:n,...t}=e;return(0,s.yg)(dW,(0,p.A)({},yW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes a scene exposed by scene files."))}hW.isMDXComponent=!0;const gW={toc:[]},fW="wrapper";function DW(e){let{components:n,...t}=e;return(0,s.yg)(fW,(0,p.A)({},gW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configuration object."))}DW.isMDXComponent=!0;const MW={toc:[]},XW="wrapper";function _W(e){let{components:n,...t}=e;return(0,s.yg)(XW,(0,p.A)({},MW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class used to instantiate the scene."))}_W.isMDXComponent=!0;const wW={toc:[]},TW="wrapper";function CW(e){let{components:n,...t}=e;return(0,s.yg)(TW,(0,p.A)({},wW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}CW.isMDXComponent=!0;const xW={toc:[]},AW="wrapper";function vW(e){let{components:n,...t}=e;return(0,s.yg)(AW,(0,p.A)({},xW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace at the moment of creation."))}vW.isMDXComponent=!0;const LW={toc:[]},bW="wrapper";function NW(e){let{components:n,...t}=e;return(0,s.yg)(bW,(0,p.A)({},LW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}NW.isMDXComponent=!0;const kW={toc:[]},zW="wrapper";function PW(e){let{components:n,...t}=e;return(0,s.yg)(zW,(0,p.A)({},kW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A part of the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.yg)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}PW.isMDXComponent=!0;const IW={toc:[]},RW="wrapper";function WW(e){let{components:n,...t}=e;return(0,s.yg)(RW,(0,p.A)({},IW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}WW.isMDXComponent=!0;const SW={toc:[]},BW="wrapper";function GW(e){let{components:n,...t}=e;return(0,s.yg)(BW,(0,p.A)({},SW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This interface is only useful when a scene uses thread generators to run."))}GW.isMDXComponent=!0;const EW={toc:[]},OW="wrapper";function UW(e){let{components:n,...t}=e;return(0,s.yg)(OW,(0,p.A)({},EW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}UW.isMDXComponent=!0;const FW={toc:[]},VW="wrapper";function qW(e){let{components:n,...t}=e;return(0,s.yg)(VW,(0,p.A)({},FW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the main thread changes."))}qW.isMDXComponent=!0;const jW={toc:[]},HW="wrapper";function YW(e){let{components:n,...t}=e;return(0,s.yg)(HW,(0,p.A)({},jW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents attributes of an inspected element."))}YW.isMDXComponent=!0;const QW={toc:[]},$W="wrapper";function KW(e){let{components:n,...t}=e;return(0,s.yg)($W,(0,p.A)({},QW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}KW.isMDXComponent=!0;const JW={toc:[]},ZW="wrapper";function eS(e){let{components:n,...t}=e;return(0,s.yg)(ZW,(0,p.A)({},JW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an element to inspect."))}eS.isMDXComponent=!0;const nS={toc:[]},tS="wrapper";function oS(e){let{components:n,...t}=e;return(0,s.yg)(tS,(0,p.A)({},nS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A runtime representation of the scene metadata."))}oS.isMDXComponent=!0;const pS={toc:[]},rS="wrapper";function sS(e){let{components:n,...t}=e;return(0,s.yg)(rS,(0,p.A)({},pS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a runtime representation of the scene metadata."))}sS.isMDXComponent=!0;const cS={toc:[]},aS="wrapper";function iS(e){let{components:n,...t}=e;return(0,s.yg)(aS,(0,p.A)({},cS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}iS.isMDXComponent=!0;const lS={toc:[]},uS="wrapper";function mS(e){let{components:n,...t}=e;return(0,s.yg)(uS,(0,p.A)({},lS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}mS.isMDXComponent=!0;const yS={toc:[]},dS="wrapper";function hS(e){let{components:n,...t}=e;return(0,s.yg)(dS,(0,p.A)({},yS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}hS.isMDXComponent=!0;const gS={toc:[]},fS="wrapper";function DS(e){let{components:n,...t}=e;return(0,s.yg)(fS,(0,p.A)({},gS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}DS.isMDXComponent=!0;const MS={toc:[]},XS="wrapper";function _S(e){let{components:n,...t}=e;return(0,s.yg)(XS,(0,p.A)({},MS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}_S.isMDXComponent=!0;const wS={toc:[]},TS="wrapper";function CS(e){let{components:n,...t}=e;return(0,s.yg)(TS,(0,p.A)({},wS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}CS.isMDXComponent=!0;const xS={toc:[]},AS="wrapper";function vS(e){let{components:n,...t}=e;return(0,s.yg)(AS,(0,p.A)({},xS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}vS.isMDXComponent=!0;const LS={toc:[]},bS="wrapper";function NS(e){let{components:n,...t}=e;return(0,s.yg)(bS,(0,p.A)({},LS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}NS.isMDXComponent=!0;const kS={toc:[]},zS="wrapper";function PS(e){let{components:n,...t}=e;return(0,s.yg)(zS,(0,p.A)({},kS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}PS.isMDXComponent=!0;const IS={toc:[]},RS="wrapper";function WS(e){let{components:n,...t}=e;return(0,s.yg)(RS,(0,p.A)({},IS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}WS.isMDXComponent=!0;const SS={toc:[]},BS="wrapper";function GS(e){let{components:n,...t}=e;return(0,s.yg)(BS,(0,p.A)({},SS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}GS.isMDXComponent=!0;const ES={toc:[]},OS="wrapper";function US(e){let{components:n,...t}=e;return(0,s.yg)(OS,(0,p.A)({},ES,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}US.isMDXComponent=!0;const FS={toc:[]},VS="wrapper";function qS(e){let{components:n,...t}=e;return(0,s.yg)(VS,(0,p.A)({},FS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}qS.isMDXComponent=!0;const jS={toc:[]},HS="wrapper";function YS(e){let{components:n,...t}=e;return(0,s.yg)(HS,(0,p.A)({},jS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}YS.isMDXComponent=!0;const QS={toc:[]},$S="wrapper";function KS(e){let{components:n,...t}=e;return(0,s.yg)($S,(0,p.A)({},QS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}KS.isMDXComponent=!0;const JS={toc:[]},ZS="wrapper";function eB(e){let{components:n,...t}=e;return(0,s.yg)(ZS,(0,p.A)({},JS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}eB.isMDXComponent=!0;const nB={toc:[]},tB="wrapper";function oB(e){let{components:n,...t}=e;return(0,s.yg)(tB,(0,p.A)({},nB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}oB.isMDXComponent=!0;const pB={toc:[]},rB="wrapper";function sB(e){let{components:n,...t}=e;return(0,s.yg)(rB,(0,p.A)({},pB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}sB.isMDXComponent=!0;const cB={toc:[]},aB="wrapper";function iB(e){let{components:n,...t}=e;return(0,s.yg)(aB,(0,p.A)({},cB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}iB.isMDXComponent=!0;const lB={toc:[]},uB="wrapper";function mB(e){let{components:n,...t}=e;return(0,s.yg)(uB,(0,p.A)({},lB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}mB.isMDXComponent=!0;const yB={toc:[]},dB="wrapper";function hB(e){let{components:n,...t}=e;return(0,s.yg)(dB,(0,p.A)({},yB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}hB.isMDXComponent=!0;const gB={toc:[]},fB="wrapper";function DB(e){let{components:n,...t}=e;return(0,s.yg)(fB,(0,p.A)({},gB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}DB.isMDXComponent=!0;const MB={toc:[]},XB="wrapper";function _B(e){let{components:n,...t}=e;return(0,s.yg)(XB,(0,p.A)({},MB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}_B.isMDXComponent=!0;const wB={toc:[]},TB="wrapper";function CB(e){let{components:n,...t}=e;return(0,s.yg)(TB,(0,p.A)({},wB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}CB.isMDXComponent=!0;const xB={toc:[]},AB="wrapper";function vB(e){let{components:n,...t}=e;return(0,s.yg)(AB,(0,p.A)({},xB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}vB.isMDXComponent=!0;const LB={toc:[]},bB="wrapper";function NB(e){let{components:n,...t}=e;return(0,s.yg)(bB,(0,p.A)({},LB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}NB.isMDXComponent=!0;const kB={toc:[]},zB="wrapper";function PB(e){let{components:n,...t}=e;return(0,s.yg)(zB,(0,p.A)({},kB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}PB.isMDXComponent=!0;const IB={toc:[]},RB="wrapper";function WB(e){let{components:n,...t}=e;return(0,s.yg)(RB,(0,p.A)({},IB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}WB.isMDXComponent=!0;const SB={toc:[]},BB="wrapper";function GB(e){let{components:n,...t}=e;return(0,s.yg)(BB,(0,p.A)({},SB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}GB.isMDXComponent=!0;const EB={toc:[]},OB="wrapper";function UB(e){let{components:n,...t}=e;return(0,s.yg)(OB,(0,p.A)({},EB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween back to the original value."))}UB.isMDXComponent=!0;const FB={toc:[]},VB="wrapper";function qB(e){let{components:n,...t}=e;return(0,s.yg)(VB,(0,p.A)({},FB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the tween."))}qB.isMDXComponent=!0;const jB={toc:[]},HB="wrapper";function YB(e){let{components:n,...t}=e;return(0,s.yg)(HB,(0,p.A)({},jB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function of the tween."))}YB.isMDXComponent=!0;const QB={toc:[]},$B="wrapper";function KB(e){let{components:n,...t}=e;return(0,s.yg)($B,(0,p.A)({},QB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interpolation function of the tween."))}KB.isMDXComponent=!0;const JB={toc:[]},ZB="wrapper";function eG(e){let{components:n,...t}=e;return(0,s.yg)(ZB,(0,p.A)({},JB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback."))}eG.isMDXComponent=!0;const nG={toc:[]},tG="wrapper";function oG(e){let{components:n,...t}=e;return(0,s.yg)(tG,(0,p.A)({},nG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}oG.isMDXComponent=!0;const pG={toc:[]},rG="wrapper";function sG(e){let{components:n,...t}=e;return(0,s.yg)(rG,(0,p.A)({},pG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given task."))}sG.isMDXComponent=!0;const cG={toc:[]},aG="wrapper";function iG(e){let{components:n,...t}=e;return(0,s.yg)(aG,(0,p.A)({},cG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator to run."))}iG.isMDXComponent=!0;const lG={toc:[]},uG="wrapper";function mG(e){let{components:n,...t}=e;return(0,s.yg)(uG,(0,p.A)({},lG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween to the specified value."))}mG.isMDXComponent=!0;const yG={toc:[]},dG="wrapper";function hG(e){let{components:n,...t}=e;return(0,s.yg)(dG,(0,p.A)({},yG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for the specified duration."))}hG.isMDXComponent=!0;const gG={toc:[]},fG="wrapper";function DG(e){let{components:n,...t}=e;return(0,s.yg)(fG,(0,p.A)({},gG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration to wait."))}DG.isMDXComponent=!0;const MG={toc:[]},XG="wrapper";function _G(e){let{components:n,...t}=e;return(0,s.yg)(XG,(0,p.A)({},MG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Thread management."))}_G.isMDXComponent=!0;const wG={toc:[]},TG="wrapper";function CG(e){let{components:n,...t}=e;return(0,s.yg)(TG,(0,p.A)({},wG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.yg)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}CG.isMDXComponent=!0;const xG={toc:[]},AG="wrapper";function vG(e){let{components:n,...t}=e;return(0,s.yg)(AG,(0,p.A)({},xG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A class representing an individual thread."))}vG.isMDXComponent=!0;const LG={toc:[]},bG="wrapper";function NG(e){let{components:n,...t}=e;return(0,s.yg)(bG,(0,p.A)({},LG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator wrapped by this thread."))}NG.isMDXComponent=!0;const kG={toc:[]},zG="wrapper";function PG(e){let{components:n,...t}=e;return(0,s.yg)(zG,(0,p.A)({},kG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator wrapped by this thread."))}PG.isMDXComponent=!0;const IG={toc:[]},RG="wrapper";function WG(e){let{components:n,...t}=e;return(0,s.yg)(RG,(0,p.A)({},IG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.yg)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}WG.isMDXComponent=!0;const SG={toc:[]},BG="wrapper";function GG(e){let{components:n,...t}=e;return(0,s.yg)(BG,(0,p.A)({},SG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current time of this thread."))}GG.isMDXComponent=!0;const EG={toc:[]},OG="wrapper";function UG(e){let{components:n,...t}=e;return(0,s.yg)(OG,(0,p.A)({},EG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The next value to be passed to the wrapped generator."))}UG.isMDXComponent=!0;const FG={toc:[]},VG="wrapper";function qG(e){let{components:n,...t}=e;return(0,s.yg)(VG,(0,p.A)({},FG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if this thread or any of its ancestors has been canceled."))}qG.isMDXComponent=!0;const jG={toc:[]},HG="wrapper";function YG(e){let{components:n,...t}=e;return(0,s.yg)(HG,(0,p.A)({},jG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.yg)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}YG.isMDXComponent=!0;const QG={toc:[]},$G="wrapper";function KG(e){let{components:n,...t}=e;return(0,s.yg)($G,(0,p.A)({},QG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The fixed time of this thread."))}KG.isMDXComponent=!0;const JG={toc:[]},ZG="wrapper";function eE(e){let{components:n,...t}=e;return(0,s.yg)(ZG,(0,p.A)({},JG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress the wrapped generator once."))}eE.isMDXComponent=!0;const nE={toc:[]},tE="wrapper";function oE(e){let{components:n,...t}=e;return(0,s.yg)(tE,(0,p.A)({},nE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the thread for the next update cycle."))}oE.isMDXComponent=!0;const pE={toc:[]},rE="wrapper";function sE(e){let{components:n,...t}=e;return(0,s.yg)(rE,(0,p.A)({},pE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delta time of the next cycle."))}sE.isMDXComponent=!0;const cE={toc:[]},aE="wrapper";function iE(e){let{components:n,...t}=e;return(0,s.yg)(aE,(0,p.A)({},cE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a normal function that returns a generator."))}iE.isMDXComponent=!0;const lE={toc:[]},uE="wrapper";function mE(e){let{components:n,...t}=e;return(0,s.yg)(uE,(0,p.A)({},lE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.yg)("p",null,"Progress to the next frame:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.yg)("p",null,"Run another generator synchronously:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.yg)("p",null,"Run another generator concurrently:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.yg)("p",null,"Await a Promise:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}mE.isMDXComponent=!0;const yE={toc:[]},dE="wrapper";function hE(e){let{components:n,...t}=e;return(0,s.yg)(dE,(0,p.A)({},yE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}hE.isMDXComponent=!0;const gE={toc:[]},fE="wrapper";function DE(e){let{components:n,...t}=e;return(0,s.yg)(fE,(0,p.A)({},gE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Cancel all listed tasks."),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}DE.isMDXComponent=!0;const ME={toc:[]},XE="wrapper";function _E(e){let{components:n,...t}=e;return(0,s.yg)(XE,(0,p.A)({},ME,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to cancel."))}_E.isMDXComponent=!0;const wE={toc:[]},TE="wrapper";function CE(e){let{components:n,...t}=e;return(0,s.yg)(TE,(0,p.A)({},wE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the given value is a ","[Promise][promise]","."))}CE.isMDXComponent=!0;const xE={toc:[]},AE="wrapper";function vE(e){let{components:n,...t}=e;return(0,s.yg)(AE,(0,p.A)({},xE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A possible ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}vE.isMDXComponent=!0;const LE={toc:[]},bE="wrapper";function NE(e){let{components:n,...t}=e;return(0,s.yg)(bE,(0,p.A)({},LE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the given value is a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.yg)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}NE.isMDXComponent=!0;const kE={toc:[]},zE="wrapper";function PE(e){let{components:n,...t}=e;return(0,s.yg)(zE,(0,p.A)({},kE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A possible thread ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.yg)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}PE.isMDXComponent=!0;const IE={toc:[]},RE="wrapper";function WE(e){let{components:n,...t}=e;return(0,s.yg)(RE,(0,p.A)({},IE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}WE.isMDXComponent=!0;const SE={toc:[]},BE="wrapper";function GE(e){let{components:n,...t}=e;return(0,s.yg)(BE,(0,p.A)({},SE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause the current generator until all listed tasks are finished."))}GE.isMDXComponent=!0;const EE={toc:[]},OE="wrapper";function UE(e){let{components:n,...t}=e;return(0,s.yg)(OE,(0,p.A)({},EE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to join."))}UE.isMDXComponent=!0;const FE={toc:[]},VE="wrapper";function qE(e){let{components:n,...t}=e;return(0,s.yg)(VE,(0,p.A)({},FE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}qE.isMDXComponent=!0;const jE={toc:[]},HE="wrapper";function YE(e){let{components:n,...t}=e;return(0,s.yg)(HE,(0,p.A)({},jE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause the current generator until listed tasks are finished."))}YE.isMDXComponent=!0;const QE={toc:[]},$E="wrapper";function KE(e){let{components:n,...t}=e;return(0,s.yg)($E,(0,p.A)({},QE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether we should wait for all tasks or for at least one."))}KE.isMDXComponent=!0;const JE={toc:[]},ZE="wrapper";function eO(e){let{components:n,...t}=e;return(0,s.yg)(ZE,(0,p.A)({},JE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to join."))}eO.isMDXComponent=!0;const nO={toc:[]},tO="wrapper";function oO(e){let{components:n,...t}=e;return(0,s.yg)(tO,(0,p.A)({},nO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using an existing task:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"spawn(rect().opacity(1, 1));\n")),(0,s.yg)("p",null,"Using a generator function:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"spawn(function* () {\n  yield* rect().opacity(1, 1);\n  yield* waitFor('click');\n  yield* rect().opacity(0, 1);\n});\n")),(0,s.yg)("p",null,"Await the spawned task:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = spawn(rect().opacity(1, 1));\n// do some other things\nyield* join(task); // await the task\n")))}oO.isMDXComponent=!0;const pO={toc:[]},rO="wrapper";function sO(e){let{components:n,...t}=e;return(0,s.yg)(rO,(0,p.A)({},pO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given task concurrently."))}sO.isMDXComponent=!0;const cO={toc:[]},aO="wrapper";function iO(e){let{components:n,...t}=e;return(0,s.yg)(aO,(0,p.A)({},cO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a generator function or a task to run."))}iO.isMDXComponent=!0;const lO={toc:[]},uO="wrapper";function mO(e){let{components:n,...t}=e;return(0,s.yg)(uO,(0,p.A)({},lO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"From the perspective of the external generator, ",(0,s.yg)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.yg)("inlineCode",{parentName:"p"},"threads")," generator."))}mO.isMDXComponent=!0;const yO={toc:[]},dO="wrapper";function hO(e){let{components:n,...t}=e;return(0,s.yg)(dO,(0,p.A)({},yO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}hO.isMDXComponent=!0;const gO={toc:[]},fO="wrapper";function DO(e){let{components:n,...t}=e;return(0,s.yg)(fO,(0,p.A)({},gO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a context in which generators can be run concurrently."))}DO.isMDXComponent=!0;const MO={toc:[]},XO="wrapper";function _O(e){let{components:n,...t}=e;return(0,s.yg)(XO,(0,p.A)({},MO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns the generator to run."))}_O.isMDXComponent=!0;const wO={toc:[]},TO="wrapper";function CO(e){let{components:n,...t}=e;return(0,s.yg)(TO,(0,p.A)({},wO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}CO.isMDXComponent=!0;const xO={toc:[]},AO="wrapper";function vO(e){let{components:n,...t}=e;return(0,s.yg)(AO,(0,p.A)({},xO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transitions between scenes."))}vO.isMDXComponent=!0;const LO={toc:[]},bO="wrapper";function NO(e){let{components:n,...t}=e;return(0,s.yg)(bO,(0,p.A)({},LO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that fades between the scenes."))}NO.isMDXComponent=!0;const kO={toc:[]},zO="wrapper";function PO(e){let{components:n,...t}=e;return(0,s.yg)(zO,(0,p.A)({},kO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}PO.isMDXComponent=!0;const IO={toc:[]},RO="wrapper";function WO(e){let{components:n,...t}=e;return(0,s.yg)(RO,(0,p.A)({},IO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that slides the scene in the given direction."))}WO.isMDXComponent=!0;const SO={toc:[]},BO="wrapper";function GO(e){let{components:n,...t}=e;return(0,s.yg)(BO,(0,p.A)({},SO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The direction in which to slide."))}GO.isMDXComponent=!0;const EO={toc:[]},OO="wrapper";function UO(e){let{components:n,...t}=e;return(0,s.yg)(OO,(0,p.A)({},EO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}UO.isMDXComponent=!0;const FO={toc:[]},VO="wrapper";function qO(e){let{components:n,...t}=e;return(0,s.yg)(VO,(0,p.A)({},FO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that slides the scene towards the given origin."))}qO.isMDXComponent=!0;const jO={toc:[]},HO="wrapper";function YO(e){let{components:n,...t}=e;return(0,s.yg)(HO,(0,p.A)({},jO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The origin towards which to slide."))}YO.isMDXComponent=!0;const QO={toc:[]},$O="wrapper";function KO(e){let{components:n,...t}=e;return(0,s.yg)($O,(0,p.A)({},QO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}KO.isMDXComponent=!0;const JO={toc:[]},ZO="wrapper";function eU(e){let{components:n,...t}=e;return(0,s.yg)(ZO,(0,p.A)({},JO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}eU.isMDXComponent=!0;const nU={toc:[]},tU="wrapper";function oU(e){let{components:n,...t}=e;return(0,s.yg)(tU,(0,p.A)({},nU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to use before the current scene is rendered."))}oU.isMDXComponent=!0;const pU={toc:[]},rU="wrapper";function sU(e){let{components:n,...t}=e;return(0,s.yg)(rU,(0,p.A)({},pU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to use before the previous scene is rendered."))}sU.isMDXComponent=!0;const cU={toc:[]},aU="wrapper";function iU(e){let{components:n,...t}=e;return(0,s.yg)(aU,(0,p.A)({},cU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the previous scene should be rendered on top."))}iU.isMDXComponent=!0;const lU={toc:[]},uU="wrapper";function mU(e){let{components:n,...t}=e;return(0,s.yg)(uU,(0,p.A)({},lU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that zooms in on a given area of the scene."))}mU.isMDXComponent=!0;const yU={toc:[]},dU="wrapper";function hU(e){let{components:n,...t}=e;return(0,s.yg)(dU,(0,p.A)({},yU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The area on which to zoom in."))}hU.isMDXComponent=!0;const gU={toc:[]},fU="wrapper";function DU(e){let{components:n,...t}=e;return(0,s.yg)(fU,(0,p.A)({},gU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}DU.isMDXComponent=!0;const MU={toc:[]},XU="wrapper";function _U(e){let{components:n,...t}=e;return(0,s.yg)(XU,(0,p.A)({},MU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that zooms out from a given area of the scene."))}_U.isMDXComponent=!0;const wU={toc:[]},TU="wrapper";function CU(e){let{components:n,...t}=e;return(0,s.yg)(TU,(0,p.A)({},wU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The area from which to zoom out."))}CU.isMDXComponent=!0;const xU={toc:[]},AU="wrapper";function vU(e){let{components:n,...t}=e;return(0,s.yg)(AU,(0,p.A)({},xU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vU.isMDXComponent=!0;const LU={toc:[]},bU="wrapper";function NU(e){let{components:n,...t}=e;return(0,s.yg)(bU,(0,p.A)({},LU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolation and timing of tweens."))}NU.isMDXComponent=!0;const kU={toc:[]},zU="wrapper";function PU(e){let{components:n,...t}=e;return(0,s.yg)(zU,(0,p.A)({},kU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Any old key that is missing in ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.yg)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"})))}PU.isMDXComponent=!0;const IU={toc:[]},RU="wrapper";function WU(e){let{components:n,...t}=e;return(0,s.yg)(RU,(0,p.A)({},IU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A value matching the structure of from and to."))}WU.isMDXComponent=!0;const SU={toc:[]},BU="wrapper";function GU(e){let{components:n,...t}=e;return(0,s.yg)(BU,(0,p.A)({},SU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}GU.isMDXComponent=!0;const EU={toc:[]},OU="wrapper";function UU(e){let{components:n,...t}=e;return(0,s.yg)(OU,(0,p.A)({},EU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 0."))}UU.isMDXComponent=!0;const FU={toc:[]},VU="wrapper";function qU(e){let{components:n,...t}=e;return(0,s.yg)(VU,(0,p.A)({},FU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 1."))}qU.isMDXComponent=!0;const jU={toc:[]},HU="wrapper";function YU(e){let{components:n,...t}=e;return(0,s.yg)(HU,(0,p.A)({},jU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}YU.isMDXComponent=!0;const QU={toc:[]},$U="wrapper";function KU(e){let{components:n,...t}=e;return(0,s.yg)($U,(0,p.A)({},QU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A value matching the structure of from and to."))}KU.isMDXComponent=!0;const JU={toc:[]},ZU="wrapper";function eF(e){let{components:n,...t}=e;return(0,s.yg)(ZU,(0,p.A)({},JU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}eF.isMDXComponent=!0;const nF={toc:[]},tF="wrapper";function oF(e){let{components:n,...t}=e;return(0,s.yg)(tF,(0,p.A)({},nF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 0."))}oF.isMDXComponent=!0;const pF={toc:[]},rF="wrapper";function sF(e){let{components:n,...t}=e;return(0,s.yg)(rF,(0,p.A)({},pF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 1."))}sF.isMDXComponent=!0;const cF={toc:[]},aF="wrapper";function iF(e){let{components:n,...t}=e;return(0,s.yg)(aF,(0,p.A)({},cF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}iF.isMDXComponent=!0;const lF={toc:[]},uF="wrapper";function mF(e){let{components:n,...t}=e;return(0,s.yg)(uF,(0,p.A)({},lF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Complex types used in animations."))}mF.isMDXComponent=!0;const yF={toc:[]},dF="wrapper";function hF(e){let{components:n,...t}=e;return(0,s.yg)(dF,(0,p.A)({},yF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/BBox#expand"},(0,s.yg)("inlineCode",{parentName:"a"},"expand"))," instead."))}hF.isMDXComponent=!0;const gF={toc:[]},fF="wrapper";function DF(e){let{components:n,...t}=e;return(0,s.yg)(fF,(0,p.A)({},gF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Expand the bounding box to accommodate the given spacing."))}DF.isMDXComponent=!0;const MF={toc:[]},XF="wrapper";function _F(e){let{components:n,...t}=e;return(0,s.yg)(XF,(0,p.A)({},MF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to expand the bounding box by."))}_F.isMDXComponent=!0;const wF={toc:[]},TF="wrapper";function CF(e){let{components:n,...t}=e;return(0,s.yg)(TF,(0,p.A)({},wF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Expand the bounding box to accommodate the given spacing."))}CF.isMDXComponent=!0;const xF={toc:[]},AF="wrapper";function vF(e){let{components:n,...t}=e;return(0,s.yg)(AF,(0,p.A)({},xF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to expand the bounding box by."))}vF.isMDXComponent=!0;const LF={toc:[]},bF="wrapper";function NF(e){let{components:n,...t}=e;return(0,s.yg)(bF,(0,p.A)({},LF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.yg)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.yg)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.yg)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.yg)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.yg)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.yg)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}NF.isMDXComponent=!0;const kF={toc:[]},zF="wrapper";function PF(e){let{components:n,...t}=e;return(0,s.yg)(zF,(0,p.A)({},kF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the determinant of the matrix."))}PF.isMDXComponent=!0;const IF={toc:[]},RF="wrapper";function WF(e){let{components:n,...t}=e;return(0,s.yg)(RF,(0,p.A)({},IF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.yg)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", instead."))}WF.isMDXComponent=!0;const SF={toc:[]},BF="wrapper";function GF(e){let{components:n,...t}=e;return(0,s.yg)(BF,(0,p.A)({},SF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}GF.isMDXComponent=!0;const EF={toc:[]},OF="wrapper";function UF(e){let{components:n,...t}=e;return(0,s.yg)(OF,(0,p.A)({},EF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the inverse of the matrix."))}UF.isMDXComponent=!0;const FF={toc:[]},VF="wrapper";function qF(e){let{components:n,...t}=e;return(0,s.yg)(VF,(0,p.A)({},FF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}qF.isMDXComponent=!0;const jF={toc:[]},HF="wrapper";function YF(e){let{components:n,...t}=e;return(0,s.yg)(HF,(0,p.A)({},jF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}YF.isMDXComponent=!0;const QF={toc:[]},$F="wrapper";function KF(e){let{components:n,...t}=e;return(0,s.yg)($F,(0,p.A)({},QF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the provided matrix to this matrix."))}KF.isMDXComponent=!0;const JF={toc:[]},ZF="wrapper";function eV(e){let{components:n,...t}=e;return(0,s.yg)(ZF,(0,p.A)({},JF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to add"))}eV.isMDXComponent=!0;const nV={toc:[]},tV="wrapper";function oV(e){let{components:n,...t}=e;return(0,s.yg)(tV,(0,p.A)({},nV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}oV.isMDXComponent=!0;const pV={toc:[]},rV="wrapper";function sV(e){let{components:n,...t}=e;return(0,s.yg)(rV,(0,p.A)({},pV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}sV.isMDXComponent=!0;const cV={toc:[]},aV="wrapper";function iV(e){let{components:n,...t}=e;return(0,s.yg)(aV,(0,p.A)({},cV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the component vector to retrieve."))}iV.isMDXComponent=!0;const lV={toc:[]},uV="wrapper";function mV(e){let{components:n,...t}=e;return(0,s.yg)(uV,(0,p.A)({},lV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}mV.isMDXComponent=!0;const yV={toc:[]},dV="wrapper";function hV(e){let{components:n,...t}=e;return(0,s.yg)(dV,(0,p.A)({},yV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}hV.isMDXComponent=!0;const gV={toc:[]},fV="wrapper";function DV(e){let{components:n,...t}=e;return(0,s.yg)(fV,(0,p.A)({},gV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}DV.isMDXComponent=!0;const MV={toc:[]},XV="wrapper";function _V(e){let{components:n,...t}=e;return(0,s.yg)(XV,(0,p.A)({},MV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to multiply with"))}_V.isMDXComponent=!0;const wV={toc:[]},TV="wrapper";function CV(e){let{components:n,...t}=e;return(0,s.yg)(TV,(0,p.A)({},wV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}CV.isMDXComponent=!0;const xV={toc:[]},AV="wrapper";function vV(e){let{components:n,...t}=e;return(0,s.yg)(AV,(0,p.A)({},xV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}vV.isMDXComponent=!0;const LV={toc:[]},bV="wrapper";function NV(e){let{components:n,...t}=e;return(0,s.yg)(bV,(0,p.A)({},LV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value by which to scale each term"))}NV.isMDXComponent=!0;const kV={toc:[]},zV="wrapper";function PV(e){let{components:n,...t}=e;return(0,s.yg)(zV,(0,p.A)({},kV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}PV.isMDXComponent=!0;const IV={toc:[]},RV="wrapper";function WV(e){let{components:n,...t}=e;return(0,s.yg)(RV,(0,p.A)({},IV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}WV.isMDXComponent=!0;const SV={toc:[]},BV="wrapper";function GV(e){let{components:n,...t}=e;return(0,s.yg)(BV,(0,p.A)({},SV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}GV.isMDXComponent=!0;const EV={toc:[]},OV="wrapper";function UV(e){let{components:n,...t}=e;return(0,s.yg)(OV,(0,p.A)({},EV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The angle by which to rotate the matrix."))}UV.isMDXComponent=!0;const FV={toc:[]},VV="wrapper";function qV(e){let{components:n,...t}=e;return(0,s.yg)(VV,(0,p.A)({},FV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the angle is provided in degrees."))}qV.isMDXComponent=!0;const jV={toc:[]},HV="wrapper";function YV(e){let{components:n,...t}=e;return(0,s.yg)(HV,(0,p.A)({},jV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}YV.isMDXComponent=!0;const QV={toc:[]},$V="wrapper";function KV(e){let{components:n,...t}=e;return(0,s.yg)($V,(0,p.A)({},QV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}KV.isMDXComponent=!0;const JV={toc:[]},ZV="wrapper";function eq(e){let{components:n,...t}=e;return(0,s.yg)(ZV,(0,p.A)({},JV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the row to retrieve."))}eq.isMDXComponent=!0;const nq={toc:[]},tq="wrapper";function oq(e){let{components:n,...t}=e;return(0,s.yg)(tq,(0,p.A)({},nq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}oq.isMDXComponent=!0;const pq={toc:[]},rq="wrapper";function sq(e){let{components:n,...t}=e;return(0,s.yg)(rq,(0,p.A)({},pq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}sq.isMDXComponent=!0;const cq={toc:[]},aq="wrapper";function iq(e){let{components:n,...t}=e;return(0,s.yg)(aq,(0,p.A)({},cq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scale the x and y component vectors of the matrix."))}iq.isMDXComponent=!0;const lq={toc:[]},uq="wrapper";function mq(e){let{components:n,...t}=e;return(0,s.yg)(uq,(0,p.A)({},lq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The factor by which to scale the matrix"))}mq.isMDXComponent=!0;const yq={toc:[]},dq="wrapper";function hq(e){let{components:n,...t}=e;return(0,s.yg)(dq,(0,p.A)({},yq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}hq.isMDXComponent=!0;const gq={toc:[]},fq="wrapper";function Dq(e){let{components:n,...t}=e;return(0,s.yg)(fq,(0,p.A)({},gq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}Dq.isMDXComponent=!0;const Mq={toc:[]},Xq="wrapper";function _q(e){let{components:n,...t}=e;return(0,s.yg)(Xq,(0,p.A)({},Mq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subtract the provided matrix from this matrix."))}_q.isMDXComponent=!0;const wq={toc:[]},Tq="wrapper";function Cq(e){let{components:n,...t}=e;return(0,s.yg)(Tq,(0,p.A)({},wq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to subract"))}Cq.isMDXComponent=!0;const xq={toc:[]},Aq="wrapper";function vq(e){let{components:n,...t}=e;return(0,s.yg)(Aq,(0,p.A)({},xq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}vq.isMDXComponent=!0;const Lq={toc:[]},bq="wrapper";function Nq(e){let{components:n,...t}=e;return(0,s.yg)(bq,(0,p.A)({},Lq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}Nq.isMDXComponent=!0;const kq={toc:[]},zq="wrapper";function Pq(e){let{components:n,...t}=e;return(0,s.yg)(zq,(0,p.A)({},kq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Pq.isMDXComponent=!0;const Iq={toc:[]},Rq="wrapper";function Wq(e){let{components:n,...t}=e;return(0,s.yg)(Rq,(0,p.A)({},Iq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector by which to translate the matrix"))}Wq.isMDXComponent=!0;const Sq={toc:[]},Bq="wrapper";function Gq(e){let{components:n,...t}=e;return(0,s.yg)(Bq,(0,p.A)({},Sq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a two-dimensional vector."))}Gq.isMDXComponent=!0;const Eq={toc:[]},Oq="wrapper";function Uq(e){let{components:n,...t}=e;return(0,s.yg)(Oq,(0,p.A)({},Eq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(0, 1)")))}Uq.isMDXComponent=!0;const Fq={toc:[]},Vq="wrapper";function qq(e){let{components:n,...t}=e;return(0,s.yg)(Vq,(0,p.A)({},Fq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(-1, 1)")))}qq.isMDXComponent=!0;const jq={toc:[]},Hq="wrapper";function Yq(e){let{components:n,...t}=e;return(0,s.yg)(Hq,(0,p.A)({},jq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(1, 1)")))}Yq.isMDXComponent=!0;const Qq={toc:[]},$q="wrapper";function Kq(e){let{components:n,...t}=e;return(0,s.yg)($q,(0,p.A)({},Qq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(0, -1)")))}Kq.isMDXComponent=!0;const Jq={toc:[]},Zq="wrapper";function ej(e){let{components:n,...t}=e;return(0,s.yg)(Zq,(0,p.A)({},Jq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(-1, -1)")))}ej.isMDXComponent=!0;const nj={toc:[]},tj="wrapper";function oj(e){let{components:n,...t}=e;return(0,s.yg)(tj,(0,p.A)({},nj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(1, -1)")))}oj.isMDXComponent=!0;const pj={toc:[]},rj="wrapper";function sj(e){let{components:n,...t}=e;return(0,s.yg)(rj,(0,p.A)({},pj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned angle will be between -180 and 180 degrees."))}sj.isMDXComponent=!0;const cj={toc:[]},aj="wrapper";function ij(e){let{components:n,...t}=e;return(0,s.yg)(aj,(0,p.A)({},cj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}ij.isMDXComponent=!0;const lj={toc:[]},uj="wrapper";function mj(e){let{components:n,...t}=e;return(0,s.yg)(uj,(0,p.A)({},lj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}mj.isMDXComponent=!0;const yj={toc:[]},dj="wrapper";function hj(e){let{components:n,...t}=e;return(0,s.yg)(dj,(0,p.A)({},yj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.yg)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}hj.isMDXComponent=!0;const gj={toc:[]},fj="wrapper";function Dj(e){let{components:n,...t}=e;return(0,s.yg)(fj,(0,p.A)({},gj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if two vectors are equal to each other."))}Dj.isMDXComponent=!0;const Mj={toc:[]},Xj="wrapper";function _j(e){let{components:n,...t}=e;return(0,s.yg)(Xj,(0,p.A)({},Mj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector to compare."))}_j.isMDXComponent=!0;const wj={toc:[]},Tj="wrapper";function Cj(e){let{components:n,...t}=e;return(0,s.yg)(Tj,(0,p.A)({},wj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The allowed error threshold when comparing the vectors."))}Cj.isMDXComponent=!0;const xj={toc:[]},Aj="wrapper";function vj(e){let{components:n,...t}=e;return(0,s.yg)(Aj,(0,p.A)({},xj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.yg)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}vj.isMDXComponent=!0;const Lj={toc:[]},bj="wrapper";function Nj(e){let{components:n,...t}=e;return(0,s.yg)(bj,(0,p.A)({},Lj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if two vectors are exactly equal to each other."))}Nj.isMDXComponent=!0;const kj={toc:[]},zj="wrapper";function Pj(e){let{components:n,...t}=e;return(0,s.yg)(zj,(0,p.A)({},kj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector to compare."))}Pj.isMDXComponent=!0;const Ij={toc:[]},Rj="wrapper";function Wj(e){let{components:n,...t}=e;return(0,s.yg)(Rj,(0,p.A)({},Ij,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotates the vector around a point by the provided angle."))}Wj.isMDXComponent=!0;const Sj={toc:[]},Bj="wrapper";function Gj(e){let{components:n,...t}=e;return(0,s.yg)(Bj,(0,p.A)({},Sj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The angle by which to rotate in degrees."))}Gj.isMDXComponent=!0;const Ej={toc:[]},Oj="wrapper";function Uj(e){let{components:n,...t}=e;return(0,s.yg)(Oj,(0,p.A)({},Ej,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}Uj.isMDXComponent=!0;const Fj={toc:[]},Vj="wrapper";function qj(e){let{components:n,...t}=e;return(0,s.yg)(Vj,(0,p.A)({},Fj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Helper function to create a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.yg)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}qj.isMDXComponent=!0;const jj={toc:[]},Hj="wrapper";function Yj(e){let{components:n,...t}=e;return(0,s.yg)(Hj,(0,p.A)({},jj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the point should get rotated\ncounterclockwise."))}Yj.isMDXComponent=!0;const Qj={toc:[]},$j="wrapper";function Kj(e){let{components:n,...t}=e;return(0,s.yg)($j,(0,p.A)({},Qj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}Kj.isMDXComponent=!0;const Jj={toc:[]},Zj="wrapper";function eH(e){let{components:n,...t}=e;return(0,s.yg)(Zj,(0,p.A)({},Jj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned angle will be between -180 and 180 degrees."))}eH.isMDXComponent=!0;const nH={toc:[]},tH="wrapper";function oH(e){let{components:n,...t}=e;return(0,s.yg)(tH,(0,p.A)({},nH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}oH.isMDXComponent=!0;const pH={toc:[]},rH="wrapper";function sH(e){let{components:n,...t}=e;return(0,s.yg)(rH,(0,p.A)({},pH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x component of the vector."))}sH.isMDXComponent=!0;const cH={toc:[]},aH="wrapper";function iH(e){let{components:n,...t}=e;return(0,s.yg)(aH,(0,p.A)({},cH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y component of the vector."))}iH.isMDXComponent=!0;const lH={toc:[]},uH="wrapper";function mH(e){let{components:n,...t}=e;return(0,s.yg)(uH,(0,p.A)({},lH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This function is useful when used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.yg)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}mH.isMDXComponent=!0;const yH={toc:[]},dH="wrapper";function hH(e){let{components:n,...t}=e;return(0,s.yg)(dH,(0,p.A)({},yH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Animating an object in a circle around the origin"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}hH.isMDXComponent=!0;const gH={toc:[]},fH="wrapper";function DH(e){let{components:n,...t}=e;return(0,s.yg)(fH,(0,p.A)({},gH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotating an object around the point ",(0,s.yg)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}DH.isMDXComponent=!0;const MH={toc:[]},XH="wrapper";function _H(e){let{components:n,...t}=e;return(0,s.yg)(XH,(0,p.A)({},MH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}_H.isMDXComponent=!0;const wH={toc:[]},TH="wrapper";function CH(e){let{components:n,...t}=e;return(0,s.yg)(TH,(0,p.A)({},wH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}CH.isMDXComponent=!0;const xH={toc:[]},AH="wrapper";function vH(e){let{components:n,...t}=e;return(0,s.yg)(AH,(0,p.A)({},xH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting vector."))}vH.isMDXComponent=!0;const LH={toc:[]},bH="wrapper";function NH(e){let{components:n,...t}=e;return(0,s.yg)(bH,(0,p.A)({},LH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The target vector."))}NH.isMDXComponent=!0;const kH={toc:[]},zH="wrapper";function PH(e){let{components:n,...t}=e;return(0,s.yg)(zH,(0,p.A)({},kH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t-value of the interpolation."))}PH.isMDXComponent=!0;const IH={toc:[]},RH="wrapper";function WH(e){let{components:n,...t}=e;return(0,s.yg)(RH,(0,p.A)({},IH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.yg)("inlineCode",{parentName:"p"},"false"),"."))}WH.isMDXComponent=!0;const SH={toc:[]},BH="wrapper";function GH(e){let{components:n,...t}=e;return(0,s.yg)(BH,(0,p.A)({},SH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}GH.isMDXComponent=!0;const EH={toc:[]},OH="wrapper";function UH(e){let{components:n,...t}=e;return(0,s.yg)(OH,(0,p.A)({},EH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}UH.isMDXComponent=!0;const FH={toc:[]},VH="wrapper";function qH(e){let{components:n,...t}=e;return(0,s.yg)(VH,(0,p.A)({},FH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x component of the vector."))}qH.isMDXComponent=!0;const jH={toc:[]},HH="wrapper";function YH(e){let{components:n,...t}=e;return(0,s.yg)(HH,(0,p.A)({},jH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y component of the vector."))}YH.isMDXComponent=!0;const QH={toc:[]},$H="wrapper";function KH(e){let{components:n,...t}=e;return(0,s.yg)($H,(0,p.A)({},QH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same class as the one created by\n",(0,s.yg)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.yg)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}KH.isMDXComponent=!0;const JH={toc:[]},ZH="wrapper";function eY(e){let{components:n,...t}=e;return(0,s.yg)(ZH,(0,p.A)({},JH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a color."))}eY.isMDXComponent=!0;const nY={toc:[]},tY="wrapper";function oY(e){let{components:n,...t}=e;return(0,s.yg)(tY,(0,p.A)({},nY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}oY.isMDXComponent=!0;const pY={toc:[]},rY="wrapper";function sY(e){let{components:n,...t}=e;return(0,s.yg)(rY,(0,p.A)({},pY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert the given origin to a vector representing its offset."))}sY.isMDXComponent=!0;const cY={toc:[]},aY="wrapper";function iY(e){let{components:n,...t}=e;return(0,s.yg)(aY,(0,p.A)({},cY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The origin to convert."))}iY.isMDXComponent=!0;const lY={toc:[]},uY="wrapper";function mY(e){let{components:n,...t}=e;return(0,s.yg)(uY,(0,p.A)({},lY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"General utilities and helper functions."))}mY.isMDXComponent=!0;const yY={toc:[]},dY="wrapper";function hY(e){let{components:n,...t}=e;return(0,s.yg)(dY,(0,p.A)({},yY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}hY.isMDXComponent=!0;const gY={toc:[]},fY="wrapper";function DY(e){let{components:n,...t}=e;return(0,s.yg)(fY,(0,p.A)({},gY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}DY.isMDXComponent=!0;const MY={toc:[]},XY="wrapper";function _Y(e){let{components:n,...t}=e;return(0,s.yg)(XY,(0,p.A)({},MY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}_Y.isMDXComponent=!0;const wY={toc:[]},TY="wrapper";function CY(e){let{components:n,...t}=e;return(0,s.yg)(TY,(0,p.A)({},wY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}CY.isMDXComponent=!0;const xY={toc:[]},AY="wrapper";function vY(e){let{components:n,...t}=e;return(0,s.yg)(AY,(0,p.A)({},xY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}vY.isMDXComponent=!0;const LY={toc:[]},bY="wrapper";function NY(e){let{components:n,...t}=e;return(0,s.yg)(bY,(0,p.A)({},LY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}NY.isMDXComponent=!0;const kY={toc:[]},zY="wrapper";function PY(e){let{components:n,...t}=e;return(0,s.yg)(zY,(0,p.A)({},kY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}PY.isMDXComponent=!0;const IY={toc:[]},RY="wrapper";function WY(e){let{components:n,...t}=e;return(0,s.yg)(RY,(0,p.A)({},IY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}WY.isMDXComponent=!0;const SY={toc:[]},BY="wrapper";function GY(e){let{components:n,...t}=e;return(0,s.yg)(BY,(0,p.A)({},SY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}GY.isMDXComponent=!0;const EY={toc:[]},OY="wrapper";function UY(e){let{components:n,...t}=e;return(0,s.yg)(OY,(0,p.A)({},EY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Optional override for formatting stack traces"))}UY.isMDXComponent=!0;const FY={toc:[]},VY="wrapper";function qY(e){let{components:n,...t}=e;return(0,s.yg)(VY,(0,p.A)({},FY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create .stack property on a target object"))}qY.isMDXComponent=!0;const jY={toc:[]},HY="wrapper";function YY(e){let{components:n,...t}=e;return(0,s.yg)(HY,(0,p.A)({},jY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}YY.isMDXComponent=!0;const QY={toc:[]},$Y="wrapper";function KY(e){let{components:n,...t}=e;return(0,s.yg)($Y,(0,p.A)({},QY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}KY.isMDXComponent=!0;const JY={toc:[]},ZY="wrapper";function eQ(e){let{components:n,...t}=e;return(0,s.yg)(ZY,(0,p.A)({},JY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}eQ.isMDXComponent=!0;const nQ={toc:[]},tQ="wrapper";function oQ(e){let{components:n,...t}=e;return(0,s.yg)(tQ,(0,p.A)({},nQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}oQ.isMDXComponent=!0;const pQ={toc:[]},rQ="wrapper";function sQ(e){let{components:n,...t}=e;return(0,s.yg)(rQ,(0,p.A)({},pQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}sQ.isMDXComponent=!0;const cQ={toc:[]},aQ="wrapper";function iQ(e){let{components:n,...t}=e;return(0,s.yg)(aQ,(0,p.A)({},cQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}iQ.isMDXComponent=!0;const lQ={toc:[]},uQ="wrapper";function mQ(e){let{components:n,...t}=e;return(0,s.yg)(uQ,(0,p.A)({},lQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}mQ.isMDXComponent=!0;const yQ={toc:[]},dQ="wrapper";function hQ(e){let{components:n,...t}=e;return(0,s.yg)(dQ,(0,p.A)({},yQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}hQ.isMDXComponent=!0;const gQ={toc:[]},fQ="wrapper";function DQ(e){let{components:n,...t}=e;return(0,s.yg)(fQ,(0,p.A)({},gQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}DQ.isMDXComponent=!0;const MQ={toc:[]},XQ="wrapper";function _Q(e){let{components:n,...t}=e;return(0,s.yg)(XQ,(0,p.A)({},MQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Optional override for formatting stack traces"))}_Q.isMDXComponent=!0;const wQ={toc:[]},TQ="wrapper";function CQ(e){let{components:n,...t}=e;return(0,s.yg)(TQ,(0,p.A)({},wQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create .stack property on a target object"))}CQ.isMDXComponent=!0;const xQ={toc:[]},AQ="wrapper";function vQ(e){let{components:n,...t}=e;return(0,s.yg)(AQ,(0,p.A)({},xQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An array of the transformed references."))}vQ.isMDXComponent=!0;const LQ={toc:[]},bQ="wrapper";function NQ(e){let{components:n,...t}=e;return(0,s.yg)(bQ,(0,p.A)({},LQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Maps the references in this group to a new array."))}NQ.isMDXComponent=!0;const kQ={toc:[]},zQ="wrapper";function PQ(e){let{components:n,...t}=e;return(0,s.yg)(zQ,(0,p.A)({},kQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function to transform each reference."))}PQ.isMDXComponent=!0;const IQ={toc:[]},RQ="wrapper";function WQ(e){let{components:n,...t}=e;return(0,s.yg)(RQ,(0,p.A)({},IQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}WQ.isMDXComponent=!0;const SQ={toc:[]},BQ="wrapper";function GQ(e){let{components:n,...t}=e;return(0,s.yg)(BQ,(0,p.A)({},SQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant for converting degrees to radians"))}GQ.isMDXComponent=!0;const EQ={toc:[]},OQ="wrapper";function UQ(e){let{components:n,...t}=e;return(0,s.yg)(OQ,(0,p.A)({},EQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}UQ.isMDXComponent=!0;const FQ={toc:[]},VQ="wrapper";function qQ(e){let{components:n,...t}=e;return(0,s.yg)(VQ,(0,p.A)({},FQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant for converting radians to degrees"))}qQ.isMDXComponent=!0;const jQ={toc:[]},HQ="wrapper";function YQ(e){let{components:n,...t}=e;return(0,s.yg)(HQ,(0,p.A)({},jQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.yg)("inlineCode",{parentName:"p"},"ref")," property of a node."))}YQ.isMDXComponent=!0;const QQ={toc:[]},$Q="wrapper";function KQ(e){let{components:n,...t}=e;return(0,s.yg)($Q,(0,p.A)({},QQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}KQ.isMDXComponent=!0;const JQ={toc:[]},ZQ="wrapper";function e$(e){let{components:n,...t}=e;return(0,s.yg)(ZQ,(0,p.A)({},JQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array of references."))}e$.isMDXComponent=!0;const n$={toc:[]},t$="wrapper";function o$(e){let{components:n,...t}=e;return(0,s.yg)(t$,(0,p.A)({},n$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.yg)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}o$.isMDXComponent=!0;const p$={toc:[]},r$="wrapper";function s$(e){let{components:n,...t}=e;return(0,s.yg)(r$,(0,p.A)({},p$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}s$.isMDXComponent=!0;const c$={toc:[]},a$="wrapper";function i$(e){let{components:n,...t}=e;return(0,s.yg)(a$,(0,p.A)({},c$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a group of references."))}i$.isMDXComponent=!0;const l$={toc:[]},u$="wrapper";function m$(e){let{components:n,...t}=e;return(0,s.yg)(u$,(0,p.A)({},l$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is a shortcut for calling ",(0,s.yg)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}m$.isMDXComponent=!0;const y$={toc:[]},d$="wrapper";function h$(e){let{components:n,...t}=e;return(0,s.yg)(d$,(0,p.A)({},y$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}h$.isMDXComponent=!0;const g$={toc:[]},f$="wrapper";function D$(e){let{components:n,...t}=e;return(0,s.yg)(f$,(0,p.A)({},g$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Logs a debug message with an arbitrary payload."))}D$.isMDXComponent=!0;const M$={toc:[]},X$="wrapper";function _$(e){let{components:n,...t}=e;return(0,s.yg)(X$,(0,p.A)({},M$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The payload to log"))}_$.isMDXComponent=!0;const w$={toc:[]},T$="wrapper";function C$(e){let{components:n,...t}=e;return(0,s.yg)(T$,(0,p.A)({},w$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mark the given function as deprecated."))}C$.isMDXComponent=!0;const x$={toc:[]},A$="wrapper";function v$(e){let{components:n,...t}=e;return(0,s.yg)(A$,(0,p.A)({},x$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function to deprecate."))}v$.isMDXComponent=!0;const L$={toc:[]},b$="wrapper";function N$(e){let{components:n,...t}=e;return(0,s.yg)(b$,(0,p.A)({},L$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The log message."))}N$.isMDXComponent=!0;const k$={toc:[]},z$="wrapper";function P$(e){let{components:n,...t}=e;return(0,s.yg)(z$,(0,p.A)({},k$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The optional log remarks."))}P$.isMDXComponent=!0;const I$={toc:[]},R$="wrapper";function W$(e){let{components:n,...t}=e;return(0,s.yg)(R$,(0,p.A)({},I$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}W$.isMDXComponent=!0;const S$={toc:[]},B$="wrapper";function G$(e){let{components:n,...t}=e;return(0,s.yg)(B$,(0,p.A)({},S$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mark the current scene as ready to transition out."))}G$.isMDXComponent=!0;const E$={toc:[]},O$="wrapper";function U$(e){let{components:n,...t}=e;return(0,s.yg)(O$,(0,p.A)({},E$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}U$.isMDXComponent=!0;const F$={toc:[]},V$="wrapper";function q$(e){let{components:n,...t}=e;return(0,s.yg)(V$,(0,p.A)({},F$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.yg)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}q$.isMDXComponent=!0;const j$={toc:[]},H$="wrapper";function Y$(e){let{components:n,...t}=e;return(0,s.yg)(H$,(0,p.A)({},j$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}Y$.isMDXComponent=!0;const Q$={toc:[]},$$="wrapper";function K$(e){let{components:n,...t}=e;return(0,s.yg)($$,(0,p.A)({},Q$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}K$.isMDXComponent=!0;const J$={toc:[]},Z$="wrapper";function eK(e){let{components:n,...t}=e;return(0,s.yg)(Z$,(0,p.A)({},J$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The length of the array."))}eK.isMDXComponent=!0;const nK={toc:[]},tK="wrapper";function oK(e){let{components:n,...t}=e;return(0,s.yg)(tK,(0,p.A)({},nK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}oK.isMDXComponent=!0;const pK={toc:[]},rK="wrapper";function sK(e){let{components:n,...t}=e;return(0,s.yg)(rK,(0,p.A)({},pK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}sK.isMDXComponent=!0;const cK={toc:[]},aK="wrapper";function iK(e){let{components:n,...t}=e;return(0,s.yg)(aK,(0,p.A)({},cK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}iK.isMDXComponent=!0;const lK={toc:[]},uK="wrapper";function mK(e){let{components:n,...t}=e;return(0,s.yg)(uK,(0,p.A)({},lK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}mK.isMDXComponent=!0;const yK={toc:[]},dK="wrapper";function hK(e){let{components:n,...t}=e;return(0,s.yg)(dK,(0,p.A)({},yK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}hK.isMDXComponent=!0;const gK={toc:[]},fK="wrapper";function DK(e){let{components:n,...t}=e;return(0,s.yg)(fK,(0,p.A)({},gK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}DK.isMDXComponent=!0;const MK={toc:[]},XK="wrapper";function _K(e){let{components:n,...t}=e;return(0,s.yg)(XK,(0,p.A)({},MK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}_K.isMDXComponent=!0;const wK={toc:[]},TK="wrapper";function CK(e){let{components:n,...t}=e;return(0,s.yg)(TK,(0,p.A)({},wK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}CK.isMDXComponent=!0;const xK={toc:[]},AK="wrapper";function vK(e){let{components:n,...t}=e;return(0,s.yg)(AK,(0,p.A)({},xK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value by which to increment or decrement."))}vK.isMDXComponent=!0;const LK={toc:[]},bK="wrapper";function NK(e){let{components:n,...t}=e;return(0,s.yg)(bK,(0,p.A)({},LK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}NK.isMDXComponent=!0;const kK={toc:[]},zK="wrapper";function PK(e){let{components:n,...t}=e;return(0,s.yg)(zK,(0,p.A)({},kK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function that will be provided the context before render."))}PK.isMDXComponent=!0;const IK={toc:[]},RK="wrapper";function WK(e){let{components:n,...t}=e;return(0,s.yg)(RK,(0,p.A)({},IK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}WK.isMDXComponent=!0;const SK={toc:[]},BK="wrapper";function GK(e){let{components:n,...t}=e;return(0,s.yg)(BK,(0,p.A)({},SK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function that will be provided the context after render."))}GK.isMDXComponent=!0;const EK={toc:[]},OK="wrapper";function UK(e){let{components:n,...t}=e;return(0,s.yg)(OK,(0,p.A)({},EK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}UK.isMDXComponent=!0;const FK={toc:[]},VK="wrapper";function qK(e){let{components:n,...t}=e;return(0,s.yg)(VK,(0,p.A)({},FK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}qK.isMDXComponent=!0;const jK={toc:[]},HK="wrapper";function YK(e){let{components:n,...t}=e;return(0,s.yg)(HK,(0,p.A)({},jK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the event in seconds."))}YK.isMDXComponent=!0;const QK={toc:[]},$K="wrapper";function KK(e){let{components:n,...t}=e;return(0,s.yg)($K,(0,p.A)({},QK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Register a time event and get its duration in seconds."))}KK.isMDXComponent=!0;const JK={toc:[]},ZK="wrapper";function eJ(e){let{components:n,...t}=e;return(0,s.yg)(ZK,(0,p.A)({},JK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the event."))}eJ.isMDXComponent=!0;const nJ={toc:[]},tJ="wrapper";function oJ(e){let{components:n,...t}=e;return(0,s.yg)(tJ,(0,p.A)({},nJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the playback status."))}oJ.isMDXComponent=!0;const pJ={toc:[]},rJ="wrapper";function sJ(e){let{components:n,...t}=e;return(0,s.yg)(rJ,(0,p.A)({},pJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the random number generator for the current scene."))}sJ.isMDXComponent=!0;const cJ={toc:[]},aJ="wrapper";function iJ(e){let{components:n,...t}=e;return(0,s.yg)(aJ,(0,p.A)({},cJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the random number generator for the given seed."))}iJ.isMDXComponent=!0;const lJ={toc:[]},uJ="wrapper";function mJ(e){let{components:n,...t}=e;return(0,s.yg)(uJ,(0,p.A)({},lJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The seed for the generator."))}mJ.isMDXComponent=!0;const yJ={toc:[]},dJ="wrapper";function hJ(e){let{components:n,...t}=e;return(0,s.yg)(dJ,(0,p.A)({},yJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}hJ.isMDXComponent=!0;const gJ={toc:[]},fJ="wrapper";function DJ(e){let{components:n,...t}=e;return(0,s.yg)(fJ,(0,p.A)({},gJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the current scene."))}DJ.isMDXComponent=!0;const MJ={toc:[]},XJ="wrapper";function _J(e){let{components:n,...t}=e;return(0,s.yg)(XJ,(0,p.A)({},MJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the current thread."))}_J.isMDXComponent=!0;const wJ={toc:[]},TJ="wrapper";function CJ(e){let{components:n,...t}=e;return(0,s.yg)(TJ,(0,p.A)({},wJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.yg)("inlineCode",{parentName:"a"},"waitFor")),"."))}CJ.isMDXComponent=!0;const xJ={toc:[]},AJ="wrapper";function vJ(e){let{components:n,...t}=e;return(0,s.yg)(AJ,(0,p.A)({},xJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}vJ.isMDXComponent=!0;const LJ={toc:[]},bJ="wrapper";function NJ(e){let{components:n,...t}=e;return(0,s.yg)(bJ,(0,p.A)({},LJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real time since the start of the animation."))}NJ.isMDXComponent=!0;const kJ={toc:[]},zJ="wrapper";function PJ(e){let{components:n,...t}=e;return(0,s.yg)(zJ,(0,p.A)({},kJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This rewrites a remote url like ",(0,s.yg)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.yg)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}PJ.isMDXComponent=!0;const IJ={toc:[]},RJ="wrapper";function WJ(e){let{components:n,...t}=e;return(0,s.yg)(RJ,(0,p.A)({},IJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Route the given url through a local proxy."))}WJ.isMDXComponent=!0;const SJ={toc:[]},BJ="wrapper";function GJ(e){let{components:n,...t}=e;return(0,s.yg)(BJ,(0,p.A)({},SJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}GJ.isMDXComponent=!0;const EJ={toc:[]},OJ="wrapper";function UJ(e){let{components:n,...t}=e;return(0,s.yg)(OJ,(0,p.A)({},EJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}UJ.isMDXComponent=!0;const FJ={toc:[]},VJ="wrapper";function qJ(e){let{components:n,...t}=e;return(0,s.yg)(VJ,(0,p.A)({},FJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}qJ.isMDXComponent=!0;const jJ={toc:[]},HJ="wrapper";function YJ(e){let{components:n,...t}=e;return(0,s.yg)(HJ,(0,p.A)({},jJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}YJ.isMDXComponent=!0;const QJ={toc:[]},$J="wrapper";function KJ(e){let{components:n,...t}=e;return(0,s.yg)($J,(0,p.A)({},QJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}KJ.isMDXComponent=!0;const JJ={toc:[]},ZJ="wrapper";function eZ(e){let{components:n,...t}=e;return(0,s.yg)(ZJ,(0,p.A)({},JJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}eZ.isMDXComponent=!0;const nZ={toc:[]},tZ="wrapper";function oZ(e){let{components:n,...t}=e;return(0,s.yg)(tZ,(0,p.A)({},nZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}oZ.isMDXComponent=!0;const pZ={toc:[]},rZ="wrapper";function sZ(e){let{components:n,...t}=e;return(0,s.yg)(rZ,(0,p.A)({},pZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}sZ.isMDXComponent=!0;const cZ={toc:[]},aZ="wrapper";function iZ(e){let{components:n,...t}=e;return(0,s.yg)(aZ,(0,p.A)({},cZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}iZ.isMDXComponent=!0;const lZ={toc:[]},uZ="wrapper";function mZ(e){let{components:n,...t}=e;return(0,s.yg)(uZ,(0,p.A)({},lZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}mZ.isMDXComponent=!0;const yZ={toc:[]},dZ="wrapper";function hZ(e){let{components:n,...t}=e;return(0,s.yg)(dZ,(0,p.A)({},yZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}hZ.isMDXComponent=!0;const gZ={toc:[]},fZ="wrapper";function DZ(e){let{components:n,...t}=e;return(0,s.yg)(fZ,(0,p.A)({},gZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}DZ.isMDXComponent=!0;const MZ={toc:[]},XZ="wrapper";function _Z(e){let{components:n,...t}=e;return(0,s.yg)(XZ,(0,p.A)({},MZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom highlighters used by the Code node."))}_Z.isMDXComponent=!0;const wZ={toc:[]},TZ="wrapper";function CZ(e){let{components:n,...t}=e;return(0,s.yg)(TZ,(0,p.A)({},wZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Highlights the code at the given index."))}CZ.isMDXComponent=!0;const xZ={toc:[]},AZ="wrapper";function vZ(e){let{components:n,...t}=e;return(0,s.yg)(AZ,(0,p.A)({},xZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the code to highlight."))}vZ.isMDXComponent=!0;const LZ={toc:[]},bZ="wrapper";function NZ(e){let{components:n,...t}=e;return(0,s.yg)(bZ,(0,p.A)({},LZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#prepare"},(0,s.yg)("inlineCode",{parentName:"a"},"prepare")),"."))}NZ.isMDXComponent=!0;const kZ={toc:[]},zZ="wrapper";function PZ(e){let{components:n,...t}=e;return(0,s.yg)(zZ,(0,p.A)({},kZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.yg)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.yg)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}PZ.isMDXComponent=!0;const IZ={toc:[]},RZ="wrapper";function WZ(e){let{components:n,...t}=e;return(0,s.yg)(RZ,(0,p.A)({},IZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializes the highlighter."))}WZ.isMDXComponent=!0;const SZ={toc:[]},BZ="wrapper";function GZ(e){let{components:n,...t}=e;return(0,s.yg)(BZ,(0,p.A)({},SZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#highlight"},(0,s.yg)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}GZ.isMDXComponent=!0;const EZ={toc:[]},OZ="wrapper";function UZ(e){let{components:n,...t}=e;return(0,s.yg)(OZ,(0,p.A)({},EZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepares the code for highlighting."))}UZ.isMDXComponent=!0;const FZ={toc:[]},VZ="wrapper";function qZ(e){let{components:n,...t}=e;return(0,s.yg)(VZ,(0,p.A)({},FZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to prepare."))}qZ.isMDXComponent=!0;const jZ={toc:[]},HZ="wrapper";function YZ(e){let{components:n,...t}=e;return(0,s.yg)(HZ,(0,p.A)({},jZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}YZ.isMDXComponent=!0;const QZ={toc:[]},$Z="wrapper";function KZ(e){let{components:n,...t}=e;return(0,s.yg)($Z,(0,p.A)({},QZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tokenize the code."))}KZ.isMDXComponent=!0;const JZ={toc:[]},ZZ="wrapper";function e0(e){let{components:n,...t}=e;return(0,s.yg)(ZZ,(0,p.A)({},JZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}e0.isMDXComponent=!0;const n0={toc:[]},t0="wrapper";function o0(e){let{components:n,...t}=e;return(0,s.yg)(t0,(0,p.A)({},n0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}o0.isMDXComponent=!0;const p0={toc:[]},r0="wrapper";function s0(e){let{components:n,...t}=e;return(0,s.yg)(r0,(0,p.A)({},p0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom highlighters used by the Code node."))}s0.isMDXComponent=!0;const c0={toc:[]},a0="wrapper";function i0(e){let{components:n,...t}=e;return(0,s.yg)(a0,(0,p.A)({},c0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Highlights the code at the given index."))}i0.isMDXComponent=!0;const l0={toc:[]},u0="wrapper";function m0(e){let{components:n,...t}=e;return(0,s.yg)(u0,(0,p.A)({},l0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the code to highlight."))}m0.isMDXComponent=!0;const y0={toc:[]},d0="wrapper";function h0(e){let{components:n,...t}=e;return(0,s.yg)(d0,(0,p.A)({},y0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#prepare"},(0,s.yg)("inlineCode",{parentName:"a"},"prepare")),"."))}h0.isMDXComponent=!0;const g0={toc:[]},f0="wrapper";function D0(e){let{components:n,...t}=e;return(0,s.yg)(f0,(0,p.A)({},g0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.yg)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.yg)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}D0.isMDXComponent=!0;const M0={toc:[]},X0="wrapper";function _0(e){let{components:n,...t}=e;return(0,s.yg)(X0,(0,p.A)({},M0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializes the highlighter."))}_0.isMDXComponent=!0;const w0={toc:[]},T0="wrapper";function C0(e){let{components:n,...t}=e;return(0,s.yg)(T0,(0,p.A)({},w0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#highlight"},(0,s.yg)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}C0.isMDXComponent=!0;const x0={toc:[]},A0="wrapper";function v0(e){let{components:n,...t}=e;return(0,s.yg)(A0,(0,p.A)({},x0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepares the code for highlighting."))}v0.isMDXComponent=!0;const L0={toc:[]},b0="wrapper";function N0(e){let{components:n,...t}=e;return(0,s.yg)(b0,(0,p.A)({},L0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to prepare."))}N0.isMDXComponent=!0;const k0={toc:[]},z0="wrapper";function P0(e){let{components:n,...t}=e;return(0,s.yg)(z0,(0,p.A)({},k0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}P0.isMDXComponent=!0;const I0={toc:[]},R0="wrapper";function W0(e){let{components:n,...t}=e;return(0,s.yg)(R0,(0,p.A)({},I0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tokenize the code."))}W0.isMDXComponent=!0;const S0={toc:[]},B0="wrapper";function G0(e){let{components:n,...t}=e;return(0,s.yg)(B0,(0,p.A)({},S0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}G0.isMDXComponent=!0;const E0={toc:[]},O0="wrapper";function U0(e){let{components:n,...t}=e;return(0,s.yg)(O0,(0,p.A)({},E0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}U0.isMDXComponent=!0;const F0={toc:[]},V0="wrapper";function q0(e){let{components:n,...t}=e;return(0,s.yg)(V0,(0,p.A)({},F0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the cache used by the highlighter."))}q0.isMDXComponent=!0;const j0={toc:[]},H0="wrapper";function Y0(e){let{components:n,...t}=e;return(0,s.yg)(H0,(0,p.A)({},j0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes the result of a highlight operation."))}Y0.isMDXComponent=!0;const Q0={toc:[]},$0="wrapper";function K0(e){let{components:n,...t}=e;return(0,s.yg)($0,(0,p.A)({},Q0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the code at the given index."))}K0.isMDXComponent=!0;const J0={toc:[]},Z0="wrapper";function e8(e){let{components:n,...t}=e;return(0,s.yg)(Z0,(0,p.A)({},J0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This should be used to skip to the end of the currently highlighted token.\nThe returned style will be used for the skipped characters, and they will\nbe drawn as one continuous string keeping emojis and ligatures intact."),(0,s.yg)("p",null,"The returned value is the number of characters to skip ahead, not the\nindex of the end of the token."))}e8.isMDXComponent=!0;const n8={toc:[]},t8="wrapper";function o8(e){let{components:n,...t}=e;return(0,s.yg)(t8,(0,p.A)({},n8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of characters to skip ahead."))}o8.isMDXComponent=!0;const p8={toc:[]},r8="wrapper";function s8(e){let{components:n,...t}=e;return(0,s.yg)(r8,(0,p.A)({},p8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that compares two code snippets and returns a list of\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeTag"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeTag")),"s describing a transition between them."))}s8.isMDXComponent=!0;const c8={toc:[]},a8="wrapper";function i8(e){let{components:n,...t}=e;return(0,s.yg)(a8,(0,p.A)({},c8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default diffing function utilizing ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#patienceDiff"},(0,s.yg)("inlineCode",{parentName:"a"},"patienceDiff")),"."))}i8.isMDXComponent=!0;const l8={toc:[]},u8="wrapper";function m8(e){let{components:n,...t}=e;return(0,s.yg)(u8,(0,p.A)({},l8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The original code scope."))}m8.isMDXComponent=!0;const y8={toc:[]},d8="wrapper";function h8(e){let{components:n,...t}=e;return(0,s.yg)(d8,(0,p.A)({},y8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new code scope."))}h8.isMDXComponent=!0;const g8={toc:[]},f8="wrapper";function D8(e){let{components:n,...t}=e;return(0,s.yg)(f8,(0,p.A)({},g8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The inherited tokenizer to use."))}D8.isMDXComponent=!0;const M8={toc:[]},X8="wrapper";function _8(e){let{components:n,...t}=e;return(0,s.yg)(X8,(0,p.A)({},M8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default tokenizer function used by ownerless code signals."))}_8.isMDXComponent=!0;const w8={toc:[]},T8="wrapper";function C8(e){let{components:n,...t}=e;return(0,s.yg)(T8,(0,p.A)({},w8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}C8.isMDXComponent=!0;const x8={toc:[]},A8="wrapper";function v8(e){let{components:n,...t}=e;return(0,s.yg)(A8,(0,p.A)({},x8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This function will try to preserve the original fragments, resolving them\nonly if they overlap with the range."))}v8.isMDXComponent=!0;const L8={toc:[]},b8="wrapper";function N8(e){let{components:n,...t}=e;return(0,s.yg)(b8,(0,p.A)({},L8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A tuple containing the transformed fragments and the index of the\nisolated fragment within."))}N8.isMDXComponent=!0;const k8={toc:[]},z8="wrapper";function P8(e){let{components:n,...t}=e;return(0,s.yg)(z8,(0,p.A)({},k8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transform the fragments to isolate the given range into its own fragment."))}P8.isMDXComponent=!0;const I8={toc:[]},R8="wrapper";function W8(e){let{components:n,...t}=e;return(0,s.yg)(R8,(0,p.A)({},I8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The range to extract."))}W8.isMDXComponent=!0;const S8={toc:[]},B8="wrapper";function G8(e){let{components:n,...t}=e;return(0,s.yg)(B8,(0,p.A)({},S8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The fragments to transform."))}G8.isMDXComponent=!0;const E8={toc:[]},O8="wrapper";function U8(e){let{components:n,...t}=e;return(0,s.yg)(O8,(0,p.A)({},E8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all code ranges that match the given pattern."))}U8.isMDXComponent=!0;const F8={toc:[]},V8="wrapper";function q8(e){let{components:n,...t}=e;return(0,s.yg)(V8,(0,p.A)({},F8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to search in."))}q8.isMDXComponent=!0;const j8={toc:[]},H8="wrapper";function Y8(e){let{components:n,...t}=e;return(0,s.yg)(H8,(0,p.A)({},j8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to search for."))}Y8.isMDXComponent=!0;const Q8={toc:[]},$8="wrapper";function K8(e){let{components:n,...t}=e;return(0,s.yg)($8,(0,p.A)({},Q8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional limit on the number of ranges to find."))}K8.isMDXComponent=!0;const J8={toc:[]},Z8="wrapper";function e2(e){let{components:n,...t}=e;return(0,s.yg)(Z8,(0,p.A)({},J8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}e2.isMDXComponent=!0;const n2={toc:[]},t2="wrapper";function o2(e){let{components:n,...t}=e;return(0,s.yg)(t2,(0,p.A)({},n2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents an insertion of code."))}o2.isMDXComponent=!0;const p2={toc:[]},r2="wrapper";function s2(e){let{components:n,...t}=e;return(0,s.yg)(r2,(0,p.A)({},p2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to insert."))}s2.isMDXComponent=!0;const c2={toc:[]},a2="wrapper";function i2(e){let{components:n,...t}=e;return(0,s.yg)(a2,(0,p.A)({},c2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code range that spans the given lines."))}i2.isMDXComponent=!0;const l2={toc:[]},u2="wrapper";function m2(e){let{components:n,...t}=e;return(0,s.yg)(u2,(0,p.A)({},l2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line from which the range starts."))}m2.isMDXComponent=!0;const y2={toc:[]},d2="wrapper";function h2(e){let{components:n,...t}=e;return(0,s.yg)(d2,(0,p.A)({},y2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the range ends. If omitted, the range will\ncover only one line."))}h2.isMDXComponent=!0;const g2={toc:[]},f2="wrapper";function D2(e){let{components:n,...t}=e;return(0,s.yg)(f2,(0,p.A)({},g2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Performs a patience diff on two arrays of strings, returning an object\ncontaining the lines that were deleted, inserted, and potentially moved\nlines. The plus parameter can result in a significant performance hit due\nto additional Longest Common Substring searches."))}D2.isMDXComponent=!0;const M2={toc:[]},X2="wrapper";function _2(e){let{components:n,...t}=e;return(0,s.yg)(X2,(0,p.A)({},M2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The original array of strings"))}_2.isMDXComponent=!0;const w2={toc:[]},T2="wrapper";function C2(e){let{components:n,...t}=e;return(0,s.yg)(T2,(0,p.A)({},w2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new array of strings"))}C2.isMDXComponent=!0;const x2={toc:[]},A2="wrapper";function v2(e){let{components:n,...t}=e;return(0,s.yg)(A2,(0,p.A)({},x2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a custom selection range."))}v2.isMDXComponent=!0;const L2={toc:[]},b2="wrapper";function N2(e){let{components:n,...t}=e;return(0,s.yg)(b2,(0,p.A)({},L2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the selection starts."))}N2.isMDXComponent=!0;const k2={toc:[]},z2="wrapper";function P2(e){let{components:n,...t}=e;return(0,s.yg)(z2,(0,p.A)({},k2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the selection starts."))}P2.isMDXComponent=!0;const I2={toc:[]},R2="wrapper";function W2(e){let{components:n,...t}=e;return(0,s.yg)(R2,(0,p.A)({},I2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the selection ends."))}W2.isMDXComponent=!0;const S2={toc:[]},B2="wrapper";function G2(e){let{components:n,...t}=e;return(0,s.yg)(B2,(0,p.A)({},S2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the selection ends."))}G2.isMDXComponent=!0;const E2={toc:[]},O2="wrapper";function U2(e){let{components:n,...t}=e;return(0,s.yg)(O2,(0,p.A)({},E2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}U2.isMDXComponent=!0;const F2={toc:[]},V2="wrapper";function q2(e){let{components:n,...t}=e;return(0,s.yg)(V2,(0,p.A)({},F2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents a removal of code."))}q2.isMDXComponent=!0;const j2={toc:[]},H2="wrapper";function Y2(e){let{components:n,...t}=e;return(0,s.yg)(H2,(0,p.A)({},j2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to remove."))}Y2.isMDXComponent=!0;const Q2={toc:[]},$2="wrapper";function K2(e){let{components:n,...t}=e;return(0,s.yg)($2,(0,p.A)({},Q2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}K2.isMDXComponent=!0;const J2={toc:[]},Z2="wrapper";function e3(e){let{components:n,...t}=e;return(0,s.yg)(Z2,(0,p.A)({},J2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents a change from one piece of code to\nanother."))}e3.isMDXComponent=!0;const n3={toc:[]},t3="wrapper";function o3(e){let{components:n,...t}=e;return(0,s.yg)(t3,(0,p.A)({},n3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to change from."))}o3.isMDXComponent=!0;const p3={toc:[]},r3="wrapper";function s3(e){let{components:n,...t}=e;return(0,s.yg)(r3,(0,p.A)({},p3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to change to."))}s3.isMDXComponent=!0;const c3={toc:[]},a3="wrapper";function i3(e){let{components:n,...t}=e;return(0,s.yg)(a3,(0,p.A)({},c3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code range that highlights the given word."))}i3.isMDXComponent=!0;const l3={toc:[]},u3="wrapper";function m3(e){let{components:n,...t}=e;return(0,s.yg)(u3,(0,p.A)({},l3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the word appears."))}m3.isMDXComponent=!0;const y3={toc:[]},d3="wrapper";function h3(e){let{components:n,...t}=e;return(0,s.yg)(d3,(0,p.A)({},y3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the word starts."))}h3.isMDXComponent=!0;const g3={toc:[]},f3="wrapper";function D3(e){let{components:n,...t}=e;return(0,s.yg)(f3,(0,p.A)({},g3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The length of the word. If omitted, the range will cover the\nrest of the line."))}D3.isMDXComponent=!0;const M3={toc:[]},X3="wrapper";function _3(e){let{components:n,...t}=e;return(0,s.yg)(X3,(0,p.A)({},M3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}_3.isMDXComponent=!0;const w3={toc:[]},T3="wrapper";function C3(e){let{components:n,...t}=e;return(0,s.yg)(T3,(0,p.A)({},w3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}C3.isMDXComponent=!0;const x3={toc:[]},A3="wrapper";function v3(e){let{components:n,...t}=e;return(0,s.yg)(A3,(0,p.A)({},x3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}v3.isMDXComponent=!0;const L3={toc:[]},b3="wrapper";function N3(e){let{components:n,...t}=e;return(0,s.yg)(b3,(0,p.A)({},L3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}N3.isMDXComponent=!0;const k3={toc:[]},z3="wrapper";function P3(e){let{components:n,...t}=e;return(0,s.yg)(z3,(0,p.A)({},k3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}P3.isMDXComponent=!0;const I3={toc:[]},R3="wrapper";function W3(e){let{components:n,...t}=e;return(0,s.yg)(R3,(0,p.A)({},I3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}W3.isMDXComponent=!0;const S3={toc:[]},B3="wrapper";function G3(e){let{components:n,...t}=e;return(0,s.yg)(B3,(0,p.A)({},S3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}G3.isMDXComponent=!0;const E3={toc:[]},O3="wrapper";function U3(e){let{components:n,...t}=e;return(0,s.yg)(O3,(0,p.A)({},E3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}U3.isMDXComponent=!0;const F3={toc:[]},V3="wrapper";function q3(e){let{components:n,...t}=e;return(0,s.yg)(V3,(0,p.A)({},F3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}q3.isMDXComponent=!0;const j3={toc:[]},H3="wrapper";function Y3(e){let{components:n,...t}=e;return(0,s.yg)(H3,(0,p.A)({},j3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Y3.isMDXComponent=!0;const Q3={toc:[]},$3="wrapper";function K3(e){let{components:n,...t}=e;return(0,s.yg)($3,(0,p.A)({},Q3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}K3.isMDXComponent=!0;const J3={toc:[]},Z3="wrapper";function e1(e){let{components:n,...t}=e;return(0,s.yg)(Z3,(0,p.A)({},J3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}e1.isMDXComponent=!0;const n1={toc:[]},t1="wrapper";function o1(e){let{components:n,...t}=e;return(0,s.yg)(t1,(0,p.A)({},n1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}o1.isMDXComponent=!0;const p1={toc:[]},r1="wrapper";function s1(e){let{components:n,...t}=e;return(0,s.yg)(r1,(0,p.A)({},p1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}s1.isMDXComponent=!0;const c1={toc:[]},a1="wrapper";function i1(e){let{components:n,...t}=e;return(0,s.yg)(a1,(0,p.A)({},c1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}i1.isMDXComponent=!0;const l1={toc:[]},u1="wrapper";function m1(e){let{components:n,...t}=e;return(0,s.yg)(u1,(0,p.A)({},l1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}m1.isMDXComponent=!0;const y1={toc:[]},d1="wrapper";function h1(e){let{components:n,...t}=e;return(0,s.yg)(d1,(0,p.A)({},y1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}h1.isMDXComponent=!0;const g1={toc:[]},f1="wrapper";function D1(e){let{components:n,...t}=e;return(0,s.yg)(f1,(0,p.A)({},g1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}D1.isMDXComponent=!0;const M1={toc:[]},X1="wrapper";function _1(e){let{components:n,...t}=e;return(0,s.yg)(X1,(0,p.A)({},M1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}_1.isMDXComponent=!0;const w1={toc:[]},T1="wrapper";function C1(e){let{components:n,...t}=e;return(0,s.yg)(T1,(0,p.A)({},w1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}C1.isMDXComponent=!0;const x1={toc:[]},A1="wrapper";function v1(e){let{components:n,...t}=e;return(0,s.yg)(A1,(0,p.A)({},x1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}v1.isMDXComponent=!0;const L1={toc:[]},b1="wrapper";function N1(e){let{components:n,...t}=e;return(0,s.yg)(b1,(0,p.A)({},L1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}N1.isMDXComponent=!0;const k1={toc:[]},z1="wrapper";function P1(e){let{components:n,...t}=e;return(0,s.yg)(z1,(0,p.A)({},k1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}P1.isMDXComponent=!0;const I1={toc:[]},R1="wrapper";function W1(e){let{components:n,...t}=e;return(0,s.yg)(R1,(0,p.A)({},I1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W1.isMDXComponent=!0;const S1={toc:[]},B1="wrapper";function G1(e){let{components:n,...t}=e;return(0,s.yg)(B1,(0,p.A)({},S1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}G1.isMDXComponent=!0;const E1={toc:[]},O1="wrapper";function U1(e){let{components:n,...t}=e;return(0,s.yg)(O1,(0,p.A)({},E1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}U1.isMDXComponent=!0;const F1={toc:[]},V1="wrapper";function q1(e){let{components:n,...t}=e;return(0,s.yg)(V1,(0,p.A)({},F1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}q1.isMDXComponent=!0;const j1={toc:[]},H1="wrapper";function Y1(e){let{components:n,...t}=e;return(0,s.yg)(H1,(0,p.A)({},j1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Y1.isMDXComponent=!0;const Q1={toc:[]},$1="wrapper";function K1(e){let{components:n,...t}=e;return(0,s.yg)($1,(0,p.A)({},Q1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}K1.isMDXComponent=!0;const J1={toc:[]},Z1="wrapper";function e4(e){let{components:n,...t}=e;return(0,s.yg)(Z1,(0,p.A)({},J1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}e4.isMDXComponent=!0;const n4={toc:[]},t4="wrapper";function o4(e){let{components:n,...t}=e;return(0,s.yg)(t4,(0,p.A)({},n4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}o4.isMDXComponent=!0;const p4={toc:[]},r4="wrapper";function s4(e){let{components:n,...t}=e;return(0,s.yg)(r4,(0,p.A)({},p4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}s4.isMDXComponent=!0;const c4={toc:[]},a4="wrapper";function i4(e){let{components:n,...t}=e;return(0,s.yg)(a4,(0,p.A)({},c4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}i4.isMDXComponent=!0;const l4={toc:[]},u4="wrapper";function m4(e){let{components:n,...t}=e;return(0,s.yg)(u4,(0,p.A)({},l4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}m4.isMDXComponent=!0;const y4={toc:[]},d4="wrapper";function h4(e){let{components:n,...t}=e;return(0,s.yg)(d4,(0,p.A)({},y4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}h4.isMDXComponent=!0;const g4={toc:[]},f4="wrapper";function D4(e){let{components:n,...t}=e;return(0,s.yg)(f4,(0,p.A)({},g4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}D4.isMDXComponent=!0;const M4={toc:[]},X4="wrapper";function _4(e){let{components:n,...t}=e;return(0,s.yg)(X4,(0,p.A)({},M4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}_4.isMDXComponent=!0;const w4={toc:[]},T4="wrapper";function C4(e){let{components:n,...t}=e;return(0,s.yg)(T4,(0,p.A)({},w4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}C4.isMDXComponent=!0;const x4={toc:[]},A4="wrapper";function v4(e){let{components:n,...t}=e;return(0,s.yg)(A4,(0,p.A)({},x4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}v4.isMDXComponent=!0;const L4={toc:[]},b4="wrapper";function N4(e){let{components:n,...t}=e;return(0,s.yg)(b4,(0,p.A)({},L4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}N4.isMDXComponent=!0;const k4={toc:[]},z4="wrapper";function P4(e){let{components:n,...t}=e;return(0,s.yg)(z4,(0,p.A)({},k4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}P4.isMDXComponent=!0;const I4={toc:[]},R4="wrapper";function W4(e){let{components:n,...t}=e;return(0,s.yg)(R4,(0,p.A)({},I4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}W4.isMDXComponent=!0;const S4={toc:[]},B4="wrapper";function G4(e){let{components:n,...t}=e;return(0,s.yg)(B4,(0,p.A)({},S4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}G4.isMDXComponent=!0;const E4={toc:[]},O4="wrapper";function U4(e){let{components:n,...t}=e;return(0,s.yg)(O4,(0,p.A)({},E4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}U4.isMDXComponent=!0;const F4={toc:[]},V4="wrapper";function q4(e){let{components:n,...t}=e;return(0,s.yg)(V4,(0,p.A)({},F4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}q4.isMDXComponent=!0;const j4={toc:[]},H4="wrapper";function Y4(e){let{components:n,...t}=e;return(0,s.yg)(H4,(0,p.A)({},j4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Y4.isMDXComponent=!0;const Q4={toc:[]},$4="wrapper";function K4(e){let{components:n,...t}=e;return(0,s.yg)($4,(0,p.A)({},Q4,t,{components:n,mdxType:"MDXLayout"}))}K4.isMDXComponent=!0;const J4={toc:[]},Z4="wrapper";function e6(e){let{components:n,...t}=e;return(0,s.yg)(Z4,(0,p.A)({},J4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}e6.isMDXComponent=!0;const n6={toc:[]},t6="wrapper";function o6(e){let{components:n,...t}=e;return(0,s.yg)(t6,(0,p.A)({},n6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}o6.isMDXComponent=!0;const p6={toc:[]},r6="wrapper";function s6(e){let{components:n,...t}=e;return(0,s.yg)(r6,(0,p.A)({},p6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}s6.isMDXComponent=!0;const c6={toc:[]},a6="wrapper";function i6(e){let{components:n,...t}=e;return(0,s.yg)(a6,(0,p.A)({},c6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}i6.isMDXComponent=!0;const l6={toc:[]},u6="wrapper";function m6(e){let{components:n,...t}=e;return(0,s.yg)(u6,(0,p.A)({},l6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}m6.isMDXComponent=!0;const y6={toc:[]},d6="wrapper";function h6(e){let{components:n,...t}=e;return(0,s.yg)(d6,(0,p.A)({},y6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}h6.isMDXComponent=!0;const g6={toc:[]},f6="wrapper";function D6(e){let{components:n,...t}=e;return(0,s.yg)(f6,(0,p.A)({},g6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}D6.isMDXComponent=!0;const M6={toc:[]},X6="wrapper";function _6(e){let{components:n,...t}=e;return(0,s.yg)(X6,(0,p.A)({},M6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}_6.isMDXComponent=!0;const w6={toc:[]},T6="wrapper";function C6(e){let{components:n,...t}=e;return(0,s.yg)(T6,(0,p.A)({},w6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}C6.isMDXComponent=!0;const x6={toc:[]},A6="wrapper";function v6(e){let{components:n,...t}=e;return(0,s.yg)(A6,(0,p.A)({},x6,t,{components:n,mdxType:"MDXLayout"}))}v6.isMDXComponent=!0;const L6={toc:[]},b6="wrapper";function N6(e){let{components:n,...t}=e;return(0,s.yg)(b6,(0,p.A)({},L6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}N6.isMDXComponent=!0;const k6={toc:[]},z6="wrapper";function P6(e){let{components:n,...t}=e;return(0,s.yg)(z6,(0,p.A)({},k6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}P6.isMDXComponent=!0;const I6={toc:[]},R6="wrapper";function W6(e){let{components:n,...t}=e;return(0,s.yg)(R6,(0,p.A)({},I6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W6.isMDXComponent=!0;const S6={toc:[]},B6="wrapper";function G6(e){let{components:n,...t}=e;return(0,s.yg)(B6,(0,p.A)({},S6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}G6.isMDXComponent=!0;const E6={toc:[]},O6="wrapper";function U6(e){let{components:n,...t}=e;return(0,s.yg)(O6,(0,p.A)({},E6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}U6.isMDXComponent=!0;const F6={toc:[]},V6="wrapper";function q6(e){let{components:n,...t}=e;return(0,s.yg)(V6,(0,p.A)({},F6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}q6.isMDXComponent=!0;const j6={toc:[]},H6="wrapper";function Y6(e){let{components:n,...t}=e;return(0,s.yg)(H6,(0,p.A)({},j6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Y6.isMDXComponent=!0;const Q6={toc:[]},$6="wrapper";function K6(e){let{components:n,...t}=e;return(0,s.yg)($6,(0,p.A)({},Q6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}K6.isMDXComponent=!0;const J6={toc:[]},Z6="wrapper";function e5(e){let{components:n,...t}=e;return(0,s.yg)(Z6,(0,p.A)({},J6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}e5.isMDXComponent=!0;const n5={toc:[]},t5="wrapper";function o5(e){let{components:n,...t}=e;return(0,s.yg)(t5,(0,p.A)({},n5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}o5.isMDXComponent=!0;const p5={toc:[]},r5="wrapper";function s5(e){let{components:n,...t}=e;return(0,s.yg)(r5,(0,p.A)({},p5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}s5.isMDXComponent=!0;const c5={toc:[]},a5="wrapper";function i5(e){let{components:n,...t}=e;return(0,s.yg)(a5,(0,p.A)({},c5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}i5.isMDXComponent=!0;const l5={toc:[]},u5="wrapper";function m5(e){let{components:n,...t}=e;return(0,s.yg)(u5,(0,p.A)({},l5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}m5.isMDXComponent=!0;const y5={toc:[]},d5="wrapper";function h5(e){let{components:n,...t}=e;return(0,s.yg)(d5,(0,p.A)({},y5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}h5.isMDXComponent=!0;const g5={toc:[]},f5="wrapper";function D5(e){let{components:n,...t}=e;return(0,s.yg)(f5,(0,p.A)({},g5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}D5.isMDXComponent=!0;const M5={toc:[]},X5="wrapper";function _5(e){let{components:n,...t}=e;return(0,s.yg)(X5,(0,p.A)({},M5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}_5.isMDXComponent=!0;const w5={toc:[]},T5="wrapper";function C5(e){let{components:n,...t}=e;return(0,s.yg)(T5,(0,p.A)({},w5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}C5.isMDXComponent=!0;const x5={toc:[]},A5="wrapper";function v5(e){let{components:n,...t}=e;return(0,s.yg)(A5,(0,p.A)({},x5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}v5.isMDXComponent=!0;const L5={toc:[]},b5="wrapper";function N5(e){let{components:n,...t}=e;return(0,s.yg)(b5,(0,p.A)({},L5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}N5.isMDXComponent=!0;const k5={toc:[]},z5="wrapper";function P5(e){let{components:n,...t}=e;return(0,s.yg)(z5,(0,p.A)({},k5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}P5.isMDXComponent=!0;const I5={toc:[]},R5="wrapper";function W5(e){let{components:n,...t}=e;return(0,s.yg)(R5,(0,p.A)({},I5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}W5.isMDXComponent=!0;const S5={toc:[]},B5="wrapper";function G5(e){let{components:n,...t}=e;return(0,s.yg)(B5,(0,p.A)({},S5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}G5.isMDXComponent=!0;const E5={toc:[]},O5="wrapper";function U5(e){let{components:n,...t}=e;return(0,s.yg)(O5,(0,p.A)({},E5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}U5.isMDXComponent=!0;const F5={toc:[]},V5="wrapper";function q5(e){let{components:n,...t}=e;return(0,s.yg)(V5,(0,p.A)({},F5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}q5.isMDXComponent=!0;const j5={toc:[]},H5="wrapper";function Y5(e){let{components:n,...t}=e;return(0,s.yg)(H5,(0,p.A)({},j5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Y5.isMDXComponent=!0;const Q5={toc:[]},$5="wrapper";function K5(e){let{components:n,...t}=e;return(0,s.yg)($5,(0,p.A)({},Q5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}K5.isMDXComponent=!0;const J5={toc:[]},Z5="wrapper";function e7(e){let{components:n,...t}=e;return(0,s.yg)(Z5,(0,p.A)({},J5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}e7.isMDXComponent=!0;const n7={toc:[]},t7="wrapper";function o7(e){let{components:n,...t}=e;return(0,s.yg)(t7,(0,p.A)({},n7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}o7.isMDXComponent=!0;const p7={toc:[]},r7="wrapper";function s7(e){let{components:n,...t}=e;return(0,s.yg)(r7,(0,p.A)({},p7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}s7.isMDXComponent=!0;const c7={toc:[]},a7="wrapper";function i7(e){let{components:n,...t}=e;return(0,s.yg)(a7,(0,p.A)({},c7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}i7.isMDXComponent=!0;const l7={toc:[]},u7="wrapper";function m7(e){let{components:n,...t}=e;return(0,s.yg)(u7,(0,p.A)({},l7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}m7.isMDXComponent=!0;const y7={toc:[]},d7="wrapper";function h7(e){let{components:n,...t}=e;return(0,s.yg)(d7,(0,p.A)({},y7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}h7.isMDXComponent=!0;const g7={toc:[]},f7="wrapper";function D7(e){let{components:n,...t}=e;return(0,s.yg)(f7,(0,p.A)({},g7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}D7.isMDXComponent=!0;const M7={toc:[]},X7="wrapper";function _7(e){let{components:n,...t}=e;return(0,s.yg)(X7,(0,p.A)({},M7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}_7.isMDXComponent=!0;const w7={toc:[]},T7="wrapper";function C7(e){let{components:n,...t}=e;return(0,s.yg)(T7,(0,p.A)({},w7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}C7.isMDXComponent=!0;const x7={toc:[]},A7="wrapper";function v7(e){let{components:n,...t}=e;return(0,s.yg)(A7,(0,p.A)({},x7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}v7.isMDXComponent=!0;const L7={toc:[]},b7="wrapper";function N7(e){let{components:n,...t}=e;return(0,s.yg)(b7,(0,p.A)({},L7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}N7.isMDXComponent=!0;const k7={toc:[]},z7="wrapper";function P7(e){let{components:n,...t}=e;return(0,s.yg)(z7,(0,p.A)({},k7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}P7.isMDXComponent=!0;const I7={toc:[]},R7="wrapper";function W7(e){let{components:n,...t}=e;return(0,s.yg)(R7,(0,p.A)({},I7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}W7.isMDXComponent=!0;const S7={toc:[]},B7="wrapper";function G7(e){let{components:n,...t}=e;return(0,s.yg)(B7,(0,p.A)({},S7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}G7.isMDXComponent=!0;const E7={toc:[]},O7="wrapper";function U7(e){let{components:n,...t}=e;return(0,s.yg)(O7,(0,p.A)({},E7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}U7.isMDXComponent=!0;const F7={toc:[]},V7="wrapper";function q7(e){let{components:n,...t}=e;return(0,s.yg)(V7,(0,p.A)({},F7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}q7.isMDXComponent=!0;const j7={toc:[]},H7="wrapper";function Y7(e){let{components:n,...t}=e;return(0,s.yg)(H7,(0,p.A)({},j7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Y7.isMDXComponent=!0;const Q7={toc:[]},$7="wrapper";function K7(e){let{components:n,...t}=e;return(0,s.yg)($7,(0,p.A)({},Q7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}K7.isMDXComponent=!0;const J7={toc:[]},Z7="wrapper";function e9(e){let{components:n,...t}=e;return(0,s.yg)(Z7,(0,p.A)({},J7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}e9.isMDXComponent=!0;const n9={toc:[]},t9="wrapper";function o9(e){let{components:n,...t}=e;return(0,s.yg)(t9,(0,p.A)({},n9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}o9.isMDXComponent=!0;const p9={toc:[]},r9="wrapper";function s9(e){let{components:n,...t}=e;return(0,s.yg)(r9,(0,p.A)({},p9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}s9.isMDXComponent=!0;const c9={toc:[]},a9="wrapper";function i9(e){let{components:n,...t}=e;return(0,s.yg)(a9,(0,p.A)({},c9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}i9.isMDXComponent=!0;const l9={toc:[]},u9="wrapper";function m9(e){let{components:n,...t}=e;return(0,s.yg)(u9,(0,p.A)({},l9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}m9.isMDXComponent=!0;const y9={toc:[]},d9="wrapper";function h9(e){let{components:n,...t}=e;return(0,s.yg)(d9,(0,p.A)({},y9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}h9.isMDXComponent=!0;const g9={toc:[]},f9="wrapper";function D9(e){let{components:n,...t}=e;return(0,s.yg)(f9,(0,p.A)({},g9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}D9.isMDXComponent=!0;const M9={toc:[]},X9="wrapper";function _9(e){let{components:n,...t}=e;return(0,s.yg)(X9,(0,p.A)({},M9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_9.isMDXComponent=!0;const w9={toc:[]},T9="wrapper";function C9(e){let{components:n,...t}=e;return(0,s.yg)(T9,(0,p.A)({},w9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}C9.isMDXComponent=!0;const x9={toc:[]},A9="wrapper";function v9(e){let{components:n,...t}=e;return(0,s.yg)(A9,(0,p.A)({},x9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}v9.isMDXComponent=!0;const L9={toc:[]},b9="wrapper";function N9(e){let{components:n,...t}=e;return(0,s.yg)(b9,(0,p.A)({},L9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}N9.isMDXComponent=!0;const k9={toc:[]},z9="wrapper";function P9(e){let{components:n,...t}=e;return(0,s.yg)(z9,(0,p.A)({},k9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}P9.isMDXComponent=!0;const I9={toc:[]},R9="wrapper";function W9(e){let{components:n,...t}=e;return(0,s.yg)(R9,(0,p.A)({},I9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}W9.isMDXComponent=!0;const S9={toc:[]},B9="wrapper";function G9(e){let{components:n,...t}=e;return(0,s.yg)(B9,(0,p.A)({},S9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}G9.isMDXComponent=!0;const E9={toc:[]},O9="wrapper";function U9(e){let{components:n,...t}=e;return(0,s.yg)(O9,(0,p.A)({},E9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}U9.isMDXComponent=!0;const F9={toc:[]},V9="wrapper";function q9(e){let{components:n,...t}=e;return(0,s.yg)(V9,(0,p.A)({},F9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}q9.isMDXComponent=!0;const j9={toc:[]},H9="wrapper";function Y9(e){let{components:n,...t}=e;return(0,s.yg)(H9,(0,p.A)({},j9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Y9.isMDXComponent=!0;const Q9={toc:[]},$9="wrapper";function K9(e){let{components:n,...t}=e;return(0,s.yg)($9,(0,p.A)({},Q9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}K9.isMDXComponent=!0;const J9={toc:[]},Z9="wrapper";function eee(e){let{components:n,...t}=e;return(0,s.yg)(Z9,(0,p.A)({},J9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}eee.isMDXComponent=!0;const nee={toc:[]},tee="wrapper";function oee(e){let{components:n,...t}=e;return(0,s.yg)(tee,(0,p.A)({},nee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}oee.isMDXComponent=!0;const pee={toc:[]},ree="wrapper";function see(e){let{components:n,...t}=e;return(0,s.yg)(ree,(0,p.A)({},pee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}see.isMDXComponent=!0;const cee={toc:[]},aee="wrapper";function iee(e){let{components:n,...t}=e;return(0,s.yg)(aee,(0,p.A)({},cee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}iee.isMDXComponent=!0;const lee={toc:[]},uee="wrapper";function mee(e){let{components:n,...t}=e;return(0,s.yg)(uee,(0,p.A)({},lee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}mee.isMDXComponent=!0;const yee={toc:[]},dee="wrapper";function hee(e){let{components:n,...t}=e;return(0,s.yg)(dee,(0,p.A)({},yee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}hee.isMDXComponent=!0;const gee={toc:[]},fee="wrapper";function Dee(e){let{components:n,...t}=e;return(0,s.yg)(fee,(0,p.A)({},gee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Dee.isMDXComponent=!0;const Mee={toc:[]},Xee="wrapper";function _ee(e){let{components:n,...t}=e;return(0,s.yg)(Xee,(0,p.A)({},Mee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_ee.isMDXComponent=!0;const wee={toc:[]},Tee="wrapper";function Cee(e){let{components:n,...t}=e;return(0,s.yg)(Tee,(0,p.A)({},wee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Cee.isMDXComponent=!0;const xee={toc:[]},Aee="wrapper";function vee(e){let{components:n,...t}=e;return(0,s.yg)(Aee,(0,p.A)({},xee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}vee.isMDXComponent=!0;const Lee={toc:[]},bee="wrapper";function Nee(e){let{components:n,...t}=e;return(0,s.yg)(bee,(0,p.A)({},Lee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nee.isMDXComponent=!0;const kee={toc:[]},zee="wrapper";function Pee(e){let{components:n,...t}=e;return(0,s.yg)(zee,(0,p.A)({},kee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Pee.isMDXComponent=!0;const Iee={toc:[]},Ree="wrapper";function Wee(e){let{components:n,...t}=e;return(0,s.yg)(Ree,(0,p.A)({},Iee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Wee.isMDXComponent=!0;const See={toc:[]},Bee="wrapper";function Gee(e){let{components:n,...t}=e;return(0,s.yg)(Bee,(0,p.A)({},See,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Gee.isMDXComponent=!0;const Eee={toc:[]},Oee="wrapper";function Uee(e){let{components:n,...t}=e;return(0,s.yg)(Oee,(0,p.A)({},Eee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Uee.isMDXComponent=!0;const Fee={toc:[]},Vee="wrapper";function qee(e){let{components:n,...t}=e;return(0,s.yg)(Vee,(0,p.A)({},Fee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}qee.isMDXComponent=!0;const jee={toc:[]},Hee="wrapper";function Yee(e){let{components:n,...t}=e;return(0,s.yg)(Hee,(0,p.A)({},jee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Yee.isMDXComponent=!0;const Qee={toc:[]},$ee="wrapper";function Kee(e){let{components:n,...t}=e;return(0,s.yg)($ee,(0,p.A)({},Qee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Kee.isMDXComponent=!0;const Jee={toc:[]},Zee="wrapper";function ene(e){let{components:n,...t}=e;return(0,s.yg)(Zee,(0,p.A)({},Jee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ene.isMDXComponent=!0;const nne={toc:[]},tne="wrapper";function one(e){let{components:n,...t}=e;return(0,s.yg)(tne,(0,p.A)({},nne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}one.isMDXComponent=!0;const pne={toc:[]},rne="wrapper";function sne(e){let{components:n,...t}=e;return(0,s.yg)(rne,(0,p.A)({},pne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}sne.isMDXComponent=!0;const cne={toc:[]},ane="wrapper";function ine(e){let{components:n,...t}=e;return(0,s.yg)(ane,(0,p.A)({},cne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}ine.isMDXComponent=!0;const lne={toc:[]},une="wrapper";function mne(e){let{components:n,...t}=e;return(0,s.yg)(une,(0,p.A)({},lne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}mne.isMDXComponent=!0;const yne={toc:[]},dne="wrapper";function hne(e){let{components:n,...t}=e;return(0,s.yg)(dne,(0,p.A)({},yne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}hne.isMDXComponent=!0;const gne={toc:[]},fne="wrapper";function Dne(e){let{components:n,...t}=e;return(0,s.yg)(fne,(0,p.A)({},gne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Dne.isMDXComponent=!0;const Mne={toc:[]},Xne="wrapper";function _ne(e){let{components:n,...t}=e;return(0,s.yg)(Xne,(0,p.A)({},Mne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}_ne.isMDXComponent=!0;const wne={toc:[]},Tne="wrapper";function Cne(e){let{components:n,...t}=e;return(0,s.yg)(Tne,(0,p.A)({},wne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Cne.isMDXComponent=!0;const xne={toc:[]},Ane="wrapper";function vne(e){let{components:n,...t}=e;return(0,s.yg)(Ane,(0,p.A)({},xne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vne.isMDXComponent=!0;const Lne={toc:[]},bne="wrapper";function Nne(e){let{components:n,...t}=e;return(0,s.yg)(bne,(0,p.A)({},Lne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Nne.isMDXComponent=!0;const kne={toc:[]},zne="wrapper";function Pne(e){let{components:n,...t}=e;return(0,s.yg)(zne,(0,p.A)({},kne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Pne.isMDXComponent=!0;const Ine={toc:[]},Rne="wrapper";function Wne(e){let{components:n,...t}=e;return(0,s.yg)(Rne,(0,p.A)({},Ine,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Wne.isMDXComponent=!0;const Sne={toc:[]},Bne="wrapper";function Gne(e){let{components:n,...t}=e;return(0,s.yg)(Bne,(0,p.A)({},Sne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Gne.isMDXComponent=!0;const Ene={toc:[]},One="wrapper";function Une(e){let{components:n,...t}=e;return(0,s.yg)(One,(0,p.A)({},Ene,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Une.isMDXComponent=!0;const Fne={toc:[]},Vne="wrapper";function qne(e){let{components:n,...t}=e;return(0,s.yg)(Vne,(0,p.A)({},Fne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}qne.isMDXComponent=!0;const jne={toc:[]},Hne="wrapper";function Yne(e){let{components:n,...t}=e;return(0,s.yg)(Hne,(0,p.A)({},jne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Yne.isMDXComponent=!0;const Qne={toc:[]},$ne="wrapper";function Kne(e){let{components:n,...t}=e;return(0,s.yg)($ne,(0,p.A)({},Qne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Kne.isMDXComponent=!0;const Jne={toc:[]},Zne="wrapper";function ete(e){let{components:n,...t}=e;return(0,s.yg)(Zne,(0,p.A)({},Jne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}ete.isMDXComponent=!0;const nte={toc:[]},tte="wrapper";function ote(e){let{components:n,...t}=e;return(0,s.yg)(tte,(0,p.A)({},nte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}ote.isMDXComponent=!0;const pte={toc:[]},rte="wrapper";function ste(e){let{components:n,...t}=e;return(0,s.yg)(rte,(0,p.A)({},pte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}ste.isMDXComponent=!0;const cte={toc:[]},ate="wrapper";function ite(e){let{components:n,...t}=e;return(0,s.yg)(ate,(0,p.A)({},cte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}ite.isMDXComponent=!0;const lte={toc:[]},ute="wrapper";function mte(e){let{components:n,...t}=e;return(0,s.yg)(ute,(0,p.A)({},lte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}mte.isMDXComponent=!0;const yte={toc:[]},dte="wrapper";function hte(e){let{components:n,...t}=e;return(0,s.yg)(dte,(0,p.A)({},yte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hte.isMDXComponent=!0;const gte={toc:[]},fte="wrapper";function Dte(e){let{components:n,...t}=e;return(0,s.yg)(fte,(0,p.A)({},gte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Dte.isMDXComponent=!0;const Mte={toc:[]},Xte="wrapper";function _te(e){let{components:n,...t}=e;return(0,s.yg)(Xte,(0,p.A)({},Mte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}_te.isMDXComponent=!0;const wte={toc:[]},Tte="wrapper";function Cte(e){let{components:n,...t}=e;return(0,s.yg)(Tte,(0,p.A)({},wte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Cte.isMDXComponent=!0;const xte={toc:[]},Ate="wrapper";function vte(e){let{components:n,...t}=e;return(0,s.yg)(Ate,(0,p.A)({},xte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}vte.isMDXComponent=!0;const Lte={toc:[]},bte="wrapper";function Nte(e){let{components:n,...t}=e;return(0,s.yg)(bte,(0,p.A)({},Lte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Nte.isMDXComponent=!0;const kte={toc:[]},zte="wrapper";function Pte(e){let{components:n,...t}=e;return(0,s.yg)(zte,(0,p.A)({},kte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Pte.isMDXComponent=!0;const Ite={toc:[]},Rte="wrapper";function Wte(e){let{components:n,...t}=e;return(0,s.yg)(Rte,(0,p.A)({},Ite,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Wte.isMDXComponent=!0;const Ste={toc:[]},Bte="wrapper";function Gte(e){let{components:n,...t}=e;return(0,s.yg)(Bte,(0,p.A)({},Ste,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Gte.isMDXComponent=!0;const Ete={toc:[]},Ote="wrapper";function Ute(e){let{components:n,...t}=e;return(0,s.yg)(Ote,(0,p.A)({},Ete,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Ute.isMDXComponent=!0;const Fte={toc:[]},Vte="wrapper";function qte(e){let{components:n,...t}=e;return(0,s.yg)(Vte,(0,p.A)({},Fte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}qte.isMDXComponent=!0;const jte={toc:[]},Hte="wrapper";function Yte(e){let{components:n,...t}=e;return(0,s.yg)(Hte,(0,p.A)({},jte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Yte.isMDXComponent=!0;const Qte={toc:[]},$te="wrapper";function Kte(e){let{components:n,...t}=e;return(0,s.yg)($te,(0,p.A)({},Qte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Kte.isMDXComponent=!0;const Jte={toc:[]},Zte="wrapper";function eoe(e){let{components:n,...t}=e;return(0,s.yg)(Zte,(0,p.A)({},Jte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}eoe.isMDXComponent=!0;const noe={toc:[]},toe="wrapper";function ooe(e){let{components:n,...t}=e;return(0,s.yg)(toe,(0,p.A)({},noe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}ooe.isMDXComponent=!0;const poe={toc:[]},roe="wrapper";function soe(e){let{components:n,...t}=e;return(0,s.yg)(roe,(0,p.A)({},poe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}soe.isMDXComponent=!0;const coe={toc:[]},aoe="wrapper";function ioe(e){let{components:n,...t}=e;return(0,s.yg)(aoe,(0,p.A)({},coe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ioe.isMDXComponent=!0;const loe={toc:[]},uoe="wrapper";function moe(e){let{components:n,...t}=e;return(0,s.yg)(uoe,(0,p.A)({},loe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}moe.isMDXComponent=!0;const yoe={toc:[]},doe="wrapper";function hoe(e){let{components:n,...t}=e;return(0,s.yg)(doe,(0,p.A)({},yoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}hoe.isMDXComponent=!0;const goe={toc:[]},foe="wrapper";function Doe(e){let{components:n,...t}=e;return(0,s.yg)(foe,(0,p.A)({},goe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Doe.isMDXComponent=!0;const Moe={toc:[]},Xoe="wrapper";function _oe(e){let{components:n,...t}=e;return(0,s.yg)(Xoe,(0,p.A)({},Moe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}_oe.isMDXComponent=!0;const woe={toc:[]},Toe="wrapper";function Coe(e){let{components:n,...t}=e;return(0,s.yg)(Toe,(0,p.A)({},woe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Coe.isMDXComponent=!0;const xoe={toc:[]},Aoe="wrapper";function voe(e){let{components:n,...t}=e;return(0,s.yg)(Aoe,(0,p.A)({},xoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}voe.isMDXComponent=!0;const Loe={toc:[]},boe="wrapper";function Noe(e){let{components:n,...t}=e;return(0,s.yg)(boe,(0,p.A)({},Loe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Noe.isMDXComponent=!0;const koe={toc:[]},zoe="wrapper";function Poe(e){let{components:n,...t}=e;return(0,s.yg)(zoe,(0,p.A)({},koe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Poe.isMDXComponent=!0;const Ioe={toc:[]},Roe="wrapper";function Woe(e){let{components:n,...t}=e;return(0,s.yg)(Roe,(0,p.A)({},Ioe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Woe.isMDXComponent=!0;const Soe={toc:[]},Boe="wrapper";function Goe(e){let{components:n,...t}=e;return(0,s.yg)(Boe,(0,p.A)({},Soe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Goe.isMDXComponent=!0;const Eoe={toc:[]},Ooe="wrapper";function Uoe(e){let{components:n,...t}=e;return(0,s.yg)(Ooe,(0,p.A)({},Eoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Uoe.isMDXComponent=!0;const Foe={toc:[]},Voe="wrapper";function qoe(e){let{components:n,...t}=e;return(0,s.yg)(Voe,(0,p.A)({},Foe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}qoe.isMDXComponent=!0;const joe={toc:[]},Hoe="wrapper";function Yoe(e){let{components:n,...t}=e;return(0,s.yg)(Hoe,(0,p.A)({},joe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Yoe.isMDXComponent=!0;const Qoe={toc:[]},$oe="wrapper";function Koe(e){let{components:n,...t}=e;return(0,s.yg)($oe,(0,p.A)({},Qoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Koe.isMDXComponent=!0;const Joe={toc:[]},Zoe="wrapper";function epe(e){let{components:n,...t}=e;return(0,s.yg)(Zoe,(0,p.A)({},Joe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}epe.isMDXComponent=!0;const npe={toc:[]},tpe="wrapper";function ope(e){let{components:n,...t}=e;return(0,s.yg)(tpe,(0,p.A)({},npe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ope.isMDXComponent=!0;const ppe={toc:[]},rpe="wrapper";function spe(e){let{components:n,...t}=e;return(0,s.yg)(rpe,(0,p.A)({},ppe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}spe.isMDXComponent=!0;const cpe={toc:[]},ape="wrapper";function ipe(e){let{components:n,...t}=e;return(0,s.yg)(ape,(0,p.A)({},cpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ipe.isMDXComponent=!0;const lpe={toc:[]},upe="wrapper";function mpe(e){let{components:n,...t}=e;return(0,s.yg)(upe,(0,p.A)({},lpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mpe.isMDXComponent=!0;const ype={toc:[]},dpe="wrapper";function hpe(e){let{components:n,...t}=e;return(0,s.yg)(dpe,(0,p.A)({},ype,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hpe.isMDXComponent=!0;const gpe={toc:[]},fpe="wrapper";function Dpe(e){let{components:n,...t}=e;return(0,s.yg)(fpe,(0,p.A)({},gpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Dpe.isMDXComponent=!0;const Mpe={toc:[]},Xpe="wrapper";function _pe(e){let{components:n,...t}=e;return(0,s.yg)(Xpe,(0,p.A)({},Mpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_pe.isMDXComponent=!0;const wpe={toc:[]},Tpe="wrapper";function Cpe(e){let{components:n,...t}=e;return(0,s.yg)(Tpe,(0,p.A)({},wpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Cpe.isMDXComponent=!0;const xpe={toc:[]},Ape="wrapper";function vpe(e){let{components:n,...t}=e;return(0,s.yg)(Ape,(0,p.A)({},xpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vpe.isMDXComponent=!0;const Lpe={toc:[]},bpe="wrapper";function Npe(e){let{components:n,...t}=e;return(0,s.yg)(bpe,(0,p.A)({},Lpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Npe.isMDXComponent=!0;const kpe={toc:[]},zpe="wrapper";function Ppe(e){let{components:n,...t}=e;return(0,s.yg)(zpe,(0,p.A)({},kpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Ppe.isMDXComponent=!0;const Ipe={toc:[]},Rpe="wrapper";function Wpe(e){let{components:n,...t}=e;return(0,s.yg)(Rpe,(0,p.A)({},Ipe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Wpe.isMDXComponent=!0;const Spe={toc:[]},Bpe="wrapper";function Gpe(e){let{components:n,...t}=e;return(0,s.yg)(Bpe,(0,p.A)({},Spe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Gpe.isMDXComponent=!0;const Epe={toc:[]},Ope="wrapper";function Upe(e){let{components:n,...t}=e;return(0,s.yg)(Ope,(0,p.A)({},Epe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Upe.isMDXComponent=!0;const Fpe={toc:[]},Vpe="wrapper";function qpe(e){let{components:n,...t}=e;return(0,s.yg)(Vpe,(0,p.A)({},Fpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}qpe.isMDXComponent=!0;const jpe={toc:[]},Hpe="wrapper";function Ype(e){let{components:n,...t}=e;return(0,s.yg)(Hpe,(0,p.A)({},jpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Ype.isMDXComponent=!0;const Qpe={toc:[]},$pe="wrapper";function Kpe(e){let{components:n,...t}=e;return(0,s.yg)($pe,(0,p.A)({},Qpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]},Zpe="wrapper";function ere(e){let{components:n,...t}=e;return(0,s.yg)(Zpe,(0,p.A)({},Jpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}ere.isMDXComponent=!0;const nre={toc:[]},tre="wrapper";function ore(e){let{components:n,...t}=e;return(0,s.yg)(tre,(0,p.A)({},nre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}ore.isMDXComponent=!0;const pre={toc:[]},rre="wrapper";function sre(e){let{components:n,...t}=e;return(0,s.yg)(rre,(0,p.A)({},pre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}sre.isMDXComponent=!0;const cre={toc:[]},are="wrapper";function ire(e){let{components:n,...t}=e;return(0,s.yg)(are,(0,p.A)({},cre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ire.isMDXComponent=!0;const lre={toc:[]},ure="wrapper";function mre(e){let{components:n,...t}=e;return(0,s.yg)(ure,(0,p.A)({},lre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}mre.isMDXComponent=!0;const yre={toc:[]},dre="wrapper";function hre(e){let{components:n,...t}=e;return(0,s.yg)(dre,(0,p.A)({},yre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}hre.isMDXComponent=!0;const gre={toc:[]},fre="wrapper";function Dre(e){let{components:n,...t}=e;return(0,s.yg)(fre,(0,p.A)({},gre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Dre.isMDXComponent=!0;const Mre={toc:[]},Xre="wrapper";function _re(e){let{components:n,...t}=e;return(0,s.yg)(Xre,(0,p.A)({},Mre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}_re.isMDXComponent=!0;const wre={toc:[]},Tre="wrapper";function Cre(e){let{components:n,...t}=e;return(0,s.yg)(Tre,(0,p.A)({},wre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Cre.isMDXComponent=!0;const xre={toc:[]},Are="wrapper";function vre(e){let{components:n,...t}=e;return(0,s.yg)(Are,(0,p.A)({},xre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}vre.isMDXComponent=!0;const Lre={toc:[]},bre="wrapper";function Nre(e){let{components:n,...t}=e;return(0,s.yg)(bre,(0,p.A)({},Lre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Nre.isMDXComponent=!0;const kre={toc:[]},zre="wrapper";function Pre(e){let{components:n,...t}=e;return(0,s.yg)(zre,(0,p.A)({},kre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Pre.isMDXComponent=!0;const Ire={toc:[]},Rre="wrapper";function Wre(e){let{components:n,...t}=e;return(0,s.yg)(Rre,(0,p.A)({},Ire,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Wre.isMDXComponent=!0;const Sre={toc:[]},Bre="wrapper";function Gre(e){let{components:n,...t}=e;return(0,s.yg)(Bre,(0,p.A)({},Sre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Gre.isMDXComponent=!0;const Ere={toc:[]},Ore="wrapper";function Ure(e){let{components:n,...t}=e;return(0,s.yg)(Ore,(0,p.A)({},Ere,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ure.isMDXComponent=!0;const Fre={toc:[]},Vre="wrapper";function qre(e){let{components:n,...t}=e;return(0,s.yg)(Vre,(0,p.A)({},Fre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}qre.isMDXComponent=!0;const jre={toc:[]},Hre="wrapper";function Yre(e){let{components:n,...t}=e;return(0,s.yg)(Hre,(0,p.A)({},jre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Yre.isMDXComponent=!0;const Qre={toc:[]},$re="wrapper";function Kre(e){let{components:n,...t}=e;return(0,s.yg)($re,(0,p.A)({},Qre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Kre.isMDXComponent=!0;const Jre={toc:[]},Zre="wrapper";function ese(e){let{components:n,...t}=e;return(0,s.yg)(Zre,(0,p.A)({},Jre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ese.isMDXComponent=!0;const nse={toc:[]},tse="wrapper";function ose(e){let{components:n,...t}=e;return(0,s.yg)(tse,(0,p.A)({},nse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}ose.isMDXComponent=!0;const pse={toc:[]},rse="wrapper";function sse(e){let{components:n,...t}=e;return(0,s.yg)(rse,(0,p.A)({},pse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}sse.isMDXComponent=!0;const cse={toc:[]},ase="wrapper";function ise(e){let{components:n,...t}=e;return(0,s.yg)(ase,(0,p.A)({},cse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}ise.isMDXComponent=!0;const lse={toc:[]},use="wrapper";function mse(e){let{components:n,...t}=e;return(0,s.yg)(use,(0,p.A)({},lse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}mse.isMDXComponent=!0;const yse={toc:[]},dse="wrapper";function hse(e){let{components:n,...t}=e;return(0,s.yg)(dse,(0,p.A)({},yse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}hse.isMDXComponent=!0;const gse={toc:[]},fse="wrapper";function Dse(e){let{components:n,...t}=e;return(0,s.yg)(fse,(0,p.A)({},gse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Dse.isMDXComponent=!0;const Mse={toc:[]},Xse="wrapper";function _se(e){let{components:n,...t}=e;return(0,s.yg)(Xse,(0,p.A)({},Mse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}_se.isMDXComponent=!0;const wse={toc:[]},Tse="wrapper";function Cse(e){let{components:n,...t}=e;return(0,s.yg)(Tse,(0,p.A)({},wse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Cse.isMDXComponent=!0;const xse={toc:[]},Ase="wrapper";function vse(e){let{components:n,...t}=e;return(0,s.yg)(Ase,(0,p.A)({},xse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}vse.isMDXComponent=!0;const Lse={toc:[]},bse="wrapper";function Nse(e){let{components:n,...t}=e;return(0,s.yg)(bse,(0,p.A)({},Lse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Nse.isMDXComponent=!0;const kse={toc:[]},zse="wrapper";function Pse(e){let{components:n,...t}=e;return(0,s.yg)(zse,(0,p.A)({},kse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Pse.isMDXComponent=!0;const Ise={toc:[]},Rse="wrapper";function Wse(e){let{components:n,...t}=e;return(0,s.yg)(Rse,(0,p.A)({},Ise,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Wse.isMDXComponent=!0;const Sse={toc:[]},Bse="wrapper";function Gse(e){let{components:n,...t}=e;return(0,s.yg)(Bse,(0,p.A)({},Sse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Gse.isMDXComponent=!0;const Ese={toc:[]},Ose="wrapper";function Use(e){let{components:n,...t}=e;return(0,s.yg)(Ose,(0,p.A)({},Ese,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Use.isMDXComponent=!0;const Fse={toc:[]},Vse="wrapper";function qse(e){let{components:n,...t}=e;return(0,s.yg)(Vse,(0,p.A)({},Fse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qse.isMDXComponent=!0;const jse={toc:[]},Hse="wrapper";function Yse(e){let{components:n,...t}=e;return(0,s.yg)(Hse,(0,p.A)({},jse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Yse.isMDXComponent=!0;const Qse={toc:[]},$se="wrapper";function Kse(e){let{components:n,...t}=e;return(0,s.yg)($se,(0,p.A)({},Qse,t,{components:n,mdxType:"MDXLayout"}))}Kse.isMDXComponent=!0;const Jse={toc:[]},Zse="wrapper";function ece(e){let{components:n,...t}=e;return(0,s.yg)(Zse,(0,p.A)({},Jse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ece.isMDXComponent=!0;const nce={toc:[]},tce="wrapper";function oce(e){let{components:n,...t}=e;return(0,s.yg)(tce,(0,p.A)({},nce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}oce.isMDXComponent=!0;const pce={toc:[]},rce="wrapper";function sce(e){let{components:n,...t}=e;return(0,s.yg)(rce,(0,p.A)({},pce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}sce.isMDXComponent=!0;const cce={toc:[]},ace="wrapper";function ice(e){let{components:n,...t}=e;return(0,s.yg)(ace,(0,p.A)({},cce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}ice.isMDXComponent=!0;const lce={toc:[]},uce="wrapper";function mce(e){let{components:n,...t}=e;return(0,s.yg)(uce,(0,p.A)({},lce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}mce.isMDXComponent=!0;const yce={toc:[]},dce="wrapper";function hce(e){let{components:n,...t}=e;return(0,s.yg)(dce,(0,p.A)({},yce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}hce.isMDXComponent=!0;const gce={toc:[]},fce="wrapper";function Dce(e){let{components:n,...t}=e;return(0,s.yg)(fce,(0,p.A)({},gce,t,{components:n,mdxType:"MDXLayout"}))}Dce.isMDXComponent=!0;const Mce={toc:[]},Xce="wrapper";function _ce(e){let{components:n,...t}=e;return(0,s.yg)(Xce,(0,p.A)({},Mce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}_ce.isMDXComponent=!0;const wce={toc:[]},Tce="wrapper";function Cce(e){let{components:n,...t}=e;return(0,s.yg)(Tce,(0,p.A)({},wce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Cce.isMDXComponent=!0;const xce={toc:[]},Ace="wrapper";function vce(e){let{components:n,...t}=e;return(0,s.yg)(Ace,(0,p.A)({},xce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}vce.isMDXComponent=!0;const Lce={toc:[]},bce="wrapper";function Nce(e){let{components:n,...t}=e;return(0,s.yg)(bce,(0,p.A)({},Lce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Nce.isMDXComponent=!0;const kce={toc:[]},zce="wrapper";function Pce(e){let{components:n,...t}=e;return(0,s.yg)(zce,(0,p.A)({},kce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Pce.isMDXComponent=!0;const Ice={toc:[]},Rce="wrapper";function Wce(e){let{components:n,...t}=e;return(0,s.yg)(Rce,(0,p.A)({},Ice,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Wce.isMDXComponent=!0;const Sce={toc:[]},Bce="wrapper";function Gce(e){let{components:n,...t}=e;return(0,s.yg)(Bce,(0,p.A)({},Sce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Gce.isMDXComponent=!0;const Ece={toc:[]},Oce="wrapper";function Uce(e){let{components:n,...t}=e;return(0,s.yg)(Oce,(0,p.A)({},Ece,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Uce.isMDXComponent=!0;const Fce={toc:[]},Vce="wrapper";function qce(e){let{components:n,...t}=e;return(0,s.yg)(Vce,(0,p.A)({},Fce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}qce.isMDXComponent=!0;const jce={toc:[]},Hce="wrapper";function Yce(e){let{components:n,...t}=e;return(0,s.yg)(Hce,(0,p.A)({},jce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Yce.isMDXComponent=!0;const Qce={toc:[]},$ce="wrapper";function Kce(e){let{components:n,...t}=e;return(0,s.yg)($ce,(0,p.A)({},Qce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Kce.isMDXComponent=!0;const Jce={toc:[]},Zce="wrapper";function eae(e){let{components:n,...t}=e;return(0,s.yg)(Zce,(0,p.A)({},Jce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}eae.isMDXComponent=!0;const nae={toc:[]},tae="wrapper";function oae(e){let{components:n,...t}=e;return(0,s.yg)(tae,(0,p.A)({},nae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}oae.isMDXComponent=!0;const pae={toc:[]},rae="wrapper";function sae(e){let{components:n,...t}=e;return(0,s.yg)(rae,(0,p.A)({},pae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sae.isMDXComponent=!0;const cae={toc:[]},aae="wrapper";function iae(e){let{components:n,...t}=e;return(0,s.yg)(aae,(0,p.A)({},cae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}iae.isMDXComponent=!0;const lae={toc:[]},uae="wrapper";function mae(e){let{components:n,...t}=e;return(0,s.yg)(uae,(0,p.A)({},lae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}mae.isMDXComponent=!0;const yae={toc:[]},dae="wrapper";function hae(e){let{components:n,...t}=e;return(0,s.yg)(dae,(0,p.A)({},yae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hae.isMDXComponent=!0;const gae={toc:[]},fae="wrapper";function Dae(e){let{components:n,...t}=e;return(0,s.yg)(fae,(0,p.A)({},gae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Dae.isMDXComponent=!0;const Mae={toc:[]},Xae="wrapper";function _ae(e){let{components:n,...t}=e;return(0,s.yg)(Xae,(0,p.A)({},Mae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}_ae.isMDXComponent=!0;const wae={toc:[]},Tae="wrapper";function Cae(e){let{components:n,...t}=e;return(0,s.yg)(Tae,(0,p.A)({},wae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Cae.isMDXComponent=!0;const xae={toc:[]},Aae="wrapper";function vae(e){let{components:n,...t}=e;return(0,s.yg)(Aae,(0,p.A)({},xae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vae.isMDXComponent=!0;const Lae={toc:[]},bae="wrapper";function Nae(e){let{components:n,...t}=e;return(0,s.yg)(bae,(0,p.A)({},Lae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Nae.isMDXComponent=!0;const kae={toc:[]},zae="wrapper";function Pae(e){let{components:n,...t}=e;return(0,s.yg)(zae,(0,p.A)({},kae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Pae.isMDXComponent=!0;const Iae={toc:[]},Rae="wrapper";function Wae(e){let{components:n,...t}=e;return(0,s.yg)(Rae,(0,p.A)({},Iae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Wae.isMDXComponent=!0;const Sae={toc:[]},Bae="wrapper";function Gae(e){let{components:n,...t}=e;return(0,s.yg)(Bae,(0,p.A)({},Sae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Gae.isMDXComponent=!0;const Eae={toc:[]},Oae="wrapper";function Uae(e){let{components:n,...t}=e;return(0,s.yg)(Oae,(0,p.A)({},Eae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Uae.isMDXComponent=!0;const Fae={toc:[]},Vae="wrapper";function qae(e){let{components:n,...t}=e;return(0,s.yg)(Vae,(0,p.A)({},Fae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qae.isMDXComponent=!0;const jae={toc:[]},Hae="wrapper";function Yae(e){let{components:n,...t}=e;return(0,s.yg)(Hae,(0,p.A)({},jae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Yae.isMDXComponent=!0;const Qae={toc:[]},$ae="wrapper";function Kae(e){let{components:n,...t}=e;return(0,s.yg)($ae,(0,p.A)({},Qae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Kae.isMDXComponent=!0;const Jae={toc:[]},Zae="wrapper";function eie(e){let{components:n,...t}=e;return(0,s.yg)(Zae,(0,p.A)({},Jae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}eie.isMDXComponent=!0;const nie={toc:[]},tie="wrapper";function oie(e){let{components:n,...t}=e;return(0,s.yg)(tie,(0,p.A)({},nie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}oie.isMDXComponent=!0;const pie={toc:[]},rie="wrapper";function sie(e){let{components:n,...t}=e;return(0,s.yg)(rie,(0,p.A)({},pie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}sie.isMDXComponent=!0;const cie={toc:[]},aie="wrapper";function iie(e){let{components:n,...t}=e;return(0,s.yg)(aie,(0,p.A)({},cie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}iie.isMDXComponent=!0;const lie={toc:[]},uie="wrapper";function mie(e){let{components:n,...t}=e;return(0,s.yg)(uie,(0,p.A)({},lie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}mie.isMDXComponent=!0;const yie={toc:[]},die="wrapper";function hie(e){let{components:n,...t}=e;return(0,s.yg)(die,(0,p.A)({},yie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}hie.isMDXComponent=!0;const gie={toc:[]},fie="wrapper";function Die(e){let{components:n,...t}=e;return(0,s.yg)(fie,(0,p.A)({},gie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Die.isMDXComponent=!0;const Mie={toc:[]},Xie="wrapper";function _ie(e){let{components:n,...t}=e;return(0,s.yg)(Xie,(0,p.A)({},Mie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}_ie.isMDXComponent=!0;const wie={toc:[]},Tie="wrapper";function Cie(e){let{components:n,...t}=e;return(0,s.yg)(Tie,(0,p.A)({},wie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Cie.isMDXComponent=!0;const xie={toc:[]},Aie="wrapper";function vie(e){let{components:n,...t}=e;return(0,s.yg)(Aie,(0,p.A)({},xie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}vie.isMDXComponent=!0;const Lie={toc:[]},bie="wrapper";function Nie(e){let{components:n,...t}=e;return(0,s.yg)(bie,(0,p.A)({},Lie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Nie.isMDXComponent=!0;const kie={toc:[]},zie="wrapper";function Pie(e){let{components:n,...t}=e;return(0,s.yg)(zie,(0,p.A)({},kie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Pie.isMDXComponent=!0;const Iie={toc:[]},Rie="wrapper";function Wie(e){let{components:n,...t}=e;return(0,s.yg)(Rie,(0,p.A)({},Iie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Wie.isMDXComponent=!0;const Sie={toc:[]},Bie="wrapper";function Gie(e){let{components:n,...t}=e;return(0,s.yg)(Bie,(0,p.A)({},Sie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Gie.isMDXComponent=!0;const Eie={toc:[]},Oie="wrapper";function Uie(e){let{components:n,...t}=e;return(0,s.yg)(Oie,(0,p.A)({},Eie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Uie.isMDXComponent=!0;const Fie={toc:[]},Vie="wrapper";function qie(e){let{components:n,...t}=e;return(0,s.yg)(Vie,(0,p.A)({},Fie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}qie.isMDXComponent=!0;const jie={toc:[]},Hie="wrapper";function Yie(e){let{components:n,...t}=e;return(0,s.yg)(Hie,(0,p.A)({},jie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Yie.isMDXComponent=!0;const Qie={toc:[]},$ie="wrapper";function Kie(e){let{components:n,...t}=e;return(0,s.yg)($ie,(0,p.A)({},Qie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Kie.isMDXComponent=!0;const Jie={toc:[]},Zie="wrapper";function ele(e){let{components:n,...t}=e;return(0,s.yg)(Zie,(0,p.A)({},Jie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}ele.isMDXComponent=!0;const nle={toc:[]},tle="wrapper";function ole(e){let{components:n,...t}=e;return(0,s.yg)(tle,(0,p.A)({},nle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ole.isMDXComponent=!0;const ple={toc:[]},rle="wrapper";function sle(e){let{components:n,...t}=e;return(0,s.yg)(rle,(0,p.A)({},ple,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}sle.isMDXComponent=!0;const cle={toc:[]},ale="wrapper";function ile(e){let{components:n,...t}=e;return(0,s.yg)(ale,(0,p.A)({},cle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}ile.isMDXComponent=!0;const lle={toc:[]},ule="wrapper";function mle(e){let{components:n,...t}=e;return(0,s.yg)(ule,(0,p.A)({},lle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}mle.isMDXComponent=!0;const yle={toc:[]},dle="wrapper";function hle(e){let{components:n,...t}=e;return(0,s.yg)(dle,(0,p.A)({},yle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}hle.isMDXComponent=!0;const gle={toc:[]},fle="wrapper";function Dle(e){let{components:n,...t}=e;return(0,s.yg)(fle,(0,p.A)({},gle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Dle.isMDXComponent=!0;const Mle={toc:[]},Xle="wrapper";function _le(e){let{components:n,...t}=e;return(0,s.yg)(Xle,(0,p.A)({},Mle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}_le.isMDXComponent=!0;const wle={toc:[]},Tle="wrapper";function Cle(e){let{components:n,...t}=e;return(0,s.yg)(Tle,(0,p.A)({},wle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Cle.isMDXComponent=!0;const xle={toc:[]},Ale="wrapper";function vle(e){let{components:n,...t}=e;return(0,s.yg)(Ale,(0,p.A)({},xle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}vle.isMDXComponent=!0;const Lle={toc:[]},ble="wrapper";function Nle(e){let{components:n,...t}=e;return(0,s.yg)(ble,(0,p.A)({},Lle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Nle.isMDXComponent=!0;const kle={toc:[]},zle="wrapper";function Ple(e){let{components:n,...t}=e;return(0,s.yg)(zle,(0,p.A)({},kle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Ple.isMDXComponent=!0;const Ile={toc:[]},Rle="wrapper";function Wle(e){let{components:n,...t}=e;return(0,s.yg)(Rle,(0,p.A)({},Ile,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Wle.isMDXComponent=!0;const Sle={toc:[]},Ble="wrapper";function Gle(e){let{components:n,...t}=e;return(0,s.yg)(Ble,(0,p.A)({},Sle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Gle.isMDXComponent=!0;const Ele={toc:[]},Ole="wrapper";function Ule(e){let{components:n,...t}=e;return(0,s.yg)(Ole,(0,p.A)({},Ele,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ule.isMDXComponent=!0;const Fle={toc:[]},Vle="wrapper";function qle(e){let{components:n,...t}=e;return(0,s.yg)(Vle,(0,p.A)({},Fle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}qle.isMDXComponent=!0;const jle={toc:[]},Hle="wrapper";function Yle(e){let{components:n,...t}=e;return(0,s.yg)(Hle,(0,p.A)({},jle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Yle.isMDXComponent=!0;const Qle={toc:[]},$le="wrapper";function Kle(e){let{components:n,...t}=e;return(0,s.yg)($le,(0,p.A)({},Qle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Kle.isMDXComponent=!0;const Jle={toc:[]},Zle="wrapper";function eue(e){let{components:n,...t}=e;return(0,s.yg)(Zle,(0,p.A)({},Jle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eue.isMDXComponent=!0;const nue={toc:[]},tue="wrapper";function oue(e){let{components:n,...t}=e;return(0,s.yg)(tue,(0,p.A)({},nue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}oue.isMDXComponent=!0;const pue={toc:[]},rue="wrapper";function sue(e){let{components:n,...t}=e;return(0,s.yg)(rue,(0,p.A)({},pue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sue.isMDXComponent=!0;const cue={toc:[]},aue="wrapper";function iue(e){let{components:n,...t}=e;return(0,s.yg)(aue,(0,p.A)({},cue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}iue.isMDXComponent=!0;const lue={toc:[]},uue="wrapper";function mue(e){let{components:n,...t}=e;return(0,s.yg)(uue,(0,p.A)({},lue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}mue.isMDXComponent=!0;const yue={toc:[]},due="wrapper";function hue(e){let{components:n,...t}=e;return(0,s.yg)(due,(0,p.A)({},yue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}hue.isMDXComponent=!0;const gue={toc:[]},fue="wrapper";function Due(e){let{components:n,...t}=e;return(0,s.yg)(fue,(0,p.A)({},gue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Due.isMDXComponent=!0;const Mue={toc:[]},Xue="wrapper";function _ue(e){let{components:n,...t}=e;return(0,s.yg)(Xue,(0,p.A)({},Mue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}_ue.isMDXComponent=!0;const wue={toc:[]},Tue="wrapper";function Cue(e){let{components:n,...t}=e;return(0,s.yg)(Tue,(0,p.A)({},wue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Cue.isMDXComponent=!0;const xue={toc:[]},Aue="wrapper";function vue(e){let{components:n,...t}=e;return(0,s.yg)(Aue,(0,p.A)({},xue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}vue.isMDXComponent=!0;const Lue={toc:[]},bue="wrapper";function Nue(e){let{components:n,...t}=e;return(0,s.yg)(bue,(0,p.A)({},Lue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Nue.isMDXComponent=!0;const kue={toc:[]},zue="wrapper";function Pue(e){let{components:n,...t}=e;return(0,s.yg)(zue,(0,p.A)({},kue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Pue.isMDXComponent=!0;const Iue={toc:[]},Rue="wrapper";function Wue(e){let{components:n,...t}=e;return(0,s.yg)(Rue,(0,p.A)({},Iue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Wue.isMDXComponent=!0;const Sue={toc:[]},Bue="wrapper";function Gue(e){let{components:n,...t}=e;return(0,s.yg)(Bue,(0,p.A)({},Sue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Gue.isMDXComponent=!0;const Eue={toc:[]},Oue="wrapper";function Uue(e){let{components:n,...t}=e;return(0,s.yg)(Oue,(0,p.A)({},Eue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Uue.isMDXComponent=!0;const Fue={toc:[]},Vue="wrapper";function que(e){let{components:n,...t}=e;return(0,s.yg)(Vue,(0,p.A)({},Fue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}que.isMDXComponent=!0;const jue={toc:[]},Hue="wrapper";function Yue(e){let{components:n,...t}=e;return(0,s.yg)(Hue,(0,p.A)({},jue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Yue.isMDXComponent=!0;const Que={toc:[]},$ue="wrapper";function Kue(e){let{components:n,...t}=e;return(0,s.yg)($ue,(0,p.A)({},Que,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Kue.isMDXComponent=!0;const Jue={toc:[]},Zue="wrapper";function eme(e){let{components:n,...t}=e;return(0,s.yg)(Zue,(0,p.A)({},Jue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}eme.isMDXComponent=!0;const nme={toc:[]},tme="wrapper";function ome(e){let{components:n,...t}=e;return(0,s.yg)(tme,(0,p.A)({},nme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}ome.isMDXComponent=!0;const pme={toc:[]},rme="wrapper";function sme(e){let{components:n,...t}=e;return(0,s.yg)(rme,(0,p.A)({},pme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}sme.isMDXComponent=!0;const cme={toc:[]},ame="wrapper";function ime(e){let{components:n,...t}=e;return(0,s.yg)(ame,(0,p.A)({},cme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ime.isMDXComponent=!0;const lme={toc:[]},ume="wrapper";function mme(e){let{components:n,...t}=e;return(0,s.yg)(ume,(0,p.A)({},lme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}mme.isMDXComponent=!0;const yme={toc:[]},dme="wrapper";function hme(e){let{components:n,...t}=e;return(0,s.yg)(dme,(0,p.A)({},yme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}hme.isMDXComponent=!0;const gme={toc:[]},fme="wrapper";function Dme(e){let{components:n,...t}=e;return(0,s.yg)(fme,(0,p.A)({},gme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Dme.isMDXComponent=!0;const Mme={toc:[]},Xme="wrapper";function _me(e){let{components:n,...t}=e;return(0,s.yg)(Xme,(0,p.A)({},Mme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}_me.isMDXComponent=!0;const wme={toc:[]},Tme="wrapper";function Cme(e){let{components:n,...t}=e;return(0,s.yg)(Tme,(0,p.A)({},wme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Cme.isMDXComponent=!0;const xme={toc:[]},Ame="wrapper";function vme(e){let{components:n,...t}=e;return(0,s.yg)(Ame,(0,p.A)({},xme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}vme.isMDXComponent=!0;const Lme={toc:[]},bme="wrapper";function Nme(e){let{components:n,...t}=e;return(0,s.yg)(bme,(0,p.A)({},Lme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Nme.isMDXComponent=!0;const kme={toc:[]},zme="wrapper";function Pme(e){let{components:n,...t}=e;return(0,s.yg)(zme,(0,p.A)({},kme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Pme.isMDXComponent=!0;const Ime={toc:[]},Rme="wrapper";function Wme(e){let{components:n,...t}=e;return(0,s.yg)(Rme,(0,p.A)({},Ime,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Wme.isMDXComponent=!0;const Sme={toc:[]},Bme="wrapper";function Gme(e){let{components:n,...t}=e;return(0,s.yg)(Bme,(0,p.A)({},Sme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Gme.isMDXComponent=!0;const Eme={toc:[]},Ome="wrapper";function Ume(e){let{components:n,...t}=e;return(0,s.yg)(Ome,(0,p.A)({},Eme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Ume.isMDXComponent=!0;const Fme={toc:[]},Vme="wrapper";function qme(e){let{components:n,...t}=e;return(0,s.yg)(Vme,(0,p.A)({},Fme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}qme.isMDXComponent=!0;const jme={toc:[]},Hme="wrapper";function Yme(e){let{components:n,...t}=e;return(0,s.yg)(Hme,(0,p.A)({},jme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Yme.isMDXComponent=!0;const Qme={toc:[]},$me="wrapper";function Kme(e){let{components:n,...t}=e;return(0,s.yg)($me,(0,p.A)({},Qme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Kme.isMDXComponent=!0;const Jme={toc:[]},Zme="wrapper";function eye(e){let{components:n,...t}=e;return(0,s.yg)(Zme,(0,p.A)({},Jme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}eye.isMDXComponent=!0;const nye={toc:[]},tye="wrapper";function oye(e){let{components:n,...t}=e;return(0,s.yg)(tye,(0,p.A)({},nye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}oye.isMDXComponent=!0;const pye={toc:[]},rye="wrapper";function sye(e){let{components:n,...t}=e;return(0,s.yg)(rye,(0,p.A)({},pye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}sye.isMDXComponent=!0;const cye={toc:[]},aye="wrapper";function iye(e){let{components:n,...t}=e;return(0,s.yg)(aye,(0,p.A)({},cye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iye.isMDXComponent=!0;const lye={toc:[]},uye="wrapper";function mye(e){let{components:n,...t}=e;return(0,s.yg)(uye,(0,p.A)({},lye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}mye.isMDXComponent=!0;const yye={toc:[]},dye="wrapper";function hye(e){let{components:n,...t}=e;return(0,s.yg)(dye,(0,p.A)({},yye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}hye.isMDXComponent=!0;const gye={toc:[]},fye="wrapper";function Dye(e){let{components:n,...t}=e;return(0,s.yg)(fye,(0,p.A)({},gye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Dye.isMDXComponent=!0;const Mye={toc:[]},Xye="wrapper";function _ye(e){let{components:n,...t}=e;return(0,s.yg)(Xye,(0,p.A)({},Mye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}_ye.isMDXComponent=!0;const wye={toc:[]},Tye="wrapper";function Cye(e){let{components:n,...t}=e;return(0,s.yg)(Tye,(0,p.A)({},wye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Cye.isMDXComponent=!0;const xye={toc:[]},Aye="wrapper";function vye(e){let{components:n,...t}=e;return(0,s.yg)(Aye,(0,p.A)({},xye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}vye.isMDXComponent=!0;const Lye={toc:[]},bye="wrapper";function Nye(e){let{components:n,...t}=e;return(0,s.yg)(bye,(0,p.A)({},Lye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Nye.isMDXComponent=!0;const kye={toc:[]},zye="wrapper";function Pye(e){let{components:n,...t}=e;return(0,s.yg)(zye,(0,p.A)({},kye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Pye.isMDXComponent=!0;const Iye={toc:[]},Rye="wrapper";function Wye(e){let{components:n,...t}=e;return(0,s.yg)(Rye,(0,p.A)({},Iye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wye.isMDXComponent=!0;const Sye={toc:[]},Bye="wrapper";function Gye(e){let{components:n,...t}=e;return(0,s.yg)(Bye,(0,p.A)({},Sye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Gye.isMDXComponent=!0;const Eye={toc:[]},Oye="wrapper";function Uye(e){let{components:n,...t}=e;return(0,s.yg)(Oye,(0,p.A)({},Eye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Uye.isMDXComponent=!0;const Fye={toc:[]},Vye="wrapper";function qye(e){let{components:n,...t}=e;return(0,s.yg)(Vye,(0,p.A)({},Fye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}qye.isMDXComponent=!0;const jye={toc:[]},Hye="wrapper";function Yye(e){let{components:n,...t}=e;return(0,s.yg)(Hye,(0,p.A)({},jye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Yye.isMDXComponent=!0;const Qye={toc:[]},$ye="wrapper";function Kye(e){let{components:n,...t}=e;return(0,s.yg)($ye,(0,p.A)({},Qye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Kye.isMDXComponent=!0;const Jye={toc:[]},Zye="wrapper";function ede(e){let{components:n,...t}=e;return(0,s.yg)(Zye,(0,p.A)({},Jye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}ede.isMDXComponent=!0;const nde={toc:[]},tde="wrapper";function ode(e){let{components:n,...t}=e;return(0,s.yg)(tde,(0,p.A)({},nde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}ode.isMDXComponent=!0;const pde={toc:[]},rde="wrapper";function sde(e){let{components:n,...t}=e;return(0,s.yg)(rde,(0,p.A)({},pde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}sde.isMDXComponent=!0;const cde={toc:[]},ade="wrapper";function ide(e){let{components:n,...t}=e;return(0,s.yg)(ade,(0,p.A)({},cde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}ide.isMDXComponent=!0;const lde={toc:[]},ude="wrapper";function mde(e){let{components:n,...t}=e;return(0,s.yg)(ude,(0,p.A)({},lde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}mde.isMDXComponent=!0;const yde={toc:[]},dde="wrapper";function hde(e){let{components:n,...t}=e;return(0,s.yg)(dde,(0,p.A)({},yde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}hde.isMDXComponent=!0;const gde={toc:[]},fde="wrapper";function Dde(e){let{components:n,...t}=e;return(0,s.yg)(fde,(0,p.A)({},gde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Dde.isMDXComponent=!0;const Mde={toc:[]},Xde="wrapper";function _de(e){let{components:n,...t}=e;return(0,s.yg)(Xde,(0,p.A)({},Mde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}_de.isMDXComponent=!0;const wde={toc:[]},Tde="wrapper";function Cde(e){let{components:n,...t}=e;return(0,s.yg)(Tde,(0,p.A)({},wde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Cde.isMDXComponent=!0;const xde={toc:[]},Ade="wrapper";function vde(e){let{components:n,...t}=e;return(0,s.yg)(Ade,(0,p.A)({},xde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}vde.isMDXComponent=!0;const Lde={toc:[]},bde="wrapper";function Nde(e){let{components:n,...t}=e;return(0,s.yg)(bde,(0,p.A)({},Lde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Nde.isMDXComponent=!0;const kde={toc:[]},zde="wrapper";function Pde(e){let{components:n,...t}=e;return(0,s.yg)(zde,(0,p.A)({},kde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Pde.isMDXComponent=!0;const Ide={toc:[]},Rde="wrapper";function Wde(e){let{components:n,...t}=e;return(0,s.yg)(Rde,(0,p.A)({},Ide,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Wde.isMDXComponent=!0;const Sde={toc:[]},Bde="wrapper";function Gde(e){let{components:n,...t}=e;return(0,s.yg)(Bde,(0,p.A)({},Sde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Gde.isMDXComponent=!0;const Ede={toc:[]},Ode="wrapper";function Ude(e){let{components:n,...t}=e;return(0,s.yg)(Ode,(0,p.A)({},Ede,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Ude.isMDXComponent=!0;const Fde={toc:[]},Vde="wrapper";function qde(e){let{components:n,...t}=e;return(0,s.yg)(Vde,(0,p.A)({},Fde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qde.isMDXComponent=!0;const jde={toc:[]},Hde="wrapper";function Yde(e){let{components:n,...t}=e;return(0,s.yg)(Hde,(0,p.A)({},jde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Yde.isMDXComponent=!0;const Qde={toc:[]},$de="wrapper";function Kde(e){let{components:n,...t}=e;return(0,s.yg)($de,(0,p.A)({},Qde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Kde.isMDXComponent=!0;const Jde={toc:[]},Zde="wrapper";function ehe(e){let{components:n,...t}=e;return(0,s.yg)(Zde,(0,p.A)({},Jde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}ehe.isMDXComponent=!0;const nhe={toc:[]},the="wrapper";function ohe(e){let{components:n,...t}=e;return(0,s.yg)(the,(0,p.A)({},nhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}ohe.isMDXComponent=!0;const phe={toc:[]},rhe="wrapper";function she(e){let{components:n,...t}=e;return(0,s.yg)(rhe,(0,p.A)({},phe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}she.isMDXComponent=!0;const che={toc:[]},ahe="wrapper";function ihe(e){let{components:n,...t}=e;return(0,s.yg)(ahe,(0,p.A)({},che,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}ihe.isMDXComponent=!0;const lhe={toc:[]},uhe="wrapper";function mhe(e){let{components:n,...t}=e;return(0,s.yg)(uhe,(0,p.A)({},lhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}mhe.isMDXComponent=!0;const yhe={toc:[]},dhe="wrapper";function hhe(e){let{components:n,...t}=e;return(0,s.yg)(dhe,(0,p.A)({},yhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}hhe.isMDXComponent=!0;const ghe={toc:[]},fhe="wrapper";function Dhe(e){let{components:n,...t}=e;return(0,s.yg)(fhe,(0,p.A)({},ghe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Dhe.isMDXComponent=!0;const Mhe={toc:[]},Xhe="wrapper";function _he(e){let{components:n,...t}=e;return(0,s.yg)(Xhe,(0,p.A)({},Mhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}_he.isMDXComponent=!0;const whe={toc:[]},The="wrapper";function Che(e){let{components:n,...t}=e;return(0,s.yg)(The,(0,p.A)({},whe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Che.isMDXComponent=!0;const xhe={toc:[]},Ahe="wrapper";function vhe(e){let{components:n,...t}=e;return(0,s.yg)(Ahe,(0,p.A)({},xhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}vhe.isMDXComponent=!0;const Lhe={toc:[]},bhe="wrapper";function Nhe(e){let{components:n,...t}=e;return(0,s.yg)(bhe,(0,p.A)({},Lhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Nhe.isMDXComponent=!0;const khe={toc:[]},zhe="wrapper";function Phe(e){let{components:n,...t}=e;return(0,s.yg)(zhe,(0,p.A)({},khe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Phe.isMDXComponent=!0;const Ihe={toc:[]},Rhe="wrapper";function Whe(e){let{components:n,...t}=e;return(0,s.yg)(Rhe,(0,p.A)({},Ihe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Whe.isMDXComponent=!0;const She={toc:[]},Bhe="wrapper";function Ghe(e){let{components:n,...t}=e;return(0,s.yg)(Bhe,(0,p.A)({},She,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Ghe.isMDXComponent=!0;const Ehe={toc:[]},Ohe="wrapper";function Uhe(e){let{components:n,...t}=e;return(0,s.yg)(Ohe,(0,p.A)({},Ehe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Uhe.isMDXComponent=!0;const Fhe={toc:[]},Vhe="wrapper";function qhe(e){let{components:n,...t}=e;return(0,s.yg)(Vhe,(0,p.A)({},Fhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qhe.isMDXComponent=!0;const jhe={toc:[]},Hhe="wrapper";function Yhe(e){let{components:n,...t}=e;return(0,s.yg)(Hhe,(0,p.A)({},jhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Yhe.isMDXComponent=!0;const Qhe={toc:[]},$he="wrapper";function Khe(e){let{components:n,...t}=e;return(0,s.yg)($he,(0,p.A)({},Qhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Khe.isMDXComponent=!0;const Jhe={toc:[]},Zhe="wrapper";function ege(e){let{components:n,...t}=e;return(0,s.yg)(Zhe,(0,p.A)({},Jhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ege.isMDXComponent=!0;const nge={toc:[]},tge="wrapper";function oge(e){let{components:n,...t}=e;return(0,s.yg)(tge,(0,p.A)({},nge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}oge.isMDXComponent=!0;const pge={toc:[]},rge="wrapper";function sge(e){let{components:n,...t}=e;return(0,s.yg)(rge,(0,p.A)({},pge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}sge.isMDXComponent=!0;const cge={toc:[]},age="wrapper";function ige(e){let{components:n,...t}=e;return(0,s.yg)(age,(0,p.A)({},cge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ige.isMDXComponent=!0;const lge={toc:[]},uge="wrapper";function mge(e){let{components:n,...t}=e;return(0,s.yg)(uge,(0,p.A)({},lge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}mge.isMDXComponent=!0;const yge={toc:[]},dge="wrapper";function hge(e){let{components:n,...t}=e;return(0,s.yg)(dge,(0,p.A)({},yge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}hge.isMDXComponent=!0;const gge={toc:[]},fge="wrapper";function Dge(e){let{components:n,...t}=e;return(0,s.yg)(fge,(0,p.A)({},gge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Dge.isMDXComponent=!0;const Mge={toc:[]},Xge="wrapper";function _ge(e){let{components:n,...t}=e;return(0,s.yg)(Xge,(0,p.A)({},Mge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}_ge.isMDXComponent=!0;const wge={toc:[]},Tge="wrapper";function Cge(e){let{components:n,...t}=e;return(0,s.yg)(Tge,(0,p.A)({},wge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Cge.isMDXComponent=!0;const xge={toc:[]},Age="wrapper";function vge(e){let{components:n,...t}=e;return(0,s.yg)(Age,(0,p.A)({},xge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vge.isMDXComponent=!0;const Lge={toc:[]},bge="wrapper";function Nge(e){let{components:n,...t}=e;return(0,s.yg)(bge,(0,p.A)({},Lge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Nge.isMDXComponent=!0;const kge={toc:[]},zge="wrapper";function Pge(e){let{components:n,...t}=e;return(0,s.yg)(zge,(0,p.A)({},kge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Pge.isMDXComponent=!0;const Ige={toc:[]},Rge="wrapper";function Wge(e){let{components:n,...t}=e;return(0,s.yg)(Rge,(0,p.A)({},Ige,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Wge.isMDXComponent=!0;const Sge={toc:[]},Bge="wrapper";function Gge(e){let{components:n,...t}=e;return(0,s.yg)(Bge,(0,p.A)({},Sge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}Gge.isMDXComponent=!0;const Ege={toc:[]},Oge="wrapper";function Uge(e){let{components:n,...t}=e;return(0,s.yg)(Oge,(0,p.A)({},Ege,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}Uge.isMDXComponent=!0;const Fge={toc:[]},Vge="wrapper";function qge(e){let{components:n,...t}=e;return(0,s.yg)(Vge,(0,p.A)({},Fge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing circular shapes."))}qge.isMDXComponent=!0;const jge={toc:[]},Hge="wrapper";function Yge(e){let{components:n,...t}=e;return(0,s.yg)(Hge,(0,p.A)({},jge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Yge.isMDXComponent=!0;const Qge={toc:[]},$ge="wrapper";function Kge(e){let{components:n,...t}=e;return(0,s.yg)($ge,(0,p.A)({},Qge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Kge.isMDXComponent=!0;const Jge={toc:[]},Zge="wrapper";function efe(e){let{components:n,...t}=e;return(0,s.yg)(Zge,(0,p.A)({},Jge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}efe.isMDXComponent=!0;const nfe={toc:[]},tfe="wrapper";function ofe(e){let{components:n,...t}=e;return(0,s.yg)(tfe,(0,p.A)({},nfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}ofe.isMDXComponent=!0;const pfe={toc:[]},rfe="wrapper";function sfe(e){let{components:n,...t}=e;return(0,s.yg)(rfe,(0,p.A)({},pfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}sfe.isMDXComponent=!0;const cfe={toc:[]},afe="wrapper";function ife(e){let{components:n,...t}=e;return(0,s.yg)(afe,(0,p.A)({},cfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}ife.isMDXComponent=!0;const lfe={toc:[]},ufe="wrapper";function mfe(e){let{components:n,...t}=e;return(0,s.yg)(ufe,(0,p.A)({},lfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}mfe.isMDXComponent=!0;const yfe={toc:[]},dfe="wrapper";function hfe(e){let{components:n,...t}=e;return(0,s.yg)(dfe,(0,p.A)({},yfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}hfe.isMDXComponent=!0;const gfe={toc:[]},ffe="wrapper";function Dfe(e){let{components:n,...t}=e;return(0,s.yg)(ffe,(0,p.A)({},gfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Dfe.isMDXComponent=!0;const Mfe={toc:[]},Xfe="wrapper";function _fe(e){let{components:n,...t}=e;return(0,s.yg)(Xfe,(0,p.A)({},Mfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}_fe.isMDXComponent=!0;const wfe={toc:[]},Tfe="wrapper";function Cfe(e){let{components:n,...t}=e;return(0,s.yg)(Tfe,(0,p.A)({},wfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Cfe.isMDXComponent=!0;const xfe={toc:[]},Afe="wrapper";function vfe(e){let{components:n,...t}=e;return(0,s.yg)(Afe,(0,p.A)({},xfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}vfe.isMDXComponent=!0;const Lfe={toc:[]},bfe="wrapper";function Nfe(e){let{components:n,...t}=e;return(0,s.yg)(bfe,(0,p.A)({},Lfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Nfe.isMDXComponent=!0;const kfe={toc:[]},zfe="wrapper";function Pfe(e){let{components:n,...t}=e;return(0,s.yg)(zfe,(0,p.A)({},kfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Pfe.isMDXComponent=!0;const Ife={toc:[]},Rfe="wrapper";function Wfe(e){let{components:n,...t}=e;return(0,s.yg)(Rfe,(0,p.A)({},Ife,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Wfe.isMDXComponent=!0;const Sfe={toc:[]},Bfe="wrapper";function Gfe(e){let{components:n,...t}=e;return(0,s.yg)(Bfe,(0,p.A)({},Sfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Gfe.isMDXComponent=!0;const Efe={toc:[]},Ofe="wrapper";function Ufe(e){let{components:n,...t}=e;return(0,s.yg)(Ofe,(0,p.A)({},Efe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}Ufe.isMDXComponent=!0;const Ffe={toc:[]},Vfe="wrapper";function qfe(e){let{components:n,...t}=e;return(0,s.yg)(Vfe,(0,p.A)({},Ffe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A closed circle will look like a pie chart:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.yg)("p",null,"An open one will look like an arc:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}qfe.isMDXComponent=!0;const jfe={toc:[]},Hfe="wrapper";function Yfe(e){let{components:n,...t}=e;return(0,s.yg)(Hfe,(0,p.A)({},jfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"false"))}Yfe.isMDXComponent=!0;const Qfe={toc:[]},$fe="wrapper";function Kfe(e){let{components:n,...t}=e;return(0,s.yg)($fe,(0,p.A)({},Qfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the path of this circle should be closed."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]},Zfe="wrapper";function eDe(e){let{components:n,...t}=e;return(0,s.yg)(Zfe,(0,p.A)({},Jfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the circle begins at ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}eDe.isMDXComponent=!0;const nDe={toc:[]},tDe="wrapper";function oDe(e){let{components:n,...t}=e;return(0,s.yg)(tDe,(0,p.A)({},nDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the circle sector should be drawn counterclockwise."))}oDe.isMDXComponent=!0;const pDe={toc:[]},rDe="wrapper";function sDe(e){let{components:n,...t}=e;return(0,s.yg)(rDe,(0,p.A)({},pDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}sDe.isMDXComponent=!0;const cDe={toc:[]},aDe="wrapper";function iDe(e){let{components:n,...t}=e;return(0,s.yg)(aDe,(0,p.A)({},cDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}iDe.isMDXComponent=!0;const lDe={toc:[]},uDe="wrapper";function mDe(e){let{components:n,...t}=e;return(0,s.yg)(uDe,(0,p.A)({},lDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}mDe.isMDXComponent=!0;const yDe={toc:[]},dDe="wrapper";function hDe(e){let{components:n,...t}=e;return(0,s.yg)(dDe,(0,p.A)({},yDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"360"))}hDe.isMDXComponent=!0;const gDe={toc:[]},fDe="wrapper";function DDe(e){let{components:n,...t}=e;return(0,s.yg)(fDe,(0,p.A)({},gDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending angle in degrees for the circle sector."))}DDe.isMDXComponent=!0;const MDe={toc:[]},XDe="wrapper";function _De(e){let{components:n,...t}=e;return(0,s.yg)(XDe,(0,p.A)({},MDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_De.isMDXComponent=!0;const wDe={toc:[]},TDe="wrapper";function CDe(e){let{components:n,...t}=e;return(0,s.yg)(TDe,(0,p.A)({},wDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}CDe.isMDXComponent=!0;const xDe={toc:[]},ADe="wrapper";function vDe(e){let{components:n,...t}=e;return(0,s.yg)(ADe,(0,p.A)({},xDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}vDe.isMDXComponent=!0;const LDe={toc:[]},bDe="wrapper";function NDe(e){let{components:n,...t}=e;return(0,s.yg)(bDe,(0,p.A)({},LDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}NDe.isMDXComponent=!0;const kDe={toc:[]},zDe="wrapper";function PDe(e){let{components:n,...t}=e;return(0,s.yg)(zDe,(0,p.A)({},kDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}PDe.isMDXComponent=!0;const IDe={toc:[]},RDe="wrapper";function WDe(e){let{components:n,...t}=e;return(0,s.yg)(RDe,(0,p.A)({},IDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}WDe.isMDXComponent=!0;const SDe={toc:[]},BDe="wrapper";function GDe(e){let{components:n,...t}=e;return(0,s.yg)(BDe,(0,p.A)({},SDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}GDe.isMDXComponent=!0;const EDe={toc:[]},ODe="wrapper";function UDe(e){let{components:n,...t}=e;return(0,s.yg)(ODe,(0,p.A)({},EDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}UDe.isMDXComponent=!0;const FDe={toc:[]},VDe="wrapper";function qDe(e){let{components:n,...t}=e;return(0,s.yg)(VDe,(0,p.A)({},FDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qDe.isMDXComponent=!0;const jDe={toc:[]},HDe="wrapper";function YDe(e){let{components:n,...t}=e;return(0,s.yg)(HDe,(0,p.A)({},jDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}YDe.isMDXComponent=!0;const QDe={toc:[]},$De="wrapper";function KDe(e){let{components:n,...t}=e;return(0,s.yg)($De,(0,p.A)({},QDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}KDe.isMDXComponent=!0;const JDe={toc:[]},ZDe="wrapper";function eMe(e){let{components:n,...t}=e;return(0,s.yg)(ZDe,(0,p.A)({},JDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}eMe.isMDXComponent=!0;const nMe={toc:[]},tMe="wrapper";function oMe(e){let{components:n,...t}=e;return(0,s.yg)(tMe,(0,p.A)({},nMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}oMe.isMDXComponent=!0;const pMe={toc:[]},rMe="wrapper";function sMe(e){let{components:n,...t}=e;return(0,s.yg)(rMe,(0,p.A)({},pMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}sMe.isMDXComponent=!0;const cMe={toc:[]},aMe="wrapper";function iMe(e){let{components:n,...t}=e;return(0,s.yg)(aMe,(0,p.A)({},cMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}iMe.isMDXComponent=!0;const lMe={toc:[]},uMe="wrapper";function mMe(e){let{components:n,...t}=e;return(0,s.yg)(uMe,(0,p.A)({},lMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}mMe.isMDXComponent=!0;const yMe={toc:[]},dMe="wrapper";function hMe(e){let{components:n,...t}=e;return(0,s.yg)(dMe,(0,p.A)({},yMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hMe.isMDXComponent=!0;const gMe={toc:[]},fMe="wrapper";function DMe(e){let{components:n,...t}=e;return(0,s.yg)(fMe,(0,p.A)({},gMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DMe.isMDXComponent=!0;const MMe={toc:[]},XMe="wrapper";function _Me(e){let{components:n,...t}=e;return(0,s.yg)(XMe,(0,p.A)({},MMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}_Me.isMDXComponent=!0;const wMe={toc:[]},TMe="wrapper";function CMe(e){let{components:n,...t}=e;return(0,s.yg)(TMe,(0,p.A)({},wMe,t,{components:n,mdxType:"MDXLayout"}))}CMe.isMDXComponent=!0;const xMe={toc:[]},AMe="wrapper";function vMe(e){let{components:n,...t}=e;return(0,s.yg)(AMe,(0,p.A)({},xMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}vMe.isMDXComponent=!0;const LMe={toc:[]},bMe="wrapper";function NMe(e){let{components:n,...t}=e;return(0,s.yg)(bMe,(0,p.A)({},LMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}NMe.isMDXComponent=!0;const kMe={toc:[]},zMe="wrapper";function PMe(e){let{components:n,...t}=e;return(0,s.yg)(zMe,(0,p.A)({},kMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}PMe.isMDXComponent=!0;const IMe={toc:[]},RMe="wrapper";function WMe(e){let{components:n,...t}=e;return(0,s.yg)(RMe,(0,p.A)({},IMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}WMe.isMDXComponent=!0;const SMe={toc:[]},BMe="wrapper";function GMe(e){let{components:n,...t}=e;return(0,s.yg)(BMe,(0,p.A)({},SMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}GMe.isMDXComponent=!0;const EMe={toc:[]},OMe="wrapper";function UMe(e){let{components:n,...t}=e;return(0,s.yg)(OMe,(0,p.A)({},EMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}UMe.isMDXComponent=!0;const FMe={toc:[]},VMe="wrapper";function qMe(e){let{components:n,...t}=e;return(0,s.yg)(VMe,(0,p.A)({},FMe,t,{components:n,mdxType:"MDXLayout"}))}qMe.isMDXComponent=!0;const jMe={toc:[]},HMe="wrapper";function YMe(e){let{components:n,...t}=e;return(0,s.yg)(HMe,(0,p.A)({},jMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}YMe.isMDXComponent=!0;const QMe={toc:[]},$Me="wrapper";function KMe(e){let{components:n,...t}=e;return(0,s.yg)($Me,(0,p.A)({},QMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}KMe.isMDXComponent=!0;const JMe={toc:[]},ZMe="wrapper";function eXe(e){let{components:n,...t}=e;return(0,s.yg)(ZMe,(0,p.A)({},JMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}eXe.isMDXComponent=!0;const nXe={toc:[]},tXe="wrapper";function oXe(e){let{components:n,...t}=e;return(0,s.yg)(tXe,(0,p.A)({},nXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0"))}oXe.isMDXComponent=!0;const pXe={toc:[]},rXe="wrapper";function sXe(e){let{components:n,...t}=e;return(0,s.yg)(rXe,(0,p.A)({},pXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting angle in degrees for the circle sector."))}sXe.isMDXComponent=!0;const cXe={toc:[]},aXe="wrapper";function iXe(e){let{components:n,...t}=e;return(0,s.yg)(aXe,(0,p.A)({},cXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}iXe.isMDXComponent=!0;const lXe={toc:[]},uXe="wrapper";function mXe(e){let{components:n,...t}=e;return(0,s.yg)(uXe,(0,p.A)({},lXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}mXe.isMDXComponent=!0;const yXe={toc:[]},dXe="wrapper";function hXe(e){let{components:n,...t}=e;return(0,s.yg)(dXe,(0,p.A)({},yXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}hXe.isMDXComponent=!0;const gXe={toc:[]},fXe="wrapper";function DXe(e){let{components:n,...t}=e;return(0,s.yg)(fXe,(0,p.A)({},gXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}DXe.isMDXComponent=!0;const MXe={toc:[]},XXe="wrapper";function _Xe(e){let{components:n,...t}=e;return(0,s.yg)(XXe,(0,p.A)({},MXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}_Xe.isMDXComponent=!0;const wXe={toc:[]},TXe="wrapper";function CXe(e){let{components:n,...t}=e;return(0,s.yg)(TXe,(0,p.A)({},wXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}CXe.isMDXComponent=!0;const xXe={toc:[]},AXe="wrapper";function vXe(e){let{components:n,...t}=e;return(0,s.yg)(AXe,(0,p.A)({},xXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}vXe.isMDXComponent=!0;const LXe={toc:[]},bXe="wrapper";function NXe(e){let{components:n,...t}=e;return(0,s.yg)(bXe,(0,p.A)({},LXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}NXe.isMDXComponent=!0;const kXe={toc:[]},zXe="wrapper";function PXe(e){let{components:n,...t}=e;return(0,s.yg)(zXe,(0,p.A)({},kXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}PXe.isMDXComponent=!0;const IXe={toc:[]},RXe="wrapper";function WXe(e){let{components:n,...t}=e;return(0,s.yg)(RXe,(0,p.A)({},IXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}WXe.isMDXComponent=!0;const SXe={toc:[]},BXe="wrapper";function GXe(e){let{components:n,...t}=e;return(0,s.yg)(BXe,(0,p.A)({},SXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}GXe.isMDXComponent=!0;const EXe={toc:[]},OXe="wrapper";function UXe(e){let{components:n,...t}=e;return(0,s.yg)(OXe,(0,p.A)({},EXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}UXe.isMDXComponent=!0;const FXe={toc:[]},VXe="wrapper";function qXe(e){let{components:n,...t}=e;return(0,s.yg)(VXe,(0,p.A)({},FXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}qXe.isMDXComponent=!0;const jXe={toc:[]},HXe="wrapper";function YXe(e){let{components:n,...t}=e;return(0,s.yg)(HXe,(0,p.A)({},jXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}YXe.isMDXComponent=!0;const QXe={toc:[]},$Xe="wrapper";function KXe(e){let{components:n,...t}=e;return(0,s.yg)($Xe,(0,p.A)({},QXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}KXe.isMDXComponent=!0;const JXe={toc:[]},ZXe="wrapper";function e_e(e){let{components:n,...t}=e;return(0,s.yg)(ZXe,(0,p.A)({},JXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}e_e.isMDXComponent=!0;const n_e={toc:[]},t_e="wrapper";function o_e(e){let{components:n,...t}=e;return(0,s.yg)(t_e,(0,p.A)({},n_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}o_e.isMDXComponent=!0;const p_e={toc:[]},r_e="wrapper";function s_e(e){let{components:n,...t}=e;return(0,s.yg)(r_e,(0,p.A)({},p_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}s_e.isMDXComponent=!0;const c_e={toc:[]},a_e="wrapper";function i_e(e){let{components:n,...t}=e;return(0,s.yg)(a_e,(0,p.A)({},c_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}i_e.isMDXComponent=!0;const l_e={toc:[]},u_e="wrapper";function m_e(e){let{components:n,...t}=e;return(0,s.yg)(u_e,(0,p.A)({},l_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}m_e.isMDXComponent=!0;const y_e={toc:[]},d_e="wrapper";function h_e(e){let{components:n,...t}=e;return(0,s.yg)(d_e,(0,p.A)({},y_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}h_e.isMDXComponent=!0;const g_e={toc:[]},f_e="wrapper";function D_e(e){let{components:n,...t}=e;return(0,s.yg)(f_e,(0,p.A)({},g_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}D_e.isMDXComponent=!0;const M_e={toc:[]},X_e="wrapper";function __e(e){let{components:n,...t}=e;return(0,s.yg)(X_e,(0,p.A)({},M_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}__e.isMDXComponent=!0;const w_e={toc:[]},T_e="wrapper";function C_e(e){let{components:n,...t}=e;return(0,s.yg)(T_e,(0,p.A)({},w_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}C_e.isMDXComponent=!0;const x_e={toc:[]},A_e="wrapper";function v_e(e){let{components:n,...t}=e;return(0,s.yg)(A_e,(0,p.A)({},x_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}v_e.isMDXComponent=!0;const L_e={toc:[]},b_e="wrapper";function N_e(e){let{components:n,...t}=e;return(0,s.yg)(b_e,(0,p.A)({},L_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}N_e.isMDXComponent=!0;const k_e={toc:[]},z_e="wrapper";function P_e(e){let{components:n,...t}=e;return(0,s.yg)(z_e,(0,p.A)({},k_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}P_e.isMDXComponent=!0;const I_e={toc:[]},R_e="wrapper";function W_e(e){let{components:n,...t}=e;return(0,s.yg)(R_e,(0,p.A)({},I_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}W_e.isMDXComponent=!0;const S_e={toc:[]},B_e="wrapper";function G_e(e){let{components:n,...t}=e;return(0,s.yg)(B_e,(0,p.A)({},S_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}G_e.isMDXComponent=!0;const E_e={toc:[]},O_e="wrapper";function U_e(e){let{components:n,...t}=e;return(0,s.yg)(O_e,(0,p.A)({},E_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}U_e.isMDXComponent=!0;const F_e={toc:[]},V_e="wrapper";function q_e(e){let{components:n,...t}=e;return(0,s.yg)(V_e,(0,p.A)({},F_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}q_e.isMDXComponent=!0;const j_e={toc:[]},H_e="wrapper";function Y_e(e){let{components:n,...t}=e;return(0,s.yg)(H_e,(0,p.A)({},j_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Y_e.isMDXComponent=!0;const Q_e={toc:[]},$_e="wrapper";function K_e(e){let{components:n,...t}=e;return(0,s.yg)($_e,(0,p.A)({},Q_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}K_e.isMDXComponent=!0;const J_e={toc:[]},Z_e="wrapper";function ewe(e){let{components:n,...t}=e;return(0,s.yg)(Z_e,(0,p.A)({},J_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}ewe.isMDXComponent=!0;const nwe={toc:[]},twe="wrapper";function owe(e){let{components:n,...t}=e;return(0,s.yg)(twe,(0,p.A)({},nwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}owe.isMDXComponent=!0;const pwe={toc:[]},rwe="wrapper";function swe(e){let{components:n,...t}=e;return(0,s.yg)(rwe,(0,p.A)({},pwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}swe.isMDXComponent=!0;const cwe={toc:[]},awe="wrapper";function iwe(e){let{components:n,...t}=e;return(0,s.yg)(awe,(0,p.A)({},cwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}iwe.isMDXComponent=!0;const lwe={toc:[]},uwe="wrapper";function mwe(e){let{components:n,...t}=e;return(0,s.yg)(uwe,(0,p.A)({},lwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}mwe.isMDXComponent=!0;const ywe={toc:[]},dwe="wrapper";function hwe(e){let{components:n,...t}=e;return(0,s.yg)(dwe,(0,p.A)({},ywe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}hwe.isMDXComponent=!0;const gwe={toc:[]},fwe="wrapper";function Dwe(e){let{components:n,...t}=e;return(0,s.yg)(fwe,(0,p.A)({},gwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Dwe.isMDXComponent=!0;const Mwe={toc:[]},Xwe="wrapper";function _we(e){let{components:n,...t}=e;return(0,s.yg)(Xwe,(0,p.A)({},Mwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}_we.isMDXComponent=!0;const wwe={toc:[]},Twe="wrapper";function Cwe(e){let{components:n,...t}=e;return(0,s.yg)(Twe,(0,p.A)({},wwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Cwe.isMDXComponent=!0;const xwe={toc:[]},Awe="wrapper";function vwe(e){let{components:n,...t}=e;return(0,s.yg)(Awe,(0,p.A)({},xwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}vwe.isMDXComponent=!0;const Lwe={toc:[]},bwe="wrapper";function Nwe(e){let{components:n,...t}=e;return(0,s.yg)(bwe,(0,p.A)({},Lwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Nwe.isMDXComponent=!0;const kwe={toc:[]},zwe="wrapper";function Pwe(e){let{components:n,...t}=e;return(0,s.yg)(zwe,(0,p.A)({},kwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Pwe.isMDXComponent=!0;const Iwe={toc:[]},Rwe="wrapper";function Wwe(e){let{components:n,...t}=e;return(0,s.yg)(Rwe,(0,p.A)({},Iwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Wwe.isMDXComponent=!0;const Swe={toc:[]},Bwe="wrapper";function Gwe(e){let{components:n,...t}=e;return(0,s.yg)(Bwe,(0,p.A)({},Swe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Gwe.isMDXComponent=!0;const Ewe={toc:[]},Owe="wrapper";function Uwe(e){let{components:n,...t}=e;return(0,s.yg)(Owe,(0,p.A)({},Ewe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Uwe.isMDXComponent=!0;const Fwe={toc:[]},Vwe="wrapper";function qwe(e){let{components:n,...t}=e;return(0,s.yg)(Vwe,(0,p.A)({},Fwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}qwe.isMDXComponent=!0;const jwe={toc:[]},Hwe="wrapper";function Ywe(e){let{components:n,...t}=e;return(0,s.yg)(Hwe,(0,p.A)({},jwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Ywe.isMDXComponent=!0;const Qwe={toc:[]},$we="wrapper";function Kwe(e){let{components:n,...t}=e;return(0,s.yg)($we,(0,p.A)({},Qwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]},Zwe="wrapper";function eTe(e){let{components:n,...t}=e;return(0,s.yg)(Zwe,(0,p.A)({},Jwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eTe.isMDXComponent=!0;const nTe={toc:[]},tTe="wrapper";function oTe(e){let{components:n,...t}=e;return(0,s.yg)(tTe,(0,p.A)({},nTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}oTe.isMDXComponent=!0;const pTe={toc:[]},rTe="wrapper";function sTe(e){let{components:n,...t}=e;return(0,s.yg)(rTe,(0,p.A)({},pTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sTe.isMDXComponent=!0;const cTe={toc:[]},aTe="wrapper";function iTe(e){let{components:n,...t}=e;return(0,s.yg)(aTe,(0,p.A)({},cTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}iTe.isMDXComponent=!0;const lTe={toc:[]},uTe="wrapper";function mTe(e){let{components:n,...t}=e;return(0,s.yg)(uTe,(0,p.A)({},lTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mTe.isMDXComponent=!0;const yTe={toc:[]},dTe="wrapper";function hTe(e){let{components:n,...t}=e;return(0,s.yg)(dTe,(0,p.A)({},yTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}hTe.isMDXComponent=!0;const gTe={toc:[]},fTe="wrapper";function DTe(e){let{components:n,...t}=e;return(0,s.yg)(fTe,(0,p.A)({},gTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DTe.isMDXComponent=!0;const MTe={toc:[]},XTe="wrapper";function _Te(e){let{components:n,...t}=e;return(0,s.yg)(XTe,(0,p.A)({},MTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}_Te.isMDXComponent=!0;const wTe={toc:[]},TTe="wrapper";function CTe(e){let{components:n,...t}=e;return(0,s.yg)(TTe,(0,p.A)({},wTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}CTe.isMDXComponent=!0;const xTe={toc:[]},ATe="wrapper";function vTe(e){let{components:n,...t}=e;return(0,s.yg)(ATe,(0,p.A)({},xTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}vTe.isMDXComponent=!0;const LTe={toc:[]},bTe="wrapper";function NTe(e){let{components:n,...t}=e;return(0,s.yg)(bTe,(0,p.A)({},LTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}NTe.isMDXComponent=!0;const kTe={toc:[]},zTe="wrapper";function PTe(e){let{components:n,...t}=e;return(0,s.yg)(zTe,(0,p.A)({},kTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}PTe.isMDXComponent=!0;const ITe={toc:[]},RTe="wrapper";function WTe(e){let{components:n,...t}=e;return(0,s.yg)(RTe,(0,p.A)({},ITe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}WTe.isMDXComponent=!0;const STe={toc:[]},BTe="wrapper";function GTe(e){let{components:n,...t}=e;return(0,s.yg)(BTe,(0,p.A)({},STe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}GTe.isMDXComponent=!0;const ETe={toc:[]},OTe="wrapper";function UTe(e){let{components:n,...t}=e;return(0,s.yg)(OTe,(0,p.A)({},ETe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}UTe.isMDXComponent=!0;const FTe={toc:[]},VTe="wrapper";function qTe(e){let{components:n,...t}=e;return(0,s.yg)(VTe,(0,p.A)({},FTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}qTe.isMDXComponent=!0;const jTe={toc:[]},HTe="wrapper";function YTe(e){let{components:n,...t}=e;return(0,s.yg)(HTe,(0,p.A)({},jTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}YTe.isMDXComponent=!0;const QTe={toc:[]},$Te="wrapper";function KTe(e){let{components:n,...t}=e;return(0,s.yg)($Te,(0,p.A)({},QTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}KTe.isMDXComponent=!0;const JTe={toc:[]},ZTe="wrapper";function eCe(e){let{components:n,...t}=e;return(0,s.yg)(ZTe,(0,p.A)({},JTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}eCe.isMDXComponent=!0;const nCe={toc:[]},tCe="wrapper";function oCe(e){let{components:n,...t}=e;return(0,s.yg)(tCe,(0,p.A)({},nCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}oCe.isMDXComponent=!0;const pCe={toc:[]},rCe="wrapper";function sCe(e){let{components:n,...t}=e;return(0,s.yg)(rCe,(0,p.A)({},pCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}sCe.isMDXComponent=!0;const cCe={toc:[]},aCe="wrapper";function iCe(e){let{components:n,...t}=e;return(0,s.yg)(aCe,(0,p.A)({},cCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}iCe.isMDXComponent=!0;const lCe={toc:[]},uCe="wrapper";function mCe(e){let{components:n,...t}=e;return(0,s.yg)(uCe,(0,p.A)({},lCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}mCe.isMDXComponent=!0;const yCe={toc:[]},dCe="wrapper";function hCe(e){let{components:n,...t}=e;return(0,s.yg)(dCe,(0,p.A)({},yCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}hCe.isMDXComponent=!0;const gCe={toc:[]},fCe="wrapper";function DCe(e){let{components:n,...t}=e;return(0,s.yg)(fCe,(0,p.A)({},gCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}DCe.isMDXComponent=!0;const MCe={toc:[]},XCe="wrapper";function _Ce(e){let{components:n,...t}=e;return(0,s.yg)(XCe,(0,p.A)({},MCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}_Ce.isMDXComponent=!0;const wCe={toc:[]},TCe="wrapper";function CCe(e){let{components:n,...t}=e;return(0,s.yg)(TCe,(0,p.A)({},wCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}CCe.isMDXComponent=!0;const xCe={toc:[]},ACe="wrapper";function vCe(e){let{components:n,...t}=e;return(0,s.yg)(ACe,(0,p.A)({},xCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}vCe.isMDXComponent=!0;const LCe={toc:[]},bCe="wrapper";function NCe(e){let{components:n,...t}=e;return(0,s.yg)(bCe,(0,p.A)({},LCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}NCe.isMDXComponent=!0;const kCe={toc:[]},zCe="wrapper";function PCe(e){let{components:n,...t}=e;return(0,s.yg)(zCe,(0,p.A)({},kCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}PCe.isMDXComponent=!0;const ICe={toc:[]},RCe="wrapper";function WCe(e){let{components:n,...t}=e;return(0,s.yg)(RCe,(0,p.A)({},ICe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}WCe.isMDXComponent=!0;const SCe={toc:[]},BCe="wrapper";function GCe(e){let{components:n,...t}=e;return(0,s.yg)(BCe,(0,p.A)({},SCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}GCe.isMDXComponent=!0;const ECe={toc:[]},OCe="wrapper";function UCe(e){let{components:n,...t}=e;return(0,s.yg)(OCe,(0,p.A)({},ECe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}UCe.isMDXComponent=!0;const FCe={toc:[]},VCe="wrapper";function qCe(e){let{components:n,...t}=e;return(0,s.yg)(VCe,(0,p.A)({},FCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qCe.isMDXComponent=!0;const jCe={toc:[]},HCe="wrapper";function YCe(e){let{components:n,...t}=e;return(0,s.yg)(HCe,(0,p.A)({},jCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}YCe.isMDXComponent=!0;const QCe={toc:[]},$Ce="wrapper";function KCe(e){let{components:n,...t}=e;return(0,s.yg)($Ce,(0,p.A)({},QCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}KCe.isMDXComponent=!0;const JCe={toc:[]},ZCe="wrapper";function exe(e){let{components:n,...t}=e;return(0,s.yg)(ZCe,(0,p.A)({},JCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}exe.isMDXComponent=!0;const nxe={toc:[]},txe="wrapper";function oxe(e){let{components:n,...t}=e;return(0,s.yg)(txe,(0,p.A)({},nxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}oxe.isMDXComponent=!0;const pxe={toc:[]},rxe="wrapper";function sxe(e){let{components:n,...t}=e;return(0,s.yg)(rxe,(0,p.A)({},pxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}sxe.isMDXComponent=!0;const cxe={toc:[]},axe="wrapper";function ixe(e){let{components:n,...t}=e;return(0,s.yg)(axe,(0,p.A)({},cxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ixe.isMDXComponent=!0;const lxe={toc:[]},uxe="wrapper";function mxe(e){let{components:n,...t}=e;return(0,s.yg)(uxe,(0,p.A)({},lxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}mxe.isMDXComponent=!0;const yxe={toc:[]},dxe="wrapper";function hxe(e){let{components:n,...t}=e;return(0,s.yg)(dxe,(0,p.A)({},yxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}hxe.isMDXComponent=!0;const gxe={toc:[]},fxe="wrapper";function Dxe(e){let{components:n,...t}=e;return(0,s.yg)(fxe,(0,p.A)({},gxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Dxe.isMDXComponent=!0;const Mxe={toc:[]},Xxe="wrapper";function _xe(e){let{components:n,...t}=e;return(0,s.yg)(Xxe,(0,p.A)({},Mxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_xe.isMDXComponent=!0;const wxe={toc:[]},Txe="wrapper";function Cxe(e){let{components:n,...t}=e;return(0,s.yg)(Txe,(0,p.A)({},wxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Cxe.isMDXComponent=!0;const xxe={toc:[]},Axe="wrapper";function vxe(e){let{components:n,...t}=e;return(0,s.yg)(Axe,(0,p.A)({},xxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}vxe.isMDXComponent=!0;const Lxe={toc:[]},bxe="wrapper";function Nxe(e){let{components:n,...t}=e;return(0,s.yg)(bxe,(0,p.A)({},Lxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Nxe.isMDXComponent=!0;const kxe={toc:[]},zxe="wrapper";function Pxe(e){let{components:n,...t}=e;return(0,s.yg)(zxe,(0,p.A)({},kxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Pxe.isMDXComponent=!0;const Ixe={toc:[]},Rxe="wrapper";function Wxe(e){let{components:n,...t}=e;return(0,s.yg)(Rxe,(0,p.A)({},Ixe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Wxe.isMDXComponent=!0;const Sxe={toc:[]},Bxe="wrapper";function Gxe(e){let{components:n,...t}=e;return(0,s.yg)(Bxe,(0,p.A)({},Sxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Gxe.isMDXComponent=!0;const Exe={toc:[]},Oxe="wrapper";function Uxe(e){let{components:n,...t}=e;return(0,s.yg)(Oxe,(0,p.A)({},Exe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Uxe.isMDXComponent=!0;const Fxe={toc:[]},Vxe="wrapper";function qxe(e){let{components:n,...t}=e;return(0,s.yg)(Vxe,(0,p.A)({},Fxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qxe.isMDXComponent=!0;const jxe={toc:[]},Hxe="wrapper";function Yxe(e){let{components:n,...t}=e;return(0,s.yg)(Hxe,(0,p.A)({},jxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Yxe.isMDXComponent=!0;const Qxe={toc:[]},$xe="wrapper";function Kxe(e){let{components:n,...t}=e;return(0,s.yg)($xe,(0,p.A)({},Qxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Kxe.isMDXComponent=!0;const Jxe={toc:[]},Zxe="wrapper";function eAe(e){let{components:n,...t}=e;return(0,s.yg)(Zxe,(0,p.A)({},Jxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}eAe.isMDXComponent=!0;const nAe={toc:[]},tAe="wrapper";function oAe(e){let{components:n,...t}=e;return(0,s.yg)(tAe,(0,p.A)({},nAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}oAe.isMDXComponent=!0;const pAe={toc:[]},rAe="wrapper";function sAe(e){let{components:n,...t}=e;return(0,s.yg)(rAe,(0,p.A)({},pAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sAe.isMDXComponent=!0;const cAe={toc:[]},aAe="wrapper";function iAe(e){let{components:n,...t}=e;return(0,s.yg)(aAe,(0,p.A)({},cAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}iAe.isMDXComponent=!0;const lAe={toc:[]},uAe="wrapper";function mAe(e){let{components:n,...t}=e;return(0,s.yg)(uAe,(0,p.A)({},lAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}mAe.isMDXComponent=!0;const yAe={toc:[]},dAe="wrapper";function hAe(e){let{components:n,...t}=e;return(0,s.yg)(dAe,(0,p.A)({},yAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}hAe.isMDXComponent=!0;const gAe={toc:[]},fAe="wrapper";function DAe(e){let{components:n,...t}=e;return(0,s.yg)(fAe,(0,p.A)({},gAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}DAe.isMDXComponent=!0;const MAe={toc:[]},XAe="wrapper";function _Ae(e){let{components:n,...t}=e;return(0,s.yg)(XAe,(0,p.A)({},MAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}_Ae.isMDXComponent=!0;const wAe={toc:[]},TAe="wrapper";function CAe(e){let{components:n,...t}=e;return(0,s.yg)(TAe,(0,p.A)({},wAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}CAe.isMDXComponent=!0;const xAe={toc:[]},AAe="wrapper";function vAe(e){let{components:n,...t}=e;return(0,s.yg)(AAe,(0,p.A)({},xAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}vAe.isMDXComponent=!0;const LAe={toc:[]},bAe="wrapper";function NAe(e){let{components:n,...t}=e;return(0,s.yg)(bAe,(0,p.A)({},LAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}NAe.isMDXComponent=!0;const kAe={toc:[]},zAe="wrapper";function PAe(e){let{components:n,...t}=e;return(0,s.yg)(zAe,(0,p.A)({},kAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}PAe.isMDXComponent=!0;const IAe={toc:[]},RAe="wrapper";function WAe(e){let{components:n,...t}=e;return(0,s.yg)(RAe,(0,p.A)({},IAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}WAe.isMDXComponent=!0;const SAe={toc:[]},BAe="wrapper";function GAe(e){let{components:n,...t}=e;return(0,s.yg)(BAe,(0,p.A)({},SAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}GAe.isMDXComponent=!0;const EAe={toc:[]},OAe="wrapper";function UAe(e){let{components:n,...t}=e;return(0,s.yg)(OAe,(0,p.A)({},EAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}UAe.isMDXComponent=!0;const FAe={toc:[]},VAe="wrapper";function qAe(e){let{components:n,...t}=e;return(0,s.yg)(VAe,(0,p.A)({},FAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}qAe.isMDXComponent=!0;const jAe={toc:[]},HAe="wrapper";function YAe(e){let{components:n,...t}=e;return(0,s.yg)(HAe,(0,p.A)({},jAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}YAe.isMDXComponent=!0;const QAe={toc:[]},$Ae="wrapper";function KAe(e){let{components:n,...t}=e;return(0,s.yg)($Ae,(0,p.A)({},QAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}KAe.isMDXComponent=!0;const JAe={toc:[]},ZAe="wrapper";function eve(e){let{components:n,...t}=e;return(0,s.yg)(ZAe,(0,p.A)({},JAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}eve.isMDXComponent=!0;const nve={toc:[]},tve="wrapper";function ove(e){let{components:n,...t}=e;return(0,s.yg)(tve,(0,p.A)({},nve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}ove.isMDXComponent=!0;const pve={toc:[]},rve="wrapper";function sve(e){let{components:n,...t}=e;return(0,s.yg)(rve,(0,p.A)({},pve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}sve.isMDXComponent=!0;const cve={toc:[]},ave="wrapper";function ive(e){let{components:n,...t}=e;return(0,s.yg)(ave,(0,p.A)({},cve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}ive.isMDXComponent=!0;const lve={toc:[]},uve="wrapper";function mve(e){let{components:n,...t}=e;return(0,s.yg)(uve,(0,p.A)({},lve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}mve.isMDXComponent=!0;const yve={toc:[]},dve="wrapper";function hve(e){let{components:n,...t}=e;return(0,s.yg)(dve,(0,p.A)({},yve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}hve.isMDXComponent=!0;const gve={toc:[]},fve="wrapper";function Dve(e){let{components:n,...t}=e;return(0,s.yg)(fve,(0,p.A)({},gve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Dve.isMDXComponent=!0;const Mve={toc:[]},Xve="wrapper";function _ve(e){let{components:n,...t}=e;return(0,s.yg)(Xve,(0,p.A)({},Mve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}_ve.isMDXComponent=!0;const wve={toc:[]},Tve="wrapper";function Cve(e){let{components:n,...t}=e;return(0,s.yg)(Tve,(0,p.A)({},wve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Cve.isMDXComponent=!0;const xve={toc:[]},Ave="wrapper";function vve(e){let{components:n,...t}=e;return(0,s.yg)(Ave,(0,p.A)({},xve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vve.isMDXComponent=!0;const Lve={toc:[]},bve="wrapper";function Nve(e){let{components:n,...t}=e;return(0,s.yg)(bve,(0,p.A)({},Lve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Nve.isMDXComponent=!0;const kve={toc:[]},zve="wrapper";function Pve(e){let{components:n,...t}=e;return(0,s.yg)(zve,(0,p.A)({},kve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Pve.isMDXComponent=!0;const Ive={toc:[]},Rve="wrapper";function Wve(e){let{components:n,...t}=e;return(0,s.yg)(Rve,(0,p.A)({},Ive,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Wve.isMDXComponent=!0;const Sve={toc:[]},Bve="wrapper";function Gve(e){let{components:n,...t}=e;return(0,s.yg)(Bve,(0,p.A)({},Sve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Gve.isMDXComponent=!0;const Eve={toc:[]},Ove="wrapper";function Uve(e){let{components:n,...t}=e;return(0,s.yg)(Ove,(0,p.A)({},Eve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Uve.isMDXComponent=!0;const Fve={toc:[]},Vve="wrapper";function qve(e){let{components:n,...t}=e;return(0,s.yg)(Vve,(0,p.A)({},Fve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qve.isMDXComponent=!0;const jve={toc:[]},Hve="wrapper";function Yve(e){let{components:n,...t}=e;return(0,s.yg)(Hve,(0,p.A)({},jve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Yve.isMDXComponent=!0;const Qve={toc:[]},$ve="wrapper";function Kve(e){let{components:n,...t}=e;return(0,s.yg)($ve,(0,p.A)({},Qve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Kve.isMDXComponent=!0;const Jve={toc:[]},Zve="wrapper";function eLe(e){let{components:n,...t}=e;return(0,s.yg)(Zve,(0,p.A)({},Jve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}eLe.isMDXComponent=!0;const nLe={toc:[]},tLe="wrapper";function oLe(e){let{components:n,...t}=e;return(0,s.yg)(tLe,(0,p.A)({},nLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}oLe.isMDXComponent=!0;const pLe={toc:[]},rLe="wrapper";function sLe(e){let{components:n,...t}=e;return(0,s.yg)(rLe,(0,p.A)({},pLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}sLe.isMDXComponent=!0;const cLe={toc:[]},aLe="wrapper";function iLe(e){let{components:n,...t}=e;return(0,s.yg)(aLe,(0,p.A)({},cLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}iLe.isMDXComponent=!0;const lLe={toc:[]},uLe="wrapper";function mLe(e){let{components:n,...t}=e;return(0,s.yg)(uLe,(0,p.A)({},lLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}mLe.isMDXComponent=!0;const yLe={toc:[]},dLe="wrapper";function hLe(e){let{components:n,...t}=e;return(0,s.yg)(dLe,(0,p.A)({},yLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}hLe.isMDXComponent=!0;const gLe={toc:[]},fLe="wrapper";function DLe(e){let{components:n,...t}=e;return(0,s.yg)(fLe,(0,p.A)({},gLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}DLe.isMDXComponent=!0;const MLe={toc:[]},XLe="wrapper";function _Le(e){let{components:n,...t}=e;return(0,s.yg)(XLe,(0,p.A)({},MLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}_Le.isMDXComponent=!0;const wLe={toc:[]},TLe="wrapper";function CLe(e){let{components:n,...t}=e;return(0,s.yg)(TLe,(0,p.A)({},wLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}CLe.isMDXComponent=!0;const xLe={toc:[]},ALe="wrapper";function vLe(e){let{components:n,...t}=e;return(0,s.yg)(ALe,(0,p.A)({},xLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}vLe.isMDXComponent=!0;const LLe={toc:[]},bLe="wrapper";function NLe(e){let{components:n,...t}=e;return(0,s.yg)(bLe,(0,p.A)({},LLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}NLe.isMDXComponent=!0;const kLe={toc:[]},zLe="wrapper";function PLe(e){let{components:n,...t}=e;return(0,s.yg)(zLe,(0,p.A)({},kLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}PLe.isMDXComponent=!0;const ILe={toc:[]},RLe="wrapper";function WLe(e){let{components:n,...t}=e;return(0,s.yg)(RLe,(0,p.A)({},ILe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}WLe.isMDXComponent=!0;const SLe={toc:[]},BLe="wrapper";function GLe(e){let{components:n,...t}=e;return(0,s.yg)(BLe,(0,p.A)({},SLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}GLe.isMDXComponent=!0;const ELe={toc:[]},OLe="wrapper";function ULe(e){let{components:n,...t}=e;return(0,s.yg)(OLe,(0,p.A)({},ELe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ULe.isMDXComponent=!0;const FLe={toc:[]},VLe="wrapper";function qLe(e){let{components:n,...t}=e;return(0,s.yg)(VLe,(0,p.A)({},FLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qLe.isMDXComponent=!0;const jLe={toc:[]},HLe="wrapper";function YLe(e){let{components:n,...t}=e;return(0,s.yg)(HLe,(0,p.A)({},jLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}YLe.isMDXComponent=!0;const QLe={toc:[]},$Le="wrapper";function KLe(e){let{components:n,...t}=e;return(0,s.yg)($Le,(0,p.A)({},QLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}KLe.isMDXComponent=!0;const JLe={toc:[]},ZLe="wrapper";function ebe(e){let{components:n,...t}=e;return(0,s.yg)(ZLe,(0,p.A)({},JLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ebe.isMDXComponent=!0;const nbe={toc:[]},tbe="wrapper";function obe(e){let{components:n,...t}=e;return(0,s.yg)(tbe,(0,p.A)({},nbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}obe.isMDXComponent=!0;const pbe={toc:[]},rbe="wrapper";function sbe(e){let{components:n,...t}=e;return(0,s.yg)(rbe,(0,p.A)({},pbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}sbe.isMDXComponent=!0;const cbe={toc:[]},abe="wrapper";function ibe(e){let{components:n,...t}=e;return(0,s.yg)(abe,(0,p.A)({},cbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ibe.isMDXComponent=!0;const lbe={toc:[]},ube="wrapper";function mbe(e){let{components:n,...t}=e;return(0,s.yg)(ube,(0,p.A)({},lbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}mbe.isMDXComponent=!0;const ybe={toc:[]},dbe="wrapper";function hbe(e){let{components:n,...t}=e;return(0,s.yg)(dbe,(0,p.A)({},ybe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}hbe.isMDXComponent=!0;const gbe={toc:[]},fbe="wrapper";function Dbe(e){let{components:n,...t}=e;return(0,s.yg)(fbe,(0,p.A)({},gbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Dbe.isMDXComponent=!0;const Mbe={toc:[]},Xbe="wrapper";function _be(e){let{components:n,...t}=e;return(0,s.yg)(Xbe,(0,p.A)({},Mbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {parser} from '@lezer/javascript';\nimport {Code, LezerHighlighter, makeScene2D} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  LezerHighlighter.registerParser(parser);\n  const code = createRef<Code>();\n\n  view.add(\n    <Code\n      ref={code}\n      offset={-1}\n      position={view.size().scale(-0.5).add(60)}\n      fontFamily={'JetBrains Mono, monospace'}\n      fontSize={36}\n      code={`\\\nfunction hello() {\n  console.log('Hello');\n}`}\n    />,\n  );\n\n  yield* code()\n    .code(\n      `\\\nfunction hello() {\n  console.warn('Hello World');\n}`,\n      1,\n    )\n    .wait(0.5)\n    .back(1)\n    .wait(0.5);\n});\n")))}_be.isMDXComponent=!0;const wbe={toc:[]},Tbe="wrapper";function Cbe(e){let{components:n,...t}=e;return(0,s.yg)(Tbe,(0,p.A)({},wbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for displaying and animating code."))}Cbe.isMDXComponent=!0;const xbe={toc:[]},Abe="wrapper";function vbe(e){let{components:n,...t}=e;return(0,s.yg)(Abe,(0,p.A)({},xbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}vbe.isMDXComponent=!0;const Lbe={toc:[]},bbe="wrapper";function Nbe(e){let{components:n,...t}=e;return(0,s.yg)(bbe,(0,p.A)({},Lbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Nbe.isMDXComponent=!0;const kbe={toc:[]},zbe="wrapper";function Pbe(e){let{components:n,...t}=e;return(0,s.yg)(zbe,(0,p.A)({},kbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Pbe.isMDXComponent=!0;const Ibe={toc:[]},Rbe="wrapper";function Wbe(e){let{components:n,...t}=e;return(0,s.yg)(Rbe,(0,p.A)({},Ibe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Wbe.isMDXComponent=!0;const Sbe={toc:[]},Bbe="wrapper";function Gbe(e){let{components:n,...t}=e;return(0,s.yg)(Bbe,(0,p.A)({},Sbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Gbe.isMDXComponent=!0;const Ebe={toc:[]},Obe="wrapper";function Ube(e){let{components:n,...t}=e;return(0,s.yg)(Obe,(0,p.A)({},Ebe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Ube.isMDXComponent=!0;const Fbe={toc:[]},Vbe="wrapper";function qbe(e){let{components:n,...t}=e;return(0,s.yg)(Vbe,(0,p.A)({},Fbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qbe.isMDXComponent=!0;const jbe={toc:[]},Hbe="wrapper";function Ybe(e){let{components:n,...t}=e;return(0,s.yg)(Hbe,(0,p.A)({},jbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Ybe.isMDXComponent=!0;const Qbe={toc:[]},$be="wrapper";function Kbe(e){let{components:n,...t}=e;return(0,s.yg)($be,(0,p.A)({},Qbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Kbe.isMDXComponent=!0;const Jbe={toc:[]},Zbe="wrapper";function eNe(e){let{components:n,...t}=e;return(0,s.yg)(Zbe,(0,p.A)({},Jbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}eNe.isMDXComponent=!0;const nNe={toc:[]},tNe="wrapper";function oNe(e){let{components:n,...t}=e;return(0,s.yg)(tNe,(0,p.A)({},nNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}oNe.isMDXComponent=!0;const pNe={toc:[]},rNe="wrapper";function sNe(e){let{components:n,...t}=e;return(0,s.yg)(rNe,(0,p.A)({},pNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}sNe.isMDXComponent=!0;const cNe={toc:[]},aNe="wrapper";function iNe(e){let{components:n,...t}=e;return(0,s.yg)(aNe,(0,p.A)({},cNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}iNe.isMDXComponent=!0;const lNe={toc:[]},uNe="wrapper";function mNe(e){let{components:n,...t}=e;return(0,s.yg)(uNe,(0,p.A)({},lNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}mNe.isMDXComponent=!0;const yNe={toc:[]},dNe="wrapper";function hNe(e){let{components:n,...t}=e;return(0,s.yg)(dNe,(0,p.A)({},yNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to display."))}hNe.isMDXComponent=!0;const gNe={toc:[]},fNe="wrapper";function DNe(e){let{components:n,...t}=e;return(0,s.yg)(fNe,(0,p.A)({},gNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This value will be passed to the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeHighlighter")),"\ndefined by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#highlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"highlighter"))," property. Different highlighters may use\nit differently."),(0,s.yg)("p",null,"The default ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter"))," uses it to select\nthe language parser to use. The parser for the given dialect can be\nregistered as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// Import the lezer parser:\nimport {parser} from '@lezer/javascript';\n\n// Register it in the highlighter:\nLezerHighlighter.registerParser(parser, 'js');\n\n// Use the dialect in a code node:\n<Code dialect=\"js\" code=\"const a = 7;\" />\n")),(0,s.yg)("p",null,"When no dialect is provided, the highlighter will use the default\nparser:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'// Register the default parser by omitting the dialect:\nLezerHighlighter.registerParser(parser);\n\n// Code nodes with no dialect will now use the default parser:\n<Code code="const a = 7;" />\n')))}DNe.isMDXComponent=!0;const MNe={toc:[]},XNe="wrapper";function _Ne(e){let{components:n,...t}=e;return(0,s.yg)(XNe,(0,p.A)({},MNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The dialect to use for highlighting the code."))}_Ne.isMDXComponent=!0;const wNe={toc:[]},TNe="wrapper";function CNe(e){let{components:n,...t}=e;return(0,s.yg)(TNe,(0,p.A)({},wNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check out ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.yg)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}CNe.isMDXComponent=!0;const xNe={toc:[]},ANe="wrapper";function vNe(e){let{components:n,...t}=e;return(0,s.yg)(ANe,(0,p.A)({},xNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Make the unselected code blurry and transparent:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  drawHooks={{\n    token(ctx, text, position, color, selection) {\n      const blur = map(3, 0, selection);\n      const alpha = map(0.5, 1, selection);\n      ctx.globalAlpha *= alpha;\n      ctx.filter = `blur(${blur}px)`;\n      ctx.fillStyle = color;\n      ctx.fillText(text, position.x, position.y);\n    },\n  }}\n  // ...\n/>\n")))}vNe.isMDXComponent=!0;const LNe={toc:[]},bNe="wrapper";function NNe(e){let{components:n,...t}=e;return(0,s.yg)(bNe,(0,p.A)({},LNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for the code."))}NNe.isMDXComponent=!0;const kNe={toc:[]},zNe="wrapper";function PNe(e){let{components:n,...t}=e;return(0,s.yg)(zNe,(0,p.A)({},kNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defaults to a shared ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}PNe.isMDXComponent=!0;const INe={toc:[]},RNe="wrapper";function WNe(e){let{components:n,...t}=e;return(0,s.yg)(RNe,(0,p.A)({},INe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code highlighter to use for this code node."))}WNe.isMDXComponent=!0;const SNe={toc:[]},BNe="wrapper";function GNe(e){let{components:n,...t}=e;return(0,s.yg)(BNe,(0,p.A)({},SNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}GNe.isMDXComponent=!0;const ENe={toc:[]},ONe="wrapper";function UNe(e){let{components:n,...t}=e;return(0,s.yg)(ONe,(0,p.A)({},ENe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}UNe.isMDXComponent=!0;const FNe={toc:[]},VNe="wrapper";function qNe(e){let{components:n,...t}=e;return(0,s.yg)(VNe,(0,p.A)({},FNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}qNe.isMDXComponent=!0;const jNe={toc:[]},HNe="wrapper";function YNe(e){let{components:n,...t}=e;return(0,s.yg)(HNe,(0,p.A)({},jNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}YNe.isMDXComponent=!0;const QNe={toc:[]},$Ne="wrapper";function KNe(e){let{components:n,...t}=e;return(0,s.yg)($Ne,(0,p.A)({},QNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}KNe.isMDXComponent=!0;const JNe={toc:[]},ZNe="wrapper";function eke(e){let{components:n,...t}=e;return(0,s.yg)(ZNe,(0,p.A)({},JNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}eke.isMDXComponent=!0;const nke={toc:[]},tke="wrapper";function oke(e){let{components:n,...t}=e;return(0,s.yg)(tke,(0,p.A)({},nke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}oke.isMDXComponent=!0;const pke={toc:[]},rke="wrapper";function ske(e){let{components:n,...t}=e;return(0,s.yg)(rke,(0,p.A)({},pke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}ske.isMDXComponent=!0;const cke={toc:[]},ake="wrapper";function ike(e){let{components:n,...t}=e;return(0,s.yg)(ake,(0,p.A)({},cke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ike.isMDXComponent=!0;const lke={toc:[]},uke="wrapper";function mke(e){let{components:n,...t}=e;return(0,s.yg)(uke,(0,p.A)({},lke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}mke.isMDXComponent=!0;const yke={toc:[]},dke="wrapper";function hke(e){let{components:n,...t}=e;return(0,s.yg)(dke,(0,p.A)({},yke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}hke.isMDXComponent=!0;const gke={toc:[]},fke="wrapper";function Dke(e){let{components:n,...t}=e;return(0,s.yg)(fke,(0,p.A)({},gke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Dke.isMDXComponent=!0;const Mke={toc:[]},Xke="wrapper";function _ke(e){let{components:n,...t}=e;return(0,s.yg)(Xke,(0,p.A)({},Mke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}_ke.isMDXComponent=!0;const wke={toc:[]},Tke="wrapper";function Cke(e){let{components:n,...t}=e;return(0,s.yg)(Tke,(0,p.A)({},wke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Cke.isMDXComponent=!0;const xke={toc:[]},Ake="wrapper";function vke(e){let{components:n,...t}=e;return(0,s.yg)(Ake,(0,p.A)({},xke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}vke.isMDXComponent=!0;const Lke={toc:[]},bke="wrapper";function Nke(e){let{components:n,...t}=e;return(0,s.yg)(bke,(0,p.A)({},Lke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a single ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.yg)("p",null,"You can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.yg)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.yg)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}Nke.isMDXComponent=!0;const kke={toc:[]},zke="wrapper";function Pke(e){let{components:n,...t}=e;return(0,s.yg)(zke,(0,p.A)({},kke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,'The following will select the word "console" in the code.\nBoth lines and columns are 0-based. So it will select a 7-character-long\n(',(0,s.yg)("inlineCode",{parentName:"p"},"7"),") word in the second line (",(0,s.yg)("inlineCode",{parentName:"p"},"1"),") starting at the third character (",(0,s.yg)("inlineCode",{parentName:"p"},"2"),")."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  selection={word(1, 2, 7)}\n  code={`\\\nfunction hello() => {\n  console.log('Hello');\n}`}\n  // ...\n/>\n")))}Pke.isMDXComponent=!0;const Ike={toc:[]},Rke="wrapper";function Wke(e){let{components:n,...t}=e;return(0,s.yg)(Rke,(0,p.A)({},Ike,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The currently selected code range."))}Wke.isMDXComponent=!0;const Ske={toc:[]},Bke="wrapper";function Gke(e){let{components:n,...t}=e;return(0,s.yg)(Bke,(0,p.A)({},Ske,t,{components:n,mdxType:"MDXLayout"}))}Gke.isMDXComponent=!0;const Eke={toc:[]},Oke="wrapper";function Uke(e){let{components:n,...t}=e;return(0,s.yg)(Oke,(0,p.A)({},Eke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Uke.isMDXComponent=!0;const Fke={toc:[]},Vke="wrapper";function qke(e){let{components:n,...t}=e;return(0,s.yg)(Vke,(0,p.A)({},Fke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qke.isMDXComponent=!0;const jke={toc:[]},Hke="wrapper";function Yke(e){let{components:n,...t}=e;return(0,s.yg)(Hke,(0,p.A)({},jke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Yke.isMDXComponent=!0;const Qke={toc:[]},$ke="wrapper";function Kke(e){let{components:n,...t}=e;return(0,s.yg)($ke,(0,p.A)({},Qke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Kke.isMDXComponent=!0;const Jke={toc:[]},Zke="wrapper";function eze(e){let{components:n,...t}=e;return(0,s.yg)(Zke,(0,p.A)({},Jke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}eze.isMDXComponent=!0;const nze={toc:[]},tze="wrapper";function oze(e){let{components:n,...t}=e;return(0,s.yg)(tze,(0,p.A)({},nze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}oze.isMDXComponent=!0;const pze={toc:[]},rze="wrapper";function sze(e){let{components:n,...t}=e;return(0,s.yg)(rze,(0,p.A)({},pze,t,{components:n,mdxType:"MDXLayout"}))}sze.isMDXComponent=!0;const cze={toc:[]},aze="wrapper";function ize(e){let{components:n,...t}=e;return(0,s.yg)(aze,(0,p.A)({},cze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ize.isMDXComponent=!0;const lze={toc:[]},uze="wrapper";function mze(e){let{components:n,...t}=e;return(0,s.yg)(uze,(0,p.A)({},lze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}mze.isMDXComponent=!0;const yze={toc:[]},dze="wrapper";function hze(e){let{components:n,...t}=e;return(0,s.yg)(dze,(0,p.A)({},yze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}hze.isMDXComponent=!0;const gze={toc:[]},fze="wrapper";function Dze(e){let{components:n,...t}=e;return(0,s.yg)(fze,(0,p.A)({},gze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Dze.isMDXComponent=!0;const Mze={toc:[]},Xze="wrapper";function _ze(e){let{components:n,...t}=e;return(0,s.yg)(Xze,(0,p.A)({},Mze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_ze.isMDXComponent=!0;const wze={toc:[]},Tze="wrapper";function Cze(e){let{components:n,...t}=e;return(0,s.yg)(Tze,(0,p.A)({},wze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Cze.isMDXComponent=!0;const xze={toc:[]},Aze="wrapper";function vze(e){let{components:n,...t}=e;return(0,s.yg)(Aze,(0,p.A)({},xze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}vze.isMDXComponent=!0;const Lze={toc:[]},bze="wrapper";function Nze(e){let{components:n,...t}=e;return(0,s.yg)(bze,(0,p.A)({},Lze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Nze.isMDXComponent=!0;const kze={toc:[]},zze="wrapper";function Pze(e){let{components:n,...t}=e;return(0,s.yg)(zze,(0,p.A)({},kze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Pze.isMDXComponent=!0;const Ize={toc:[]},Rze="wrapper";function Wze(e){let{components:n,...t}=e;return(0,s.yg)(Rze,(0,p.A)({},Ize,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Wze.isMDXComponent=!0;const Sze={toc:[]},Bze="wrapper";function Gze(e){let{components:n,...t}=e;return(0,s.yg)(Bze,(0,p.A)({},Sze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Gze.isMDXComponent=!0;const Eze={toc:[]},Oze="wrapper";function Uze(e){let{components:n,...t}=e;return(0,s.yg)(Oze,(0,p.A)({},Eze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Uze.isMDXComponent=!0;const Fze={toc:[]},Vze="wrapper";function qze(e){let{components:n,...t}=e;return(0,s.yg)(Vze,(0,p.A)({},Fze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}qze.isMDXComponent=!0;const jze={toc:[]},Hze="wrapper";function Yze(e){let{components:n,...t}=e;return(0,s.yg)(Hze,(0,p.A)({},jze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Yze.isMDXComponent=!0;const Qze={toc:[]},$ze="wrapper";function Kze(e){let{components:n,...t}=e;return(0,s.yg)($ze,(0,p.A)({},Qze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Kze.isMDXComponent=!0;const Jze={toc:[]},Zze="wrapper";function ePe(e){let{components:n,...t}=e;return(0,s.yg)(Zze,(0,p.A)({},Jze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}ePe.isMDXComponent=!0;const nPe={toc:[]},tPe="wrapper";function oPe(e){let{components:n,...t}=e;return(0,s.yg)(tPe,(0,p.A)({},nPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}oPe.isMDXComponent=!0;const pPe={toc:[]},rPe="wrapper";function sPe(e){let{components:n,...t}=e;return(0,s.yg)(rPe,(0,p.A)({},pPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sPe.isMDXComponent=!0;const cPe={toc:[]},aPe="wrapper";function iPe(e){let{components:n,...t}=e;return(0,s.yg)(aPe,(0,p.A)({},cPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}iPe.isMDXComponent=!0;const lPe={toc:[]},uPe="wrapper";function mPe(e){let{components:n,...t}=e;return(0,s.yg)(uPe,(0,p.A)({},lPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}mPe.isMDXComponent=!0;const yPe={toc:[]},dPe="wrapper";function hPe(e){let{components:n,...t}=e;return(0,s.yg)(dPe,(0,p.A)({},yPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}hPe.isMDXComponent=!0;const gPe={toc:[]},fPe="wrapper";function DPe(e){let{components:n,...t}=e;return(0,s.yg)(fPe,(0,p.A)({},gPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}DPe.isMDXComponent=!0;const MPe={toc:[]},XPe="wrapper";function _Pe(e){let{components:n,...t}=e;return(0,s.yg)(XPe,(0,p.A)({},MPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}_Pe.isMDXComponent=!0;const wPe={toc:[]},TPe="wrapper";function CPe(e){let{components:n,...t}=e;return(0,s.yg)(TPe,(0,p.A)({},wPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}CPe.isMDXComponent=!0;const xPe={toc:[]},APe="wrapper";function vPe(e){let{components:n,...t}=e;return(0,s.yg)(APe,(0,p.A)({},xPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}vPe.isMDXComponent=!0;const LPe={toc:[]},bPe="wrapper";function NPe(e){let{components:n,...t}=e;return(0,s.yg)(bPe,(0,p.A)({},LPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}NPe.isMDXComponent=!0;const kPe={toc:[]},zPe="wrapper";function PPe(e){let{components:n,...t}=e;return(0,s.yg)(zPe,(0,p.A)({},kPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a child code signal."))}PPe.isMDXComponent=!0;const IPe={toc:[]},RPe="wrapper";function WPe(e){let{components:n,...t}=e;return(0,s.yg)(RPe,(0,p.A)({},IPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial code."))}WPe.isMDXComponent=!0;const SPe={toc:[]},BPe="wrapper";function GPe(e){let{components:n,...t}=e;return(0,s.yg)(BPe,(0,p.A)({},SPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}GPe.isMDXComponent=!0;const EPe={toc:[]},OPe="wrapper";function UPe(e){let{components:n,...t}=e;return(0,s.yg)(OPe,(0,p.A)({},EPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}UPe.isMDXComponent=!0;const FPe={toc:[]},VPe="wrapper";function qPe(e){let{components:n,...t}=e;return(0,s.yg)(VPe,(0,p.A)({},FPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qPe.isMDXComponent=!0;const jPe={toc:[]},HPe="wrapper";function YPe(e){let{components:n,...t}=e;return(0,s.yg)(HPe,(0,p.A)({},jPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}YPe.isMDXComponent=!0;const QPe={toc:[]},$Pe="wrapper";function KPe(e){let{components:n,...t}=e;return(0,s.yg)($Pe,(0,p.A)({},QPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}KPe.isMDXComponent=!0;const JPe={toc:[]},ZPe="wrapper";function eIe(e){let{components:n,...t}=e;return(0,s.yg)(ZPe,(0,p.A)({},JPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}eIe.isMDXComponent=!0;const nIe={toc:[]},tIe="wrapper";function oIe(e){let{components:n,...t}=e;return(0,s.yg)(tIe,(0,p.A)({},nIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}oIe.isMDXComponent=!0;const pIe={toc:[]},rIe="wrapper";function sIe(e){let{components:n,...t}=e;return(0,s.yg)(rIe,(0,p.A)({},pIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sIe.isMDXComponent=!0;const cIe={toc:[]},aIe="wrapper";function iIe(e){let{components:n,...t}=e;return(0,s.yg)(aIe,(0,p.A)({},cIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}iIe.isMDXComponent=!0;const lIe={toc:[]},uIe="wrapper";function mIe(e){let{components:n,...t}=e;return(0,s.yg)(uIe,(0,p.A)({},lIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}mIe.isMDXComponent=!0;const yIe={toc:[]},dIe="wrapper";function hIe(e){let{components:n,...t}=e;return(0,s.yg)(dIe,(0,p.A)({},yIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}hIe.isMDXComponent=!0;const gIe={toc:[]},fIe="wrapper";function DIe(e){let{components:n,...t}=e;return(0,s.yg)(fIe,(0,p.A)({},gIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}DIe.isMDXComponent=!0;const MIe={toc:[]},XIe="wrapper";function _Ie(e){let{components:n,...t}=e;return(0,s.yg)(XIe,(0,p.A)({},MIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_Ie.isMDXComponent=!0;const wIe={toc:[]},TIe="wrapper";function CIe(e){let{components:n,...t}=e;return(0,s.yg)(TIe,(0,p.A)({},wIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}CIe.isMDXComponent=!0;const xIe={toc:[]},AIe="wrapper";function vIe(e){let{components:n,...t}=e;return(0,s.yg)(AIe,(0,p.A)({},xIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vIe.isMDXComponent=!0;const LIe={toc:[]},bIe="wrapper";function NIe(e){let{components:n,...t}=e;return(0,s.yg)(bIe,(0,p.A)({},LIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all code ranges that match the given pattern."))}NIe.isMDXComponent=!0;const kIe={toc:[]},zIe="wrapper";function PIe(e){let{components:n,...t}=e;return(0,s.yg)(zIe,(0,p.A)({},kIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}PIe.isMDXComponent=!0;const IIe={toc:[]},RIe="wrapper";function WIe(e){let{components:n,...t}=e;return(0,s.yg)(RIe,(0,p.A)({},IIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}WIe.isMDXComponent=!0;const SIe={toc:[]},BIe="wrapper";function GIe(e){let{components:n,...t}=e;return(0,s.yg)(BIe,(0,p.A)({},SIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GIe.isMDXComponent=!0;const EIe={toc:[]},OIe="wrapper";function UIe(e){let{components:n,...t}=e;return(0,s.yg)(OIe,(0,p.A)({},EIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}UIe.isMDXComponent=!0;const FIe={toc:[]},VIe="wrapper";function qIe(e){let{components:n,...t}=e;return(0,s.yg)(VIe,(0,p.A)({},FIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qIe.isMDXComponent=!0;const jIe={toc:[]},HIe="wrapper";function YIe(e){let{components:n,...t}=e;return(0,s.yg)(HIe,(0,p.A)({},jIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}YIe.isMDXComponent=!0;const QIe={toc:[]},$Ie="wrapper";function KIe(e){let{components:n,...t}=e;return(0,s.yg)($Ie,(0,p.A)({},QIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}KIe.isMDXComponent=!0;const JIe={toc:[]},ZIe="wrapper";function eRe(e){let{components:n,...t}=e;return(0,s.yg)(ZIe,(0,p.A)({},JIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}eRe.isMDXComponent=!0;const nRe={toc:[]},tRe="wrapper";function oRe(e){let{components:n,...t}=e;return(0,s.yg)(tRe,(0,p.A)({},nRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oRe.isMDXComponent=!0;const pRe={toc:[]},rRe="wrapper";function sRe(e){let{components:n,...t}=e;return(0,s.yg)(rRe,(0,p.A)({},pRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first code range that matches the given pattern."))}sRe.isMDXComponent=!0;const cRe={toc:[]},aRe="wrapper";function iRe(e){let{components:n,...t}=e;return(0,s.yg)(aRe,(0,p.A)({},cRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}iRe.isMDXComponent=!0;const lRe={toc:[]},uRe="wrapper";function mRe(e){let{components:n,...t}=e;return(0,s.yg)(uRe,(0,p.A)({},lRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}mRe.isMDXComponent=!0;const yRe={toc:[]},dRe="wrapper";function hRe(e){let{components:n,...t}=e;return(0,s.yg)(dRe,(0,p.A)({},yRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hRe.isMDXComponent=!0;const gRe={toc:[]},fRe="wrapper";function DRe(e){let{components:n,...t}=e;return(0,s.yg)(fRe,(0,p.A)({},gRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}DRe.isMDXComponent=!0;const MRe={toc:[]},XRe="wrapper";function _Re(e){let{components:n,...t}=e;return(0,s.yg)(XRe,(0,p.A)({},MRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_Re.isMDXComponent=!0;const wRe={toc:[]},TRe="wrapper";function CRe(e){let{components:n,...t}=e;return(0,s.yg)(TRe,(0,p.A)({},wRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last code range that matches the given pattern."))}CRe.isMDXComponent=!0;const xRe={toc:[]},ARe="wrapper";function vRe(e){let{components:n,...t}=e;return(0,s.yg)(ARe,(0,p.A)({},xRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}vRe.isMDXComponent=!0;const LRe={toc:[]},bRe="wrapper";function NRe(e){let{components:n,...t}=e;return(0,s.yg)(bRe,(0,p.A)({},LRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}NRe.isMDXComponent=!0;const kRe={toc:[]},zRe="wrapper";function PRe(e){let{components:n,...t}=e;return(0,s.yg)(zRe,(0,p.A)({},kRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}PRe.isMDXComponent=!0;const IRe={toc:[]},RRe="wrapper";function WRe(e){let{components:n,...t}=e;return(0,s.yg)(RRe,(0,p.A)({},IRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}WRe.isMDXComponent=!0;const SRe={toc:[]},BRe="wrapper";function GRe(e){let{components:n,...t}=e;return(0,s.yg)(BRe,(0,p.A)({},SRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}GRe.isMDXComponent=!0;const ERe={toc:[]},ORe="wrapper";function URe(e){let{components:n,...t}=e;return(0,s.yg)(ORe,(0,p.A)({},ERe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bound box is in local space of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Code")," node."))}URe.isMDXComponent=!0;const FRe={toc:[]},VRe="wrapper";function qRe(e){let{components:n,...t}=e;return(0,s.yg)(VRe,(0,p.A)({},FRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the bounding box of the given point (character) in the code."))}qRe.isMDXComponent=!0;const jRe={toc:[]},HRe="wrapper";function YRe(e){let{components:n,...t}=e;return(0,s.yg)(HRe,(0,p.A)({},jRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The point to get the bounding box for."))}YRe.isMDXComponent=!0;const QRe={toc:[]},$Re="wrapper";function KRe(e){let{components:n,...t}=e;return(0,s.yg)($Re,(0,p.A)({},QRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bound boxes are in local space of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Code")," node.\nEach line of code has a separate bounding box."))}KRe.isMDXComponent=!0;const JRe={toc:[]},ZRe="wrapper";function eWe(e){let{components:n,...t}=e;return(0,s.yg)(ZRe,(0,p.A)({},JRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return bounding boxes of all characters in the selection."))}eWe.isMDXComponent=!0;const nWe={toc:[]},tWe="wrapper";function oWe(e){let{components:n,...t}=e;return(0,s.yg)(tWe,(0,p.A)({},nWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The selection to get the bounding boxes for."))}oWe.isMDXComponent=!0;const pWe={toc:[]},rWe="wrapper";function sWe(e){let{components:n,...t}=e;return(0,s.yg)(rWe,(0,p.A)({},pWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}sWe.isMDXComponent=!0;const cWe={toc:[]},aWe="wrapper";function iWe(e){let{components:n,...t}=e;return(0,s.yg)(aWe,(0,p.A)({},cWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}iWe.isMDXComponent=!0;const lWe={toc:[]},uWe="wrapper";function mWe(e){let{components:n,...t}=e;return(0,s.yg)(uWe,(0,p.A)({},lWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}mWe.isMDXComponent=!0;const yWe={toc:[]},dWe="wrapper";function hWe(e){let{components:n,...t}=e;return(0,s.yg)(dWe,(0,p.A)({},yWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}hWe.isMDXComponent=!0;const gWe={toc:[]},fWe="wrapper";function DWe(e){let{components:n,...t}=e;return(0,s.yg)(fWe,(0,p.A)({},gWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}DWe.isMDXComponent=!0;const MWe={toc:[]},XWe="wrapper";function _We(e){let{components:n,...t}=e;return(0,s.yg)(XWe,(0,p.A)({},MWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}_We.isMDXComponent=!0;const wWe={toc:[]},TWe="wrapper";function CWe(e){let{components:n,...t}=e;return(0,s.yg)(TWe,(0,p.A)({},wWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}CWe.isMDXComponent=!0;const xWe={toc:[]},AWe="wrapper";function vWe(e){let{components:n,...t}=e;return(0,s.yg)(AWe,(0,p.A)({},xWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}vWe.isMDXComponent=!0;const LWe={toc:[]},bWe="wrapper";function NWe(e){let{components:n,...t}=e;return(0,s.yg)(bWe,(0,p.A)({},LWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}NWe.isMDXComponent=!0;const kWe={toc:[]},zWe="wrapper";function PWe(e){let{components:n,...t}=e;return(0,s.yg)(zWe,(0,p.A)({},kWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}PWe.isMDXComponent=!0;const IWe={toc:[]},RWe="wrapper";function WWe(e){let{components:n,...t}=e;return(0,s.yg)(RWe,(0,p.A)({},IWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}WWe.isMDXComponent=!0;const SWe={toc:[]},BWe="wrapper";function GWe(e){let{components:n,...t}=e;return(0,s.yg)(BWe,(0,p.A)({},SWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}GWe.isMDXComponent=!0;const EWe={toc:[]},OWe="wrapper";function UWe(e){let{components:n,...t}=e;return(0,s.yg)(OWe,(0,p.A)({},EWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}UWe.isMDXComponent=!0;const FWe={toc:[]},VWe="wrapper";function qWe(e){let{components:n,...t}=e;return(0,s.yg)(VWe,(0,p.A)({},FWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}qWe.isMDXComponent=!0;const jWe={toc:[]},HWe="wrapper";function YWe(e){let{components:n,...t}=e;return(0,s.yg)(HWe,(0,p.A)({},jWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}YWe.isMDXComponent=!0;const QWe={toc:[]},$We="wrapper";function KWe(e){let{components:n,...t}=e;return(0,s.yg)($We,(0,p.A)({},QWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}KWe.isMDXComponent=!0;const JWe={toc:[]},ZWe="wrapper";function eSe(e){let{components:n,...t}=e;return(0,s.yg)(ZWe,(0,p.A)({},JWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}eSe.isMDXComponent=!0;const nSe={toc:[]},tSe="wrapper";function oSe(e){let{components:n,...t}=e;return(0,s.yg)(tSe,(0,p.A)({},nSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}oSe.isMDXComponent=!0;const pSe={toc:[]},rSe="wrapper";function sSe(e){let{components:n,...t}=e;return(0,s.yg)(rSe,(0,p.A)({},pSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}sSe.isMDXComponent=!0;const cSe={toc:[]},aSe="wrapper";function iSe(e){let{components:n,...t}=e;return(0,s.yg)(aSe,(0,p.A)({},cSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}iSe.isMDXComponent=!0;const lSe={toc:[]},uSe="wrapper";function mSe(e){let{components:n,...t}=e;return(0,s.yg)(uSe,(0,p.A)({},lSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mSe.isMDXComponent=!0;const ySe={toc:[]},dSe="wrapper";function hSe(e){let{components:n,...t}=e;return(0,s.yg)(dSe,(0,p.A)({},ySe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}hSe.isMDXComponent=!0;const gSe={toc:[]},fSe="wrapper";function DSe(e){let{components:n,...t}=e;return(0,s.yg)(fSe,(0,p.A)({},gSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}DSe.isMDXComponent=!0;const MSe={toc:[]},XSe="wrapper";function _Se(e){let{components:n,...t}=e;return(0,s.yg)(XSe,(0,p.A)({},MSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_Se.isMDXComponent=!0;const wSe={toc:[]},TSe="wrapper";function CSe(e){let{components:n,...t}=e;return(0,s.yg)(TSe,(0,p.A)({},wSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}CSe.isMDXComponent=!0;const xSe={toc:[]},ASe="wrapper";function vSe(e){let{components:n,...t}=e;return(0,s.yg)(ASe,(0,p.A)({},xSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}vSe.isMDXComponent=!0;const LSe={toc:[]},bSe="wrapper";function NSe(e){let{components:n,...t}=e;return(0,s.yg)(bSe,(0,p.A)({},LSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}NSe.isMDXComponent=!0;const kSe={toc:[]},zSe="wrapper";function PSe(e){let{components:n,...t}=e;return(0,s.yg)(zSe,(0,p.A)({},kSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}PSe.isMDXComponent=!0;const ISe={toc:[]},RSe="wrapper";function WSe(e){let{components:n,...t}=e;return(0,s.yg)(RSe,(0,p.A)({},ISe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}WSe.isMDXComponent=!0;const SSe={toc:[]},BSe="wrapper";function GSe(e){let{components:n,...t}=e;return(0,s.yg)(BSe,(0,p.A)({},SSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}GSe.isMDXComponent=!0;const ESe={toc:[]},OSe="wrapper";function USe(e){let{components:n,...t}=e;return(0,s.yg)(OSe,(0,p.A)({},ESe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}USe.isMDXComponent=!0;const FSe={toc:[]},VSe="wrapper";function qSe(e){let{components:n,...t}=e;return(0,s.yg)(VSe,(0,p.A)({},FSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}qSe.isMDXComponent=!0;const jSe={toc:[]},HSe="wrapper";function YSe(e){let{components:n,...t}=e;return(0,s.yg)(HSe,(0,p.A)({},jSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}YSe.isMDXComponent=!0;const QSe={toc:[]},$Se="wrapper";function KSe(e){let{components:n,...t}=e;return(0,s.yg)($Se,(0,p.A)({},QSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}KSe.isMDXComponent=!0;const JSe={toc:[]},ZSe="wrapper";function eBe(e){let{components:n,...t}=e;return(0,s.yg)(ZSe,(0,p.A)({},JSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}eBe.isMDXComponent=!0;const nBe={toc:[]},tBe="wrapper";function oBe(e){let{components:n,...t}=e;return(0,s.yg)(tBe,(0,p.A)({},nBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}oBe.isMDXComponent=!0;const pBe={toc:[]},rBe="wrapper";function sBe(e){let{components:n,...t}=e;return(0,s.yg)(rBe,(0,p.A)({},pBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}sBe.isMDXComponent=!0;const cBe={toc:[]},aBe="wrapper";function iBe(e){let{components:n,...t}=e;return(0,s.yg)(aBe,(0,p.A)({},cBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}iBe.isMDXComponent=!0;const lBe={toc:[]},uBe="wrapper";function mBe(e){let{components:n,...t}=e;return(0,s.yg)(uBe,(0,p.A)({},lBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}mBe.isMDXComponent=!0;const yBe={toc:[]},dBe="wrapper";function hBe(e){let{components:n,...t}=e;return(0,s.yg)(dBe,(0,p.A)({},yBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hBe.isMDXComponent=!0;const gBe={toc:[]},fBe="wrapper";function DBe(e){let{components:n,...t}=e;return(0,s.yg)(fBe,(0,p.A)({},gBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}DBe.isMDXComponent=!0;const MBe={toc:[]},XBe="wrapper";function _Be(e){let{components:n,...t}=e;return(0,s.yg)(XBe,(0,p.A)({},MBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}_Be.isMDXComponent=!0;const wBe={toc:[]},TBe="wrapper";function CBe(e){let{components:n,...t}=e;return(0,s.yg)(TBe,(0,p.A)({},wBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}CBe.isMDXComponent=!0;const xBe={toc:[]},ABe="wrapper";function vBe(e){let{components:n,...t}=e;return(0,s.yg)(ABe,(0,p.A)({},xBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}vBe.isMDXComponent=!0;const LBe={toc:[]},bBe="wrapper";function NBe(e){let{components:n,...t}=e;return(0,s.yg)(bBe,(0,p.A)({},LBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the currently displayed code as a string."))}NBe.isMDXComponent=!0;const kBe={toc:[]},zBe="wrapper";function PBe(e){let{components:n,...t}=e;return(0,s.yg)(zBe,(0,p.A)({},kBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}PBe.isMDXComponent=!0;const IBe={toc:[]},RBe="wrapper";function WBe(e){let{components:n,...t}=e;return(0,s.yg)(RBe,(0,p.A)({},IBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}WBe.isMDXComponent=!0;const SBe={toc:[]},BBe="wrapper";function GBe(e){let{components:n,...t}=e;return(0,s.yg)(BBe,(0,p.A)({},SBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}GBe.isMDXComponent=!0;const EBe={toc:[]},OBe="wrapper";function UBe(e){let{components:n,...t}=e;return(0,s.yg)(OBe,(0,p.A)({},EBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}UBe.isMDXComponent=!0;const FBe={toc:[]},VBe="wrapper";function qBe(e){let{components:n,...t}=e;return(0,s.yg)(VBe,(0,p.A)({},FBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}qBe.isMDXComponent=!0;const jBe={toc:[]},HBe="wrapper";function YBe(e){let{components:n,...t}=e;return(0,s.yg)(HBe,(0,p.A)({},jBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}YBe.isMDXComponent=!0;const QBe={toc:[]},$Be="wrapper";function KBe(e){let{components:n,...t}=e;return(0,s.yg)($Be,(0,p.A)({},QBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}KBe.isMDXComponent=!0;const JBe={toc:[]},ZBe="wrapper";function eGe(e){let{components:n,...t}=e;return(0,s.yg)(ZBe,(0,p.A)({},JBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}eGe.isMDXComponent=!0;const nGe={toc:[]},tGe="wrapper";function oGe(e){let{components:n,...t}=e;return(0,s.yg)(tGe,(0,p.A)({},nGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}oGe.isMDXComponent=!0;const pGe={toc:[]},rGe="wrapper";function sGe(e){let{components:n,...t}=e;return(0,s.yg)(rGe,(0,p.A)({},pGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}sGe.isMDXComponent=!0;const cGe={toc:[]},aGe="wrapper";function iGe(e){let{components:n,...t}=e;return(0,s.yg)(aGe,(0,p.A)({},cGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}iGe.isMDXComponent=!0;const lGe={toc:[]},uGe="wrapper";function mGe(e){let{components:n,...t}=e;return(0,s.yg)(uGe,(0,p.A)({},lGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}mGe.isMDXComponent=!0;const yGe={toc:[]},dGe="wrapper";function hGe(e){let{components:n,...t}=e;return(0,s.yg)(dGe,(0,p.A)({},yGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}hGe.isMDXComponent=!0;const gGe={toc:[]},fGe="wrapper";function DGe(e){let{components:n,...t}=e;return(0,s.yg)(fGe,(0,p.A)({},gGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}DGe.isMDXComponent=!0;const MGe={toc:[]},XGe="wrapper";function _Ge(e){let{components:n,...t}=e;return(0,s.yg)(XGe,(0,p.A)({},MGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}_Ge.isMDXComponent=!0;const wGe={toc:[]},TGe="wrapper";function CGe(e){let{components:n,...t}=e;return(0,s.yg)(TGe,(0,p.A)({},wGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}CGe.isMDXComponent=!0;const xGe={toc:[]},AGe="wrapper";function vGe(e){let{components:n,...t}=e;return(0,s.yg)(AGe,(0,p.A)({},xGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}vGe.isMDXComponent=!0;const LGe={toc:[]},bGe="wrapper";function NGe(e){let{components:n,...t}=e;return(0,s.yg)(bGe,(0,p.A)({},LGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}NGe.isMDXComponent=!0;const kGe={toc:[]},zGe="wrapper";function PGe(e){let{components:n,...t}=e;return(0,s.yg)(zGe,(0,p.A)({},kGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}PGe.isMDXComponent=!0;const IGe={toc:[]},RGe="wrapper";function WGe(e){let{components:n,...t}=e;return(0,s.yg)(RGe,(0,p.A)({},IGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}WGe.isMDXComponent=!0;const SGe={toc:[]},BGe="wrapper";function GGe(e){let{components:n,...t}=e;return(0,s.yg)(BGe,(0,p.A)({},SGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GGe.isMDXComponent=!0;const EGe={toc:[]},OGe="wrapper";function UGe(e){let{components:n,...t}=e;return(0,s.yg)(OGe,(0,p.A)({},EGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}UGe.isMDXComponent=!0;const FGe={toc:[]},VGe="wrapper";function qGe(e){let{components:n,...t}=e;return(0,s.yg)(VGe,(0,p.A)({},FGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}qGe.isMDXComponent=!0;const jGe={toc:[]},HGe="wrapper";function YGe(e){let{components:n,...t}=e;return(0,s.yg)(HGe,(0,p.A)({},jGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}YGe.isMDXComponent=!0;const QGe={toc:[]},$Ge="wrapper";function KGe(e){let{components:n,...t}=e;return(0,s.yg)($Ge,(0,p.A)({},QGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}KGe.isMDXComponent=!0;const JGe={toc:[]},ZGe="wrapper";function eEe(e){let{components:n,...t}=e;return(0,s.yg)(ZGe,(0,p.A)({},JGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eEe.isMDXComponent=!0;const nEe={toc:[]},tEe="wrapper";function oEe(e){let{components:n,...t}=e;return(0,s.yg)(tEe,(0,p.A)({},nEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}oEe.isMDXComponent=!0;const pEe={toc:[]},rEe="wrapper";function sEe(e){let{components:n,...t}=e;return(0,s.yg)(rEe,(0,p.A)({},pEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}sEe.isMDXComponent=!0;const cEe={toc:[]},aEe="wrapper";function iEe(e){let{components:n,...t}=e;return(0,s.yg)(aEe,(0,p.A)({},cEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}iEe.isMDXComponent=!0;const lEe={toc:[]},uEe="wrapper";function mEe(e){let{components:n,...t}=e;return(0,s.yg)(uEe,(0,p.A)({},lEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mEe.isMDXComponent=!0;const yEe={toc:[]},dEe="wrapper";function hEe(e){let{components:n,...t}=e;return(0,s.yg)(dEe,(0,p.A)({},yEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}hEe.isMDXComponent=!0;const gEe={toc:[]},fEe="wrapper";function DEe(e){let{components:n,...t}=e;return(0,s.yg)(fEe,(0,p.A)({},gEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}DEe.isMDXComponent=!0;const MEe={toc:[]},XEe="wrapper";function _Ee(e){let{components:n,...t}=e;return(0,s.yg)(XEe,(0,p.A)({},MEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_Ee.isMDXComponent=!0;const wEe={toc:[]},TEe="wrapper";function CEe(e){let{components:n,...t}=e;return(0,s.yg)(TEe,(0,p.A)({},wEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}CEe.isMDXComponent=!0;const xEe={toc:[]},AEe="wrapper";function vEe(e){let{components:n,...t}=e;return(0,s.yg)(AEe,(0,p.A)({},xEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}vEe.isMDXComponent=!0;const LEe={toc:[]},bEe="wrapper";function NEe(e){let{components:n,...t}=e;return(0,s.yg)(bEe,(0,p.A)({},LEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}NEe.isMDXComponent=!0;const kEe={toc:[]},zEe="wrapper";function PEe(e){let{components:n,...t}=e;return(0,s.yg)(zEe,(0,p.A)({},kEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}PEe.isMDXComponent=!0;const IEe={toc:[]},REe="wrapper";function WEe(e){let{components:n,...t}=e;return(0,s.yg)(REe,(0,p.A)({},IEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}WEe.isMDXComponent=!0;const SEe={toc:[]},BEe="wrapper";function GEe(e){let{components:n,...t}=e;return(0,s.yg)(BEe,(0,p.A)({},SEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}GEe.isMDXComponent=!0;const EEe={toc:[]},OEe="wrapper";function UEe(e){let{components:n,...t}=e;return(0,s.yg)(OEe,(0,p.A)({},EEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}UEe.isMDXComponent=!0;const FEe={toc:[]},VEe="wrapper";function qEe(e){let{components:n,...t}=e;return(0,s.yg)(VEe,(0,p.A)({},FEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qEe.isMDXComponent=!0;const jEe={toc:[]},HEe="wrapper";function YEe(e){let{components:n,...t}=e;return(0,s.yg)(HEe,(0,p.A)({},jEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}YEe.isMDXComponent=!0;const QEe={toc:[]},$Ee="wrapper";function KEe(e){let{components:n,...t}=e;return(0,s.yg)($Ee,(0,p.A)({},QEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}KEe.isMDXComponent=!0;const JEe={toc:[]},ZEe="wrapper";function eOe(e){let{components:n,...t}=e;return(0,s.yg)(ZEe,(0,p.A)({},JEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}eOe.isMDXComponent=!0;const nOe={toc:[]},tOe="wrapper";function oOe(e){let{components:n,...t}=e;return(0,s.yg)(tOe,(0,p.A)({},nOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}oOe.isMDXComponent=!0;const pOe={toc:[]},rOe="wrapper";function sOe(e){let{components:n,...t}=e;return(0,s.yg)(rOe,(0,p.A)({},pOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a standalone code signal."))}sOe.isMDXComponent=!0;const cOe={toc:[]},aOe="wrapper";function iOe(e){let{components:n,...t}=e;return(0,s.yg)(aOe,(0,p.A)({},cOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial code."))}iOe.isMDXComponent=!0;const lOe={toc:[]},uOe="wrapper";function mOe(e){let{components:n,...t}=e;return(0,s.yg)(uOe,(0,p.A)({},lOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom highlighter to use."))}mOe.isMDXComponent=!0;const yOe={toc:[]},dOe="wrapper";function hOe(e){let{components:n,...t}=e;return(0,s.yg)(dOe,(0,p.A)({},yOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom dialect to use."))}hOe.isMDXComponent=!0;const gOe={toc:[]},fOe="wrapper";function DOe(e){let{components:n,...t}=e;return(0,s.yg)(fOe,(0,p.A)({},gOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}DOe.isMDXComponent=!0;const MOe={toc:[]},XOe="wrapper";function _Oe(e){let{components:n,...t}=e;return(0,s.yg)(XOe,(0,p.A)({},MOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a cubic B\xe9zier curve."))}_Oe.isMDXComponent=!0;const wOe={toc:[]},TOe="wrapper";function COe(e){let{components:n,...t}=e;return(0,s.yg)(TOe,(0,p.A)({},wOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}COe.isMDXComponent=!0;const xOe={toc:[]},AOe="wrapper";function vOe(e){let{components:n,...t}=e;return(0,s.yg)(AOe,(0,p.A)({},xOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}vOe.isMDXComponent=!0;const LOe={toc:[]},bOe="wrapper";function NOe(e){let{components:n,...t}=e;return(0,s.yg)(bOe,(0,p.A)({},LOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NOe.isMDXComponent=!0;const kOe={toc:[]},zOe="wrapper";function POe(e){let{components:n,...t}=e;return(0,s.yg)(zOe,(0,p.A)({},kOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}POe.isMDXComponent=!0;const IOe={toc:[]},ROe="wrapper";function WOe(e){let{components:n,...t}=e;return(0,s.yg)(ROe,(0,p.A)({},IOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}WOe.isMDXComponent=!0;const SOe={toc:[]},BOe="wrapper";function GOe(e){let{components:n,...t}=e;return(0,s.yg)(BOe,(0,p.A)({},SOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}GOe.isMDXComponent=!0;const EOe={toc:[]},OOe="wrapper";function UOe(e){let{components:n,...t}=e;return(0,s.yg)(OOe,(0,p.A)({},EOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}UOe.isMDXComponent=!0;const FOe={toc:[]},VOe="wrapper";function qOe(e){let{components:n,...t}=e;return(0,s.yg)(VOe,(0,p.A)({},FOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}qOe.isMDXComponent=!0;const jOe={toc:[]},HOe="wrapper";function YOe(e){let{components:n,...t}=e;return(0,s.yg)(HOe,(0,p.A)({},jOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}YOe.isMDXComponent=!0;const QOe={toc:[]},$Oe="wrapper";function KOe(e){let{components:n,...t}=e;return(0,s.yg)($Oe,(0,p.A)({},QOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}KOe.isMDXComponent=!0;const JOe={toc:[]},ZOe="wrapper";function eUe(e){let{components:n,...t}=e;return(0,s.yg)(ZOe,(0,p.A)({},JOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}eUe.isMDXComponent=!0;const nUe={toc:[]},tUe="wrapper";function oUe(e){let{components:n,...t}=e;return(0,s.yg)(tUe,(0,p.A)({},nUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}oUe.isMDXComponent=!0;const pUe={toc:[]},rUe="wrapper";function sUe(e){let{components:n,...t}=e;return(0,s.yg)(rUe,(0,p.A)({},pUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}sUe.isMDXComponent=!0;const cUe={toc:[]},aUe="wrapper";function iUe(e){let{components:n,...t}=e;return(0,s.yg)(aUe,(0,p.A)({},cUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}iUe.isMDXComponent=!0;const lUe={toc:[]},uUe="wrapper";function mUe(e){let{components:n,...t}=e;return(0,s.yg)(uUe,(0,p.A)({},lUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}mUe.isMDXComponent=!0;const yUe={toc:[]},dUe="wrapper";function hUe(e){let{components:n,...t}=e;return(0,s.yg)(dUe,(0,p.A)({},yUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}hUe.isMDXComponent=!0;const gUe={toc:[]},fUe="wrapper";function DUe(e){let{components:n,...t}=e;return(0,s.yg)(fUe,(0,p.A)({},gUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}DUe.isMDXComponent=!0;const MUe={toc:[]},XUe="wrapper";function _Ue(e){let{components:n,...t}=e;return(0,s.yg)(XUe,(0,p.A)({},MUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}_Ue.isMDXComponent=!0;const wUe={toc:[]},TUe="wrapper";function CUe(e){let{components:n,...t}=e;return(0,s.yg)(TUe,(0,p.A)({},wUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}CUe.isMDXComponent=!0;const xUe={toc:[]},AUe="wrapper";function vUe(e){let{components:n,...t}=e;return(0,s.yg)(AUe,(0,p.A)({},xUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}vUe.isMDXComponent=!0;const LUe={toc:[]},bUe="wrapper";function NUe(e){let{components:n,...t}=e;return(0,s.yg)(bUe,(0,p.A)({},LUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NUe.isMDXComponent=!0;const kUe={toc:[]},zUe="wrapper";function PUe(e){let{components:n,...t}=e;return(0,s.yg)(zUe,(0,p.A)({},kUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}PUe.isMDXComponent=!0;const IUe={toc:[]},RUe="wrapper";function WUe(e){let{components:n,...t}=e;return(0,s.yg)(RUe,(0,p.A)({},IUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}WUe.isMDXComponent=!0;const SUe={toc:[]},BUe="wrapper";function GUe(e){let{components:n,...t}=e;return(0,s.yg)(BUe,(0,p.A)({},SUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}GUe.isMDXComponent=!0;const EUe={toc:[]},OUe="wrapper";function UUe(e){let{components:n,...t}=e;return(0,s.yg)(OUe,(0,p.A)({},EUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}UUe.isMDXComponent=!0;const FUe={toc:[]},VUe="wrapper";function qUe(e){let{components:n,...t}=e;return(0,s.yg)(VUe,(0,p.A)({},FUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}qUe.isMDXComponent=!0;const jUe={toc:[]},HUe="wrapper";function YUe(e){let{components:n,...t}=e;return(0,s.yg)(HUe,(0,p.A)({},jUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}YUe.isMDXComponent=!0;const QUe={toc:[]},$Ue="wrapper";function KUe(e){let{components:n,...t}=e;return(0,s.yg)($Ue,(0,p.A)({},QUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}KUe.isMDXComponent=!0;const JUe={toc:[]},ZUe="wrapper";function eFe(e){let{components:n,...t}=e;return(0,s.yg)(ZUe,(0,p.A)({},JUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}eFe.isMDXComponent=!0;const nFe={toc:[]},tFe="wrapper";function oFe(e){let{components:n,...t}=e;return(0,s.yg)(tFe,(0,p.A)({},nFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}oFe.isMDXComponent=!0;const pFe={toc:[]},rFe="wrapper";function sFe(e){let{components:n,...t}=e;return(0,s.yg)(rFe,(0,p.A)({},pFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}sFe.isMDXComponent=!0;const cFe={toc:[]},aFe="wrapper";function iFe(e){let{components:n,...t}=e;return(0,s.yg)(aFe,(0,p.A)({},cFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}iFe.isMDXComponent=!0;const lFe={toc:[]},uFe="wrapper";function mFe(e){let{components:n,...t}=e;return(0,s.yg)(uFe,(0,p.A)({},lFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start point of the B\xe9zier curve."))}mFe.isMDXComponent=!0;const yFe={toc:[]},dFe="wrapper";function hFe(e){let{components:n,...t}=e;return(0,s.yg)(dFe,(0,p.A)({},yFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The first control point of the B\xe9zier curve."))}hFe.isMDXComponent=!0;const gFe={toc:[]},fFe="wrapper";function DFe(e){let{components:n,...t}=e;return(0,s.yg)(fFe,(0,p.A)({},gFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The second control point of the B\xe9zier curve."))}DFe.isMDXComponent=!0;const MFe={toc:[]},XFe="wrapper";function _Fe(e){let{components:n,...t}=e;return(0,s.yg)(XFe,(0,p.A)({},MFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end point of the B\xe9zier curve."))}_Fe.isMDXComponent=!0;const wFe={toc:[]},TFe="wrapper";function CFe(e){let{components:n,...t}=e;return(0,s.yg)(TFe,(0,p.A)({},wFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}CFe.isMDXComponent=!0;const xFe={toc:[]},AFe="wrapper";function vFe(e){let{components:n,...t}=e;return(0,s.yg)(AFe,(0,p.A)({},xFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}vFe.isMDXComponent=!0;const LFe={toc:[]},bFe="wrapper";function NFe(e){let{components:n,...t}=e;return(0,s.yg)(bFe,(0,p.A)({},LFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}NFe.isMDXComponent=!0;const kFe={toc:[]},zFe="wrapper";function PFe(e){let{components:n,...t}=e;return(0,s.yg)(zFe,(0,p.A)({},kFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}PFe.isMDXComponent=!0;const IFe={toc:[]},RFe="wrapper";function WFe(e){let{components:n,...t}=e;return(0,s.yg)(RFe,(0,p.A)({},IFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}WFe.isMDXComponent=!0;const SFe={toc:[]},BFe="wrapper";function GFe(e){let{components:n,...t}=e;return(0,s.yg)(BFe,(0,p.A)({},SFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}GFe.isMDXComponent=!0;const EFe={toc:[]},OFe="wrapper";function UFe(e){let{components:n,...t}=e;return(0,s.yg)(OFe,(0,p.A)({},EFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}UFe.isMDXComponent=!0;const FFe={toc:[]},VFe="wrapper";function qFe(e){let{components:n,...t}=e;return(0,s.yg)(VFe,(0,p.A)({},FFe,t,{components:n,mdxType:"MDXLayout"}))}qFe.isMDXComponent=!0;const jFe={toc:[]},HFe="wrapper";function YFe(e){let{components:n,...t}=e;return(0,s.yg)(HFe,(0,p.A)({},jFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}YFe.isMDXComponent=!0;const QFe={toc:[]},$Fe="wrapper";function KFe(e){let{components:n,...t}=e;return(0,s.yg)($Fe,(0,p.A)({},QFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}KFe.isMDXComponent=!0;const JFe={toc:[]},ZFe="wrapper";function eVe(e){let{components:n,...t}=e;return(0,s.yg)(ZFe,(0,p.A)({},JFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}eVe.isMDXComponent=!0;const nVe={toc:[]},tVe="wrapper";function oVe(e){let{components:n,...t}=e;return(0,s.yg)(tVe,(0,p.A)({},nVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}oVe.isMDXComponent=!0;const pVe={toc:[]},rVe="wrapper";function sVe(e){let{components:n,...t}=e;return(0,s.yg)(rVe,(0,p.A)({},pVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}sVe.isMDXComponent=!0;const cVe={toc:[]},aVe="wrapper";function iVe(e){let{components:n,...t}=e;return(0,s.yg)(aVe,(0,p.A)({},cVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}iVe.isMDXComponent=!0;const lVe={toc:[]},uVe="wrapper";function mVe(e){let{components:n,...t}=e;return(0,s.yg)(uVe,(0,p.A)({},lVe,t,{components:n,mdxType:"MDXLayout"}))}mVe.isMDXComponent=!0;const yVe={toc:[]},dVe="wrapper";function hVe(e){let{components:n,...t}=e;return(0,s.yg)(dVe,(0,p.A)({},yVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}hVe.isMDXComponent=!0;const gVe={toc:[]},fVe="wrapper";function DVe(e){let{components:n,...t}=e;return(0,s.yg)(fVe,(0,p.A)({},gVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}DVe.isMDXComponent=!0;const MVe={toc:[]},XVe="wrapper";function _Ve(e){let{components:n,...t}=e;return(0,s.yg)(XVe,(0,p.A)({},MVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_Ve.isMDXComponent=!0;const wVe={toc:[]},TVe="wrapper";function CVe(e){let{components:n,...t}=e;return(0,s.yg)(TVe,(0,p.A)({},wVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}CVe.isMDXComponent=!0;const xVe={toc:[]},AVe="wrapper";function vVe(e){let{components:n,...t}=e;return(0,s.yg)(AVe,(0,p.A)({},xVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}vVe.isMDXComponent=!0;const LVe={toc:[]},bVe="wrapper";function NVe(e){let{components:n,...t}=e;return(0,s.yg)(bVe,(0,p.A)({},LVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}NVe.isMDXComponent=!0;const kVe={toc:[]},zVe="wrapper";function PVe(e){let{components:n,...t}=e;return(0,s.yg)(zVe,(0,p.A)({},kVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}PVe.isMDXComponent=!0;const IVe={toc:[]},RVe="wrapper";function WVe(e){let{components:n,...t}=e;return(0,s.yg)(RVe,(0,p.A)({},IVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}WVe.isMDXComponent=!0;const SVe={toc:[]},BVe="wrapper";function GVe(e){let{components:n,...t}=e;return(0,s.yg)(BVe,(0,p.A)({},SVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}GVe.isMDXComponent=!0;const EVe={toc:[]},OVe="wrapper";function UVe(e){let{components:n,...t}=e;return(0,s.yg)(OVe,(0,p.A)({},EVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}UVe.isMDXComponent=!0;const FVe={toc:[]},VVe="wrapper";function qVe(e){let{components:n,...t}=e;return(0,s.yg)(VVe,(0,p.A)({},FVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}qVe.isMDXComponent=!0;const jVe={toc:[]},HVe="wrapper";function YVe(e){let{components:n,...t}=e;return(0,s.yg)(HVe,(0,p.A)({},jVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}YVe.isMDXComponent=!0;const QVe={toc:[]},$Ve="wrapper";function KVe(e){let{components:n,...t}=e;return(0,s.yg)($Ve,(0,p.A)({},QVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}KVe.isMDXComponent=!0;const JVe={toc:[]},ZVe="wrapper";function eqe(e){let{components:n,...t}=e;return(0,s.yg)(ZVe,(0,p.A)({},JVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}eqe.isMDXComponent=!0;const nqe={toc:[]},tqe="wrapper";function oqe(e){let{components:n,...t}=e;return(0,s.yg)(tqe,(0,p.A)({},nqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}oqe.isMDXComponent=!0;const pqe={toc:[]},rqe="wrapper";function sqe(e){let{components:n,...t}=e;return(0,s.yg)(rqe,(0,p.A)({},pqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}sqe.isMDXComponent=!0;const cqe={toc:[]},aqe="wrapper";function iqe(e){let{components:n,...t}=e;return(0,s.yg)(aqe,(0,p.A)({},cqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}iqe.isMDXComponent=!0;const lqe={toc:[]},uqe="wrapper";function mqe(e){let{components:n,...t}=e;return(0,s.yg)(uqe,(0,p.A)({},lqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}mqe.isMDXComponent=!0;const yqe={toc:[]},dqe="wrapper";function hqe(e){let{components:n,...t}=e;return(0,s.yg)(dqe,(0,p.A)({},yqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}hqe.isMDXComponent=!0;const gqe={toc:[]},fqe="wrapper";function Dqe(e){let{components:n,...t}=e;return(0,s.yg)(fqe,(0,p.A)({},gqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Dqe.isMDXComponent=!0;const Mqe={toc:[]},Xqe="wrapper";function _qe(e){let{components:n,...t}=e;return(0,s.yg)(Xqe,(0,p.A)({},Mqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}_qe.isMDXComponent=!0;const wqe={toc:[]},Tqe="wrapper";function Cqe(e){let{components:n,...t}=e;return(0,s.yg)(Tqe,(0,p.A)({},wqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Cqe.isMDXComponent=!0;const xqe={toc:[]},Aqe="wrapper";function vqe(e){let{components:n,...t}=e;return(0,s.yg)(Aqe,(0,p.A)({},xqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}vqe.isMDXComponent=!0;const Lqe={toc:[]},bqe="wrapper";function Nqe(e){let{components:n,...t}=e;return(0,s.yg)(bqe,(0,p.A)({},Lqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Nqe.isMDXComponent=!0;const kqe={toc:[]},zqe="wrapper";function Pqe(e){let{components:n,...t}=e;return(0,s.yg)(zqe,(0,p.A)({},kqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Pqe.isMDXComponent=!0;const Iqe={toc:[]},Rqe="wrapper";function Wqe(e){let{components:n,...t}=e;return(0,s.yg)(Rqe,(0,p.A)({},Iqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Wqe.isMDXComponent=!0;const Sqe={toc:[]},Bqe="wrapper";function Gqe(e){let{components:n,...t}=e;return(0,s.yg)(Bqe,(0,p.A)({},Sqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Gqe.isMDXComponent=!0;const Eqe={toc:[]},Oqe="wrapper";function Uqe(e){let{components:n,...t}=e;return(0,s.yg)(Oqe,(0,p.A)({},Eqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Uqe.isMDXComponent=!0;const Fqe={toc:[]},Vqe="wrapper";function qqe(e){let{components:n,...t}=e;return(0,s.yg)(Vqe,(0,p.A)({},Fqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}qqe.isMDXComponent=!0;const jqe={toc:[]},Hqe="wrapper";function Yqe(e){let{components:n,...t}=e;return(0,s.yg)(Hqe,(0,p.A)({},jqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Yqe.isMDXComponent=!0;const Qqe={toc:[]},$qe="wrapper";function Kqe(e){let{components:n,...t}=e;return(0,s.yg)($qe,(0,p.A)({},Qqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Kqe.isMDXComponent=!0;const Jqe={toc:[]},Zqe="wrapper";function eje(e){let{components:n,...t}=e;return(0,s.yg)(Zqe,(0,p.A)({},Jqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}eje.isMDXComponent=!0;const nje={toc:[]},tje="wrapper";function oje(e){let{components:n,...t}=e;return(0,s.yg)(tje,(0,p.A)({},nje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}oje.isMDXComponent=!0;const pje={toc:[]},rje="wrapper";function sje(e){let{components:n,...t}=e;return(0,s.yg)(rje,(0,p.A)({},pje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}sje.isMDXComponent=!0;const cje={toc:[]},aje="wrapper";function ije(e){let{components:n,...t}=e;return(0,s.yg)(aje,(0,p.A)({},cje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}ije.isMDXComponent=!0;const lje={toc:[]},uje="wrapper";function mje(e){let{components:n,...t}=e;return(0,s.yg)(uje,(0,p.A)({},lje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}mje.isMDXComponent=!0;const yje={toc:[]},dje="wrapper";function hje(e){let{components:n,...t}=e;return(0,s.yg)(dje,(0,p.A)({},yje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}hje.isMDXComponent=!0;const gje={toc:[]},fje="wrapper";function Dje(e){let{components:n,...t}=e;return(0,s.yg)(fje,(0,p.A)({},gje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Dje.isMDXComponent=!0;const Mje={toc:[]},Xje="wrapper";function _je(e){let{components:n,...t}=e;return(0,s.yg)(Xje,(0,p.A)({},Mje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}_je.isMDXComponent=!0;const wje={toc:[]},Tje="wrapper";function Cje(e){let{components:n,...t}=e;return(0,s.yg)(Tje,(0,p.A)({},wje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Cje.isMDXComponent=!0;const xje={toc:[]},Aje="wrapper";function vje(e){let{components:n,...t}=e;return(0,s.yg)(Aje,(0,p.A)({},xje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}vje.isMDXComponent=!0;const Lje={toc:[]},bje="wrapper";function Nje(e){let{components:n,...t}=e;return(0,s.yg)(bje,(0,p.A)({},Lje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Nje.isMDXComponent=!0;const kje={toc:[]},zje="wrapper";function Pje(e){let{components:n,...t}=e;return(0,s.yg)(zje,(0,p.A)({},kje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Pje.isMDXComponent=!0;const Ije={toc:[]},Rje="wrapper";function Wje(e){let{components:n,...t}=e;return(0,s.yg)(Rje,(0,p.A)({},Ije,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Wje.isMDXComponent=!0;const Sje={toc:[]},Bje="wrapper";function Gje(e){let{components:n,...t}=e;return(0,s.yg)(Bje,(0,p.A)({},Sje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Gje.isMDXComponent=!0;const Eje={toc:[]},Oje="wrapper";function Uje(e){let{components:n,...t}=e;return(0,s.yg)(Oje,(0,p.A)({},Eje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Uje.isMDXComponent=!0;const Fje={toc:[]},Vje="wrapper";function qje(e){let{components:n,...t}=e;return(0,s.yg)(Vje,(0,p.A)({},Fje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}qje.isMDXComponent=!0;const jje={toc:[]},Hje="wrapper";function Yje(e){let{components:n,...t}=e;return(0,s.yg)(Hje,(0,p.A)({},jje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Yje.isMDXComponent=!0;const Qje={toc:[]},$je="wrapper";function Kje(e){let{components:n,...t}=e;return(0,s.yg)($je,(0,p.A)({},Qje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kje.isMDXComponent=!0;const Jje={toc:[]},Zje="wrapper";function eHe(e){let{components:n,...t}=e;return(0,s.yg)(Zje,(0,p.A)({},Jje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}eHe.isMDXComponent=!0;const nHe={toc:[]},tHe="wrapper";function oHe(e){let{components:n,...t}=e;return(0,s.yg)(tHe,(0,p.A)({},nHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}oHe.isMDXComponent=!0;const pHe={toc:[]},rHe="wrapper";function sHe(e){let{components:n,...t}=e;return(0,s.yg)(rHe,(0,p.A)({},pHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}sHe.isMDXComponent=!0;const cHe={toc:[]},aHe="wrapper";function iHe(e){let{components:n,...t}=e;return(0,s.yg)(aHe,(0,p.A)({},cHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}iHe.isMDXComponent=!0;const lHe={toc:[]},uHe="wrapper";function mHe(e){let{components:n,...t}=e;return(0,s.yg)(uHe,(0,p.A)({},lHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mHe.isMDXComponent=!0;const yHe={toc:[]},dHe="wrapper";function hHe(e){let{components:n,...t}=e;return(0,s.yg)(dHe,(0,p.A)({},yHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}hHe.isMDXComponent=!0;const gHe={toc:[]},fHe="wrapper";function DHe(e){let{components:n,...t}=e;return(0,s.yg)(fHe,(0,p.A)({},gHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DHe.isMDXComponent=!0;const MHe={toc:[]},XHe="wrapper";function _He(e){let{components:n,...t}=e;return(0,s.yg)(XHe,(0,p.A)({},MHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}_He.isMDXComponent=!0;const wHe={toc:[]},THe="wrapper";function CHe(e){let{components:n,...t}=e;return(0,s.yg)(THe,(0,p.A)({},wHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}CHe.isMDXComponent=!0;const xHe={toc:[]},AHe="wrapper";function vHe(e){let{components:n,...t}=e;return(0,s.yg)(AHe,(0,p.A)({},xHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}vHe.isMDXComponent=!0;const LHe={toc:[]},bHe="wrapper";function NHe(e){let{components:n,...t}=e;return(0,s.yg)(bHe,(0,p.A)({},LHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}NHe.isMDXComponent=!0;const kHe={toc:[]},zHe="wrapper";function PHe(e){let{components:n,...t}=e;return(0,s.yg)(zHe,(0,p.A)({},kHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}PHe.isMDXComponent=!0;const IHe={toc:[]},RHe="wrapper";function WHe(e){let{components:n,...t}=e;return(0,s.yg)(RHe,(0,p.A)({},IHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}WHe.isMDXComponent=!0;const SHe={toc:[]},BHe="wrapper";function GHe(e){let{components:n,...t}=e;return(0,s.yg)(BHe,(0,p.A)({},SHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}GHe.isMDXComponent=!0;const EHe={toc:[]},OHe="wrapper";function UHe(e){let{components:n,...t}=e;return(0,s.yg)(OHe,(0,p.A)({},EHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}UHe.isMDXComponent=!0;const FHe={toc:[]},VHe="wrapper";function qHe(e){let{components:n,...t}=e;return(0,s.yg)(VHe,(0,p.A)({},FHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}qHe.isMDXComponent=!0;const jHe={toc:[]},HHe="wrapper";function YHe(e){let{components:n,...t}=e;return(0,s.yg)(HHe,(0,p.A)({},jHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}YHe.isMDXComponent=!0;const QHe={toc:[]},$He="wrapper";function KHe(e){let{components:n,...t}=e;return(0,s.yg)($He,(0,p.A)({},QHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}KHe.isMDXComponent=!0;const JHe={toc:[]},ZHe="wrapper";function eYe(e){let{components:n,...t}=e;return(0,s.yg)(ZHe,(0,p.A)({},JHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eYe.isMDXComponent=!0;const nYe={toc:[]},tYe="wrapper";function oYe(e){let{components:n,...t}=e;return(0,s.yg)(tYe,(0,p.A)({},nYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}oYe.isMDXComponent=!0;const pYe={toc:[]},rYe="wrapper";function sYe(e){let{components:n,...t}=e;return(0,s.yg)(rYe,(0,p.A)({},pYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}sYe.isMDXComponent=!0;const cYe={toc:[]},aYe="wrapper";function iYe(e){let{components:n,...t}=e;return(0,s.yg)(aYe,(0,p.A)({},cYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}iYe.isMDXComponent=!0;const lYe={toc:[]},uYe="wrapper";function mYe(e){let{components:n,...t}=e;return(0,s.yg)(uYe,(0,p.A)({},lYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}mYe.isMDXComponent=!0;const yYe={toc:[]},dYe="wrapper";function hYe(e){let{components:n,...t}=e;return(0,s.yg)(dYe,(0,p.A)({},yYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hYe.isMDXComponent=!0;const gYe={toc:[]},fYe="wrapper";function DYe(e){let{components:n,...t}=e;return(0,s.yg)(fYe,(0,p.A)({},gYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}DYe.isMDXComponent=!0;const MYe={toc:[]},XYe="wrapper";function _Ye(e){let{components:n,...t}=e;return(0,s.yg)(XYe,(0,p.A)({},MYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}_Ye.isMDXComponent=!0;const wYe={toc:[]},TYe="wrapper";function CYe(e){let{components:n,...t}=e;return(0,s.yg)(TYe,(0,p.A)({},wYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}CYe.isMDXComponent=!0;const xYe={toc:[]},AYe="wrapper";function vYe(e){let{components:n,...t}=e;return(0,s.yg)(AYe,(0,p.A)({},xYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}vYe.isMDXComponent=!0;const LYe={toc:[]},bYe="wrapper";function NYe(e){let{components:n,...t}=e;return(0,s.yg)(bYe,(0,p.A)({},LYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}NYe.isMDXComponent=!0;const kYe={toc:[]},zYe="wrapper";function PYe(e){let{components:n,...t}=e;return(0,s.yg)(zYe,(0,p.A)({},kYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}PYe.isMDXComponent=!0;const IYe={toc:[]},RYe="wrapper";function WYe(e){let{components:n,...t}=e;return(0,s.yg)(RYe,(0,p.A)({},IYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}WYe.isMDXComponent=!0;const SYe={toc:[]},BYe="wrapper";function GYe(e){let{components:n,...t}=e;return(0,s.yg)(BYe,(0,p.A)({},SYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}GYe.isMDXComponent=!0;const EYe={toc:[]},OYe="wrapper";function UYe(e){let{components:n,...t}=e;return(0,s.yg)(OYe,(0,p.A)({},EYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}UYe.isMDXComponent=!0;const FYe={toc:[]},VYe="wrapper";function qYe(e){let{components:n,...t}=e;return(0,s.yg)(VYe,(0,p.A)({},FYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qYe.isMDXComponent=!0;const jYe={toc:[]},HYe="wrapper";function YYe(e){let{components:n,...t}=e;return(0,s.yg)(HYe,(0,p.A)({},jYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}YYe.isMDXComponent=!0;const QYe={toc:[]},$Ye="wrapper";function KYe(e){let{components:n,...t}=e;return(0,s.yg)($Ye,(0,p.A)({},QYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}KYe.isMDXComponent=!0;const JYe={toc:[]},ZYe="wrapper";function eQe(e){let{components:n,...t}=e;return(0,s.yg)(ZYe,(0,p.A)({},JYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}eQe.isMDXComponent=!0;const nQe={toc:[]},tQe="wrapper";function oQe(e){let{components:n,...t}=e;return(0,s.yg)(tQe,(0,p.A)({},nQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}oQe.isMDXComponent=!0;const pQe={toc:[]},rQe="wrapper";function sQe(e){let{components:n,...t}=e;return(0,s.yg)(rQe,(0,p.A)({},pQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sQe.isMDXComponent=!0;const cQe={toc:[]},aQe="wrapper";function iQe(e){let{components:n,...t}=e;return(0,s.yg)(aQe,(0,p.A)({},cQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}iQe.isMDXComponent=!0;const lQe={toc:[]},uQe="wrapper";function mQe(e){let{components:n,...t}=e;return(0,s.yg)(uQe,(0,p.A)({},lQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}mQe.isMDXComponent=!0;const yQe={toc:[]},dQe="wrapper";function hQe(e){let{components:n,...t}=e;return(0,s.yg)(dQe,(0,p.A)({},yQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}hQe.isMDXComponent=!0;const gQe={toc:[]},fQe="wrapper";function DQe(e){let{components:n,...t}=e;return(0,s.yg)(fQe,(0,p.A)({},gQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}DQe.isMDXComponent=!0;const MQe={toc:[]},XQe="wrapper";function _Qe(e){let{components:n,...t}=e;return(0,s.yg)(XQe,(0,p.A)({},MQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_Qe.isMDXComponent=!0;const wQe={toc:[]},TQe="wrapper";function CQe(e){let{components:n,...t}=e;return(0,s.yg)(TQe,(0,p.A)({},wQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}CQe.isMDXComponent=!0;const xQe={toc:[]},AQe="wrapper";function vQe(e){let{components:n,...t}=e;return(0,s.yg)(AQe,(0,p.A)({},xQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}vQe.isMDXComponent=!0;const LQe={toc:[]},bQe="wrapper";function NQe(e){let{components:n,...t}=e;return(0,s.yg)(bQe,(0,p.A)({},LQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}NQe.isMDXComponent=!0;const kQe={toc:[]},zQe="wrapper";function PQe(e){let{components:n,...t}=e;return(0,s.yg)(zQe,(0,p.A)({},kQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}PQe.isMDXComponent=!0;const IQe={toc:[]},RQe="wrapper";function WQe(e){let{components:n,...t}=e;return(0,s.yg)(RQe,(0,p.A)({},IQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}WQe.isMDXComponent=!0;const SQe={toc:[]},BQe="wrapper";function GQe(e){let{components:n,...t}=e;return(0,s.yg)(BQe,(0,p.A)({},SQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}GQe.isMDXComponent=!0;const EQe={toc:[]},OQe="wrapper";function UQe(e){let{components:n,...t}=e;return(0,s.yg)(OQe,(0,p.A)({},EQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}UQe.isMDXComponent=!0;const FQe={toc:[]},VQe="wrapper";function qQe(e){let{components:n,...t}=e;return(0,s.yg)(VQe,(0,p.A)({},FQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qQe.isMDXComponent=!0;const jQe={toc:[]},HQe="wrapper";function YQe(e){let{components:n,...t}=e;return(0,s.yg)(HQe,(0,p.A)({},jQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}YQe.isMDXComponent=!0;const QQe={toc:[]},$Qe="wrapper";function KQe(e){let{components:n,...t}=e;return(0,s.yg)($Qe,(0,p.A)({},QQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}KQe.isMDXComponent=!0;const JQe={toc:[]},ZQe="wrapper";function e$e(e){let{components:n,...t}=e;return(0,s.yg)(ZQe,(0,p.A)({},JQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}e$e.isMDXComponent=!0;const n$e={toc:[]},t$e="wrapper";function o$e(e){let{components:n,...t}=e;return(0,s.yg)(t$e,(0,p.A)({},n$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}o$e.isMDXComponent=!0;const p$e={toc:[]},r$e="wrapper";function s$e(e){let{components:n,...t}=e;return(0,s.yg)(r$e,(0,p.A)({},p$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}s$e.isMDXComponent=!0;const c$e={toc:[]},a$e="wrapper";function i$e(e){let{components:n,...t}=e;return(0,s.yg)(a$e,(0,p.A)({},c$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}i$e.isMDXComponent=!0;const l$e={toc:[]},u$e="wrapper";function m$e(e){let{components:n,...t}=e;return(0,s.yg)(u$e,(0,p.A)({},l$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}m$e.isMDXComponent=!0;const y$e={toc:[]},d$e="wrapper";function h$e(e){let{components:n,...t}=e;return(0,s.yg)(d$e,(0,p.A)({},y$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}h$e.isMDXComponent=!0;const g$e={toc:[]},f$e="wrapper";function D$e(e){let{components:n,...t}=e;return(0,s.yg)(f$e,(0,p.A)({},g$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}D$e.isMDXComponent=!0;const M$e={toc:[]},X$e="wrapper";function _$e(e){let{components:n,...t}=e;return(0,s.yg)(X$e,(0,p.A)({},M$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}_$e.isMDXComponent=!0;const w$e={toc:[]},T$e="wrapper";function C$e(e){let{components:n,...t}=e;return(0,s.yg)(T$e,(0,p.A)({},w$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}C$e.isMDXComponent=!0;const x$e={toc:[]},A$e="wrapper";function v$e(e){let{components:n,...t}=e;return(0,s.yg)(A$e,(0,p.A)({},x$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}v$e.isMDXComponent=!0;const L$e={toc:[]},b$e="wrapper";function N$e(e){let{components:n,...t}=e;return(0,s.yg)(b$e,(0,p.A)({},L$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}N$e.isMDXComponent=!0;const k$e={toc:[]},z$e="wrapper";function P$e(e){let{components:n,...t}=e;return(0,s.yg)(z$e,(0,p.A)({},k$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}P$e.isMDXComponent=!0;const I$e={toc:[]},R$e="wrapper";function W$e(e){let{components:n,...t}=e;return(0,s.yg)(R$e,(0,p.A)({},I$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}W$e.isMDXComponent=!0;const S$e={toc:[]},B$e="wrapper";function G$e(e){let{components:n,...t}=e;return(0,s.yg)(B$e,(0,p.A)({},S$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}G$e.isMDXComponent=!0;const E$e={toc:[]},O$e="wrapper";function U$e(e){let{components:n,...t}=e;return(0,s.yg)(O$e,(0,p.A)({},E$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}U$e.isMDXComponent=!0;const F$e={toc:[]},V$e="wrapper";function q$e(e){let{components:n,...t}=e;return(0,s.yg)(V$e,(0,p.A)({},F$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}q$e.isMDXComponent=!0;const j$e={toc:[]},H$e="wrapper";function Y$e(e){let{components:n,...t}=e;return(0,s.yg)(H$e,(0,p.A)({},j$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Y$e.isMDXComponent=!0;const Q$e={toc:[]},$$e="wrapper";function K$e(e){let{components:n,...t}=e;return(0,s.yg)($$e,(0,p.A)({},Q$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}K$e.isMDXComponent=!0;const J$e={toc:[]},Z$e="wrapper";function eKe(e){let{components:n,...t}=e;return(0,s.yg)(Z$e,(0,p.A)({},J$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}eKe.isMDXComponent=!0;const nKe={toc:[]},tKe="wrapper";function oKe(e){let{components:n,...t}=e;return(0,s.yg)(tKe,(0,p.A)({},nKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}oKe.isMDXComponent=!0;const pKe={toc:[]},rKe="wrapper";function sKe(e){let{components:n,...t}=e;return(0,s.yg)(rKe,(0,p.A)({},pKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sKe.isMDXComponent=!0;const cKe={toc:[]},aKe="wrapper";function iKe(e){let{components:n,...t}=e;return(0,s.yg)(aKe,(0,p.A)({},cKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}iKe.isMDXComponent=!0;const lKe={toc:[]},uKe="wrapper";function mKe(e){let{components:n,...t}=e;return(0,s.yg)(uKe,(0,p.A)({},lKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}mKe.isMDXComponent=!0;const yKe={toc:[]},dKe="wrapper";function hKe(e){let{components:n,...t}=e;return(0,s.yg)(dKe,(0,p.A)({},yKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}hKe.isMDXComponent=!0;const gKe={toc:[]},fKe="wrapper";function DKe(e){let{components:n,...t}=e;return(0,s.yg)(fKe,(0,p.A)({},gKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}DKe.isMDXComponent=!0;const MKe={toc:[]},XKe="wrapper";function _Ke(e){let{components:n,...t}=e;return(0,s.yg)(XKe,(0,p.A)({},MKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}_Ke.isMDXComponent=!0;const wKe={toc:[]},TKe="wrapper";function CKe(e){let{components:n,...t}=e;return(0,s.yg)(TKe,(0,p.A)({},wKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}CKe.isMDXComponent=!0;const xKe={toc:[]},AKe="wrapper";function vKe(e){let{components:n,...t}=e;return(0,s.yg)(AKe,(0,p.A)({},xKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}vKe.isMDXComponent=!0;const LKe={toc:[]},bKe="wrapper";function NKe(e){let{components:n,...t}=e;return(0,s.yg)(bKe,(0,p.A)({},LKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}NKe.isMDXComponent=!0;const kKe={toc:[]},zKe="wrapper";function PKe(e){let{components:n,...t}=e;return(0,s.yg)(zKe,(0,p.A)({},kKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}PKe.isMDXComponent=!0;const IKe={toc:[]},RKe="wrapper";function WKe(e){let{components:n,...t}=e;return(0,s.yg)(RKe,(0,p.A)({},IKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}WKe.isMDXComponent=!0;const SKe={toc:[]},BKe="wrapper";function GKe(e){let{components:n,...t}=e;return(0,s.yg)(BKe,(0,p.A)({},SKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}GKe.isMDXComponent=!0;const EKe={toc:[]},OKe="wrapper";function UKe(e){let{components:n,...t}=e;return(0,s.yg)(OKe,(0,p.A)({},EKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}UKe.isMDXComponent=!0;const FKe={toc:[]},VKe="wrapper";function qKe(e){let{components:n,...t}=e;return(0,s.yg)(VKe,(0,p.A)({},FKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}qKe.isMDXComponent=!0;const jKe={toc:[]},HKe="wrapper";function YKe(e){let{components:n,...t}=e;return(0,s.yg)(HKe,(0,p.A)({},jKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}YKe.isMDXComponent=!0;const QKe={toc:[]},$Ke="wrapper";function KKe(e){let{components:n,...t}=e;return(0,s.yg)($Ke,(0,p.A)({},QKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}KKe.isMDXComponent=!0;const JKe={toc:[]},ZKe="wrapper";function eJe(e){let{components:n,...t}=e;return(0,s.yg)(ZKe,(0,p.A)({},JKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}eJe.isMDXComponent=!0;const nJe={toc:[]},tJe="wrapper";function oJe(e){let{components:n,...t}=e;return(0,s.yg)(tJe,(0,p.A)({},nJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}oJe.isMDXComponent=!0;const pJe={toc:[]},rJe="wrapper";function sJe(e){let{components:n,...t}=e;return(0,s.yg)(rJe,(0,p.A)({},pJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}sJe.isMDXComponent=!0;const cJe={toc:[]},aJe="wrapper";function iJe(e){let{components:n,...t}=e;return(0,s.yg)(aJe,(0,p.A)({},cJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}iJe.isMDXComponent=!0;const lJe={toc:[]},uJe="wrapper";function mJe(e){let{components:n,...t}=e;return(0,s.yg)(uJe,(0,p.A)({},lJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}mJe.isMDXComponent=!0;const yJe={toc:[]},dJe="wrapper";function hJe(e){let{components:n,...t}=e;return(0,s.yg)(dJe,(0,p.A)({},yJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}hJe.isMDXComponent=!0;const gJe={toc:[]},fJe="wrapper";function DJe(e){let{components:n,...t}=e;return(0,s.yg)(fJe,(0,p.A)({},gJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}DJe.isMDXComponent=!0;const MJe={toc:[]},XJe="wrapper";function _Je(e){let{components:n,...t}=e;return(0,s.yg)(XJe,(0,p.A)({},MJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}_Je.isMDXComponent=!0;const wJe={toc:[]},TJe="wrapper";function CJe(e){let{components:n,...t}=e;return(0,s.yg)(TJe,(0,p.A)({},wJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}CJe.isMDXComponent=!0;const xJe={toc:[]},AJe="wrapper";function vJe(e){let{components:n,...t}=e;return(0,s.yg)(AJe,(0,p.A)({},xJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}vJe.isMDXComponent=!0;const LJe={toc:[]},bJe="wrapper";function NJe(e){let{components:n,...t}=e;return(0,s.yg)(bJe,(0,p.A)({},LJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}NJe.isMDXComponent=!0;const kJe={toc:[]},zJe="wrapper";function PJe(e){let{components:n,...t}=e;return(0,s.yg)(zJe,(0,p.A)({},kJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}PJe.isMDXComponent=!0;const IJe={toc:[]},RJe="wrapper";function WJe(e){let{components:n,...t}=e;return(0,s.yg)(RJe,(0,p.A)({},IJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}WJe.isMDXComponent=!0;const SJe={toc:[]},BJe="wrapper";function GJe(e){let{components:n,...t}=e;return(0,s.yg)(BJe,(0,p.A)({},SJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}GJe.isMDXComponent=!0;const EJe={toc:[]},OJe="wrapper";function UJe(e){let{components:n,...t}=e;return(0,s.yg)(OJe,(0,p.A)({},EJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}UJe.isMDXComponent=!0;const FJe={toc:[]},VJe="wrapper";function qJe(e){let{components:n,...t}=e;return(0,s.yg)(VJe,(0,p.A)({},FJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}qJe.isMDXComponent=!0;const jJe={toc:[]},HJe="wrapper";function YJe(e){let{components:n,...t}=e;return(0,s.yg)(HJe,(0,p.A)({},jJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}YJe.isMDXComponent=!0;const QJe={toc:[]},$Je="wrapper";function KJe(e){let{components:n,...t}=e;return(0,s.yg)($Je,(0,p.A)({},QJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}KJe.isMDXComponent=!0;const JJe={toc:[]},ZJe="wrapper";function eZe(e){let{components:n,...t}=e;return(0,s.yg)(ZJe,(0,p.A)({},JJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}eZe.isMDXComponent=!0;const nZe={toc:[]},tZe="wrapper";function oZe(e){let{components:n,...t}=e;return(0,s.yg)(tZe,(0,p.A)({},nZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oZe.isMDXComponent=!0;const pZe={toc:[]},rZe="wrapper";function sZe(e){let{components:n,...t}=e;return(0,s.yg)(rZe,(0,p.A)({},pZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sZe.isMDXComponent=!0;const cZe={toc:[]},aZe="wrapper";function iZe(e){let{components:n,...t}=e;return(0,s.yg)(aZe,(0,p.A)({},cZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}iZe.isMDXComponent=!0;const lZe={toc:[]},uZe="wrapper";function mZe(e){let{components:n,...t}=e;return(0,s.yg)(uZe,(0,p.A)({},lZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}mZe.isMDXComponent=!0;const yZe={toc:[]},dZe="wrapper";function hZe(e){let{components:n,...t}=e;return(0,s.yg)(dZe,(0,p.A)({},yZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}hZe.isMDXComponent=!0;const gZe={toc:[]},fZe="wrapper";function DZe(e){let{components:n,...t}=e;return(0,s.yg)(fZe,(0,p.A)({},gZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}DZe.isMDXComponent=!0;const MZe={toc:[]},XZe="wrapper";function _Ze(e){let{components:n,...t}=e;return(0,s.yg)(XZe,(0,p.A)({},MZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}_Ze.isMDXComponent=!0;const wZe={toc:[]},TZe="wrapper";function CZe(e){let{components:n,...t}=e;return(0,s.yg)(TZe,(0,p.A)({},wZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}CZe.isMDXComponent=!0;const xZe={toc:[]},AZe="wrapper";function vZe(e){let{components:n,...t}=e;return(0,s.yg)(AZe,(0,p.A)({},xZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}vZe.isMDXComponent=!0;const LZe={toc:[]},bZe="wrapper";function NZe(e){let{components:n,...t}=e;return(0,s.yg)(bZe,(0,p.A)({},LZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}NZe.isMDXComponent=!0;const kZe={toc:[]},zZe="wrapper";function PZe(e){let{components:n,...t}=e;return(0,s.yg)(zZe,(0,p.A)({},kZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}PZe.isMDXComponent=!0;const IZe={toc:[]},RZe="wrapper";function WZe(e){let{components:n,...t}=e;return(0,s.yg)(RZe,(0,p.A)({},IZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}WZe.isMDXComponent=!0;const SZe={toc:[]},BZe="wrapper";function GZe(e){let{components:n,...t}=e;return(0,s.yg)(BZe,(0,p.A)({},SZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}GZe.isMDXComponent=!0;const EZe={toc:[]},OZe="wrapper";function UZe(e){let{components:n,...t}=e;return(0,s.yg)(OZe,(0,p.A)({},EZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}UZe.isMDXComponent=!0;const FZe={toc:[]},VZe="wrapper";function qZe(e){let{components:n,...t}=e;return(0,s.yg)(VZe,(0,p.A)({},FZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}qZe.isMDXComponent=!0;const jZe={toc:[]},HZe="wrapper";function YZe(e){let{components:n,...t}=e;return(0,s.yg)(HZe,(0,p.A)({},jZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}YZe.isMDXComponent=!0;const QZe={toc:[]},$Ze="wrapper";function KZe(e){let{components:n,...t}=e;return(0,s.yg)($Ze,(0,p.A)({},QZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}KZe.isMDXComponent=!0;const JZe={toc:[]},ZZe="wrapper";function e0e(e){let{components:n,...t}=e;return(0,s.yg)(ZZe,(0,p.A)({},JZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}e0e.isMDXComponent=!0;const n0e={toc:[]},t0e="wrapper";function o0e(e){let{components:n,...t}=e;return(0,s.yg)(t0e,(0,p.A)({},n0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}o0e.isMDXComponent=!0;const p0e={toc:[]},r0e="wrapper";function s0e(e){let{components:n,...t}=e;return(0,s.yg)(r0e,(0,p.A)({},p0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}s0e.isMDXComponent=!0;const c0e={toc:[]},a0e="wrapper";function i0e(e){let{components:n,...t}=e;return(0,s.yg)(a0e,(0,p.A)({},c0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}i0e.isMDXComponent=!0;const l0e={toc:[]},u0e="wrapper";function m0e(e){let{components:n,...t}=e;return(0,s.yg)(u0e,(0,p.A)({},l0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}m0e.isMDXComponent=!0;const y0e={toc:[]},d0e="wrapper";function h0e(e){let{components:n,...t}=e;return(0,s.yg)(d0e,(0,p.A)({},y0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}h0e.isMDXComponent=!0;const g0e={toc:[]},f0e="wrapper";function D0e(e){let{components:n,...t}=e;return(0,s.yg)(f0e,(0,p.A)({},g0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}D0e.isMDXComponent=!0;const M0e={toc:[]},X0e="wrapper";function _0e(e){let{components:n,...t}=e;return(0,s.yg)(X0e,(0,p.A)({},M0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}_0e.isMDXComponent=!0;const w0e={toc:[]},T0e="wrapper";function C0e(e){let{components:n,...t}=e;return(0,s.yg)(T0e,(0,p.A)({},w0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}C0e.isMDXComponent=!0;const x0e={toc:[]},A0e="wrapper";function v0e(e){let{components:n,...t}=e;return(0,s.yg)(A0e,(0,p.A)({},x0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}v0e.isMDXComponent=!0;const L0e={toc:[]},b0e="wrapper";function N0e(e){let{components:n,...t}=e;return(0,s.yg)(b0e,(0,p.A)({},L0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}N0e.isMDXComponent=!0;const k0e={toc:[]},z0e="wrapper";function P0e(e){let{components:n,...t}=e;return(0,s.yg)(z0e,(0,p.A)({},k0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}P0e.isMDXComponent=!0;const I0e={toc:[]},R0e="wrapper";function W0e(e){let{components:n,...t}=e;return(0,s.yg)(R0e,(0,p.A)({},I0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}W0e.isMDXComponent=!0;const S0e={toc:[]},B0e="wrapper";function G0e(e){let{components:n,...t}=e;return(0,s.yg)(B0e,(0,p.A)({},S0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}G0e.isMDXComponent=!0;const E0e={toc:[]},O0e="wrapper";function U0e(e){let{components:n,...t}=e;return(0,s.yg)(O0e,(0,p.A)({},E0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}U0e.isMDXComponent=!0;const F0e={toc:[]},V0e="wrapper";function q0e(e){let{components:n,...t}=e;return(0,s.yg)(V0e,(0,p.A)({},F0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}q0e.isMDXComponent=!0;const j0e={toc:[]},H0e="wrapper";function Y0e(e){let{components:n,...t}=e;return(0,s.yg)(H0e,(0,p.A)({},j0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Y0e.isMDXComponent=!0;const Q0e={toc:[]},$0e="wrapper";function K0e(e){let{components:n,...t}=e;return(0,s.yg)($0e,(0,p.A)({},Q0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}K0e.isMDXComponent=!0;const J0e={toc:[]},Z0e="wrapper";function e8e(e){let{components:n,...t}=e;return(0,s.yg)(Z0e,(0,p.A)({},J0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}e8e.isMDXComponent=!0;const n8e={toc:[]},t8e="wrapper";function o8e(e){let{components:n,...t}=e;return(0,s.yg)(t8e,(0,p.A)({},n8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}o8e.isMDXComponent=!0;const p8e={toc:[]},r8e="wrapper";function s8e(e){let{components:n,...t}=e;return(0,s.yg)(r8e,(0,p.A)({},p8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}s8e.isMDXComponent=!0;const c8e={toc:[]},a8e="wrapper";function i8e(e){let{components:n,...t}=e;return(0,s.yg)(a8e,(0,p.A)({},c8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}i8e.isMDXComponent=!0;const l8e={toc:[]},u8e="wrapper";function m8e(e){let{components:n,...t}=e;return(0,s.yg)(u8e,(0,p.A)({},l8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}m8e.isMDXComponent=!0;const y8e={toc:[]},d8e="wrapper";function h8e(e){let{components:n,...t}=e;return(0,s.yg)(d8e,(0,p.A)({},y8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}h8e.isMDXComponent=!0;const g8e={toc:[]},f8e="wrapper";function D8e(e){let{components:n,...t}=e;return(0,s.yg)(f8e,(0,p.A)({},g8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}D8e.isMDXComponent=!0;const M8e={toc:[]},X8e="wrapper";function _8e(e){let{components:n,...t}=e;return(0,s.yg)(X8e,(0,p.A)({},M8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}_8e.isMDXComponent=!0;const w8e={toc:[]},T8e="wrapper";function C8e(e){let{components:n,...t}=e;return(0,s.yg)(T8e,(0,p.A)({},w8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}C8e.isMDXComponent=!0;const x8e={toc:[]},A8e="wrapper";function v8e(e){let{components:n,...t}=e;return(0,s.yg)(A8e,(0,p.A)({},x8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}v8e.isMDXComponent=!0;const L8e={toc:[]},b8e="wrapper";function N8e(e){let{components:n,...t}=e;return(0,s.yg)(b8e,(0,p.A)({},L8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}N8e.isMDXComponent=!0;const k8e={toc:[]},z8e="wrapper";function P8e(e){let{components:n,...t}=e;return(0,s.yg)(z8e,(0,p.A)({},k8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}P8e.isMDXComponent=!0;const I8e={toc:[]},R8e="wrapper";function W8e(e){let{components:n,...t}=e;return(0,s.yg)(R8e,(0,p.A)({},I8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}W8e.isMDXComponent=!0;const S8e={toc:[]},B8e="wrapper";function G8e(e){let{components:n,...t}=e;return(0,s.yg)(B8e,(0,p.A)({},S8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}G8e.isMDXComponent=!0;const E8e={toc:[]},O8e="wrapper";function U8e(e){let{components:n,...t}=e;return(0,s.yg)(O8e,(0,p.A)({},E8e,t,{components:n,mdxType:"MDXLayout"}))}U8e.isMDXComponent=!0;const F8e={toc:[]},V8e="wrapper";function q8e(e){let{components:n,...t}=e;return(0,s.yg)(V8e,(0,p.A)({},F8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}q8e.isMDXComponent=!0;const j8e={toc:[]},H8e="wrapper";function Y8e(e){let{components:n,...t}=e;return(0,s.yg)(H8e,(0,p.A)({},j8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Y8e.isMDXComponent=!0;const Q8e={toc:[]},$8e="wrapper";function K8e(e){let{components:n,...t}=e;return(0,s.yg)($8e,(0,p.A)({},Q8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}K8e.isMDXComponent=!0;const J8e={toc:[]},Z8e="wrapper";function e2e(e){let{components:n,...t}=e;return(0,s.yg)(Z8e,(0,p.A)({},J8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}e2e.isMDXComponent=!0;const n2e={toc:[]},t2e="wrapper";function o2e(e){let{components:n,...t}=e;return(0,s.yg)(t2e,(0,p.A)({},n2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}o2e.isMDXComponent=!0;const p2e={toc:[]},r2e="wrapper";function s2e(e){let{components:n,...t}=e;return(0,s.yg)(r2e,(0,p.A)({},p2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}s2e.isMDXComponent=!0;const c2e={toc:[]},a2e="wrapper";function i2e(e){let{components:n,...t}=e;return(0,s.yg)(a2e,(0,p.A)({},c2e,t,{components:n,mdxType:"MDXLayout"}))}i2e.isMDXComponent=!0;const l2e={toc:[]},u2e="wrapper";function m2e(e){let{components:n,...t}=e;return(0,s.yg)(u2e,(0,p.A)({},l2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}m2e.isMDXComponent=!0;const y2e={toc:[]},d2e="wrapper";function h2e(e){let{components:n,...t}=e;return(0,s.yg)(d2e,(0,p.A)({},y2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}h2e.isMDXComponent=!0;const g2e={toc:[]},f2e="wrapper";function D2e(e){let{components:n,...t}=e;return(0,s.yg)(f2e,(0,p.A)({},g2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}D2e.isMDXComponent=!0;const M2e={toc:[]},X2e="wrapper";function _2e(e){let{components:n,...t}=e;return(0,s.yg)(X2e,(0,p.A)({},M2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}_2e.isMDXComponent=!0;const w2e={toc:[]},T2e="wrapper";function C2e(e){let{components:n,...t}=e;return(0,s.yg)(T2e,(0,p.A)({},w2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}C2e.isMDXComponent=!0;const x2e={toc:[]},A2e="wrapper";function v2e(e){let{components:n,...t}=e;return(0,s.yg)(A2e,(0,p.A)({},x2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}v2e.isMDXComponent=!0;const L2e={toc:[]},b2e="wrapper";function N2e(e){let{components:n,...t}=e;return(0,s.yg)(b2e,(0,p.A)({},L2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}N2e.isMDXComponent=!0;const k2e={toc:[]},z2e="wrapper";function P2e(e){let{components:n,...t}=e;return(0,s.yg)(z2e,(0,p.A)({},k2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}P2e.isMDXComponent=!0;const I2e={toc:[]},R2e="wrapper";function W2e(e){let{components:n,...t}=e;return(0,s.yg)(R2e,(0,p.A)({},I2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}W2e.isMDXComponent=!0;const S2e={toc:[]},B2e="wrapper";function G2e(e){let{components:n,...t}=e;return(0,s.yg)(B2e,(0,p.A)({},S2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}G2e.isMDXComponent=!0;const E2e={toc:[]},O2e="wrapper";function U2e(e){let{components:n,...t}=e;return(0,s.yg)(O2e,(0,p.A)({},E2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}U2e.isMDXComponent=!0;const F2e={toc:[]},V2e="wrapper";function q2e(e){let{components:n,...t}=e;return(0,s.yg)(V2e,(0,p.A)({},F2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}q2e.isMDXComponent=!0;const j2e={toc:[]},H2e="wrapper";function Y2e(e){let{components:n,...t}=e;return(0,s.yg)(H2e,(0,p.A)({},j2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Y2e.isMDXComponent=!0;const Q2e={toc:[]},$2e="wrapper";function K2e(e){let{components:n,...t}=e;return(0,s.yg)($2e,(0,p.A)({},Q2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}K2e.isMDXComponent=!0;const J2e={toc:[]},Z2e="wrapper";function e3e(e){let{components:n,...t}=e;return(0,s.yg)(Z2e,(0,p.A)({},J2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}e3e.isMDXComponent=!0;const n3e={toc:[]},t3e="wrapper";function o3e(e){let{components:n,...t}=e;return(0,s.yg)(t3e,(0,p.A)({},n3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}o3e.isMDXComponent=!0;const p3e={toc:[]},r3e="wrapper";function s3e(e){let{components:n,...t}=e;return(0,s.yg)(r3e,(0,p.A)({},p3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}s3e.isMDXComponent=!0;const c3e={toc:[]},a3e="wrapper";function i3e(e){let{components:n,...t}=e;return(0,s.yg)(a3e,(0,p.A)({},c3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}i3e.isMDXComponent=!0;const l3e={toc:[]},u3e="wrapper";function m3e(e){let{components:n,...t}=e;return(0,s.yg)(u3e,(0,p.A)({},l3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}m3e.isMDXComponent=!0;const y3e={toc:[]},d3e="wrapper";function h3e(e){let{components:n,...t}=e;return(0,s.yg)(d3e,(0,p.A)({},y3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}h3e.isMDXComponent=!0;const g3e={toc:[]},f3e="wrapper";function D3e(e){let{components:n,...t}=e;return(0,s.yg)(f3e,(0,p.A)({},g3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}D3e.isMDXComponent=!0;const M3e={toc:[]},X3e="wrapper";function _3e(e){let{components:n,...t}=e;return(0,s.yg)(X3e,(0,p.A)({},M3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}_3e.isMDXComponent=!0;const w3e={toc:[]},T3e="wrapper";function C3e(e){let{components:n,...t}=e;return(0,s.yg)(T3e,(0,p.A)({},w3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}C3e.isMDXComponent=!0;const x3e={toc:[]},A3e="wrapper";function v3e(e){let{components:n,...t}=e;return(0,s.yg)(A3e,(0,p.A)({},x3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}v3e.isMDXComponent=!0;const L3e={toc:[]},b3e="wrapper";function N3e(e){let{components:n,...t}=e;return(0,s.yg)(b3e,(0,p.A)({},L3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}N3e.isMDXComponent=!0;const k3e={toc:[]},z3e="wrapper";function P3e(e){let{components:n,...t}=e;return(0,s.yg)(z3e,(0,p.A)({},k3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}P3e.isMDXComponent=!0;const I3e={toc:[]},R3e="wrapper";function W3e(e){let{components:n,...t}=e;return(0,s.yg)(R3e,(0,p.A)({},I3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}W3e.isMDXComponent=!0;const S3e={toc:[]},B3e="wrapper";function G3e(e){let{components:n,...t}=e;return(0,s.yg)(B3e,(0,p.A)({},S3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}G3e.isMDXComponent=!0;const E3e={toc:[]},O3e="wrapper";function U3e(e){let{components:n,...t}=e;return(0,s.yg)(O3e,(0,p.A)({},E3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}U3e.isMDXComponent=!0;const F3e={toc:[]},V3e="wrapper";function q3e(e){let{components:n,...t}=e;return(0,s.yg)(V3e,(0,p.A)({},F3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}q3e.isMDXComponent=!0;const j3e={toc:[]},H3e="wrapper";function Y3e(e){let{components:n,...t}=e;return(0,s.yg)(H3e,(0,p.A)({},j3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Y3e.isMDXComponent=!0;const Q3e={toc:[]},$3e="wrapper";function K3e(e){let{components:n,...t}=e;return(0,s.yg)($3e,(0,p.A)({},Q3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}K3e.isMDXComponent=!0;const J3e={toc:[]},Z3e="wrapper";function e1e(e){let{components:n,...t}=e;return(0,s.yg)(Z3e,(0,p.A)({},J3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}e1e.isMDXComponent=!0;const n1e={toc:[]},t1e="wrapper";function o1e(e){let{components:n,...t}=e;return(0,s.yg)(t1e,(0,p.A)({},n1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}o1e.isMDXComponent=!0;const p1e={toc:[]},r1e="wrapper";function s1e(e){let{components:n,...t}=e;return(0,s.yg)(r1e,(0,p.A)({},p1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}s1e.isMDXComponent=!0;const c1e={toc:[]},a1e="wrapper";function i1e(e){let{components:n,...t}=e;return(0,s.yg)(a1e,(0,p.A)({},c1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}i1e.isMDXComponent=!0;const l1e={toc:[]},u1e="wrapper";function m1e(e){let{components:n,...t}=e;return(0,s.yg)(u1e,(0,p.A)({},l1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}m1e.isMDXComponent=!0;const y1e={toc:[]},d1e="wrapper";function h1e(e){let{components:n,...t}=e;return(0,s.yg)(d1e,(0,p.A)({},y1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}h1e.isMDXComponent=!0;const g1e={toc:[]},f1e="wrapper";function D1e(e){let{components:n,...t}=e;return(0,s.yg)(f1e,(0,p.A)({},g1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}D1e.isMDXComponent=!0;const M1e={toc:[]},X1e="wrapper";function _1e(e){let{components:n,...t}=e;return(0,s.yg)(X1e,(0,p.A)({},M1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}_1e.isMDXComponent=!0;const w1e={toc:[]},T1e="wrapper";function C1e(e){let{components:n,...t}=e;return(0,s.yg)(T1e,(0,p.A)({},w1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}C1e.isMDXComponent=!0;const x1e={toc:[]},A1e="wrapper";function v1e(e){let{components:n,...t}=e;return(0,s.yg)(A1e,(0,p.A)({},x1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}v1e.isMDXComponent=!0;const L1e={toc:[]},b1e="wrapper";function N1e(e){let{components:n,...t}=e;return(0,s.yg)(b1e,(0,p.A)({},L1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}N1e.isMDXComponent=!0;const k1e={toc:[]},z1e="wrapper";function P1e(e){let{components:n,...t}=e;return(0,s.yg)(z1e,(0,p.A)({},k1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}P1e.isMDXComponent=!0;const I1e={toc:[]},R1e="wrapper";function W1e(e){let{components:n,...t}=e;return(0,s.yg)(R1e,(0,p.A)({},I1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}W1e.isMDXComponent=!0;const S1e={toc:[]},B1e="wrapper";function G1e(e){let{components:n,...t}=e;return(0,s.yg)(B1e,(0,p.A)({},S1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}G1e.isMDXComponent=!0;const E1e={toc:[]},O1e="wrapper";function U1e(e){let{components:n,...t}=e;return(0,s.yg)(O1e,(0,p.A)({},E1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}U1e.isMDXComponent=!0;const F1e={toc:[]},V1e="wrapper";function q1e(e){let{components:n,...t}=e;return(0,s.yg)(V1e,(0,p.A)({},F1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}q1e.isMDXComponent=!0;const j1e={toc:[]},H1e="wrapper";function Y1e(e){let{components:n,...t}=e;return(0,s.yg)(H1e,(0,p.A)({},j1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Y1e.isMDXComponent=!0;const Q1e={toc:[]},$1e="wrapper";function K1e(e){let{components:n,...t}=e;return(0,s.yg)($1e,(0,p.A)({},Q1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}K1e.isMDXComponent=!0;const J1e={toc:[]},Z1e="wrapper";function e4e(e){let{components:n,...t}=e;return(0,s.yg)(Z1e,(0,p.A)({},J1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}e4e.isMDXComponent=!0;const n4e={toc:[]},t4e="wrapper";function o4e(e){let{components:n,...t}=e;return(0,s.yg)(t4e,(0,p.A)({},n4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}o4e.isMDXComponent=!0;const p4e={toc:[]},r4e="wrapper";function s4e(e){let{components:n,...t}=e;return(0,s.yg)(r4e,(0,p.A)({},p4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}s4e.isMDXComponent=!0;const c4e={toc:[]},a4e="wrapper";function i4e(e){let{components:n,...t}=e;return(0,s.yg)(a4e,(0,p.A)({},c4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}i4e.isMDXComponent=!0;const l4e={toc:[]},u4e="wrapper";function m4e(e){let{components:n,...t}=e;return(0,s.yg)(u4e,(0,p.A)({},l4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}m4e.isMDXComponent=!0;const y4e={toc:[]},d4e="wrapper";function h4e(e){let{components:n,...t}=e;return(0,s.yg)(d4e,(0,p.A)({},y4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}h4e.isMDXComponent=!0;const g4e={toc:[]},f4e="wrapper";function D4e(e){let{components:n,...t}=e;return(0,s.yg)(f4e,(0,p.A)({},g4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}D4e.isMDXComponent=!0;const M4e={toc:[]},X4e="wrapper";function _4e(e){let{components:n,...t}=e;return(0,s.yg)(X4e,(0,p.A)({},M4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_4e.isMDXComponent=!0;const w4e={toc:[]},T4e="wrapper";function C4e(e){let{components:n,...t}=e;return(0,s.yg)(T4e,(0,p.A)({},w4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}C4e.isMDXComponent=!0;const x4e={toc:[]},A4e="wrapper";function v4e(e){let{components:n,...t}=e;return(0,s.yg)(A4e,(0,p.A)({},x4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}v4e.isMDXComponent=!0;const L4e={toc:[]},b4e="wrapper";function N4e(e){let{components:n,...t}=e;return(0,s.yg)(b4e,(0,p.A)({},L4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}N4e.isMDXComponent=!0;const k4e={toc:[]},z4e="wrapper";function P4e(e){let{components:n,...t}=e;return(0,s.yg)(z4e,(0,p.A)({},k4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}P4e.isMDXComponent=!0;const I4e={toc:[]},R4e="wrapper";function W4e(e){let{components:n,...t}=e;return(0,s.yg)(R4e,(0,p.A)({},I4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}W4e.isMDXComponent=!0;const S4e={toc:[]},B4e="wrapper";function G4e(e){let{components:n,...t}=e;return(0,s.yg)(B4e,(0,p.A)({},S4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}G4e.isMDXComponent=!0;const E4e={toc:[]},O4e="wrapper";function U4e(e){let{components:n,...t}=e;return(0,s.yg)(O4e,(0,p.A)({},E4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}U4e.isMDXComponent=!0;const F4e={toc:[]},V4e="wrapper";function q4e(e){let{components:n,...t}=e;return(0,s.yg)(V4e,(0,p.A)({},F4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}q4e.isMDXComponent=!0;const j4e={toc:[]},H4e="wrapper";function Y4e(e){let{components:n,...t}=e;return(0,s.yg)(H4e,(0,p.A)({},j4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Y4e.isMDXComponent=!0;const Q4e={toc:[]},$4e="wrapper";function K4e(e){let{components:n,...t}=e;return(0,s.yg)($4e,(0,p.A)({},Q4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}K4e.isMDXComponent=!0;const J4e={toc:[]},Z4e="wrapper";function e6e(e){let{components:n,...t}=e;return(0,s.yg)(Z4e,(0,p.A)({},J4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}e6e.isMDXComponent=!0;const n6e={toc:[]},t6e="wrapper";function o6e(e){let{components:n,...t}=e;return(0,s.yg)(t6e,(0,p.A)({},n6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}o6e.isMDXComponent=!0;const p6e={toc:[]},r6e="wrapper";function s6e(e){let{components:n,...t}=e;return(0,s.yg)(r6e,(0,p.A)({},p6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}s6e.isMDXComponent=!0;const c6e={toc:[]},a6e="wrapper";function i6e(e){let{components:n,...t}=e;return(0,s.yg)(a6e,(0,p.A)({},c6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}i6e.isMDXComponent=!0;const l6e={toc:[]},u6e="wrapper";function m6e(e){let{components:n,...t}=e;return(0,s.yg)(u6e,(0,p.A)({},l6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}m6e.isMDXComponent=!0;const y6e={toc:[]},d6e="wrapper";function h6e(e){let{components:n,...t}=e;return(0,s.yg)(d6e,(0,p.A)({},y6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}h6e.isMDXComponent=!0;const g6e={toc:[]},f6e="wrapper";function D6e(e){let{components:n,...t}=e;return(0,s.yg)(f6e,(0,p.A)({},g6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}D6e.isMDXComponent=!0;const M6e={toc:[]},X6e="wrapper";function _6e(e){let{components:n,...t}=e;return(0,s.yg)(X6e,(0,p.A)({},M6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}_6e.isMDXComponent=!0;const w6e={toc:[]},T6e="wrapper";function C6e(e){let{components:n,...t}=e;return(0,s.yg)(T6e,(0,p.A)({},w6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}C6e.isMDXComponent=!0;const x6e={toc:[]},A6e="wrapper";function v6e(e){let{components:n,...t}=e;return(0,s.yg)(A6e,(0,p.A)({},x6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}v6e.isMDXComponent=!0;const L6e={toc:[]},b6e="wrapper";function N6e(e){let{components:n,...t}=e;return(0,s.yg)(b6e,(0,p.A)({},L6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}N6e.isMDXComponent=!0;const k6e={toc:[]},z6e="wrapper";function P6e(e){let{components:n,...t}=e;return(0,s.yg)(z6e,(0,p.A)({},k6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}P6e.isMDXComponent=!0;const I6e={toc:[]},R6e="wrapper";function W6e(e){let{components:n,...t}=e;return(0,s.yg)(R6e,(0,p.A)({},I6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}W6e.isMDXComponent=!0;const S6e={toc:[]},B6e="wrapper";function G6e(e){let{components:n,...t}=e;return(0,s.yg)(B6e,(0,p.A)({},S6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}G6e.isMDXComponent=!0;const E6e={toc:[]},O6e="wrapper";function U6e(e){let{components:n,...t}=e;return(0,s.yg)(O6e,(0,p.A)({},E6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}U6e.isMDXComponent=!0;const F6e={toc:[]},V6e="wrapper";function q6e(e){let{components:n,...t}=e;return(0,s.yg)(V6e,(0,p.A)({},F6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}q6e.isMDXComponent=!0;const j6e={toc:[]},H6e="wrapper";function Y6e(e){let{components:n,...t}=e;return(0,s.yg)(H6e,(0,p.A)({},j6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Y6e.isMDXComponent=!0;const Q6e={toc:[]},$6e="wrapper";function K6e(e){let{components:n,...t}=e;return(0,s.yg)($6e,(0,p.A)({},Q6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}K6e.isMDXComponent=!0;const J6e={toc:[]},Z6e="wrapper";function e5e(e){let{components:n,...t}=e;return(0,s.yg)(Z6e,(0,p.A)({},J6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}e5e.isMDXComponent=!0;const n5e={toc:[]},t5e="wrapper";function o5e(e){let{components:n,...t}=e;return(0,s.yg)(t5e,(0,p.A)({},n5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}o5e.isMDXComponent=!0;const p5e={toc:[]},r5e="wrapper";function s5e(e){let{components:n,...t}=e;return(0,s.yg)(r5e,(0,p.A)({},p5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}s5e.isMDXComponent=!0;const c5e={toc:[]},a5e="wrapper";function i5e(e){let{components:n,...t}=e;return(0,s.yg)(a5e,(0,p.A)({},c5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}i5e.isMDXComponent=!0;const l5e={toc:[]},u5e="wrapper";function m5e(e){let{components:n,...t}=e;return(0,s.yg)(u5e,(0,p.A)({},l5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}m5e.isMDXComponent=!0;const y5e={toc:[]},d5e="wrapper";function h5e(e){let{components:n,...t}=e;return(0,s.yg)(d5e,(0,p.A)({},y5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}h5e.isMDXComponent=!0;const g5e={toc:[]},f5e="wrapper";function D5e(e){let{components:n,...t}=e;return(0,s.yg)(f5e,(0,p.A)({},g5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}D5e.isMDXComponent=!0;const M5e={toc:[]},X5e="wrapper";function _5e(e){let{components:n,...t}=e;return(0,s.yg)(X5e,(0,p.A)({},M5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}_5e.isMDXComponent=!0;const w5e={toc:[]},T5e="wrapper";function C5e(e){let{components:n,...t}=e;return(0,s.yg)(T5e,(0,p.A)({},w5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}C5e.isMDXComponent=!0;const x5e={toc:[]},A5e="wrapper";function v5e(e){let{components:n,...t}=e;return(0,s.yg)(A5e,(0,p.A)({},x5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}v5e.isMDXComponent=!0;const L5e={toc:[]},b5e="wrapper";function N5e(e){let{components:n,...t}=e;return(0,s.yg)(b5e,(0,p.A)({},L5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}N5e.isMDXComponent=!0;const k5e={toc:[]},z5e="wrapper";function P5e(e){let{components:n,...t}=e;return(0,s.yg)(z5e,(0,p.A)({},k5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}P5e.isMDXComponent=!0;const I5e={toc:[]},R5e="wrapper";function W5e(e){let{components:n,...t}=e;return(0,s.yg)(R5e,(0,p.A)({},I5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}W5e.isMDXComponent=!0;const S5e={toc:[]},B5e="wrapper";function G5e(e){let{components:n,...t}=e;return(0,s.yg)(B5e,(0,p.A)({},S5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}G5e.isMDXComponent=!0;const E5e={toc:[]},O5e="wrapper";function U5e(e){let{components:n,...t}=e;return(0,s.yg)(O5e,(0,p.A)({},E5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}U5e.isMDXComponent=!0;const F5e={toc:[]},V5e="wrapper";function q5e(e){let{components:n,...t}=e;return(0,s.yg)(V5e,(0,p.A)({},F5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}q5e.isMDXComponent=!0;const j5e={toc:[]},H5e="wrapper";function Y5e(e){let{components:n,...t}=e;return(0,s.yg)(H5e,(0,p.A)({},j5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Y5e.isMDXComponent=!0;const Q5e={toc:[]},$5e="wrapper";function K5e(e){let{components:n,...t}=e;return(0,s.yg)($5e,(0,p.A)({},Q5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}K5e.isMDXComponent=!0;const J5e={toc:[]},Z5e="wrapper";function e7e(e){let{components:n,...t}=e;return(0,s.yg)(Z5e,(0,p.A)({},J5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}e7e.isMDXComponent=!0;const n7e={toc:[]},t7e="wrapper";function o7e(e){let{components:n,...t}=e;return(0,s.yg)(t7e,(0,p.A)({},n7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}o7e.isMDXComponent=!0;const p7e={toc:[]},r7e="wrapper";function s7e(e){let{components:n,...t}=e;return(0,s.yg)(r7e,(0,p.A)({},p7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}s7e.isMDXComponent=!0;const c7e={toc:[]},a7e="wrapper";function i7e(e){let{components:n,...t}=e;return(0,s.yg)(a7e,(0,p.A)({},c7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}i7e.isMDXComponent=!0;const l7e={toc:[]},u7e="wrapper";function m7e(e){let{components:n,...t}=e;return(0,s.yg)(u7e,(0,p.A)({},l7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}m7e.isMDXComponent=!0;const y7e={toc:[]},d7e="wrapper";function h7e(e){let{components:n,...t}=e;return(0,s.yg)(d7e,(0,p.A)({},y7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}h7e.isMDXComponent=!0;const g7e={toc:[]},f7e="wrapper";function D7e(e){let{components:n,...t}=e;return(0,s.yg)(f7e,(0,p.A)({},g7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}D7e.isMDXComponent=!0;const M7e={toc:[]},X7e="wrapper";function _7e(e){let{components:n,...t}=e;return(0,s.yg)(X7e,(0,p.A)({},M7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}_7e.isMDXComponent=!0;const w7e={toc:[]},T7e="wrapper";function C7e(e){let{components:n,...t}=e;return(0,s.yg)(T7e,(0,p.A)({},w7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}C7e.isMDXComponent=!0;const x7e={toc:[]},A7e="wrapper";function v7e(e){let{components:n,...t}=e;return(0,s.yg)(A7e,(0,p.A)({},x7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}v7e.isMDXComponent=!0;const L7e={toc:[]},b7e="wrapper";function N7e(e){let{components:n,...t}=e;return(0,s.yg)(b7e,(0,p.A)({},L7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}N7e.isMDXComponent=!0;const k7e={toc:[]},z7e="wrapper";function P7e(e){let{components:n,...t}=e;return(0,s.yg)(z7e,(0,p.A)({},k7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}P7e.isMDXComponent=!0;const I7e={toc:[]},R7e="wrapper";function W7e(e){let{components:n,...t}=e;return(0,s.yg)(R7e,(0,p.A)({},I7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}W7e.isMDXComponent=!0;const S7e={toc:[]},B7e="wrapper";function G7e(e){let{components:n,...t}=e;return(0,s.yg)(B7e,(0,p.A)({},S7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}G7e.isMDXComponent=!0;const E7e={toc:[]},O7e="wrapper";function U7e(e){let{components:n,...t}=e;return(0,s.yg)(O7e,(0,p.A)({},E7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}U7e.isMDXComponent=!0;const F7e={toc:[]},V7e="wrapper";function q7e(e){let{components:n,...t}=e;return(0,s.yg)(V7e,(0,p.A)({},F7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}q7e.isMDXComponent=!0;const j7e={toc:[]},H7e="wrapper";function Y7e(e){let{components:n,...t}=e;return(0,s.yg)(H7e,(0,p.A)({},j7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Y7e.isMDXComponent=!0;const Q7e={toc:[]},$7e="wrapper";function K7e(e){let{components:n,...t}=e;return(0,s.yg)($7e,(0,p.A)({},Q7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}K7e.isMDXComponent=!0;const J7e={toc:[]},Z7e="wrapper";function e9e(e){let{components:n,...t}=e;return(0,s.yg)(Z7e,(0,p.A)({},J7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}e9e.isMDXComponent=!0;const n9e={toc:[]},t9e="wrapper";function o9e(e){let{components:n,...t}=e;return(0,s.yg)(t9e,(0,p.A)({},n9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}o9e.isMDXComponent=!0;const p9e={toc:[]},r9e="wrapper";function s9e(e){let{components:n,...t}=e;return(0,s.yg)(r9e,(0,p.A)({},p9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}s9e.isMDXComponent=!0;const c9e={toc:[]},a9e="wrapper";function i9e(e){let{components:n,...t}=e;return(0,s.yg)(a9e,(0,p.A)({},c9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}i9e.isMDXComponent=!0;const l9e={toc:[]},u9e="wrapper";function m9e(e){let{components:n,...t}=e;return(0,s.yg)(u9e,(0,p.A)({},l9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}m9e.isMDXComponent=!0;const y9e={toc:[]},d9e="wrapper";function h9e(e){let{components:n,...t}=e;return(0,s.yg)(d9e,(0,p.A)({},y9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}h9e.isMDXComponent=!0;const g9e={toc:[]},f9e="wrapper";function D9e(e){let{components:n,...t}=e;return(0,s.yg)(f9e,(0,p.A)({},g9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}D9e.isMDXComponent=!0;const M9e={toc:[]},X9e="wrapper";function _9e(e){let{components:n,...t}=e;return(0,s.yg)(X9e,(0,p.A)({},M9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}_9e.isMDXComponent=!0;const w9e={toc:[]},T9e="wrapper";function C9e(e){let{components:n,...t}=e;return(0,s.yg)(T9e,(0,p.A)({},w9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}C9e.isMDXComponent=!0;const x9e={toc:[]},A9e="wrapper";function v9e(e){let{components:n,...t}=e;return(0,s.yg)(A9e,(0,p.A)({},x9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}v9e.isMDXComponent=!0;const L9e={toc:[]},b9e="wrapper";function N9e(e){let{components:n,...t}=e;return(0,s.yg)(b9e,(0,p.A)({},L9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}N9e.isMDXComponent=!0;const k9e={toc:[]},z9e="wrapper";function P9e(e){let{components:n,...t}=e;return(0,s.yg)(z9e,(0,p.A)({},k9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}P9e.isMDXComponent=!0;const I9e={toc:[]},R9e="wrapper";function W9e(e){let{components:n,...t}=e;return(0,s.yg)(R9e,(0,p.A)({},I9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}W9e.isMDXComponent=!0;const S9e={toc:[]},B9e="wrapper";function G9e(e){let{components:n,...t}=e;return(0,s.yg)(B9e,(0,p.A)({},S9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}G9e.isMDXComponent=!0;const E9e={toc:[]},O9e="wrapper";function U9e(e){let{components:n,...t}=e;return(0,s.yg)(O9e,(0,p.A)({},E9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}U9e.isMDXComponent=!0;const F9e={toc:[]},V9e="wrapper";function q9e(e){let{components:n,...t}=e;return(0,s.yg)(V9e,(0,p.A)({},F9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}q9e.isMDXComponent=!0;const j9e={toc:[]},H9e="wrapper";function Y9e(e){let{components:n,...t}=e;return(0,s.yg)(H9e,(0,p.A)({},j9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Y9e.isMDXComponent=!0;const Q9e={toc:[]},$9e="wrapper";function K9e(e){let{components:n,...t}=e;return(0,s.yg)($9e,(0,p.A)({},Q9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}K9e.isMDXComponent=!0;const J9e={toc:[]},Z9e="wrapper";function een(e){let{components:n,...t}=e;return(0,s.yg)(Z9e,(0,p.A)({},J9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}een.isMDXComponent=!0;const nen={toc:[]},ten="wrapper";function oen(e){let{components:n,...t}=e;return(0,s.yg)(ten,(0,p.A)({},nen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}oen.isMDXComponent=!0;const pen={toc:[]},ren="wrapper";function sen(e){let{components:n,...t}=e;return(0,s.yg)(ren,(0,p.A)({},pen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sen.isMDXComponent=!0;const cen={toc:[]},aen="wrapper";function ien(e){let{components:n,...t}=e;return(0,s.yg)(aen,(0,p.A)({},cen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ien.isMDXComponent=!0;const len={toc:[]},uen="wrapper";function men(e){let{components:n,...t}=e;return(0,s.yg)(uen,(0,p.A)({},len,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}men.isMDXComponent=!0;const yen={toc:[]},den="wrapper";function hen(e){let{components:n,...t}=e;return(0,s.yg)(den,(0,p.A)({},yen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}hen.isMDXComponent=!0;const gen={toc:[]},fen="wrapper";function Den(e){let{components:n,...t}=e;return(0,s.yg)(fen,(0,p.A)({},gen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Den.isMDXComponent=!0;const Men={toc:[]},Xen="wrapper";function _en(e){let{components:n,...t}=e;return(0,s.yg)(Xen,(0,p.A)({},Men,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}_en.isMDXComponent=!0;const wen={toc:[]},Ten="wrapper";function Cen(e){let{components:n,...t}=e;return(0,s.yg)(Ten,(0,p.A)({},wen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Cen.isMDXComponent=!0;const xen={toc:[]},Aen="wrapper";function ven(e){let{components:n,...t}=e;return(0,s.yg)(Aen,(0,p.A)({},xen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}ven.isMDXComponent=!0;const Len={toc:[]},ben="wrapper";function Nen(e){let{components:n,...t}=e;return(0,s.yg)(ben,(0,p.A)({},Len,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Nen.isMDXComponent=!0;const ken={toc:[]},zen="wrapper";function Pen(e){let{components:n,...t}=e;return(0,s.yg)(zen,(0,p.A)({},ken,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Pen.isMDXComponent=!0;const Ien={toc:[]},Ren="wrapper";function Wen(e){let{components:n,...t}=e;return(0,s.yg)(Ren,(0,p.A)({},Ien,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Wen.isMDXComponent=!0;const Sen={toc:[]},Ben="wrapper";function Gen(e){let{components:n,...t}=e;return(0,s.yg)(Ben,(0,p.A)({},Sen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Gen.isMDXComponent=!0;const Een={toc:[]},Oen="wrapper";function Uen(e){let{components:n,...t}=e;return(0,s.yg)(Oen,(0,p.A)({},Een,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Uen.isMDXComponent=!0;const Fen={toc:[]},Ven="wrapper";function qen(e){let{components:n,...t}=e;return(0,s.yg)(Ven,(0,p.A)({},Fen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}qen.isMDXComponent=!0;const jen={toc:[]},Hen="wrapper";function Yen(e){let{components:n,...t}=e;return(0,s.yg)(Hen,(0,p.A)({},jen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Yen.isMDXComponent=!0;const Qen={toc:[]},$en="wrapper";function Ken(e){let{components:n,...t}=e;return(0,s.yg)($en,(0,p.A)({},Qen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Ken.isMDXComponent=!0;const Jen={toc:[]},Zen="wrapper";function enn(e){let{components:n,...t}=e;return(0,s.yg)(Zen,(0,p.A)({},Jen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}enn.isMDXComponent=!0;const nnn={toc:[]},tnn="wrapper";function onn(e){let{components:n,...t}=e;return(0,s.yg)(tnn,(0,p.A)({},nnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}onn.isMDXComponent=!0;const pnn={toc:[]},rnn="wrapper";function snn(e){let{components:n,...t}=e;return(0,s.yg)(rnn,(0,p.A)({},pnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}snn.isMDXComponent=!0;const cnn={toc:[]},ann="wrapper";function inn(e){let{components:n,...t}=e;return(0,s.yg)(ann,(0,p.A)({},cnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}inn.isMDXComponent=!0;const lnn={toc:[]},unn="wrapper";function mnn(e){let{components:n,...t}=e;return(0,s.yg)(unn,(0,p.A)({},lnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}mnn.isMDXComponent=!0;const ynn={toc:[]},dnn="wrapper";function hnn(e){let{components:n,...t}=e;return(0,s.yg)(dnn,(0,p.A)({},ynn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}hnn.isMDXComponent=!0;const gnn={toc:[]},fnn="wrapper";function Dnn(e){let{components:n,...t}=e;return(0,s.yg)(fnn,(0,p.A)({},gnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Dnn.isMDXComponent=!0;const Mnn={toc:[]},Xnn="wrapper";function _nn(e){let{components:n,...t}=e;return(0,s.yg)(Xnn,(0,p.A)({},Mnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}_nn.isMDXComponent=!0;const wnn={toc:[]},Tnn="wrapper";function Cnn(e){let{components:n,...t}=e;return(0,s.yg)(Tnn,(0,p.A)({},wnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Cnn.isMDXComponent=!0;const xnn={toc:[]},Ann="wrapper";function vnn(e){let{components:n,...t}=e;return(0,s.yg)(Ann,(0,p.A)({},xnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}vnn.isMDXComponent=!0;const Lnn={toc:[]},bnn="wrapper";function Nnn(e){let{components:n,...t}=e;return(0,s.yg)(bnn,(0,p.A)({},Lnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@revideo/2d';\nimport {all, createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}Nnn.isMDXComponent=!0;const knn={toc:[]},znn="wrapper";function Pnn(e){let{components:n,...t}=e;return(0,s.yg)(znn,(0,p.A)({},knn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a two-dimensional grid."))}Pnn.isMDXComponent=!0;const Inn={toc:[]},Rnn="wrapper";function Wnn(e){let{components:n,...t}=e;return(0,s.yg)(Rnn,(0,p.A)({},Inn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Wnn.isMDXComponent=!0;const Snn={toc:[]},Bnn="wrapper";function Gnn(e){let{components:n,...t}=e;return(0,s.yg)(Bnn,(0,p.A)({},Snn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Gnn.isMDXComponent=!0;const Enn={toc:[]},Onn="wrapper";function Unn(e){let{components:n,...t}=e;return(0,s.yg)(Onn,(0,p.A)({},Enn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Unn.isMDXComponent=!0;const Fnn={toc:[]},Vnn="wrapper";function qnn(e){let{components:n,...t}=e;return(0,s.yg)(Vnn,(0,p.A)({},Fnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}qnn.isMDXComponent=!0;const jnn={toc:[]},Hnn="wrapper";function Ynn(e){let{components:n,...t}=e;return(0,s.yg)(Hnn,(0,p.A)({},jnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Ynn.isMDXComponent=!0;const Qnn={toc:[]},$nn="wrapper";function Knn(e){let{components:n,...t}=e;return(0,s.yg)($nn,(0,p.A)({},Qnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Knn.isMDXComponent=!0;const Jnn={toc:[]},Znn="wrapper";function etn(e){let{components:n,...t}=e;return(0,s.yg)(Znn,(0,p.A)({},Jnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}etn.isMDXComponent=!0;const ntn={toc:[]},ttn="wrapper";function otn(e){let{components:n,...t}=e;return(0,s.yg)(ttn,(0,p.A)({},ntn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}otn.isMDXComponent=!0;const ptn={toc:[]},rtn="wrapper";function stn(e){let{components:n,...t}=e;return(0,s.yg)(rtn,(0,p.A)({},ptn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}stn.isMDXComponent=!0;const ctn={toc:[]},atn="wrapper";function itn(e){let{components:n,...t}=e;return(0,s.yg)(atn,(0,p.A)({},ctn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}itn.isMDXComponent=!0;const ltn={toc:[]},utn="wrapper";function mtn(e){let{components:n,...t}=e;return(0,s.yg)(utn,(0,p.A)({},ltn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}mtn.isMDXComponent=!0;const ytn={toc:[]},dtn="wrapper";function htn(e){let{components:n,...t}=e;return(0,s.yg)(dtn,(0,p.A)({},ytn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}htn.isMDXComponent=!0;const gtn={toc:[]},ftn="wrapper";function Dtn(e){let{components:n,...t}=e;return(0,s.yg)(ftn,(0,p.A)({},gtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Dtn.isMDXComponent=!0;const Mtn={toc:[]},Xtn="wrapper";function _tn(e){let{components:n,...t}=e;return(0,s.yg)(Xtn,(0,p.A)({},Mtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}_tn.isMDXComponent=!0;const wtn={toc:[]},Ttn="wrapper";function Ctn(e){let{components:n,...t}=e;return(0,s.yg)(Ttn,(0,p.A)({},wtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}Ctn.isMDXComponent=!0;const xtn={toc:[]},Atn="wrapper";function vtn(e){let{components:n,...t}=e;return(0,s.yg)(Atn,(0,p.A)({},xtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the end of each grid line."))}vtn.isMDXComponent=!0;const Ltn={toc:[]},btn="wrapper";function Ntn(e){let{components:n,...t}=e;return(0,s.yg)(btn,(0,p.A)({},Ltn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Ntn.isMDXComponent=!0;const ktn={toc:[]},ztn="wrapper";function Ptn(e){let{components:n,...t}=e;return(0,s.yg)(ztn,(0,p.A)({},ktn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ptn.isMDXComponent=!0;const Itn={toc:[]},Rtn="wrapper";function Wtn(e){let{components:n,...t}=e;return(0,s.yg)(Rtn,(0,p.A)({},Itn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Wtn.isMDXComponent=!0;const Stn={toc:[]},Btn="wrapper";function Gtn(e){let{components:n,...t}=e;return(0,s.yg)(Btn,(0,p.A)({},Stn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Gtn.isMDXComponent=!0;const Etn={toc:[]},Otn="wrapper";function Utn(e){let{components:n,...t}=e;return(0,s.yg)(Otn,(0,p.A)({},Etn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Utn.isMDXComponent=!0;const Ftn={toc:[]},Vtn="wrapper";function qtn(e){let{components:n,...t}=e;return(0,s.yg)(Vtn,(0,p.A)({},Ftn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}qtn.isMDXComponent=!0;const jtn={toc:[]},Htn="wrapper";function Ytn(e){let{components:n,...t}=e;return(0,s.yg)(Htn,(0,p.A)({},jtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Ytn.isMDXComponent=!0;const Qtn={toc:[]},$tn="wrapper";function Ktn(e){let{components:n,...t}=e;return(0,s.yg)($tn,(0,p.A)({},Qtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]},Ztn="wrapper";function eon(e){let{components:n,...t}=e;return(0,s.yg)(Ztn,(0,p.A)({},Jtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eon.isMDXComponent=!0;const non={toc:[]},ton="wrapper";function oon(e){let{components:n,...t}=e;return(0,s.yg)(ton,(0,p.A)({},non,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}oon.isMDXComponent=!0;const pon={toc:[]},ron="wrapper";function son(e){let{components:n,...t}=e;return(0,s.yg)(ron,(0,p.A)({},pon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}son.isMDXComponent=!0;const con={toc:[]},aon="wrapper";function ion(e){let{components:n,...t}=e;return(0,s.yg)(aon,(0,p.A)({},con,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}ion.isMDXComponent=!0;const lon={toc:[]},uon="wrapper";function mon(e){let{components:n,...t}=e;return(0,s.yg)(uon,(0,p.A)({},lon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mon.isMDXComponent=!0;const yon={toc:[]},don="wrapper";function hon(e){let{components:n,...t}=e;return(0,s.yg)(don,(0,p.A)({},yon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}hon.isMDXComponent=!0;const gon={toc:[]},fon="wrapper";function Don(e){let{components:n,...t}=e;return(0,s.yg)(fon,(0,p.A)({},gon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Don.isMDXComponent=!0;const Mon={toc:[]},Xon="wrapper";function _on(e){let{components:n,...t}=e;return(0,s.yg)(Xon,(0,p.A)({},Mon,t,{components:n,mdxType:"MDXLayout"}))}_on.isMDXComponent=!0;const won={toc:[]},Ton="wrapper";function Con(e){let{components:n,...t}=e;return(0,s.yg)(Ton,(0,p.A)({},won,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Con.isMDXComponent=!0;const xon={toc:[]},Aon="wrapper";function von(e){let{components:n,...t}=e;return(0,s.yg)(Aon,(0,p.A)({},xon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}von.isMDXComponent=!0;const Lon={toc:[]},bon="wrapper";function Non(e){let{components:n,...t}=e;return(0,s.yg)(bon,(0,p.A)({},Lon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Non.isMDXComponent=!0;const kon={toc:[]},zon="wrapper";function Pon(e){let{components:n,...t}=e;return(0,s.yg)(zon,(0,p.A)({},kon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Pon.isMDXComponent=!0;const Ion={toc:[]},Ron="wrapper";function Won(e){let{components:n,...t}=e;return(0,s.yg)(Ron,(0,p.A)({},Ion,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Won.isMDXComponent=!0;const Son={toc:[]},Bon="wrapper";function Gon(e){let{components:n,...t}=e;return(0,s.yg)(Bon,(0,p.A)({},Son,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The spacing between the grid lines."))}Gon.isMDXComponent=!0;const Eon={toc:[]},Oon="wrapper";function Uon(e){let{components:n,...t}=e;return(0,s.yg)(Oon,(0,p.A)({},Eon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Uon.isMDXComponent=!0;const Fon={toc:[]},Von="wrapper";function qon(e){let{components:n,...t}=e;return(0,s.yg)(Von,(0,p.A)({},Fon,t,{components:n,mdxType:"MDXLayout"}))}qon.isMDXComponent=!0;const jon={toc:[]},Hon="wrapper";function Yon(e){let{components:n,...t}=e;return(0,s.yg)(Hon,(0,p.A)({},jon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}Yon.isMDXComponent=!0;const Qon={toc:[]},$on="wrapper";function Kon(e){let{components:n,...t}=e;return(0,s.yg)($on,(0,p.A)({},Qon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}Kon.isMDXComponent=!0;const Jon={toc:[]},Zon="wrapper";function epn(e){let{components:n,...t}=e;return(0,s.yg)(Zon,(0,p.A)({},Jon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}epn.isMDXComponent=!0;const npn={toc:[]},tpn="wrapper";function opn(e){let{components:n,...t}=e;return(0,s.yg)(tpn,(0,p.A)({},npn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}opn.isMDXComponent=!0;const ppn={toc:[]},rpn="wrapper";function spn(e){let{components:n,...t}=e;return(0,s.yg)(rpn,(0,p.A)({},ppn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}spn.isMDXComponent=!0;const cpn={toc:[]},apn="wrapper";function ipn(e){let{components:n,...t}=e;return(0,s.yg)(apn,(0,p.A)({},cpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}ipn.isMDXComponent=!0;const lpn={toc:[]},upn="wrapper";function mpn(e){let{components:n,...t}=e;return(0,s.yg)(upn,(0,p.A)({},lpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}mpn.isMDXComponent=!0;const ypn={toc:[]},dpn="wrapper";function hpn(e){let{components:n,...t}=e;return(0,s.yg)(dpn,(0,p.A)({},ypn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}hpn.isMDXComponent=!0;const gpn={toc:[]},fpn="wrapper";function Dpn(e){let{components:n,...t}=e;return(0,s.yg)(fpn,(0,p.A)({},gpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Dpn.isMDXComponent=!0;const Mpn={toc:[]},Xpn="wrapper";function _pn(e){let{components:n,...t}=e;return(0,s.yg)(Xpn,(0,p.A)({},Mpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}_pn.isMDXComponent=!0;const wpn={toc:[]},Tpn="wrapper";function Cpn(e){let{components:n,...t}=e;return(0,s.yg)(Tpn,(0,p.A)({},wpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Cpn.isMDXComponent=!0;const xpn={toc:[]},Apn="wrapper";function vpn(e){let{components:n,...t}=e;return(0,s.yg)(Apn,(0,p.A)({},xpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}vpn.isMDXComponent=!0;const Lpn={toc:[]},bpn="wrapper";function Npn(e){let{components:n,...t}=e;return(0,s.yg)(bpn,(0,p.A)({},Lpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Npn.isMDXComponent=!0;const kpn={toc:[]},zpn="wrapper";function Ppn(e){let{components:n,...t}=e;return(0,s.yg)(zpn,(0,p.A)({},kpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Ppn.isMDXComponent=!0;const Ipn={toc:[]},Rpn="wrapper";function Wpn(e){let{components:n,...t}=e;return(0,s.yg)(Rpn,(0,p.A)({},Ipn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Wpn.isMDXComponent=!0;const Spn={toc:[]},Bpn="wrapper";function Gpn(e){let{components:n,...t}=e;return(0,s.yg)(Bpn,(0,p.A)({},Spn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Gpn.isMDXComponent=!0;const Epn={toc:[]},Opn="wrapper";function Upn(e){let{components:n,...t}=e;return(0,s.yg)(Opn,(0,p.A)({},Epn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Upn.isMDXComponent=!0;const Fpn={toc:[]},Vpn="wrapper";function qpn(e){let{components:n,...t}=e;return(0,s.yg)(Vpn,(0,p.A)({},Fpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}qpn.isMDXComponent=!0;const jpn={toc:[]},Hpn="wrapper";function Ypn(e){let{components:n,...t}=e;return(0,s.yg)(Hpn,(0,p.A)({},jpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Ypn.isMDXComponent=!0;const Qpn={toc:[]},$pn="wrapper";function Kpn(e){let{components:n,...t}=e;return(0,s.yg)($pn,(0,p.A)({},Qpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]},Zpn="wrapper";function ern(e){let{components:n,...t}=e;return(0,s.yg)(Zpn,(0,p.A)({},Jpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}ern.isMDXComponent=!0;const nrn={toc:[]},trn="wrapper";function orn(e){let{components:n,...t}=e;return(0,s.yg)(trn,(0,p.A)({},nrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}orn.isMDXComponent=!0;const prn={toc:[]},rrn="wrapper";function srn(e){let{components:n,...t}=e;return(0,s.yg)(rrn,(0,p.A)({},prn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}srn.isMDXComponent=!0;const crn={toc:[]},arn="wrapper";function irn(e){let{components:n,...t}=e;return(0,s.yg)(arn,(0,p.A)({},crn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}irn.isMDXComponent=!0;const lrn={toc:[]},urn="wrapper";function mrn(e){let{components:n,...t}=e;return(0,s.yg)(urn,(0,p.A)({},lrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}mrn.isMDXComponent=!0;const yrn={toc:[]},drn="wrapper";function hrn(e){let{components:n,...t}=e;return(0,s.yg)(drn,(0,p.A)({},yrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}hrn.isMDXComponent=!0;const grn={toc:[]},frn="wrapper";function Drn(e){let{components:n,...t}=e;return(0,s.yg)(frn,(0,p.A)({},grn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Drn.isMDXComponent=!0;const Mrn={toc:[]},Xrn="wrapper";function _rn(e){let{components:n,...t}=e;return(0,s.yg)(Xrn,(0,p.A)({},Mrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}_rn.isMDXComponent=!0;const wrn={toc:[]},Trn="wrapper";function Crn(e){let{components:n,...t}=e;return(0,s.yg)(Trn,(0,p.A)({},wrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Crn.isMDXComponent=!0;const xrn={toc:[]},Arn="wrapper";function vrn(e){let{components:n,...t}=e;return(0,s.yg)(Arn,(0,p.A)({},xrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}vrn.isMDXComponent=!0;const Lrn={toc:[]},brn="wrapper";function Nrn(e){let{components:n,...t}=e;return(0,s.yg)(brn,(0,p.A)({},Lrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Nrn.isMDXComponent=!0;const krn={toc:[]},zrn="wrapper";function Prn(e){let{components:n,...t}=e;return(0,s.yg)(zrn,(0,p.A)({},krn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Prn.isMDXComponent=!0;const Irn={toc:[]},Rrn="wrapper";function Wrn(e){let{components:n,...t}=e;return(0,s.yg)(Rrn,(0,p.A)({},Irn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Wrn.isMDXComponent=!0;const Srn={toc:[]},Brn="wrapper";function Grn(e){let{components:n,...t}=e;return(0,s.yg)(Brn,(0,p.A)({},Srn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Grn.isMDXComponent=!0;const Ern={toc:[]},Orn="wrapper";function Urn(e){let{components:n,...t}=e;return(0,s.yg)(Orn,(0,p.A)({},Ern,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Urn.isMDXComponent=!0;const Frn={toc:[]},Vrn="wrapper";function qrn(e){let{components:n,...t}=e;return(0,s.yg)(Vrn,(0,p.A)({},Frn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qrn.isMDXComponent=!0;const jrn={toc:[]},Hrn="wrapper";function Yrn(e){let{components:n,...t}=e;return(0,s.yg)(Hrn,(0,p.A)({},jrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Yrn.isMDXComponent=!0;const Qrn={toc:[]},$rn="wrapper";function Krn(e){let{components:n,...t}=e;return(0,s.yg)($rn,(0,p.A)({},Qrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Krn.isMDXComponent=!0;const Jrn={toc:[]},Zrn="wrapper";function esn(e){let{components:n,...t}=e;return(0,s.yg)(Zrn,(0,p.A)({},Jrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}esn.isMDXComponent=!0;const nsn={toc:[]},tsn="wrapper";function osn(e){let{components:n,...t}=e;return(0,s.yg)(tsn,(0,p.A)({},nsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}osn.isMDXComponent=!0;const psn={toc:[]},rsn="wrapper";function ssn(e){let{components:n,...t}=e;return(0,s.yg)(rsn,(0,p.A)({},psn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ssn.isMDXComponent=!0;const csn={toc:[]},asn="wrapper";function isn(e){let{components:n,...t}=e;return(0,s.yg)(asn,(0,p.A)({},csn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}isn.isMDXComponent=!0;const lsn={toc:[]},usn="wrapper";function msn(e){let{components:n,...t}=e;return(0,s.yg)(usn,(0,p.A)({},lsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}msn.isMDXComponent=!0;const ysn={toc:[]},dsn="wrapper";function hsn(e){let{components:n,...t}=e;return(0,s.yg)(dsn,(0,p.A)({},ysn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}hsn.isMDXComponent=!0;const gsn={toc:[]},fsn="wrapper";function Dsn(e){let{components:n,...t}=e;return(0,s.yg)(fsn,(0,p.A)({},gsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Dsn.isMDXComponent=!0;const Msn={toc:[]},Xsn="wrapper";function _sn(e){let{components:n,...t}=e;return(0,s.yg)(Xsn,(0,p.A)({},Msn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}_sn.isMDXComponent=!0;const wsn={toc:[]},Tsn="wrapper";function Csn(e){let{components:n,...t}=e;return(0,s.yg)(Tsn,(0,p.A)({},wsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Csn.isMDXComponent=!0;const xsn={toc:[]},Asn="wrapper";function vsn(e){let{components:n,...t}=e;return(0,s.yg)(Asn,(0,p.A)({},xsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}vsn.isMDXComponent=!0;const Lsn={toc:[]},bsn="wrapper";function Nsn(e){let{components:n,...t}=e;return(0,s.yg)(bsn,(0,p.A)({},Lsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Nsn.isMDXComponent=!0;const ksn={toc:[]},zsn="wrapper";function Psn(e){let{components:n,...t}=e;return(0,s.yg)(zsn,(0,p.A)({},ksn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Psn.isMDXComponent=!0;const Isn={toc:[]},Rsn="wrapper";function Wsn(e){let{components:n,...t}=e;return(0,s.yg)(Rsn,(0,p.A)({},Isn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Wsn.isMDXComponent=!0;const Ssn={toc:[]},Bsn="wrapper";function Gsn(e){let{components:n,...t}=e;return(0,s.yg)(Bsn,(0,p.A)({},Ssn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Gsn.isMDXComponent=!0;const Esn={toc:[]},Osn="wrapper";function Usn(e){let{components:n,...t}=e;return(0,s.yg)(Osn,(0,p.A)({},Esn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Usn.isMDXComponent=!0;const Fsn={toc:[]},Vsn="wrapper";function qsn(e){let{components:n,...t}=e;return(0,s.yg)(Vsn,(0,p.A)({},Fsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}qsn.isMDXComponent=!0;const jsn={toc:[]},Hsn="wrapper";function Ysn(e){let{components:n,...t}=e;return(0,s.yg)(Hsn,(0,p.A)({},jsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ysn.isMDXComponent=!0;const Qsn={toc:[]},$sn="wrapper";function Ksn(e){let{components:n,...t}=e;return(0,s.yg)($sn,(0,p.A)({},Qsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Ksn.isMDXComponent=!0;const Jsn={toc:[]},Zsn="wrapper";function ecn(e){let{components:n,...t}=e;return(0,s.yg)(Zsn,(0,p.A)({},Jsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ecn.isMDXComponent=!0;const ncn={toc:[]},tcn="wrapper";function ocn(e){let{components:n,...t}=e;return(0,s.yg)(tcn,(0,p.A)({},ncn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}ocn.isMDXComponent=!0;const pcn={toc:[]},rcn="wrapper";function scn(e){let{components:n,...t}=e;return(0,s.yg)(rcn,(0,p.A)({},pcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}scn.isMDXComponent=!0;const ccn={toc:[]},acn="wrapper";function icn(e){let{components:n,...t}=e;return(0,s.yg)(acn,(0,p.A)({},ccn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}icn.isMDXComponent=!0;const lcn={toc:[]},ucn="wrapper";function mcn(e){let{components:n,...t}=e;return(0,s.yg)(ucn,(0,p.A)({},lcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}mcn.isMDXComponent=!0;const ycn={toc:[]},dcn="wrapper";function hcn(e){let{components:n,...t}=e;return(0,s.yg)(dcn,(0,p.A)({},ycn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}hcn.isMDXComponent=!0;const gcn={toc:[]},fcn="wrapper";function Dcn(e){let{components:n,...t}=e;return(0,s.yg)(fcn,(0,p.A)({},gcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Dcn.isMDXComponent=!0;const Mcn={toc:[]},Xcn="wrapper";function _cn(e){let{components:n,...t}=e;return(0,s.yg)(Xcn,(0,p.A)({},Mcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_cn.isMDXComponent=!0;const wcn={toc:[]},Tcn="wrapper";function Ccn(e){let{components:n,...t}=e;return(0,s.yg)(Tcn,(0,p.A)({},wcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Ccn.isMDXComponent=!0;const xcn={toc:[]},Acn="wrapper";function vcn(e){let{components:n,...t}=e;return(0,s.yg)(Acn,(0,p.A)({},xcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}vcn.isMDXComponent=!0;const Lcn={toc:[]},bcn="wrapper";function Ncn(e){let{components:n,...t}=e;return(0,s.yg)(bcn,(0,p.A)({},Lcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Ncn.isMDXComponent=!0;const kcn={toc:[]},zcn="wrapper";function Pcn(e){let{components:n,...t}=e;return(0,s.yg)(zcn,(0,p.A)({},kcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Pcn.isMDXComponent=!0;const Icn={toc:[]},Rcn="wrapper";function Wcn(e){let{components:n,...t}=e;return(0,s.yg)(Rcn,(0,p.A)({},Icn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Wcn.isMDXComponent=!0;const Scn={toc:[]},Bcn="wrapper";function Gcn(e){let{components:n,...t}=e;return(0,s.yg)(Bcn,(0,p.A)({},Scn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Gcn.isMDXComponent=!0;const Ecn={toc:[]},Ocn="wrapper";function Ucn(e){let{components:n,...t}=e;return(0,s.yg)(Ocn,(0,p.A)({},Ecn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Ucn.isMDXComponent=!0;const Fcn={toc:[]},Vcn="wrapper";function qcn(e){let{components:n,...t}=e;return(0,s.yg)(Vcn,(0,p.A)({},Fcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qcn.isMDXComponent=!0;const jcn={toc:[]},Hcn="wrapper";function Ycn(e){let{components:n,...t}=e;return(0,s.yg)(Hcn,(0,p.A)({},jcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Ycn.isMDXComponent=!0;const Qcn={toc:[]},$cn="wrapper";function Kcn(e){let{components:n,...t}=e;return(0,s.yg)($cn,(0,p.A)({},Qcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Kcn.isMDXComponent=!0;const Jcn={toc:[]},Zcn="wrapper";function ean(e){let{components:n,...t}=e;return(0,s.yg)(Zcn,(0,p.A)({},Jcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ean.isMDXComponent=!0;const nan={toc:[]},tan="wrapper";function oan(e){let{components:n,...t}=e;return(0,s.yg)(tan,(0,p.A)({},nan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}oan.isMDXComponent=!0;const pan={toc:[]},ran="wrapper";function san(e){let{components:n,...t}=e;return(0,s.yg)(ran,(0,p.A)({},pan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}san.isMDXComponent=!0;const can={toc:[]},aan="wrapper";function ian(e){let{components:n,...t}=e;return(0,s.yg)(aan,(0,p.A)({},can,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}ian.isMDXComponent=!0;const lan={toc:[]},uan="wrapper";function man(e){let{components:n,...t}=e;return(0,s.yg)(uan,(0,p.A)({},lan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}man.isMDXComponent=!0;const yan={toc:[]},dan="wrapper";function han(e){let{components:n,...t}=e;return(0,s.yg)(dan,(0,p.A)({},yan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}han.isMDXComponent=!0;const gan={toc:[]},fan="wrapper";function Dan(e){let{components:n,...t}=e;return(0,s.yg)(fan,(0,p.A)({},gan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Dan.isMDXComponent=!0;const Man={toc:[]},Xan="wrapper";function _an(e){let{components:n,...t}=e;return(0,s.yg)(Xan,(0,p.A)({},Man,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}_an.isMDXComponent=!0;const wan={toc:[]},Tan="wrapper";function Can(e){let{components:n,...t}=e;return(0,s.yg)(Tan,(0,p.A)({},wan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Can.isMDXComponent=!0;const xan={toc:[]},Aan="wrapper";function van(e){let{components:n,...t}=e;return(0,s.yg)(Aan,(0,p.A)({},xan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}van.isMDXComponent=!0;const Lan={toc:[]},ban="wrapper";function Nan(e){let{components:n,...t}=e;return(0,s.yg)(ban,(0,p.A)({},Lan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Nan.isMDXComponent=!0;const kan={toc:[]},zan="wrapper";function Pan(e){let{components:n,...t}=e;return(0,s.yg)(zan,(0,p.A)({},kan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Pan.isMDXComponent=!0;const Ian={toc:[]},Ran="wrapper";function Wan(e){let{components:n,...t}=e;return(0,s.yg)(Ran,(0,p.A)({},Ian,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Wan.isMDXComponent=!0;const San={toc:[]},Ban="wrapper";function Gan(e){let{components:n,...t}=e;return(0,s.yg)(Ban,(0,p.A)({},San,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Gan.isMDXComponent=!0;const Ean={toc:[]},Oan="wrapper";function Uan(e){let{components:n,...t}=e;return(0,s.yg)(Oan,(0,p.A)({},Ean,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Uan.isMDXComponent=!0;const Fan={toc:[]},Van="wrapper";function qan(e){let{components:n,...t}=e;return(0,s.yg)(Van,(0,p.A)({},Fan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qan.isMDXComponent=!0;const jan={toc:[]},Han="wrapper";function Yan(e){let{components:n,...t}=e;return(0,s.yg)(Han,(0,p.A)({},jan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Yan.isMDXComponent=!0;const Qan={toc:[]},$an="wrapper";function Kan(e){let{components:n,...t}=e;return(0,s.yg)($an,(0,p.A)({},Qan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Kan.isMDXComponent=!0;const Jan={toc:[]},Zan="wrapper";function ein(e){let{components:n,...t}=e;return(0,s.yg)(Zan,(0,p.A)({},Jan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}ein.isMDXComponent=!0;const nin={toc:[]},tin="wrapper";function oin(e){let{components:n,...t}=e;return(0,s.yg)(tin,(0,p.A)({},nin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}oin.isMDXComponent=!0;const pin={toc:[]},rin="wrapper";function sin(e){let{components:n,...t}=e;return(0,s.yg)(rin,(0,p.A)({},pin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sin.isMDXComponent=!0;const cin={toc:[]},ain="wrapper";function iin(e){let{components:n,...t}=e;return(0,s.yg)(ain,(0,p.A)({},cin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}iin.isMDXComponent=!0;const lin={toc:[]},uin="wrapper";function min(e){let{components:n,...t}=e;return(0,s.yg)(uin,(0,p.A)({},lin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}min.isMDXComponent=!0;const yin={toc:[]},din="wrapper";function hin(e){let{components:n,...t}=e;return(0,s.yg)(din,(0,p.A)({},yin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}hin.isMDXComponent=!0;const gin={toc:[]},fin="wrapper";function Din(e){let{components:n,...t}=e;return(0,s.yg)(fin,(0,p.A)({},gin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Din.isMDXComponent=!0;const Min={toc:[]},Xin="wrapper";function _in(e){let{components:n,...t}=e;return(0,s.yg)(Xin,(0,p.A)({},Min,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}_in.isMDXComponent=!0;const win={toc:[]},Tin="wrapper";function Cin(e){let{components:n,...t}=e;return(0,s.yg)(Tin,(0,p.A)({},win,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Cin.isMDXComponent=!0;const xin={toc:[]},Ain="wrapper";function vin(e){let{components:n,...t}=e;return(0,s.yg)(Ain,(0,p.A)({},xin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}vin.isMDXComponent=!0;const Lin={toc:[]},bin="wrapper";function Nin(e){let{components:n,...t}=e;return(0,s.yg)(bin,(0,p.A)({},Lin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Nin.isMDXComponent=!0;const kin={toc:[]},zin="wrapper";function Pin(e){let{components:n,...t}=e;return(0,s.yg)(zin,(0,p.A)({},kin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Pin.isMDXComponent=!0;const Iin={toc:[]},Rin="wrapper";function Win(e){let{components:n,...t}=e;return(0,s.yg)(Rin,(0,p.A)({},Iin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Win.isMDXComponent=!0;const Sin={toc:[]},Bin="wrapper";function Gin(e){let{components:n,...t}=e;return(0,s.yg)(Bin,(0,p.A)({},Sin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Gin.isMDXComponent=!0;const Ein={toc:[]},Oin="wrapper";function Uin(e){let{components:n,...t}=e;return(0,s.yg)(Oin,(0,p.A)({},Ein,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Uin.isMDXComponent=!0;const Fin={toc:[]},Vin="wrapper";function qin(e){let{components:n,...t}=e;return(0,s.yg)(Vin,(0,p.A)({},Fin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}qin.isMDXComponent=!0;const jin={toc:[]},Hin="wrapper";function Yin(e){let{components:n,...t}=e;return(0,s.yg)(Hin,(0,p.A)({},jin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Yin.isMDXComponent=!0;const Qin={toc:[]},$in="wrapper";function Kin(e){let{components:n,...t}=e;return(0,s.yg)($in,(0,p.A)({},Qin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Kin.isMDXComponent=!0;const Jin={toc:[]},Zin="wrapper";function eln(e){let{components:n,...t}=e;return(0,s.yg)(Zin,(0,p.A)({},Jin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}eln.isMDXComponent=!0;const nln={toc:[]},tln="wrapper";function oln(e){let{components:n,...t}=e;return(0,s.yg)(tln,(0,p.A)({},nln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}oln.isMDXComponent=!0;const pln={toc:[]},rln="wrapper";function sln(e){let{components:n,...t}=e;return(0,s.yg)(rln,(0,p.A)({},pln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}sln.isMDXComponent=!0;const cln={toc:[]},aln="wrapper";function iln(e){let{components:n,...t}=e;return(0,s.yg)(aln,(0,p.A)({},cln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}iln.isMDXComponent=!0;const lln={toc:[]},uln="wrapper";function mln(e){let{components:n,...t}=e;return(0,s.yg)(uln,(0,p.A)({},lln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}mln.isMDXComponent=!0;const yln={toc:[]},dln="wrapper";function hln(e){let{components:n,...t}=e;return(0,s.yg)(dln,(0,p.A)({},yln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}hln.isMDXComponent=!0;const gln={toc:[]},fln="wrapper";function Dln(e){let{components:n,...t}=e;return(0,s.yg)(fln,(0,p.A)({},gln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Dln.isMDXComponent=!0;const Mln={toc:[]},Xln="wrapper";function _ln(e){let{components:n,...t}=e;return(0,s.yg)(Xln,(0,p.A)({},Mln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}_ln.isMDXComponent=!0;const wln={toc:[]},Tln="wrapper";function Cln(e){let{components:n,...t}=e;return(0,s.yg)(Tln,(0,p.A)({},wln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Cln.isMDXComponent=!0;const xln={toc:[]},Aln="wrapper";function vln(e){let{components:n,...t}=e;return(0,s.yg)(Aln,(0,p.A)({},xln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}vln.isMDXComponent=!0;const Lln={toc:[]},bln="wrapper";function Nln(e){let{components:n,...t}=e;return(0,s.yg)(bln,(0,p.A)({},Lln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Nln.isMDXComponent=!0;const kln={toc:[]},zln="wrapper";function Pln(e){let{components:n,...t}=e;return(0,s.yg)(zln,(0,p.A)({},kln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Pln.isMDXComponent=!0;const Iln={toc:[]},Rln="wrapper";function Wln(e){let{components:n,...t}=e;return(0,s.yg)(Rln,(0,p.A)({},Iln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Wln.isMDXComponent=!0;const Sln={toc:[]},Bln="wrapper";function Gln(e){let{components:n,...t}=e;return(0,s.yg)(Bln,(0,p.A)({},Sln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Gln.isMDXComponent=!0;const Eln={toc:[]},Oln="wrapper";function Uln(e){let{components:n,...t}=e;return(0,s.yg)(Oln,(0,p.A)({},Eln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Uln.isMDXComponent=!0;const Fln={toc:[]},Vln="wrapper";function qln(e){let{components:n,...t}=e;return(0,s.yg)(Vln,(0,p.A)({},Fln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}qln.isMDXComponent=!0;const jln={toc:[]},Hln="wrapper";function Yln(e){let{components:n,...t}=e;return(0,s.yg)(Hln,(0,p.A)({},jln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Yln.isMDXComponent=!0;const Qln={toc:[]},$ln="wrapper";function Kln(e){let{components:n,...t}=e;return(0,s.yg)($ln,(0,p.A)({},Qln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Kln.isMDXComponent=!0;const Jln={toc:[]},Zln="wrapper";function eun(e){let{components:n,...t}=e;return(0,s.yg)(Zln,(0,p.A)({},Jln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eun.isMDXComponent=!0;const nun={toc:[]},tun="wrapper";function oun(e){let{components:n,...t}=e;return(0,s.yg)(tun,(0,p.A)({},nun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}oun.isMDXComponent=!0;const pun={toc:[]},run="wrapper";function sun(e){let{components:n,...t}=e;return(0,s.yg)(run,(0,p.A)({},pun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}sun.isMDXComponent=!0;const cun={toc:[]},aun="wrapper";function iun(e){let{components:n,...t}=e;return(0,s.yg)(aun,(0,p.A)({},cun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}iun.isMDXComponent=!0;const lun={toc:[]},uun="wrapper";function mun(e){let{components:n,...t}=e;return(0,s.yg)(uun,(0,p.A)({},lun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mun.isMDXComponent=!0;const yun={toc:[]},dun="wrapper";function hun(e){let{components:n,...t}=e;return(0,s.yg)(dun,(0,p.A)({},yun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}hun.isMDXComponent=!0;const gun={toc:[]},fun="wrapper";function Dun(e){let{components:n,...t}=e;return(0,s.yg)(fun,(0,p.A)({},gun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Dun.isMDXComponent=!0;const Mun={toc:[]},Xun="wrapper";function _un(e){let{components:n,...t}=e;return(0,s.yg)(Xun,(0,p.A)({},Mun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_un.isMDXComponent=!0;const wun={toc:[]},Tun="wrapper";function Cun(e){let{components:n,...t}=e;return(0,s.yg)(Tun,(0,p.A)({},wun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Cun.isMDXComponent=!0;const xun={toc:[]},Aun="wrapper";function vun(e){let{components:n,...t}=e;return(0,s.yg)(Aun,(0,p.A)({},xun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}vun.isMDXComponent=!0;const Lun={toc:[]},bun="wrapper";function Nun(e){let{components:n,...t}=e;return(0,s.yg)(bun,(0,p.A)({},Lun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Nun.isMDXComponent=!0;const kun={toc:[]},zun="wrapper";function Pun(e){let{components:n,...t}=e;return(0,s.yg)(zun,(0,p.A)({},kun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Pun.isMDXComponent=!0;const Iun={toc:[]},Run="wrapper";function Wun(e){let{components:n,...t}=e;return(0,s.yg)(Run,(0,p.A)({},Iun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Wun.isMDXComponent=!0;const Sun={toc:[]},Bun="wrapper";function Gun(e){let{components:n,...t}=e;return(0,s.yg)(Bun,(0,p.A)({},Sun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Gun.isMDXComponent=!0;const Eun={toc:[]},Oun="wrapper";function Uun(e){let{components:n,...t}=e;return(0,s.yg)(Oun,(0,p.A)({},Eun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Uun.isMDXComponent=!0;const Fun={toc:[]},Vun="wrapper";function qun(e){let{components:n,...t}=e;return(0,s.yg)(Vun,(0,p.A)({},Fun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qun.isMDXComponent=!0;const jun={toc:[]},Hun="wrapper";function Yun(e){let{components:n,...t}=e;return(0,s.yg)(Hun,(0,p.A)({},jun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Yun.isMDXComponent=!0;const Qun={toc:[]},$un="wrapper";function Kun(e){let{components:n,...t}=e;return(0,s.yg)($un,(0,p.A)({},Qun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Kun.isMDXComponent=!0;const Jun={toc:[]},Zun="wrapper";function emn(e){let{components:n,...t}=e;return(0,s.yg)(Zun,(0,p.A)({},Jun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}emn.isMDXComponent=!0;const nmn={toc:[]},tmn="wrapper";function omn(e){let{components:n,...t}=e;return(0,s.yg)(tmn,(0,p.A)({},nmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}omn.isMDXComponent=!0;const pmn={toc:[]},rmn="wrapper";function smn(e){let{components:n,...t}=e;return(0,s.yg)(rmn,(0,p.A)({},pmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}smn.isMDXComponent=!0;const cmn={toc:[]},amn="wrapper";function imn(e){let{components:n,...t}=e;return(0,s.yg)(amn,(0,p.A)({},cmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}imn.isMDXComponent=!0;const lmn={toc:[]},umn="wrapper";function mmn(e){let{components:n,...t}=e;return(0,s.yg)(umn,(0,p.A)({},lmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}mmn.isMDXComponent=!0;const ymn={toc:[]},dmn="wrapper";function hmn(e){let{components:n,...t}=e;return(0,s.yg)(dmn,(0,p.A)({},ymn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}hmn.isMDXComponent=!0;const gmn={toc:[]},fmn="wrapper";function Dmn(e){let{components:n,...t}=e;return(0,s.yg)(fmn,(0,p.A)({},gmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Dmn.isMDXComponent=!0;const Mmn={toc:[]},Xmn="wrapper";function _mn(e){let{components:n,...t}=e;return(0,s.yg)(Xmn,(0,p.A)({},Mmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}_mn.isMDXComponent=!0;const wmn={toc:[]},Tmn="wrapper";function Cmn(e){let{components:n,...t}=e;return(0,s.yg)(Tmn,(0,p.A)({},wmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Cmn.isMDXComponent=!0;const xmn={toc:[]},Amn="wrapper";function vmn(e){let{components:n,...t}=e;return(0,s.yg)(Amn,(0,p.A)({},xmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}vmn.isMDXComponent=!0;const Lmn={toc:[]},bmn="wrapper";function Nmn(e){let{components:n,...t}=e;return(0,s.yg)(bmn,(0,p.A)({},Lmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}Nmn.isMDXComponent=!0;const kmn={toc:[]},zmn="wrapper";function Pmn(e){let{components:n,...t}=e;return(0,s.yg)(zmn,(0,p.A)({},kmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Pmn.isMDXComponent=!0;const Imn={toc:[]},Rmn="wrapper";function Wmn(e){let{components:n,...t}=e;return(0,s.yg)(Rmn,(0,p.A)({},Imn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Wmn.isMDXComponent=!0;const Smn={toc:[]},Bmn="wrapper";function Gmn(e){let{components:n,...t}=e;return(0,s.yg)(Bmn,(0,p.A)({},Smn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Gmn.isMDXComponent=!0;const Emn={toc:[]},Omn="wrapper";function Umn(e){let{components:n,...t}=e;return(0,s.yg)(Omn,(0,p.A)({},Emn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Umn.isMDXComponent=!0;const Fmn={toc:[]},Vmn="wrapper";function qmn(e){let{components:n,...t}=e;return(0,s.yg)(Vmn,(0,p.A)({},Fmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qmn.isMDXComponent=!0;const jmn={toc:[]},Hmn="wrapper";function Ymn(e){let{components:n,...t}=e;return(0,s.yg)(Hmn,(0,p.A)({},jmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Ymn.isMDXComponent=!0;const Qmn={toc:[]},$mn="wrapper";function Kmn(e){let{components:n,...t}=e;return(0,s.yg)($mn,(0,p.A)({},Qmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Kmn.isMDXComponent=!0;const Jmn={toc:[]},Zmn="wrapper";function eyn(e){let{components:n,...t}=e;return(0,s.yg)(Zmn,(0,p.A)({},Jmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}eyn.isMDXComponent=!0;const nyn={toc:[]},tyn="wrapper";function oyn(e){let{components:n,...t}=e;return(0,s.yg)(tyn,(0,p.A)({},nyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}oyn.isMDXComponent=!0;const pyn={toc:[]},ryn="wrapper";function syn(e){let{components:n,...t}=e;return(0,s.yg)(ryn,(0,p.A)({},pyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}syn.isMDXComponent=!0;const cyn={toc:[]},ayn="wrapper";function iyn(e){let{components:n,...t}=e;return(0,s.yg)(ayn,(0,p.A)({},cyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}iyn.isMDXComponent=!0;const lyn={toc:[]},uyn="wrapper";function myn(e){let{components:n,...t}=e;return(0,s.yg)(uyn,(0,p.A)({},lyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}myn.isMDXComponent=!0;const yyn={toc:[]},dyn="wrapper";function hyn(e){let{components:n,...t}=e;return(0,s.yg)(dyn,(0,p.A)({},yyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide the color in one of the following formats:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"named color like ",(0,s.yg)("inlineCode",{parentName:"li"},"red"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.yg)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.yg)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}hyn.isMDXComponent=!0;const gyn={toc:[]},fyn="wrapper";function Dyn(e){let{components:n,...t}=e;return(0,s.yg)(fyn,(0,p.A)({},gyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"'white'"))}Dyn.isMDXComponent=!0;const Myn={toc:[]},Xyn="wrapper";function _yn(e){let{components:n,...t}=e;return(0,s.yg)(Xyn,(0,p.A)({},Myn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the icon"))}_yn.isMDXComponent=!0;const wyn={toc:[]},Tyn="wrapper";function Cyn(e){let{components:n,...t}=e;return(0,s.yg)(Tyn,(0,p.A)({},wyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Cyn.isMDXComponent=!0;const xyn={toc:[]},Ayn="wrapper";function vyn(e){let{components:n,...t}=e;return(0,s.yg)(Ayn,(0,p.A)({},xyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}vyn.isMDXComponent=!0;const Lyn={toc:[]},byn="wrapper";function Nyn(e){let{components:n,...t}=e;return(0,s.yg)(byn,(0,p.A)({},Lyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Nyn.isMDXComponent=!0;const kyn={toc:[]},zyn="wrapper";function Pyn(e){let{components:n,...t}=e;return(0,s.yg)(zyn,(0,p.A)({},kyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Pyn.isMDXComponent=!0;const Iyn={toc:[]},Ryn="wrapper";function Wyn(e){let{components:n,...t}=e;return(0,s.yg)(Ryn,(0,p.A)({},Iyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Wyn.isMDXComponent=!0;const Syn={toc:[]},Byn="wrapper";function Gyn(e){let{components:n,...t}=e;return(0,s.yg)(Byn,(0,p.A)({},Syn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Gyn.isMDXComponent=!0;const Eyn={toc:[]},Oyn="wrapper";function Uyn(e){let{components:n,...t}=e;return(0,s.yg)(Oyn,(0,p.A)({},Eyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Uyn.isMDXComponent=!0;const Fyn={toc:[]},Vyn="wrapper";function qyn(e){let{components:n,...t}=e;return(0,s.yg)(Vyn,(0,p.A)({},Fyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qyn.isMDXComponent=!0;const jyn={toc:[]},Hyn="wrapper";function Yyn(e){let{components:n,...t}=e;return(0,s.yg)(Hyn,(0,p.A)({},jyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Yyn.isMDXComponent=!0;const Qyn={toc:[]},$yn="wrapper";function Kyn(e){let{components:n,...t}=e;return(0,s.yg)($yn,(0,p.A)({},Qyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can find identifiers on ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Kyn.isMDXComponent=!0;const Jyn={toc:[]},Zyn="wrapper";function edn(e){let{components:n,...t}=e;return(0,s.yg)(Zyn,(0,p.A)({},Jyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The identifier of the icon."))}edn.isMDXComponent=!0;const ndn={toc:[]},tdn="wrapper";function odn(e){let{components:n,...t}=e;return(0,s.yg)(tdn,(0,p.A)({},ndn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}odn.isMDXComponent=!0;const pdn={toc:[]},rdn="wrapper";function sdn(e){let{components:n,...t}=e;return(0,s.yg)(rdn,(0,p.A)({},pdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}sdn.isMDXComponent=!0;const cdn={toc:[]},adn="wrapper";function idn(e){let{components:n,...t}=e;return(0,s.yg)(adn,(0,p.A)({},cdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}idn.isMDXComponent=!0;const ldn={toc:[]},udn="wrapper";function mdn(e){let{components:n,...t}=e;return(0,s.yg)(udn,(0,p.A)({},ldn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}mdn.isMDXComponent=!0;const ydn={toc:[]},ddn="wrapper";function hdn(e){let{components:n,...t}=e;return(0,s.yg)(ddn,(0,p.A)({},ydn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}hdn.isMDXComponent=!0;const gdn={toc:[]},fdn="wrapper";function Ddn(e){let{components:n,...t}=e;return(0,s.yg)(fdn,(0,p.A)({},gdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Ddn.isMDXComponent=!0;const Mdn={toc:[]},Xdn="wrapper";function _dn(e){let{components:n,...t}=e;return(0,s.yg)(Xdn,(0,p.A)({},Mdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}_dn.isMDXComponent=!0;const wdn={toc:[]},Tdn="wrapper";function Cdn(e){let{components:n,...t}=e;return(0,s.yg)(Tdn,(0,p.A)({},wdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Cdn.isMDXComponent=!0;const xdn={toc:[]},Adn="wrapper";function vdn(e){let{components:n,...t}=e;return(0,s.yg)(Adn,(0,p.A)({},xdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vdn.isMDXComponent=!0;const Ldn={toc:[]},bdn="wrapper";function Ndn(e){let{components:n,...t}=e;return(0,s.yg)(bdn,(0,p.A)({},Ldn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Ndn.isMDXComponent=!0;const kdn={toc:[]},zdn="wrapper";function Pdn(e){let{components:n,...t}=e;return(0,s.yg)(zdn,(0,p.A)({},kdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Pdn.isMDXComponent=!0;const Idn={toc:[]},Rdn="wrapper";function Wdn(e){let{components:n,...t}=e;return(0,s.yg)(Rdn,(0,p.A)({},Idn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Wdn.isMDXComponent=!0;const Sdn={toc:[]},Bdn="wrapper";function Gdn(e){let{components:n,...t}=e;return(0,s.yg)(Bdn,(0,p.A)({},Sdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Gdn.isMDXComponent=!0;const Edn={toc:[]},Odn="wrapper";function Udn(e){let{components:n,...t}=e;return(0,s.yg)(Odn,(0,p.A)({},Edn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Udn.isMDXComponent=!0;const Fdn={toc:[]},Vdn="wrapper";function qdn(e){let{components:n,...t}=e;return(0,s.yg)(Vdn,(0,p.A)({},Fdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qdn.isMDXComponent=!0;const jdn={toc:[]},Hdn="wrapper";function Ydn(e){let{components:n,...t}=e;return(0,s.yg)(Hdn,(0,p.A)({},jdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Ydn.isMDXComponent=!0;const Qdn={toc:[]},$dn="wrapper";function Kdn(e){let{components:n,...t}=e;return(0,s.yg)($dn,(0,p.A)({},Qdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Kdn.isMDXComponent=!0;const Jdn={toc:[]},Zdn="wrapper";function ehn(e){let{components:n,...t}=e;return(0,s.yg)(Zdn,(0,p.A)({},Jdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ehn.isMDXComponent=!0;const nhn={toc:[]},thn="wrapper";function ohn(e){let{components:n,...t}=e;return(0,s.yg)(thn,(0,p.A)({},nhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}ohn.isMDXComponent=!0;const phn={toc:[]},rhn="wrapper";function shn(e){let{components:n,...t}=e;return(0,s.yg)(rhn,(0,p.A)({},phn,t,{components:n,mdxType:"MDXLayout"}))}shn.isMDXComponent=!0;const chn={toc:[]},ahn="wrapper";function ihn(e){let{components:n,...t}=e;return(0,s.yg)(ahn,(0,p.A)({},chn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ihn.isMDXComponent=!0;const lhn={toc:[]},uhn="wrapper";function mhn(e){let{components:n,...t}=e;return(0,s.yg)(uhn,(0,p.A)({},lhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}mhn.isMDXComponent=!0;const yhn={toc:[]},dhn="wrapper";function hhn(e){let{components:n,...t}=e;return(0,s.yg)(dhn,(0,p.A)({},yhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}hhn.isMDXComponent=!0;const ghn={toc:[]},fhn="wrapper";function Dhn(e){let{components:n,...t}=e;return(0,s.yg)(fhn,(0,p.A)({},ghn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Dhn.isMDXComponent=!0;const Mhn={toc:[]},Xhn="wrapper";function _hn(e){let{components:n,...t}=e;return(0,s.yg)(Xhn,(0,p.A)({},Mhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}_hn.isMDXComponent=!0;const whn={toc:[]},Thn="wrapper";function Chn(e){let{components:n,...t}=e;return(0,s.yg)(Thn,(0,p.A)({},whn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Chn.isMDXComponent=!0;const xhn={toc:[]},Ahn="wrapper";function vhn(e){let{components:n,...t}=e;return(0,s.yg)(Ahn,(0,p.A)({},xhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}vhn.isMDXComponent=!0;const Lhn={toc:[]},bhn="wrapper";function Nhn(e){let{components:n,...t}=e;return(0,s.yg)(bhn,(0,p.A)({},Lhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}Nhn.isMDXComponent=!0;const khn={toc:[]},zhn="wrapper";function Phn(e){let{components:n,...t}=e;return(0,s.yg)(zhn,(0,p.A)({},khn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Phn.isMDXComponent=!0;const Ihn={toc:[]},Rhn="wrapper";function Whn(e){let{components:n,...t}=e;return(0,s.yg)(Rhn,(0,p.A)({},Ihn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}Whn.isMDXComponent=!0;const Shn={toc:[]},Bhn="wrapper";function Ghn(e){let{components:n,...t}=e;return(0,s.yg)(Bhn,(0,p.A)({},Shn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}Ghn.isMDXComponent=!0;const Ehn={toc:[]},Ohn="wrapper";function Uhn(e){let{components:n,...t}=e;return(0,s.yg)(Ohn,(0,p.A)({},Ehn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Uhn.isMDXComponent=!0;const Fhn={toc:[]},Vhn="wrapper";function qhn(e){let{components:n,...t}=e;return(0,s.yg)(Vhn,(0,p.A)({},Fhn,t,{components:n,mdxType:"MDXLayout"}))}qhn.isMDXComponent=!0;const jhn={toc:[]},Hhn="wrapper";function Yhn(e){let{components:n,...t}=e;return(0,s.yg)(Hhn,(0,p.A)({},jhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Yhn.isMDXComponent=!0;const Qhn={toc:[]},$hn="wrapper";function Khn(e){let{components:n,...t}=e;return(0,s.yg)($hn,(0,p.A)({},Qhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}Khn.isMDXComponent=!0;const Jhn={toc:[]},Zhn="wrapper";function egn(e){let{components:n,...t}=e;return(0,s.yg)(Zhn,(0,p.A)({},Jhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}egn.isMDXComponent=!0;const ngn={toc:[]},tgn="wrapper";function ogn(e){let{components:n,...t}=e;return(0,s.yg)(tgn,(0,p.A)({},ngn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}ogn.isMDXComponent=!0;const pgn={toc:[]},rgn="wrapper";function sgn(e){let{components:n,...t}=e;return(0,s.yg)(rgn,(0,p.A)({},pgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sgn.isMDXComponent=!0;const cgn={toc:[]},agn="wrapper";function ign(e){let{components:n,...t}=e;return(0,s.yg)(agn,(0,p.A)({},cgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}ign.isMDXComponent=!0;const lgn={toc:[]},ugn="wrapper";function mgn(e){let{components:n,...t}=e;return(0,s.yg)(ugn,(0,p.A)({},lgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}mgn.isMDXComponent=!0;const ygn={toc:[]},dgn="wrapper";function hgn(e){let{components:n,...t}=e;return(0,s.yg)(dgn,(0,p.A)({},ygn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}hgn.isMDXComponent=!0;const ggn={toc:[]},fgn="wrapper";function Dgn(e){let{components:n,...t}=e;return(0,s.yg)(fgn,(0,p.A)({},ggn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Dgn.isMDXComponent=!0;const Mgn={toc:[]},Xgn="wrapper";function _gn(e){let{components:n,...t}=e;return(0,s.yg)(Xgn,(0,p.A)({},Mgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}_gn.isMDXComponent=!0;const wgn={toc:[]},Tgn="wrapper";function Cgn(e){let{components:n,...t}=e;return(0,s.yg)(Tgn,(0,p.A)({},wgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Cgn.isMDXComponent=!0;const xgn={toc:[]},Agn="wrapper";function vgn(e){let{components:n,...t}=e;return(0,s.yg)(Agn,(0,p.A)({},xgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}vgn.isMDXComponent=!0;const Lgn={toc:[]},bgn="wrapper";function Ngn(e){let{components:n,...t}=e;return(0,s.yg)(bgn,(0,p.A)({},Lgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Ngn.isMDXComponent=!0;const kgn={toc:[]},zgn="wrapper";function Pgn(e){let{components:n,...t}=e;return(0,s.yg)(zgn,(0,p.A)({},kgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Pgn.isMDXComponent=!0;const Ign={toc:[]},Rgn="wrapper";function Wgn(e){let{components:n,...t}=e;return(0,s.yg)(Rgn,(0,p.A)({},Ign,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Wgn.isMDXComponent=!0;const Sgn={toc:[]},Bgn="wrapper";function Ggn(e){let{components:n,...t}=e;return(0,s.yg)(Bgn,(0,p.A)({},Sgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ggn.isMDXComponent=!0;const Egn={toc:[]},Ogn="wrapper";function Ugn(e){let{components:n,...t}=e;return(0,s.yg)(Ogn,(0,p.A)({},Egn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Ugn.isMDXComponent=!0;const Fgn={toc:[]},Vgn="wrapper";function qgn(e){let{components:n,...t}=e;return(0,s.yg)(Vgn,(0,p.A)({},Fgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}qgn.isMDXComponent=!0;const jgn={toc:[]},Hgn="wrapper";function Ygn(e){let{components:n,...t}=e;return(0,s.yg)(Hgn,(0,p.A)({},jgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ygn.isMDXComponent=!0;const Qgn={toc:[]},$gn="wrapper";function Kgn(e){let{components:n,...t}=e;return(0,s.yg)($gn,(0,p.A)({},Qgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Kgn.isMDXComponent=!0;const Jgn={toc:[]},Zgn="wrapper";function efn(e){let{components:n,...t}=e;return(0,s.yg)(Zgn,(0,p.A)({},Jgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}efn.isMDXComponent=!0;const nfn={toc:[]},tfn="wrapper";function ofn(e){let{components:n,...t}=e;return(0,s.yg)(tfn,(0,p.A)({},nfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}ofn.isMDXComponent=!0;const pfn={toc:[]},rfn="wrapper";function sfn(e){let{components:n,...t}=e;return(0,s.yg)(rfn,(0,p.A)({},pfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}sfn.isMDXComponent=!0;const cfn={toc:[]},afn="wrapper";function ifn(e){let{components:n,...t}=e;return(0,s.yg)(afn,(0,p.A)({},cfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}ifn.isMDXComponent=!0;const lfn={toc:[]},ufn="wrapper";function mfn(e){let{components:n,...t}=e;return(0,s.yg)(ufn,(0,p.A)({},lfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}mfn.isMDXComponent=!0;const yfn={toc:[]},dfn="wrapper";function hfn(e){let{components:n,...t}=e;return(0,s.yg)(dfn,(0,p.A)({},yfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}hfn.isMDXComponent=!0;const gfn={toc:[]},ffn="wrapper";function Dfn(e){let{components:n,...t}=e;return(0,s.yg)(ffn,(0,p.A)({},gfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Dfn.isMDXComponent=!0;const Mfn={toc:[]},Xfn="wrapper";function _fn(e){let{components:n,...t}=e;return(0,s.yg)(Xfn,(0,p.A)({},Mfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}_fn.isMDXComponent=!0;const wfn={toc:[]},Tfn="wrapper";function Cfn(e){let{components:n,...t}=e;return(0,s.yg)(Tfn,(0,p.A)({},wfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Cfn.isMDXComponent=!0;const xfn={toc:[]},Afn="wrapper";function vfn(e){let{components:n,...t}=e;return(0,s.yg)(Afn,(0,p.A)({},xfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vfn.isMDXComponent=!0;const Lfn={toc:[]},bfn="wrapper";function Nfn(e){let{components:n,...t}=e;return(0,s.yg)(bfn,(0,p.A)({},Lfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Nfn.isMDXComponent=!0;const kfn={toc:[]},zfn="wrapper";function Pfn(e){let{components:n,...t}=e;return(0,s.yg)(zfn,(0,p.A)({},kfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Pfn.isMDXComponent=!0;const Ifn={toc:[]},Rfn="wrapper";function Wfn(e){let{components:n,...t}=e;return(0,s.yg)(Rfn,(0,p.A)({},Ifn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Wfn.isMDXComponent=!0;const Sfn={toc:[]},Bfn="wrapper";function Gfn(e){let{components:n,...t}=e;return(0,s.yg)(Bfn,(0,p.A)({},Sfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Gfn.isMDXComponent=!0;const Efn={toc:[]},Ofn="wrapper";function Ufn(e){let{components:n,...t}=e;return(0,s.yg)(Ofn,(0,p.A)({},Efn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Ufn.isMDXComponent=!0;const Ffn={toc:[]},Vfn="wrapper";function qfn(e){let{components:n,...t}=e;return(0,s.yg)(Vfn,(0,p.A)({},Ffn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}qfn.isMDXComponent=!0;const jfn={toc:[]},Hfn="wrapper";function Yfn(e){let{components:n,...t}=e;return(0,s.yg)(Hfn,(0,p.A)({},jfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Yfn.isMDXComponent=!0;const Qfn={toc:[]},$fn="wrapper";function Kfn(e){let{components:n,...t}=e;return(0,s.yg)($fn,(0,p.A)({},Qfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]},Zfn="wrapper";function eDn(e){let{components:n,...t}=e;return(0,s.yg)(Zfn,(0,p.A)({},Jfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}eDn.isMDXComponent=!0;const nDn={toc:[]},tDn="wrapper";function oDn(e){let{components:n,...t}=e;return(0,s.yg)(tDn,(0,p.A)({},nDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}oDn.isMDXComponent=!0;const pDn={toc:[]},rDn="wrapper";function sDn(e){let{components:n,...t}=e;return(0,s.yg)(rDn,(0,p.A)({},pDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}sDn.isMDXComponent=!0;const cDn={toc:[]},aDn="wrapper";function iDn(e){let{components:n,...t}=e;return(0,s.yg)(aDn,(0,p.A)({},cDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}iDn.isMDXComponent=!0;const lDn={toc:[]},uDn="wrapper";function mDn(e){let{components:n,...t}=e;return(0,s.yg)(uDn,(0,p.A)({},lDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}mDn.isMDXComponent=!0;const yDn={toc:[]},dDn="wrapper";function hDn(e){let{components:n,...t}=e;return(0,s.yg)(dDn,(0,p.A)({},yDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}hDn.isMDXComponent=!0;const gDn={toc:[]},fDn="wrapper";function DDn(e){let{components:n,...t}=e;return(0,s.yg)(fDn,(0,p.A)({},gDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}DDn.isMDXComponent=!0;const MDn={toc:[]},XDn="wrapper";function _Dn(e){let{components:n,...t}=e;return(0,s.yg)(XDn,(0,p.A)({},MDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}_Dn.isMDXComponent=!0;const wDn={toc:[]},TDn="wrapper";function CDn(e){let{components:n,...t}=e;return(0,s.yg)(TDn,(0,p.A)({},wDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}CDn.isMDXComponent=!0;const xDn={toc:[]},ADn="wrapper";function vDn(e){let{components:n,...t}=e;return(0,s.yg)(ADn,(0,p.A)({},xDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}vDn.isMDXComponent=!0;const LDn={toc:[]},bDn="wrapper";function NDn(e){let{components:n,...t}=e;return(0,s.yg)(bDn,(0,p.A)({},LDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}NDn.isMDXComponent=!0;const kDn={toc:[]},zDn="wrapper";function PDn(e){let{components:n,...t}=e;return(0,s.yg)(zDn,(0,p.A)({},kDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}PDn.isMDXComponent=!0;const IDn={toc:[]},RDn="wrapper";function WDn(e){let{components:n,...t}=e;return(0,s.yg)(RDn,(0,p.A)({},IDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}WDn.isMDXComponent=!0;const SDn={toc:[]},BDn="wrapper";function GDn(e){let{components:n,...t}=e;return(0,s.yg)(BDn,(0,p.A)({},SDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}GDn.isMDXComponent=!0;const EDn={toc:[]},ODn="wrapper";function UDn(e){let{components:n,...t}=e;return(0,s.yg)(ODn,(0,p.A)({},EDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}UDn.isMDXComponent=!0;const FDn={toc:[]},VDn="wrapper";function qDn(e){let{components:n,...t}=e;return(0,s.yg)(VDn,(0,p.A)({},FDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}qDn.isMDXComponent=!0;const jDn={toc:[]},HDn="wrapper";function YDn(e){let{components:n,...t}=e;return(0,s.yg)(HDn,(0,p.A)({},jDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}YDn.isMDXComponent=!0;const QDn={toc:[]},$Dn="wrapper";function KDn(e){let{components:n,...t}=e;return(0,s.yg)($Dn,(0,p.A)({},QDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}KDn.isMDXComponent=!0;const JDn={toc:[]},ZDn="wrapper";function eMn(e){let{components:n,...t}=e;return(0,s.yg)(ZDn,(0,p.A)({},JDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}eMn.isMDXComponent=!0;const nMn={toc:[]},tMn="wrapper";function oMn(e){let{components:n,...t}=e;return(0,s.yg)(tMn,(0,p.A)({},nMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oMn.isMDXComponent=!0;const pMn={toc:[]},rMn="wrapper";function sMn(e){let{components:n,...t}=e;return(0,s.yg)(rMn,(0,p.A)({},pMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}sMn.isMDXComponent=!0;const cMn={toc:[]},aMn="wrapper";function iMn(e){let{components:n,...t}=e;return(0,s.yg)(aMn,(0,p.A)({},cMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}iMn.isMDXComponent=!0;const lMn={toc:[]},uMn="wrapper";function mMn(e){let{components:n,...t}=e;return(0,s.yg)(uMn,(0,p.A)({},lMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}mMn.isMDXComponent=!0;const yMn={toc:[]},dMn="wrapper";function hMn(e){let{components:n,...t}=e;return(0,s.yg)(dMn,(0,p.A)({},yMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hMn.isMDXComponent=!0;const gMn={toc:[]},fMn="wrapper";function DMn(e){let{components:n,...t}=e;return(0,s.yg)(fMn,(0,p.A)({},gMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}DMn.isMDXComponent=!0;const MMn={toc:[]},XMn="wrapper";function _Mn(e){let{components:n,...t}=e;return(0,s.yg)(XMn,(0,p.A)({},MMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_Mn.isMDXComponent=!0;const wMn={toc:[]},TMn="wrapper";function CMn(e){let{components:n,...t}=e;return(0,s.yg)(TMn,(0,p.A)({},wMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}CMn.isMDXComponent=!0;const xMn={toc:[]},AMn="wrapper";function vMn(e){let{components:n,...t}=e;return(0,s.yg)(AMn,(0,p.A)({},xMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vMn.isMDXComponent=!0;const LMn={toc:[]},bMn="wrapper";function NMn(e){let{components:n,...t}=e;return(0,s.yg)(bMn,(0,p.A)({},LMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}NMn.isMDXComponent=!0;const kMn={toc:[]},zMn="wrapper";function PMn(e){let{components:n,...t}=e;return(0,s.yg)(zMn,(0,p.A)({},kMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}PMn.isMDXComponent=!0;const IMn={toc:[]},RMn="wrapper";function WMn(e){let{components:n,...t}=e;return(0,s.yg)(RMn,(0,p.A)({},IMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}WMn.isMDXComponent=!0;const SMn={toc:[]},BMn="wrapper";function GMn(e){let{components:n,...t}=e;return(0,s.yg)(BMn,(0,p.A)({},SMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GMn.isMDXComponent=!0;const EMn={toc:[]},OMn="wrapper";function UMn(e){let{components:n,...t}=e;return(0,s.yg)(OMn,(0,p.A)({},EMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}UMn.isMDXComponent=!0;const FMn={toc:[]},VMn="wrapper";function qMn(e){let{components:n,...t}=e;return(0,s.yg)(VMn,(0,p.A)({},FMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qMn.isMDXComponent=!0;const jMn={toc:[]},HMn="wrapper";function YMn(e){let{components:n,...t}=e;return(0,s.yg)(HMn,(0,p.A)({},jMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}YMn.isMDXComponent=!0;const QMn={toc:[]},$Mn="wrapper";function KMn(e){let{components:n,...t}=e;return(0,s.yg)($Mn,(0,p.A)({},QMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}KMn.isMDXComponent=!0;const JMn={toc:[]},ZMn="wrapper";function eXn(e){let{components:n,...t}=e;return(0,s.yg)(ZMn,(0,p.A)({},JMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}eXn.isMDXComponent=!0;const nXn={toc:[]},tXn="wrapper";function oXn(e){let{components:n,...t}=e;return(0,s.yg)(tXn,(0,p.A)({},nXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}oXn.isMDXComponent=!0;const pXn={toc:[]},rXn="wrapper";function sXn(e){let{components:n,...t}=e;return(0,s.yg)(rXn,(0,p.A)({},pXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}sXn.isMDXComponent=!0;const cXn={toc:[]},aXn="wrapper";function iXn(e){let{components:n,...t}=e;return(0,s.yg)(aXn,(0,p.A)({},cXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}iXn.isMDXComponent=!0;const lXn={toc:[]},uXn="wrapper";function mXn(e){let{components:n,...t}=e;return(0,s.yg)(uXn,(0,p.A)({},lXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"overrides ",(0,s.yg)("inlineCode",{parentName:"p"},"Image.src")," getter"))}mXn.isMDXComponent=!0;const yXn={toc:[]},dXn="wrapper";function hXn(e){let{components:n,...t}=e;return(0,s.yg)(dXn,(0,p.A)({},yXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hXn.isMDXComponent=!0;const gXn={toc:[]},fXn="wrapper";function DXn(e){let{components:n,...t}=e;return(0,s.yg)(fXn,(0,p.A)({},gXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}DXn.isMDXComponent=!0;const MXn={toc:[]},XXn="wrapper";function _Xn(e){let{components:n,...t}=e;return(0,s.yg)(XXn,(0,p.A)({},MXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}_Xn.isMDXComponent=!0;const wXn={toc:[]},TXn="wrapper";function CXn(e){let{components:n,...t}=e;return(0,s.yg)(TXn,(0,p.A)({},wXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}CXn.isMDXComponent=!0;const xXn={toc:[]},AXn="wrapper";function vXn(e){let{components:n,...t}=e;return(0,s.yg)(AXn,(0,p.A)({},xXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}vXn.isMDXComponent=!0;const LXn={toc:[]},bXn="wrapper";function NXn(e){let{components:n,...t}=e;return(0,s.yg)(bXn,(0,p.A)({},LXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}NXn.isMDXComponent=!0;const kXn={toc:[]},zXn="wrapper";function PXn(e){let{components:n,...t}=e;return(0,s.yg)(zXn,(0,p.A)({},kXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}PXn.isMDXComponent=!0;const IXn={toc:[]},RXn="wrapper";function WXn(e){let{components:n,...t}=e;return(0,s.yg)(RXn,(0,p.A)({},IXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}WXn.isMDXComponent=!0;const SXn={toc:[]},BXn="wrapper";function GXn(e){let{components:n,...t}=e;return(0,s.yg)(BXn,(0,p.A)({},SXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}GXn.isMDXComponent=!0;const EXn={toc:[]},OXn="wrapper";function UXn(e){let{components:n,...t}=e;return(0,s.yg)(OXn,(0,p.A)({},EXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}UXn.isMDXComponent=!0;const FXn={toc:[]},VXn="wrapper";function qXn(e){let{components:n,...t}=e;return(0,s.yg)(VXn,(0,p.A)({},FXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qXn.isMDXComponent=!0;const jXn={toc:[]},HXn="wrapper";function YXn(e){let{components:n,...t}=e;return(0,s.yg)(HXn,(0,p.A)({},jXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}YXn.isMDXComponent=!0;const QXn={toc:[]},$Xn="wrapper";function KXn(e){let{components:n,...t}=e;return(0,s.yg)($Xn,(0,p.A)({},QXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}KXn.isMDXComponent=!0;const JXn={toc:[]},ZXn="wrapper";function e_n(e){let{components:n,...t}=e;return(0,s.yg)(ZXn,(0,p.A)({},JXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}e_n.isMDXComponent=!0;const n_n={toc:[]},t_n="wrapper";function o_n(e){let{components:n,...t}=e;return(0,s.yg)(t_n,(0,p.A)({},n_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}o_n.isMDXComponent=!0;const p_n={toc:[]},r_n="wrapper";function s_n(e){let{components:n,...t}=e;return(0,s.yg)(r_n,(0,p.A)({},p_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}s_n.isMDXComponent=!0;const c_n={toc:[]},a_n="wrapper";function i_n(e){let{components:n,...t}=e;return(0,s.yg)(a_n,(0,p.A)({},c_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}i_n.isMDXComponent=!0;const l_n={toc:[]},u_n="wrapper";function m_n(e){let{components:n,...t}=e;return(0,s.yg)(u_n,(0,p.A)({},l_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}m_n.isMDXComponent=!0;const y_n={toc:[]},d_n="wrapper";function h_n(e){let{components:n,...t}=e;return(0,s.yg)(d_n,(0,p.A)({},y_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}h_n.isMDXComponent=!0;const g_n={toc:[]},f_n="wrapper";function D_n(e){let{components:n,...t}=e;return(0,s.yg)(f_n,(0,p.A)({},g_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}D_n.isMDXComponent=!0;const M_n={toc:[]},X_n="wrapper";function __n(e){let{components:n,...t}=e;return(0,s.yg)(X_n,(0,p.A)({},M_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}__n.isMDXComponent=!0;const w_n={toc:[]},T_n="wrapper";function C_n(e){let{components:n,...t}=e;return(0,s.yg)(T_n,(0,p.A)({},w_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}C_n.isMDXComponent=!0;const x_n={toc:[]},A_n="wrapper";function v_n(e){let{components:n,...t}=e;return(0,s.yg)(A_n,(0,p.A)({},x_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}v_n.isMDXComponent=!0;const L_n={toc:[]},b_n="wrapper";function N_n(e){let{components:n,...t}=e;return(0,s.yg)(b_n,(0,p.A)({},L_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}N_n.isMDXComponent=!0;const k_n={toc:[]},z_n="wrapper";function P_n(e){let{components:n,...t}=e;return(0,s.yg)(z_n,(0,p.A)({},k_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}P_n.isMDXComponent=!0;const I_n={toc:[]},R_n="wrapper";function W_n(e){let{components:n,...t}=e;return(0,s.yg)(R_n,(0,p.A)({},I_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}W_n.isMDXComponent=!0;const S_n={toc:[]},B_n="wrapper";function G_n(e){let{components:n,...t}=e;return(0,s.yg)(B_n,(0,p.A)({},S_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}G_n.isMDXComponent=!0;const E_n={toc:[]},O_n="wrapper";function U_n(e){let{components:n,...t}=e;return(0,s.yg)(O_n,(0,p.A)({},E_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}U_n.isMDXComponent=!0;const F_n={toc:[]},V_n="wrapper";function q_n(e){let{components:n,...t}=e;return(0,s.yg)(V_n,(0,p.A)({},F_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}q_n.isMDXComponent=!0;const j_n={toc:[]},H_n="wrapper";function Y_n(e){let{components:n,...t}=e;return(0,s.yg)(H_n,(0,p.A)({},j_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Y_n.isMDXComponent=!0;const Q_n={toc:[]},$_n="wrapper";function K_n(e){let{components:n,...t}=e;return(0,s.yg)($_n,(0,p.A)({},Q_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}K_n.isMDXComponent=!0;const J_n={toc:[]},Z_n="wrapper";function ewn(e){let{components:n,...t}=e;return(0,s.yg)(Z_n,(0,p.A)({},J_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}ewn.isMDXComponent=!0;const nwn={toc:[]},twn="wrapper";function own(e){let{components:n,...t}=e;return(0,s.yg)(twn,(0,p.A)({},nwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}own.isMDXComponent=!0;const pwn={toc:[]},rwn="wrapper";function swn(e){let{components:n,...t}=e;return(0,s.yg)(rwn,(0,p.A)({},pwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}swn.isMDXComponent=!0;const cwn={toc:[]},awn="wrapper";function iwn(e){let{components:n,...t}=e;return(0,s.yg)(awn,(0,p.A)({},cwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}iwn.isMDXComponent=!0;const lwn={toc:[]},uwn="wrapper";function mwn(e){let{components:n,...t}=e;return(0,s.yg)(uwn,(0,p.A)({},lwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mwn.isMDXComponent=!0;const ywn={toc:[]},dwn="wrapper";function hwn(e){let{components:n,...t}=e;return(0,s.yg)(dwn,(0,p.A)({},ywn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}hwn.isMDXComponent=!0;const gwn={toc:[]},fwn="wrapper";function Dwn(e){let{components:n,...t}=e;return(0,s.yg)(fwn,(0,p.A)({},gwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Dwn.isMDXComponent=!0;const Mwn={toc:[]},Xwn="wrapper";function _wn(e){let{components:n,...t}=e;return(0,s.yg)(Xwn,(0,p.A)({},Mwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}_wn.isMDXComponent=!0;const wwn={toc:[]},Twn="wrapper";function Cwn(e){let{components:n,...t}=e;return(0,s.yg)(Twn,(0,p.A)({},wwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Cwn.isMDXComponent=!0;const xwn={toc:[]},Awn="wrapper";function vwn(e){let{components:n,...t}=e;return(0,s.yg)(Awn,(0,p.A)({},xwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}vwn.isMDXComponent=!0;const Lwn={toc:[]},bwn="wrapper";function Nwn(e){let{components:n,...t}=e;return(0,s.yg)(bwn,(0,p.A)({},Lwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Nwn.isMDXComponent=!0;const kwn={toc:[]},zwn="wrapper";function Pwn(e){let{components:n,...t}=e;return(0,s.yg)(zwn,(0,p.A)({},kwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}Pwn.isMDXComponent=!0;const Iwn={toc:[]},Rwn="wrapper";function Wwn(e){let{components:n,...t}=e;return(0,s.yg)(Rwn,(0,p.A)({},Iwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wwn.isMDXComponent=!0;const Swn={toc:[]},Bwn="wrapper";function Gwn(e){let{components:n,...t}=e;return(0,s.yg)(Bwn,(0,p.A)({},Swn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Gwn.isMDXComponent=!0;const Ewn={toc:[]},Own="wrapper";function Uwn(e){let{components:n,...t}=e;return(0,s.yg)(Own,(0,p.A)({},Ewn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Uwn.isMDXComponent=!0;const Fwn={toc:[]},Vwn="wrapper";function qwn(e){let{components:n,...t}=e;return(0,s.yg)(Vwn,(0,p.A)({},Fwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}qwn.isMDXComponent=!0;const jwn={toc:[]},Hwn="wrapper";function Ywn(e){let{components:n,...t}=e;return(0,s.yg)(Hwn,(0,p.A)({},jwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Ywn.isMDXComponent=!0;const Qwn={toc:[]},$wn="wrapper";function Kwn(e){let{components:n,...t}=e;return(0,s.yg)($wn,(0,p.A)({},Qwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]},Zwn="wrapper";function eTn(e){let{components:n,...t}=e;return(0,s.yg)(Zwn,(0,p.A)({},Jwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}eTn.isMDXComponent=!0;const nTn={toc:[]},tTn="wrapper";function oTn(e){let{components:n,...t}=e;return(0,s.yg)(tTn,(0,p.A)({},nTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}oTn.isMDXComponent=!0;const pTn={toc:[]},rTn="wrapper";function sTn(e){let{components:n,...t}=e;return(0,s.yg)(rTn,(0,p.A)({},pTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}sTn.isMDXComponent=!0;const cTn={toc:[]},aTn="wrapper";function iTn(e){let{components:n,...t}=e;return(0,s.yg)(aTn,(0,p.A)({},cTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}iTn.isMDXComponent=!0;const lTn={toc:[]},uTn="wrapper";function mTn(e){let{components:n,...t}=e;return(0,s.yg)(uTn,(0,p.A)({},lTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}mTn.isMDXComponent=!0;const yTn={toc:[]},dTn="wrapper";function hTn(e){let{components:n,...t}=e;return(0,s.yg)(dTn,(0,p.A)({},yTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}hTn.isMDXComponent=!0;const gTn={toc:[]},fTn="wrapper";function DTn(e){let{components:n,...t}=e;return(0,s.yg)(fTn,(0,p.A)({},gTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}DTn.isMDXComponent=!0;const MTn={toc:[]},XTn="wrapper";function _Tn(e){let{components:n,...t}=e;return(0,s.yg)(XTn,(0,p.A)({},MTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}_Tn.isMDXComponent=!0;const wTn={toc:[]},TTn="wrapper";function CTn(e){let{components:n,...t}=e;return(0,s.yg)(TTn,(0,p.A)({},wTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}CTn.isMDXComponent=!0;const xTn={toc:[]},ATn="wrapper";function vTn(e){let{components:n,...t}=e;return(0,s.yg)(ATn,(0,p.A)({},xTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}vTn.isMDXComponent=!0;const LTn={toc:[]},bTn="wrapper";function NTn(e){let{components:n,...t}=e;return(0,s.yg)(bTn,(0,p.A)({},LTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}NTn.isMDXComponent=!0;const kTn={toc:[]},zTn="wrapper";function PTn(e){let{components:n,...t}=e;return(0,s.yg)(zTn,(0,p.A)({},kTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}PTn.isMDXComponent=!0;const ITn={toc:[]},RTn="wrapper";function WTn(e){let{components:n,...t}=e;return(0,s.yg)(RTn,(0,p.A)({},ITn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}WTn.isMDXComponent=!0;const STn={toc:[]},BTn="wrapper";function GTn(e){let{components:n,...t}=e;return(0,s.yg)(BTn,(0,p.A)({},STn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}GTn.isMDXComponent=!0;const ETn={toc:[]},OTn="wrapper";function UTn(e){let{components:n,...t}=e;return(0,s.yg)(OTn,(0,p.A)({},ETn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}UTn.isMDXComponent=!0;const FTn={toc:[]},VTn="wrapper";function qTn(e){let{components:n,...t}=e;return(0,s.yg)(VTn,(0,p.A)({},FTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qTn.isMDXComponent=!0;const jTn={toc:[]},HTn="wrapper";function YTn(e){let{components:n,...t}=e;return(0,s.yg)(HTn,(0,p.A)({},jTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}YTn.isMDXComponent=!0;const QTn={toc:[]},$Tn="wrapper";function KTn(e){let{components:n,...t}=e;return(0,s.yg)($Tn,(0,p.A)({},QTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}KTn.isMDXComponent=!0;const JTn={toc:[]},ZTn="wrapper";function eCn(e){let{components:n,...t}=e;return(0,s.yg)(ZTn,(0,p.A)({},JTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}eCn.isMDXComponent=!0;const nCn={toc:[]},tCn="wrapper";function oCn(e){let{components:n,...t}=e;return(0,s.yg)(tCn,(0,p.A)({},nCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}oCn.isMDXComponent=!0;const pCn={toc:[]},rCn="wrapper";function sCn(e){let{components:n,...t}=e;return(0,s.yg)(rCn,(0,p.A)({},pCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sCn.isMDXComponent=!0;const cCn={toc:[]},aCn="wrapper";function iCn(e){let{components:n,...t}=e;return(0,s.yg)(aCn,(0,p.A)({},cCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}iCn.isMDXComponent=!0;const lCn={toc:[]},uCn="wrapper";function mCn(e){let{components:n,...t}=e;return(0,s.yg)(uCn,(0,p.A)({},lCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}mCn.isMDXComponent=!0;const yCn={toc:[]},dCn="wrapper";function hCn(e){let{components:n,...t}=e;return(0,s.yg)(dCn,(0,p.A)({},yCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}hCn.isMDXComponent=!0;const gCn={toc:[]},fCn="wrapper";function DCn(e){let{components:n,...t}=e;return(0,s.yg)(fCn,(0,p.A)({},gCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}DCn.isMDXComponent=!0;const MCn={toc:[]},XCn="wrapper";function _Cn(e){let{components:n,...t}=e;return(0,s.yg)(XCn,(0,p.A)({},MCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}_Cn.isMDXComponent=!0;const wCn={toc:[]},TCn="wrapper";function CCn(e){let{components:n,...t}=e;return(0,s.yg)(TCn,(0,p.A)({},wCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}CCn.isMDXComponent=!0;const xCn={toc:[]},ACn="wrapper";function vCn(e){let{components:n,...t}=e;return(0,s.yg)(ACn,(0,p.A)({},xCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}vCn.isMDXComponent=!0;const LCn={toc:[]},bCn="wrapper";function NCn(e){let{components:n,...t}=e;return(0,s.yg)(bCn,(0,p.A)({},LCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}NCn.isMDXComponent=!0;const kCn={toc:[]},zCn="wrapper";function PCn(e){let{components:n,...t}=e;return(0,s.yg)(zCn,(0,p.A)({},kCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}PCn.isMDXComponent=!0;const ICn={toc:[]},RCn="wrapper";function WCn(e){let{components:n,...t}=e;return(0,s.yg)(RCn,(0,p.A)({},ICn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}WCn.isMDXComponent=!0;const SCn={toc:[]},BCn="wrapper";function GCn(e){let{components:n,...t}=e;return(0,s.yg)(BCn,(0,p.A)({},SCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}GCn.isMDXComponent=!0;const ECn={toc:[]},OCn="wrapper";function UCn(e){let{components:n,...t}=e;return(0,s.yg)(OCn,(0,p.A)({},ECn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}UCn.isMDXComponent=!0;const FCn={toc:[]},VCn="wrapper";function qCn(e){let{components:n,...t}=e;return(0,s.yg)(VCn,(0,p.A)({},FCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"overrides ",(0,s.yg)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}qCn.isMDXComponent=!0;const jCn={toc:[]},HCn="wrapper";function YCn(e){let{components:n,...t}=e;return(0,s.yg)(HCn,(0,p.A)({},jCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YCn.isMDXComponent=!0;const QCn={toc:[]},$Cn="wrapper";function KCn(e){let{components:n,...t}=e;return(0,s.yg)($Cn,(0,p.A)({},QCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}KCn.isMDXComponent=!0;const JCn={toc:[]},ZCn="wrapper";function exn(e){let{components:n,...t}=e;return(0,s.yg)(ZCn,(0,p.A)({},JCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}exn.isMDXComponent=!0;const nxn={toc:[]},txn="wrapper";function oxn(e){let{components:n,...t}=e;return(0,s.yg)(txn,(0,p.A)({},nxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oxn.isMDXComponent=!0;const pxn={toc:[]},rxn="wrapper";function sxn(e){let{components:n,...t}=e;return(0,s.yg)(rxn,(0,p.A)({},pxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}sxn.isMDXComponent=!0;const cxn={toc:[]},axn="wrapper";function ixn(e){let{components:n,...t}=e;return(0,s.yg)(axn,(0,p.A)({},cxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ixn.isMDXComponent=!0;const lxn={toc:[]},uxn="wrapper";function mxn(e){let{components:n,...t}=e;return(0,s.yg)(uxn,(0,p.A)({},lxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Address to Iconify API for the requested Icon."))}mxn.isMDXComponent=!0;const yxn={toc:[]},dxn="wrapper";function hxn(e){let{components:n,...t}=e;return(0,s.yg)(dxn,(0,p.A)({},yxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create the URL that will be used as the Image source"))}hxn.isMDXComponent=!0;const gxn={toc:[]},fxn="wrapper";function Dxn(e){let{components:n,...t}=e;return(0,s.yg)(fxn,(0,p.A)({},gxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Dxn.isMDXComponent=!0;const Mxn={toc:[]},Xxn="wrapper";function _xn(e){let{components:n,...t}=e;return(0,s.yg)(Xxn,(0,p.A)({},Mxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_xn.isMDXComponent=!0;const wxn={toc:[]},Txn="wrapper";function Cxn(e){let{components:n,...t}=e;return(0,s.yg)(Txn,(0,p.A)({},wxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Cxn.isMDXComponent=!0;const xxn={toc:[]},Axn="wrapper";function vxn(e){let{components:n,...t}=e;return(0,s.yg)(Axn,(0,p.A)({},xxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}vxn.isMDXComponent=!0;const Lxn={toc:[]},bxn="wrapper";function Nxn(e){let{components:n,...t}=e;return(0,s.yg)(bxn,(0,p.A)({},Lxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Nxn.isMDXComponent=!0;const kxn={toc:[]},zxn="wrapper";function Pxn(e){let{components:n,...t}=e;return(0,s.yg)(zxn,(0,p.A)({},kxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Pxn.isMDXComponent=!0;const Ixn={toc:[]},Rxn="wrapper";function Wxn(e){let{components:n,...t}=e;return(0,s.yg)(Rxn,(0,p.A)({},Ixn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Wxn.isMDXComponent=!0;const Sxn={toc:[]},Bxn="wrapper";function Gxn(e){let{components:n,...t}=e;return(0,s.yg)(Bxn,(0,p.A)({},Sxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Gxn.isMDXComponent=!0;const Exn={toc:[]},Oxn="wrapper";function Uxn(e){let{components:n,...t}=e;return(0,s.yg)(Oxn,(0,p.A)({},Exn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Uxn.isMDXComponent=!0;const Fxn={toc:[]},Vxn="wrapper";function qxn(e){let{components:n,...t}=e;return(0,s.yg)(Vxn,(0,p.A)({},Fxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}qxn.isMDXComponent=!0;const jxn={toc:[]},Hxn="wrapper";function Yxn(e){let{components:n,...t}=e;return(0,s.yg)(Hxn,(0,p.A)({},jxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@revideo/2d';\nimport {all, waitFor} from '@revideo/core';\nimport {createRef} from '@revideo/core';\nimport {makeScene2D} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}Yxn.isMDXComponent=!0;const Qxn={toc:[]},$xn="wrapper";function Kxn(e){let{components:n,...t}=e;return(0,s.yg)($xn,(0,p.A)({},Qxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for displaying images."))}Kxn.isMDXComponent=!0;const Jxn={toc:[]},Zxn="wrapper";function eAn(e){let{components:n,...t}=e;return(0,s.yg)(Zxn,(0,p.A)({},Jxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}eAn.isMDXComponent=!0;const nAn={toc:[]},tAn="wrapper";function oAn(e){let{components:n,...t}=e;return(0,s.yg)(tAn,(0,p.A)({},nAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}oAn.isMDXComponent=!0;const pAn={toc:[]},rAn="wrapper";function sAn(e){let{components:n,...t}=e;return(0,s.yg)(rAn,(0,p.A)({},pAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}sAn.isMDXComponent=!0;const cAn={toc:[]},aAn="wrapper";function iAn(e){let{components:n,...t}=e;return(0,s.yg)(aAn,(0,p.A)({},cAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}iAn.isMDXComponent=!0;const lAn={toc:[]},uAn="wrapper";function mAn(e){let{components:n,...t}=e;return(0,s.yg)(uAn,(0,p.A)({},lAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}mAn.isMDXComponent=!0;const yAn={toc:[]},dAn="wrapper";function hAn(e){let{components:n,...t}=e;return(0,s.yg)(dAn,(0,p.A)({},yAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}hAn.isMDXComponent=!0;const gAn={toc:[]},fAn="wrapper";function DAn(e){let{components:n,...t}=e;return(0,s.yg)(fAn,(0,p.A)({},gAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}DAn.isMDXComponent=!0;const MAn={toc:[]},XAn="wrapper";function _An(e){let{components:n,...t}=e;return(0,s.yg)(XAn,(0,p.A)({},MAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}_An.isMDXComponent=!0;const wAn={toc:[]},TAn="wrapper";function CAn(e){let{components:n,...t}=e;return(0,s.yg)(TAn,(0,p.A)({},wAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}CAn.isMDXComponent=!0;const xAn={toc:[]},AAn="wrapper";function vAn(e){let{components:n,...t}=e;return(0,s.yg)(AAn,(0,p.A)({},xAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}vAn.isMDXComponent=!0;const LAn={toc:[]},bAn="wrapper";function NAn(e){let{components:n,...t}=e;return(0,s.yg)(bAn,(0,p.A)({},LAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}NAn.isMDXComponent=!0;const kAn={toc:[]},zAn="wrapper";function PAn(e){let{components:n,...t}=e;return(0,s.yg)(zAn,(0,p.A)({},kAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}PAn.isMDXComponent=!0;const IAn={toc:[]},RAn="wrapper";function WAn(e){let{components:n,...t}=e;return(0,s.yg)(RAn,(0,p.A)({},IAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}WAn.isMDXComponent=!0;const SAn={toc:[]},BAn="wrapper";function GAn(e){let{components:n,...t}=e;return(0,s.yg)(BAn,(0,p.A)({},SAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}GAn.isMDXComponent=!0;const EAn={toc:[]},OAn="wrapper";function UAn(e){let{components:n,...t}=e;return(0,s.yg)(OAn,(0,p.A)({},EAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}UAn.isMDXComponent=!0;const FAn={toc:[]},VAn="wrapper";function qAn(e){let{components:n,...t}=e;return(0,s.yg)(VAn,(0,p.A)({},FAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}qAn.isMDXComponent=!0;const jAn={toc:[]},HAn="wrapper";function YAn(e){let{components:n,...t}=e;return(0,s.yg)(HAn,(0,p.A)({},jAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}YAn.isMDXComponent=!0;const QAn={toc:[]},$An="wrapper";function KAn(e){let{components:n,...t}=e;return(0,s.yg)($An,(0,p.A)({},QAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}KAn.isMDXComponent=!0;const JAn={toc:[]},ZAn="wrapper";function evn(e){let{components:n,...t}=e;return(0,s.yg)(ZAn,(0,p.A)({},JAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}evn.isMDXComponent=!0;const nvn={toc:[]},tvn="wrapper";function ovn(e){let{components:n,...t}=e;return(0,s.yg)(tvn,(0,p.A)({},nvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}ovn.isMDXComponent=!0;const pvn={toc:[]},rvn="wrapper";function svn(e){let{components:n,...t}=e;return(0,s.yg)(rvn,(0,p.A)({},pvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}svn.isMDXComponent=!0;const cvn={toc:[]},avn="wrapper";function ivn(e){let{components:n,...t}=e;return(0,s.yg)(avn,(0,p.A)({},cvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}ivn.isMDXComponent=!0;const lvn={toc:[]},uvn="wrapper";function mvn(e){let{components:n,...t}=e;return(0,s.yg)(uvn,(0,p.A)({},lvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mvn.isMDXComponent=!0;const yvn={toc:[]},dvn="wrapper";function hvn(e){let{components:n,...t}=e;return(0,s.yg)(dvn,(0,p.A)({},yvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}hvn.isMDXComponent=!0;const gvn={toc:[]},fvn="wrapper";function Dvn(e){let{components:n,...t}=e;return(0,s.yg)(fvn,(0,p.A)({},gvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Dvn.isMDXComponent=!0;const Mvn={toc:[]},Xvn="wrapper";function _vn(e){let{components:n,...t}=e;return(0,s.yg)(Xvn,(0,p.A)({},Mvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_vn.isMDXComponent=!0;const wvn={toc:[]},Tvn="wrapper";function Cvn(e){let{components:n,...t}=e;return(0,s.yg)(Tvn,(0,p.A)({},wvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Cvn.isMDXComponent=!0;const xvn={toc:[]},Avn="wrapper";function vvn(e){let{components:n,...t}=e;return(0,s.yg)(Avn,(0,p.A)({},xvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}vvn.isMDXComponent=!0;const Lvn={toc:[]},bvn="wrapper";function Nvn(e){let{components:n,...t}=e;return(0,s.yg)(bvn,(0,p.A)({},Lvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Nvn.isMDXComponent=!0;const kvn={toc:[]},zvn="wrapper";function Pvn(e){let{components:n,...t}=e;return(0,s.yg)(zvn,(0,p.A)({},kvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Pvn.isMDXComponent=!0;const Ivn={toc:[]},Rvn="wrapper";function Wvn(e){let{components:n,...t}=e;return(0,s.yg)(Rvn,(0,p.A)({},Ivn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Wvn.isMDXComponent=!0;const Svn={toc:[]},Bvn="wrapper";function Gvn(e){let{components:n,...t}=e;return(0,s.yg)(Bvn,(0,p.A)({},Svn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Gvn.isMDXComponent=!0;const Evn={toc:[]},Ovn="wrapper";function Uvn(e){let{components:n,...t}=e;return(0,s.yg)(Ovn,(0,p.A)({},Evn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Uvn.isMDXComponent=!0;const Fvn={toc:[]},Vvn="wrapper";function qvn(e){let{components:n,...t}=e;return(0,s.yg)(Vvn,(0,p.A)({},Fvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qvn.isMDXComponent=!0;const jvn={toc:[]},Hvn="wrapper";function Yvn(e){let{components:n,...t}=e;return(0,s.yg)(Hvn,(0,p.A)({},jvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Yvn.isMDXComponent=!0;const Qvn={toc:[]},$vn="wrapper";function Kvn(e){let{components:n,...t}=e;return(0,s.yg)($vn,(0,p.A)({},Qvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Kvn.isMDXComponent=!0;const Jvn={toc:[]},Zvn="wrapper";function eLn(e){let{components:n,...t}=e;return(0,s.yg)(Zvn,(0,p.A)({},Jvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}eLn.isMDXComponent=!0;const nLn={toc:[]},tLn="wrapper";function oLn(e){let{components:n,...t}=e;return(0,s.yg)(tLn,(0,p.A)({},nLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}oLn.isMDXComponent=!0;const pLn={toc:[]},rLn="wrapper";function sLn(e){let{components:n,...t}=e;return(0,s.yg)(rLn,(0,p.A)({},pLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}sLn.isMDXComponent=!0;const cLn={toc:[]},aLn="wrapper";function iLn(e){let{components:n,...t}=e;return(0,s.yg)(aLn,(0,p.A)({},cLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}iLn.isMDXComponent=!0;const lLn={toc:[]},uLn="wrapper";function mLn(e){let{components:n,...t}=e;return(0,s.yg)(uLn,(0,p.A)({},lLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}mLn.isMDXComponent=!0;const yLn={toc:[]},dLn="wrapper";function hLn(e){let{components:n,...t}=e;return(0,s.yg)(dLn,(0,p.A)({},yLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}hLn.isMDXComponent=!0;const gLn={toc:[]},fLn="wrapper";function DLn(e){let{components:n,...t}=e;return(0,s.yg)(fLn,(0,p.A)({},gLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}DLn.isMDXComponent=!0;const MLn={toc:[]},XLn="wrapper";function _Ln(e){let{components:n,...t}=e;return(0,s.yg)(XLn,(0,p.A)({},MLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}_Ln.isMDXComponent=!0;const wLn={toc:[]},TLn="wrapper";function CLn(e){let{components:n,...t}=e;return(0,s.yg)(TLn,(0,p.A)({},wLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}CLn.isMDXComponent=!0;const xLn={toc:[]},ALn="wrapper";function vLn(e){let{components:n,...t}=e;return(0,s.yg)(ALn,(0,p.A)({},xLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vLn.isMDXComponent=!0;const LLn={toc:[]},bLn="wrapper";function NLn(e){let{components:n,...t}=e;return(0,s.yg)(bLn,(0,p.A)({},LLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NLn.isMDXComponent=!0;const kLn={toc:[]},zLn="wrapper";function PLn(e){let{components:n,...t}=e;return(0,s.yg)(zLn,(0,p.A)({},kLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}PLn.isMDXComponent=!0;const ILn={toc:[]},RLn="wrapper";function WLn(e){let{components:n,...t}=e;return(0,s.yg)(RLn,(0,p.A)({},ILn,t,{components:n,mdxType:"MDXLayout"}))}WLn.isMDXComponent=!0;const SLn={toc:[]},BLn="wrapper";function GLn(e){let{components:n,...t}=e;return(0,s.yg)(BLn,(0,p.A)({},SLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}GLn.isMDXComponent=!0;const ELn={toc:[]},OLn="wrapper";function ULn(e){let{components:n,...t}=e;return(0,s.yg)(OLn,(0,p.A)({},ELn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ULn.isMDXComponent=!0;const FLn={toc:[]},VLn="wrapper";function qLn(e){let{components:n,...t}=e;return(0,s.yg)(VLn,(0,p.A)({},FLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}qLn.isMDXComponent=!0;const jLn={toc:[]},HLn="wrapper";function YLn(e){let{components:n,...t}=e;return(0,s.yg)(HLn,(0,p.A)({},jLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}YLn.isMDXComponent=!0;const QLn={toc:[]},$Ln="wrapper";function KLn(e){let{components:n,...t}=e;return(0,s.yg)($Ln,(0,p.A)({},QLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}KLn.isMDXComponent=!0;const JLn={toc:[]},ZLn="wrapper";function ebn(e){let{components:n,...t}=e;return(0,s.yg)(ZLn,(0,p.A)({},JLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}ebn.isMDXComponent=!0;const nbn={toc:[]},tbn="wrapper";function obn(e){let{components:n,...t}=e;return(0,s.yg)(tbn,(0,p.A)({},nbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}obn.isMDXComponent=!0;const pbn={toc:[]},rbn="wrapper";function sbn(e){let{components:n,...t}=e;return(0,s.yg)(rbn,(0,p.A)({},pbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}sbn.isMDXComponent=!0;const cbn={toc:[]},abn="wrapper";function ibn(e){let{components:n,...t}=e;return(0,s.yg)(abn,(0,p.A)({},cbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}ibn.isMDXComponent=!0;const lbn={toc:[]},ubn="wrapper";function mbn(e){let{components:n,...t}=e;return(0,s.yg)(ubn,(0,p.A)({},lbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}mbn.isMDXComponent=!0;const ybn={toc:[]},dbn="wrapper";function hbn(e){let{components:n,...t}=e;return(0,s.yg)(dbn,(0,p.A)({},ybn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}hbn.isMDXComponent=!0;const gbn={toc:[]},fbn="wrapper";function Dbn(e){let{components:n,...t}=e;return(0,s.yg)(fbn,(0,p.A)({},gbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Dbn.isMDXComponent=!0;const Mbn={toc:[]},Xbn="wrapper";function _bn(e){let{components:n,...t}=e;return(0,s.yg)(Xbn,(0,p.A)({},Mbn,t,{components:n,mdxType:"MDXLayout"}))}_bn.isMDXComponent=!0;const wbn={toc:[]},Tbn="wrapper";function Cbn(e){let{components:n,...t}=e;return(0,s.yg)(Tbn,(0,p.A)({},wbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Cbn.isMDXComponent=!0;const xbn={toc:[]},Abn="wrapper";function vbn(e){let{components:n,...t}=e;return(0,s.yg)(Abn,(0,p.A)({},xbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}vbn.isMDXComponent=!0;const Lbn={toc:[]},bbn="wrapper";function Nbn(e){let{components:n,...t}=e;return(0,s.yg)(bbn,(0,p.A)({},Lbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nbn.isMDXComponent=!0;const kbn={toc:[]},zbn="wrapper";function Pbn(e){let{components:n,...t}=e;return(0,s.yg)(zbn,(0,p.A)({},kbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Pbn.isMDXComponent=!0;const Ibn={toc:[]},Rbn="wrapper";function Wbn(e){let{components:n,...t}=e;return(0,s.yg)(Rbn,(0,p.A)({},Ibn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wbn.isMDXComponent=!0;const Sbn={toc:[]},Bbn="wrapper";function Gbn(e){let{components:n,...t}=e;return(0,s.yg)(Bbn,(0,p.A)({},Sbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Gbn.isMDXComponent=!0;const Ebn={toc:[]},Obn="wrapper";function Ubn(e){let{components:n,...t}=e;return(0,s.yg)(Obn,(0,p.A)({},Ebn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ubn.isMDXComponent=!0;const Fbn={toc:[]},Vbn="wrapper";function qbn(e){let{components:n,...t}=e;return(0,s.yg)(Vbn,(0,p.A)({},Fbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}qbn.isMDXComponent=!0;const jbn={toc:[]},Hbn="wrapper";function Ybn(e){let{components:n,...t}=e;return(0,s.yg)(Hbn,(0,p.A)({},jbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ybn.isMDXComponent=!0;const Qbn={toc:[]},$bn="wrapper";function Kbn(e){let{components:n,...t}=e;return(0,s.yg)($bn,(0,p.A)({},Qbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Kbn.isMDXComponent=!0;const Jbn={toc:[]},Zbn="wrapper";function eNn(e){let{components:n,...t}=e;return(0,s.yg)(Zbn,(0,p.A)({},Jbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}eNn.isMDXComponent=!0;const nNn={toc:[]},tNn="wrapper";function oNn(e){let{components:n,...t}=e;return(0,s.yg)(tNn,(0,p.A)({},nNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}oNn.isMDXComponent=!0;const pNn={toc:[]},rNn="wrapper";function sNn(e){let{components:n,...t}=e;return(0,s.yg)(rNn,(0,p.A)({},pNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}sNn.isMDXComponent=!0;const cNn={toc:[]},aNn="wrapper";function iNn(e){let{components:n,...t}=e;return(0,s.yg)(aNn,(0,p.A)({},cNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}iNn.isMDXComponent=!0;const lNn={toc:[]},uNn="wrapper";function mNn(e){let{components:n,...t}=e;return(0,s.yg)(uNn,(0,p.A)({},lNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}mNn.isMDXComponent=!0;const yNn={toc:[]},dNn="wrapper";function hNn(e){let{components:n,...t}=e;return(0,s.yg)(dNn,(0,p.A)({},yNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hNn.isMDXComponent=!0;const gNn={toc:[]},fNn="wrapper";function DNn(e){let{components:n,...t}=e;return(0,s.yg)(fNn,(0,p.A)({},gNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}DNn.isMDXComponent=!0;const MNn={toc:[]},XNn="wrapper";function _Nn(e){let{components:n,...t}=e;return(0,s.yg)(XNn,(0,p.A)({},MNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}_Nn.isMDXComponent=!0;const wNn={toc:[]},TNn="wrapper";function CNn(e){let{components:n,...t}=e;return(0,s.yg)(TNn,(0,p.A)({},wNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}CNn.isMDXComponent=!0;const xNn={toc:[]},ANn="wrapper";function vNn(e){let{components:n,...t}=e;return(0,s.yg)(ANn,(0,p.A)({},xNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}vNn.isMDXComponent=!0;const LNn={toc:[]},bNn="wrapper";function NNn(e){let{components:n,...t}=e;return(0,s.yg)(bNn,(0,p.A)({},LNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}NNn.isMDXComponent=!0;const kNn={toc:[]},zNn="wrapper";function PNn(e){let{components:n,...t}=e;return(0,s.yg)(zNn,(0,p.A)({},kNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}PNn.isMDXComponent=!0;const INn={toc:[]},RNn="wrapper";function WNn(e){let{components:n,...t}=e;return(0,s.yg)(RNn,(0,p.A)({},INn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}WNn.isMDXComponent=!0;const SNn={toc:[]},BNn="wrapper";function GNn(e){let{components:n,...t}=e;return(0,s.yg)(BNn,(0,p.A)({},SNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}GNn.isMDXComponent=!0;const ENn={toc:[]},ONn="wrapper";function UNn(e){let{components:n,...t}=e;return(0,s.yg)(ONn,(0,p.A)({},ENn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}UNn.isMDXComponent=!0;const FNn={toc:[]},VNn="wrapper";function qNn(e){let{components:n,...t}=e;return(0,s.yg)(VNn,(0,p.A)({},FNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}qNn.isMDXComponent=!0;const jNn={toc:[]},HNn="wrapper";function YNn(e){let{components:n,...t}=e;return(0,s.yg)(HNn,(0,p.A)({},jNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}YNn.isMDXComponent=!0;const QNn={toc:[]},$Nn="wrapper";function KNn(e){let{components:n,...t}=e;return(0,s.yg)($Nn,(0,p.A)({},QNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}KNn.isMDXComponent=!0;const JNn={toc:[]},ZNn="wrapper";function ekn(e){let{components:n,...t}=e;return(0,s.yg)(ZNn,(0,p.A)({},JNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ekn.isMDXComponent=!0;const nkn={toc:[]},tkn="wrapper";function okn(e){let{components:n,...t}=e;return(0,s.yg)(tkn,(0,p.A)({},nkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}okn.isMDXComponent=!0;const pkn={toc:[]},rkn="wrapper";function skn(e){let{components:n,...t}=e;return(0,s.yg)(rkn,(0,p.A)({},pkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}skn.isMDXComponent=!0;const ckn={toc:[]},akn="wrapper";function ikn(e){let{components:n,...t}=e;return(0,s.yg)(akn,(0,p.A)({},ckn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}ikn.isMDXComponent=!0;const lkn={toc:[]},ukn="wrapper";function mkn(e){let{components:n,...t}=e;return(0,s.yg)(ukn,(0,p.A)({},lkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}mkn.isMDXComponent=!0;const ykn={toc:[]},dkn="wrapper";function hkn(e){let{components:n,...t}=e;return(0,s.yg)(dkn,(0,p.A)({},ykn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}hkn.isMDXComponent=!0;const gkn={toc:[]},fkn="wrapper";function Dkn(e){let{components:n,...t}=e;return(0,s.yg)(fkn,(0,p.A)({},gkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Dkn.isMDXComponent=!0;const Mkn={toc:[]},Xkn="wrapper";function _kn(e){let{components:n,...t}=e;return(0,s.yg)(Xkn,(0,p.A)({},Mkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}_kn.isMDXComponent=!0;const wkn={toc:[]},Tkn="wrapper";function Ckn(e){let{components:n,...t}=e;return(0,s.yg)(Tkn,(0,p.A)({},wkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Ckn.isMDXComponent=!0;const xkn={toc:[]},Akn="wrapper";function vkn(e){let{components:n,...t}=e;return(0,s.yg)(Akn,(0,p.A)({},xkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}vkn.isMDXComponent=!0;const Lkn={toc:[]},bkn="wrapper";function Nkn(e){let{components:n,...t}=e;return(0,s.yg)(bkn,(0,p.A)({},Lkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Nkn.isMDXComponent=!0;const kkn={toc:[]},zkn="wrapper";function Pkn(e){let{components:n,...t}=e;return(0,s.yg)(zkn,(0,p.A)({},kkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Pkn.isMDXComponent=!0;const Ikn={toc:[]},Rkn="wrapper";function Wkn(e){let{components:n,...t}=e;return(0,s.yg)(Rkn,(0,p.A)({},Ikn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Wkn.isMDXComponent=!0;const Skn={toc:[]},Bkn="wrapper";function Gkn(e){let{components:n,...t}=e;return(0,s.yg)(Bkn,(0,p.A)({},Skn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Gkn.isMDXComponent=!0;const Ekn={toc:[]},Okn="wrapper";function Ukn(e){let{components:n,...t}=e;return(0,s.yg)(Okn,(0,p.A)({},Ekn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Ukn.isMDXComponent=!0;const Fkn={toc:[]},Vkn="wrapper";function qkn(e){let{components:n,...t}=e;return(0,s.yg)(Vkn,(0,p.A)({},Fkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}qkn.isMDXComponent=!0;const jkn={toc:[]},Hkn="wrapper";function Ykn(e){let{components:n,...t}=e;return(0,s.yg)(Hkn,(0,p.A)({},jkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Ykn.isMDXComponent=!0;const Qkn={toc:[]},$kn="wrapper";function Kkn(e){let{components:n,...t}=e;return(0,s.yg)($kn,(0,p.A)({},Qkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]},Zkn="wrapper";function ezn(e){let{components:n,...t}=e;return(0,s.yg)(Zkn,(0,p.A)({},Jkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}ezn.isMDXComponent=!0;const nzn={toc:[]},tzn="wrapper";function ozn(e){let{components:n,...t}=e;return(0,s.yg)(tzn,(0,p.A)({},nzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ozn.isMDXComponent=!0;const pzn={toc:[]},rzn="wrapper";function szn(e){let{components:n,...t}=e;return(0,s.yg)(rzn,(0,p.A)({},pzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}szn.isMDXComponent=!0;const czn={toc:[]},azn="wrapper";function izn(e){let{components:n,...t}=e;return(0,s.yg)(azn,(0,p.A)({},czn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}izn.isMDXComponent=!0;const lzn={toc:[]},uzn="wrapper";function mzn(e){let{components:n,...t}=e;return(0,s.yg)(uzn,(0,p.A)({},lzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mzn.isMDXComponent=!0;const yzn={toc:[]},dzn="wrapper";function hzn(e){let{components:n,...t}=e;return(0,s.yg)(dzn,(0,p.A)({},yzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}hzn.isMDXComponent=!0;const gzn={toc:[]},fzn="wrapper";function Dzn(e){let{components:n,...t}=e;return(0,s.yg)(fzn,(0,p.A)({},gzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Dzn.isMDXComponent=!0;const Mzn={toc:[]},Xzn="wrapper";function _zn(e){let{components:n,...t}=e;return(0,s.yg)(Xzn,(0,p.A)({},Mzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}_zn.isMDXComponent=!0;const wzn={toc:[]},Tzn="wrapper";function Czn(e){let{components:n,...t}=e;return(0,s.yg)(Tzn,(0,p.A)({},wzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Czn.isMDXComponent=!0;const xzn={toc:[]},Azn="wrapper";function vzn(e){let{components:n,...t}=e;return(0,s.yg)(Azn,(0,p.A)({},xzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vzn.isMDXComponent=!0;const Lzn={toc:[]},bzn="wrapper";function Nzn(e){let{components:n,...t}=e;return(0,s.yg)(bzn,(0,p.A)({},Lzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Nzn.isMDXComponent=!0;const kzn={toc:[]},zzn="wrapper";function Pzn(e){let{components:n,...t}=e;return(0,s.yg)(zzn,(0,p.A)({},kzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Pzn.isMDXComponent=!0;const Izn={toc:[]},Rzn="wrapper";function Wzn(e){let{components:n,...t}=e;return(0,s.yg)(Rzn,(0,p.A)({},Izn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Wzn.isMDXComponent=!0;const Szn={toc:[]},Bzn="wrapper";function Gzn(e){let{components:n,...t}=e;return(0,s.yg)(Bzn,(0,p.A)({},Szn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Gzn.isMDXComponent=!0;const Ezn={toc:[]},Ozn="wrapper";function Uzn(e){let{components:n,...t}=e;return(0,s.yg)(Ozn,(0,p.A)({},Ezn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Uzn.isMDXComponent=!0;const Fzn={toc:[]},Vzn="wrapper";function qzn(e){let{components:n,...t}=e;return(0,s.yg)(Vzn,(0,p.A)({},Fzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qzn.isMDXComponent=!0;const jzn={toc:[]},Hzn="wrapper";function Yzn(e){let{components:n,...t}=e;return(0,s.yg)(Hzn,(0,p.A)({},jzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Yzn.isMDXComponent=!0;const Qzn={toc:[]},$zn="wrapper";function Kzn(e){let{components:n,...t}=e;return(0,s.yg)($zn,(0,p.A)({},Qzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Kzn.isMDXComponent=!0;const Jzn={toc:[]},Zzn="wrapper";function ePn(e){let{components:n,...t}=e;return(0,s.yg)(Zzn,(0,p.A)({},Jzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}ePn.isMDXComponent=!0;const nPn={toc:[]},tPn="wrapper";function oPn(e){let{components:n,...t}=e;return(0,s.yg)(tPn,(0,p.A)({},nPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oPn.isMDXComponent=!0;const pPn={toc:[]},rPn="wrapper";function sPn(e){let{components:n,...t}=e;return(0,s.yg)(rPn,(0,p.A)({},pPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}sPn.isMDXComponent=!0;const cPn={toc:[]},aPn="wrapper";function iPn(e){let{components:n,...t}=e;return(0,s.yg)(aPn,(0,p.A)({},cPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}iPn.isMDXComponent=!0;const lPn={toc:[]},uPn="wrapper";function mPn(e){let{components:n,...t}=e;return(0,s.yg)(uPn,(0,p.A)({},lPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}mPn.isMDXComponent=!0;const yPn={toc:[]},dPn="wrapper";function hPn(e){let{components:n,...t}=e;return(0,s.yg)(dPn,(0,p.A)({},yPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hPn.isMDXComponent=!0;const gPn={toc:[]},fPn="wrapper";function DPn(e){let{components:n,...t}=e;return(0,s.yg)(fPn,(0,p.A)({},gPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}DPn.isMDXComponent=!0;const MPn={toc:[]},XPn="wrapper";function _Pn(e){let{components:n,...t}=e;return(0,s.yg)(XPn,(0,p.A)({},MPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}_Pn.isMDXComponent=!0;const wPn={toc:[]},TPn="wrapper";function CPn(e){let{components:n,...t}=e;return(0,s.yg)(TPn,(0,p.A)({},wPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}CPn.isMDXComponent=!0;const xPn={toc:[]},APn="wrapper";function vPn(e){let{components:n,...t}=e;return(0,s.yg)(APn,(0,p.A)({},xPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}vPn.isMDXComponent=!0;const LPn={toc:[]},bPn="wrapper";function NPn(e){let{components:n,...t}=e;return(0,s.yg)(bPn,(0,p.A)({},LPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}NPn.isMDXComponent=!0;const kPn={toc:[]},zPn="wrapper";function PPn(e){let{components:n,...t}=e;return(0,s.yg)(zPn,(0,p.A)({},kPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}PPn.isMDXComponent=!0;const IPn={toc:[]},RPn="wrapper";function WPn(e){let{components:n,...t}=e;return(0,s.yg)(RPn,(0,p.A)({},IPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}WPn.isMDXComponent=!0;const SPn={toc:[]},BPn="wrapper";function GPn(e){let{components:n,...t}=e;return(0,s.yg)(BPn,(0,p.A)({},SPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}GPn.isMDXComponent=!0;const EPn={toc:[]},OPn="wrapper";function UPn(e){let{components:n,...t}=e;return(0,s.yg)(OPn,(0,p.A)({},EPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}UPn.isMDXComponent=!0;const FPn={toc:[]},VPn="wrapper";function qPn(e){let{components:n,...t}=e;return(0,s.yg)(VPn,(0,p.A)({},FPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}qPn.isMDXComponent=!0;const jPn={toc:[]},HPn="wrapper";function YPn(e){let{components:n,...t}=e;return(0,s.yg)(HPn,(0,p.A)({},jPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}YPn.isMDXComponent=!0;const QPn={toc:[]},$Pn="wrapper";function KPn(e){let{components:n,...t}=e;return(0,s.yg)($Pn,(0,p.A)({},QPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}KPn.isMDXComponent=!0;const JPn={toc:[]},ZPn="wrapper";function eIn(e){let{components:n,...t}=e;return(0,s.yg)(ZPn,(0,p.A)({},JPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}eIn.isMDXComponent=!0;const nIn={toc:[]},tIn="wrapper";function oIn(e){let{components:n,...t}=e;return(0,s.yg)(tIn,(0,p.A)({},nIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}oIn.isMDXComponent=!0;const pIn={toc:[]},rIn="wrapper";function sIn(e){let{components:n,...t}=e;return(0,s.yg)(rIn,(0,p.A)({},pIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}sIn.isMDXComponent=!0;const cIn={toc:[]},aIn="wrapper";function iIn(e){let{components:n,...t}=e;return(0,s.yg)(aIn,(0,p.A)({},cIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}iIn.isMDXComponent=!0;const lIn={toc:[]},uIn="wrapper";function mIn(e){let{components:n,...t}=e;return(0,s.yg)(uIn,(0,p.A)({},lIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}mIn.isMDXComponent=!0;const yIn={toc:[]},dIn="wrapper";function hIn(e){let{components:n,...t}=e;return(0,s.yg)(dIn,(0,p.A)({},yIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}hIn.isMDXComponent=!0;const gIn={toc:[]},fIn="wrapper";function DIn(e){let{components:n,...t}=e;return(0,s.yg)(fIn,(0,p.A)({},gIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}DIn.isMDXComponent=!0;const MIn={toc:[]},XIn="wrapper";function _In(e){let{components:n,...t}=e;return(0,s.yg)(XIn,(0,p.A)({},MIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}_In.isMDXComponent=!0;const wIn={toc:[]},TIn="wrapper";function CIn(e){let{components:n,...t}=e;return(0,s.yg)(TIn,(0,p.A)({},wIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}CIn.isMDXComponent=!0;const xIn={toc:[]},AIn="wrapper";function vIn(e){let{components:n,...t}=e;return(0,s.yg)(AIn,(0,p.A)({},xIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}vIn.isMDXComponent=!0;const LIn={toc:[]},bIn="wrapper";function NIn(e){let{components:n,...t}=e;return(0,s.yg)(bIn,(0,p.A)({},LIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}NIn.isMDXComponent=!0;const kIn={toc:[]},zIn="wrapper";function PIn(e){let{components:n,...t}=e;return(0,s.yg)(zIn,(0,p.A)({},kIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PIn.isMDXComponent=!0;const IIn={toc:[]},RIn="wrapper";function WIn(e){let{components:n,...t}=e;return(0,s.yg)(RIn,(0,p.A)({},IIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}WIn.isMDXComponent=!0;const SIn={toc:[]},BIn="wrapper";function GIn(e){let{components:n,...t}=e;return(0,s.yg)(BIn,(0,p.A)({},SIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}GIn.isMDXComponent=!0;const EIn={toc:[]},OIn="wrapper";function UIn(e){let{components:n,...t}=e;return(0,s.yg)(OIn,(0,p.A)({},EIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}UIn.isMDXComponent=!0;const FIn={toc:[]},VIn="wrapper";function qIn(e){let{components:n,...t}=e;return(0,s.yg)(VIn,(0,p.A)({},FIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}qIn.isMDXComponent=!0;const jIn={toc:[]},HIn="wrapper";function YIn(e){let{components:n,...t}=e;return(0,s.yg)(HIn,(0,p.A)({},jIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}YIn.isMDXComponent=!0;const QIn={toc:[]},$In="wrapper";function KIn(e){let{components:n,...t}=e;return(0,s.yg)($In,(0,p.A)({},QIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}KIn.isMDXComponent=!0;const JIn={toc:[]},ZIn="wrapper";function eRn(e){let{components:n,...t}=e;return(0,s.yg)(ZIn,(0,p.A)({},JIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}eRn.isMDXComponent=!0;const nRn={toc:[]},tRn="wrapper";function oRn(e){let{components:n,...t}=e;return(0,s.yg)(tRn,(0,p.A)({},nRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}oRn.isMDXComponent=!0;const pRn={toc:[]},rRn="wrapper";function sRn(e){let{components:n,...t}=e;return(0,s.yg)(rRn,(0,p.A)({},pRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}sRn.isMDXComponent=!0;const cRn={toc:[]},aRn="wrapper";function iRn(e){let{components:n,...t}=e;return(0,s.yg)(aRn,(0,p.A)({},cRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}iRn.isMDXComponent=!0;const lRn={toc:[]},uRn="wrapper";function mRn(e){let{components:n,...t}=e;return(0,s.yg)(uRn,(0,p.A)({},lRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}mRn.isMDXComponent=!0;const yRn={toc:[]},dRn="wrapper";function hRn(e){let{components:n,...t}=e;return(0,s.yg)(dRn,(0,p.A)({},yRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hRn.isMDXComponent=!0;const gRn={toc:[]},fRn="wrapper";function DRn(e){let{components:n,...t}=e;return(0,s.yg)(fRn,(0,p.A)({},gRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}DRn.isMDXComponent=!0;const MRn={toc:[]},XRn="wrapper";function _Rn(e){let{components:n,...t}=e;return(0,s.yg)(XRn,(0,p.A)({},MRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}_Rn.isMDXComponent=!0;const wRn={toc:[]},TRn="wrapper";function CRn(e){let{components:n,...t}=e;return(0,s.yg)(TRn,(0,p.A)({},wRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}CRn.isMDXComponent=!0;const xRn={toc:[]},ARn="wrapper";function vRn(e){let{components:n,...t}=e;return(0,s.yg)(ARn,(0,p.A)({},xRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}vRn.isMDXComponent=!0;const LRn={toc:[]},bRn="wrapper";function NRn(e){let{components:n,...t}=e;return(0,s.yg)(bRn,(0,p.A)({},LRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}NRn.isMDXComponent=!0;const kRn={toc:[]},zRn="wrapper";function PRn(e){let{components:n,...t}=e;return(0,s.yg)(zRn,(0,p.A)({},kRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}PRn.isMDXComponent=!0;const IRn={toc:[]},RRn="wrapper";function WRn(e){let{components:n,...t}=e;return(0,s.yg)(RRn,(0,p.A)({},IRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}WRn.isMDXComponent=!0;const SRn={toc:[]},BRn="wrapper";function GRn(e){let{components:n,...t}=e;return(0,s.yg)(BRn,(0,p.A)({},SRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}GRn.isMDXComponent=!0;const ERn={toc:[]},ORn="wrapper";function URn(e){let{components:n,...t}=e;return(0,s.yg)(ORn,(0,p.A)({},ERn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}URn.isMDXComponent=!0;const FRn={toc:[]},VRn="wrapper";function qRn(e){let{components:n,...t}=e;return(0,s.yg)(VRn,(0,p.A)({},FRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qRn.isMDXComponent=!0;const jRn={toc:[]},HRn="wrapper";function YRn(e){let{components:n,...t}=e;return(0,s.yg)(HRn,(0,p.A)({},jRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}YRn.isMDXComponent=!0;const QRn={toc:[]},$Rn="wrapper";function KRn(e){let{components:n,...t}=e;return(0,s.yg)($Rn,(0,p.A)({},QRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}KRn.isMDXComponent=!0;const JRn={toc:[]},ZRn="wrapper";function eWn(e){let{components:n,...t}=e;return(0,s.yg)(ZRn,(0,p.A)({},JRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}eWn.isMDXComponent=!0;const nWn={toc:[]},tWn="wrapper";function oWn(e){let{components:n,...t}=e;return(0,s.yg)(tWn,(0,p.A)({},nWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}oWn.isMDXComponent=!0;const pWn={toc:[]},rWn="wrapper";function sWn(e){let{components:n,...t}=e;return(0,s.yg)(rWn,(0,p.A)({},pWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}sWn.isMDXComponent=!0;const cWn={toc:[]},aWn="wrapper";function iWn(e){let{components:n,...t}=e;return(0,s.yg)(aWn,(0,p.A)({},cWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}iWn.isMDXComponent=!0;const lWn={toc:[]},uWn="wrapper";function mWn(e){let{components:n,...t}=e;return(0,s.yg)(uWn,(0,p.A)({},lWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}mWn.isMDXComponent=!0;const yWn={toc:[]},dWn="wrapper";function hWn(e){let{components:n,...t}=e;return(0,s.yg)(dWn,(0,p.A)({},yWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}hWn.isMDXComponent=!0;const gWn={toc:[]},fWn="wrapper";function DWn(e){let{components:n,...t}=e;return(0,s.yg)(fWn,(0,p.A)({},gWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}DWn.isMDXComponent=!0;const MWn={toc:[]},XWn="wrapper";function _Wn(e){let{components:n,...t}=e;return(0,s.yg)(XWn,(0,p.A)({},MWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}_Wn.isMDXComponent=!0;const wWn={toc:[]},TWn="wrapper";function CWn(e){let{components:n,...t}=e;return(0,s.yg)(TWn,(0,p.A)({},wWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}CWn.isMDXComponent=!0;const xWn={toc:[]},AWn="wrapper";function vWn(e){let{components:n,...t}=e;return(0,s.yg)(AWn,(0,p.A)({},xWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}vWn.isMDXComponent=!0;const LWn={toc:[]},bWn="wrapper";function NWn(e){let{components:n,...t}=e;return(0,s.yg)(bWn,(0,p.A)({},LWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}NWn.isMDXComponent=!0;const kWn={toc:[]},zWn="wrapper";function PWn(e){let{components:n,...t}=e;return(0,s.yg)(zWn,(0,p.A)({},kWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}PWn.isMDXComponent=!0;const IWn={toc:[]},RWn="wrapper";function WWn(e){let{components:n,...t}=e;return(0,s.yg)(RWn,(0,p.A)({},IWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}WWn.isMDXComponent=!0;const SWn={toc:[]},BWn="wrapper";function GWn(e){let{components:n,...t}=e;return(0,s.yg)(BWn,(0,p.A)({},SWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}GWn.isMDXComponent=!0;const EWn={toc:[]},OWn="wrapper";function UWn(e){let{components:n,...t}=e;return(0,s.yg)(OWn,(0,p.A)({},EWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}UWn.isMDXComponent=!0;const FWn={toc:[]},VWn="wrapper";function qWn(e){let{components:n,...t}=e;return(0,s.yg)(VWn,(0,p.A)({},FWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}qWn.isMDXComponent=!0;const jWn={toc:[]},HWn="wrapper";function YWn(e){let{components:n,...t}=e;return(0,s.yg)(HWn,(0,p.A)({},jWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}YWn.isMDXComponent=!0;const QWn={toc:[]},$Wn="wrapper";function KWn(e){let{components:n,...t}=e;return(0,s.yg)($Wn,(0,p.A)({},QWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}KWn.isMDXComponent=!0;const JWn={toc:[]},ZWn="wrapper";function eSn(e){let{components:n,...t}=e;return(0,s.yg)(ZWn,(0,p.A)({},JWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}eSn.isMDXComponent=!0;const nSn={toc:[]},tSn="wrapper";function oSn(e){let{components:n,...t}=e;return(0,s.yg)(tSn,(0,p.A)({},nSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}oSn.isMDXComponent=!0;const pSn={toc:[]},rSn="wrapper";function sSn(e){let{components:n,...t}=e;return(0,s.yg)(rSn,(0,p.A)({},pSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}sSn.isMDXComponent=!0;const cSn={toc:[]},aSn="wrapper";function iSn(e){let{components:n,...t}=e;return(0,s.yg)(aSn,(0,p.A)({},cSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}iSn.isMDXComponent=!0;const lSn={toc:[]},uSn="wrapper";function mSn(e){let{components:n,...t}=e;return(0,s.yg)(uSn,(0,p.A)({},lSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}mSn.isMDXComponent=!0;const ySn={toc:[]},dSn="wrapper";function hSn(e){let{components:n,...t}=e;return(0,s.yg)(dSn,(0,p.A)({},ySn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}hSn.isMDXComponent=!0;const gSn={toc:[]},fSn="wrapper";function DSn(e){let{components:n,...t}=e;return(0,s.yg)(fSn,(0,p.A)({},gSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}DSn.isMDXComponent=!0;const MSn={toc:[]},XSn="wrapper";function _Sn(e){let{components:n,...t}=e;return(0,s.yg)(XSn,(0,p.A)({},MSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}_Sn.isMDXComponent=!0;const wSn={toc:[]},TSn="wrapper";function CSn(e){let{components:n,...t}=e;return(0,s.yg)(TSn,(0,p.A)({},wSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}CSn.isMDXComponent=!0;const xSn={toc:[]},ASn="wrapper";function vSn(e){let{components:n,...t}=e;return(0,s.yg)(ASn,(0,p.A)({},xSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}vSn.isMDXComponent=!0;const LSn={toc:[]},bSn="wrapper";function NSn(e){let{components:n,...t}=e;return(0,s.yg)(bSn,(0,p.A)({},LSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}NSn.isMDXComponent=!0;const kSn={toc:[]},zSn="wrapper";function PSn(e){let{components:n,...t}=e;return(0,s.yg)(zSn,(0,p.A)({},kSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PSn.isMDXComponent=!0;const ISn={toc:[]},RSn="wrapper";function WSn(e){let{components:n,...t}=e;return(0,s.yg)(RSn,(0,p.A)({},ISn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}WSn.isMDXComponent=!0;const SSn={toc:[]},BSn="wrapper";function GSn(e){let{components:n,...t}=e;return(0,s.yg)(BSn,(0,p.A)({},SSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}GSn.isMDXComponent=!0;const ESn={toc:[]},OSn="wrapper";function USn(e){let{components:n,...t}=e;return(0,s.yg)(OSn,(0,p.A)({},ESn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}USn.isMDXComponent=!0;const FSn={toc:[]},VSn="wrapper";function qSn(e){let{components:n,...t}=e;return(0,s.yg)(VSn,(0,p.A)({},FSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qSn.isMDXComponent=!0;const jSn={toc:[]},HSn="wrapper";function YSn(e){let{components:n,...t}=e;return(0,s.yg)(HSn,(0,p.A)({},jSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}YSn.isMDXComponent=!0;const QSn={toc:[]},$Sn="wrapper";function KSn(e){let{components:n,...t}=e;return(0,s.yg)($Sn,(0,p.A)({},QSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}KSn.isMDXComponent=!0;const JSn={toc:[]},ZSn="wrapper";function eBn(e){let{components:n,...t}=e;return(0,s.yg)(ZSn,(0,p.A)({},JSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}eBn.isMDXComponent=!0;const nBn={toc:[]},tBn="wrapper";function oBn(e){let{components:n,...t}=e;return(0,s.yg)(tBn,(0,p.A)({},nBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}oBn.isMDXComponent=!0;const pBn={toc:[]},rBn="wrapper";function sBn(e){let{components:n,...t}=e;return(0,s.yg)(rBn,(0,p.A)({},pBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}sBn.isMDXComponent=!0;const cBn={toc:[]},aBn="wrapper";function iBn(e){let{components:n,...t}=e;return(0,s.yg)(aBn,(0,p.A)({},cBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}iBn.isMDXComponent=!0;const lBn={toc:[]},uBn="wrapper";function mBn(e){let{components:n,...t}=e;return(0,s.yg)(uBn,(0,p.A)({},lBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}mBn.isMDXComponent=!0;const yBn={toc:[]},dBn="wrapper";function hBn(e){let{components:n,...t}=e;return(0,s.yg)(dBn,(0,p.A)({},yBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}hBn.isMDXComponent=!0;const gBn={toc:[]},fBn="wrapper";function DBn(e){let{components:n,...t}=e;return(0,s.yg)(fBn,(0,p.A)({},gBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DBn.isMDXComponent=!0;const MBn={toc:[]},XBn="wrapper";function _Bn(e){let{components:n,...t}=e;return(0,s.yg)(XBn,(0,p.A)({},MBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}_Bn.isMDXComponent=!0;const wBn={toc:[]},TBn="wrapper";function CBn(e){let{components:n,...t}=e;return(0,s.yg)(TBn,(0,p.A)({},wBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}CBn.isMDXComponent=!0;const xBn={toc:[]},ABn="wrapper";function vBn(e){let{components:n,...t}=e;return(0,s.yg)(ABn,(0,p.A)({},xBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}vBn.isMDXComponent=!0;const LBn={toc:[]},bBn="wrapper";function NBn(e){let{components:n,...t}=e;return(0,s.yg)(bBn,(0,p.A)({},LBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}NBn.isMDXComponent=!0;const kBn={toc:[]},zBn="wrapper";function PBn(e){let{components:n,...t}=e;return(0,s.yg)(zBn,(0,p.A)({},kBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}PBn.isMDXComponent=!0;const IBn={toc:[]},RBn="wrapper";function WBn(e){let{components:n,...t}=e;return(0,s.yg)(RBn,(0,p.A)({},IBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}WBn.isMDXComponent=!0;const SBn={toc:[]},BBn="wrapper";function GBn(e){let{components:n,...t}=e;return(0,s.yg)(BBn,(0,p.A)({},SBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GBn.isMDXComponent=!0;const EBn={toc:[]},OBn="wrapper";function UBn(e){let{components:n,...t}=e;return(0,s.yg)(OBn,(0,p.A)({},EBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}UBn.isMDXComponent=!0;const FBn={toc:[]},VBn="wrapper";function qBn(e){let{components:n,...t}=e;return(0,s.yg)(VBn,(0,p.A)({},FBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qBn.isMDXComponent=!0;const jBn={toc:[]},HBn="wrapper";function YBn(e){let{components:n,...t}=e;return(0,s.yg)(HBn,(0,p.A)({},jBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}YBn.isMDXComponent=!0;const QBn={toc:[]},$Bn="wrapper";function KBn(e){let{components:n,...t}=e;return(0,s.yg)($Bn,(0,p.A)({},QBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}KBn.isMDXComponent=!0;const JBn={toc:[]},ZBn="wrapper";function eGn(e){let{components:n,...t}=e;return(0,s.yg)(ZBn,(0,p.A)({},JBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eGn.isMDXComponent=!0;const nGn={toc:[]},tGn="wrapper";function oGn(e){let{components:n,...t}=e;return(0,s.yg)(tGn,(0,p.A)({},nGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}oGn.isMDXComponent=!0;const pGn={toc:[]},rGn="wrapper";function sGn(e){let{components:n,...t}=e;return(0,s.yg)(rGn,(0,p.A)({},pGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}sGn.isMDXComponent=!0;const cGn={toc:[]},aGn="wrapper";function iGn(e){let{components:n,...t}=e;return(0,s.yg)(aGn,(0,p.A)({},cGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}iGn.isMDXComponent=!0;const lGn={toc:[]},uGn="wrapper";function mGn(e){let{components:n,...t}=e;return(0,s.yg)(uGn,(0,p.A)({},lGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node representing a knot of a ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.yg)("inlineCode",{parentName:"a"},"Spline")),"."))}mGn.isMDXComponent=!0;const yGn={toc:[]},dGn="wrapper";function hGn(e){let{components:n,...t}=e;return(0,s.yg)(dGn,(0,p.A)({},yGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}hGn.isMDXComponent=!0;const gGn={toc:[]},fGn="wrapper";function DGn(e){let{components:n,...t}=e;return(0,s.yg)(fGn,(0,p.A)({},gGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}DGn.isMDXComponent=!0;const MGn={toc:[]},XGn="wrapper";function _Gn(e){let{components:n,...t}=e;return(0,s.yg)(XGn,(0,p.A)({},MGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}_Gn.isMDXComponent=!0;const wGn={toc:[]},TGn="wrapper";function CGn(e){let{components:n,...t}=e;return(0,s.yg)(TGn,(0,p.A)({},wGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}CGn.isMDXComponent=!0;const xGn={toc:[]},AGn="wrapper";function vGn(e){let{components:n,...t}=e;return(0,s.yg)(AGn,(0,p.A)({},xGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}vGn.isMDXComponent=!0;const LGn={toc:[]},bGn="wrapper";function NGn(e){let{components:n,...t}=e;return(0,s.yg)(bGn,(0,p.A)({},LGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}NGn.isMDXComponent=!0;const kGn={toc:[]},zGn="wrapper";function PGn(e){let{components:n,...t}=e;return(0,s.yg)(zGn,(0,p.A)({},kGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}PGn.isMDXComponent=!0;const IGn={toc:[]},RGn="wrapper";function WGn(e){let{components:n,...t}=e;return(0,s.yg)(RGn,(0,p.A)({},IGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0"))}WGn.isMDXComponent=!0;const SGn={toc:[]},BGn="wrapper";function GGn(e){let{components:n,...t}=e;return(0,s.yg)(BGn,(0,p.A)({},SGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}GGn.isMDXComponent=!0;const EGn={toc:[]},OGn="wrapper";function UGn(e){let{components:n,...t}=e;return(0,s.yg)(OGn,(0,p.A)({},EGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}UGn.isMDXComponent=!0;const FGn={toc:[]},VGn="wrapper";function qGn(e){let{components:n,...t}=e;return(0,s.yg)(VGn,(0,p.A)({},FGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}qGn.isMDXComponent=!0;const jGn={toc:[]},HGn="wrapper";function YGn(e){let{components:n,...t}=e;return(0,s.yg)(HGn,(0,p.A)({},jGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}YGn.isMDXComponent=!0;const QGn={toc:[]},$Gn="wrapper";function KGn(e){let{components:n,...t}=e;return(0,s.yg)($Gn,(0,p.A)({},QGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mirrored position of the startHandle."))}KGn.isMDXComponent=!0;const JGn={toc:[]},ZGn="wrapper";function eEn(e){let{components:n,...t}=e;return(0,s.yg)(ZGn,(0,p.A)({},JGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}eEn.isMDXComponent=!0;const nEn={toc:[]},tEn="wrapper";function oEn(e){let{components:n,...t}=e;return(0,s.yg)(tEn,(0,p.A)({},nEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}oEn.isMDXComponent=!0;const pEn={toc:[]},rEn="wrapper";function sEn(e){let{components:n,...t}=e;return(0,s.yg)(rEn,(0,p.A)({},pEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}sEn.isMDXComponent=!0;const cEn={toc:[]},aEn="wrapper";function iEn(e){let{components:n,...t}=e;return(0,s.yg)(aEn,(0,p.A)({},cEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}iEn.isMDXComponent=!0;const lEn={toc:[]},uEn="wrapper";function mEn(e){let{components:n,...t}=e;return(0,s.yg)(uEn,(0,p.A)({},lEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}mEn.isMDXComponent=!0;const yEn={toc:[]},dEn="wrapper";function hEn(e){let{components:n,...t}=e;return(0,s.yg)(dEn,(0,p.A)({},yEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hEn.isMDXComponent=!0;const gEn={toc:[]},fEn="wrapper";function DEn(e){let{components:n,...t}=e;return(0,s.yg)(fEn,(0,p.A)({},gEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DEn.isMDXComponent=!0;const MEn={toc:[]},XEn="wrapper";function _En(e){let{components:n,...t}=e;return(0,s.yg)(XEn,(0,p.A)({},MEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}_En.isMDXComponent=!0;const wEn={toc:[]},TEn="wrapper";function CEn(e){let{components:n,...t}=e;return(0,s.yg)(TEn,(0,p.A)({},wEn,t,{components:n,mdxType:"MDXLayout"}))}CEn.isMDXComponent=!0;const xEn={toc:[]},AEn="wrapper";function vEn(e){let{components:n,...t}=e;return(0,s.yg)(AEn,(0,p.A)({},xEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}vEn.isMDXComponent=!0;const LEn={toc:[]},bEn="wrapper";function NEn(e){let{components:n,...t}=e;return(0,s.yg)(bEn,(0,p.A)({},LEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}NEn.isMDXComponent=!0;const kEn={toc:[]},zEn="wrapper";function PEn(e){let{components:n,...t}=e;return(0,s.yg)(zEn,(0,p.A)({},kEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}PEn.isMDXComponent=!0;const IEn={toc:[]},REn="wrapper";function WEn(e){let{components:n,...t}=e;return(0,s.yg)(REn,(0,p.A)({},IEn,t,{components:n,mdxType:"MDXLayout"}))}WEn.isMDXComponent=!0;const SEn={toc:[]},BEn="wrapper";function GEn(e){let{components:n,...t}=e;return(0,s.yg)(BEn,(0,p.A)({},SEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}GEn.isMDXComponent=!0;const EEn={toc:[]},OEn="wrapper";function UEn(e){let{components:n,...t}=e;return(0,s.yg)(OEn,(0,p.A)({},EEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mirrored position of the endHandle."))}UEn.isMDXComponent=!0;const FEn={toc:[]},VEn="wrapper";function qEn(e){let{components:n,...t}=e;return(0,s.yg)(VEn,(0,p.A)({},FEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}qEn.isMDXComponent=!0;const jEn={toc:[]},HEn="wrapper";function YEn(e){let{components:n,...t}=e;return(0,s.yg)(HEn,(0,p.A)({},jEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}YEn.isMDXComponent=!0;const QEn={toc:[]},$En="wrapper";function KEn(e){let{components:n,...t}=e;return(0,s.yg)($En,(0,p.A)({},QEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KEn.isMDXComponent=!0;const JEn={toc:[]},ZEn="wrapper";function eOn(e){let{components:n,...t}=e;return(0,s.yg)(ZEn,(0,p.A)({},JEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}eOn.isMDXComponent=!0;const nOn={toc:[]},tOn="wrapper";function oOn(e){let{components:n,...t}=e;return(0,s.yg)(tOn,(0,p.A)({},nOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}oOn.isMDXComponent=!0;const pOn={toc:[]},rOn="wrapper";function sOn(e){let{components:n,...t}=e;return(0,s.yg)(rOn,(0,p.A)({},pOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}sOn.isMDXComponent=!0;const cOn={toc:[]},aOn="wrapper";function iOn(e){let{components:n,...t}=e;return(0,s.yg)(aOn,(0,p.A)({},cOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}iOn.isMDXComponent=!0;const lOn={toc:[]},uOn="wrapper";function mOn(e){let{components:n,...t}=e;return(0,s.yg)(uOn,(0,p.A)({},lOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}mOn.isMDXComponent=!0;const yOn={toc:[]},dOn="wrapper";function hOn(e){let{components:n,...t}=e;return(0,s.yg)(dOn,(0,p.A)({},yOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}hOn.isMDXComponent=!0;const gOn={toc:[]},fOn="wrapper";function DOn(e){let{components:n,...t}=e;return(0,s.yg)(fOn,(0,p.A)({},gOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}DOn.isMDXComponent=!0;const MOn={toc:[]},XOn="wrapper";function _On(e){let{components:n,...t}=e;return(0,s.yg)(XOn,(0,p.A)({},MOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}_On.isMDXComponent=!0;const wOn={toc:[]},TOn="wrapper";function COn(e){let{components:n,...t}=e;return(0,s.yg)(TOn,(0,p.A)({},wOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}COn.isMDXComponent=!0;const xOn={toc:[]},AOn="wrapper";function vOn(e){let{components:n,...t}=e;return(0,s.yg)(AOn,(0,p.A)({},xOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vOn.isMDXComponent=!0;const LOn={toc:[]},bOn="wrapper";function NOn(e){let{components:n,...t}=e;return(0,s.yg)(bOn,(0,p.A)({},LOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}NOn.isMDXComponent=!0;const kOn={toc:[]},zOn="wrapper";function POn(e){let{components:n,...t}=e;return(0,s.yg)(zOn,(0,p.A)({},kOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}POn.isMDXComponent=!0;const IOn={toc:[]},ROn="wrapper";function WOn(e){let{components:n,...t}=e;return(0,s.yg)(ROn,(0,p.A)({},IOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}WOn.isMDXComponent=!0;const SOn={toc:[]},BOn="wrapper";function GOn(e){let{components:n,...t}=e;return(0,s.yg)(BOn,(0,p.A)({},SOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}GOn.isMDXComponent=!0;const EOn={toc:[]},OOn="wrapper";function UOn(e){let{components:n,...t}=e;return(0,s.yg)(OOn,(0,p.A)({},EOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}UOn.isMDXComponent=!0;const FOn={toc:[]},VOn="wrapper";function qOn(e){let{components:n,...t}=e;return(0,s.yg)(VOn,(0,p.A)({},FOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}qOn.isMDXComponent=!0;const jOn={toc:[]},HOn="wrapper";function YOn(e){let{components:n,...t}=e;return(0,s.yg)(HOn,(0,p.A)({},jOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}YOn.isMDXComponent=!0;const QOn={toc:[]},$On="wrapper";function KOn(e){let{components:n,...t}=e;return(0,s.yg)($On,(0,p.A)({},QOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}KOn.isMDXComponent=!0;const JOn={toc:[]},ZOn="wrapper";function eUn(e){let{components:n,...t}=e;return(0,s.yg)(ZOn,(0,p.A)({},JOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}eUn.isMDXComponent=!0;const nUn={toc:[]},tUn="wrapper";function oUn(e){let{components:n,...t}=e;return(0,s.yg)(tUn,(0,p.A)({},nUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}oUn.isMDXComponent=!0;const pUn={toc:[]},rUn="wrapper";function sUn(e){let{components:n,...t}=e;return(0,s.yg)(rUn,(0,p.A)({},pUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sUn.isMDXComponent=!0;const cUn={toc:[]},aUn="wrapper";function iUn(e){let{components:n,...t}=e;return(0,s.yg)(aUn,(0,p.A)({},cUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}iUn.isMDXComponent=!0;const lUn={toc:[]},uUn="wrapper";function mUn(e){let{components:n,...t}=e;return(0,s.yg)(uUn,(0,p.A)({},lUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}mUn.isMDXComponent=!0;const yUn={toc:[]},dUn="wrapper";function hUn(e){let{components:n,...t}=e;return(0,s.yg)(dUn,(0,p.A)({},yUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hUn.isMDXComponent=!0;const gUn={toc:[]},fUn="wrapper";function DUn(e){let{components:n,...t}=e;return(0,s.yg)(fUn,(0,p.A)({},gUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}DUn.isMDXComponent=!0;const MUn={toc:[]},XUn="wrapper";function _Un(e){let{components:n,...t}=e;return(0,s.yg)(XUn,(0,p.A)({},MUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}_Un.isMDXComponent=!0;const wUn={toc:[]},TUn="wrapper";function CUn(e){let{components:n,...t}=e;return(0,s.yg)(TUn,(0,p.A)({},wUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}CUn.isMDXComponent=!0;const xUn={toc:[]},AUn="wrapper";function vUn(e){let{components:n,...t}=e;return(0,s.yg)(AUn,(0,p.A)({},xUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}vUn.isMDXComponent=!0;const LUn={toc:[]},bUn="wrapper";function NUn(e){let{components:n,...t}=e;return(0,s.yg)(bUn,(0,p.A)({},LUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}NUn.isMDXComponent=!0;const kUn={toc:[]},zUn="wrapper";function PUn(e){let{components:n,...t}=e;return(0,s.yg)(zUn,(0,p.A)({},kUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}PUn.isMDXComponent=!0;const IUn={toc:[]},RUn="wrapper";function WUn(e){let{components:n,...t}=e;return(0,s.yg)(RUn,(0,p.A)({},IUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}WUn.isMDXComponent=!0;const SUn={toc:[]},BUn="wrapper";function GUn(e){let{components:n,...t}=e;return(0,s.yg)(BUn,(0,p.A)({},SUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}GUn.isMDXComponent=!0;const EUn={toc:[]},OUn="wrapper";function UUn(e){let{components:n,...t}=e;return(0,s.yg)(OUn,(0,p.A)({},EUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}UUn.isMDXComponent=!0;const FUn={toc:[]},VUn="wrapper";function qUn(e){let{components:n,...t}=e;return(0,s.yg)(VUn,(0,p.A)({},FUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qUn.isMDXComponent=!0;const jUn={toc:[]},HUn="wrapper";function YUn(e){let{components:n,...t}=e;return(0,s.yg)(HUn,(0,p.A)({},jUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}YUn.isMDXComponent=!0;const QUn={toc:[]},$Un="wrapper";function KUn(e){let{components:n,...t}=e;return(0,s.yg)($Un,(0,p.A)({},QUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}KUn.isMDXComponent=!0;const JUn={toc:[]},ZUn="wrapper";function eFn(e){let{components:n,...t}=e;return(0,s.yg)(ZUn,(0,p.A)({},JUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eFn.isMDXComponent=!0;const nFn={toc:[]},tFn="wrapper";function oFn(e){let{components:n,...t}=e;return(0,s.yg)(tFn,(0,p.A)({},nFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}oFn.isMDXComponent=!0;const pFn={toc:[]},rFn="wrapper";function sFn(e){let{components:n,...t}=e;return(0,s.yg)(rFn,(0,p.A)({},pFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sFn.isMDXComponent=!0;const cFn={toc:[]},aFn="wrapper";function iFn(e){let{components:n,...t}=e;return(0,s.yg)(aFn,(0,p.A)({},cFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}iFn.isMDXComponent=!0;const lFn={toc:[]},uFn="wrapper";function mFn(e){let{components:n,...t}=e;return(0,s.yg)(uFn,(0,p.A)({},lFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mFn.isMDXComponent=!0;const yFn={toc:[]},dFn="wrapper";function hFn(e){let{components:n,...t}=e;return(0,s.yg)(dFn,(0,p.A)({},yFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}hFn.isMDXComponent=!0;const gFn={toc:[]},fFn="wrapper";function DFn(e){let{components:n,...t}=e;return(0,s.yg)(fFn,(0,p.A)({},gFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DFn.isMDXComponent=!0;const MFn={toc:[]},XFn="wrapper";function _Fn(e){let{components:n,...t}=e;return(0,s.yg)(XFn,(0,p.A)({},MFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}_Fn.isMDXComponent=!0;const wFn={toc:[]},TFn="wrapper";function CFn(e){let{components:n,...t}=e;return(0,s.yg)(TFn,(0,p.A)({},wFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}CFn.isMDXComponent=!0;const xFn={toc:[]},AFn="wrapper";function vFn(e){let{components:n,...t}=e;return(0,s.yg)(AFn,(0,p.A)({},xFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}vFn.isMDXComponent=!0;const LFn={toc:[]},bFn="wrapper";function NFn(e){let{components:n,...t}=e;return(0,s.yg)(bFn,(0,p.A)({},LFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}NFn.isMDXComponent=!0;const kFn={toc:[]},zFn="wrapper";function PFn(e){let{components:n,...t}=e;return(0,s.yg)(zFn,(0,p.A)({},kFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}PFn.isMDXComponent=!0;const IFn={toc:[]},RFn="wrapper";function WFn(e){let{components:n,...t}=e;return(0,s.yg)(RFn,(0,p.A)({},IFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}WFn.isMDXComponent=!0;const SFn={toc:[]},BFn="wrapper";function GFn(e){let{components:n,...t}=e;return(0,s.yg)(BFn,(0,p.A)({},SFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}GFn.isMDXComponent=!0;const EFn={toc:[]},OFn="wrapper";function UFn(e){let{components:n,...t}=e;return(0,s.yg)(OFn,(0,p.A)({},EFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}UFn.isMDXComponent=!0;const FFn={toc:[]},VFn="wrapper";function qFn(e){let{components:n,...t}=e;return(0,s.yg)(VFn,(0,p.A)({},FFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qFn.isMDXComponent=!0;const jFn={toc:[]},HFn="wrapper";function YFn(e){let{components:n,...t}=e;return(0,s.yg)(HFn,(0,p.A)({},jFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}YFn.isMDXComponent=!0;const QFn={toc:[]},$Fn="wrapper";function KFn(e){let{components:n,...t}=e;return(0,s.yg)($Fn,(0,p.A)({},QFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}KFn.isMDXComponent=!0;const JFn={toc:[]},ZFn="wrapper";function eVn(e){let{components:n,...t}=e;return(0,s.yg)(ZFn,(0,p.A)({},JFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}eVn.isMDXComponent=!0;const nVn={toc:[]},tVn="wrapper";function oVn(e){let{components:n,...t}=e;return(0,s.yg)(tVn,(0,p.A)({},nVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}oVn.isMDXComponent=!0;const pVn={toc:[]},rVn="wrapper";function sVn(e){let{components:n,...t}=e;return(0,s.yg)(rVn,(0,p.A)({},pVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}sVn.isMDXComponent=!0;const cVn={toc:[]},aVn="wrapper";function iVn(e){let{components:n,...t}=e;return(0,s.yg)(aVn,(0,p.A)({},cVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}iVn.isMDXComponent=!0;const lVn={toc:[]},uVn="wrapper";function mVn(e){let{components:n,...t}=e;return(0,s.yg)(uVn,(0,p.A)({},lVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}mVn.isMDXComponent=!0;const yVn={toc:[]},dVn="wrapper";function hVn(e){let{components:n,...t}=e;return(0,s.yg)(dVn,(0,p.A)({},yVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}hVn.isMDXComponent=!0;const gVn={toc:[]},fVn="wrapper";function DVn(e){let{components:n,...t}=e;return(0,s.yg)(fVn,(0,p.A)({},gVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}DVn.isMDXComponent=!0;const MVn={toc:[]},XVn="wrapper";function _Vn(e){let{components:n,...t}=e;return(0,s.yg)(XVn,(0,p.A)({},MVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}_Vn.isMDXComponent=!0;const wVn={toc:[]},TVn="wrapper";function CVn(e){let{components:n,...t}=e;return(0,s.yg)(TVn,(0,p.A)({},wVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}CVn.isMDXComponent=!0;const xVn={toc:[]},AVn="wrapper";function vVn(e){let{components:n,...t}=e;return(0,s.yg)(AVn,(0,p.A)({},xVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}vVn.isMDXComponent=!0;const LVn={toc:[]},bVn="wrapper";function NVn(e){let{components:n,...t}=e;return(0,s.yg)(bVn,(0,p.A)({},LVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}NVn.isMDXComponent=!0;const kVn={toc:[]},zVn="wrapper";function PVn(e){let{components:n,...t}=e;return(0,s.yg)(zVn,(0,p.A)({},kVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}PVn.isMDXComponent=!0;const IVn={toc:[]},RVn="wrapper";function WVn(e){let{components:n,...t}=e;return(0,s.yg)(RVn,(0,p.A)({},IVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}WVn.isMDXComponent=!0;const SVn={toc:[]},BVn="wrapper";function GVn(e){let{components:n,...t}=e;return(0,s.yg)(BVn,(0,p.A)({},SVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}GVn.isMDXComponent=!0;const EVn={toc:[]},OVn="wrapper";function UVn(e){let{components:n,...t}=e;return(0,s.yg)(OVn,(0,p.A)({},EVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}UVn.isMDXComponent=!0;const FVn={toc:[]},VVn="wrapper";function qVn(e){let{components:n,...t}=e;return(0,s.yg)(VVn,(0,p.A)({},FVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}qVn.isMDXComponent=!0;const jVn={toc:[]},HVn="wrapper";function YVn(e){let{components:n,...t}=e;return(0,s.yg)(HVn,(0,p.A)({},jVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}YVn.isMDXComponent=!0;const QVn={toc:[]},$Vn="wrapper";function KVn(e){let{components:n,...t}=e;return(0,s.yg)($Vn,(0,p.A)({},QVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}KVn.isMDXComponent=!0;const JVn={toc:[]},ZVn="wrapper";function eqn(e){let{components:n,...t}=e;return(0,s.yg)(ZVn,(0,p.A)({},JVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}eqn.isMDXComponent=!0;const nqn={toc:[]},tqn="wrapper";function oqn(e){let{components:n,...t}=e;return(0,s.yg)(tqn,(0,p.A)({},nqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}oqn.isMDXComponent=!0;const pqn={toc:[]},rqn="wrapper";function sqn(e){let{components:n,...t}=e;return(0,s.yg)(rqn,(0,p.A)({},pqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}sqn.isMDXComponent=!0;const cqn={toc:[]},aqn="wrapper";function iqn(e){let{components:n,...t}=e;return(0,s.yg)(aqn,(0,p.A)({},cqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iqn.isMDXComponent=!0;const lqn={toc:[]},uqn="wrapper";function mqn(e){let{components:n,...t}=e;return(0,s.yg)(uqn,(0,p.A)({},lqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}mqn.isMDXComponent=!0;const yqn={toc:[]},dqn="wrapper";function hqn(e){let{components:n,...t}=e;return(0,s.yg)(dqn,(0,p.A)({},yqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}hqn.isMDXComponent=!0;const gqn={toc:[]},fqn="wrapper";function Dqn(e){let{components:n,...t}=e;return(0,s.yg)(fqn,(0,p.A)({},gqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Dqn.isMDXComponent=!0;const Mqn={toc:[]},Xqn="wrapper";function _qn(e){let{components:n,...t}=e;return(0,s.yg)(Xqn,(0,p.A)({},Mqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}_qn.isMDXComponent=!0;const wqn={toc:[]},Tqn="wrapper";function Cqn(e){let{components:n,...t}=e;return(0,s.yg)(Tqn,(0,p.A)({},wqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Cqn.isMDXComponent=!0;const xqn={toc:[]},Aqn="wrapper";function vqn(e){let{components:n,...t}=e;return(0,s.yg)(Aqn,(0,p.A)({},xqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}vqn.isMDXComponent=!0;const Lqn={toc:[]},bqn="wrapper";function Nqn(e){let{components:n,...t}=e;return(0,s.yg)(bqn,(0,p.A)({},Lqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Nqn.isMDXComponent=!0;const kqn={toc:[]},zqn="wrapper";function Pqn(e){let{components:n,...t}=e;return(0,s.yg)(zqn,(0,p.A)({},kqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Pqn.isMDXComponent=!0;const Iqn={toc:[]},Rqn="wrapper";function Wqn(e){let{components:n,...t}=e;return(0,s.yg)(Rqn,(0,p.A)({},Iqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Wqn.isMDXComponent=!0;const Sqn={toc:[]},Bqn="wrapper";function Gqn(e){let{components:n,...t}=e;return(0,s.yg)(Bqn,(0,p.A)({},Sqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Gqn.isMDXComponent=!0;const Eqn={toc:[]},Oqn="wrapper";function Uqn(e){let{components:n,...t}=e;return(0,s.yg)(Oqn,(0,p.A)({},Eqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Uqn.isMDXComponent=!0;const Fqn={toc:[]},Vqn="wrapper";function qqn(e){let{components:n,...t}=e;return(0,s.yg)(Vqn,(0,p.A)({},Fqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}qqn.isMDXComponent=!0;const jqn={toc:[]},Hqn="wrapper";function Yqn(e){let{components:n,...t}=e;return(0,s.yg)(Hqn,(0,p.A)({},jqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Yqn.isMDXComponent=!0;const Qqn={toc:[]},$qn="wrapper";function Kqn(e){let{components:n,...t}=e;return(0,s.yg)($qn,(0,p.A)({},Qqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Kqn.isMDXComponent=!0;const Jqn={toc:[]},Zqn="wrapper";function ejn(e){let{components:n,...t}=e;return(0,s.yg)(Zqn,(0,p.A)({},Jqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}ejn.isMDXComponent=!0;const njn={toc:[]},tjn="wrapper";function ojn(e){let{components:n,...t}=e;return(0,s.yg)(tjn,(0,p.A)({},njn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ojn.isMDXComponent=!0;const pjn={toc:[]},rjn="wrapper";function sjn(e){let{components:n,...t}=e;return(0,s.yg)(rjn,(0,p.A)({},pjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}sjn.isMDXComponent=!0;const cjn={toc:[]},ajn="wrapper";function ijn(e){let{components:n,...t}=e;return(0,s.yg)(ajn,(0,p.A)({},cjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}ijn.isMDXComponent=!0;const ljn={toc:[]},ujn="wrapper";function mjn(e){let{components:n,...t}=e;return(0,s.yg)(ujn,(0,p.A)({},ljn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}mjn.isMDXComponent=!0;const yjn={toc:[]},djn="wrapper";function hjn(e){let{components:n,...t}=e;return(0,s.yg)(djn,(0,p.A)({},yjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}hjn.isMDXComponent=!0;const gjn={toc:[]},fjn="wrapper";function Djn(e){let{components:n,...t}=e;return(0,s.yg)(fjn,(0,p.A)({},gjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Djn.isMDXComponent=!0;const Mjn={toc:[]},Xjn="wrapper";function _jn(e){let{components:n,...t}=e;return(0,s.yg)(Xjn,(0,p.A)({},Mjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_jn.isMDXComponent=!0;const wjn={toc:[]},Tjn="wrapper";function Cjn(e){let{components:n,...t}=e;return(0,s.yg)(Tjn,(0,p.A)({},wjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Cjn.isMDXComponent=!0;const xjn={toc:[]},Ajn="wrapper";function vjn(e){let{components:n,...t}=e;return(0,s.yg)(Ajn,(0,p.A)({},xjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}vjn.isMDXComponent=!0;const Ljn={toc:[]},bjn="wrapper";function Njn(e){let{components:n,...t}=e;return(0,s.yg)(bjn,(0,p.A)({},Ljn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Njn.isMDXComponent=!0;const kjn={toc:[]},zjn="wrapper";function Pjn(e){let{components:n,...t}=e;return(0,s.yg)(zjn,(0,p.A)({},kjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pjn.isMDXComponent=!0;const Ijn={toc:[]},Rjn="wrapper";function Wjn(e){let{components:n,...t}=e;return(0,s.yg)(Rjn,(0,p.A)({},Ijn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Wjn.isMDXComponent=!0;const Sjn={toc:[]},Bjn="wrapper";function Gjn(e){let{components:n,...t}=e;return(0,s.yg)(Bjn,(0,p.A)({},Sjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Gjn.isMDXComponent=!0;const Ejn={toc:[]},Ojn="wrapper";function Ujn(e){let{components:n,...t}=e;return(0,s.yg)(Ojn,(0,p.A)({},Ejn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Ujn.isMDXComponent=!0;const Fjn={toc:[]},Vjn="wrapper";function qjn(e){let{components:n,...t}=e;return(0,s.yg)(Vjn,(0,p.A)({},Fjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qjn.isMDXComponent=!0;const jjn={toc:[]},Hjn="wrapper";function Yjn(e){let{components:n,...t}=e;return(0,s.yg)(Hjn,(0,p.A)({},jjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Yjn.isMDXComponent=!0;const Qjn={toc:[]},$jn="wrapper";function Kjn(e){let{components:n,...t}=e;return(0,s.yg)($jn,(0,p.A)({},Qjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Kjn.isMDXComponent=!0;const Jjn={toc:[]},Zjn="wrapper";function eHn(e){let{components:n,...t}=e;return(0,s.yg)(Zjn,(0,p.A)({},Jjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}eHn.isMDXComponent=!0;const nHn={toc:[]},tHn="wrapper";function oHn(e){let{components:n,...t}=e;return(0,s.yg)(tHn,(0,p.A)({},nHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}oHn.isMDXComponent=!0;const pHn={toc:[]},rHn="wrapper";function sHn(e){let{components:n,...t}=e;return(0,s.yg)(rHn,(0,p.A)({},pHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}sHn.isMDXComponent=!0;const cHn={toc:[]},aHn="wrapper";function iHn(e){let{components:n,...t}=e;return(0,s.yg)(aHn,(0,p.A)({},cHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}iHn.isMDXComponent=!0;const lHn={toc:[]},uHn="wrapper";function mHn(e){let{components:n,...t}=e;return(0,s.yg)(uHn,(0,p.A)({},lHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}mHn.isMDXComponent=!0;const yHn={toc:[]},dHn="wrapper";function hHn(e){let{components:n,...t}=e;return(0,s.yg)(dHn,(0,p.A)({},yHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}hHn.isMDXComponent=!0;const gHn={toc:[]},fHn="wrapper";function DHn(e){let{components:n,...t}=e;return(0,s.yg)(fHn,(0,p.A)({},gHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DHn.isMDXComponent=!0;const MHn={toc:[]},XHn="wrapper";function _Hn(e){let{components:n,...t}=e;return(0,s.yg)(XHn,(0,p.A)({},MHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}_Hn.isMDXComponent=!0;const wHn={toc:[]},THn="wrapper";function CHn(e){let{components:n,...t}=e;return(0,s.yg)(THn,(0,p.A)({},wHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}CHn.isMDXComponent=!0;const xHn={toc:[]},AHn="wrapper";function vHn(e){let{components:n,...t}=e;return(0,s.yg)(AHn,(0,p.A)({},xHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}vHn.isMDXComponent=!0;const LHn={toc:[]},bHn="wrapper";function NHn(e){let{components:n,...t}=e;return(0,s.yg)(bHn,(0,p.A)({},LHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}NHn.isMDXComponent=!0;const kHn={toc:[]},zHn="wrapper";function PHn(e){let{components:n,...t}=e;return(0,s.yg)(zHn,(0,p.A)({},kHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}PHn.isMDXComponent=!0;const IHn={toc:[]},RHn="wrapper";function WHn(e){let{components:n,...t}=e;return(0,s.yg)(RHn,(0,p.A)({},IHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}WHn.isMDXComponent=!0;const SHn={toc:[]},BHn="wrapper";function GHn(e){let{components:n,...t}=e;return(0,s.yg)(BHn,(0,p.A)({},SHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GHn.isMDXComponent=!0;const EHn={toc:[]},OHn="wrapper";function UHn(e){let{components:n,...t}=e;return(0,s.yg)(OHn,(0,p.A)({},EHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}UHn.isMDXComponent=!0;const FHn={toc:[]},VHn="wrapper";function qHn(e){let{components:n,...t}=e;return(0,s.yg)(VHn,(0,p.A)({},FHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}qHn.isMDXComponent=!0;const jHn={toc:[]},HHn="wrapper";function YHn(e){let{components:n,...t}=e;return(0,s.yg)(HHn,(0,p.A)({},jHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}YHn.isMDXComponent=!0;const QHn={toc:[]},$Hn="wrapper";function KHn(e){let{components:n,...t}=e;return(0,s.yg)($Hn,(0,p.A)({},QHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}KHn.isMDXComponent=!0;const JHn={toc:[]},ZHn="wrapper";function eYn(e){let{components:n,...t}=e;return(0,s.yg)(ZHn,(0,p.A)({},JHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}eYn.isMDXComponent=!0;const nYn={toc:[]},tYn="wrapper";function oYn(e){let{components:n,...t}=e;return(0,s.yg)(tYn,(0,p.A)({},nYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oYn.isMDXComponent=!0;const pYn={toc:[]},rYn="wrapper";function sYn(e){let{components:n,...t}=e;return(0,s.yg)(rYn,(0,p.A)({},pYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}sYn.isMDXComponent=!0;const cYn={toc:[]},aYn="wrapper";function iYn(e){let{components:n,...t}=e;return(0,s.yg)(aYn,(0,p.A)({},cYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}iYn.isMDXComponent=!0;const lYn={toc:[]},uYn="wrapper";function mYn(e){let{components:n,...t}=e;return(0,s.yg)(uYn,(0,p.A)({},lYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for rendering equations with LaTeX."))}mYn.isMDXComponent=!0;const yYn={toc:[]},dYn="wrapper";function hYn(e){let{components:n,...t}=e;return(0,s.yg)(dYn,(0,p.A)({},yYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}hYn.isMDXComponent=!0;const gYn={toc:[]},fYn="wrapper";function DYn(e){let{components:n,...t}=e;return(0,s.yg)(fYn,(0,p.A)({},gYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}DYn.isMDXComponent=!0;const MYn={toc:[]},XYn="wrapper";function _Yn(e){let{components:n,...t}=e;return(0,s.yg)(XYn,(0,p.A)({},MYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}_Yn.isMDXComponent=!0;const wYn={toc:[]},TYn="wrapper";function CYn(e){let{components:n,...t}=e;return(0,s.yg)(TYn,(0,p.A)({},wYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}CYn.isMDXComponent=!0;const xYn={toc:[]},AYn="wrapper";function vYn(e){let{components:n,...t}=e;return(0,s.yg)(AYn,(0,p.A)({},xYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}vYn.isMDXComponent=!0;const LYn={toc:[]},bYn="wrapper";function NYn(e){let{components:n,...t}=e;return(0,s.yg)(bYn,(0,p.A)({},LYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}NYn.isMDXComponent=!0;const kYn={toc:[]},zYn="wrapper";function PYn(e){let{components:n,...t}=e;return(0,s.yg)(zYn,(0,p.A)({},kYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}PYn.isMDXComponent=!0;const IYn={toc:[]},RYn="wrapper";function WYn(e){let{components:n,...t}=e;return(0,s.yg)(RYn,(0,p.A)({},IYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}WYn.isMDXComponent=!0;const SYn={toc:[]},BYn="wrapper";function GYn(e){let{components:n,...t}=e;return(0,s.yg)(BYn,(0,p.A)({},SYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}GYn.isMDXComponent=!0;const EYn={toc:[]},OYn="wrapper";function UYn(e){let{components:n,...t}=e;return(0,s.yg)(OYn,(0,p.A)({},EYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}UYn.isMDXComponent=!0;const FYn={toc:[]},VYn="wrapper";function qYn(e){let{components:n,...t}=e;return(0,s.yg)(VYn,(0,p.A)({},FYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qYn.isMDXComponent=!0;const jYn={toc:[]},HYn="wrapper";function YYn(e){let{components:n,...t}=e;return(0,s.yg)(HYn,(0,p.A)({},jYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}YYn.isMDXComponent=!0;const QYn={toc:[]},$Yn="wrapper";function KYn(e){let{components:n,...t}=e;return(0,s.yg)($Yn,(0,p.A)({},QYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}KYn.isMDXComponent=!0;const JYn={toc:[]},ZYn="wrapper";function eQn(e){let{components:n,...t}=e;return(0,s.yg)(ZYn,(0,p.A)({},JYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}eQn.isMDXComponent=!0;const nQn={toc:[]},tQn="wrapper";function oQn(e){let{components:n,...t}=e;return(0,s.yg)(tQn,(0,p.A)({},nQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}oQn.isMDXComponent=!0;const pQn={toc:[]},rQn="wrapper";function sQn(e){let{components:n,...t}=e;return(0,s.yg)(rQn,(0,p.A)({},pQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}sQn.isMDXComponent=!0;const cQn={toc:[]},aQn="wrapper";function iQn(e){let{components:n,...t}=e;return(0,s.yg)(aQn,(0,p.A)({},cQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}iQn.isMDXComponent=!0;const lQn={toc:[]},uQn="wrapper";function mQn(e){let{components:n,...t}=e;return(0,s.yg)(uQn,(0,p.A)({},lQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}mQn.isMDXComponent=!0;const yQn={toc:[]},dQn="wrapper";function hQn(e){let{components:n,...t}=e;return(0,s.yg)(dQn,(0,p.A)({},yQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}hQn.isMDXComponent=!0;const gQn={toc:[]},fQn="wrapper";function DQn(e){let{components:n,...t}=e;return(0,s.yg)(fQn,(0,p.A)({},gQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}DQn.isMDXComponent=!0;const MQn={toc:[]},XQn="wrapper";function _Qn(e){let{components:n,...t}=e;return(0,s.yg)(XQn,(0,p.A)({},MQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}_Qn.isMDXComponent=!0;const wQn={toc:[]},TQn="wrapper";function CQn(e){let{components:n,...t}=e;return(0,s.yg)(TQn,(0,p.A)({},wQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}CQn.isMDXComponent=!0;const xQn={toc:[]},AQn="wrapper";function vQn(e){let{components:n,...t}=e;return(0,s.yg)(AQn,(0,p.A)({},xQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}vQn.isMDXComponent=!0;const LQn={toc:[]},bQn="wrapper";function NQn(e){let{components:n,...t}=e;return(0,s.yg)(bQn,(0,p.A)({},LQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}NQn.isMDXComponent=!0;const kQn={toc:[]},zQn="wrapper";function PQn(e){let{components:n,...t}=e;return(0,s.yg)(zQn,(0,p.A)({},kQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}PQn.isMDXComponent=!0;const IQn={toc:[]},RQn="wrapper";function WQn(e){let{components:n,...t}=e;return(0,s.yg)(RQn,(0,p.A)({},IQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}WQn.isMDXComponent=!0;const SQn={toc:[]},BQn="wrapper";function GQn(e){let{components:n,...t}=e;return(0,s.yg)(BQn,(0,p.A)({},SQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}GQn.isMDXComponent=!0;const EQn={toc:[]},OQn="wrapper";function UQn(e){let{components:n,...t}=e;return(0,s.yg)(OQn,(0,p.A)({},EQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}UQn.isMDXComponent=!0;const FQn={toc:[]},VQn="wrapper";function qQn(e){let{components:n,...t}=e;return(0,s.yg)(VQn,(0,p.A)({},FQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}qQn.isMDXComponent=!0;const jQn={toc:[]},HQn="wrapper";function YQn(e){let{components:n,...t}=e;return(0,s.yg)(HQn,(0,p.A)({},jQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}YQn.isMDXComponent=!0;const QQn={toc:[]},$Qn="wrapper";function KQn(e){let{components:n,...t}=e;return(0,s.yg)($Qn,(0,p.A)({},QQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}KQn.isMDXComponent=!0;const JQn={toc:[]},ZQn="wrapper";function e$n(e){let{components:n,...t}=e;return(0,s.yg)(ZQn,(0,p.A)({},JQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}e$n.isMDXComponent=!0;const n$n={toc:[]},t$n="wrapper";function o$n(e){let{components:n,...t}=e;return(0,s.yg)(t$n,(0,p.A)({},n$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}o$n.isMDXComponent=!0;const p$n={toc:[]},r$n="wrapper";function s$n(e){let{components:n,...t}=e;return(0,s.yg)(r$n,(0,p.A)({},p$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}s$n.isMDXComponent=!0;const c$n={toc:[]},a$n="wrapper";function i$n(e){let{components:n,...t}=e;return(0,s.yg)(a$n,(0,p.A)({},c$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}i$n.isMDXComponent=!0;const l$n={toc:[]},u$n="wrapper";function m$n(e){let{components:n,...t}=e;return(0,s.yg)(u$n,(0,p.A)({},l$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}m$n.isMDXComponent=!0;const y$n={toc:[]},d$n="wrapper";function h$n(e){let{components:n,...t}=e;return(0,s.yg)(d$n,(0,p.A)({},y$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}h$n.isMDXComponent=!0;const g$n={toc:[]},f$n="wrapper";function D$n(e){let{components:n,...t}=e;return(0,s.yg)(f$n,(0,p.A)({},g$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}D$n.isMDXComponent=!0;const M$n={toc:[]},X$n="wrapper";function _$n(e){let{components:n,...t}=e;return(0,s.yg)(X$n,(0,p.A)({},M$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}_$n.isMDXComponent=!0;const w$n={toc:[]},T$n="wrapper";function C$n(e){let{components:n,...t}=e;return(0,s.yg)(T$n,(0,p.A)({},w$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}C$n.isMDXComponent=!0;const x$n={toc:[]},A$n="wrapper";function v$n(e){let{components:n,...t}=e;return(0,s.yg)(A$n,(0,p.A)({},x$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}v$n.isMDXComponent=!0;const L$n={toc:[]},b$n="wrapper";function N$n(e){let{components:n,...t}=e;return(0,s.yg)(b$n,(0,p.A)({},L$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}N$n.isMDXComponent=!0;const k$n={toc:[]},z$n="wrapper";function P$n(e){let{components:n,...t}=e;return(0,s.yg)(z$n,(0,p.A)({},k$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}P$n.isMDXComponent=!0;const I$n={toc:[]},R$n="wrapper";function W$n(e){let{components:n,...t}=e;return(0,s.yg)(R$n,(0,p.A)({},I$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}W$n.isMDXComponent=!0;const S$n={toc:[]},B$n="wrapper";function G$n(e){let{components:n,...t}=e;return(0,s.yg)(B$n,(0,p.A)({},S$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}G$n.isMDXComponent=!0;const E$n={toc:[]},O$n="wrapper";function U$n(e){let{components:n,...t}=e;return(0,s.yg)(O$n,(0,p.A)({},E$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}U$n.isMDXComponent=!0;const F$n={toc:[]},V$n="wrapper";function q$n(e){let{components:n,...t}=e;return(0,s.yg)(V$n,(0,p.A)({},F$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}q$n.isMDXComponent=!0;const j$n={toc:[]},H$n="wrapper";function Y$n(e){let{components:n,...t}=e;return(0,s.yg)(H$n,(0,p.A)({},j$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Y$n.isMDXComponent=!0;const Q$n={toc:[]},$$n="wrapper";function K$n(e){let{components:n,...t}=e;return(0,s.yg)($$n,(0,p.A)({},Q$n,t,{components:n,mdxType:"MDXLayout"}))}K$n.isMDXComponent=!0;const J$n={toc:[]},Z$n="wrapper";function eKn(e){let{components:n,...t}=e;return(0,s.yg)(Z$n,(0,p.A)({},J$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}eKn.isMDXComponent=!0;const nKn={toc:[]},tKn="wrapper";function oKn(e){let{components:n,...t}=e;return(0,s.yg)(tKn,(0,p.A)({},nKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}oKn.isMDXComponent=!0;const pKn={toc:[]},rKn="wrapper";function sKn(e){let{components:n,...t}=e;return(0,s.yg)(rKn,(0,p.A)({},pKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}sKn.isMDXComponent=!0;const cKn={toc:[]},aKn="wrapper";function iKn(e){let{components:n,...t}=e;return(0,s.yg)(aKn,(0,p.A)({},cKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}iKn.isMDXComponent=!0;const lKn={toc:[]},uKn="wrapper";function mKn(e){let{components:n,...t}=e;return(0,s.yg)(uKn,(0,p.A)({},lKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}mKn.isMDXComponent=!0;const yKn={toc:[]},dKn="wrapper";function hKn(e){let{components:n,...t}=e;return(0,s.yg)(dKn,(0,p.A)({},yKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}hKn.isMDXComponent=!0;const gKn={toc:[]},fKn="wrapper";function DKn(e){let{components:n,...t}=e;return(0,s.yg)(fKn,(0,p.A)({},gKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}DKn.isMDXComponent=!0;const MKn={toc:[]},XKn="wrapper";function _Kn(e){let{components:n,...t}=e;return(0,s.yg)(XKn,(0,p.A)({},MKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}_Kn.isMDXComponent=!0;const wKn={toc:[]},TKn="wrapper";function CKn(e){let{components:n,...t}=e;return(0,s.yg)(TKn,(0,p.A)({},wKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}CKn.isMDXComponent=!0;const xKn={toc:[]},AKn="wrapper";function vKn(e){let{components:n,...t}=e;return(0,s.yg)(AKn,(0,p.A)({},xKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}vKn.isMDXComponent=!0;const LKn={toc:[]},bKn="wrapper";function NKn(e){let{components:n,...t}=e;return(0,s.yg)(bKn,(0,p.A)({},LKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}NKn.isMDXComponent=!0;const kKn={toc:[]},zKn="wrapper";function PKn(e){let{components:n,...t}=e;return(0,s.yg)(zKn,(0,p.A)({},kKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}PKn.isMDXComponent=!0;const IKn={toc:[]},RKn="wrapper";function WKn(e){let{components:n,...t}=e;return(0,s.yg)(RKn,(0,p.A)({},IKn,t,{components:n,mdxType:"MDXLayout"}))}WKn.isMDXComponent=!0;const SKn={toc:[]},BKn="wrapper";function GKn(e){let{components:n,...t}=e;return(0,s.yg)(BKn,(0,p.A)({},SKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}GKn.isMDXComponent=!0;const EKn={toc:[]},OKn="wrapper";function UKn(e){let{components:n,...t}=e;return(0,s.yg)(OKn,(0,p.A)({},EKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}UKn.isMDXComponent=!0;const FKn={toc:[]},VKn="wrapper";function qKn(e){let{components:n,...t}=e;return(0,s.yg)(VKn,(0,p.A)({},FKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}qKn.isMDXComponent=!0;const jKn={toc:[]},HKn="wrapper";function YKn(e){let{components:n,...t}=e;return(0,s.yg)(HKn,(0,p.A)({},jKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}YKn.isMDXComponent=!0;const QKn={toc:[]},$Kn="wrapper";function KKn(e){let{components:n,...t}=e;return(0,s.yg)($Kn,(0,p.A)({},QKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}KKn.isMDXComponent=!0;const JKn={toc:[]},ZKn="wrapper";function eJn(e){let{components:n,...t}=e;return(0,s.yg)(ZKn,(0,p.A)({},JKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}eJn.isMDXComponent=!0;const nJn={toc:[]},tJn="wrapper";function oJn(e){let{components:n,...t}=e;return(0,s.yg)(tJn,(0,p.A)({},nJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}oJn.isMDXComponent=!0;const pJn={toc:[]},rJn="wrapper";function sJn(e){let{components:n,...t}=e;return(0,s.yg)(rJn,(0,p.A)({},pJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}sJn.isMDXComponent=!0;const cJn={toc:[]},aJn="wrapper";function iJn(e){let{components:n,...t}=e;return(0,s.yg)(aJn,(0,p.A)({},cJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}iJn.isMDXComponent=!0;const lJn={toc:[]},uJn="wrapper";function mJn(e){let{components:n,...t}=e;return(0,s.yg)(uJn,(0,p.A)({},lJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}mJn.isMDXComponent=!0;const yJn={toc:[]},dJn="wrapper";function hJn(e){let{components:n,...t}=e;return(0,s.yg)(dJn,(0,p.A)({},yJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}hJn.isMDXComponent=!0;const gJn={toc:[]},fJn="wrapper";function DJn(e){let{components:n,...t}=e;return(0,s.yg)(fJn,(0,p.A)({},gJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}DJn.isMDXComponent=!0;const MJn={toc:[]},XJn="wrapper";function _Jn(e){let{components:n,...t}=e;return(0,s.yg)(XJn,(0,p.A)({},MJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_Jn.isMDXComponent=!0;const wJn={toc:[]},TJn="wrapper";function CJn(e){let{components:n,...t}=e;return(0,s.yg)(TJn,(0,p.A)({},wJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}CJn.isMDXComponent=!0;const xJn={toc:[]},AJn="wrapper";function vJn(e){let{components:n,...t}=e;return(0,s.yg)(AJn,(0,p.A)({},xJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}vJn.isMDXComponent=!0;const LJn={toc:[]},bJn="wrapper";function NJn(e){let{components:n,...t}=e;return(0,s.yg)(bJn,(0,p.A)({},LJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}NJn.isMDXComponent=!0;const kJn={toc:[]},zJn="wrapper";function PJn(e){let{components:n,...t}=e;return(0,s.yg)(zJn,(0,p.A)({},kJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}PJn.isMDXComponent=!0;const IJn={toc:[]},RJn="wrapper";function WJn(e){let{components:n,...t}=e;return(0,s.yg)(RJn,(0,p.A)({},IJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}WJn.isMDXComponent=!0;const SJn={toc:[]},BJn="wrapper";function GJn(e){let{components:n,...t}=e;return(0,s.yg)(BJn,(0,p.A)({},SJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}GJn.isMDXComponent=!0;const EJn={toc:[]},OJn="wrapper";function UJn(e){let{components:n,...t}=e;return(0,s.yg)(OJn,(0,p.A)({},EJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}UJn.isMDXComponent=!0;const FJn={toc:[]},VJn="wrapper";function qJn(e){let{components:n,...t}=e;return(0,s.yg)(VJn,(0,p.A)({},FJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}qJn.isMDXComponent=!0;const jJn={toc:[]},HJn="wrapper";function YJn(e){let{components:n,...t}=e;return(0,s.yg)(HJn,(0,p.A)({},jJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}YJn.isMDXComponent=!0;const QJn={toc:[]},$Jn="wrapper";function KJn(e){let{components:n,...t}=e;return(0,s.yg)($Jn,(0,p.A)({},QJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}KJn.isMDXComponent=!0;const JJn={toc:[]},ZJn="wrapper";function eZn(e){let{components:n,...t}=e;return(0,s.yg)(ZJn,(0,p.A)({},JJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}eZn.isMDXComponent=!0;const nZn={toc:[]},tZn="wrapper";function oZn(e){let{components:n,...t}=e;return(0,s.yg)(tZn,(0,p.A)({},nZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}oZn.isMDXComponent=!0;const pZn={toc:[]},rZn="wrapper";function sZn(e){let{components:n,...t}=e;return(0,s.yg)(rZn,(0,p.A)({},pZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}sZn.isMDXComponent=!0;const cZn={toc:[]},aZn="wrapper";function iZn(e){let{components:n,...t}=e;return(0,s.yg)(aZn,(0,p.A)({},cZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}iZn.isMDXComponent=!0;const lZn={toc:[]},uZn="wrapper";function mZn(e){let{components:n,...t}=e;return(0,s.yg)(uZn,(0,p.A)({},lZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}mZn.isMDXComponent=!0;const yZn={toc:[]},dZn="wrapper";function hZn(e){let{components:n,...t}=e;return(0,s.yg)(dZn,(0,p.A)({},yZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}hZn.isMDXComponent=!0;const gZn={toc:[]},fZn="wrapper";function DZn(e){let{components:n,...t}=e;return(0,s.yg)(fZn,(0,p.A)({},gZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DZn.isMDXComponent=!0;const MZn={toc:[]},XZn="wrapper";function _Zn(e){let{components:n,...t}=e;return(0,s.yg)(XZn,(0,p.A)({},MZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}_Zn.isMDXComponent=!0;const wZn={toc:[]},TZn="wrapper";function CZn(e){let{components:n,...t}=e;return(0,s.yg)(TZn,(0,p.A)({},wZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}CZn.isMDXComponent=!0;const xZn={toc:[]},AZn="wrapper";function vZn(e){let{components:n,...t}=e;return(0,s.yg)(AZn,(0,p.A)({},xZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}vZn.isMDXComponent=!0;const LZn={toc:[]},bZn="wrapper";function NZn(e){let{components:n,...t}=e;return(0,s.yg)(bZn,(0,p.A)({},LZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}NZn.isMDXComponent=!0;const kZn={toc:[]},zZn="wrapper";function PZn(e){let{components:n,...t}=e;return(0,s.yg)(zZn,(0,p.A)({},kZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}PZn.isMDXComponent=!0;const IZn={toc:[]},RZn="wrapper";function WZn(e){let{components:n,...t}=e;return(0,s.yg)(RZn,(0,p.A)({},IZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}WZn.isMDXComponent=!0;const SZn={toc:[]},BZn="wrapper";function GZn(e){let{components:n,...t}=e;return(0,s.yg)(BZn,(0,p.A)({},SZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}GZn.isMDXComponent=!0;const EZn={toc:[]},OZn="wrapper";function UZn(e){let{components:n,...t}=e;return(0,s.yg)(OZn,(0,p.A)({},EZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}UZn.isMDXComponent=!0;const FZn={toc:[]},VZn="wrapper";function qZn(e){let{components:n,...t}=e;return(0,s.yg)(VZn,(0,p.A)({},FZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}qZn.isMDXComponent=!0;const jZn={toc:[]},HZn="wrapper";function YZn(e){let{components:n,...t}=e;return(0,s.yg)(HZn,(0,p.A)({},jZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}YZn.isMDXComponent=!0;const QZn={toc:[]},$Zn="wrapper";function KZn(e){let{components:n,...t}=e;return(0,s.yg)($Zn,(0,p.A)({},QZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}KZn.isMDXComponent=!0;const JZn={toc:[]},ZZn="wrapper";function e0n(e){let{components:n,...t}=e;return(0,s.yg)(ZZn,(0,p.A)({},JZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}e0n.isMDXComponent=!0;const n0n={toc:[]},t0n="wrapper";function o0n(e){let{components:n,...t}=e;return(0,s.yg)(t0n,(0,p.A)({},n0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}o0n.isMDXComponent=!0;const p0n={toc:[]},r0n="wrapper";function s0n(e){let{components:n,...t}=e;return(0,s.yg)(r0n,(0,p.A)({},p0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}s0n.isMDXComponent=!0;const c0n={toc:[]},a0n="wrapper";function i0n(e){let{components:n,...t}=e;return(0,s.yg)(a0n,(0,p.A)({},c0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}i0n.isMDXComponent=!0;const l0n={toc:[]},u0n="wrapper";function m0n(e){let{components:n,...t}=e;return(0,s.yg)(u0n,(0,p.A)({},l0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}m0n.isMDXComponent=!0;const y0n={toc:[]},d0n="wrapper";function h0n(e){let{components:n,...t}=e;return(0,s.yg)(d0n,(0,p.A)({},y0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}h0n.isMDXComponent=!0;const g0n={toc:[]},f0n="wrapper";function D0n(e){let{components:n,...t}=e;return(0,s.yg)(f0n,(0,p.A)({},g0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}D0n.isMDXComponent=!0;const M0n={toc:[]},X0n="wrapper";function _0n(e){let{components:n,...t}=e;return(0,s.yg)(X0n,(0,p.A)({},M0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}_0n.isMDXComponent=!0;const w0n={toc:[]},T0n="wrapper";function C0n(e){let{components:n,...t}=e;return(0,s.yg)(T0n,(0,p.A)({},w0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}C0n.isMDXComponent=!0;const x0n={toc:[]},A0n="wrapper";function v0n(e){let{components:n,...t}=e;return(0,s.yg)(A0n,(0,p.A)({},x0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}v0n.isMDXComponent=!0;const L0n={toc:[]},b0n="wrapper";function N0n(e){let{components:n,...t}=e;return(0,s.yg)(b0n,(0,p.A)({},L0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}N0n.isMDXComponent=!0;const k0n={toc:[]},z0n="wrapper";function P0n(e){let{components:n,...t}=e;return(0,s.yg)(z0n,(0,p.A)({},k0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}P0n.isMDXComponent=!0;const I0n={toc:[]},R0n="wrapper";function W0n(e){let{components:n,...t}=e;return(0,s.yg)(R0n,(0,p.A)({},I0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}W0n.isMDXComponent=!0;const S0n={toc:[]},B0n="wrapper";function G0n(e){let{components:n,...t}=e;return(0,s.yg)(B0n,(0,p.A)({},S0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}G0n.isMDXComponent=!0;const E0n={toc:[]},O0n="wrapper";function U0n(e){let{components:n,...t}=e;return(0,s.yg)(O0n,(0,p.A)({},E0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}U0n.isMDXComponent=!0;const F0n={toc:[]},V0n="wrapper";function q0n(e){let{components:n,...t}=e;return(0,s.yg)(V0n,(0,p.A)({},F0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}q0n.isMDXComponent=!0;const j0n={toc:[]},H0n="wrapper";function Y0n(e){let{components:n,...t}=e;return(0,s.yg)(H0n,(0,p.A)({},j0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Y0n.isMDXComponent=!0;const Q0n={toc:[]},$0n="wrapper";function K0n(e){let{components:n,...t}=e;return(0,s.yg)($0n,(0,p.A)({},Q0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}K0n.isMDXComponent=!0;const J0n={toc:[]},Z0n="wrapper";function e8n(e){let{components:n,...t}=e;return(0,s.yg)(Z0n,(0,p.A)({},J0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}e8n.isMDXComponent=!0;const n8n={toc:[]},t8n="wrapper";function o8n(e){let{components:n,...t}=e;return(0,s.yg)(t8n,(0,p.A)({},n8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}o8n.isMDXComponent=!0;const p8n={toc:[]},r8n="wrapper";function s8n(e){let{components:n,...t}=e;return(0,s.yg)(r8n,(0,p.A)({},p8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}s8n.isMDXComponent=!0;const c8n={toc:[]},a8n="wrapper";function i8n(e){let{components:n,...t}=e;return(0,s.yg)(a8n,(0,p.A)({},c8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}i8n.isMDXComponent=!0;const l8n={toc:[]},u8n="wrapper";function m8n(e){let{components:n,...t}=e;return(0,s.yg)(u8n,(0,p.A)({},l8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}m8n.isMDXComponent=!0;const y8n={toc:[]},d8n="wrapper";function h8n(e){let{components:n,...t}=e;return(0,s.yg)(d8n,(0,p.A)({},y8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}h8n.isMDXComponent=!0;const g8n={toc:[]},f8n="wrapper";function D8n(e){let{components:n,...t}=e;return(0,s.yg)(f8n,(0,p.A)({},g8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}D8n.isMDXComponent=!0;const M8n={toc:[]},X8n="wrapper";function _8n(e){let{components:n,...t}=e;return(0,s.yg)(X8n,(0,p.A)({},M8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}_8n.isMDXComponent=!0;const w8n={toc:[]},T8n="wrapper";function C8n(e){let{components:n,...t}=e;return(0,s.yg)(T8n,(0,p.A)({},w8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}C8n.isMDXComponent=!0;const x8n={toc:[]},A8n="wrapper";function v8n(e){let{components:n,...t}=e;return(0,s.yg)(A8n,(0,p.A)({},x8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}v8n.isMDXComponent=!0;const L8n={toc:[]},b8n="wrapper";function N8n(e){let{components:n,...t}=e;return(0,s.yg)(b8n,(0,p.A)({},L8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}N8n.isMDXComponent=!0;const k8n={toc:[]},z8n="wrapper";function P8n(e){let{components:n,...t}=e;return(0,s.yg)(z8n,(0,p.A)({},k8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}P8n.isMDXComponent=!0;const I8n={toc:[]},R8n="wrapper";function W8n(e){let{components:n,...t}=e;return(0,s.yg)(R8n,(0,p.A)({},I8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}W8n.isMDXComponent=!0;const S8n={toc:[]},B8n="wrapper";function G8n(e){let{components:n,...t}=e;return(0,s.yg)(B8n,(0,p.A)({},S8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}G8n.isMDXComponent=!0;const E8n={toc:[]},O8n="wrapper";function U8n(e){let{components:n,...t}=e;return(0,s.yg)(O8n,(0,p.A)({},E8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}U8n.isMDXComponent=!0;const F8n={toc:[]},V8n="wrapper";function q8n(e){let{components:n,...t}=e;return(0,s.yg)(V8n,(0,p.A)({},F8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}q8n.isMDXComponent=!0;const j8n={toc:[]},H8n="wrapper";function Y8n(e){let{components:n,...t}=e;return(0,s.yg)(H8n,(0,p.A)({},j8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}Y8n.isMDXComponent=!0;const Q8n={toc:[]},$8n="wrapper";function K8n(e){let{components:n,...t}=e;return(0,s.yg)($8n,(0,p.A)({},Q8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}K8n.isMDXComponent=!0;const J8n={toc:[]},Z8n="wrapper";function e2n(e){let{components:n,...t}=e;return(0,s.yg)(Z8n,(0,p.A)({},J8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}e2n.isMDXComponent=!0;const n2n={toc:[]},t2n="wrapper";function o2n(e){let{components:n,...t}=e;return(0,s.yg)(t2n,(0,p.A)({},n2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}o2n.isMDXComponent=!0;const p2n={toc:[]},r2n="wrapper";function s2n(e){let{components:n,...t}=e;return(0,s.yg)(r2n,(0,p.A)({},p2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}s2n.isMDXComponent=!0;const c2n={toc:[]},a2n="wrapper";function i2n(e){let{components:n,...t}=e;return(0,s.yg)(a2n,(0,p.A)({},c2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}i2n.isMDXComponent=!0;const l2n={toc:[]},u2n="wrapper";function m2n(e){let{components:n,...t}=e;return(0,s.yg)(u2n,(0,p.A)({},l2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}m2n.isMDXComponent=!0;const y2n={toc:[]},d2n="wrapper";function h2n(e){let{components:n,...t}=e;return(0,s.yg)(d2n,(0,p.A)({},y2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}h2n.isMDXComponent=!0;const g2n={toc:[]},f2n="wrapper";function D2n(e){let{components:n,...t}=e;return(0,s.yg)(f2n,(0,p.A)({},g2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}D2n.isMDXComponent=!0;const M2n={toc:[]},X2n="wrapper";function _2n(e){let{components:n,...t}=e;return(0,s.yg)(X2n,(0,p.A)({},M2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}_2n.isMDXComponent=!0;const w2n={toc:[]},T2n="wrapper";function C2n(e){let{components:n,...t}=e;return(0,s.yg)(T2n,(0,p.A)({},w2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}C2n.isMDXComponent=!0;const x2n={toc:[]},A2n="wrapper";function v2n(e){let{components:n,...t}=e;return(0,s.yg)(A2n,(0,p.A)({},x2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}v2n.isMDXComponent=!0;const L2n={toc:[]},b2n="wrapper";function N2n(e){let{components:n,...t}=e;return(0,s.yg)(b2n,(0,p.A)({},L2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}N2n.isMDXComponent=!0;const k2n={toc:[]},z2n="wrapper";function P2n(e){let{components:n,...t}=e;return(0,s.yg)(z2n,(0,p.A)({},k2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}P2n.isMDXComponent=!0;const I2n={toc:[]},R2n="wrapper";function W2n(e){let{components:n,...t}=e;return(0,s.yg)(R2n,(0,p.A)({},I2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}W2n.isMDXComponent=!0;const S2n={toc:[]},B2n="wrapper";function G2n(e){let{components:n,...t}=e;return(0,s.yg)(B2n,(0,p.A)({},S2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}G2n.isMDXComponent=!0;const E2n={toc:[]},O2n="wrapper";function U2n(e){let{components:n,...t}=e;return(0,s.yg)(O2n,(0,p.A)({},E2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}U2n.isMDXComponent=!0;const F2n={toc:[]},V2n="wrapper";function q2n(e){let{components:n,...t}=e;return(0,s.yg)(V2n,(0,p.A)({},F2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}q2n.isMDXComponent=!0;const j2n={toc:[]},H2n="wrapper";function Y2n(e){let{components:n,...t}=e;return(0,s.yg)(H2n,(0,p.A)({},j2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Y2n.isMDXComponent=!0;const Q2n={toc:[]},$2n="wrapper";function K2n(e){let{components:n,...t}=e;return(0,s.yg)($2n,(0,p.A)({},Q2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}K2n.isMDXComponent=!0;const J2n={toc:[]},Z2n="wrapper";function e3n(e){let{components:n,...t}=e;return(0,s.yg)(Z2n,(0,p.A)({},J2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}e3n.isMDXComponent=!0;const n3n={toc:[]},t3n="wrapper";function o3n(e){let{components:n,...t}=e;return(0,s.yg)(t3n,(0,p.A)({},n3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}o3n.isMDXComponent=!0;const p3n={toc:[]},r3n="wrapper";function s3n(e){let{components:n,...t}=e;return(0,s.yg)(r3n,(0,p.A)({},p3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}s3n.isMDXComponent=!0;const c3n={toc:[]},a3n="wrapper";function i3n(e){let{components:n,...t}=e;return(0,s.yg)(a3n,(0,p.A)({},c3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}i3n.isMDXComponent=!0;const l3n={toc:[]},u3n="wrapper";function m3n(e){let{components:n,...t}=e;return(0,s.yg)(u3n,(0,p.A)({},l3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}m3n.isMDXComponent=!0;const y3n={toc:[]},d3n="wrapper";function h3n(e){let{components:n,...t}=e;return(0,s.yg)(d3n,(0,p.A)({},y3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}h3n.isMDXComponent=!0;const g3n={toc:[]},f3n="wrapper";function D3n(e){let{components:n,...t}=e;return(0,s.yg)(f3n,(0,p.A)({},g3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}D3n.isMDXComponent=!0;const M3n={toc:[]},X3n="wrapper";function _3n(e){let{components:n,...t}=e;return(0,s.yg)(X3n,(0,p.A)({},M3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_3n.isMDXComponent=!0;const w3n={toc:[]},T3n="wrapper";function C3n(e){let{components:n,...t}=e;return(0,s.yg)(T3n,(0,p.A)({},w3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}C3n.isMDXComponent=!0;const x3n={toc:[]},A3n="wrapper";function v3n(e){let{components:n,...t}=e;return(0,s.yg)(A3n,(0,p.A)({},x3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}v3n.isMDXComponent=!0;const L3n={toc:[]},b3n="wrapper";function N3n(e){let{components:n,...t}=e;return(0,s.yg)(b3n,(0,p.A)({},L3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}N3n.isMDXComponent=!0;const k3n={toc:[]},z3n="wrapper";function P3n(e){let{components:n,...t}=e;return(0,s.yg)(z3n,(0,p.A)({},k3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}P3n.isMDXComponent=!0;const I3n={toc:[]},R3n="wrapper";function W3n(e){let{components:n,...t}=e;return(0,s.yg)(R3n,(0,p.A)({},I3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}W3n.isMDXComponent=!0;const S3n={toc:[]},B3n="wrapper";function G3n(e){let{components:n,...t}=e;return(0,s.yg)(B3n,(0,p.A)({},S3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}G3n.isMDXComponent=!0;const E3n={toc:[]},O3n="wrapper";function U3n(e){let{components:n,...t}=e;return(0,s.yg)(O3n,(0,p.A)({},E3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}U3n.isMDXComponent=!0;const F3n={toc:[]},V3n="wrapper";function q3n(e){let{components:n,...t}=e;return(0,s.yg)(V3n,(0,p.A)({},F3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}q3n.isMDXComponent=!0;const j3n={toc:[]},H3n="wrapper";function Y3n(e){let{components:n,...t}=e;return(0,s.yg)(H3n,(0,p.A)({},j3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Y3n.isMDXComponent=!0;const Q3n={toc:[]},$3n="wrapper";function K3n(e){let{components:n,...t}=e;return(0,s.yg)($3n,(0,p.A)({},Q3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}K3n.isMDXComponent=!0;const J3n={toc:[]},Z3n="wrapper";function e1n(e){let{components:n,...t}=e;return(0,s.yg)(Z3n,(0,p.A)({},J3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}e1n.isMDXComponent=!0;const n1n={toc:[]},t1n="wrapper";function o1n(e){let{components:n,...t}=e;return(0,s.yg)(t1n,(0,p.A)({},n1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}o1n.isMDXComponent=!0;const p1n={toc:[]},r1n="wrapper";function s1n(e){let{components:n,...t}=e;return(0,s.yg)(r1n,(0,p.A)({},p1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}s1n.isMDXComponent=!0;const c1n={toc:[]},a1n="wrapper";function i1n(e){let{components:n,...t}=e;return(0,s.yg)(a1n,(0,p.A)({},c1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}i1n.isMDXComponent=!0;const l1n={toc:[]},u1n="wrapper";function m1n(e){let{components:n,...t}=e;return(0,s.yg)(u1n,(0,p.A)({},l1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}m1n.isMDXComponent=!0;const y1n={toc:[]},d1n="wrapper";function h1n(e){let{components:n,...t}=e;return(0,s.yg)(d1n,(0,p.A)({},y1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}h1n.isMDXComponent=!0;const g1n={toc:[]},f1n="wrapper";function D1n(e){let{components:n,...t}=e;return(0,s.yg)(f1n,(0,p.A)({},g1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}D1n.isMDXComponent=!0;const M1n={toc:[]},X1n="wrapper";function _1n(e){let{components:n,...t}=e;return(0,s.yg)(X1n,(0,p.A)({},M1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}_1n.isMDXComponent=!0;const w1n={toc:[]},T1n="wrapper";function C1n(e){let{components:n,...t}=e;return(0,s.yg)(T1n,(0,p.A)({},w1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}C1n.isMDXComponent=!0;const x1n={toc:[]},A1n="wrapper";function v1n(e){let{components:n,...t}=e;return(0,s.yg)(A1n,(0,p.A)({},x1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}v1n.isMDXComponent=!0;const L1n={toc:[]},b1n="wrapper";function N1n(e){let{components:n,...t}=e;return(0,s.yg)(b1n,(0,p.A)({},L1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}N1n.isMDXComponent=!0;const k1n={toc:[]},z1n="wrapper";function P1n(e){let{components:n,...t}=e;return(0,s.yg)(z1n,(0,p.A)({},k1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}P1n.isMDXComponent=!0;const I1n={toc:[]},R1n="wrapper";function W1n(e){let{components:n,...t}=e;return(0,s.yg)(R1n,(0,p.A)({},I1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}W1n.isMDXComponent=!0;const S1n={toc:[]},B1n="wrapper";function G1n(e){let{components:n,...t}=e;return(0,s.yg)(B1n,(0,p.A)({},S1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}G1n.isMDXComponent=!0;const E1n={toc:[]},O1n="wrapper";function U1n(e){let{components:n,...t}=e;return(0,s.yg)(O1n,(0,p.A)({},E1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}U1n.isMDXComponent=!0;const F1n={toc:[]},V1n="wrapper";function q1n(e){let{components:n,...t}=e;return(0,s.yg)(V1n,(0,p.A)({},F1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}q1n.isMDXComponent=!0;const j1n={toc:[]},H1n="wrapper";function Y1n(e){let{components:n,...t}=e;return(0,s.yg)(H1n,(0,p.A)({},j1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Y1n.isMDXComponent=!0;const Q1n={toc:[]},$1n="wrapper";function K1n(e){let{components:n,...t}=e;return(0,s.yg)($1n,(0,p.A)({},Q1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}K1n.isMDXComponent=!0;const J1n={toc:[]},Z1n="wrapper";function e4n(e){let{components:n,...t}=e;return(0,s.yg)(Z1n,(0,p.A)({},J1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}e4n.isMDXComponent=!0;const n4n={toc:[]},t4n="wrapper";function o4n(e){let{components:n,...t}=e;return(0,s.yg)(t4n,(0,p.A)({},n4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}o4n.isMDXComponent=!0;const p4n={toc:[]},r4n="wrapper";function s4n(e){let{components:n,...t}=e;return(0,s.yg)(r4n,(0,p.A)({},p4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}s4n.isMDXComponent=!0;const c4n={toc:[]},a4n="wrapper";function i4n(e){let{components:n,...t}=e;return(0,s.yg)(a4n,(0,p.A)({},c4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}i4n.isMDXComponent=!0;const l4n={toc:[]},u4n="wrapper";function m4n(e){let{components:n,...t}=e;return(0,s.yg)(u4n,(0,p.A)({},l4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}m4n.isMDXComponent=!0;const y4n={toc:[]},d4n="wrapper";function h4n(e){let{components:n,...t}=e;return(0,s.yg)(d4n,(0,p.A)({},y4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}h4n.isMDXComponent=!0;const g4n={toc:[]},f4n="wrapper";function D4n(e){let{components:n,...t}=e;return(0,s.yg)(f4n,(0,p.A)({},g4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}D4n.isMDXComponent=!0;const M4n={toc:[]},X4n="wrapper";function _4n(e){let{components:n,...t}=e;return(0,s.yg)(X4n,(0,p.A)({},M4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}_4n.isMDXComponent=!0;const w4n={toc:[]},T4n="wrapper";function C4n(e){let{components:n,...t}=e;return(0,s.yg)(T4n,(0,p.A)({},w4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}C4n.isMDXComponent=!0;const x4n={toc:[]},A4n="wrapper";function v4n(e){let{components:n,...t}=e;return(0,s.yg)(A4n,(0,p.A)({},x4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}v4n.isMDXComponent=!0;const L4n={toc:[]},b4n="wrapper";function N4n(e){let{components:n,...t}=e;return(0,s.yg)(b4n,(0,p.A)({},L4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}N4n.isMDXComponent=!0;const k4n={toc:[]},z4n="wrapper";function P4n(e){let{components:n,...t}=e;return(0,s.yg)(z4n,(0,p.A)({},k4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}P4n.isMDXComponent=!0;const I4n={toc:[]},R4n="wrapper";function W4n(e){let{components:n,...t}=e;return(0,s.yg)(R4n,(0,p.A)({},I4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}W4n.isMDXComponent=!0;const S4n={toc:[]},B4n="wrapper";function G4n(e){let{components:n,...t}=e;return(0,s.yg)(B4n,(0,p.A)({},S4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}G4n.isMDXComponent=!0;const E4n={toc:[]},O4n="wrapper";function U4n(e){let{components:n,...t}=e;return(0,s.yg)(O4n,(0,p.A)({},E4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}U4n.isMDXComponent=!0;const F4n={toc:[]},V4n="wrapper";function q4n(e){let{components:n,...t}=e;return(0,s.yg)(V4n,(0,p.A)({},F4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}q4n.isMDXComponent=!0;const j4n={toc:[]},H4n="wrapper";function Y4n(e){let{components:n,...t}=e;return(0,s.yg)(H4n,(0,p.A)({},j4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Y4n.isMDXComponent=!0;const Q4n={toc:[]},$4n="wrapper";function K4n(e){let{components:n,...t}=e;return(0,s.yg)($4n,(0,p.A)({},Q4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}K4n.isMDXComponent=!0;const J4n={toc:[]},Z4n="wrapper";function e6n(e){let{components:n,...t}=e;return(0,s.yg)(Z4n,(0,p.A)({},J4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}e6n.isMDXComponent=!0;const n6n={toc:[]},t6n="wrapper";function o6n(e){let{components:n,...t}=e;return(0,s.yg)(t6n,(0,p.A)({},n6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}o6n.isMDXComponent=!0;const p6n={toc:[]},r6n="wrapper";function s6n(e){let{components:n,...t}=e;return(0,s.yg)(r6n,(0,p.A)({},p6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}s6n.isMDXComponent=!0;const c6n={toc:[]},a6n="wrapper";function i6n(e){let{components:n,...t}=e;return(0,s.yg)(a6n,(0,p.A)({},c6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}i6n.isMDXComponent=!0;const l6n={toc:[]},u6n="wrapper";function m6n(e){let{components:n,...t}=e;return(0,s.yg)(u6n,(0,p.A)({},l6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}m6n.isMDXComponent=!0;const y6n={toc:[]},d6n="wrapper";function h6n(e){let{components:n,...t}=e;return(0,s.yg)(d6n,(0,p.A)({},y6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}h6n.isMDXComponent=!0;const g6n={toc:[]},f6n="wrapper";function D6n(e){let{components:n,...t}=e;return(0,s.yg)(f6n,(0,p.A)({},g6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}D6n.isMDXComponent=!0;const M6n={toc:[]},X6n="wrapper";function _6n(e){let{components:n,...t}=e;return(0,s.yg)(X6n,(0,p.A)({},M6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}_6n.isMDXComponent=!0;const w6n={toc:[]},T6n="wrapper";function C6n(e){let{components:n,...t}=e;return(0,s.yg)(T6n,(0,p.A)({},w6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}C6n.isMDXComponent=!0;const x6n={toc:[]},A6n="wrapper";function v6n(e){let{components:n,...t}=e;return(0,s.yg)(A6n,(0,p.A)({},x6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}v6n.isMDXComponent=!0;const L6n={toc:[]},b6n="wrapper";function N6n(e){let{components:n,...t}=e;return(0,s.yg)(b6n,(0,p.A)({},L6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}N6n.isMDXComponent=!0;const k6n={toc:[]},z6n="wrapper";function P6n(e){let{components:n,...t}=e;return(0,s.yg)(z6n,(0,p.A)({},k6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}P6n.isMDXComponent=!0;const I6n={toc:[]},R6n="wrapper";function W6n(e){let{components:n,...t}=e;return(0,s.yg)(R6n,(0,p.A)({},I6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}W6n.isMDXComponent=!0;const S6n={toc:[]},B6n="wrapper";function G6n(e){let{components:n,...t}=e;return(0,s.yg)(B6n,(0,p.A)({},S6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}G6n.isMDXComponent=!0;const E6n={toc:[]},O6n="wrapper";function U6n(e){let{components:n,...t}=e;return(0,s.yg)(O6n,(0,p.A)({},E6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}U6n.isMDXComponent=!0;const F6n={toc:[]},V6n="wrapper";function q6n(e){let{components:n,...t}=e;return(0,s.yg)(V6n,(0,p.A)({},F6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}q6n.isMDXComponent=!0;const j6n={toc:[]},H6n="wrapper";function Y6n(e){let{components:n,...t}=e;return(0,s.yg)(H6n,(0,p.A)({},j6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Y6n.isMDXComponent=!0;const Q6n={toc:[]},$6n="wrapper";function K6n(e){let{components:n,...t}=e;return(0,s.yg)($6n,(0,p.A)({},Q6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}K6n.isMDXComponent=!0;const J6n={toc:[]},Z6n="wrapper";function e5n(e){let{components:n,...t}=e;return(0,s.yg)(Z6n,(0,p.A)({},J6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}e5n.isMDXComponent=!0;const n5n={toc:[]},t5n="wrapper";function o5n(e){let{components:n,...t}=e;return(0,s.yg)(t5n,(0,p.A)({},n5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}o5n.isMDXComponent=!0;const p5n={toc:[]},r5n="wrapper";function s5n(e){let{components:n,...t}=e;return(0,s.yg)(r5n,(0,p.A)({},p5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}s5n.isMDXComponent=!0;const c5n={toc:[]},a5n="wrapper";function i5n(e){let{components:n,...t}=e;return(0,s.yg)(a5n,(0,p.A)({},c5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}i5n.isMDXComponent=!0;const l5n={toc:[]},u5n="wrapper";function m5n(e){let{components:n,...t}=e;return(0,s.yg)(u5n,(0,p.A)({},l5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}m5n.isMDXComponent=!0;const y5n={toc:[]},d5n="wrapper";function h5n(e){let{components:n,...t}=e;return(0,s.yg)(d5n,(0,p.A)({},y5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}h5n.isMDXComponent=!0;const g5n={toc:[]},f5n="wrapper";function D5n(e){let{components:n,...t}=e;return(0,s.yg)(f5n,(0,p.A)({},g5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}D5n.isMDXComponent=!0;const M5n={toc:[]},X5n="wrapper";function _5n(e){let{components:n,...t}=e;return(0,s.yg)(X5n,(0,p.A)({},M5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_5n.isMDXComponent=!0;const w5n={toc:[]},T5n="wrapper";function C5n(e){let{components:n,...t}=e;return(0,s.yg)(T5n,(0,p.A)({},w5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}C5n.isMDXComponent=!0;const x5n={toc:[]},A5n="wrapper";function v5n(e){let{components:n,...t}=e;return(0,s.yg)(A5n,(0,p.A)({},x5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}v5n.isMDXComponent=!0;const L5n={toc:[]},b5n="wrapper";function N5n(e){let{components:n,...t}=e;return(0,s.yg)(b5n,(0,p.A)({},L5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}N5n.isMDXComponent=!0;const k5n={toc:[]},z5n="wrapper";function P5n(e){let{components:n,...t}=e;return(0,s.yg)(z5n,(0,p.A)({},k5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}P5n.isMDXComponent=!0;const I5n={toc:[]},R5n="wrapper";function W5n(e){let{components:n,...t}=e;return(0,s.yg)(R5n,(0,p.A)({},I5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}W5n.isMDXComponent=!0;const S5n={toc:[]},B5n="wrapper";function G5n(e){let{components:n,...t}=e;return(0,s.yg)(B5n,(0,p.A)({},S5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}G5n.isMDXComponent=!0;const E5n={toc:[]},O5n="wrapper";function U5n(e){let{components:n,...t}=e;return(0,s.yg)(O5n,(0,p.A)({},E5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}U5n.isMDXComponent=!0;const F5n={toc:[]},V5n="wrapper";function q5n(e){let{components:n,...t}=e;return(0,s.yg)(V5n,(0,p.A)({},F5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}q5n.isMDXComponent=!0;const j5n={toc:[]},H5n="wrapper";function Y5n(e){let{components:n,...t}=e;return(0,s.yg)(H5n,(0,p.A)({},j5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Y5n.isMDXComponent=!0;const Q5n={toc:[]},$5n="wrapper";function K5n(e){let{components:n,...t}=e;return(0,s.yg)($5n,(0,p.A)({},Q5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}K5n.isMDXComponent=!0;const J5n={toc:[]},Z5n="wrapper";function e7n(e){let{components:n,...t}=e;return(0,s.yg)(Z5n,(0,p.A)({},J5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}e7n.isMDXComponent=!0;const n7n={toc:[]},t7n="wrapper";function o7n(e){let{components:n,...t}=e;return(0,s.yg)(t7n,(0,p.A)({},n7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}o7n.isMDXComponent=!0;const p7n={toc:[]},r7n="wrapper";function s7n(e){let{components:n,...t}=e;return(0,s.yg)(r7n,(0,p.A)({},p7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}s7n.isMDXComponent=!0;const c7n={toc:[]},a7n="wrapper";function i7n(e){let{components:n,...t}=e;return(0,s.yg)(a7n,(0,p.A)({},c7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}i7n.isMDXComponent=!0;const l7n={toc:[]},u7n="wrapper";function m7n(e){let{components:n,...t}=e;return(0,s.yg)(u7n,(0,p.A)({},l7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}m7n.isMDXComponent=!0;const y7n={toc:[]},d7n="wrapper";function h7n(e){let{components:n,...t}=e;return(0,s.yg)(d7n,(0,p.A)({},y7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}h7n.isMDXComponent=!0;const g7n={toc:[]},f7n="wrapper";function D7n(e){let{components:n,...t}=e;return(0,s.yg)(f7n,(0,p.A)({},g7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}D7n.isMDXComponent=!0;const M7n={toc:[]},X7n="wrapper";function _7n(e){let{components:n,...t}=e;return(0,s.yg)(X7n,(0,p.A)({},M7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}_7n.isMDXComponent=!0;const w7n={toc:[]},T7n="wrapper";function C7n(e){let{components:n,...t}=e;return(0,s.yg)(T7n,(0,p.A)({},w7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}C7n.isMDXComponent=!0;const x7n={toc:[]},A7n="wrapper";function v7n(e){let{components:n,...t}=e;return(0,s.yg)(A7n,(0,p.A)({},x7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}v7n.isMDXComponent=!0;const L7n={toc:[]},b7n="wrapper";function N7n(e){let{components:n,...t}=e;return(0,s.yg)(b7n,(0,p.A)({},L7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}N7n.isMDXComponent=!0;const k7n={toc:[]},z7n="wrapper";function P7n(e){let{components:n,...t}=e;return(0,s.yg)(z7n,(0,p.A)({},k7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}P7n.isMDXComponent=!0;const I7n={toc:[]},R7n="wrapper";function W7n(e){let{components:n,...t}=e;return(0,s.yg)(R7n,(0,p.A)({},I7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}W7n.isMDXComponent=!0;const S7n={toc:[]},B7n="wrapper";function G7n(e){let{components:n,...t}=e;return(0,s.yg)(B7n,(0,p.A)({},S7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}G7n.isMDXComponent=!0;const E7n={toc:[]},O7n="wrapper";function U7n(e){let{components:n,...t}=e;return(0,s.yg)(O7n,(0,p.A)({},E7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}U7n.isMDXComponent=!0;const F7n={toc:[]},V7n="wrapper";function q7n(e){let{components:n,...t}=e;return(0,s.yg)(V7n,(0,p.A)({},F7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}q7n.isMDXComponent=!0;const j7n={toc:[]},H7n="wrapper";function Y7n(e){let{components:n,...t}=e;return(0,s.yg)(H7n,(0,p.A)({},j7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Y7n.isMDXComponent=!0;const Q7n={toc:[]},$7n="wrapper";function K7n(e){let{components:n,...t}=e;return(0,s.yg)($7n,(0,p.A)({},Q7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}K7n.isMDXComponent=!0;const J7n={toc:[]},Z7n="wrapper";function e9n(e){let{components:n,...t}=e;return(0,s.yg)(Z7n,(0,p.A)({},J7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}e9n.isMDXComponent=!0;const n9n={toc:[]},t9n="wrapper";function o9n(e){let{components:n,...t}=e;return(0,s.yg)(t9n,(0,p.A)({},n9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}o9n.isMDXComponent=!0;const p9n={toc:[]},r9n="wrapper";function s9n(e){let{components:n,...t}=e;return(0,s.yg)(r9n,(0,p.A)({},p9n,t,{components:n,mdxType:"MDXLayout"}))}s9n.isMDXComponent=!0;const c9n={toc:[]},a9n="wrapper";function i9n(e){let{components:n,...t}=e;return(0,s.yg)(a9n,(0,p.A)({},c9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}i9n.isMDXComponent=!0;const l9n={toc:[]},u9n="wrapper";function m9n(e){let{components:n,...t}=e;return(0,s.yg)(u9n,(0,p.A)({},l9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}m9n.isMDXComponent=!0;const y9n={toc:[]},d9n="wrapper";function h9n(e){let{components:n,...t}=e;return(0,s.yg)(d9n,(0,p.A)({},y9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}h9n.isMDXComponent=!0;const g9n={toc:[]},f9n="wrapper";function D9n(e){let{components:n,...t}=e;return(0,s.yg)(f9n,(0,p.A)({},g9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}D9n.isMDXComponent=!0;const M9n={toc:[]},X9n="wrapper";function _9n(e){let{components:n,...t}=e;return(0,s.yg)(X9n,(0,p.A)({},M9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}_9n.isMDXComponent=!0;const w9n={toc:[]},T9n="wrapper";function C9n(e){let{components:n,...t}=e;return(0,s.yg)(T9n,(0,p.A)({},w9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}C9n.isMDXComponent=!0;const x9n={toc:[]},A9n="wrapper";function v9n(e){let{components:n,...t}=e;return(0,s.yg)(A9n,(0,p.A)({},x9n,t,{components:n,mdxType:"MDXLayout"}))}v9n.isMDXComponent=!0;const L9n={toc:[]},b9n="wrapper";function N9n(e){let{components:n,...t}=e;return(0,s.yg)(b9n,(0,p.A)({},L9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}N9n.isMDXComponent=!0;const k9n={toc:[]},z9n="wrapper";function P9n(e){let{components:n,...t}=e;return(0,s.yg)(z9n,(0,p.A)({},k9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}P9n.isMDXComponent=!0;const I9n={toc:[]},R9n="wrapper";function W9n(e){let{components:n,...t}=e;return(0,s.yg)(R9n,(0,p.A)({},I9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}W9n.isMDXComponent=!0;const S9n={toc:[]},B9n="wrapper";function G9n(e){let{components:n,...t}=e;return(0,s.yg)(B9n,(0,p.A)({},S9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}G9n.isMDXComponent=!0;const E9n={toc:[]},O9n="wrapper";function U9n(e){let{components:n,...t}=e;return(0,s.yg)(O9n,(0,p.A)({},E9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}U9n.isMDXComponent=!0;const F9n={toc:[]},V9n="wrapper";function q9n(e){let{components:n,...t}=e;return(0,s.yg)(V9n,(0,p.A)({},F9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}q9n.isMDXComponent=!0;const j9n={toc:[]},H9n="wrapper";function Y9n(e){let{components:n,...t}=e;return(0,s.yg)(H9n,(0,p.A)({},j9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Y9n.isMDXComponent=!0;const Q9n={toc:[]},$9n="wrapper";function K9n(e){let{components:n,...t}=e;return(0,s.yg)($9n,(0,p.A)({},Q9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}K9n.isMDXComponent=!0;const J9n={toc:[]},Z9n="wrapper";function eet(e){let{components:n,...t}=e;return(0,s.yg)(Z9n,(0,p.A)({},J9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}eet.isMDXComponent=!0;const net={toc:[]},tet="wrapper";function oet(e){let{components:n,...t}=e;return(0,s.yg)(tet,(0,p.A)({},net,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}oet.isMDXComponent=!0;const pet={toc:[]},ret="wrapper";function set(e){let{components:n,...t}=e;return(0,s.yg)(ret,(0,p.A)({},pet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}set.isMDXComponent=!0;const cet={toc:[]},aet="wrapper";function iet(e){let{components:n,...t}=e;return(0,s.yg)(aet,(0,p.A)({},cet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}iet.isMDXComponent=!0;const uet={toc:[]},met="wrapper";function yet(e){let{components:n,...t}=e;return(0,s.yg)(met,(0,p.A)({},uet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}yet.isMDXComponent=!0;const det={toc:[]},het="wrapper";function get(e){let{components:n,...t}=e;return(0,s.yg)(het,(0,p.A)({},det,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}get.isMDXComponent=!0;const fet={toc:[]},Det="wrapper";function Met(e){let{components:n,...t}=e;return(0,s.yg)(Det,(0,p.A)({},fet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Met.isMDXComponent=!0;const Xet={toc:[]},_et="wrapper";function wet(e){let{components:n,...t}=e;return(0,s.yg)(_et,(0,p.A)({},Xet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}wet.isMDXComponent=!0;const Tet={toc:[]},Cet="wrapper";function xet(e){let{components:n,...t}=e;return(0,s.yg)(Cet,(0,p.A)({},Tet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}xet.isMDXComponent=!0;const Aet={toc:[]},vet="wrapper";function Let(e){let{components:n,...t}=e;return(0,s.yg)(vet,(0,p.A)({},Aet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Let.isMDXComponent=!0;const bet={toc:[]},Net="wrapper";function ket(e){let{components:n,...t}=e;return(0,s.yg)(Net,(0,p.A)({},bet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}ket.isMDXComponent=!0;const zet={toc:[]},Pet="wrapper";function Iet(e){let{components:n,...t}=e;return(0,s.yg)(Pet,(0,p.A)({},zet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Iet.isMDXComponent=!0;const Ret={toc:[]},Wet="wrapper";function Set(e){let{components:n,...t}=e;return(0,s.yg)(Wet,(0,p.A)({},Ret,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Set.isMDXComponent=!0;const Bet={toc:[]},Get="wrapper";function Eet(e){let{components:n,...t}=e;return(0,s.yg)(Get,(0,p.A)({},Bet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Eet.isMDXComponent=!0;const Oet={toc:[]},Uet="wrapper";function Fet(e){let{components:n,...t}=e;return(0,s.yg)(Uet,(0,p.A)({},Oet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Fet.isMDXComponent=!0;const Vet={toc:[]},qet="wrapper";function jet(e){let{components:n,...t}=e;return(0,s.yg)(qet,(0,p.A)({},Vet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}jet.isMDXComponent=!0;const Het={toc:[]},Yet="wrapper";function Qet(e){let{components:n,...t}=e;return(0,s.yg)(Yet,(0,p.A)({},Het,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Qet.isMDXComponent=!0;const $et={toc:[]},Ket="wrapper";function Jet(e){let{components:n,...t}=e;return(0,s.yg)(Ket,(0,p.A)({},$et,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Jet.isMDXComponent=!0;const Zet={toc:[]},ent="wrapper";function nnt(e){let{components:n,...t}=e;return(0,s.yg)(ent,(0,p.A)({},Zet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}nnt.isMDXComponent=!0;const tnt={toc:[]},ont="wrapper";function pnt(e){let{components:n,...t}=e;return(0,s.yg)(ont,(0,p.A)({},tnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}pnt.isMDXComponent=!0;const rnt={toc:[]},snt="wrapper";function cnt(e){let{components:n,...t}=e;return(0,s.yg)(snt,(0,p.A)({},rnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}cnt.isMDXComponent=!0;const ant={toc:[]},int="wrapper";function lnt(e){let{components:n,...t}=e;return(0,s.yg)(int,(0,p.A)({},ant,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}lnt.isMDXComponent=!0;const unt={toc:[]},mnt="wrapper";function ynt(e){let{components:n,...t}=e;return(0,s.yg)(mnt,(0,p.A)({},unt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ynt.isMDXComponent=!0;const dnt={toc:[]},hnt="wrapper";function gnt(e){let{components:n,...t}=e;return(0,s.yg)(hnt,(0,p.A)({},dnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}gnt.isMDXComponent=!0;const fnt={toc:[]},Dnt="wrapper";function Mnt(e){let{components:n,...t}=e;return(0,s.yg)(Dnt,(0,p.A)({},fnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Mnt.isMDXComponent=!0;const Xnt={toc:[]},_nt="wrapper";function wnt(e){let{components:n,...t}=e;return(0,s.yg)(_nt,(0,p.A)({},Xnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wnt.isMDXComponent=!0;const Tnt={toc:[]},Cnt="wrapper";function xnt(e){let{components:n,...t}=e;return(0,s.yg)(Cnt,(0,p.A)({},Tnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}xnt.isMDXComponent=!0;const Ant={toc:[]},vnt="wrapper";function Lnt(e){let{components:n,...t}=e;return(0,s.yg)(vnt,(0,p.A)({},Ant,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Lnt.isMDXComponent=!0;const bnt={toc:[]},Nnt="wrapper";function knt(e){let{components:n,...t}=e;return(0,s.yg)(Nnt,(0,p.A)({},bnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}knt.isMDXComponent=!0;const znt={toc:[]},Pnt="wrapper";function Int(e){let{components:n,...t}=e;return(0,s.yg)(Pnt,(0,p.A)({},znt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Int.isMDXComponent=!0;const Rnt={toc:[]},Wnt="wrapper";function Snt(e){let{components:n,...t}=e;return(0,s.yg)(Wnt,(0,p.A)({},Rnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Snt.isMDXComponent=!0;const Bnt={toc:[]},Gnt="wrapper";function Ent(e){let{components:n,...t}=e;return(0,s.yg)(Gnt,(0,p.A)({},Bnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Ent.isMDXComponent=!0;const Ont={toc:[]},Unt="wrapper";function Fnt(e){let{components:n,...t}=e;return(0,s.yg)(Unt,(0,p.A)({},Ont,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fnt.isMDXComponent=!0;const Vnt={toc:[]},qnt="wrapper";function jnt(e){let{components:n,...t}=e;return(0,s.yg)(qnt,(0,p.A)({},Vnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}jnt.isMDXComponent=!0;const Hnt={toc:[]},Ynt="wrapper";function Qnt(e){let{components:n,...t}=e;return(0,s.yg)(Ynt,(0,p.A)({},Hnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qnt.isMDXComponent=!0;const $nt={toc:[]},Knt="wrapper";function Jnt(e){let{components:n,...t}=e;return(0,s.yg)(Knt,(0,p.A)({},$nt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Jnt.isMDXComponent=!0;const Znt={toc:[]},ett="wrapper";function ntt(e){let{components:n,...t}=e;return(0,s.yg)(ett,(0,p.A)({},Znt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ntt.isMDXComponent=!0;const ttt={toc:[]},ott="wrapper";function ptt(e){let{components:n,...t}=e;return(0,s.yg)(ott,(0,p.A)({},ttt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}ptt.isMDXComponent=!0;const rtt={toc:[]},stt="wrapper";function ctt(e){let{components:n,...t}=e;return(0,s.yg)(stt,(0,p.A)({},rtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ctt.isMDXComponent=!0;const att={toc:[]},itt="wrapper";function ltt(e){let{components:n,...t}=e;return(0,s.yg)(itt,(0,p.A)({},att,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}ltt.isMDXComponent=!0;const utt={toc:[]},mtt="wrapper";function ytt(e){let{components:n,...t}=e;return(0,s.yg)(mtt,(0,p.A)({},utt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ytt.isMDXComponent=!0;const dtt={toc:[]},htt="wrapper";function gtt(e){let{components:n,...t}=e;return(0,s.yg)(htt,(0,p.A)({},dtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}gtt.isMDXComponent=!0;const ftt={toc:[]},Dtt="wrapper";function Mtt(e){let{components:n,...t}=e;return(0,s.yg)(Dtt,(0,p.A)({},ftt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mtt.isMDXComponent=!0;const Xtt={toc:[]},_tt="wrapper";function wtt(e){let{components:n,...t}=e;return(0,s.yg)(_tt,(0,p.A)({},Xtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}wtt.isMDXComponent=!0;const Ttt={toc:[]},Ctt="wrapper";function xtt(e){let{components:n,...t}=e;return(0,s.yg)(Ctt,(0,p.A)({},Ttt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xtt.isMDXComponent=!0;const Att={toc:[]},vtt="wrapper";function Ltt(e){let{components:n,...t}=e;return(0,s.yg)(vtt,(0,p.A)({},Att,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Ltt.isMDXComponent=!0;const btt={toc:[]},Ntt="wrapper";function ktt(e){let{components:n,...t}=e;return(0,s.yg)(Ntt,(0,p.A)({},btt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ktt.isMDXComponent=!0;const ztt={toc:[]},Ptt="wrapper";function Itt(e){let{components:n,...t}=e;return(0,s.yg)(Ptt,(0,p.A)({},ztt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Itt.isMDXComponent=!0;const Rtt={toc:[]},Wtt="wrapper";function Stt(e){let{components:n,...t}=e;return(0,s.yg)(Wtt,(0,p.A)({},Rtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Stt.isMDXComponent=!0;const Btt={toc:[]},Gtt="wrapper";function Ett(e){let{components:n,...t}=e;return(0,s.yg)(Gtt,(0,p.A)({},Btt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ett.isMDXComponent=!0;const Ott={toc:[]},Utt="wrapper";function Ftt(e){let{components:n,...t}=e;return(0,s.yg)(Utt,(0,p.A)({},Ott,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Ftt.isMDXComponent=!0;const Vtt={toc:[]},qtt="wrapper";function jtt(e){let{components:n,...t}=e;return(0,s.yg)(qtt,(0,p.A)({},Vtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}jtt.isMDXComponent=!0;const Htt={toc:[]},Ytt="wrapper";function Qtt(e){let{components:n,...t}=e;return(0,s.yg)(Ytt,(0,p.A)({},Htt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Qtt.isMDXComponent=!0;const $tt={toc:[]},Ktt="wrapper";function Jtt(e){let{components:n,...t}=e;return(0,s.yg)(Ktt,(0,p.A)({},$tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Jtt.isMDXComponent=!0;const Ztt={toc:[]},eot="wrapper";function not(e){let{components:n,...t}=e;return(0,s.yg)(eot,(0,p.A)({},Ztt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}not.isMDXComponent=!0;const tot={toc:[]},oot="wrapper";function pot(e){let{components:n,...t}=e;return(0,s.yg)(oot,(0,p.A)({},tot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}pot.isMDXComponent=!0;const rot={toc:[]},sot="wrapper";function cot(e){let{components:n,...t}=e;return(0,s.yg)(sot,(0,p.A)({},rot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}cot.isMDXComponent=!0;const aot={toc:[]},iot="wrapper";function lot(e){let{components:n,...t}=e;return(0,s.yg)(iot,(0,p.A)({},aot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}lot.isMDXComponent=!0;const uot={toc:[]},mot="wrapper";function yot(e){let{components:n,...t}=e;return(0,s.yg)(mot,(0,p.A)({},uot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}yot.isMDXComponent=!0;const dot={toc:[]},hot="wrapper";function got(e){let{components:n,...t}=e;return(0,s.yg)(hot,(0,p.A)({},dot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}got.isMDXComponent=!0;const fot={toc:[]},Dot="wrapper";function Mot(e){let{components:n,...t}=e;return(0,s.yg)(Dot,(0,p.A)({},fot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Mot.isMDXComponent=!0;const Xot={toc:[]},_ot="wrapper";function wot(e){let{components:n,...t}=e;return(0,s.yg)(_ot,(0,p.A)({},Xot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wot.isMDXComponent=!0;const Tot={toc:[]},Cot="wrapper";function xot(e){let{components:n,...t}=e;return(0,s.yg)(Cot,(0,p.A)({},Tot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}xot.isMDXComponent=!0;const Aot={toc:[]},vot="wrapper";function Lot(e){let{components:n,...t}=e;return(0,s.yg)(vot,(0,p.A)({},Aot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Lot.isMDXComponent=!0;const bot={toc:[]},Not="wrapper";function kot(e){let{components:n,...t}=e;return(0,s.yg)(Not,(0,p.A)({},bot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kot.isMDXComponent=!0;const zot={toc:[]},Pot="wrapper";function Iot(e){let{components:n,...t}=e;return(0,s.yg)(Pot,(0,p.A)({},zot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Iot.isMDXComponent=!0;const Rot={toc:[]},Wot="wrapper";function Sot(e){let{components:n,...t}=e;return(0,s.yg)(Wot,(0,p.A)({},Rot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Sot.isMDXComponent=!0;const Bot={toc:[]},Got="wrapper";function Eot(e){let{components:n,...t}=e;return(0,s.yg)(Got,(0,p.A)({},Bot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Eot.isMDXComponent=!0;const Oot={toc:[]},Uot="wrapper";function Fot(e){let{components:n,...t}=e;return(0,s.yg)(Uot,(0,p.A)({},Oot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Fot.isMDXComponent=!0;const Vot={toc:[]},qot="wrapper";function jot(e){let{components:n,...t}=e;return(0,s.yg)(qot,(0,p.A)({},Vot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}jot.isMDXComponent=!0;const Hot={toc:[]},Yot="wrapper";function Qot(e){let{components:n,...t}=e;return(0,s.yg)(Yot,(0,p.A)({},Hot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Qot.isMDXComponent=!0;const $ot={toc:[]},Kot="wrapper";function Jot(e){let{components:n,...t}=e;return(0,s.yg)(Kot,(0,p.A)({},$ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Jot.isMDXComponent=!0;const Zot={toc:[]},ept="wrapper";function npt(e){let{components:n,...t}=e;return(0,s.yg)(ept,(0,p.A)({},Zot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}npt.isMDXComponent=!0;const tpt={toc:[]},opt="wrapper";function ppt(e){let{components:n,...t}=e;return(0,s.yg)(opt,(0,p.A)({},tpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}ppt.isMDXComponent=!0;const rpt={toc:[]},spt="wrapper";function cpt(e){let{components:n,...t}=e;return(0,s.yg)(spt,(0,p.A)({},rpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}cpt.isMDXComponent=!0;const apt={toc:[]},ipt="wrapper";function lpt(e){let{components:n,...t}=e;return(0,s.yg)(ipt,(0,p.A)({},apt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}lpt.isMDXComponent=!0;const upt={toc:[]},mpt="wrapper";function ypt(e){let{components:n,...t}=e;return(0,s.yg)(mpt,(0,p.A)({},upt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}ypt.isMDXComponent=!0;const dpt={toc:[]},hpt="wrapper";function gpt(e){let{components:n,...t}=e;return(0,s.yg)(hpt,(0,p.A)({},dpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gpt.isMDXComponent=!0;const fpt={toc:[]},Dpt="wrapper";function Mpt(e){let{components:n,...t}=e;return(0,s.yg)(Dpt,(0,p.A)({},fpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Mpt.isMDXComponent=!0;const Xpt={toc:[]},_pt="wrapper";function wpt(e){let{components:n,...t}=e;return(0,s.yg)(_pt,(0,p.A)({},Xpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wpt.isMDXComponent=!0;const Tpt={toc:[]},Cpt="wrapper";function xpt(e){let{components:n,...t}=e;return(0,s.yg)(Cpt,(0,p.A)({},Tpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}xpt.isMDXComponent=!0;const Apt={toc:[]},vpt="wrapper";function Lpt(e){let{components:n,...t}=e;return(0,s.yg)(vpt,(0,p.A)({},Apt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Lpt.isMDXComponent=!0;const bpt={toc:[]},Npt="wrapper";function kpt(e){let{components:n,...t}=e;return(0,s.yg)(Npt,(0,p.A)({},bpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}kpt.isMDXComponent=!0;const zpt={toc:[]},Ppt="wrapper";function Ipt(e){let{components:n,...t}=e;return(0,s.yg)(Ppt,(0,p.A)({},zpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Ipt.isMDXComponent=!0;const Rpt={toc:[]},Wpt="wrapper";function Spt(e){let{components:n,...t}=e;return(0,s.yg)(Wpt,(0,p.A)({},Rpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Spt.isMDXComponent=!0;const Bpt={toc:[]},Gpt="wrapper";function Ept(e){let{components:n,...t}=e;return(0,s.yg)(Gpt,(0,p.A)({},Bpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Ept.isMDXComponent=!0;const Opt={toc:[]},Upt="wrapper";function Fpt(e){let{components:n,...t}=e;return(0,s.yg)(Upt,(0,p.A)({},Opt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fpt.isMDXComponent=!0;const Vpt={toc:[]},qpt="wrapper";function jpt(e){let{components:n,...t}=e;return(0,s.yg)(qpt,(0,p.A)({},Vpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}jpt.isMDXComponent=!0;const Hpt={toc:[]},Ypt="wrapper";function Qpt(e){let{components:n,...t}=e;return(0,s.yg)(Ypt,(0,p.A)({},Hpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Qpt.isMDXComponent=!0;const $pt={toc:[]},Kpt="wrapper";function Jpt(e){let{components:n,...t}=e;return(0,s.yg)(Kpt,(0,p.A)({},$pt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Jpt.isMDXComponent=!0;const Zpt={toc:[]},ert="wrapper";function nrt(e){let{components:n,...t}=e;return(0,s.yg)(ert,(0,p.A)({},Zpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}nrt.isMDXComponent=!0;const trt={toc:[]},ort="wrapper";function prt(e){let{components:n,...t}=e;return(0,s.yg)(ort,(0,p.A)({},trt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}prt.isMDXComponent=!0;const rrt={toc:[]},srt="wrapper";function crt(e){let{components:n,...t}=e;return(0,s.yg)(srt,(0,p.A)({},rrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}crt.isMDXComponent=!0;const art={toc:[]},irt="wrapper";function lrt(e){let{components:n,...t}=e;return(0,s.yg)(irt,(0,p.A)({},art,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}lrt.isMDXComponent=!0;const urt={toc:[]},mrt="wrapper";function yrt(e){let{components:n,...t}=e;return(0,s.yg)(mrt,(0,p.A)({},urt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}yrt.isMDXComponent=!0;const drt={toc:[]},hrt="wrapper";function grt(e){let{components:n,...t}=e;return(0,s.yg)(hrt,(0,p.A)({},drt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}grt.isMDXComponent=!0;const frt={toc:[]},Drt="wrapper";function Mrt(e){let{components:n,...t}=e;return(0,s.yg)(Drt,(0,p.A)({},frt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Mrt.isMDXComponent=!0;const Xrt={toc:[]},_rt="wrapper";function wrt(e){let{components:n,...t}=e;return(0,s.yg)(_rt,(0,p.A)({},Xrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}wrt.isMDXComponent=!0;const Trt={toc:[]},Crt="wrapper";function xrt(e){let{components:n,...t}=e;return(0,s.yg)(Crt,(0,p.A)({},Trt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}xrt.isMDXComponent=!0;const Art={toc:[]},vrt="wrapper";function Lrt(e){let{components:n,...t}=e;return(0,s.yg)(vrt,(0,p.A)({},Art,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Lrt.isMDXComponent=!0;const brt={toc:[]},Nrt="wrapper";function krt(e){let{components:n,...t}=e;return(0,s.yg)(Nrt,(0,p.A)({},brt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}krt.isMDXComponent=!0;const zrt={toc:[]},Prt="wrapper";function Irt(e){let{components:n,...t}=e;return(0,s.yg)(Prt,(0,p.A)({},zrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Irt.isMDXComponent=!0;const Rrt={toc:[]},Wrt="wrapper";function Srt(e){let{components:n,...t}=e;return(0,s.yg)(Wrt,(0,p.A)({},Rrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Srt.isMDXComponent=!0;const Brt={toc:[]},Grt="wrapper";function Ert(e){let{components:n,...t}=e;return(0,s.yg)(Grt,(0,p.A)({},Brt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Ert.isMDXComponent=!0;const Ort={toc:[]},Urt="wrapper";function Frt(e){let{components:n,...t}=e;return(0,s.yg)(Urt,(0,p.A)({},Ort,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Frt.isMDXComponent=!0;const Vrt={toc:[]},qrt="wrapper";function jrt(e){let{components:n,...t}=e;return(0,s.yg)(qrt,(0,p.A)({},Vrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}jrt.isMDXComponent=!0;const Hrt={toc:[]},Yrt="wrapper";function Qrt(e){let{components:n,...t}=e;return(0,s.yg)(Yrt,(0,p.A)({},Hrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Qrt.isMDXComponent=!0;const $rt={toc:[]},Krt="wrapper";function Jrt(e){let{components:n,...t}=e;return(0,s.yg)(Krt,(0,p.A)({},$rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Jrt.isMDXComponent=!0;const Zrt={toc:[]},est="wrapper";function nst(e){let{components:n,...t}=e;return(0,s.yg)(est,(0,p.A)({},Zrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}nst.isMDXComponent=!0;const tst={toc:[]},ost="wrapper";function pst(e){let{components:n,...t}=e;return(0,s.yg)(ost,(0,p.A)({},tst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pst.isMDXComponent=!0;const rst={toc:[]},sst="wrapper";function cst(e){let{components:n,...t}=e;return(0,s.yg)(sst,(0,p.A)({},rst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}cst.isMDXComponent=!0;const ast={toc:[]},ist="wrapper";function lst(e){let{components:n,...t}=e;return(0,s.yg)(ist,(0,p.A)({},ast,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}lst.isMDXComponent=!0;const ust={toc:[]},mst="wrapper";function yst(e){let{components:n,...t}=e;return(0,s.yg)(mst,(0,p.A)({},ust,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}yst.isMDXComponent=!0;const dst={toc:[]},hst="wrapper";function gst(e){let{components:n,...t}=e;return(0,s.yg)(hst,(0,p.A)({},dst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gst.isMDXComponent=!0;const fst={toc:[]},Dst="wrapper";function Mst(e){let{components:n,...t}=e;return(0,s.yg)(Dst,(0,p.A)({},fst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Mst.isMDXComponent=!0;const Xst={toc:[]},_st="wrapper";function wst(e){let{components:n,...t}=e;return(0,s.yg)(_st,(0,p.A)({},Xst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}wst.isMDXComponent=!0;const Tst={toc:[]},Cst="wrapper";function xst(e){let{components:n,...t}=e;return(0,s.yg)(Cst,(0,p.A)({},Tst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xst.isMDXComponent=!0;const Ast={toc:[]},vst="wrapper";function Lst(e){let{components:n,...t}=e;return(0,s.yg)(vst,(0,p.A)({},Ast,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Lst.isMDXComponent=!0;const bst={toc:[]},Nst="wrapper";function kst(e){let{components:n,...t}=e;return(0,s.yg)(Nst,(0,p.A)({},bst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kst.isMDXComponent=!0;const zst={toc:[]},Pst="wrapper";function Ist(e){let{components:n,...t}=e;return(0,s.yg)(Pst,(0,p.A)({},zst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Ist.isMDXComponent=!0;const Rst={toc:[]},Wst="wrapper";function Sst(e){let{components:n,...t}=e;return(0,s.yg)(Wst,(0,p.A)({},Rst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Sst.isMDXComponent=!0;const Bst={toc:[]},Gst="wrapper";function Est(e){let{components:n,...t}=e;return(0,s.yg)(Gst,(0,p.A)({},Bst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Est.isMDXComponent=!0;const Ost={toc:[]},Ust="wrapper";function Fst(e){let{components:n,...t}=e;return(0,s.yg)(Ust,(0,p.A)({},Ost,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Fst.isMDXComponent=!0;const Vst={toc:[]},qst="wrapper";function jst(e){let{components:n,...t}=e;return(0,s.yg)(qst,(0,p.A)({},Vst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}jst.isMDXComponent=!0;const Hst={toc:[]},Yst="wrapper";function Qst(e){let{components:n,...t}=e;return(0,s.yg)(Yst,(0,p.A)({},Hst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Qst.isMDXComponent=!0;const $st={toc:[]},Kst="wrapper";function Jst(e){let{components:n,...t}=e;return(0,s.yg)(Kst,(0,p.A)({},$st,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Jst.isMDXComponent=!0;const Zst={toc:[]},ect="wrapper";function nct(e){let{components:n,...t}=e;return(0,s.yg)(ect,(0,p.A)({},Zst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}nct.isMDXComponent=!0;const tct={toc:[]},oct="wrapper";function pct(e){let{components:n,...t}=e;return(0,s.yg)(oct,(0,p.A)({},tct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}pct.isMDXComponent=!0;const rct={toc:[]},sct="wrapper";function cct(e){let{components:n,...t}=e;return(0,s.yg)(sct,(0,p.A)({},rct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cct.isMDXComponent=!0;const act={toc:[]},ict="wrapper";function lct(e){let{components:n,...t}=e;return(0,s.yg)(ict,(0,p.A)({},act,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lct.isMDXComponent=!0;const uct={toc:[]},mct="wrapper";function yct(e){let{components:n,...t}=e;return(0,s.yg)(mct,(0,p.A)({},uct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}yct.isMDXComponent=!0;const dct={toc:[]},hct="wrapper";function gct(e){let{components:n,...t}=e;return(0,s.yg)(hct,(0,p.A)({},dct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gct.isMDXComponent=!0;const fct={toc:[]},Dct="wrapper";function Mct(e){let{components:n,...t}=e;return(0,s.yg)(Dct,(0,p.A)({},fct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Mct.isMDXComponent=!0;const Xct={toc:[]},_ct="wrapper";function wct(e){let{components:n,...t}=e;return(0,s.yg)(_ct,(0,p.A)({},Xct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wct.isMDXComponent=!0;const Tct={toc:[]},Cct="wrapper";function xct(e){let{components:n,...t}=e;return(0,s.yg)(Cct,(0,p.A)({},Tct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xct.isMDXComponent=!0;const Act={toc:[]},vct="wrapper";function Lct(e){let{components:n,...t}=e;return(0,s.yg)(vct,(0,p.A)({},Act,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Lct.isMDXComponent=!0;const bct={toc:[]},Nct="wrapper";function kct(e){let{components:n,...t}=e;return(0,s.yg)(Nct,(0,p.A)({},bct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kct.isMDXComponent=!0;const zct={toc:[]},Pct="wrapper";function Ict(e){let{components:n,...t}=e;return(0,s.yg)(Pct,(0,p.A)({},zct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Ict.isMDXComponent=!0;const Rct={toc:[]},Wct="wrapper";function Sct(e){let{components:n,...t}=e;return(0,s.yg)(Wct,(0,p.A)({},Rct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render any polygonal shape defined by a set of\npoints."))}Sct.isMDXComponent=!0;const Bct={toc:[]},Gct="wrapper";function Ect(e){let{components:n,...t}=e;return(0,s.yg)(Gct,(0,p.A)({},Bct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple line\nimport {makeScene2D, Line} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [150, 50],\n        [0, -50],\n        [-150, 50],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={40}\n      startArrow\n    />,\n  );\n});\n\n// snippet Polygon\nimport {makeScene2D, Line} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [-200, 70],\n        [150, 70],\n        [100, -70],\n        [-100, -70],\n      ]}\n      fill={'lightseagreen'}\n      closed\n    />,\n  );\n});\n\n// snippet Using signals\nimport {makeScene2D, Line} from '@revideo/2d';\nimport {createSignal} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const tip = createSignal(-150);\n  view.add(\n    <Line\n      points={[\n        [-150, 70],\n        [150, 70],\n        // this point is dynamically calculated based on the signal:\n        () => [tip(), -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      closed\n    />,\n  );\n\n  yield* tip(150, 1).back(1);\n});\n\n// snippet Tweening points\nimport {makeScene2D, Line} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const line = createRef<Line>();\n  view.add(\n    <Line\n      ref={line}\n      points={[\n        [-150, 70],\n        [150, 70],\n        [0, -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={20}\n      closed\n    />,\n  );\n\n  yield* line()\n    .points(\n      [\n        [-150, 0],\n        [0, 100],\n        [150, 0],\n        [150, -70],\n        [-150, -70],\n      ],\n      2,\n    )\n    .back(2);\n});\n")))}Ect.isMDXComponent=!0;const Oct={toc:[]},Uct="wrapper";function Fct(e){let{components:n,...t}=e;return(0,s.yg)(Uct,(0,p.A)({},Oct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing lines and polygons."))}Fct.isMDXComponent=!0;const Vct={toc:[]},qct="wrapper";function jct(e){let{components:n,...t}=e;return(0,s.yg)(qct,(0,p.A)({},Vct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}jct.isMDXComponent=!0;const Hct={toc:[]},Yct="wrapper";function Qct(e){let{components:n,...t}=e;return(0,s.yg)(Yct,(0,p.A)({},Hct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Qct.isMDXComponent=!0;const $ct={toc:[]},Kct="wrapper";function Jct(e){let{components:n,...t}=e;return(0,s.yg)(Kct,(0,p.A)({},$ct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Jct.isMDXComponent=!0;const Zct={toc:[]},eat="wrapper";function nat(e){let{components:n,...t}=e;return(0,s.yg)(eat,(0,p.A)({},Zct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}nat.isMDXComponent=!0;const tat={toc:[]},oat="wrapper";function pat(e){let{components:n,...t}=e;return(0,s.yg)(oat,(0,p.A)({},tat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}pat.isMDXComponent=!0;const rat={toc:[]},sat="wrapper";function cat(e){let{components:n,...t}=e;return(0,s.yg)(sat,(0,p.A)({},rat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}cat.isMDXComponent=!0;const aat={toc:[]},iat="wrapper";function lat(e){let{components:n,...t}=e;return(0,s.yg)(iat,(0,p.A)({},aat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}lat.isMDXComponent=!0;const uat={toc:[]},mat="wrapper";function yat(e){let{components:n,...t}=e;return(0,s.yg)(mat,(0,p.A)({},uat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}yat.isMDXComponent=!0;const dat={toc:[]},hat="wrapper";function gat(e){let{components:n,...t}=e;return(0,s.yg)(hat,(0,p.A)({},dat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}gat.isMDXComponent=!0;const fat={toc:[]},Dat="wrapper";function Mat(e){let{components:n,...t}=e;return(0,s.yg)(Dat,(0,p.A)({},fat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Mat.isMDXComponent=!0;const Xat={toc:[]},_at="wrapper";function wat(e){let{components:n,...t}=e;return(0,s.yg)(_at,(0,p.A)({},Xat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wat.isMDXComponent=!0;const Tat={toc:[]},Cat="wrapper";function xat(e){let{components:n,...t}=e;return(0,s.yg)(Cat,(0,p.A)({},Tat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}xat.isMDXComponent=!0;const Aat={toc:[]},vat="wrapper";function Lat(e){let{components:n,...t}=e;return(0,s.yg)(vat,(0,p.A)({},Aat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Lat.isMDXComponent=!0;const bat={toc:[]},Nat="wrapper";function kat(e){let{components:n,...t}=e;return(0,s.yg)(Nat,(0,p.A)({},bat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}kat.isMDXComponent=!0;const zat={toc:[]},Pat="wrapper";function Iat(e){let{components:n,...t}=e;return(0,s.yg)(Pat,(0,p.A)({},zat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Iat.isMDXComponent=!0;const Rat={toc:[]},Wat="wrapper";function Sat(e){let{components:n,...t}=e;return(0,s.yg)(Wat,(0,p.A)({},Rat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Sat.isMDXComponent=!0;const Bat={toc:[]},Gat="wrapper";function Eat(e){let{components:n,...t}=e;return(0,s.yg)(Gat,(0,p.A)({},Bat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Eat.isMDXComponent=!0;const Oat={toc:[]},Uat="wrapper";function Fat(e){let{components:n,...t}=e;return(0,s.yg)(Uat,(0,p.A)({},Oat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Fat.isMDXComponent=!0;const Vat={toc:[]},qat="wrapper";function jat(e){let{components:n,...t}=e;return(0,s.yg)(qat,(0,p.A)({},Vat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}jat.isMDXComponent=!0;const Hat={toc:[]},Yat="wrapper";function Qat(e){let{components:n,...t}=e;return(0,s.yg)(Yat,(0,p.A)({},Hat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Qat.isMDXComponent=!0;const $at={toc:[]},Kat="wrapper";function Jat(e){let{components:n,...t}=e;return(0,s.yg)(Kat,(0,p.A)({},$at,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Jat.isMDXComponent=!0;const Zat={toc:[]},eit="wrapper";function nit(e){let{components:n,...t}=e;return(0,s.yg)(eit,(0,p.A)({},Zat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}nit.isMDXComponent=!0;const tit={toc:[]},oit="wrapper";function pit(e){let{components:n,...t}=e;return(0,s.yg)(oit,(0,p.A)({},tit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pit.isMDXComponent=!0;const rit={toc:[]},sit="wrapper";function cit(e){let{components:n,...t}=e;return(0,s.yg)(sit,(0,p.A)({},rit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}cit.isMDXComponent=!0;const ait={toc:[]},iit="wrapper";function lit(e){let{components:n,...t}=e;return(0,s.yg)(iit,(0,p.A)({},ait,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lit.isMDXComponent=!0;const uit={toc:[]},mit="wrapper";function yit(e){let{components:n,...t}=e;return(0,s.yg)(mit,(0,p.A)({},uit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}yit.isMDXComponent=!0;const dit={toc:[]},hit="wrapper";function git(e){let{components:n,...t}=e;return(0,s.yg)(hit,(0,p.A)({},dit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}git.isMDXComponent=!0;const fit={toc:[]},Dit="wrapper";function Mit(e){let{components:n,...t}=e;return(0,s.yg)(Dit,(0,p.A)({},fit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Mit.isMDXComponent=!0;const Xit={toc:[]},_it="wrapper";function wit(e){let{components:n,...t}=e;return(0,s.yg)(_it,(0,p.A)({},Xit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wit.isMDXComponent=!0;const Tit={toc:[]},Cit="wrapper";function xit(e){let{components:n,...t}=e;return(0,s.yg)(Cit,(0,p.A)({},Tit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}xit.isMDXComponent=!0;const Ait={toc:[]},vit="wrapper";function Lit(e){let{components:n,...t}=e;return(0,s.yg)(vit,(0,p.A)({},Ait,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Lit.isMDXComponent=!0;const bit={toc:[]},Nit="wrapper";function kit(e){let{components:n,...t}=e;return(0,s.yg)(Nit,(0,p.A)({},bit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}kit.isMDXComponent=!0;const zit={toc:[]},Pit="wrapper";function Iit(e){let{components:n,...t}=e;return(0,s.yg)(Pit,(0,p.A)({},zit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}Iit.isMDXComponent=!0;const Rit={toc:[]},Wit="wrapper";function Sit(e){let{components:n,...t}=e;return(0,s.yg)(Wit,(0,p.A)({},Rit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The points of the line."))}Sit.isMDXComponent=!0;const Bit={toc:[]},Git="wrapper";function Eit(e){let{components:n,...t}=e;return(0,s.yg)(Git,(0,p.A)({},Bit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Eit.isMDXComponent=!0;const Oit={toc:[]},Uit="wrapper";function Fit(e){let{components:n,...t}=e;return(0,s.yg)(Uit,(0,p.A)({},Oit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Fit.isMDXComponent=!0;const Vit={toc:[]},qit="wrapper";function jit(e){let{components:n,...t}=e;return(0,s.yg)(qit,(0,p.A)({},Vit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the line's corners."))}jit.isMDXComponent=!0;const Hit={toc:[]},Yit="wrapper";function Qit(e){let{components:n,...t}=e;return(0,s.yg)(Yit,(0,p.A)({},Hit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Qit.isMDXComponent=!0;const $it={toc:[]},Kit="wrapper";function Jit(e){let{components:n,...t}=e;return(0,s.yg)(Kit,(0,p.A)({},$it,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Jit.isMDXComponent=!0;const Zit={toc:[]},elt="wrapper";function nlt(e){let{components:n,...t}=e;return(0,s.yg)(elt,(0,p.A)({},Zit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nlt.isMDXComponent=!0;const tlt={toc:[]},olt="wrapper";function plt(e){let{components:n,...t}=e;return(0,s.yg)(olt,(0,p.A)({},tlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}plt.isMDXComponent=!0;const rlt={toc:[]},slt="wrapper";function clt(e){let{components:n,...t}=e;return(0,s.yg)(slt,(0,p.A)({},rlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}clt.isMDXComponent=!0;const alt={toc:[]},ilt="wrapper";function llt(e){let{components:n,...t}=e;return(0,s.yg)(ilt,(0,p.A)({},alt,t,{components:n,mdxType:"MDXLayout"}))}llt.isMDXComponent=!0;const ult={toc:[]},mlt="wrapper";function ylt(e){let{components:n,...t}=e;return(0,s.yg)(mlt,(0,p.A)({},ult,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ylt.isMDXComponent=!0;const dlt={toc:[]},hlt="wrapper";function glt(e){let{components:n,...t}=e;return(0,s.yg)(hlt,(0,p.A)({},dlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}glt.isMDXComponent=!0;const flt={toc:[]},Dlt="wrapper";function Mlt(e){let{components:n,...t}=e;return(0,s.yg)(Dlt,(0,p.A)({},flt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Mlt.isMDXComponent=!0;const Xlt={toc:[]},_lt="wrapper";function wlt(e){let{components:n,...t}=e;return(0,s.yg)(_lt,(0,p.A)({},Xlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}wlt.isMDXComponent=!0;const Tlt={toc:[]},Clt="wrapper";function xlt(e){let{components:n,...t}=e;return(0,s.yg)(Clt,(0,p.A)({},Tlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}xlt.isMDXComponent=!0;const Alt={toc:[]},vlt="wrapper";function Llt(e){let{components:n,...t}=e;return(0,s.yg)(vlt,(0,p.A)({},Alt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Llt.isMDXComponent=!0;const blt={toc:[]},Nlt="wrapper";function klt(e){let{components:n,...t}=e;return(0,s.yg)(Nlt,(0,p.A)({},blt,t,{components:n,mdxType:"MDXLayout"}))}klt.isMDXComponent=!0;const zlt={toc:[]},Plt="wrapper";function Ilt(e){let{components:n,...t}=e;return(0,s.yg)(Plt,(0,p.A)({},zlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ilt.isMDXComponent=!0;const Rlt={toc:[]},Wlt="wrapper";function Slt(e){let{components:n,...t}=e;return(0,s.yg)(Wlt,(0,p.A)({},Rlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Slt.isMDXComponent=!0;const Blt={toc:[]},Glt="wrapper";function Elt(e){let{components:n,...t}=e;return(0,s.yg)(Glt,(0,p.A)({},Blt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Elt.isMDXComponent=!0;const Olt={toc:[]},Ult="wrapper";function Flt(e){let{components:n,...t}=e;return(0,s.yg)(Ult,(0,p.A)({},Olt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Flt.isMDXComponent=!0;const Vlt={toc:[]},qlt="wrapper";function jlt(e){let{components:n,...t}=e;return(0,s.yg)(qlt,(0,p.A)({},Vlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jlt.isMDXComponent=!0;const Hlt={toc:[]},Ylt="wrapper";function Qlt(e){let{components:n,...t}=e;return(0,s.yg)(Ylt,(0,p.A)({},Hlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Qlt.isMDXComponent=!0;const $lt={toc:[]},Klt="wrapper";function Jlt(e){let{components:n,...t}=e;return(0,s.yg)(Klt,(0,p.A)({},$lt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Jlt.isMDXComponent=!0;const Zlt={toc:[]},eut="wrapper";function nut(e){let{components:n,...t}=e;return(0,s.yg)(eut,(0,p.A)({},Zlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}nut.isMDXComponent=!0;const tut={toc:[]},out="wrapper";function put(e){let{components:n,...t}=e;return(0,s.yg)(out,(0,p.A)({},tut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}put.isMDXComponent=!0;const rut={toc:[]},sut="wrapper";function cut(e){let{components:n,...t}=e;return(0,s.yg)(sut,(0,p.A)({},rut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}cut.isMDXComponent=!0;const aut={toc:[]},iut="wrapper";function lut(e){let{components:n,...t}=e;return(0,s.yg)(iut,(0,p.A)({},aut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}lut.isMDXComponent=!0;const uut={toc:[]},mut="wrapper";function yut(e){let{components:n,...t}=e;return(0,s.yg)(mut,(0,p.A)({},uut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}yut.isMDXComponent=!0;const dut={toc:[]},hut="wrapper";function gut(e){let{components:n,...t}=e;return(0,s.yg)(hut,(0,p.A)({},dut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}gut.isMDXComponent=!0;const fut={toc:[]},Dut="wrapper";function Mut(e){let{components:n,...t}=e;return(0,s.yg)(Dut,(0,p.A)({},fut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Mut.isMDXComponent=!0;const Xut={toc:[]},_ut="wrapper";function wut(e){let{components:n,...t}=e;return(0,s.yg)(_ut,(0,p.A)({},Xut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}wut.isMDXComponent=!0;const Tut={toc:[]},Cut="wrapper";function xut(e){let{components:n,...t}=e;return(0,s.yg)(Cut,(0,p.A)({},Tut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}xut.isMDXComponent=!0;const Aut={toc:[]},vut="wrapper";function Lut(e){let{components:n,...t}=e;return(0,s.yg)(vut,(0,p.A)({},Aut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lut.isMDXComponent=!0;const but={toc:[]},Nut="wrapper";function kut(e){let{components:n,...t}=e;return(0,s.yg)(Nut,(0,p.A)({},but,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}kut.isMDXComponent=!0;const zut={toc:[]},Put="wrapper";function Iut(e){let{components:n,...t}=e;return(0,s.yg)(Put,(0,p.A)({},zut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Iut.isMDXComponent=!0;const Rut={toc:[]},Wut="wrapper";function Sut(e){let{components:n,...t}=e;return(0,s.yg)(Wut,(0,p.A)({},Rut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Sut.isMDXComponent=!0;const But={toc:[]},Gut="wrapper";function Eut(e){let{components:n,...t}=e;return(0,s.yg)(Gut,(0,p.A)({},But,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Eut.isMDXComponent=!0;const Out={toc:[]},Uut="wrapper";function Fut(e){let{components:n,...t}=e;return(0,s.yg)(Uut,(0,p.A)({},Out,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Fut.isMDXComponent=!0;const Vut={toc:[]},qut="wrapper";function jut(e){let{components:n,...t}=e;return(0,s.yg)(qut,(0,p.A)({},Vut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}jut.isMDXComponent=!0;const Hut={toc:[]},Yut="wrapper";function Qut(e){let{components:n,...t}=e;return(0,s.yg)(Yut,(0,p.A)({},Hut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Qut.isMDXComponent=!0;const $ut={toc:[]},Kut="wrapper";function Jut(e){let{components:n,...t}=e;return(0,s.yg)(Kut,(0,p.A)({},$ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Jut.isMDXComponent=!0;const Zut={toc:[]},emt="wrapper";function nmt(e){let{components:n,...t}=e;return(0,s.yg)(emt,(0,p.A)({},Zut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}nmt.isMDXComponent=!0;const tmt={toc:[]},omt="wrapper";function pmt(e){let{components:n,...t}=e;return(0,s.yg)(omt,(0,p.A)({},tmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}pmt.isMDXComponent=!0;const rmt={toc:[]},smt="wrapper";function cmt(e){let{components:n,...t}=e;return(0,s.yg)(smt,(0,p.A)({},rmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cmt.isMDXComponent=!0;const amt={toc:[]},imt="wrapper";function lmt(e){let{components:n,...t}=e;return(0,s.yg)(imt,(0,p.A)({},amt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}lmt.isMDXComponent=!0;const umt={toc:[]},mmt="wrapper";function ymt(e){let{components:n,...t}=e;return(0,s.yg)(mmt,(0,p.A)({},umt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}ymt.isMDXComponent=!0;const dmt={toc:[]},hmt="wrapper";function gmt(e){let{components:n,...t}=e;return(0,s.yg)(hmt,(0,p.A)({},dmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}gmt.isMDXComponent=!0;const fmt={toc:[]},Dmt="wrapper";function Mmt(e){let{components:n,...t}=e;return(0,s.yg)(Dmt,(0,p.A)({},fmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Mmt.isMDXComponent=!0;const Xmt={toc:[]},_mt="wrapper";function wmt(e){let{components:n,...t}=e;return(0,s.yg)(_mt,(0,p.A)({},Xmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}wmt.isMDXComponent=!0;const Tmt={toc:[]},Cmt="wrapper";function xmt(e){let{components:n,...t}=e;return(0,s.yg)(Cmt,(0,p.A)({},Tmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}xmt.isMDXComponent=!0;const Amt={toc:[]},vmt="wrapper";function Lmt(e){let{components:n,...t}=e;return(0,s.yg)(vmt,(0,p.A)({},Amt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Lmt.isMDXComponent=!0;const bmt={toc:[]},Nmt="wrapper";function kmt(e){let{components:n,...t}=e;return(0,s.yg)(Nmt,(0,p.A)({},bmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}kmt.isMDXComponent=!0;const zmt={toc:[]},Pmt="wrapper";function Imt(e){let{components:n,...t}=e;return(0,s.yg)(Pmt,(0,p.A)({},zmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Imt.isMDXComponent=!0;const Rmt={toc:[]},Wmt="wrapper";function Smt(e){let{components:n,...t}=e;return(0,s.yg)(Wmt,(0,p.A)({},Rmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Smt.isMDXComponent=!0;const Bmt={toc:[]},Gmt="wrapper";function Emt(e){let{components:n,...t}=e;return(0,s.yg)(Gmt,(0,p.A)({},Bmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Emt.isMDXComponent=!0;const Omt={toc:[]},Umt="wrapper";function Fmt(e){let{components:n,...t}=e;return(0,s.yg)(Umt,(0,p.A)({},Omt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Fmt.isMDXComponent=!0;const Vmt={toc:[]},qmt="wrapper";function jmt(e){let{components:n,...t}=e;return(0,s.yg)(qmt,(0,p.A)({},Vmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jmt.isMDXComponent=!0;const Hmt={toc:[]},Ymt="wrapper";function Qmt(e){let{components:n,...t}=e;return(0,s.yg)(Ymt,(0,p.A)({},Hmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Qmt.isMDXComponent=!0;const $mt={toc:[]},Kmt="wrapper";function Jmt(e){let{components:n,...t}=e;return(0,s.yg)(Kmt,(0,p.A)({},$mt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Jmt.isMDXComponent=!0;const Zmt={toc:[]},eyt="wrapper";function nyt(e){let{components:n,...t}=e;return(0,s.yg)(eyt,(0,p.A)({},Zmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}nyt.isMDXComponent=!0;const tyt={toc:[]},oyt="wrapper";function pyt(e){let{components:n,...t}=e;return(0,s.yg)(oyt,(0,p.A)({},tyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}pyt.isMDXComponent=!0;const ryt={toc:[]},syt="wrapper";function cyt(e){let{components:n,...t}=e;return(0,s.yg)(syt,(0,p.A)({},ryt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cyt.isMDXComponent=!0;const ayt={toc:[]},iyt="wrapper";function lyt(e){let{components:n,...t}=e;return(0,s.yg)(iyt,(0,p.A)({},ayt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}lyt.isMDXComponent=!0;const uyt={toc:[]},myt="wrapper";function yyt(e){let{components:n,...t}=e;return(0,s.yg)(myt,(0,p.A)({},uyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}yyt.isMDXComponent=!0;const dyt={toc:[]},hyt="wrapper";function gyt(e){let{components:n,...t}=e;return(0,s.yg)(hyt,(0,p.A)({},dyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}gyt.isMDXComponent=!0;const fyt={toc:[]},Dyt="wrapper";function Myt(e){let{components:n,...t}=e;return(0,s.yg)(Dyt,(0,p.A)({},fyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Myt.isMDXComponent=!0;const Xyt={toc:[]},_yt="wrapper";function wyt(e){let{components:n,...t}=e;return(0,s.yg)(_yt,(0,p.A)({},Xyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wyt.isMDXComponent=!0;const Tyt={toc:[]},Cyt="wrapper";function xyt(e){let{components:n,...t}=e;return(0,s.yg)(Cyt,(0,p.A)({},Tyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}xyt.isMDXComponent=!0;const Ayt={toc:[]},vyt="wrapper";function Lyt(e){let{components:n,...t}=e;return(0,s.yg)(vyt,(0,p.A)({},Ayt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Lyt.isMDXComponent=!0;const byt={toc:[]},Nyt="wrapper";function kyt(e){let{components:n,...t}=e;return(0,s.yg)(Nyt,(0,p.A)({},byt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kyt.isMDXComponent=!0;const zyt={toc:[]},Pyt="wrapper";function Iyt(e){let{components:n,...t}=e;return(0,s.yg)(Pyt,(0,p.A)({},zyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Iyt.isMDXComponent=!0;const Ryt={toc:[]},Wyt="wrapper";function Syt(e){let{components:n,...t}=e;return(0,s.yg)(Wyt,(0,p.A)({},Ryt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Syt.isMDXComponent=!0;const Byt={toc:[]},Gyt="wrapper";function Eyt(e){let{components:n,...t}=e;return(0,s.yg)(Gyt,(0,p.A)({},Byt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Eyt.isMDXComponent=!0;const Oyt={toc:[]},Uyt="wrapper";function Fyt(e){let{components:n,...t}=e;return(0,s.yg)(Uyt,(0,p.A)({},Oyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fyt.isMDXComponent=!0;const Vyt={toc:[]},qyt="wrapper";function jyt(e){let{components:n,...t}=e;return(0,s.yg)(qyt,(0,p.A)({},Vyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}jyt.isMDXComponent=!0;const Hyt={toc:[]},Yyt="wrapper";function Qyt(e){let{components:n,...t}=e;return(0,s.yg)(Yyt,(0,p.A)({},Hyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qyt.isMDXComponent=!0;const $yt={toc:[]},Kyt="wrapper";function Jyt(e){let{components:n,...t}=e;return(0,s.yg)(Kyt,(0,p.A)({},$yt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Jyt.isMDXComponent=!0;const Zyt={toc:[]},edt="wrapper";function ndt(e){let{components:n,...t}=e;return(0,s.yg)(edt,(0,p.A)({},Zyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ndt.isMDXComponent=!0;const tdt={toc:[]},odt="wrapper";function pdt(e){let{components:n,...t}=e;return(0,s.yg)(odt,(0,p.A)({},tdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}pdt.isMDXComponent=!0;const rdt={toc:[]},sdt="wrapper";function cdt(e){let{components:n,...t}=e;return(0,s.yg)(sdt,(0,p.A)({},rdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cdt.isMDXComponent=!0;const adt={toc:[]},idt="wrapper";function ldt(e){let{components:n,...t}=e;return(0,s.yg)(idt,(0,p.A)({},adt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}ldt.isMDXComponent=!0;const udt={toc:[]},mdt="wrapper";function ydt(e){let{components:n,...t}=e;return(0,s.yg)(mdt,(0,p.A)({},udt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ydt.isMDXComponent=!0;const ddt={toc:[]},hdt="wrapper";function gdt(e){let{components:n,...t}=e;return(0,s.yg)(hdt,(0,p.A)({},ddt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}gdt.isMDXComponent=!0;const fdt={toc:[]},Ddt="wrapper";function Mdt(e){let{components:n,...t}=e;return(0,s.yg)(Ddt,(0,p.A)({},fdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mdt.isMDXComponent=!0;const Xdt={toc:[]},_dt="wrapper";function wdt(e){let{components:n,...t}=e;return(0,s.yg)(_dt,(0,p.A)({},Xdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}wdt.isMDXComponent=!0;const Tdt={toc:[]},Cdt="wrapper";function xdt(e){let{components:n,...t}=e;return(0,s.yg)(Cdt,(0,p.A)({},Tdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}xdt.isMDXComponent=!0;const Adt={toc:[]},vdt="wrapper";function Ldt(e){let{components:n,...t}=e;return(0,s.yg)(vdt,(0,p.A)({},Adt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Ldt.isMDXComponent=!0;const bdt={toc:[]},Ndt="wrapper";function kdt(e){let{components:n,...t}=e;return(0,s.yg)(Ndt,(0,p.A)({},bdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}kdt.isMDXComponent=!0;const zdt={toc:[]},Pdt="wrapper";function Idt(e){let{components:n,...t}=e;return(0,s.yg)(Pdt,(0,p.A)({},zdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Idt.isMDXComponent=!0;const Rdt={toc:[]},Wdt="wrapper";function Sdt(e){let{components:n,...t}=e;return(0,s.yg)(Wdt,(0,p.A)({},Rdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Sdt.isMDXComponent=!0;const Bdt={toc:[]},Gdt="wrapper";function Edt(e){let{components:n,...t}=e;return(0,s.yg)(Gdt,(0,p.A)({},Bdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Edt.isMDXComponent=!0;const Odt={toc:[]},Udt="wrapper";function Fdt(e){let{components:n,...t}=e;return(0,s.yg)(Udt,(0,p.A)({},Odt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Fdt.isMDXComponent=!0;const Vdt={toc:[]},qdt="wrapper";function jdt(e){let{components:n,...t}=e;return(0,s.yg)(qdt,(0,p.A)({},Vdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jdt.isMDXComponent=!0;const Hdt={toc:[]},Ydt="wrapper";function Qdt(e){let{components:n,...t}=e;return(0,s.yg)(Ydt,(0,p.A)({},Hdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Qdt.isMDXComponent=!0;const $dt={toc:[]},Kdt="wrapper";function Jdt(e){let{components:n,...t}=e;return(0,s.yg)(Kdt,(0,p.A)({},$dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Jdt.isMDXComponent=!0;const Zdt={toc:[]},eht="wrapper";function nht(e){let{components:n,...t}=e;return(0,s.yg)(eht,(0,p.A)({},Zdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}nht.isMDXComponent=!0;const tht={toc:[]},oht="wrapper";function pht(e){let{components:n,...t}=e;return(0,s.yg)(oht,(0,p.A)({},tht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}pht.isMDXComponent=!0;const rht={toc:[]},sht="wrapper";function cht(e){let{components:n,...t}=e;return(0,s.yg)(sht,(0,p.A)({},rht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}cht.isMDXComponent=!0;const aht={toc:[]},iht="wrapper";function lht(e){let{components:n,...t}=e;return(0,s.yg)(iht,(0,p.A)({},aht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lht.isMDXComponent=!0;const uht={toc:[]},mht="wrapper";function yht(e){let{components:n,...t}=e;return(0,s.yg)(mht,(0,p.A)({},uht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}yht.isMDXComponent=!0;const dht={toc:[]},hht="wrapper";function ght(e){let{components:n,...t}=e;return(0,s.yg)(hht,(0,p.A)({},dht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}ght.isMDXComponent=!0;const fht={toc:[]},Dht="wrapper";function Mht(e){let{components:n,...t}=e;return(0,s.yg)(Dht,(0,p.A)({},fht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Mht.isMDXComponent=!0;const Xht={toc:[]},_ht="wrapper";function wht(e){let{components:n,...t}=e;return(0,s.yg)(_ht,(0,p.A)({},Xht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wht.isMDXComponent=!0;const Tht={toc:[]},Cht="wrapper";function xht(e){let{components:n,...t}=e;return(0,s.yg)(Cht,(0,p.A)({},Tht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}xht.isMDXComponent=!0;const Aht={toc:[]},vht="wrapper";function Lht(e){let{components:n,...t}=e;return(0,s.yg)(vht,(0,p.A)({},Aht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Lht.isMDXComponent=!0;const bht={toc:[]},Nht="wrapper";function kht(e){let{components:n,...t}=e;return(0,s.yg)(Nht,(0,p.A)({},bht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kht.isMDXComponent=!0;const zht={toc:[]},Pht="wrapper";function Iht(e){let{components:n,...t}=e;return(0,s.yg)(Pht,(0,p.A)({},zht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Iht.isMDXComponent=!0;const Rht={toc:[]},Wht="wrapper";function Sht(e){let{components:n,...t}=e;return(0,s.yg)(Wht,(0,p.A)({},Rht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Sht.isMDXComponent=!0;const Bht={toc:[]},Ght="wrapper";function Eht(e){let{components:n,...t}=e;return(0,s.yg)(Ght,(0,p.A)({},Bht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Eht.isMDXComponent=!0;const Oht={toc:[]},Uht="wrapper";function Fht(e){let{components:n,...t}=e;return(0,s.yg)(Uht,(0,p.A)({},Oht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Fht.isMDXComponent=!0;const Vht={toc:[]},qht="wrapper";function jht(e){let{components:n,...t}=e;return(0,s.yg)(qht,(0,p.A)({},Vht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}jht.isMDXComponent=!0;const Hht={toc:[]},Yht="wrapper";function Qht(e){let{components:n,...t}=e;return(0,s.yg)(Yht,(0,p.A)({},Hht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Qht.isMDXComponent=!0;const $ht={toc:[]},Kht="wrapper";function Jht(e){let{components:n,...t}=e;return(0,s.yg)(Kht,(0,p.A)({},$ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Jht.isMDXComponent=!0;const Zht={toc:[]},egt="wrapper";function ngt(e){let{components:n,...t}=e;return(0,s.yg)(egt,(0,p.A)({},Zht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}ngt.isMDXComponent=!0;const tgt={toc:[]},ogt="wrapper";function pgt(e){let{components:n,...t}=e;return(0,s.yg)(ogt,(0,p.A)({},tgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}pgt.isMDXComponent=!0;const rgt={toc:[]},sgt="wrapper";function cgt(e){let{components:n,...t}=e;return(0,s.yg)(sgt,(0,p.A)({},rgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cgt.isMDXComponent=!0;const agt={toc:[]},igt="wrapper";function lgt(e){let{components:n,...t}=e;return(0,s.yg)(igt,(0,p.A)({},agt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lgt.isMDXComponent=!0;const ugt={toc:[]},mgt="wrapper";function ygt(e){let{components:n,...t}=e;return(0,s.yg)(mgt,(0,p.A)({},ugt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}ygt.isMDXComponent=!0;const dgt={toc:[]},hgt="wrapper";function ggt(e){let{components:n,...t}=e;return(0,s.yg)(hgt,(0,p.A)({},dgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ggt.isMDXComponent=!0;const fgt={toc:[]},Dgt="wrapper";function Mgt(e){let{components:n,...t}=e;return(0,s.yg)(Dgt,(0,p.A)({},fgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Mgt.isMDXComponent=!0;const Xgt={toc:[]},_gt="wrapper";function wgt(e){let{components:n,...t}=e;return(0,s.yg)(_gt,(0,p.A)({},Xgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wgt.isMDXComponent=!0;const Tgt={toc:[]},Cgt="wrapper";function xgt(e){let{components:n,...t}=e;return(0,s.yg)(Cgt,(0,p.A)({},Tgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}xgt.isMDXComponent=!0;const Agt={toc:[]},vgt="wrapper";function Lgt(e){let{components:n,...t}=e;return(0,s.yg)(vgt,(0,p.A)({},Agt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Lgt.isMDXComponent=!0;const bgt={toc:[]},Ngt="wrapper";function kgt(e){let{components:n,...t}=e;return(0,s.yg)(Ngt,(0,p.A)({},bgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}kgt.isMDXComponent=!0;const zgt={toc:[]},Pgt="wrapper";function Igt(e){let{components:n,...t}=e;return(0,s.yg)(Pgt,(0,p.A)({},zgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Igt.isMDXComponent=!0;const Rgt={toc:[]},Wgt="wrapper";function Sgt(e){let{components:n,...t}=e;return(0,s.yg)(Wgt,(0,p.A)({},Rgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Sgt.isMDXComponent=!0;const Bgt={toc:[]},Ggt="wrapper";function Egt(e){let{components:n,...t}=e;return(0,s.yg)(Ggt,(0,p.A)({},Bgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Egt.isMDXComponent=!0;const Ogt={toc:[]},Ugt="wrapper";function Fgt(e){let{components:n,...t}=e;return(0,s.yg)(Ugt,(0,p.A)({},Ogt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Fgt.isMDXComponent=!0;const Vgt={toc:[]},qgt="wrapper";function jgt(e){let{components:n,...t}=e;return(0,s.yg)(qgt,(0,p.A)({},Vgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}jgt.isMDXComponent=!0;const Hgt={toc:[]},Ygt="wrapper";function Qgt(e){let{components:n,...t}=e;return(0,s.yg)(Ygt,(0,p.A)({},Hgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Qgt.isMDXComponent=!0;const $gt={toc:[]},Kgt="wrapper";function Jgt(e){let{components:n,...t}=e;return(0,s.yg)(Kgt,(0,p.A)({},$gt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Jgt.isMDXComponent=!0;const Zgt={toc:[]},eft="wrapper";function nft(e){let{components:n,...t}=e;return(0,s.yg)(eft,(0,p.A)({},Zgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}nft.isMDXComponent=!0;const tft={toc:[]},oft="wrapper";function pft(e){let{components:n,...t}=e;return(0,s.yg)(oft,(0,p.A)({},tft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}pft.isMDXComponent=!0;const rft={toc:[]},sft="wrapper";function cft(e){let{components:n,...t}=e;return(0,s.yg)(sft,(0,p.A)({},rft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}cft.isMDXComponent=!0;const aft={toc:[]},ift="wrapper";function lft(e){let{components:n,...t}=e;return(0,s.yg)(ift,(0,p.A)({},aft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}lft.isMDXComponent=!0;const uft={toc:[]},mft="wrapper";function yft(e){let{components:n,...t}=e;return(0,s.yg)(mft,(0,p.A)({},uft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}yft.isMDXComponent=!0;const dft={toc:[]},hft="wrapper";function gft(e){let{components:n,...t}=e;return(0,s.yg)(hft,(0,p.A)({},dft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}gft.isMDXComponent=!0;const fft={toc:[]},Dft="wrapper";function Mft(e){let{components:n,...t}=e;return(0,s.yg)(Dft,(0,p.A)({},fft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Mft.isMDXComponent=!0;const Xft={toc:[]},_ft="wrapper";function wft(e){let{components:n,...t}=e;return(0,s.yg)(_ft,(0,p.A)({},Xft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}wft.isMDXComponent=!0;const Tft={toc:[]},Cft="wrapper";function xft(e){let{components:n,...t}=e;return(0,s.yg)(Cft,(0,p.A)({},Tft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xft.isMDXComponent=!0;const Aft={toc:[]},vft="wrapper";function Lft(e){let{components:n,...t}=e;return(0,s.yg)(vft,(0,p.A)({},Aft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Lft.isMDXComponent=!0;const bft={toc:[]},Nft="wrapper";function kft(e){let{components:n,...t}=e;return(0,s.yg)(Nft,(0,p.A)({},bft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}kft.isMDXComponent=!0;const zft={toc:[]},Pft="wrapper";function Ift(e){let{components:n,...t}=e;return(0,s.yg)(Pft,(0,p.A)({},zft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Ift.isMDXComponent=!0;const Rft={toc:[]},Wft="wrapper";function Sft(e){let{components:n,...t}=e;return(0,s.yg)(Wft,(0,p.A)({},Rft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Sft.isMDXComponent=!0;const Bft={toc:[]},Gft="wrapper";function Eft(e){let{components:n,...t}=e;return(0,s.yg)(Gft,(0,p.A)({},Bft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Eft.isMDXComponent=!0;const Oft={toc:[]},Uft="wrapper";function Fft(e){let{components:n,...t}=e;return(0,s.yg)(Uft,(0,p.A)({},Oft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Fft.isMDXComponent=!0;const Vft={toc:[]},qft="wrapper";function jft(e){let{components:n,...t}=e;return(0,s.yg)(qft,(0,p.A)({},Vft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jft.isMDXComponent=!0;const Hft={toc:[]},Yft="wrapper";function Qft(e){let{components:n,...t}=e;return(0,s.yg)(Yft,(0,p.A)({},Hft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Qft.isMDXComponent=!0;const $ft={toc:[]},Kft="wrapper";function Jft(e){let{components:n,...t}=e;return(0,s.yg)(Kft,(0,p.A)({},$ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Jft.isMDXComponent=!0;const Zft={toc:[]},eDt="wrapper";function nDt(e){let{components:n,...t}=e;return(0,s.yg)(eDt,(0,p.A)({},Zft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}nDt.isMDXComponent=!0;const tDt={toc:[]},oDt="wrapper";function pDt(e){let{components:n,...t}=e;return(0,s.yg)(oDt,(0,p.A)({},tDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}pDt.isMDXComponent=!0;const rDt={toc:[]},sDt="wrapper";function cDt(e){let{components:n,...t}=e;return(0,s.yg)(sDt,(0,p.A)({},rDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}cDt.isMDXComponent=!0;const aDt={toc:[]},iDt="wrapper";function lDt(e){let{components:n,...t}=e;return(0,s.yg)(iDt,(0,p.A)({},aDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}lDt.isMDXComponent=!0;const uDt={toc:[]},mDt="wrapper";function yDt(e){let{components:n,...t}=e;return(0,s.yg)(mDt,(0,p.A)({},uDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}yDt.isMDXComponent=!0;const dDt={toc:[]},hDt="wrapper";function gDt(e){let{components:n,...t}=e;return(0,s.yg)(hDt,(0,p.A)({},dDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}gDt.isMDXComponent=!0;const fDt={toc:[]},DDt="wrapper";function MDt(e){let{components:n,...t}=e;return(0,s.yg)(DDt,(0,p.A)({},fDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}MDt.isMDXComponent=!0;const XDt={toc:[]},_Dt="wrapper";function wDt(e){let{components:n,...t}=e;return(0,s.yg)(_Dt,(0,p.A)({},XDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}wDt.isMDXComponent=!0;const TDt={toc:[]},CDt="wrapper";function xDt(e){let{components:n,...t}=e;return(0,s.yg)(CDt,(0,p.A)({},TDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}xDt.isMDXComponent=!0;const ADt={toc:[]},vDt="wrapper";function LDt(e){let{components:n,...t}=e;return(0,s.yg)(vDt,(0,p.A)({},ADt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}LDt.isMDXComponent=!0;const bDt={toc:[]},NDt="wrapper";function kDt(e){let{components:n,...t}=e;return(0,s.yg)(NDt,(0,p.A)({},bDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}kDt.isMDXComponent=!0;const zDt={toc:[]},PDt="wrapper";function IDt(e){let{components:n,...t}=e;return(0,s.yg)(PDt,(0,p.A)({},zDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}IDt.isMDXComponent=!0;const RDt={toc:[]},WDt="wrapper";function SDt(e){let{components:n,...t}=e;return(0,s.yg)(WDt,(0,p.A)({},RDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}SDt.isMDXComponent=!0;const BDt={toc:[]},GDt="wrapper";function EDt(e){let{components:n,...t}=e;return(0,s.yg)(GDt,(0,p.A)({},BDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}EDt.isMDXComponent=!0;const ODt={toc:[]},UDt="wrapper";function FDt(e){let{components:n,...t}=e;return(0,s.yg)(UDt,(0,p.A)({},ODt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}FDt.isMDXComponent=!0;const VDt={toc:[]},qDt="wrapper";function jDt(e){let{components:n,...t}=e;return(0,s.yg)(qDt,(0,p.A)({},VDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}jDt.isMDXComponent=!0;const HDt={toc:[]},YDt="wrapper";function QDt(e){let{components:n,...t}=e;return(0,s.yg)(YDt,(0,p.A)({},HDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}QDt.isMDXComponent=!0;const $Dt={toc:[]},KDt="wrapper";function JDt(e){let{components:n,...t}=e;return(0,s.yg)(KDt,(0,p.A)({},$Dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}JDt.isMDXComponent=!0;const ZDt={toc:[]},eMt="wrapper";function nMt(e){let{components:n,...t}=e;return(0,s.yg)(eMt,(0,p.A)({},ZDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}nMt.isMDXComponent=!0;const tMt={toc:[]},oMt="wrapper";function pMt(e){let{components:n,...t}=e;return(0,s.yg)(oMt,(0,p.A)({},tMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pMt.isMDXComponent=!0;const rMt={toc:[]},sMt="wrapper";function cMt(e){let{components:n,...t}=e;return(0,s.yg)(sMt,(0,p.A)({},rMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}cMt.isMDXComponent=!0;const aMt={toc:[]},iMt="wrapper";function lMt(e){let{components:n,...t}=e;return(0,s.yg)(iMt,(0,p.A)({},aMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}lMt.isMDXComponent=!0;const uMt={toc:[]},mMt="wrapper";function yMt(e){let{components:n,...t}=e;return(0,s.yg)(mMt,(0,p.A)({},uMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}yMt.isMDXComponent=!0;const dMt={toc:[]},hMt="wrapper";function gMt(e){let{components:n,...t}=e;return(0,s.yg)(hMt,(0,p.A)({},dMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}gMt.isMDXComponent=!0;const fMt={toc:[]},DMt="wrapper";function MMt(e){let{components:n,...t}=e;return(0,s.yg)(DMt,(0,p.A)({},fMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}MMt.isMDXComponent=!0;const XMt={toc:[]},_Mt="wrapper";function wMt(e){let{components:n,...t}=e;return(0,s.yg)(_Mt,(0,p.A)({},XMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}wMt.isMDXComponent=!0;const TMt={toc:[]},CMt="wrapper";function xMt(e){let{components:n,...t}=e;return(0,s.yg)(CMt,(0,p.A)({},TMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xMt.isMDXComponent=!0;const AMt={toc:[]},vMt="wrapper";function LMt(e){let{components:n,...t}=e;return(0,s.yg)(vMt,(0,p.A)({},AMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}LMt.isMDXComponent=!0;const bMt={toc:[]},NMt="wrapper";function kMt(e){let{components:n,...t}=e;return(0,s.yg)(NMt,(0,p.A)({},bMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kMt.isMDXComponent=!0;const zMt={toc:[]},PMt="wrapper";function IMt(e){let{components:n,...t}=e;return(0,s.yg)(PMt,(0,p.A)({},zMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}IMt.isMDXComponent=!0;const RMt={toc:[]},WMt="wrapper";function SMt(e){let{components:n,...t}=e;return(0,s.yg)(WMt,(0,p.A)({},RMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}SMt.isMDXComponent=!0;const BMt={toc:[]},GMt="wrapper";function EMt(e){let{components:n,...t}=e;return(0,s.yg)(GMt,(0,p.A)({},BMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}EMt.isMDXComponent=!0;const OMt={toc:[]},UMt="wrapper";function FMt(e){let{components:n,...t}=e;return(0,s.yg)(UMt,(0,p.A)({},OMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}FMt.isMDXComponent=!0;const VMt={toc:[]},qMt="wrapper";function jMt(e){let{components:n,...t}=e;return(0,s.yg)(qMt,(0,p.A)({},VMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jMt.isMDXComponent=!0;const HMt={toc:[]},YMt="wrapper";function QMt(e){let{components:n,...t}=e;return(0,s.yg)(YMt,(0,p.A)({},HMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}QMt.isMDXComponent=!0;const $Mt={toc:[]},KMt="wrapper";function JMt(e){let{components:n,...t}=e;return(0,s.yg)(KMt,(0,p.A)({},$Mt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}JMt.isMDXComponent=!0;const ZMt={toc:[]},eXt="wrapper";function nXt(e){let{components:n,...t}=e;return(0,s.yg)(eXt,(0,p.A)({},ZMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}nXt.isMDXComponent=!0;const tXt={toc:[]},oXt="wrapper";function pXt(e){let{components:n,...t}=e;return(0,s.yg)(oXt,(0,p.A)({},tXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pXt.isMDXComponent=!0;const rXt={toc:[]},sXt="wrapper";function cXt(e){let{components:n,...t}=e;return(0,s.yg)(sXt,(0,p.A)({},rXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}cXt.isMDXComponent=!0;const aXt={toc:[]},iXt="wrapper";function lXt(e){let{components:n,...t}=e;return(0,s.yg)(iXt,(0,p.A)({},aXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}lXt.isMDXComponent=!0;const uXt={toc:[]},mXt="wrapper";function yXt(e){let{components:n,...t}=e;return(0,s.yg)(mXt,(0,p.A)({},uXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}yXt.isMDXComponent=!0;const dXt={toc:[]},hXt="wrapper";function gXt(e){let{components:n,...t}=e;return(0,s.yg)(hXt,(0,p.A)({},dXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gXt.isMDXComponent=!0;const fXt={toc:[]},DXt="wrapper";function MXt(e){let{components:n,...t}=e;return(0,s.yg)(DXt,(0,p.A)({},fXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}MXt.isMDXComponent=!0;const XXt={toc:[]},_Xt="wrapper";function wXt(e){let{components:n,...t}=e;return(0,s.yg)(_Xt,(0,p.A)({},XXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}wXt.isMDXComponent=!0;const TXt={toc:[]},CXt="wrapper";function xXt(e){let{components:n,...t}=e;return(0,s.yg)(CXt,(0,p.A)({},TXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}xXt.isMDXComponent=!0;const AXt={toc:[]},vXt="wrapper";function LXt(e){let{components:n,...t}=e;return(0,s.yg)(vXt,(0,p.A)({},AXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}LXt.isMDXComponent=!0;const bXt={toc:[]},NXt="wrapper";function kXt(e){let{components:n,...t}=e;return(0,s.yg)(NXt,(0,p.A)({},bXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}kXt.isMDXComponent=!0;const zXt={toc:[]},PXt="wrapper";function IXt(e){let{components:n,...t}=e;return(0,s.yg)(PXt,(0,p.A)({},zXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}IXt.isMDXComponent=!0;const RXt={toc:[]},WXt="wrapper";function SXt(e){let{components:n,...t}=e;return(0,s.yg)(WXt,(0,p.A)({},RXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}SXt.isMDXComponent=!0;const BXt={toc:[]},GXt="wrapper";function EXt(e){let{components:n,...t}=e;return(0,s.yg)(GXt,(0,p.A)({},BXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}EXt.isMDXComponent=!0;const OXt={toc:[]},UXt="wrapper";function FXt(e){let{components:n,...t}=e;return(0,s.yg)(UXt,(0,p.A)({},OXt,t,{components:n,mdxType:"MDXLayout"}))}FXt.isMDXComponent=!0;const VXt={toc:[]},qXt="wrapper";function jXt(e){let{components:n,...t}=e;return(0,s.yg)(qXt,(0,p.A)({},VXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}jXt.isMDXComponent=!0;const HXt={toc:[]},YXt="wrapper";function QXt(e){let{components:n,...t}=e;return(0,s.yg)(YXt,(0,p.A)({},HXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}QXt.isMDXComponent=!0;const $Xt={toc:[]},KXt="wrapper";function JXt(e){let{components:n,...t}=e;return(0,s.yg)(KXt,(0,p.A)({},$Xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}JXt.isMDXComponent=!0;const ZXt={toc:[]},e_t="wrapper";function n_t(e){let{components:n,...t}=e;return(0,s.yg)(e_t,(0,p.A)({},ZXt,t,{components:n,mdxType:"MDXLayout"}))}n_t.isMDXComponent=!0;const t_t={toc:[]},o_t="wrapper";function p_t(e){let{components:n,...t}=e;return(0,s.yg)(o_t,(0,p.A)({},t_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}p_t.isMDXComponent=!0;const r_t={toc:[]},s_t="wrapper";function c_t(e){let{components:n,...t}=e;return(0,s.yg)(s_t,(0,p.A)({},r_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}c_t.isMDXComponent=!0;const a_t={toc:[]},i_t="wrapper";function l_t(e){let{components:n,...t}=e;return(0,s.yg)(i_t,(0,p.A)({},a_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}l_t.isMDXComponent=!0;const u_t={toc:[]},m_t="wrapper";function y_t(e){let{components:n,...t}=e;return(0,s.yg)(m_t,(0,p.A)({},u_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}y_t.isMDXComponent=!0;const d_t={toc:[]},h_t="wrapper";function g_t(e){let{components:n,...t}=e;return(0,s.yg)(h_t,(0,p.A)({},d_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}g_t.isMDXComponent=!0;const f_t={toc:[]},D_t="wrapper";function M_t(e){let{components:n,...t}=e;return(0,s.yg)(D_t,(0,p.A)({},f_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}M_t.isMDXComponent=!0;const X_t={toc:[]},__t="wrapper";function w_t(e){let{components:n,...t}=e;return(0,s.yg)(__t,(0,p.A)({},X_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}w_t.isMDXComponent=!0;const T_t={toc:[]},C_t="wrapper";function x_t(e){let{components:n,...t}=e;return(0,s.yg)(C_t,(0,p.A)({},T_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}x_t.isMDXComponent=!0;const A_t={toc:[]},v_t="wrapper";function L_t(e){let{components:n,...t}=e;return(0,s.yg)(v_t,(0,p.A)({},A_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}L_t.isMDXComponent=!0;const b_t={toc:[]},N_t="wrapper";function k_t(e){let{components:n,...t}=e;return(0,s.yg)(N_t,(0,p.A)({},b_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}k_t.isMDXComponent=!0;const z_t={toc:[]},P_t="wrapper";function I_t(e){let{components:n,...t}=e;return(0,s.yg)(P_t,(0,p.A)({},z_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}I_t.isMDXComponent=!0;const R_t={toc:[]},W_t="wrapper";function S_t(e){let{components:n,...t}=e;return(0,s.yg)(W_t,(0,p.A)({},R_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}S_t.isMDXComponent=!0;const B_t={toc:[]},G_t="wrapper";function E_t(e){let{components:n,...t}=e;return(0,s.yg)(G_t,(0,p.A)({},B_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}E_t.isMDXComponent=!0;const O_t={toc:[]},U_t="wrapper";function F_t(e){let{components:n,...t}=e;return(0,s.yg)(U_t,(0,p.A)({},O_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}F_t.isMDXComponent=!0;const V_t={toc:[]},q_t="wrapper";function j_t(e){let{components:n,...t}=e;return(0,s.yg)(q_t,(0,p.A)({},V_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}j_t.isMDXComponent=!0;const H_t={toc:[]},Y_t="wrapper";function Q_t(e){let{components:n,...t}=e;return(0,s.yg)(Y_t,(0,p.A)({},H_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Q_t.isMDXComponent=!0;const $_t={toc:[]},K_t="wrapper";function J_t(e){let{components:n,...t}=e;return(0,s.yg)(K_t,(0,p.A)({},$_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}J_t.isMDXComponent=!0;const Z_t={toc:[]},ewt="wrapper";function nwt(e){let{components:n,...t}=e;return(0,s.yg)(ewt,(0,p.A)({},Z_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}nwt.isMDXComponent=!0;const twt={toc:[]},owt="wrapper";function pwt(e){let{components:n,...t}=e;return(0,s.yg)(owt,(0,p.A)({},twt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}pwt.isMDXComponent=!0;const rwt={toc:[]},swt="wrapper";function cwt(e){let{components:n,...t}=e;return(0,s.yg)(swt,(0,p.A)({},rwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}cwt.isMDXComponent=!0;const awt={toc:[]},iwt="wrapper";function lwt(e){let{components:n,...t}=e;return(0,s.yg)(iwt,(0,p.A)({},awt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lwt.isMDXComponent=!0;const uwt={toc:[]},mwt="wrapper";function ywt(e){let{components:n,...t}=e;return(0,s.yg)(mwt,(0,p.A)({},uwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}ywt.isMDXComponent=!0;const dwt={toc:[]},hwt="wrapper";function gwt(e){let{components:n,...t}=e;return(0,s.yg)(hwt,(0,p.A)({},dwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gwt.isMDXComponent=!0;const fwt={toc:[]},Dwt="wrapper";function Mwt(e){let{components:n,...t}=e;return(0,s.yg)(Dwt,(0,p.A)({},fwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Mwt.isMDXComponent=!0;const Xwt={toc:[]},_wt="wrapper";function wwt(e){let{components:n,...t}=e;return(0,s.yg)(_wt,(0,p.A)({},Xwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wwt.isMDXComponent=!0;const Twt={toc:[]},Cwt="wrapper";function xwt(e){let{components:n,...t}=e;return(0,s.yg)(Cwt,(0,p.A)({},Twt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xwt.isMDXComponent=!0;const Awt={toc:[]},vwt="wrapper";function Lwt(e){let{components:n,...t}=e;return(0,s.yg)(vwt,(0,p.A)({},Awt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Lwt.isMDXComponent=!0;const bwt={toc:[]},Nwt="wrapper";function kwt(e){let{components:n,...t}=e;return(0,s.yg)(Nwt,(0,p.A)({},bwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}kwt.isMDXComponent=!0;const zwt={toc:[]},Pwt="wrapper";function Iwt(e){let{components:n,...t}=e;return(0,s.yg)(Pwt,(0,p.A)({},zwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Iwt.isMDXComponent=!0;const Rwt={toc:[]},Wwt="wrapper";function Swt(e){let{components:n,...t}=e;return(0,s.yg)(Wwt,(0,p.A)({},Rwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Swt.isMDXComponent=!0;const Bwt={toc:[]},Gwt="wrapper";function Ewt(e){let{components:n,...t}=e;return(0,s.yg)(Gwt,(0,p.A)({},Bwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ewt.isMDXComponent=!0;const Owt={toc:[]},Uwt="wrapper";function Fwt(e){let{components:n,...t}=e;return(0,s.yg)(Uwt,(0,p.A)({},Owt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Fwt.isMDXComponent=!0;const Vwt={toc:[]},qwt="wrapper";function jwt(e){let{components:n,...t}=e;return(0,s.yg)(qwt,(0,p.A)({},Vwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jwt.isMDXComponent=!0;const Hwt={toc:[]},Ywt="wrapper";function Qwt(e){let{components:n,...t}=e;return(0,s.yg)(Ywt,(0,p.A)({},Hwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Qwt.isMDXComponent=!0;const $wt={toc:[]},Kwt="wrapper";function Jwt(e){let{components:n,...t}=e;return(0,s.yg)(Kwt,(0,p.A)({},$wt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jwt.isMDXComponent=!0;const Zwt={toc:[]},eTt="wrapper";function nTt(e){let{components:n,...t}=e;return(0,s.yg)(eTt,(0,p.A)({},Zwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nTt.isMDXComponent=!0;const tTt={toc:[]},oTt="wrapper";function pTt(e){let{components:n,...t}=e;return(0,s.yg)(oTt,(0,p.A)({},tTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pTt.isMDXComponent=!0;const rTt={toc:[]},sTt="wrapper";function cTt(e){let{components:n,...t}=e;return(0,s.yg)(sTt,(0,p.A)({},rTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}cTt.isMDXComponent=!0;const aTt={toc:[]},iTt="wrapper";function lTt(e){let{components:n,...t}=e;return(0,s.yg)(iTt,(0,p.A)({},aTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lTt.isMDXComponent=!0;const uTt={toc:[]},mTt="wrapper";function yTt(e){let{components:n,...t}=e;return(0,s.yg)(mTt,(0,p.A)({},uTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}yTt.isMDXComponent=!0;const dTt={toc:[]},hTt="wrapper";function gTt(e){let{components:n,...t}=e;return(0,s.yg)(hTt,(0,p.A)({},dTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gTt.isMDXComponent=!0;const fTt={toc:[]},DTt="wrapper";function MTt(e){let{components:n,...t}=e;return(0,s.yg)(DTt,(0,p.A)({},fTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}MTt.isMDXComponent=!0;const XTt={toc:[]},_Tt="wrapper";function wTt(e){let{components:n,...t}=e;return(0,s.yg)(_Tt,(0,p.A)({},XTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wTt.isMDXComponent=!0;const TTt={toc:[]},CTt="wrapper";function xTt(e){let{components:n,...t}=e;return(0,s.yg)(CTt,(0,p.A)({},TTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}xTt.isMDXComponent=!0;const ATt={toc:[]},vTt="wrapper";function LTt(e){let{components:n,...t}=e;return(0,s.yg)(vTt,(0,p.A)({},ATt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LTt.isMDXComponent=!0;const bTt={toc:[]},NTt="wrapper";function kTt(e){let{components:n,...t}=e;return(0,s.yg)(NTt,(0,p.A)({},bTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}kTt.isMDXComponent=!0;const zTt={toc:[]},PTt="wrapper";function ITt(e){let{components:n,...t}=e;return(0,s.yg)(PTt,(0,p.A)({},zTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ITt.isMDXComponent=!0;const RTt={toc:[]},WTt="wrapper";function STt(e){let{components:n,...t}=e;return(0,s.yg)(WTt,(0,p.A)({},RTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}STt.isMDXComponent=!0;const BTt={toc:[]},GTt="wrapper";function ETt(e){let{components:n,...t}=e;return(0,s.yg)(GTt,(0,p.A)({},BTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}ETt.isMDXComponent=!0;const OTt={toc:[]},UTt="wrapper";function FTt(e){let{components:n,...t}=e;return(0,s.yg)(UTt,(0,p.A)({},OTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}FTt.isMDXComponent=!0;const VTt={toc:[]},qTt="wrapper";function jTt(e){let{components:n,...t}=e;return(0,s.yg)(qTt,(0,p.A)({},VTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}jTt.isMDXComponent=!0;const HTt={toc:[]},YTt="wrapper";function QTt(e){let{components:n,...t}=e;return(0,s.yg)(YTt,(0,p.A)({},HTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}QTt.isMDXComponent=!0;const $Tt={toc:[]},KTt="wrapper";function JTt(e){let{components:n,...t}=e;return(0,s.yg)(KTt,(0,p.A)({},$Tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}JTt.isMDXComponent=!0;const ZTt={toc:[]},eCt="wrapper";function nCt(e){let{components:n,...t}=e;return(0,s.yg)(eCt,(0,p.A)({},ZTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}nCt.isMDXComponent=!0;const tCt={toc:[]},oCt="wrapper";function pCt(e){let{components:n,...t}=e;return(0,s.yg)(oCt,(0,p.A)({},tCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}pCt.isMDXComponent=!0;const rCt={toc:[]},sCt="wrapper";function cCt(e){let{components:n,...t}=e;return(0,s.yg)(sCt,(0,p.A)({},rCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}cCt.isMDXComponent=!0;const aCt={toc:[]},iCt="wrapper";function lCt(e){let{components:n,...t}=e;return(0,s.yg)(iCt,(0,p.A)({},aCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}lCt.isMDXComponent=!0;const uCt={toc:[]},mCt="wrapper";function yCt(e){let{components:n,...t}=e;return(0,s.yg)(mCt,(0,p.A)({},uCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}yCt.isMDXComponent=!0;const dCt={toc:[]},hCt="wrapper";function gCt(e){let{components:n,...t}=e;return(0,s.yg)(hCt,(0,p.A)({},dCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}gCt.isMDXComponent=!0;const fCt={toc:[]},DCt="wrapper";function MCt(e){let{components:n,...t}=e;return(0,s.yg)(DCt,(0,p.A)({},fCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}MCt.isMDXComponent=!0;const XCt={toc:[]},_Ct="wrapper";function wCt(e){let{components:n,...t}=e;return(0,s.yg)(_Ct,(0,p.A)({},XCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}wCt.isMDXComponent=!0;const TCt={toc:[]},CCt="wrapper";function xCt(e){let{components:n,...t}=e;return(0,s.yg)(CCt,(0,p.A)({},TCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xCt.isMDXComponent=!0;const ACt={toc:[]},vCt="wrapper";function LCt(e){let{components:n,...t}=e;return(0,s.yg)(vCt,(0,p.A)({},ACt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}LCt.isMDXComponent=!0;const bCt={toc:[]},NCt="wrapper";function kCt(e){let{components:n,...t}=e;return(0,s.yg)(NCt,(0,p.A)({},bCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}kCt.isMDXComponent=!0;const zCt={toc:[]},PCt="wrapper";function ICt(e){let{components:n,...t}=e;return(0,s.yg)(PCt,(0,p.A)({},zCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}ICt.isMDXComponent=!0;const RCt={toc:[]},WCt="wrapper";function SCt(e){let{components:n,...t}=e;return(0,s.yg)(WCt,(0,p.A)({},RCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}SCt.isMDXComponent=!0;const BCt={toc:[]},GCt="wrapper";function ECt(e){let{components:n,...t}=e;return(0,s.yg)(GCt,(0,p.A)({},BCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}ECt.isMDXComponent=!0;const OCt={toc:[]},UCt="wrapper";function FCt(e){let{components:n,...t}=e;return(0,s.yg)(UCt,(0,p.A)({},OCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}FCt.isMDXComponent=!0;const VCt={toc:[]},qCt="wrapper";function jCt(e){let{components:n,...t}=e;return(0,s.yg)(qCt,(0,p.A)({},VCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}jCt.isMDXComponent=!0;const HCt={toc:[]},YCt="wrapper";function QCt(e){let{components:n,...t}=e;return(0,s.yg)(YCt,(0,p.A)({},HCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}QCt.isMDXComponent=!0;const $Ct={toc:[]},KCt="wrapper";function JCt(e){let{components:n,...t}=e;return(0,s.yg)(KCt,(0,p.A)({},$Ct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}JCt.isMDXComponent=!0;const ZCt={toc:[]},ext="wrapper";function nxt(e){let{components:n,...t}=e;return(0,s.yg)(ext,(0,p.A)({},ZCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nxt.isMDXComponent=!0;const txt={toc:[]},oxt="wrapper";function pxt(e){let{components:n,...t}=e;return(0,s.yg)(oxt,(0,p.A)({},txt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}pxt.isMDXComponent=!0;const rxt={toc:[]},sxt="wrapper";function cxt(e){let{components:n,...t}=e;return(0,s.yg)(sxt,(0,p.A)({},rxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}cxt.isMDXComponent=!0;const axt={toc:[]},ixt="wrapper";function lxt(e){let{components:n,...t}=e;return(0,s.yg)(ixt,(0,p.A)({},axt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lxt.isMDXComponent=!0;const uxt={toc:[]},mxt="wrapper";function yxt(e){let{components:n,...t}=e;return(0,s.yg)(mxt,(0,p.A)({},uxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yxt.isMDXComponent=!0;const dxt={toc:[]},hxt="wrapper";function gxt(e){let{components:n,...t}=e;return(0,s.yg)(hxt,(0,p.A)({},dxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}gxt.isMDXComponent=!0;const fxt={toc:[]},Dxt="wrapper";function Mxt(e){let{components:n,...t}=e;return(0,s.yg)(Dxt,(0,p.A)({},fxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Mxt.isMDXComponent=!0;const Xxt={toc:[]},_xt="wrapper";function wxt(e){let{components:n,...t}=e;return(0,s.yg)(_xt,(0,p.A)({},Xxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}wxt.isMDXComponent=!0;const Txt={toc:[]},Cxt="wrapper";function xxt(e){let{components:n,...t}=e;return(0,s.yg)(Cxt,(0,p.A)({},Txt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}xxt.isMDXComponent=!0;const Axt={toc:[]},vxt="wrapper";function Lxt(e){let{components:n,...t}=e;return(0,s.yg)(vxt,(0,p.A)({},Axt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Lxt.isMDXComponent=!0;const bxt={toc:[]},Nxt="wrapper";function kxt(e){let{components:n,...t}=e;return(0,s.yg)(Nxt,(0,p.A)({},bxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}kxt.isMDXComponent=!0;const zxt={toc:[]},Pxt="wrapper";function Ixt(e){let{components:n,...t}=e;return(0,s.yg)(Pxt,(0,p.A)({},zxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Ixt.isMDXComponent=!0;const Rxt={toc:[]},Wxt="wrapper";function Sxt(e){let{components:n,...t}=e;return(0,s.yg)(Wxt,(0,p.A)({},Rxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Sxt.isMDXComponent=!0;const Bxt={toc:[]},Gxt="wrapper";function Ext(e){let{components:n,...t}=e;return(0,s.yg)(Gxt,(0,p.A)({},Bxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Ext.isMDXComponent=!0;const Oxt={toc:[]},Uxt="wrapper";function Fxt(e){let{components:n,...t}=e;return(0,s.yg)(Uxt,(0,p.A)({},Oxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Fxt.isMDXComponent=!0;const Vxt={toc:[]},qxt="wrapper";function jxt(e){let{components:n,...t}=e;return(0,s.yg)(qxt,(0,p.A)({},Vxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}jxt.isMDXComponent=!0;const Hxt={toc:[]},Yxt="wrapper";function Qxt(e){let{components:n,...t}=e;return(0,s.yg)(Yxt,(0,p.A)({},Hxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Qxt.isMDXComponent=!0;const $xt={toc:[]},Kxt="wrapper";function Jxt(e){let{components:n,...t}=e;return(0,s.yg)(Kxt,(0,p.A)({},$xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Jxt.isMDXComponent=!0;const Zxt={toc:[]},eAt="wrapper";function nAt(e){let{components:n,...t}=e;return(0,s.yg)(eAt,(0,p.A)({},Zxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}nAt.isMDXComponent=!0;const tAt={toc:[]},oAt="wrapper";function pAt(e){let{components:n,...t}=e;return(0,s.yg)(oAt,(0,p.A)({},tAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}pAt.isMDXComponent=!0;const rAt={toc:[]},sAt="wrapper";function cAt(e){let{components:n,...t}=e;return(0,s.yg)(sAt,(0,p.A)({},rAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cAt.isMDXComponent=!0;const aAt={toc:[]},iAt="wrapper";function lAt(e){let{components:n,...t}=e;return(0,s.yg)(iAt,(0,p.A)({},aAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}lAt.isMDXComponent=!0;const uAt={toc:[]},mAt="wrapper";function yAt(e){let{components:n,...t}=e;return(0,s.yg)(mAt,(0,p.A)({},uAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}yAt.isMDXComponent=!0;const dAt={toc:[]},hAt="wrapper";function gAt(e){let{components:n,...t}=e;return(0,s.yg)(hAt,(0,p.A)({},dAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}gAt.isMDXComponent=!0;const fAt={toc:[]},DAt="wrapper";function MAt(e){let{components:n,...t}=e;return(0,s.yg)(DAt,(0,p.A)({},fAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}MAt.isMDXComponent=!0;const XAt={toc:[]},_At="wrapper";function wAt(e){let{components:n,...t}=e;return(0,s.yg)(_At,(0,p.A)({},XAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}wAt.isMDXComponent=!0;const TAt={toc:[]},CAt="wrapper";function xAt(e){let{components:n,...t}=e;return(0,s.yg)(CAt,(0,p.A)({},TAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}xAt.isMDXComponent=!0;const AAt={toc:[]},vAt="wrapper";function LAt(e){let{components:n,...t}=e;return(0,s.yg)(vAt,(0,p.A)({},AAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}LAt.isMDXComponent=!0;const bAt={toc:[]},NAt="wrapper";function kAt(e){let{components:n,...t}=e;return(0,s.yg)(NAt,(0,p.A)({},bAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}kAt.isMDXComponent=!0;const zAt={toc:[]},PAt="wrapper";function IAt(e){let{components:n,...t}=e;return(0,s.yg)(PAt,(0,p.A)({},zAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}IAt.isMDXComponent=!0;const RAt={toc:[]},WAt="wrapper";function SAt(e){let{components:n,...t}=e;return(0,s.yg)(WAt,(0,p.A)({},RAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}SAt.isMDXComponent=!0;const BAt={toc:[]},GAt="wrapper";function EAt(e){let{components:n,...t}=e;return(0,s.yg)(GAt,(0,p.A)({},BAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}EAt.isMDXComponent=!0;const OAt={toc:[]},UAt="wrapper";function FAt(e){let{components:n,...t}=e;return(0,s.yg)(UAt,(0,p.A)({},OAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}FAt.isMDXComponent=!0;const VAt={toc:[]},qAt="wrapper";function jAt(e){let{components:n,...t}=e;return(0,s.yg)(qAt,(0,p.A)({},VAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}jAt.isMDXComponent=!0;const HAt={toc:[]},YAt="wrapper";function QAt(e){let{components:n,...t}=e;return(0,s.yg)(YAt,(0,p.A)({},HAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}QAt.isMDXComponent=!0;const $At={toc:[]},KAt="wrapper";function JAt(e){let{components:n,...t}=e;return(0,s.yg)(KAt,(0,p.A)({},$At,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}JAt.isMDXComponent=!0;const ZAt={toc:[]},evt="wrapper";function nvt(e){let{components:n,...t}=e;return(0,s.yg)(evt,(0,p.A)({},ZAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}nvt.isMDXComponent=!0;const tvt={toc:[]},ovt="wrapper";function pvt(e){let{components:n,...t}=e;return(0,s.yg)(ovt,(0,p.A)({},tvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}pvt.isMDXComponent=!0;const rvt={toc:[]},svt="wrapper";function cvt(e){let{components:n,...t}=e;return(0,s.yg)(svt,(0,p.A)({},rvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}cvt.isMDXComponent=!0;const avt={toc:[]},ivt="wrapper";function lvt(e){let{components:n,...t}=e;return(0,s.yg)(ivt,(0,p.A)({},avt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}lvt.isMDXComponent=!0;const uvt={toc:[]},mvt="wrapper";function yvt(e){let{components:n,...t}=e;return(0,s.yg)(mvt,(0,p.A)({},uvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yvt.isMDXComponent=!0;const dvt={toc:[]},hvt="wrapper";function gvt(e){let{components:n,...t}=e;return(0,s.yg)(hvt,(0,p.A)({},dvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}gvt.isMDXComponent=!0;const fvt={toc:[]},Dvt="wrapper";function Mvt(e){let{components:n,...t}=e;return(0,s.yg)(Dvt,(0,p.A)({},fvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Mvt.isMDXComponent=!0;const Xvt={toc:[]},_vt="wrapper";function wvt(e){let{components:n,...t}=e;return(0,s.yg)(_vt,(0,p.A)({},Xvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}wvt.isMDXComponent=!0;const Tvt={toc:[]},Cvt="wrapper";function xvt(e){let{components:n,...t}=e;return(0,s.yg)(Cvt,(0,p.A)({},Tvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}xvt.isMDXComponent=!0;const Avt={toc:[]},vvt="wrapper";function Lvt(e){let{components:n,...t}=e;return(0,s.yg)(vvt,(0,p.A)({},Avt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lvt.isMDXComponent=!0;const bvt={toc:[]},Nvt="wrapper";function kvt(e){let{components:n,...t}=e;return(0,s.yg)(Nvt,(0,p.A)({},bvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}kvt.isMDXComponent=!0;const zvt={toc:[]},Pvt="wrapper";function Ivt(e){let{components:n,...t}=e;return(0,s.yg)(Pvt,(0,p.A)({},zvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Ivt.isMDXComponent=!0;const Rvt={toc:[]},Wvt="wrapper";function Svt(e){let{components:n,...t}=e;return(0,s.yg)(Wvt,(0,p.A)({},Rvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Svt.isMDXComponent=!0;const Bvt={toc:[]},Gvt="wrapper";function Evt(e){let{components:n,...t}=e;return(0,s.yg)(Gvt,(0,p.A)({},Bvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Evt.isMDXComponent=!0;const Ovt={toc:[]},Uvt="wrapper";function Fvt(e){let{components:n,...t}=e;return(0,s.yg)(Uvt,(0,p.A)({},Ovt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Fvt.isMDXComponent=!0;const Vvt={toc:[]},qvt="wrapper";function jvt(e){let{components:n,...t}=e;return(0,s.yg)(qvt,(0,p.A)({},Vvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}jvt.isMDXComponent=!0;const Hvt={toc:[]},Yvt="wrapper";function Qvt(e){let{components:n,...t}=e;return(0,s.yg)(Yvt,(0,p.A)({},Hvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Qvt.isMDXComponent=!0;const $vt={toc:[]},Kvt="wrapper";function Jvt(e){let{components:n,...t}=e;return(0,s.yg)(Kvt,(0,p.A)({},$vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Jvt.isMDXComponent=!0;const Zvt={toc:[]},eLt="wrapper";function nLt(e){let{components:n,...t}=e;return(0,s.yg)(eLt,(0,p.A)({},Zvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nLt.isMDXComponent=!0;const tLt={toc:[]},oLt="wrapper";function pLt(e){let{components:n,...t}=e;return(0,s.yg)(oLt,(0,p.A)({},tLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pLt.isMDXComponent=!0;const rLt={toc:[]},sLt="wrapper";function cLt(e){let{components:n,...t}=e;return(0,s.yg)(sLt,(0,p.A)({},rLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cLt.isMDXComponent=!0;const aLt={toc:[]},iLt="wrapper";function lLt(e){let{components:n,...t}=e;return(0,s.yg)(iLt,(0,p.A)({},aLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}lLt.isMDXComponent=!0;const uLt={toc:[]},mLt="wrapper";function yLt(e){let{components:n,...t}=e;return(0,s.yg)(mLt,(0,p.A)({},uLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yLt.isMDXComponent=!0;const dLt={toc:[]},hLt="wrapper";function gLt(e){let{components:n,...t}=e;return(0,s.yg)(hLt,(0,p.A)({},dLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}gLt.isMDXComponent=!0;const fLt={toc:[]},DLt="wrapper";function MLt(e){let{components:n,...t}=e;return(0,s.yg)(DLt,(0,p.A)({},fLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}MLt.isMDXComponent=!0;const XLt={toc:[]},_Lt="wrapper";function wLt(e){let{components:n,...t}=e;return(0,s.yg)(_Lt,(0,p.A)({},XLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}wLt.isMDXComponent=!0;const TLt={toc:[]},CLt="wrapper";function xLt(e){let{components:n,...t}=e;return(0,s.yg)(CLt,(0,p.A)({},TLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xLt.isMDXComponent=!0;const ALt={toc:[]},vLt="wrapper";function LLt(e){let{components:n,...t}=e;return(0,s.yg)(vLt,(0,p.A)({},ALt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}LLt.isMDXComponent=!0;const bLt={toc:[]},NLt="wrapper";function kLt(e){let{components:n,...t}=e;return(0,s.yg)(NLt,(0,p.A)({},bLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}kLt.isMDXComponent=!0;const zLt={toc:[]},PLt="wrapper";function ILt(e){let{components:n,...t}=e;return(0,s.yg)(PLt,(0,p.A)({},zLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}ILt.isMDXComponent=!0;const RLt={toc:[]},WLt="wrapper";function SLt(e){let{components:n,...t}=e;return(0,s.yg)(WLt,(0,p.A)({},RLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}SLt.isMDXComponent=!0;const BLt={toc:[]},GLt="wrapper";function ELt(e){let{components:n,...t}=e;return(0,s.yg)(GLt,(0,p.A)({},BLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ELt.isMDXComponent=!0;const OLt={toc:[]},ULt="wrapper";function FLt(e){let{components:n,...t}=e;return(0,s.yg)(ULt,(0,p.A)({},OLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}FLt.isMDXComponent=!0;const VLt={toc:[]},qLt="wrapper";function jLt(e){let{components:n,...t}=e;return(0,s.yg)(qLt,(0,p.A)({},VLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}jLt.isMDXComponent=!0;const HLt={toc:[]},YLt="wrapper";function QLt(e){let{components:n,...t}=e;return(0,s.yg)(YLt,(0,p.A)({},HLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}QLt.isMDXComponent=!0;const $Lt={toc:[]},KLt="wrapper";function JLt(e){let{components:n,...t}=e;return(0,s.yg)(KLt,(0,p.A)({},$Lt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}JLt.isMDXComponent=!0;const ZLt={toc:[]},ebt="wrapper";function nbt(e){let{components:n,...t}=e;return(0,s.yg)(ebt,(0,p.A)({},ZLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}nbt.isMDXComponent=!0;const tbt={toc:[]},obt="wrapper";function pbt(e){let{components:n,...t}=e;return(0,s.yg)(obt,(0,p.A)({},tbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}pbt.isMDXComponent=!0;const rbt={toc:[]},sbt="wrapper";function cbt(e){let{components:n,...t}=e;return(0,s.yg)(sbt,(0,p.A)({},rbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cbt.isMDXComponent=!0;const abt={toc:[]},ibt="wrapper";function lbt(e){let{components:n,...t}=e;return(0,s.yg)(ibt,(0,p.A)({},abt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lbt.isMDXComponent=!0;const ubt={toc:[]},mbt="wrapper";function ybt(e){let{components:n,...t}=e;return(0,s.yg)(mbt,(0,p.A)({},ubt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}ybt.isMDXComponent=!0;const dbt={toc:[]},hbt="wrapper";function gbt(e){let{components:n,...t}=e;return(0,s.yg)(hbt,(0,p.A)({},dbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}gbt.isMDXComponent=!0;const fbt={toc:[]},Dbt="wrapper";function Mbt(e){let{components:n,...t}=e;return(0,s.yg)(Dbt,(0,p.A)({},fbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Mbt.isMDXComponent=!0;const Xbt={toc:[]},_bt="wrapper";function wbt(e){let{components:n,...t}=e;return(0,s.yg)(_bt,(0,p.A)({},Xbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}wbt.isMDXComponent=!0;const Tbt={toc:[]},Cbt="wrapper";function xbt(e){let{components:n,...t}=e;return(0,s.yg)(Cbt,(0,p.A)({},Tbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xbt.isMDXComponent=!0;const Abt={toc:[]},vbt="wrapper";function Lbt(e){let{components:n,...t}=e;return(0,s.yg)(vbt,(0,p.A)({},Abt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Lbt.isMDXComponent=!0;const bbt={toc:[]},Nbt="wrapper";function kbt(e){let{components:n,...t}=e;return(0,s.yg)(Nbt,(0,p.A)({},bbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kbt.isMDXComponent=!0;const zbt={toc:[]},Pbt="wrapper";function Ibt(e){let{components:n,...t}=e;return(0,s.yg)(Pbt,(0,p.A)({},zbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Ibt.isMDXComponent=!0;const Rbt={toc:[]},Wbt="wrapper";function Sbt(e){let{components:n,...t}=e;return(0,s.yg)(Wbt,(0,p.A)({},Rbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Sbt.isMDXComponent=!0;const Bbt={toc:[]},Gbt="wrapper";function Ebt(e){let{components:n,...t}=e;return(0,s.yg)(Gbt,(0,p.A)({},Bbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ebt.isMDXComponent=!0;const Obt={toc:[]},Ubt="wrapper";function Fbt(e){let{components:n,...t}=e;return(0,s.yg)(Ubt,(0,p.A)({},Obt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Fbt.isMDXComponent=!0;const Vbt={toc:[]},qbt="wrapper";function jbt(e){let{components:n,...t}=e;return(0,s.yg)(qbt,(0,p.A)({},Vbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}jbt.isMDXComponent=!0;const Hbt={toc:[]},Ybt="wrapper";function Qbt(e){let{components:n,...t}=e;return(0,s.yg)(Ybt,(0,p.A)({},Hbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Qbt.isMDXComponent=!0;const $bt={toc:[]},Kbt="wrapper";function Jbt(e){let{components:n,...t}=e;return(0,s.yg)(Kbt,(0,p.A)({},$bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Jbt.isMDXComponent=!0;const Zbt={toc:[]},eNt="wrapper";function nNt(e){let{components:n,...t}=e;return(0,s.yg)(eNt,(0,p.A)({},Zbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}nNt.isMDXComponent=!0;const tNt={toc:[]},oNt="wrapper";function pNt(e){let{components:n,...t}=e;return(0,s.yg)(oNt,(0,p.A)({},tNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}pNt.isMDXComponent=!0;const rNt={toc:[]},sNt="wrapper";function cNt(e){let{components:n,...t}=e;return(0,s.yg)(sNt,(0,p.A)({},rNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}cNt.isMDXComponent=!0;const aNt={toc:[]},iNt="wrapper";function lNt(e){let{components:n,...t}=e;return(0,s.yg)(iNt,(0,p.A)({},aNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}lNt.isMDXComponent=!0;const uNt={toc:[]},mNt="wrapper";function yNt(e){let{components:n,...t}=e;return(0,s.yg)(mNt,(0,p.A)({},uNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}yNt.isMDXComponent=!0;const dNt={toc:[]},hNt="wrapper";function gNt(e){let{components:n,...t}=e;return(0,s.yg)(hNt,(0,p.A)({},dNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}gNt.isMDXComponent=!0;const fNt={toc:[]},DNt="wrapper";function MNt(e){let{components:n,...t}=e;return(0,s.yg)(DNt,(0,p.A)({},fNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}MNt.isMDXComponent=!0;const XNt={toc:[]},_Nt="wrapper";function wNt(e){let{components:n,...t}=e;return(0,s.yg)(_Nt,(0,p.A)({},XNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}wNt.isMDXComponent=!0;const TNt={toc:[]},CNt="wrapper";function xNt(e){let{components:n,...t}=e;return(0,s.yg)(CNt,(0,p.A)({},TNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}xNt.isMDXComponent=!0;const ANt={toc:[]},vNt="wrapper";function LNt(e){let{components:n,...t}=e;return(0,s.yg)(vNt,(0,p.A)({},ANt,t,{components:n,mdxType:"MDXLayout"}))}LNt.isMDXComponent=!0;const bNt={toc:[]},NNt="wrapper";function kNt(e){let{components:n,...t}=e;return(0,s.yg)(NNt,(0,p.A)({},bNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kNt.isMDXComponent=!0;const zNt={toc:[]},PNt="wrapper";function INt(e){let{components:n,...t}=e;return(0,s.yg)(PNt,(0,p.A)({},zNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}INt.isMDXComponent=!0;const RNt={toc:[]},WNt="wrapper";function SNt(e){let{components:n,...t}=e;return(0,s.yg)(WNt,(0,p.A)({},RNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}SNt.isMDXComponent=!0;const BNt={toc:[]},GNt="wrapper";function ENt(e){let{components:n,...t}=e;return(0,s.yg)(GNt,(0,p.A)({},BNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}ENt.isMDXComponent=!0;const ONt={toc:[]},UNt="wrapper";function FNt(e){let{components:n,...t}=e;return(0,s.yg)(UNt,(0,p.A)({},ONt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}FNt.isMDXComponent=!0;const VNt={toc:[]},qNt="wrapper";function jNt(e){let{components:n,...t}=e;return(0,s.yg)(qNt,(0,p.A)({},VNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}jNt.isMDXComponent=!0;const HNt={toc:[]},YNt="wrapper";function QNt(e){let{components:n,...t}=e;return(0,s.yg)(YNt,(0,p.A)({},HNt,t,{components:n,mdxType:"MDXLayout"}))}QNt.isMDXComponent=!0;const $Nt={toc:[]},KNt="wrapper";function JNt(e){let{components:n,...t}=e;return(0,s.yg)(KNt,(0,p.A)({},$Nt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}JNt.isMDXComponent=!0;const ZNt={toc:[]},ekt="wrapper";function nkt(e){let{components:n,...t}=e;return(0,s.yg)(ekt,(0,p.A)({},ZNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}nkt.isMDXComponent=!0;const tkt={toc:[]},okt="wrapper";function pkt(e){let{components:n,...t}=e;return(0,s.yg)(okt,(0,p.A)({},tkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pkt.isMDXComponent=!0;const rkt={toc:[]},skt="wrapper";function ckt(e){let{components:n,...t}=e;return(0,s.yg)(skt,(0,p.A)({},rkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}ckt.isMDXComponent=!0;const akt={toc:[]},ikt="wrapper";function lkt(e){let{components:n,...t}=e;return(0,s.yg)(ikt,(0,p.A)({},akt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lkt.isMDXComponent=!0;const ukt={toc:[]},mkt="wrapper";function ykt(e){let{components:n,...t}=e;return(0,s.yg)(mkt,(0,p.A)({},ukt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}ykt.isMDXComponent=!0;const dkt={toc:[]},hkt="wrapper";function gkt(e){let{components:n,...t}=e;return(0,s.yg)(hkt,(0,p.A)({},dkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}gkt.isMDXComponent=!0;const fkt={toc:[]},Dkt="wrapper";function Mkt(e){let{components:n,...t}=e;return(0,s.yg)(Dkt,(0,p.A)({},fkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Mkt.isMDXComponent=!0;const Xkt={toc:[]},_kt="wrapper";function wkt(e){let{components:n,...t}=e;return(0,s.yg)(_kt,(0,p.A)({},Xkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wkt.isMDXComponent=!0;const Tkt={toc:[]},Ckt="wrapper";function xkt(e){let{components:n,...t}=e;return(0,s.yg)(Ckt,(0,p.A)({},Tkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}xkt.isMDXComponent=!0;const Akt={toc:[]},vkt="wrapper";function Lkt(e){let{components:n,...t}=e;return(0,s.yg)(vkt,(0,p.A)({},Akt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Lkt.isMDXComponent=!0;const bkt={toc:[]},Nkt="wrapper";function kkt(e){let{components:n,...t}=e;return(0,s.yg)(Nkt,(0,p.A)({},bkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}kkt.isMDXComponent=!0;const zkt={toc:[]},Pkt="wrapper";function Ikt(e){let{components:n,...t}=e;return(0,s.yg)(Pkt,(0,p.A)({},zkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Ikt.isMDXComponent=!0;const Rkt={toc:[]},Wkt="wrapper";function Skt(e){let{components:n,...t}=e;return(0,s.yg)(Wkt,(0,p.A)({},Rkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Skt.isMDXComponent=!0;const Bkt={toc:[]},Gkt="wrapper";function Ekt(e){let{components:n,...t}=e;return(0,s.yg)(Gkt,(0,p.A)({},Bkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Ekt.isMDXComponent=!0;const Okt={toc:[]},Ukt="wrapper";function Fkt(e){let{components:n,...t}=e;return(0,s.yg)(Ukt,(0,p.A)({},Okt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Fkt.isMDXComponent=!0;const Vkt={toc:[]},qkt="wrapper";function jkt(e){let{components:n,...t}=e;return(0,s.yg)(qkt,(0,p.A)({},Vkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}jkt.isMDXComponent=!0;const Hkt={toc:[]},Ykt="wrapper";function Qkt(e){let{components:n,...t}=e;return(0,s.yg)(Ykt,(0,p.A)({},Hkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Qkt.isMDXComponent=!0;const $kt={toc:[]},Kkt="wrapper";function Jkt(e){let{components:n,...t}=e;return(0,s.yg)(Kkt,(0,p.A)({},$kt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Jkt.isMDXComponent=!0;const Zkt={toc:[]},ezt="wrapper";function nzt(e){let{components:n,...t}=e;return(0,s.yg)(ezt,(0,p.A)({},Zkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}nzt.isMDXComponent=!0;const tzt={toc:[]},ozt="wrapper";function pzt(e){let{components:n,...t}=e;return(0,s.yg)(ozt,(0,p.A)({},tzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}pzt.isMDXComponent=!0;const rzt={toc:[]},szt="wrapper";function czt(e){let{components:n,...t}=e;return(0,s.yg)(szt,(0,p.A)({},rzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}czt.isMDXComponent=!0;const azt={toc:[]},izt="wrapper";function lzt(e){let{components:n,...t}=e;return(0,s.yg)(izt,(0,p.A)({},azt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}lzt.isMDXComponent=!0;const uzt={toc:[]},mzt="wrapper";function yzt(e){let{components:n,...t}=e;return(0,s.yg)(mzt,(0,p.A)({},uzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}yzt.isMDXComponent=!0;const dzt={toc:[]},hzt="wrapper";function gzt(e){let{components:n,...t}=e;return(0,s.yg)(hzt,(0,p.A)({},dzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}gzt.isMDXComponent=!0;const fzt={toc:[]},Dzt="wrapper";function Mzt(e){let{components:n,...t}=e;return(0,s.yg)(Dzt,(0,p.A)({},fzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Mzt.isMDXComponent=!0;const Xzt={toc:[]},_zt="wrapper";function wzt(e){let{components:n,...t}=e;return(0,s.yg)(_zt,(0,p.A)({},Xzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wzt.isMDXComponent=!0;const Tzt={toc:[]},Czt="wrapper";function xzt(e){let{components:n,...t}=e;return(0,s.yg)(Czt,(0,p.A)({},Tzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}xzt.isMDXComponent=!0;const Azt={toc:[]},vzt="wrapper";function Lzt(e){let{components:n,...t}=e;return(0,s.yg)(vzt,(0,p.A)({},Azt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Lzt.isMDXComponent=!0;const bzt={toc:[]},Nzt="wrapper";function kzt(e){let{components:n,...t}=e;return(0,s.yg)(Nzt,(0,p.A)({},bzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}kzt.isMDXComponent=!0;const zzt={toc:[]},Pzt="wrapper";function Izt(e){let{components:n,...t}=e;return(0,s.yg)(Pzt,(0,p.A)({},zzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Izt.isMDXComponent=!0;const Rzt={toc:[]},Wzt="wrapper";function Szt(e){let{components:n,...t}=e;return(0,s.yg)(Wzt,(0,p.A)({},Rzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Szt.isMDXComponent=!0;const Bzt={toc:[]},Gzt="wrapper";function Ezt(e){let{components:n,...t}=e;return(0,s.yg)(Gzt,(0,p.A)({},Bzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Ezt.isMDXComponent=!0;const Ozt={toc:[]},Uzt="wrapper";function Fzt(e){let{components:n,...t}=e;return(0,s.yg)(Uzt,(0,p.A)({},Ozt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Fzt.isMDXComponent=!0;const Vzt={toc:[]},qzt="wrapper";function jzt(e){let{components:n,...t}=e;return(0,s.yg)(qzt,(0,p.A)({},Vzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}jzt.isMDXComponent=!0;const Hzt={toc:[]},Yzt="wrapper";function Qzt(e){let{components:n,...t}=e;return(0,s.yg)(Yzt,(0,p.A)({},Hzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Qzt.isMDXComponent=!0;const $zt={toc:[]},Kzt="wrapper";function Jzt(e){let{components:n,...t}=e;return(0,s.yg)(Kzt,(0,p.A)({},$zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Jzt.isMDXComponent=!0;const Zzt={toc:[]},ePt="wrapper";function nPt(e){let{components:n,...t}=e;return(0,s.yg)(ePt,(0,p.A)({},Zzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}nPt.isMDXComponent=!0;const tPt={toc:[]},oPt="wrapper";function pPt(e){let{components:n,...t}=e;return(0,s.yg)(oPt,(0,p.A)({},tPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pPt.isMDXComponent=!0;const rPt={toc:[]},sPt="wrapper";function cPt(e){let{components:n,...t}=e;return(0,s.yg)(sPt,(0,p.A)({},rPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}cPt.isMDXComponent=!0;const aPt={toc:[]},iPt="wrapper";function lPt(e){let{components:n,...t}=e;return(0,s.yg)(iPt,(0,p.A)({},aPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lPt.isMDXComponent=!0;const uPt={toc:[]},mPt="wrapper";function yPt(e){let{components:n,...t}=e;return(0,s.yg)(mPt,(0,p.A)({},uPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}yPt.isMDXComponent=!0;const dPt={toc:[]},hPt="wrapper";function gPt(e){let{components:n,...t}=e;return(0,s.yg)(hPt,(0,p.A)({},dPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}gPt.isMDXComponent=!0;const fPt={toc:[]},DPt="wrapper";function MPt(e){let{components:n,...t}=e;return(0,s.yg)(DPt,(0,p.A)({},fPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}MPt.isMDXComponent=!0;const XPt={toc:[]},_Pt="wrapper";function wPt(e){let{components:n,...t}=e;return(0,s.yg)(_Pt,(0,p.A)({},XPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}wPt.isMDXComponent=!0;const TPt={toc:[]},CPt="wrapper";function xPt(e){let{components:n,...t}=e;return(0,s.yg)(CPt,(0,p.A)({},TPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xPt.isMDXComponent=!0;const APt={toc:[]},vPt="wrapper";function LPt(e){let{components:n,...t}=e;return(0,s.yg)(vPt,(0,p.A)({},APt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}LPt.isMDXComponent=!0;const bPt={toc:[]},NPt="wrapper";function kPt(e){let{components:n,...t}=e;return(0,s.yg)(NPt,(0,p.A)({},bPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}kPt.isMDXComponent=!0;const zPt={toc:[]},PPt="wrapper";function IPt(e){let{components:n,...t}=e;return(0,s.yg)(PPt,(0,p.A)({},zPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}IPt.isMDXComponent=!0;const RPt={toc:[]},WPt="wrapper";function SPt(e){let{components:n,...t}=e;return(0,s.yg)(WPt,(0,p.A)({},RPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}SPt.isMDXComponent=!0;const BPt={toc:[]},GPt="wrapper";function EPt(e){let{components:n,...t}=e;return(0,s.yg)(GPt,(0,p.A)({},BPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}EPt.isMDXComponent=!0;const OPt={toc:[]},UPt="wrapper";function FPt(e){let{components:n,...t}=e;return(0,s.yg)(UPt,(0,p.A)({},OPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}FPt.isMDXComponent=!0;const VPt={toc:[]},qPt="wrapper";function jPt(e){let{components:n,...t}=e;return(0,s.yg)(qPt,(0,p.A)({},VPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}jPt.isMDXComponent=!0;const HPt={toc:[]},YPt="wrapper";function QPt(e){let{components:n,...t}=e;return(0,s.yg)(YPt,(0,p.A)({},HPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}QPt.isMDXComponent=!0;const $Pt={toc:[]},KPt="wrapper";function JPt(e){let{components:n,...t}=e;return(0,s.yg)(KPt,(0,p.A)({},$Pt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}JPt.isMDXComponent=!0;const ZPt={toc:[]},eIt="wrapper";function nIt(e){let{components:n,...t}=e;return(0,s.yg)(eIt,(0,p.A)({},ZPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nIt.isMDXComponent=!0;const tIt={toc:[]},oIt="wrapper";function pIt(e){let{components:n,...t}=e;return(0,s.yg)(oIt,(0,p.A)({},tIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}pIt.isMDXComponent=!0;const rIt={toc:[]},sIt="wrapper";function cIt(e){let{components:n,...t}=e;return(0,s.yg)(sIt,(0,p.A)({},rIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cIt.isMDXComponent=!0;const aIt={toc:[]},iIt="wrapper";function lIt(e){let{components:n,...t}=e;return(0,s.yg)(iIt,(0,p.A)({},aIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lIt.isMDXComponent=!0;const uIt={toc:[]},mIt="wrapper";function yIt(e){let{components:n,...t}=e;return(0,s.yg)(mIt,(0,p.A)({},uIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yIt.isMDXComponent=!0;const dIt={toc:[]},hIt="wrapper";function gIt(e){let{components:n,...t}=e;return(0,s.yg)(hIt,(0,p.A)({},dIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}gIt.isMDXComponent=!0;const fIt={toc:[]},DIt="wrapper";function MIt(e){let{components:n,...t}=e;return(0,s.yg)(DIt,(0,p.A)({},fIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}MIt.isMDXComponent=!0;const XIt={toc:[]},_It="wrapper";function wIt(e){let{components:n,...t}=e;return(0,s.yg)(_It,(0,p.A)({},XIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}wIt.isMDXComponent=!0;const TIt={toc:[]},CIt="wrapper";function xIt(e){let{components:n,...t}=e;return(0,s.yg)(CIt,(0,p.A)({},TIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xIt.isMDXComponent=!0;const AIt={toc:[]},vIt="wrapper";function LIt(e){let{components:n,...t}=e;return(0,s.yg)(vIt,(0,p.A)({},AIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}LIt.isMDXComponent=!0;const bIt={toc:[]},NIt="wrapper";function kIt(e){let{components:n,...t}=e;return(0,s.yg)(NIt,(0,p.A)({},bIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kIt.isMDXComponent=!0;const zIt={toc:[]},PIt="wrapper";function IIt(e){let{components:n,...t}=e;return(0,s.yg)(PIt,(0,p.A)({},zIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}IIt.isMDXComponent=!0;const RIt={toc:[]},WIt="wrapper";function SIt(e){let{components:n,...t}=e;return(0,s.yg)(WIt,(0,p.A)({},RIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}SIt.isMDXComponent=!0;const BIt={toc:[]},GIt="wrapper";function EIt(e){let{components:n,...t}=e;return(0,s.yg)(GIt,(0,p.A)({},BIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}EIt.isMDXComponent=!0;const OIt={toc:[]},UIt="wrapper";function FIt(e){let{components:n,...t}=e;return(0,s.yg)(UIt,(0,p.A)({},OIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}FIt.isMDXComponent=!0;const VIt={toc:[]},qIt="wrapper";function jIt(e){let{components:n,...t}=e;return(0,s.yg)(qIt,(0,p.A)({},VIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}jIt.isMDXComponent=!0;const HIt={toc:[]},YIt="wrapper";function QIt(e){let{components:n,...t}=e;return(0,s.yg)(YIt,(0,p.A)({},HIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}QIt.isMDXComponent=!0;const $It={toc:[]},KIt="wrapper";function JIt(e){let{components:n,...t}=e;return(0,s.yg)(KIt,(0,p.A)({},$It,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}JIt.isMDXComponent=!0;const ZIt={toc:[]},eRt="wrapper";function nRt(e){let{components:n,...t}=e;return(0,s.yg)(eRt,(0,p.A)({},ZIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}nRt.isMDXComponent=!0;const tRt={toc:[]},oRt="wrapper";function pRt(e){let{components:n,...t}=e;return(0,s.yg)(oRt,(0,p.A)({},tRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}pRt.isMDXComponent=!0;const rRt={toc:[]},sRt="wrapper";function cRt(e){let{components:n,...t}=e;return(0,s.yg)(sRt,(0,p.A)({},rRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}cRt.isMDXComponent=!0;const aRt={toc:[]},iRt="wrapper";function lRt(e){let{components:n,...t}=e;return(0,s.yg)(iRt,(0,p.A)({},aRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lRt.isMDXComponent=!0;const uRt={toc:[]},mRt="wrapper";function yRt(e){let{components:n,...t}=e;return(0,s.yg)(mRt,(0,p.A)({},uRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}yRt.isMDXComponent=!0;const dRt={toc:[]},hRt="wrapper";function gRt(e){let{components:n,...t}=e;return(0,s.yg)(hRt,(0,p.A)({},dRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}gRt.isMDXComponent=!0;const fRt={toc:[]},DRt="wrapper";function MRt(e){let{components:n,...t}=e;return(0,s.yg)(DRt,(0,p.A)({},fRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}MRt.isMDXComponent=!0;const XRt={toc:[]},_Rt="wrapper";function wRt(e){let{components:n,...t}=e;return(0,s.yg)(_Rt,(0,p.A)({},XRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}wRt.isMDXComponent=!0;const TRt={toc:[]},CRt="wrapper";function xRt(e){let{components:n,...t}=e;return(0,s.yg)(CRt,(0,p.A)({},TRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}xRt.isMDXComponent=!0;const ARt={toc:[]},vRt="wrapper";function LRt(e){let{components:n,...t}=e;return(0,s.yg)(vRt,(0,p.A)({},ARt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LRt.isMDXComponent=!0;const bRt={toc:[]},NRt="wrapper";function kRt(e){let{components:n,...t}=e;return(0,s.yg)(NRt,(0,p.A)({},bRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}kRt.isMDXComponent=!0;const zRt={toc:[]},PRt="wrapper";function IRt(e){let{components:n,...t}=e;return(0,s.yg)(PRt,(0,p.A)({},zRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}IRt.isMDXComponent=!0;const RRt={toc:[]},WRt="wrapper";function SRt(e){let{components:n,...t}=e;return(0,s.yg)(WRt,(0,p.A)({},RRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}SRt.isMDXComponent=!0;const BRt={toc:[]},GRt="wrapper";function ERt(e){let{components:n,...t}=e;return(0,s.yg)(GRt,(0,p.A)({},BRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ERt.isMDXComponent=!0;const ORt={toc:[]},URt="wrapper";function FRt(e){let{components:n,...t}=e;return(0,s.yg)(URt,(0,p.A)({},ORt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}FRt.isMDXComponent=!0;const VRt={toc:[]},qRt="wrapper";function jRt(e){let{components:n,...t}=e;return(0,s.yg)(qRt,(0,p.A)({},VRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}jRt.isMDXComponent=!0;const HRt={toc:[]},YRt="wrapper";function QRt(e){let{components:n,...t}=e;return(0,s.yg)(YRt,(0,p.A)({},HRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}QRt.isMDXComponent=!0;const $Rt={toc:[]},KRt="wrapper";function JRt(e){let{components:n,...t}=e;return(0,s.yg)(KRt,(0,p.A)({},$Rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}JRt.isMDXComponent=!0;const ZRt={toc:[]},eWt="wrapper";function nWt(e){let{components:n,...t}=e;return(0,s.yg)(eWt,(0,p.A)({},ZRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}nWt.isMDXComponent=!0;const tWt={toc:[]},oWt="wrapper";function pWt(e){let{components:n,...t}=e;return(0,s.yg)(oWt,(0,p.A)({},tWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pWt.isMDXComponent=!0;const rWt={toc:[]},sWt="wrapper";function cWt(e){let{components:n,...t}=e;return(0,s.yg)(sWt,(0,p.A)({},rWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}cWt.isMDXComponent=!0;const aWt={toc:[]},iWt="wrapper";function lWt(e){let{components:n,...t}=e;return(0,s.yg)(iWt,(0,p.A)({},aWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}lWt.isMDXComponent=!0;const uWt={toc:[]},mWt="wrapper";function yWt(e){let{components:n,...t}=e;return(0,s.yg)(mWt,(0,p.A)({},uWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}yWt.isMDXComponent=!0;const dWt={toc:[]},hWt="wrapper";function gWt(e){let{components:n,...t}=e;return(0,s.yg)(hWt,(0,p.A)({},dWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}gWt.isMDXComponent=!0;const fWt={toc:[]},DWt="wrapper";function MWt(e){let{components:n,...t}=e;return(0,s.yg)(DWt,(0,p.A)({},fWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}MWt.isMDXComponent=!0;const XWt={toc:[]},_Wt="wrapper";function wWt(e){let{components:n,...t}=e;return(0,s.yg)(_Wt,(0,p.A)({},XWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}wWt.isMDXComponent=!0;const TWt={toc:[]},CWt="wrapper";function xWt(e){let{components:n,...t}=e;return(0,s.yg)(CWt,(0,p.A)({},TWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}xWt.isMDXComponent=!0;const AWt={toc:[]},vWt="wrapper";function LWt(e){let{components:n,...t}=e;return(0,s.yg)(vWt,(0,p.A)({},AWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}LWt.isMDXComponent=!0;const bWt={toc:[]},NWt="wrapper";function kWt(e){let{components:n,...t}=e;return(0,s.yg)(NWt,(0,p.A)({},bWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}kWt.isMDXComponent=!0;const zWt={toc:[]},PWt="wrapper";function IWt(e){let{components:n,...t}=e;return(0,s.yg)(PWt,(0,p.A)({},zWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}IWt.isMDXComponent=!0;const RWt={toc:[]},WWt="wrapper";function SWt(e){let{components:n,...t}=e;return(0,s.yg)(WWt,(0,p.A)({},RWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}SWt.isMDXComponent=!0;const BWt={toc:[]},GWt="wrapper";function EWt(e){let{components:n,...t}=e;return(0,s.yg)(GWt,(0,p.A)({},BWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}EWt.isMDXComponent=!0;const OWt={toc:[]},UWt="wrapper";function FWt(e){let{components:n,...t}=e;return(0,s.yg)(UWt,(0,p.A)({},OWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}FWt.isMDXComponent=!0;const VWt={toc:[]},qWt="wrapper";function jWt(e){let{components:n,...t}=e;return(0,s.yg)(qWt,(0,p.A)({},VWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}jWt.isMDXComponent=!0;const HWt={toc:[]},YWt="wrapper";function QWt(e){let{components:n,...t}=e;return(0,s.yg)(YWt,(0,p.A)({},HWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}QWt.isMDXComponent=!0;const $Wt={toc:[]},KWt="wrapper";function JWt(e){let{components:n,...t}=e;return(0,s.yg)(KWt,(0,p.A)({},$Wt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}JWt.isMDXComponent=!0;const ZWt={toc:[]},eSt="wrapper";function nSt(e){let{components:n,...t}=e;return(0,s.yg)(eSt,(0,p.A)({},ZWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}nSt.isMDXComponent=!0;const tSt={toc:[]},oSt="wrapper";function pSt(e){let{components:n,...t}=e;return(0,s.yg)(oSt,(0,p.A)({},tSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}pSt.isMDXComponent=!0;const rSt={toc:[]},sSt="wrapper";function cSt(e){let{components:n,...t}=e;return(0,s.yg)(sSt,(0,p.A)({},rSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}cSt.isMDXComponent=!0;const aSt={toc:[]},iSt="wrapper";function lSt(e){let{components:n,...t}=e;return(0,s.yg)(iSt,(0,p.A)({},aSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}lSt.isMDXComponent=!0;const uSt={toc:[]},mSt="wrapper";function ySt(e){let{components:n,...t}=e;return(0,s.yg)(mSt,(0,p.A)({},uSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}ySt.isMDXComponent=!0;const dSt={toc:[]},hSt="wrapper";function gSt(e){let{components:n,...t}=e;return(0,s.yg)(hSt,(0,p.A)({},dSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}gSt.isMDXComponent=!0;const fSt={toc:[]},DSt="wrapper";function MSt(e){let{components:n,...t}=e;return(0,s.yg)(DSt,(0,p.A)({},fSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}MSt.isMDXComponent=!0;const XSt={toc:[]},_St="wrapper";function wSt(e){let{components:n,...t}=e;return(0,s.yg)(_St,(0,p.A)({},XSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}wSt.isMDXComponent=!0;const TSt={toc:[]},CSt="wrapper";function xSt(e){let{components:n,...t}=e;return(0,s.yg)(CSt,(0,p.A)({},TSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}xSt.isMDXComponent=!0;const ASt={toc:[]},vSt="wrapper";function LSt(e){let{components:n,...t}=e;return(0,s.yg)(vSt,(0,p.A)({},ASt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}LSt.isMDXComponent=!0;const bSt={toc:[]},NSt="wrapper";function kSt(e){let{components:n,...t}=e;return(0,s.yg)(NSt,(0,p.A)({},bSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}kSt.isMDXComponent=!0;const zSt={toc:[]},PSt="wrapper";function ISt(e){let{components:n,...t}=e;return(0,s.yg)(PSt,(0,p.A)({},zSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}ISt.isMDXComponent=!0;const RSt={toc:[]},WSt="wrapper";function SSt(e){let{components:n,...t}=e;return(0,s.yg)(WSt,(0,p.A)({},RSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}SSt.isMDXComponent=!0;const BSt={toc:[]},GSt="wrapper";function ESt(e){let{components:n,...t}=e;return(0,s.yg)(GSt,(0,p.A)({},BSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}ESt.isMDXComponent=!0;const OSt={toc:[]},USt="wrapper";function FSt(e){let{components:n,...t}=e;return(0,s.yg)(USt,(0,p.A)({},OSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}FSt.isMDXComponent=!0;const VSt={toc:[]},qSt="wrapper";function jSt(e){let{components:n,...t}=e;return(0,s.yg)(qSt,(0,p.A)({},VSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}jSt.isMDXComponent=!0;const HSt={toc:[]},YSt="wrapper";function QSt(e){let{components:n,...t}=e;return(0,s.yg)(YSt,(0,p.A)({},HSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}QSt.isMDXComponent=!0;const $St={toc:[]},KSt="wrapper";function JSt(e){let{components:n,...t}=e;return(0,s.yg)(KSt,(0,p.A)({},$St,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}JSt.isMDXComponent=!0;const ZSt={toc:[]},eBt="wrapper";function nBt(e){let{components:n,...t}=e;return(0,s.yg)(eBt,(0,p.A)({},ZSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}nBt.isMDXComponent=!0;const tBt={toc:[]},oBt="wrapper";function pBt(e){let{components:n,...t}=e;return(0,s.yg)(oBt,(0,p.A)({},tBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}pBt.isMDXComponent=!0;const rBt={toc:[]},sBt="wrapper";function cBt(e){let{components:n,...t}=e;return(0,s.yg)(sBt,(0,p.A)({},rBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}cBt.isMDXComponent=!0;const aBt={toc:[]},iBt="wrapper";function lBt(e){let{components:n,...t}=e;return(0,s.yg)(iBt,(0,p.A)({},aBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}lBt.isMDXComponent=!0;const uBt={toc:[]},mBt="wrapper";function yBt(e){let{components:n,...t}=e;return(0,s.yg)(mBt,(0,p.A)({},uBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}yBt.isMDXComponent=!0;const dBt={toc:[]},hBt="wrapper";function gBt(e){let{components:n,...t}=e;return(0,s.yg)(hBt,(0,p.A)({},dBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}gBt.isMDXComponent=!0;const fBt={toc:[]},DBt="wrapper";function MBt(e){let{components:n,...t}=e;return(0,s.yg)(DBt,(0,p.A)({},fBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}MBt.isMDXComponent=!0;const XBt={toc:[]},_Bt="wrapper";function wBt(e){let{components:n,...t}=e;return(0,s.yg)(_Bt,(0,p.A)({},XBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wBt.isMDXComponent=!0;const TBt={toc:[]},CBt="wrapper";function xBt(e){let{components:n,...t}=e;return(0,s.yg)(CBt,(0,p.A)({},TBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}xBt.isMDXComponent=!0;const ABt={toc:[]},vBt="wrapper";function LBt(e){let{components:n,...t}=e;return(0,s.yg)(vBt,(0,p.A)({},ABt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}LBt.isMDXComponent=!0;const bBt={toc:[]},NBt="wrapper";function kBt(e){let{components:n,...t}=e;return(0,s.yg)(NBt,(0,p.A)({},bBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}kBt.isMDXComponent=!0;const zBt={toc:[]},PBt="wrapper";function IBt(e){let{components:n,...t}=e;return(0,s.yg)(PBt,(0,p.A)({},zBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}IBt.isMDXComponent=!0;const RBt={toc:[]},WBt="wrapper";function SBt(e){let{components:n,...t}=e;return(0,s.yg)(WBt,(0,p.A)({},RBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}SBt.isMDXComponent=!0;const BBt={toc:[]},GBt="wrapper";function EBt(e){let{components:n,...t}=e;return(0,s.yg)(GBt,(0,p.A)({},BBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}EBt.isMDXComponent=!0;const OBt={toc:[]},UBt="wrapper";function FBt(e){let{components:n,...t}=e;return(0,s.yg)(UBt,(0,p.A)({},OBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}FBt.isMDXComponent=!0;const VBt={toc:[]},qBt="wrapper";function jBt(e){let{components:n,...t}=e;return(0,s.yg)(qBt,(0,p.A)({},VBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}jBt.isMDXComponent=!0;const HBt={toc:[]},YBt="wrapper";function QBt(e){let{components:n,...t}=e;return(0,s.yg)(YBt,(0,p.A)({},HBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}QBt.isMDXComponent=!0;const $Bt={toc:[]},KBt="wrapper";function JBt(e){let{components:n,...t}=e;return(0,s.yg)(KBt,(0,p.A)({},$Bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}JBt.isMDXComponent=!0;const ZBt={toc:[]},eGt="wrapper";function nGt(e){let{components:n,...t}=e;return(0,s.yg)(eGt,(0,p.A)({},ZBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}nGt.isMDXComponent=!0;const tGt={toc:[]},oGt="wrapper";function pGt(e){let{components:n,...t}=e;return(0,s.yg)(oGt,(0,p.A)({},tGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}pGt.isMDXComponent=!0;const rGt={toc:[]},sGt="wrapper";function cGt(e){let{components:n,...t}=e;return(0,s.yg)(sGt,(0,p.A)({},rGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cGt.isMDXComponent=!0;const aGt={toc:[]},iGt="wrapper";function lGt(e){let{components:n,...t}=e;return(0,s.yg)(iGt,(0,p.A)({},aGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lGt.isMDXComponent=!0;const uGt={toc:[]},mGt="wrapper";function yGt(e){let{components:n,...t}=e;return(0,s.yg)(mGt,(0,p.A)({},uGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}yGt.isMDXComponent=!0;const dGt={toc:[]},hGt="wrapper";function gGt(e){let{components:n,...t}=e;return(0,s.yg)(hGt,(0,p.A)({},dGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}gGt.isMDXComponent=!0;const fGt={toc:[]},DGt="wrapper";function MGt(e){let{components:n,...t}=e;return(0,s.yg)(DGt,(0,p.A)({},fGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}MGt.isMDXComponent=!0;const XGt={toc:[]},_Gt="wrapper";function wGt(e){let{components:n,...t}=e;return(0,s.yg)(_Gt,(0,p.A)({},XGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wGt.isMDXComponent=!0;const TGt={toc:[]},CGt="wrapper";function xGt(e){let{components:n,...t}=e;return(0,s.yg)(CGt,(0,p.A)({},TGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}xGt.isMDXComponent=!0;const AGt={toc:[]},vGt="wrapper";function LGt(e){let{components:n,...t}=e;return(0,s.yg)(vGt,(0,p.A)({},AGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}LGt.isMDXComponent=!0;const bGt={toc:[]},NGt="wrapper";function kGt(e){let{components:n,...t}=e;return(0,s.yg)(NGt,(0,p.A)({},bGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}kGt.isMDXComponent=!0;const zGt={toc:[]},PGt="wrapper";function IGt(e){let{components:n,...t}=e;return(0,s.yg)(PGt,(0,p.A)({},zGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}IGt.isMDXComponent=!0;const RGt={toc:[]},WGt="wrapper";function SGt(e){let{components:n,...t}=e;return(0,s.yg)(WGt,(0,p.A)({},RGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}SGt.isMDXComponent=!0;const BGt={toc:[]},GGt="wrapper";function EGt(e){let{components:n,...t}=e;return(0,s.yg)(GGt,(0,p.A)({},BGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}EGt.isMDXComponent=!0;const OGt={toc:[]},UGt="wrapper";function FGt(e){let{components:n,...t}=e;return(0,s.yg)(UGt,(0,p.A)({},OGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}FGt.isMDXComponent=!0;const VGt={toc:[]},qGt="wrapper";function jGt(e){let{components:n,...t}=e;return(0,s.yg)(qGt,(0,p.A)({},VGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}jGt.isMDXComponent=!0;const HGt={toc:[]},YGt="wrapper";function QGt(e){let{components:n,...t}=e;return(0,s.yg)(YGt,(0,p.A)({},HGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}QGt.isMDXComponent=!0;const $Gt={toc:[]},KGt="wrapper";function JGt(e){let{components:n,...t}=e;return(0,s.yg)(KGt,(0,p.A)({},$Gt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}JGt.isMDXComponent=!0;const ZGt={toc:[]},eEt="wrapper";function nEt(e){let{components:n,...t}=e;return(0,s.yg)(eEt,(0,p.A)({},ZGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nEt.isMDXComponent=!0;const tEt={toc:[]},oEt="wrapper";function pEt(e){let{components:n,...t}=e;return(0,s.yg)(oEt,(0,p.A)({},tEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pEt.isMDXComponent=!0;const rEt={toc:[]},sEt="wrapper";function cEt(e){let{components:n,...t}=e;return(0,s.yg)(sEt,(0,p.A)({},rEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}cEt.isMDXComponent=!0;const aEt={toc:[]},iEt="wrapper";function lEt(e){let{components:n,...t}=e;return(0,s.yg)(iEt,(0,p.A)({},aEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lEt.isMDXComponent=!0;const uEt={toc:[]},mEt="wrapper";function yEt(e){let{components:n,...t}=e;return(0,s.yg)(mEt,(0,p.A)({},uEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}yEt.isMDXComponent=!0;const dEt={toc:[]},hEt="wrapper";function gEt(e){let{components:n,...t}=e;return(0,s.yg)(hEt,(0,p.A)({},dEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.yg)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.yg)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}gEt.isMDXComponent=!0;const fEt={toc:[]},DEt="wrapper";function MEt(e){let{components:n,...t}=e;return(0,s.yg)(DEt,(0,p.A)({},fEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      radius={30}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}MEt.isMDXComponent=!0;const XEt={toc:[]},_Et="wrapper";function wEt(e){let{components:n,...t}=e;return(0,s.yg)(_Et,(0,p.A)({},XEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing regular polygons."))}wEt.isMDXComponent=!0;const TEt={toc:[]},CEt="wrapper";function xEt(e){let{components:n,...t}=e;return(0,s.yg)(CEt,(0,p.A)({},TEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}xEt.isMDXComponent=!0;const AEt={toc:[]},vEt="wrapper";function LEt(e){let{components:n,...t}=e;return(0,s.yg)(vEt,(0,p.A)({},AEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}LEt.isMDXComponent=!0;const bEt={toc:[]},NEt="wrapper";function kEt(e){let{components:n,...t}=e;return(0,s.yg)(NEt,(0,p.A)({},bEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}kEt.isMDXComponent=!0;const zEt={toc:[]},PEt="wrapper";function IEt(e){let{components:n,...t}=e;return(0,s.yg)(PEt,(0,p.A)({},zEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}IEt.isMDXComponent=!0;const REt={toc:[]},WEt="wrapper";function SEt(e){let{components:n,...t}=e;return(0,s.yg)(WEt,(0,p.A)({},REt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}SEt.isMDXComponent=!0;const BEt={toc:[]},GEt="wrapper";function EEt(e){let{components:n,...t}=e;return(0,s.yg)(GEt,(0,p.A)({},BEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}EEt.isMDXComponent=!0;const OEt={toc:[]},UEt="wrapper";function FEt(e){let{components:n,...t}=e;return(0,s.yg)(UEt,(0,p.A)({},OEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}FEt.isMDXComponent=!0;const VEt={toc:[]},qEt="wrapper";function jEt(e){let{components:n,...t}=e;return(0,s.yg)(qEt,(0,p.A)({},VEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}jEt.isMDXComponent=!0;const HEt={toc:[]},YEt="wrapper";function QEt(e){let{components:n,...t}=e;return(0,s.yg)(YEt,(0,p.A)({},HEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}QEt.isMDXComponent=!0;const $Et={toc:[]},KEt="wrapper";function JEt(e){let{components:n,...t}=e;return(0,s.yg)(KEt,(0,p.A)({},$Et,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}JEt.isMDXComponent=!0;const ZEt={toc:[]},eOt="wrapper";function nOt(e){let{components:n,...t}=e;return(0,s.yg)(eOt,(0,p.A)({},ZEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}nOt.isMDXComponent=!0;const tOt={toc:[]},oOt="wrapper";function pOt(e){let{components:n,...t}=e;return(0,s.yg)(oOt,(0,p.A)({},tOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}pOt.isMDXComponent=!0;const rOt={toc:[]},sOt="wrapper";function cOt(e){let{components:n,...t}=e;return(0,s.yg)(sOt,(0,p.A)({},rOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cOt.isMDXComponent=!0;const aOt={toc:[]},iOt="wrapper";function lOt(e){let{components:n,...t}=e;return(0,s.yg)(iOt,(0,p.A)({},aOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}lOt.isMDXComponent=!0;const uOt={toc:[]},mOt="wrapper";function yOt(e){let{components:n,...t}=e;return(0,s.yg)(mOt,(0,p.A)({},uOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yOt.isMDXComponent=!0;const dOt={toc:[]},hOt="wrapper";function gOt(e){let{components:n,...t}=e;return(0,s.yg)(hOt,(0,p.A)({},dOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gOt.isMDXComponent=!0;const fOt={toc:[]},DOt="wrapper";function MOt(e){let{components:n,...t}=e;return(0,s.yg)(DOt,(0,p.A)({},fOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}MOt.isMDXComponent=!0;const XOt={toc:[]},_Ot="wrapper";function wOt(e){let{components:n,...t}=e;return(0,s.yg)(_Ot,(0,p.A)({},XOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}wOt.isMDXComponent=!0;const TOt={toc:[]},COt="wrapper";function xOt(e){let{components:n,...t}=e;return(0,s.yg)(COt,(0,p.A)({},TOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}xOt.isMDXComponent=!0;const AOt={toc:[]},vOt="wrapper";function LOt(e){let{components:n,...t}=e;return(0,s.yg)(vOt,(0,p.A)({},AOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}LOt.isMDXComponent=!0;const bOt={toc:[]},NOt="wrapper";function kOt(e){let{components:n,...t}=e;return(0,s.yg)(NOt,(0,p.A)({},bOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kOt.isMDXComponent=!0;const zOt={toc:[]},POt="wrapper";function IOt(e){let{components:n,...t}=e;return(0,s.yg)(POt,(0,p.A)({},zOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}IOt.isMDXComponent=!0;const ROt={toc:[]},WOt="wrapper";function SOt(e){let{components:n,...t}=e;return(0,s.yg)(WOt,(0,p.A)({},ROt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}SOt.isMDXComponent=!0;const BOt={toc:[]},GOt="wrapper";function EOt(e){let{components:n,...t}=e;return(0,s.yg)(GOt,(0,p.A)({},BOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}EOt.isMDXComponent=!0;const OOt={toc:[]},UOt="wrapper";function FOt(e){let{components:n,...t}=e;return(0,s.yg)(UOt,(0,p.A)({},OOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}FOt.isMDXComponent=!0;const VOt={toc:[]},qOt="wrapper";function jOt(e){let{components:n,...t}=e;return(0,s.yg)(qOt,(0,p.A)({},VOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}jOt.isMDXComponent=!0;const HOt={toc:[]},YOt="wrapper";function QOt(e){let{components:n,...t}=e;return(0,s.yg)(YOt,(0,p.A)({},HOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}QOt.isMDXComponent=!0;const $Ot={toc:[]},KOt="wrapper";function JOt(e){let{components:n,...t}=e;return(0,s.yg)(KOt,(0,p.A)({},$Ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}JOt.isMDXComponent=!0;const ZOt={toc:[]},eUt="wrapper";function nUt(e){let{components:n,...t}=e;return(0,s.yg)(eUt,(0,p.A)({},ZOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nUt.isMDXComponent=!0;const tUt={toc:[]},oUt="wrapper";function pUt(e){let{components:n,...t}=e;return(0,s.yg)(oUt,(0,p.A)({},tUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}pUt.isMDXComponent=!0;const rUt={toc:[]},sUt="wrapper";function cUt(e){let{components:n,...t}=e;return(0,s.yg)(sUt,(0,p.A)({},rUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}cUt.isMDXComponent=!0;const aUt={toc:[]},iUt="wrapper";function lUt(e){let{components:n,...t}=e;return(0,s.yg)(iUt,(0,p.A)({},aUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}lUt.isMDXComponent=!0;const uUt={toc:[]},mUt="wrapper";function yUt(e){let{components:n,...t}=e;return(0,s.yg)(mUt,(0,p.A)({},uUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}yUt.isMDXComponent=!0;const dUt={toc:[]},hUt="wrapper";function gUt(e){let{components:n,...t}=e;return(0,s.yg)(hUt,(0,p.A)({},dUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}gUt.isMDXComponent=!0;const fUt={toc:[]},DUt="wrapper";function MUt(e){let{components:n,...t}=e;return(0,s.yg)(DUt,(0,p.A)({},fUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  radius={30}\n  size={320}\n  sides={3}\n  stroke={'#fff'}\n  lineWidth={8}\n/>\n")))}MUt.isMDXComponent=!0;const XUt={toc:[]},_Ut="wrapper";function wUt(e){let{components:n,...t}=e;return(0,s.yg)(_Ut,(0,p.A)({},XUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the polygon's corners."))}wUt.isMDXComponent=!0;const TUt={toc:[]},CUt="wrapper";function xUt(e){let{components:n,...t}=e;return(0,s.yg)(CUt,(0,p.A)({},TUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}xUt.isMDXComponent=!0;const AUt={toc:[]},vUt="wrapper";function LUt(e){let{components:n,...t}=e;return(0,s.yg)(vUt,(0,p.A)({},AUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}LUt.isMDXComponent=!0;const bUt={toc:[]},NUt="wrapper";function kUt(e){let{components:n,...t}=e;return(0,s.yg)(NUt,(0,p.A)({},bUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kUt.isMDXComponent=!0;const zUt={toc:[]},PUt="wrapper";function IUt(e){let{components:n,...t}=e;return(0,s.yg)(PUt,(0,p.A)({},zUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}IUt.isMDXComponent=!0;const RUt={toc:[]},WUt="wrapper";function SUt(e){let{components:n,...t}=e;return(0,s.yg)(WUt,(0,p.A)({},RUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}SUt.isMDXComponent=!0;const BUt={toc:[]},GUt="wrapper";function EUt(e){let{components:n,...t}=e;return(0,s.yg)(GUt,(0,p.A)({},BUt,t,{components:n,mdxType:"MDXLayout"}))}EUt.isMDXComponent=!0;const OUt={toc:[]},UUt="wrapper";function FUt(e){let{components:n,...t}=e;return(0,s.yg)(UUt,(0,p.A)({},OUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"For example, a value of 6 creates a hexagon."))}FUt.isMDXComponent=!0;const VUt={toc:[]},qUt="wrapper";function jUt(e){let{components:n,...t}=e;return(0,s.yg)(qUt,(0,p.A)({},VUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}jUt.isMDXComponent=!0;const HUt={toc:[]},YUt="wrapper";function QUt(e){let{components:n,...t}=e;return(0,s.yg)(YUt,(0,p.A)({},HUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of sides of the polygon."))}QUt.isMDXComponent=!0;const $Ut={toc:[]},KUt="wrapper";function JUt(e){let{components:n,...t}=e;return(0,s.yg)(KUt,(0,p.A)({},$Ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}JUt.isMDXComponent=!0;const ZUt={toc:[]},eFt="wrapper";function nFt(e){let{components:n,...t}=e;return(0,s.yg)(eFt,(0,p.A)({},ZUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nFt.isMDXComponent=!0;const tFt={toc:[]},oFt="wrapper";function pFt(e){let{components:n,...t}=e;return(0,s.yg)(oFt,(0,p.A)({},tFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}pFt.isMDXComponent=!0;const rFt={toc:[]},sFt="wrapper";function cFt(e){let{components:n,...t}=e;return(0,s.yg)(sFt,(0,p.A)({},rFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}cFt.isMDXComponent=!0;const aFt={toc:[]},iFt="wrapper";function lFt(e){let{components:n,...t}=e;return(0,s.yg)(iFt,(0,p.A)({},aFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}lFt.isMDXComponent=!0;const uFt={toc:[]},mFt="wrapper";function yFt(e){let{components:n,...t}=e;return(0,s.yg)(mFt,(0,p.A)({},uFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}yFt.isMDXComponent=!0;const dFt={toc:[]},hFt="wrapper";function gFt(e){let{components:n,...t}=e;return(0,s.yg)(hFt,(0,p.A)({},dFt,t,{components:n,mdxType:"MDXLayout"}))}gFt.isMDXComponent=!0;const fFt={toc:[]},DFt="wrapper";function MFt(e){let{components:n,...t}=e;return(0,s.yg)(DFt,(0,p.A)({},fFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}MFt.isMDXComponent=!0;const XFt={toc:[]},_Ft="wrapper";function wFt(e){let{components:n,...t}=e;return(0,s.yg)(_Ft,(0,p.A)({},XFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}wFt.isMDXComponent=!0;const TFt={toc:[]},CFt="wrapper";function xFt(e){let{components:n,...t}=e;return(0,s.yg)(CFt,(0,p.A)({},TFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xFt.isMDXComponent=!0;const AFt={toc:[]},vFt="wrapper";function LFt(e){let{components:n,...t}=e;return(0,s.yg)(vFt,(0,p.A)({},AFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}LFt.isMDXComponent=!0;const bFt={toc:[]},NFt="wrapper";function kFt(e){let{components:n,...t}=e;return(0,s.yg)(NFt,(0,p.A)({},bFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kFt.isMDXComponent=!0;const zFt={toc:[]},PFt="wrapper";function IFt(e){let{components:n,...t}=e;return(0,s.yg)(PFt,(0,p.A)({},zFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}IFt.isMDXComponent=!0;const RFt={toc:[]},WFt="wrapper";function SFt(e){let{components:n,...t}=e;return(0,s.yg)(WFt,(0,p.A)({},RFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}SFt.isMDXComponent=!0;const BFt={toc:[]},GFt="wrapper";function EFt(e){let{components:n,...t}=e;return(0,s.yg)(GFt,(0,p.A)({},BFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}EFt.isMDXComponent=!0;const OFt={toc:[]},UFt="wrapper";function FFt(e){let{components:n,...t}=e;return(0,s.yg)(UFt,(0,p.A)({},OFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}FFt.isMDXComponent=!0;const VFt={toc:[]},qFt="wrapper";function jFt(e){let{components:n,...t}=e;return(0,s.yg)(qFt,(0,p.A)({},VFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}jFt.isMDXComponent=!0;const HFt={toc:[]},YFt="wrapper";function QFt(e){let{components:n,...t}=e;return(0,s.yg)(YFt,(0,p.A)({},HFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}QFt.isMDXComponent=!0;const $Ft={toc:[]},KFt="wrapper";function JFt(e){let{components:n,...t}=e;return(0,s.yg)(KFt,(0,p.A)({},$Ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}JFt.isMDXComponent=!0;const ZFt={toc:[]},eVt="wrapper";function nVt(e){let{components:n,...t}=e;return(0,s.yg)(eVt,(0,p.A)({},ZFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}nVt.isMDXComponent=!0;const tVt={toc:[]},oVt="wrapper";function pVt(e){let{components:n,...t}=e;return(0,s.yg)(oVt,(0,p.A)({},tVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}pVt.isMDXComponent=!0;const rVt={toc:[]},sVt="wrapper";function cVt(e){let{components:n,...t}=e;return(0,s.yg)(sVt,(0,p.A)({},rVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}cVt.isMDXComponent=!0;const aVt={toc:[]},iVt="wrapper";function lVt(e){let{components:n,...t}=e;return(0,s.yg)(iVt,(0,p.A)({},aVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}lVt.isMDXComponent=!0;const uVt={toc:[]},mVt="wrapper";function yVt(e){let{components:n,...t}=e;return(0,s.yg)(mVt,(0,p.A)({},uVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}yVt.isMDXComponent=!0;const dVt={toc:[]},hVt="wrapper";function gVt(e){let{components:n,...t}=e;return(0,s.yg)(hVt,(0,p.A)({},dVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}gVt.isMDXComponent=!0;const fVt={toc:[]},DVt="wrapper";function MVt(e){let{components:n,...t}=e;return(0,s.yg)(DVt,(0,p.A)({},fVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}MVt.isMDXComponent=!0;const XVt={toc:[]},_Vt="wrapper";function wVt(e){let{components:n,...t}=e;return(0,s.yg)(_Vt,(0,p.A)({},XVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}wVt.isMDXComponent=!0;const TVt={toc:[]},CVt="wrapper";function xVt(e){let{components:n,...t}=e;return(0,s.yg)(CVt,(0,p.A)({},TVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}xVt.isMDXComponent=!0;const AVt={toc:[]},vVt="wrapper";function LVt(e){let{components:n,...t}=e;return(0,s.yg)(vVt,(0,p.A)({},AVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}LVt.isMDXComponent=!0;const bVt={toc:[]},NVt="wrapper";function kVt(e){let{components:n,...t}=e;return(0,s.yg)(NVt,(0,p.A)({},bVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}kVt.isMDXComponent=!0;const zVt={toc:[]},PVt="wrapper";function IVt(e){let{components:n,...t}=e;return(0,s.yg)(PVt,(0,p.A)({},zVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}IVt.isMDXComponent=!0;const RVt={toc:[]},WVt="wrapper";function SVt(e){let{components:n,...t}=e;return(0,s.yg)(WVt,(0,p.A)({},RVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}SVt.isMDXComponent=!0;const BVt={toc:[]},GVt="wrapper";function EVt(e){let{components:n,...t}=e;return(0,s.yg)(GVt,(0,p.A)({},BVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}EVt.isMDXComponent=!0;const OVt={toc:[]},UVt="wrapper";function FVt(e){let{components:n,...t}=e;return(0,s.yg)(UVt,(0,p.A)({},OVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}FVt.isMDXComponent=!0;const VVt={toc:[]},qVt="wrapper";function jVt(e){let{components:n,...t}=e;return(0,s.yg)(qVt,(0,p.A)({},VVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}jVt.isMDXComponent=!0;const HVt={toc:[]},YVt="wrapper";function QVt(e){let{components:n,...t}=e;return(0,s.yg)(YVt,(0,p.A)({},HVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}QVt.isMDXComponent=!0;const $Vt={toc:[]},KVt="wrapper";function JVt(e){let{components:n,...t}=e;return(0,s.yg)(KVt,(0,p.A)({},$Vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}JVt.isMDXComponent=!0;const ZVt={toc:[]},eqt="wrapper";function nqt(e){let{components:n,...t}=e;return(0,s.yg)(eqt,(0,p.A)({},ZVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}nqt.isMDXComponent=!0;const tqt={toc:[]},oqt="wrapper";function pqt(e){let{components:n,...t}=e;return(0,s.yg)(oqt,(0,p.A)({},tqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}pqt.isMDXComponent=!0;const rqt={toc:[]},sqt="wrapper";function cqt(e){let{components:n,...t}=e;return(0,s.yg)(sqt,(0,p.A)({},rqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}cqt.isMDXComponent=!0;const aqt={toc:[]},iqt="wrapper";function lqt(e){let{components:n,...t}=e;return(0,s.yg)(iqt,(0,p.A)({},aqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}lqt.isMDXComponent=!0;const uqt={toc:[]},mqt="wrapper";function yqt(e){let{components:n,...t}=e;return(0,s.yg)(mqt,(0,p.A)({},uqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}yqt.isMDXComponent=!0;const dqt={toc:[]},hqt="wrapper";function gqt(e){let{components:n,...t}=e;return(0,s.yg)(hqt,(0,p.A)({},dqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}gqt.isMDXComponent=!0;const fqt={toc:[]},Dqt="wrapper";function Mqt(e){let{components:n,...t}=e;return(0,s.yg)(Dqt,(0,p.A)({},fqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Mqt.isMDXComponent=!0;const Xqt={toc:[]},_qt="wrapper";function wqt(e){let{components:n,...t}=e;return(0,s.yg)(_qt,(0,p.A)({},Xqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}wqt.isMDXComponent=!0;const Tqt={toc:[]},Cqt="wrapper";function xqt(e){let{components:n,...t}=e;return(0,s.yg)(Cqt,(0,p.A)({},Tqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}xqt.isMDXComponent=!0;const Aqt={toc:[]},vqt="wrapper";function Lqt(e){let{components:n,...t}=e;return(0,s.yg)(vqt,(0,p.A)({},Aqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Lqt.isMDXComponent=!0;const bqt={toc:[]},Nqt="wrapper";function kqt(e){let{components:n,...t}=e;return(0,s.yg)(Nqt,(0,p.A)({},bqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kqt.isMDXComponent=!0;const zqt={toc:[]},Pqt="wrapper";function Iqt(e){let{components:n,...t}=e;return(0,s.yg)(Pqt,(0,p.A)({},zqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Iqt.isMDXComponent=!0;const Rqt={toc:[]},Wqt="wrapper";function Sqt(e){let{components:n,...t}=e;return(0,s.yg)(Wqt,(0,p.A)({},Rqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Sqt.isMDXComponent=!0;const Bqt={toc:[]},Gqt="wrapper";function Eqt(e){let{components:n,...t}=e;return(0,s.yg)(Gqt,(0,p.A)({},Bqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Eqt.isMDXComponent=!0;const Oqt={toc:[]},Uqt="wrapper";function Fqt(e){let{components:n,...t}=e;return(0,s.yg)(Uqt,(0,p.A)({},Oqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Fqt.isMDXComponent=!0;const Vqt={toc:[]},qqt="wrapper";function jqt(e){let{components:n,...t}=e;return(0,s.yg)(qqt,(0,p.A)({},Vqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}jqt.isMDXComponent=!0;const Hqt={toc:[]},Yqt="wrapper";function Qqt(e){let{components:n,...t}=e;return(0,s.yg)(Yqt,(0,p.A)({},Hqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Qqt.isMDXComponent=!0;const $qt={toc:[]},Kqt="wrapper";function Jqt(e){let{components:n,...t}=e;return(0,s.yg)(Kqt,(0,p.A)({},$qt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Jqt.isMDXComponent=!0;const Zqt={toc:[]},ejt="wrapper";function njt(e){let{components:n,...t}=e;return(0,s.yg)(ejt,(0,p.A)({},Zqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}njt.isMDXComponent=!0;const tjt={toc:[]},ojt="wrapper";function pjt(e){let{components:n,...t}=e;return(0,s.yg)(ojt,(0,p.A)({},tjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}pjt.isMDXComponent=!0;const rjt={toc:[]},sjt="wrapper";function cjt(e){let{components:n,...t}=e;return(0,s.yg)(sjt,(0,p.A)({},rjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}cjt.isMDXComponent=!0;const ajt={toc:[]},ijt="wrapper";function ljt(e){let{components:n,...t}=e;return(0,s.yg)(ijt,(0,p.A)({},ajt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}ljt.isMDXComponent=!0;const ujt={toc:[]},mjt="wrapper";function yjt(e){let{components:n,...t}=e;return(0,s.yg)(mjt,(0,p.A)({},ujt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yjt.isMDXComponent=!0;const djt={toc:[]},hjt="wrapper";function gjt(e){let{components:n,...t}=e;return(0,s.yg)(hjt,(0,p.A)({},djt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gjt.isMDXComponent=!0;const fjt={toc:[]},Djt="wrapper";function Mjt(e){let{components:n,...t}=e;return(0,s.yg)(Djt,(0,p.A)({},fjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Mjt.isMDXComponent=!0;const Xjt={toc:[]},_jt="wrapper";function wjt(e){let{components:n,...t}=e;return(0,s.yg)(_jt,(0,p.A)({},Xjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wjt.isMDXComponent=!0;const Tjt={toc:[]},Cjt="wrapper";function xjt(e){let{components:n,...t}=e;return(0,s.yg)(Cjt,(0,p.A)({},Tjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xjt.isMDXComponent=!0;const Ajt={toc:[]},vjt="wrapper";function Ljt(e){let{components:n,...t}=e;return(0,s.yg)(vjt,(0,p.A)({},Ajt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ljt.isMDXComponent=!0;const bjt={toc:[]},Njt="wrapper";function kjt(e){let{components:n,...t}=e;return(0,s.yg)(Njt,(0,p.A)({},bjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kjt.isMDXComponent=!0;const zjt={toc:[]},Pjt="wrapper";function Ijt(e){let{components:n,...t}=e;return(0,s.yg)(Pjt,(0,p.A)({},zjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ijt.isMDXComponent=!0;const Rjt={toc:[]},Wjt="wrapper";function Sjt(e){let{components:n,...t}=e;return(0,s.yg)(Wjt,(0,p.A)({},Rjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Sjt.isMDXComponent=!0;const Bjt={toc:[]},Gjt="wrapper";function Ejt(e){let{components:n,...t}=e;return(0,s.yg)(Gjt,(0,p.A)({},Bjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ejt.isMDXComponent=!0;const Ojt={toc:[]},Ujt="wrapper";function Fjt(e){let{components:n,...t}=e;return(0,s.yg)(Ujt,(0,p.A)({},Ojt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Fjt.isMDXComponent=!0;const Vjt={toc:[]},qjt="wrapper";function jjt(e){let{components:n,...t}=e;return(0,s.yg)(qjt,(0,p.A)({},Vjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jjt.isMDXComponent=!0;const Hjt={toc:[]},Yjt="wrapper";function Qjt(e){let{components:n,...t}=e;return(0,s.yg)(Yjt,(0,p.A)({},Hjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Qjt.isMDXComponent=!0;const $jt={toc:[]},Kjt="wrapper";function Jjt(e){let{components:n,...t}=e;return(0,s.yg)(Kjt,(0,p.A)({},$jt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jjt.isMDXComponent=!0;const Zjt={toc:[]},eHt="wrapper";function nHt(e){let{components:n,...t}=e;return(0,s.yg)(eHt,(0,p.A)({},Zjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}nHt.isMDXComponent=!0;const tHt={toc:[]},oHt="wrapper";function pHt(e){let{components:n,...t}=e;return(0,s.yg)(oHt,(0,p.A)({},tHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pHt.isMDXComponent=!0;const rHt={toc:[]},sHt="wrapper";function cHt(e){let{components:n,...t}=e;return(0,s.yg)(sHt,(0,p.A)({},rHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}cHt.isMDXComponent=!0;const aHt={toc:[]},iHt="wrapper";function lHt(e){let{components:n,...t}=e;return(0,s.yg)(iHt,(0,p.A)({},aHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lHt.isMDXComponent=!0;const uHt={toc:[]},mHt="wrapper";function yHt(e){let{components:n,...t}=e;return(0,s.yg)(mHt,(0,p.A)({},uHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}yHt.isMDXComponent=!0;const dHt={toc:[]},hHt="wrapper";function gHt(e){let{components:n,...t}=e;return(0,s.yg)(hHt,(0,p.A)({},dHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}gHt.isMDXComponent=!0;const fHt={toc:[]},DHt="wrapper";function MHt(e){let{components:n,...t}=e;return(0,s.yg)(DHt,(0,p.A)({},fHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}MHt.isMDXComponent=!0;const XHt={toc:[]},_Ht="wrapper";function wHt(e){let{components:n,...t}=e;return(0,s.yg)(_Ht,(0,p.A)({},XHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}wHt.isMDXComponent=!0;const THt={toc:[]},CHt="wrapper";function xHt(e){let{components:n,...t}=e;return(0,s.yg)(CHt,(0,p.A)({},THt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}xHt.isMDXComponent=!0;const AHt={toc:[]},vHt="wrapper";function LHt(e){let{components:n,...t}=e;return(0,s.yg)(vHt,(0,p.A)({},AHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}LHt.isMDXComponent=!0;const bHt={toc:[]},NHt="wrapper";function kHt(e){let{components:n,...t}=e;return(0,s.yg)(NHt,(0,p.A)({},bHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kHt.isMDXComponent=!0;const zHt={toc:[]},PHt="wrapper";function IHt(e){let{components:n,...t}=e;return(0,s.yg)(PHt,(0,p.A)({},zHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}IHt.isMDXComponent=!0;const RHt={toc:[]},WHt="wrapper";function SHt(e){let{components:n,...t}=e;return(0,s.yg)(WHt,(0,p.A)({},RHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}SHt.isMDXComponent=!0;const BHt={toc:[]},GHt="wrapper";function EHt(e){let{components:n,...t}=e;return(0,s.yg)(GHt,(0,p.A)({},BHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}EHt.isMDXComponent=!0;const OHt={toc:[]},UHt="wrapper";function FHt(e){let{components:n,...t}=e;return(0,s.yg)(UHt,(0,p.A)({},OHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}FHt.isMDXComponent=!0;const VHt={toc:[]},qHt="wrapper";function jHt(e){let{components:n,...t}=e;return(0,s.yg)(qHt,(0,p.A)({},VHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}jHt.isMDXComponent=!0;const HHt={toc:[]},YHt="wrapper";function QHt(e){let{components:n,...t}=e;return(0,s.yg)(YHt,(0,p.A)({},HHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QHt.isMDXComponent=!0;const $Ht={toc:[]},KHt="wrapper";function JHt(e){let{components:n,...t}=e;return(0,s.yg)(KHt,(0,p.A)({},$Ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}JHt.isMDXComponent=!0;const ZHt={toc:[]},eYt="wrapper";function nYt(e){let{components:n,...t}=e;return(0,s.yg)(eYt,(0,p.A)({},ZHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}nYt.isMDXComponent=!0;const tYt={toc:[]},oYt="wrapper";function pYt(e){let{components:n,...t}=e;return(0,s.yg)(oYt,(0,p.A)({},tYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}pYt.isMDXComponent=!0;const rYt={toc:[]},sYt="wrapper";function cYt(e){let{components:n,...t}=e;return(0,s.yg)(sYt,(0,p.A)({},rYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cYt.isMDXComponent=!0;const aYt={toc:[]},iYt="wrapper";function lYt(e){let{components:n,...t}=e;return(0,s.yg)(iYt,(0,p.A)({},aYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lYt.isMDXComponent=!0;const uYt={toc:[]},mYt="wrapper";function yYt(e){let{components:n,...t}=e;return(0,s.yg)(mYt,(0,p.A)({},uYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}yYt.isMDXComponent=!0;const dYt={toc:[]},hYt="wrapper";function gYt(e){let{components:n,...t}=e;return(0,s.yg)(hYt,(0,p.A)({},dYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}gYt.isMDXComponent=!0;const fYt={toc:[]},DYt="wrapper";function MYt(e){let{components:n,...t}=e;return(0,s.yg)(DYt,(0,p.A)({},fYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}MYt.isMDXComponent=!0;const XYt={toc:[]},_Yt="wrapper";function wYt(e){let{components:n,...t}=e;return(0,s.yg)(_Yt,(0,p.A)({},XYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}wYt.isMDXComponent=!0;const TYt={toc:[]},CYt="wrapper";function xYt(e){let{components:n,...t}=e;return(0,s.yg)(CYt,(0,p.A)({},TYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}xYt.isMDXComponent=!0;const AYt={toc:[]},vYt="wrapper";function LYt(e){let{components:n,...t}=e;return(0,s.yg)(vYt,(0,p.A)({},AYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}LYt.isMDXComponent=!0;const bYt={toc:[]},NYt="wrapper";function kYt(e){let{components:n,...t}=e;return(0,s.yg)(NYt,(0,p.A)({},bYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}kYt.isMDXComponent=!0;const zYt={toc:[]},PYt="wrapper";function IYt(e){let{components:n,...t}=e;return(0,s.yg)(PYt,(0,p.A)({},zYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}IYt.isMDXComponent=!0;const RYt={toc:[]},WYt="wrapper";function SYt(e){let{components:n,...t}=e;return(0,s.yg)(WYt,(0,p.A)({},RYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}SYt.isMDXComponent=!0;const BYt={toc:[]},GYt="wrapper";function EYt(e){let{components:n,...t}=e;return(0,s.yg)(GYt,(0,p.A)({},BYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}EYt.isMDXComponent=!0;const OYt={toc:[]},UYt="wrapper";function FYt(e){let{components:n,...t}=e;return(0,s.yg)(UYt,(0,p.A)({},OYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}FYt.isMDXComponent=!0;const VYt={toc:[]},qYt="wrapper";function jYt(e){let{components:n,...t}=e;return(0,s.yg)(qYt,(0,p.A)({},VYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jYt.isMDXComponent=!0;const HYt={toc:[]},YYt="wrapper";function QYt(e){let{components:n,...t}=e;return(0,s.yg)(YYt,(0,p.A)({},HYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}QYt.isMDXComponent=!0;const $Yt={toc:[]},KYt="wrapper";function JYt(e){let{components:n,...t}=e;return(0,s.yg)(KYt,(0,p.A)({},$Yt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}JYt.isMDXComponent=!0;const ZYt={toc:[]},eQt="wrapper";function nQt(e){let{components:n,...t}=e;return(0,s.yg)(eQt,(0,p.A)({},ZYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nQt.isMDXComponent=!0;const tQt={toc:[]},oQt="wrapper";function pQt(e){let{components:n,...t}=e;return(0,s.yg)(oQt,(0,p.A)({},tQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}pQt.isMDXComponent=!0;const rQt={toc:[]},sQt="wrapper";function cQt(e){let{components:n,...t}=e;return(0,s.yg)(sQt,(0,p.A)({},rQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}cQt.isMDXComponent=!0;const aQt={toc:[]},iQt="wrapper";function lQt(e){let{components:n,...t}=e;return(0,s.yg)(iQt,(0,p.A)({},aQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}lQt.isMDXComponent=!0;const uQt={toc:[]},mQt="wrapper";function yQt(e){let{components:n,...t}=e;return(0,s.yg)(mQt,(0,p.A)({},uQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}yQt.isMDXComponent=!0;const dQt={toc:[]},hQt="wrapper";function gQt(e){let{components:n,...t}=e;return(0,s.yg)(hQt,(0,p.A)({},dQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gQt.isMDXComponent=!0;const fQt={toc:[]},DQt="wrapper";function MQt(e){let{components:n,...t}=e;return(0,s.yg)(DQt,(0,p.A)({},fQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}MQt.isMDXComponent=!0;const XQt={toc:[]},_Qt="wrapper";function wQt(e){let{components:n,...t}=e;return(0,s.yg)(_Qt,(0,p.A)({},XQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wQt.isMDXComponent=!0;const TQt={toc:[]},CQt="wrapper";function xQt(e){let{components:n,...t}=e;return(0,s.yg)(CQt,(0,p.A)({},TQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}xQt.isMDXComponent=!0;const AQt={toc:[]},vQt="wrapper";function LQt(e){let{components:n,...t}=e;return(0,s.yg)(vQt,(0,p.A)({},AQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}LQt.isMDXComponent=!0;const bQt={toc:[]},NQt="wrapper";function kQt(e){let{components:n,...t}=e;return(0,s.yg)(NQt,(0,p.A)({},bQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}kQt.isMDXComponent=!0;const zQt={toc:[]},PQt="wrapper";function IQt(e){let{components:n,...t}=e;return(0,s.yg)(PQt,(0,p.A)({},zQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}IQt.isMDXComponent=!0;const RQt={toc:[]},WQt="wrapper";function SQt(e){let{components:n,...t}=e;return(0,s.yg)(WQt,(0,p.A)({},RQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}SQt.isMDXComponent=!0;const BQt={toc:[]},GQt="wrapper";function EQt(e){let{components:n,...t}=e;return(0,s.yg)(GQt,(0,p.A)({},BQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}EQt.isMDXComponent=!0;const OQt={toc:[]},UQt="wrapper";function FQt(e){let{components:n,...t}=e;return(0,s.yg)(UQt,(0,p.A)({},OQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}FQt.isMDXComponent=!0;const VQt={toc:[]},qQt="wrapper";function jQt(e){let{components:n,...t}=e;return(0,s.yg)(qQt,(0,p.A)({},VQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}jQt.isMDXComponent=!0;const HQt={toc:[]},YQt="wrapper";function QQt(e){let{components:n,...t}=e;return(0,s.yg)(YQt,(0,p.A)({},HQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}QQt.isMDXComponent=!0;const $Qt={toc:[]},KQt="wrapper";function JQt(e){let{components:n,...t}=e;return(0,s.yg)(KQt,(0,p.A)({},$Qt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}JQt.isMDXComponent=!0;const ZQt={toc:[]},e$t="wrapper";function n$t(e){let{components:n,...t}=e;return(0,s.yg)(e$t,(0,p.A)({},ZQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}n$t.isMDXComponent=!0;const t$t={toc:[]},o$t="wrapper";function p$t(e){let{components:n,...t}=e;return(0,s.yg)(o$t,(0,p.A)({},t$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}p$t.isMDXComponent=!0;const r$t={toc:[]},s$t="wrapper";function c$t(e){let{components:n,...t}=e;return(0,s.yg)(s$t,(0,p.A)({},r$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}c$t.isMDXComponent=!0;const a$t={toc:[]},i$t="wrapper";function l$t(e){let{components:n,...t}=e;return(0,s.yg)(i$t,(0,p.A)({},a$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}l$t.isMDXComponent=!0;const u$t={toc:[]},m$t="wrapper";function y$t(e){let{components:n,...t}=e;return(0,s.yg)(m$t,(0,p.A)({},u$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}y$t.isMDXComponent=!0;const d$t={toc:[]},h$t="wrapper";function g$t(e){let{components:n,...t}=e;return(0,s.yg)(h$t,(0,p.A)({},d$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}g$t.isMDXComponent=!0;const f$t={toc:[]},D$t="wrapper";function M$t(e){let{components:n,...t}=e;return(0,s.yg)(D$t,(0,p.A)({},f$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}M$t.isMDXComponent=!0;const X$t={toc:[]},_$t="wrapper";function w$t(e){let{components:n,...t}=e;return(0,s.yg)(_$t,(0,p.A)({},X$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}w$t.isMDXComponent=!0;const T$t={toc:[]},C$t="wrapper";function x$t(e){let{components:n,...t}=e;return(0,s.yg)(C$t,(0,p.A)({},T$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}x$t.isMDXComponent=!0;const A$t={toc:[]},v$t="wrapper";function L$t(e){let{components:n,...t}=e;return(0,s.yg)(v$t,(0,p.A)({},A$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}L$t.isMDXComponent=!0;const b$t={toc:[]},N$t="wrapper";function k$t(e){let{components:n,...t}=e;return(0,s.yg)(N$t,(0,p.A)({},b$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}k$t.isMDXComponent=!0;const z$t={toc:[]},P$t="wrapper";function I$t(e){let{components:n,...t}=e;return(0,s.yg)(P$t,(0,p.A)({},z$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}I$t.isMDXComponent=!0;const R$t={toc:[]},W$t="wrapper";function S$t(e){let{components:n,...t}=e;return(0,s.yg)(W$t,(0,p.A)({},R$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}S$t.isMDXComponent=!0;const B$t={toc:[]},G$t="wrapper";function E$t(e){let{components:n,...t}=e;return(0,s.yg)(G$t,(0,p.A)({},B$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}E$t.isMDXComponent=!0;const O$t={toc:[]},U$t="wrapper";function F$t(e){let{components:n,...t}=e;return(0,s.yg)(U$t,(0,p.A)({},O$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}F$t.isMDXComponent=!0;const V$t={toc:[]},q$t="wrapper";function j$t(e){let{components:n,...t}=e;return(0,s.yg)(q$t,(0,p.A)({},V$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}j$t.isMDXComponent=!0;const H$t={toc:[]},Y$t="wrapper";function Q$t(e){let{components:n,...t}=e;return(0,s.yg)(Y$t,(0,p.A)({},H$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Q$t.isMDXComponent=!0;const $$t={toc:[]},K$t="wrapper";function J$t(e){let{components:n,...t}=e;return(0,s.yg)(K$t,(0,p.A)({},$$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}J$t.isMDXComponent=!0;const Z$t={toc:[]},eKt="wrapper";function nKt(e){let{components:n,...t}=e;return(0,s.yg)(eKt,(0,p.A)({},Z$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}nKt.isMDXComponent=!0;const tKt={toc:[]},oKt="wrapper";function pKt(e){let{components:n,...t}=e;return(0,s.yg)(oKt,(0,p.A)({},tKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pKt.isMDXComponent=!0;const rKt={toc:[]},sKt="wrapper";function cKt(e){let{components:n,...t}=e;return(0,s.yg)(sKt,(0,p.A)({},rKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}cKt.isMDXComponent=!0;const aKt={toc:[]},iKt="wrapper";function lKt(e){let{components:n,...t}=e;return(0,s.yg)(iKt,(0,p.A)({},aKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}lKt.isMDXComponent=!0;const uKt={toc:[]},mKt="wrapper";function yKt(e){let{components:n,...t}=e;return(0,s.yg)(mKt,(0,p.A)({},uKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}yKt.isMDXComponent=!0;const dKt={toc:[]},hKt="wrapper";function gKt(e){let{components:n,...t}=e;return(0,s.yg)(hKt,(0,p.A)({},dKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gKt.isMDXComponent=!0;const fKt={toc:[]},DKt="wrapper";function MKt(e){let{components:n,...t}=e;return(0,s.yg)(DKt,(0,p.A)({},fKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}MKt.isMDXComponent=!0;const XKt={toc:[]},_Kt="wrapper";function wKt(e){let{components:n,...t}=e;return(0,s.yg)(_Kt,(0,p.A)({},XKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}wKt.isMDXComponent=!0;const TKt={toc:[]},CKt="wrapper";function xKt(e){let{components:n,...t}=e;return(0,s.yg)(CKt,(0,p.A)({},TKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xKt.isMDXComponent=!0;const AKt={toc:[]},vKt="wrapper";function LKt(e){let{components:n,...t}=e;return(0,s.yg)(vKt,(0,p.A)({},AKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}LKt.isMDXComponent=!0;const bKt={toc:[]},NKt="wrapper";function kKt(e){let{components:n,...t}=e;return(0,s.yg)(NKt,(0,p.A)({},bKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kKt.isMDXComponent=!0;const zKt={toc:[]},PKt="wrapper";function IKt(e){let{components:n,...t}=e;return(0,s.yg)(PKt,(0,p.A)({},zKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}IKt.isMDXComponent=!0;const RKt={toc:[]},WKt="wrapper";function SKt(e){let{components:n,...t}=e;return(0,s.yg)(WKt,(0,p.A)({},RKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}SKt.isMDXComponent=!0;const BKt={toc:[]},GKt="wrapper";function EKt(e){let{components:n,...t}=e;return(0,s.yg)(GKt,(0,p.A)({},BKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}EKt.isMDXComponent=!0;const OKt={toc:[]},UKt="wrapper";function FKt(e){let{components:n,...t}=e;return(0,s.yg)(UKt,(0,p.A)({},OKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}FKt.isMDXComponent=!0;const VKt={toc:[]},qKt="wrapper";function jKt(e){let{components:n,...t}=e;return(0,s.yg)(qKt,(0,p.A)({},VKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}jKt.isMDXComponent=!0;const HKt={toc:[]},YKt="wrapper";function QKt(e){let{components:n,...t}=e;return(0,s.yg)(YKt,(0,p.A)({},HKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}QKt.isMDXComponent=!0;const $Kt={toc:[]},KKt="wrapper";function JKt(e){let{components:n,...t}=e;return(0,s.yg)(KKt,(0,p.A)({},$Kt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JKt.isMDXComponent=!0;const ZKt={toc:[]},eJt="wrapper";function nJt(e){let{components:n,...t}=e;return(0,s.yg)(eJt,(0,p.A)({},ZKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}nJt.isMDXComponent=!0;const tJt={toc:[]},oJt="wrapper";function pJt(e){let{components:n,...t}=e;return(0,s.yg)(oJt,(0,p.A)({},tJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}pJt.isMDXComponent=!0;const rJt={toc:[]},sJt="wrapper";function cJt(e){let{components:n,...t}=e;return(0,s.yg)(sJt,(0,p.A)({},rJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cJt.isMDXComponent=!0;const aJt={toc:[]},iJt="wrapper";function lJt(e){let{components:n,...t}=e;return(0,s.yg)(iJt,(0,p.A)({},aJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lJt.isMDXComponent=!0;const uJt={toc:[]},mJt="wrapper";function yJt(e){let{components:n,...t}=e;return(0,s.yg)(mJt,(0,p.A)({},uJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}yJt.isMDXComponent=!0;const dJt={toc:[]},hJt="wrapper";function gJt(e){let{components:n,...t}=e;return(0,s.yg)(hJt,(0,p.A)({},dJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gJt.isMDXComponent=!0;const fJt={toc:[]},DJt="wrapper";function MJt(e){let{components:n,...t}=e;return(0,s.yg)(DJt,(0,p.A)({},fJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}MJt.isMDXComponent=!0;const XJt={toc:[]},_Jt="wrapper";function wJt(e){let{components:n,...t}=e;return(0,s.yg)(_Jt,(0,p.A)({},XJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wJt.isMDXComponent=!0;const TJt={toc:[]},CJt="wrapper";function xJt(e){let{components:n,...t}=e;return(0,s.yg)(CJt,(0,p.A)({},TJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xJt.isMDXComponent=!0;const AJt={toc:[]},vJt="wrapper";function LJt(e){let{components:n,...t}=e;return(0,s.yg)(vJt,(0,p.A)({},AJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}LJt.isMDXComponent=!0;const bJt={toc:[]},NJt="wrapper";function kJt(e){let{components:n,...t}=e;return(0,s.yg)(NJt,(0,p.A)({},bJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kJt.isMDXComponent=!0;const zJt={toc:[]},PJt="wrapper";function IJt(e){let{components:n,...t}=e;return(0,s.yg)(PJt,(0,p.A)({},zJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}IJt.isMDXComponent=!0;const RJt={toc:[]},WJt="wrapper";function SJt(e){let{components:n,...t}=e;return(0,s.yg)(WJt,(0,p.A)({},RJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}SJt.isMDXComponent=!0;const BJt={toc:[]},GJt="wrapper";function EJt(e){let{components:n,...t}=e;return(0,s.yg)(GJt,(0,p.A)({},BJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}EJt.isMDXComponent=!0;const OJt={toc:[]},UJt="wrapper";function FJt(e){let{components:n,...t}=e;return(0,s.yg)(UJt,(0,p.A)({},OJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}FJt.isMDXComponent=!0;const VJt={toc:[]},qJt="wrapper";function jJt(e){let{components:n,...t}=e;return(0,s.yg)(qJt,(0,p.A)({},VJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}jJt.isMDXComponent=!0;const HJt={toc:[]},YJt="wrapper";function QJt(e){let{components:n,...t}=e;return(0,s.yg)(YJt,(0,p.A)({},HJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}QJt.isMDXComponent=!0;const $Jt={toc:[]},KJt="wrapper";function JJt(e){let{components:n,...t}=e;return(0,s.yg)(KJt,(0,p.A)({},$Jt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}JJt.isMDXComponent=!0;const ZJt={toc:[]},eZt="wrapper";function nZt(e){let{components:n,...t}=e;return(0,s.yg)(eZt,(0,p.A)({},ZJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}nZt.isMDXComponent=!0;const tZt={toc:[]},oZt="wrapper";function pZt(e){let{components:n,...t}=e;return(0,s.yg)(oZt,(0,p.A)({},tZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}pZt.isMDXComponent=!0;const rZt={toc:[]},sZt="wrapper";function cZt(e){let{components:n,...t}=e;return(0,s.yg)(sZt,(0,p.A)({},rZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}cZt.isMDXComponent=!0;const aZt={toc:[]},iZt="wrapper";function lZt(e){let{components:n,...t}=e;return(0,s.yg)(iZt,(0,p.A)({},aZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}lZt.isMDXComponent=!0;const uZt={toc:[]},mZt="wrapper";function yZt(e){let{components:n,...t}=e;return(0,s.yg)(mZt,(0,p.A)({},uZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}yZt.isMDXComponent=!0;const dZt={toc:[]},hZt="wrapper";function gZt(e){let{components:n,...t}=e;return(0,s.yg)(hZt,(0,p.A)({},dZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}gZt.isMDXComponent=!0;const fZt={toc:[]},DZt="wrapper";function MZt(e){let{components:n,...t}=e;return(0,s.yg)(DZt,(0,p.A)({},fZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}MZt.isMDXComponent=!0;const XZt={toc:[]},_Zt="wrapper";function wZt(e){let{components:n,...t}=e;return(0,s.yg)(_Zt,(0,p.A)({},XZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}wZt.isMDXComponent=!0;const TZt={toc:[]},CZt="wrapper";function xZt(e){let{components:n,...t}=e;return(0,s.yg)(CZt,(0,p.A)({},TZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}xZt.isMDXComponent=!0;const AZt={toc:[]},vZt="wrapper";function LZt(e){let{components:n,...t}=e;return(0,s.yg)(vZt,(0,p.A)({},AZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}LZt.isMDXComponent=!0;const bZt={toc:[]},NZt="wrapper";function kZt(e){let{components:n,...t}=e;return(0,s.yg)(NZt,(0,p.A)({},bZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kZt.isMDXComponent=!0;const zZt={toc:[]},PZt="wrapper";function IZt(e){let{components:n,...t}=e;return(0,s.yg)(PZt,(0,p.A)({},zZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IZt.isMDXComponent=!0;const RZt={toc:[]},WZt="wrapper";function SZt(e){let{components:n,...t}=e;return(0,s.yg)(WZt,(0,p.A)({},RZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}SZt.isMDXComponent=!0;const BZt={toc:[]},GZt="wrapper";function EZt(e){let{components:n,...t}=e;return(0,s.yg)(GZt,(0,p.A)({},BZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}EZt.isMDXComponent=!0;const OZt={toc:[]},UZt="wrapper";function FZt(e){let{components:n,...t}=e;return(0,s.yg)(UZt,(0,p.A)({},OZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}FZt.isMDXComponent=!0;const VZt={toc:[]},qZt="wrapper";function jZt(e){let{components:n,...t}=e;return(0,s.yg)(qZt,(0,p.A)({},VZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}jZt.isMDXComponent=!0;const HZt={toc:[]},YZt="wrapper";function QZt(e){let{components:n,...t}=e;return(0,s.yg)(YZt,(0,p.A)({},HZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QZt.isMDXComponent=!0;const $Zt={toc:[]},KZt="wrapper";function JZt(e){let{components:n,...t}=e;return(0,s.yg)(KZt,(0,p.A)({},$Zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}JZt.isMDXComponent=!0;const ZZt={toc:[]},e0t="wrapper";function n0t(e){let{components:n,...t}=e;return(0,s.yg)(e0t,(0,p.A)({},ZZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}n0t.isMDXComponent=!0;const t0t={toc:[]},o0t="wrapper";function p0t(e){let{components:n,...t}=e;return(0,s.yg)(o0t,(0,p.A)({},t0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}p0t.isMDXComponent=!0;const r0t={toc:[]},s0t="wrapper";function c0t(e){let{components:n,...t}=e;return(0,s.yg)(s0t,(0,p.A)({},r0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}c0t.isMDXComponent=!0;const a0t={toc:[]},i0t="wrapper";function l0t(e){let{components:n,...t}=e;return(0,s.yg)(i0t,(0,p.A)({},a0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}l0t.isMDXComponent=!0;const u0t={toc:[]},m0t="wrapper";function y0t(e){let{components:n,...t}=e;return(0,s.yg)(m0t,(0,p.A)({},u0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}y0t.isMDXComponent=!0;const d0t={toc:[]},h0t="wrapper";function g0t(e){let{components:n,...t}=e;return(0,s.yg)(h0t,(0,p.A)({},d0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}g0t.isMDXComponent=!0;const f0t={toc:[]},D0t="wrapper";function M0t(e){let{components:n,...t}=e;return(0,s.yg)(D0t,(0,p.A)({},f0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}M0t.isMDXComponent=!0;const X0t={toc:[]},_0t="wrapper";function w0t(e){let{components:n,...t}=e;return(0,s.yg)(_0t,(0,p.A)({},X0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}w0t.isMDXComponent=!0;const T0t={toc:[]},C0t="wrapper";function x0t(e){let{components:n,...t}=e;return(0,s.yg)(C0t,(0,p.A)({},T0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}x0t.isMDXComponent=!0;const A0t={toc:[]},v0t="wrapper";function L0t(e){let{components:n,...t}=e;return(0,s.yg)(v0t,(0,p.A)({},A0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}L0t.isMDXComponent=!0;const b0t={toc:[]},N0t="wrapper";function k0t(e){let{components:n,...t}=e;return(0,s.yg)(N0t,(0,p.A)({},b0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start point of the B\xe9zier curve."))}k0t.isMDXComponent=!0;const z0t={toc:[]},P0t="wrapper";function I0t(e){let{components:n,...t}=e;return(0,s.yg)(P0t,(0,p.A)({},z0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The control point of the B\xe9zier curve."))}I0t.isMDXComponent=!0;const R0t={toc:[]},W0t="wrapper";function S0t(e){let{components:n,...t}=e;return(0,s.yg)(W0t,(0,p.A)({},R0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end point of the B\xe9zier curve."))}S0t.isMDXComponent=!0;const B0t={toc:[]},G0t="wrapper";function E0t(e){let{components:n,...t}=e;return(0,s.yg)(G0t,(0,p.A)({},B0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}E0t.isMDXComponent=!0;const O0t={toc:[]},U0t="wrapper";function F0t(e){let{components:n,...t}=e;return(0,s.yg)(U0t,(0,p.A)({},O0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}F0t.isMDXComponent=!0;const V0t={toc:[]},q0t="wrapper";function j0t(e){let{components:n,...t}=e;return(0,s.yg)(q0t,(0,p.A)({},V0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}j0t.isMDXComponent=!0;const H0t={toc:[]},Y0t="wrapper";function Q0t(e){let{components:n,...t}=e;return(0,s.yg)(Y0t,(0,p.A)({},H0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Q0t.isMDXComponent=!0;const $0t={toc:[]},K0t="wrapper";function J0t(e){let{components:n,...t}=e;return(0,s.yg)(K0t,(0,p.A)({},$0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}J0t.isMDXComponent=!0;const Z0t={toc:[]},e8t="wrapper";function n8t(e){let{components:n,...t}=e;return(0,s.yg)(e8t,(0,p.A)({},Z0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}n8t.isMDXComponent=!0;const t8t={toc:[]},o8t="wrapper";function p8t(e){let{components:n,...t}=e;return(0,s.yg)(o8t,(0,p.A)({},t8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}p8t.isMDXComponent=!0;const r8t={toc:[]},s8t="wrapper";function c8t(e){let{components:n,...t}=e;return(0,s.yg)(s8t,(0,p.A)({},r8t,t,{components:n,mdxType:"MDXLayout"}))}c8t.isMDXComponent=!0;const a8t={toc:[]},i8t="wrapper";function l8t(e){let{components:n,...t}=e;return(0,s.yg)(i8t,(0,p.A)({},a8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}l8t.isMDXComponent=!0;const u8t={toc:[]},m8t="wrapper";function y8t(e){let{components:n,...t}=e;return(0,s.yg)(m8t,(0,p.A)({},u8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}y8t.isMDXComponent=!0;const d8t={toc:[]},h8t="wrapper";function g8t(e){let{components:n,...t}=e;return(0,s.yg)(h8t,(0,p.A)({},d8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}g8t.isMDXComponent=!0;const f8t={toc:[]},D8t="wrapper";function M8t(e){let{components:n,...t}=e;return(0,s.yg)(D8t,(0,p.A)({},f8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}M8t.isMDXComponent=!0;const X8t={toc:[]},_8t="wrapper";function w8t(e){let{components:n,...t}=e;return(0,s.yg)(_8t,(0,p.A)({},X8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}w8t.isMDXComponent=!0;const T8t={toc:[]},C8t="wrapper";function x8t(e){let{components:n,...t}=e;return(0,s.yg)(C8t,(0,p.A)({},T8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}x8t.isMDXComponent=!0;const A8t={toc:[]},v8t="wrapper";function L8t(e){let{components:n,...t}=e;return(0,s.yg)(v8t,(0,p.A)({},A8t,t,{components:n,mdxType:"MDXLayout"}))}L8t.isMDXComponent=!0;const b8t={toc:[]},N8t="wrapper";function k8t(e){let{components:n,...t}=e;return(0,s.yg)(N8t,(0,p.A)({},b8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}k8t.isMDXComponent=!0;const z8t={toc:[]},P8t="wrapper";function I8t(e){let{components:n,...t}=e;return(0,s.yg)(P8t,(0,p.A)({},z8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}I8t.isMDXComponent=!0;const R8t={toc:[]},W8t="wrapper";function S8t(e){let{components:n,...t}=e;return(0,s.yg)(W8t,(0,p.A)({},R8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}S8t.isMDXComponent=!0;const B8t={toc:[]},G8t="wrapper";function E8t(e){let{components:n,...t}=e;return(0,s.yg)(G8t,(0,p.A)({},B8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}E8t.isMDXComponent=!0;const O8t={toc:[]},U8t="wrapper";function F8t(e){let{components:n,...t}=e;return(0,s.yg)(U8t,(0,p.A)({},O8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}F8t.isMDXComponent=!0;const V8t={toc:[]},q8t="wrapper";function j8t(e){let{components:n,...t}=e;return(0,s.yg)(q8t,(0,p.A)({},V8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}j8t.isMDXComponent=!0;const H8t={toc:[]},Y8t="wrapper";function Q8t(e){let{components:n,...t}=e;return(0,s.yg)(Y8t,(0,p.A)({},H8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Q8t.isMDXComponent=!0;const $8t={toc:[]},K8t="wrapper";function J8t(e){let{components:n,...t}=e;return(0,s.yg)(K8t,(0,p.A)({},$8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}J8t.isMDXComponent=!0;const Z8t={toc:[]},e2t="wrapper";function n2t(e){let{components:n,...t}=e;return(0,s.yg)(e2t,(0,p.A)({},Z8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}n2t.isMDXComponent=!0;const t2t={toc:[]},o2t="wrapper";function p2t(e){let{components:n,...t}=e;return(0,s.yg)(o2t,(0,p.A)({},t2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}p2t.isMDXComponent=!0;const r2t={toc:[]},s2t="wrapper";function c2t(e){let{components:n,...t}=e;return(0,s.yg)(s2t,(0,p.A)({},r2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}c2t.isMDXComponent=!0;const a2t={toc:[]},i2t="wrapper";function l2t(e){let{components:n,...t}=e;return(0,s.yg)(i2t,(0,p.A)({},a2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}l2t.isMDXComponent=!0;const u2t={toc:[]},m2t="wrapper";function y2t(e){let{components:n,...t}=e;return(0,s.yg)(m2t,(0,p.A)({},u2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}y2t.isMDXComponent=!0;const d2t={toc:[]},h2t="wrapper";function g2t(e){let{components:n,...t}=e;return(0,s.yg)(h2t,(0,p.A)({},d2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}g2t.isMDXComponent=!0;const f2t={toc:[]},D2t="wrapper";function M2t(e){let{components:n,...t}=e;return(0,s.yg)(D2t,(0,p.A)({},f2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}M2t.isMDXComponent=!0;const X2t={toc:[]},_2t="wrapper";function w2t(e){let{components:n,...t}=e;return(0,s.yg)(_2t,(0,p.A)({},X2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}w2t.isMDXComponent=!0;const T2t={toc:[]},C2t="wrapper";function x2t(e){let{components:n,...t}=e;return(0,s.yg)(C2t,(0,p.A)({},T2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}x2t.isMDXComponent=!0;const A2t={toc:[]},v2t="wrapper";function L2t(e){let{components:n,...t}=e;return(0,s.yg)(v2t,(0,p.A)({},A2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}L2t.isMDXComponent=!0;const b2t={toc:[]},N2t="wrapper";function k2t(e){let{components:n,...t}=e;return(0,s.yg)(N2t,(0,p.A)({},b2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}k2t.isMDXComponent=!0;const z2t={toc:[]},P2t="wrapper";function I2t(e){let{components:n,...t}=e;return(0,s.yg)(P2t,(0,p.A)({},z2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}I2t.isMDXComponent=!0;const R2t={toc:[]},W2t="wrapper";function S2t(e){let{components:n,...t}=e;return(0,s.yg)(W2t,(0,p.A)({},R2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}S2t.isMDXComponent=!0;const B2t={toc:[]},G2t="wrapper";function E2t(e){let{components:n,...t}=e;return(0,s.yg)(G2t,(0,p.A)({},B2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}E2t.isMDXComponent=!0;const O2t={toc:[]},U2t="wrapper";function F2t(e){let{components:n,...t}=e;return(0,s.yg)(U2t,(0,p.A)({},O2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}F2t.isMDXComponent=!0;const V2t={toc:[]},q2t="wrapper";function j2t(e){let{components:n,...t}=e;return(0,s.yg)(q2t,(0,p.A)({},V2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}j2t.isMDXComponent=!0;const H2t={toc:[]},Y2t="wrapper";function Q2t(e){let{components:n,...t}=e;return(0,s.yg)(Y2t,(0,p.A)({},H2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Q2t.isMDXComponent=!0;const $2t={toc:[]},K2t="wrapper";function J2t(e){let{components:n,...t}=e;return(0,s.yg)(K2t,(0,p.A)({},$2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}J2t.isMDXComponent=!0;const Z2t={toc:[]},e3t="wrapper";function n3t(e){let{components:n,...t}=e;return(0,s.yg)(e3t,(0,p.A)({},Z2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}n3t.isMDXComponent=!0;const t3t={toc:[]},o3t="wrapper";function p3t(e){let{components:n,...t}=e;return(0,s.yg)(o3t,(0,p.A)({},t3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}p3t.isMDXComponent=!0;const r3t={toc:[]},s3t="wrapper";function c3t(e){let{components:n,...t}=e;return(0,s.yg)(s3t,(0,p.A)({},r3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}c3t.isMDXComponent=!0;const a3t={toc:[]},i3t="wrapper";function l3t(e){let{components:n,...t}=e;return(0,s.yg)(i3t,(0,p.A)({},a3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}l3t.isMDXComponent=!0;const u3t={toc:[]},m3t="wrapper";function y3t(e){let{components:n,...t}=e;return(0,s.yg)(m3t,(0,p.A)({},u3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}y3t.isMDXComponent=!0;const d3t={toc:[]},h3t="wrapper";function g3t(e){let{components:n,...t}=e;return(0,s.yg)(h3t,(0,p.A)({},d3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}g3t.isMDXComponent=!0;const f3t={toc:[]},D3t="wrapper";function M3t(e){let{components:n,...t}=e;return(0,s.yg)(D3t,(0,p.A)({},f3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}M3t.isMDXComponent=!0;const X3t={toc:[]},_3t="wrapper";function w3t(e){let{components:n,...t}=e;return(0,s.yg)(_3t,(0,p.A)({},X3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}w3t.isMDXComponent=!0;const T3t={toc:[]},C3t="wrapper";function x3t(e){let{components:n,...t}=e;return(0,s.yg)(C3t,(0,p.A)({},T3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}x3t.isMDXComponent=!0;const A3t={toc:[]},v3t="wrapper";function L3t(e){let{components:n,...t}=e;return(0,s.yg)(v3t,(0,p.A)({},A3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}L3t.isMDXComponent=!0;const b3t={toc:[]},N3t="wrapper";function k3t(e){let{components:n,...t}=e;return(0,s.yg)(N3t,(0,p.A)({},b3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}k3t.isMDXComponent=!0;const z3t={toc:[]},P3t="wrapper";function I3t(e){let{components:n,...t}=e;return(0,s.yg)(P3t,(0,p.A)({},z3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}I3t.isMDXComponent=!0;const R3t={toc:[]},W3t="wrapper";function S3t(e){let{components:n,...t}=e;return(0,s.yg)(W3t,(0,p.A)({},R3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}S3t.isMDXComponent=!0;const B3t={toc:[]},G3t="wrapper";function E3t(e){let{components:n,...t}=e;return(0,s.yg)(G3t,(0,p.A)({},B3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}E3t.isMDXComponent=!0;const O3t={toc:[]},U3t="wrapper";function F3t(e){let{components:n,...t}=e;return(0,s.yg)(U3t,(0,p.A)({},O3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}F3t.isMDXComponent=!0;const V3t={toc:[]},q3t="wrapper";function j3t(e){let{components:n,...t}=e;return(0,s.yg)(q3t,(0,p.A)({},V3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}j3t.isMDXComponent=!0;const H3t={toc:[]},Y3t="wrapper";function Q3t(e){let{components:n,...t}=e;return(0,s.yg)(Y3t,(0,p.A)({},H3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Q3t.isMDXComponent=!0;const $3t={toc:[]},K3t="wrapper";function J3t(e){let{components:n,...t}=e;return(0,s.yg)(K3t,(0,p.A)({},$3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}J3t.isMDXComponent=!0;const Z3t={toc:[]},e1t="wrapper";function n1t(e){let{components:n,...t}=e;return(0,s.yg)(e1t,(0,p.A)({},Z3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}n1t.isMDXComponent=!0;const t1t={toc:[]},o1t="wrapper";function p1t(e){let{components:n,...t}=e;return(0,s.yg)(o1t,(0,p.A)({},t1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}p1t.isMDXComponent=!0;const r1t={toc:[]},s1t="wrapper";function c1t(e){let{components:n,...t}=e;return(0,s.yg)(s1t,(0,p.A)({},r1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}c1t.isMDXComponent=!0;const a1t={toc:[]},i1t="wrapper";function l1t(e){let{components:n,...t}=e;return(0,s.yg)(i1t,(0,p.A)({},a1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}l1t.isMDXComponent=!0;const u1t={toc:[]},m1t="wrapper";function y1t(e){let{components:n,...t}=e;return(0,s.yg)(m1t,(0,p.A)({},u1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}y1t.isMDXComponent=!0;const d1t={toc:[]},h1t="wrapper";function g1t(e){let{components:n,...t}=e;return(0,s.yg)(h1t,(0,p.A)({},d1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}g1t.isMDXComponent=!0;const f1t={toc:[]},D1t="wrapper";function M1t(e){let{components:n,...t}=e;return(0,s.yg)(D1t,(0,p.A)({},f1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}M1t.isMDXComponent=!0;const X1t={toc:[]},_1t="wrapper";function w1t(e){let{components:n,...t}=e;return(0,s.yg)(_1t,(0,p.A)({},X1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}w1t.isMDXComponent=!0;const T1t={toc:[]},C1t="wrapper";function x1t(e){let{components:n,...t}=e;return(0,s.yg)(C1t,(0,p.A)({},T1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}x1t.isMDXComponent=!0;const A1t={toc:[]},v1t="wrapper";function L1t(e){let{components:n,...t}=e;return(0,s.yg)(v1t,(0,p.A)({},A1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}L1t.isMDXComponent=!0;const b1t={toc:[]},N1t="wrapper";function k1t(e){let{components:n,...t}=e;return(0,s.yg)(N1t,(0,p.A)({},b1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}k1t.isMDXComponent=!0;const z1t={toc:[]},P1t="wrapper";function I1t(e){let{components:n,...t}=e;return(0,s.yg)(P1t,(0,p.A)({},z1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}I1t.isMDXComponent=!0;const R1t={toc:[]},W1t="wrapper";function S1t(e){let{components:n,...t}=e;return(0,s.yg)(W1t,(0,p.A)({},R1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}S1t.isMDXComponent=!0;const B1t={toc:[]},G1t="wrapper";function E1t(e){let{components:n,...t}=e;return(0,s.yg)(G1t,(0,p.A)({},B1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}E1t.isMDXComponent=!0;const O1t={toc:[]},U1t="wrapper";function F1t(e){let{components:n,...t}=e;return(0,s.yg)(U1t,(0,p.A)({},O1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}F1t.isMDXComponent=!0;const V1t={toc:[]},q1t="wrapper";function j1t(e){let{components:n,...t}=e;return(0,s.yg)(q1t,(0,p.A)({},V1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}j1t.isMDXComponent=!0;const H1t={toc:[]},Y1t="wrapper";function Q1t(e){let{components:n,...t}=e;return(0,s.yg)(Y1t,(0,p.A)({},H1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Q1t.isMDXComponent=!0;const $1t={toc:[]},K1t="wrapper";function J1t(e){let{components:n,...t}=e;return(0,s.yg)(K1t,(0,p.A)({},$1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}J1t.isMDXComponent=!0;const Z1t={toc:[]},e4t="wrapper";function n4t(e){let{components:n,...t}=e;return(0,s.yg)(e4t,(0,p.A)({},Z1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}n4t.isMDXComponent=!0;const t4t={toc:[]},o4t="wrapper";function p4t(e){let{components:n,...t}=e;return(0,s.yg)(o4t,(0,p.A)({},t4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}p4t.isMDXComponent=!0;const r4t={toc:[]},s4t="wrapper";function c4t(e){let{components:n,...t}=e;return(0,s.yg)(s4t,(0,p.A)({},r4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}c4t.isMDXComponent=!0;const a4t={toc:[]},i4t="wrapper";function l4t(e){let{components:n,...t}=e;return(0,s.yg)(i4t,(0,p.A)({},a4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}l4t.isMDXComponent=!0;const u4t={toc:[]},m4t="wrapper";function y4t(e){let{components:n,...t}=e;return(0,s.yg)(m4t,(0,p.A)({},u4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}y4t.isMDXComponent=!0;const d4t={toc:[]},h4t="wrapper";function g4t(e){let{components:n,...t}=e;return(0,s.yg)(h4t,(0,p.A)({},d4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}g4t.isMDXComponent=!0;const f4t={toc:[]},D4t="wrapper";function M4t(e){let{components:n,...t}=e;return(0,s.yg)(D4t,(0,p.A)({},f4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}M4t.isMDXComponent=!0;const X4t={toc:[]},_4t="wrapper";function w4t(e){let{components:n,...t}=e;return(0,s.yg)(_4t,(0,p.A)({},X4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}w4t.isMDXComponent=!0;const T4t={toc:[]},C4t="wrapper";function x4t(e){let{components:n,...t}=e;return(0,s.yg)(C4t,(0,p.A)({},T4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}x4t.isMDXComponent=!0;const A4t={toc:[]},v4t="wrapper";function L4t(e){let{components:n,...t}=e;return(0,s.yg)(v4t,(0,p.A)({},A4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}L4t.isMDXComponent=!0;const b4t={toc:[]},N4t="wrapper";function k4t(e){let{components:n,...t}=e;return(0,s.yg)(N4t,(0,p.A)({},b4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}k4t.isMDXComponent=!0;const z4t={toc:[]},P4t="wrapper";function I4t(e){let{components:n,...t}=e;return(0,s.yg)(P4t,(0,p.A)({},z4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}I4t.isMDXComponent=!0;const R4t={toc:[]},W4t="wrapper";function S4t(e){let{components:n,...t}=e;return(0,s.yg)(W4t,(0,p.A)({},R4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}S4t.isMDXComponent=!0;const B4t={toc:[]},G4t="wrapper";function E4t(e){let{components:n,...t}=e;return(0,s.yg)(G4t,(0,p.A)({},B4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}E4t.isMDXComponent=!0;const O4t={toc:[]},U4t="wrapper";function F4t(e){let{components:n,...t}=e;return(0,s.yg)(U4t,(0,p.A)({},O4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}F4t.isMDXComponent=!0;const V4t={toc:[]},q4t="wrapper";function j4t(e){let{components:n,...t}=e;return(0,s.yg)(q4t,(0,p.A)({},V4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}j4t.isMDXComponent=!0;const H4t={toc:[]},Y4t="wrapper";function Q4t(e){let{components:n,...t}=e;return(0,s.yg)(Y4t,(0,p.A)({},H4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Q4t.isMDXComponent=!0;const $4t={toc:[]},K4t="wrapper";function J4t(e){let{components:n,...t}=e;return(0,s.yg)(K4t,(0,p.A)({},$4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}J4t.isMDXComponent=!0;const Z4t={toc:[]},e6t="wrapper";function n6t(e){let{components:n,...t}=e;return(0,s.yg)(e6t,(0,p.A)({},Z4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}n6t.isMDXComponent=!0;const t6t={toc:[]},o6t="wrapper";function p6t(e){let{components:n,...t}=e;return(0,s.yg)(o6t,(0,p.A)({},t6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}p6t.isMDXComponent=!0;const r6t={toc:[]},s6t="wrapper";function c6t(e){let{components:n,...t}=e;return(0,s.yg)(s6t,(0,p.A)({},r6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}c6t.isMDXComponent=!0;const a6t={toc:[]},i6t="wrapper";function l6t(e){let{components:n,...t}=e;return(0,s.yg)(i6t,(0,p.A)({},a6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}l6t.isMDXComponent=!0;const u6t={toc:[]},m6t="wrapper";function y6t(e){let{components:n,...t}=e;return(0,s.yg)(m6t,(0,p.A)({},u6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}y6t.isMDXComponent=!0;const d6t={toc:[]},h6t="wrapper";function g6t(e){let{components:n,...t}=e;return(0,s.yg)(h6t,(0,p.A)({},d6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}g6t.isMDXComponent=!0;const f6t={toc:[]},D6t="wrapper";function M6t(e){let{components:n,...t}=e;return(0,s.yg)(D6t,(0,p.A)({},f6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}M6t.isMDXComponent=!0;const X6t={toc:[]},_6t="wrapper";function w6t(e){let{components:n,...t}=e;return(0,s.yg)(_6t,(0,p.A)({},X6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}w6t.isMDXComponent=!0;const T6t={toc:[]},C6t="wrapper";function x6t(e){let{components:n,...t}=e;return(0,s.yg)(C6t,(0,p.A)({},T6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}x6t.isMDXComponent=!0;const A6t={toc:[]},v6t="wrapper";function L6t(e){let{components:n,...t}=e;return(0,s.yg)(v6t,(0,p.A)({},A6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}L6t.isMDXComponent=!0;const b6t={toc:[]},N6t="wrapper";function k6t(e){let{components:n,...t}=e;return(0,s.yg)(N6t,(0,p.A)({},b6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}k6t.isMDXComponent=!0;const z6t={toc:[]},P6t="wrapper";function I6t(e){let{components:n,...t}=e;return(0,s.yg)(P6t,(0,p.A)({},z6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}I6t.isMDXComponent=!0;const R6t={toc:[]},W6t="wrapper";function S6t(e){let{components:n,...t}=e;return(0,s.yg)(W6t,(0,p.A)({},R6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}S6t.isMDXComponent=!0;const B6t={toc:[]},G6t="wrapper";function E6t(e){let{components:n,...t}=e;return(0,s.yg)(G6t,(0,p.A)({},B6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}E6t.isMDXComponent=!0;const O6t={toc:[]},U6t="wrapper";function F6t(e){let{components:n,...t}=e;return(0,s.yg)(U6t,(0,p.A)({},O6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}F6t.isMDXComponent=!0;const V6t={toc:[]},q6t="wrapper";function j6t(e){let{components:n,...t}=e;return(0,s.yg)(q6t,(0,p.A)({},V6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}j6t.isMDXComponent=!0;const H6t={toc:[]},Y6t="wrapper";function Q6t(e){let{components:n,...t}=e;return(0,s.yg)(Y6t,(0,p.A)({},H6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Q6t.isMDXComponent=!0;const $6t={toc:[]},K6t="wrapper";function J6t(e){let{components:n,...t}=e;return(0,s.yg)(K6t,(0,p.A)({},$6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}J6t.isMDXComponent=!0;const Z6t={toc:[]},e5t="wrapper";function n5t(e){let{components:n,...t}=e;return(0,s.yg)(e5t,(0,p.A)({},Z6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}n5t.isMDXComponent=!0;const t5t={toc:[]},o5t="wrapper";function p5t(e){let{components:n,...t}=e;return(0,s.yg)(o5t,(0,p.A)({},t5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}p5t.isMDXComponent=!0;const r5t={toc:[]},s5t="wrapper";function c5t(e){let{components:n,...t}=e;return(0,s.yg)(s5t,(0,p.A)({},r5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}c5t.isMDXComponent=!0;const a5t={toc:[]},i5t="wrapper";function l5t(e){let{components:n,...t}=e;return(0,s.yg)(i5t,(0,p.A)({},a5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}l5t.isMDXComponent=!0;const u5t={toc:[]},m5t="wrapper";function y5t(e){let{components:n,...t}=e;return(0,s.yg)(m5t,(0,p.A)({},u5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}y5t.isMDXComponent=!0;const d5t={toc:[]},h5t="wrapper";function g5t(e){let{components:n,...t}=e;return(0,s.yg)(h5t,(0,p.A)({},d5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}g5t.isMDXComponent=!0;const f5t={toc:[]},D5t="wrapper";function M5t(e){let{components:n,...t}=e;return(0,s.yg)(D5t,(0,p.A)({},f5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}M5t.isMDXComponent=!0;const X5t={toc:[]},_5t="wrapper";function w5t(e){let{components:n,...t}=e;return(0,s.yg)(_5t,(0,p.A)({},X5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}w5t.isMDXComponent=!0;const T5t={toc:[]},C5t="wrapper";function x5t(e){let{components:n,...t}=e;return(0,s.yg)(C5t,(0,p.A)({},T5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}x5t.isMDXComponent=!0;const A5t={toc:[]},v5t="wrapper";function L5t(e){let{components:n,...t}=e;return(0,s.yg)(v5t,(0,p.A)({},A5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}L5t.isMDXComponent=!0;const b5t={toc:[]},N5t="wrapper";function k5t(e){let{components:n,...t}=e;return(0,s.yg)(N5t,(0,p.A)({},b5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}k5t.isMDXComponent=!0;const z5t={toc:[]},P5t="wrapper";function I5t(e){let{components:n,...t}=e;return(0,s.yg)(P5t,(0,p.A)({},z5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}I5t.isMDXComponent=!0;const R5t={toc:[]},W5t="wrapper";function S5t(e){let{components:n,...t}=e;return(0,s.yg)(W5t,(0,p.A)({},R5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}S5t.isMDXComponent=!0;const B5t={toc:[]},G5t="wrapper";function E5t(e){let{components:n,...t}=e;return(0,s.yg)(G5t,(0,p.A)({},B5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}E5t.isMDXComponent=!0;const O5t={toc:[]},U5t="wrapper";function F5t(e){let{components:n,...t}=e;return(0,s.yg)(U5t,(0,p.A)({},O5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}F5t.isMDXComponent=!0;const V5t={toc:[]},q5t="wrapper";function j5t(e){let{components:n,...t}=e;return(0,s.yg)(q5t,(0,p.A)({},V5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}j5t.isMDXComponent=!0;const H5t={toc:[]},Y5t="wrapper";function Q5t(e){let{components:n,...t}=e;return(0,s.yg)(Y5t,(0,p.A)({},H5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Q5t.isMDXComponent=!0;const $5t={toc:[]},K5t="wrapper";function J5t(e){let{components:n,...t}=e;return(0,s.yg)(K5t,(0,p.A)({},$5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}J5t.isMDXComponent=!0;const Z5t={toc:[]},e7t="wrapper";function n7t(e){let{components:n,...t}=e;return(0,s.yg)(e7t,(0,p.A)({},Z5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}n7t.isMDXComponent=!0;const t7t={toc:[]},o7t="wrapper";function p7t(e){let{components:n,...t}=e;return(0,s.yg)(o7t,(0,p.A)({},t7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}p7t.isMDXComponent=!0;const r7t={toc:[]},s7t="wrapper";function c7t(e){let{components:n,...t}=e;return(0,s.yg)(s7t,(0,p.A)({},r7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}c7t.isMDXComponent=!0;const a7t={toc:[]},i7t="wrapper";function l7t(e){let{components:n,...t}=e;return(0,s.yg)(i7t,(0,p.A)({},a7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}l7t.isMDXComponent=!0;const u7t={toc:[]},m7t="wrapper";function y7t(e){let{components:n,...t}=e;return(0,s.yg)(m7t,(0,p.A)({},u7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}y7t.isMDXComponent=!0;const d7t={toc:[]},h7t="wrapper";function g7t(e){let{components:n,...t}=e;return(0,s.yg)(h7t,(0,p.A)({},d7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}g7t.isMDXComponent=!0;const f7t={toc:[]},D7t="wrapper";function M7t(e){let{components:n,...t}=e;return(0,s.yg)(D7t,(0,p.A)({},f7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}M7t.isMDXComponent=!0;const X7t={toc:[]},_7t="wrapper";function w7t(e){let{components:n,...t}=e;return(0,s.yg)(_7t,(0,p.A)({},X7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}w7t.isMDXComponent=!0;const T7t={toc:[]},C7t="wrapper";function x7t(e){let{components:n,...t}=e;return(0,s.yg)(C7t,(0,p.A)({},T7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}x7t.isMDXComponent=!0;const A7t={toc:[]},v7t="wrapper";function L7t(e){let{components:n,...t}=e;return(0,s.yg)(v7t,(0,p.A)({},A7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}L7t.isMDXComponent=!0;const b7t={toc:[]},N7t="wrapper";function k7t(e){let{components:n,...t}=e;return(0,s.yg)(N7t,(0,p.A)({},b7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}k7t.isMDXComponent=!0;const z7t={toc:[]},P7t="wrapper";function I7t(e){let{components:n,...t}=e;return(0,s.yg)(P7t,(0,p.A)({},z7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}I7t.isMDXComponent=!0;const R7t={toc:[]},W7t="wrapper";function S7t(e){let{components:n,...t}=e;return(0,s.yg)(W7t,(0,p.A)({},R7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}S7t.isMDXComponent=!0;const B7t={toc:[]},G7t="wrapper";function E7t(e){let{components:n,...t}=e;return(0,s.yg)(G7t,(0,p.A)({},B7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}E7t.isMDXComponent=!0;const O7t={toc:[]},U7t="wrapper";function F7t(e){let{components:n,...t}=e;return(0,s.yg)(U7t,(0,p.A)({},O7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}F7t.isMDXComponent=!0;const V7t={toc:[]},q7t="wrapper";function j7t(e){let{components:n,...t}=e;return(0,s.yg)(q7t,(0,p.A)({},V7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}j7t.isMDXComponent=!0;const H7t={toc:[]},Y7t="wrapper";function Q7t(e){let{components:n,...t}=e;return(0,s.yg)(Y7t,(0,p.A)({},H7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Q7t.isMDXComponent=!0;const $7t={toc:[]},K7t="wrapper";function J7t(e){let{components:n,...t}=e;return(0,s.yg)(K7t,(0,p.A)({},$7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}J7t.isMDXComponent=!0;const Z7t={toc:[]},e9t="wrapper";function n9t(e){let{components:n,...t}=e;return(0,s.yg)(e9t,(0,p.A)({},Z7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}n9t.isMDXComponent=!0;const t9t={toc:[]},o9t="wrapper";function p9t(e){let{components:n,...t}=e;return(0,s.yg)(o9t,(0,p.A)({},t9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}p9t.isMDXComponent=!0;const r9t={toc:[]},s9t="wrapper";function c9t(e){let{components:n,...t}=e;return(0,s.yg)(s9t,(0,p.A)({},r9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}c9t.isMDXComponent=!0;const a9t={toc:[]},i9t="wrapper";function l9t(e){let{components:n,...t}=e;return(0,s.yg)(i9t,(0,p.A)({},a9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}l9t.isMDXComponent=!0;const u9t={toc:[]},m9t="wrapper";function y9t(e){let{components:n,...t}=e;return(0,s.yg)(m9t,(0,p.A)({},u9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}y9t.isMDXComponent=!0;const d9t={toc:[]},h9t="wrapper";function g9t(e){let{components:n,...t}=e;return(0,s.yg)(h9t,(0,p.A)({},d9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}g9t.isMDXComponent=!0;const f9t={toc:[]},D9t="wrapper";function M9t(e){let{components:n,...t}=e;return(0,s.yg)(D9t,(0,p.A)({},f9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}M9t.isMDXComponent=!0;const X9t={toc:[]},_9t="wrapper";function w9t(e){let{components:n,...t}=e;return(0,s.yg)(_9t,(0,p.A)({},X9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}w9t.isMDXComponent=!0;const T9t={toc:[]},C9t="wrapper";function x9t(e){let{components:n,...t}=e;return(0,s.yg)(C9t,(0,p.A)({},T9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}x9t.isMDXComponent=!0;const A9t={toc:[]},v9t="wrapper";function L9t(e){let{components:n,...t}=e;return(0,s.yg)(v9t,(0,p.A)({},A9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}L9t.isMDXComponent=!0;const b9t={toc:[]},N9t="wrapper";function k9t(e){let{components:n,...t}=e;return(0,s.yg)(N9t,(0,p.A)({},b9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}k9t.isMDXComponent=!0;const z9t={toc:[]},P9t="wrapper";function I9t(e){let{components:n,...t}=e;return(0,s.yg)(P9t,(0,p.A)({},z9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}I9t.isMDXComponent=!0;const R9t={toc:[]},W9t="wrapper";function S9t(e){let{components:n,...t}=e;return(0,s.yg)(W9t,(0,p.A)({},R9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}S9t.isMDXComponent=!0;const B9t={toc:[]},G9t="wrapper";function E9t(e){let{components:n,...t}=e;return(0,s.yg)(G9t,(0,p.A)({},B9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}E9t.isMDXComponent=!0;const O9t={toc:[]},U9t="wrapper";function F9t(e){let{components:n,...t}=e;return(0,s.yg)(U9t,(0,p.A)({},O9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}F9t.isMDXComponent=!0;const V9t={toc:[]},q9t="wrapper";function j9t(e){let{components:n,...t}=e;return(0,s.yg)(q9t,(0,p.A)({},V9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}j9t.isMDXComponent=!0;const H9t={toc:[]},Y9t="wrapper";function Q9t(e){let{components:n,...t}=e;return(0,s.yg)(Y9t,(0,p.A)({},H9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Q9t.isMDXComponent=!0;const $9t={toc:[]},K9t="wrapper";function J9t(e){let{components:n,...t}=e;return(0,s.yg)(K9t,(0,p.A)({},$9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}J9t.isMDXComponent=!0;const Z9t={toc:[]},eeo="wrapper";function neo(e){let{components:n,...t}=e;return(0,s.yg)(eeo,(0,p.A)({},Z9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}neo.isMDXComponent=!0;const teo={toc:[]},oeo="wrapper";function peo(e){let{components:n,...t}=e;return(0,s.yg)(oeo,(0,p.A)({},teo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}peo.isMDXComponent=!0;const reo={toc:[]},seo="wrapper";function ceo(e){let{components:n,...t}=e;return(0,s.yg)(seo,(0,p.A)({},reo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}ceo.isMDXComponent=!0;const aeo={toc:[]},ieo="wrapper";function leo(e){let{components:n,...t}=e;return(0,s.yg)(ieo,(0,p.A)({},aeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}leo.isMDXComponent=!0;const ueo={toc:[]},meo="wrapper";function yeo(e){let{components:n,...t}=e;return(0,s.yg)(meo,(0,p.A)({},ueo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}yeo.isMDXComponent=!0;const deo={toc:[]},heo="wrapper";function geo(e){let{components:n,...t}=e;return(0,s.yg)(heo,(0,p.A)({},deo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}geo.isMDXComponent=!0;const feo={toc:[]},Deo="wrapper";function Meo(e){let{components:n,...t}=e;return(0,s.yg)(Deo,(0,p.A)({},feo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Meo.isMDXComponent=!0;const Xeo={toc:[]},_eo="wrapper";function weo(e){let{components:n,...t}=e;return(0,s.yg)(_eo,(0,p.A)({},Xeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}weo.isMDXComponent=!0;const Teo={toc:[]},Ceo="wrapper";function xeo(e){let{components:n,...t}=e;return(0,s.yg)(Ceo,(0,p.A)({},Teo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}xeo.isMDXComponent=!0;const Aeo={toc:[]},veo="wrapper";function Leo(e){let{components:n,...t}=e;return(0,s.yg)(veo,(0,p.A)({},Aeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Leo.isMDXComponent=!0;const beo={toc:[]},Neo="wrapper";function keo(e){let{components:n,...t}=e;return(0,s.yg)(Neo,(0,p.A)({},beo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}keo.isMDXComponent=!0;const zeo={toc:[]},Peo="wrapper";function Ieo(e){let{components:n,...t}=e;return(0,s.yg)(Peo,(0,p.A)({},zeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Ieo.isMDXComponent=!0;const Reo={toc:[]},Weo="wrapper";function Seo(e){let{components:n,...t}=e;return(0,s.yg)(Weo,(0,p.A)({},Reo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Seo.isMDXComponent=!0;const Beo={toc:[]},Geo="wrapper";function Eeo(e){let{components:n,...t}=e;return(0,s.yg)(Geo,(0,p.A)({},Beo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Eeo.isMDXComponent=!0;const Oeo={toc:[]},Ueo="wrapper";function Feo(e){let{components:n,...t}=e;return(0,s.yg)(Ueo,(0,p.A)({},Oeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Feo.isMDXComponent=!0;const Veo={toc:[]},qeo="wrapper";function jeo(e){let{components:n,...t}=e;return(0,s.yg)(qeo,(0,p.A)({},Veo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}jeo.isMDXComponent=!0;const Heo={toc:[]},Yeo="wrapper";function Qeo(e){let{components:n,...t}=e;return(0,s.yg)(Yeo,(0,p.A)({},Heo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@revideo/2d';\nimport {Ray} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}Qeo.isMDXComponent=!0;const $eo={toc:[]},Keo="wrapper";function Jeo(e){let{components:n,...t}=e;return(0,s.yg)(Keo,(0,p.A)({},$eo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing an individual line segment."))}Jeo.isMDXComponent=!0;const Zeo={toc:[]},eno="wrapper";function nno(e){let{components:n,...t}=e;return(0,s.yg)(eno,(0,p.A)({},Zeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}nno.isMDXComponent=!0;const tno={toc:[]},ono="wrapper";function pno(e){let{components:n,...t}=e;return(0,s.yg)(ono,(0,p.A)({},tno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}pno.isMDXComponent=!0;const rno={toc:[]},sno="wrapper";function cno(e){let{components:n,...t}=e;return(0,s.yg)(sno,(0,p.A)({},rno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cno.isMDXComponent=!0;const ano={toc:[]},ino="wrapper";function lno(e){let{components:n,...t}=e;return(0,s.yg)(ino,(0,p.A)({},ano,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}lno.isMDXComponent=!0;const uno={toc:[]},mno="wrapper";function yno(e){let{components:n,...t}=e;return(0,s.yg)(mno,(0,p.A)({},uno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}yno.isMDXComponent=!0;const dno={toc:[]},hno="wrapper";function gno(e){let{components:n,...t}=e;return(0,s.yg)(hno,(0,p.A)({},dno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}gno.isMDXComponent=!0;const fno={toc:[]},Dno="wrapper";function Mno(e){let{components:n,...t}=e;return(0,s.yg)(Dno,(0,p.A)({},fno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Mno.isMDXComponent=!0;const Xno={toc:[]},_no="wrapper";function wno(e){let{components:n,...t}=e;return(0,s.yg)(_no,(0,p.A)({},Xno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}wno.isMDXComponent=!0;const Tno={toc:[]},Cno="wrapper";function xno(e){let{components:n,...t}=e;return(0,s.yg)(Cno,(0,p.A)({},Tno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}xno.isMDXComponent=!0;const Ano={toc:[]},vno="wrapper";function Lno(e){let{components:n,...t}=e;return(0,s.yg)(vno,(0,p.A)({},Ano,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Lno.isMDXComponent=!0;const bno={toc:[]},Nno="wrapper";function kno(e){let{components:n,...t}=e;return(0,s.yg)(Nno,(0,p.A)({},bno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}kno.isMDXComponent=!0;const zno={toc:[]},Pno="wrapper";function Ino(e){let{components:n,...t}=e;return(0,s.yg)(Pno,(0,p.A)({},zno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Ino.isMDXComponent=!0;const Rno={toc:[]},Wno="wrapper";function Sno(e){let{components:n,...t}=e;return(0,s.yg)(Wno,(0,p.A)({},Rno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Sno.isMDXComponent=!0;const Bno={toc:[]},Gno="wrapper";function Eno(e){let{components:n,...t}=e;return(0,s.yg)(Gno,(0,p.A)({},Bno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Eno.isMDXComponent=!0;const Ono={toc:[]},Uno="wrapper";function Fno(e){let{components:n,...t}=e;return(0,s.yg)(Uno,(0,p.A)({},Ono,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Fno.isMDXComponent=!0;const Vno={toc:[]},qno="wrapper";function jno(e){let{components:n,...t}=e;return(0,s.yg)(qno,(0,p.A)({},Vno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jno.isMDXComponent=!0;const Hno={toc:[]},Yno="wrapper";function Qno(e){let{components:n,...t}=e;return(0,s.yg)(Yno,(0,p.A)({},Hno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Qno.isMDXComponent=!0;const $no={toc:[]},Kno="wrapper";function Jno(e){let{components:n,...t}=e;return(0,s.yg)(Kno,(0,p.A)({},$no,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Jno.isMDXComponent=!0;const Zno={toc:[]},eto="wrapper";function nto(e){let{components:n,...t}=e;return(0,s.yg)(eto,(0,p.A)({},Zno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}nto.isMDXComponent=!0;const tto={toc:[]},oto="wrapper";function pto(e){let{components:n,...t}=e;return(0,s.yg)(oto,(0,p.A)({},tto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}pto.isMDXComponent=!0;const rto={toc:[]},sto="wrapper";function cto(e){let{components:n,...t}=e;return(0,s.yg)(sto,(0,p.A)({},rto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cto.isMDXComponent=!0;const ato={toc:[]},ito="wrapper";function lto(e){let{components:n,...t}=e;return(0,s.yg)(ito,(0,p.A)({},ato,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}lto.isMDXComponent=!0;const uto={toc:[]},mto="wrapper";function yto(e){let{components:n,...t}=e;return(0,s.yg)(mto,(0,p.A)({},uto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}yto.isMDXComponent=!0;const dto={toc:[]},hto="wrapper";function gto(e){let{components:n,...t}=e;return(0,s.yg)(hto,(0,p.A)({},dto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}gto.isMDXComponent=!0;const fto={toc:[]},Dto="wrapper";function Mto(e){let{components:n,...t}=e;return(0,s.yg)(Dto,(0,p.A)({},fto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting point of the ray."))}Mto.isMDXComponent=!0;const Xto={toc:[]},_to="wrapper";function wto(e){let{components:n,...t}=e;return(0,s.yg)(_to,(0,p.A)({},Xto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}wto.isMDXComponent=!0;const Tto={toc:[]},Cto="wrapper";function xto(e){let{components:n,...t}=e;return(0,s.yg)(Cto,(0,p.A)({},Tto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}xto.isMDXComponent=!0;const Ato={toc:[]},vto="wrapper";function Lto(e){let{components:n,...t}=e;return(0,s.yg)(vto,(0,p.A)({},Ato,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Lto.isMDXComponent=!0;const bto={toc:[]},Nto="wrapper";function kto(e){let{components:n,...t}=e;return(0,s.yg)(Nto,(0,p.A)({},bto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}kto.isMDXComponent=!0;const zto={toc:[]},Pto="wrapper";function Ito(e){let{components:n,...t}=e;return(0,s.yg)(Pto,(0,p.A)({},zto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ito.isMDXComponent=!0;const Rto={toc:[]},Wto="wrapper";function Sto(e){let{components:n,...t}=e;return(0,s.yg)(Wto,(0,p.A)({},Rto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Sto.isMDXComponent=!0;const Bto={toc:[]},Gto="wrapper";function Eto(e){let{components:n,...t}=e;return(0,s.yg)(Gto,(0,p.A)({},Bto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Eto.isMDXComponent=!0;const Oto={toc:[]},Uto="wrapper";function Fto(e){let{components:n,...t}=e;return(0,s.yg)(Uto,(0,p.A)({},Oto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Fto.isMDXComponent=!0;const Vto={toc:[]},qto="wrapper";function jto(e){let{components:n,...t}=e;return(0,s.yg)(qto,(0,p.A)({},Vto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jto.isMDXComponent=!0;const Hto={toc:[]},Yto="wrapper";function Qto(e){let{components:n,...t}=e;return(0,s.yg)(Yto,(0,p.A)({},Hto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Qto.isMDXComponent=!0;const $to={toc:[]},Kto="wrapper";function Jto(e){let{components:n,...t}=e;return(0,s.yg)(Kto,(0,p.A)({},$to,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Jto.isMDXComponent=!0;const Zto={toc:[]},eoo="wrapper";function noo(e){let{components:n,...t}=e;return(0,s.yg)(eoo,(0,p.A)({},Zto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}noo.isMDXComponent=!0;const too={toc:[]},ooo="wrapper";function poo(e){let{components:n,...t}=e;return(0,s.yg)(ooo,(0,p.A)({},too,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}poo.isMDXComponent=!0;const roo={toc:[]},soo="wrapper";function coo(e){let{components:n,...t}=e;return(0,s.yg)(soo,(0,p.A)({},roo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}coo.isMDXComponent=!0;const aoo={toc:[]},ioo="wrapper";function loo(e){let{components:n,...t}=e;return(0,s.yg)(ioo,(0,p.A)({},aoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}loo.isMDXComponent=!0;const uoo={toc:[]},moo="wrapper";function yoo(e){let{components:n,...t}=e;return(0,s.yg)(moo,(0,p.A)({},uoo,t,{components:n,mdxType:"MDXLayout"}))}yoo.isMDXComponent=!0;const doo={toc:[]},hoo="wrapper";function goo(e){let{components:n,...t}=e;return(0,s.yg)(hoo,(0,p.A)({},doo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}goo.isMDXComponent=!0;const foo={toc:[]},Doo="wrapper";function Moo(e){let{components:n,...t}=e;return(0,s.yg)(Doo,(0,p.A)({},foo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Moo.isMDXComponent=!0;const Xoo={toc:[]},_oo="wrapper";function woo(e){let{components:n,...t}=e;return(0,s.yg)(_oo,(0,p.A)({},Xoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}woo.isMDXComponent=!0;const Too={toc:[]},Coo="wrapper";function xoo(e){let{components:n,...t}=e;return(0,s.yg)(Coo,(0,p.A)({},Too,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}xoo.isMDXComponent=!0;const Aoo={toc:[]},voo="wrapper";function Loo(e){let{components:n,...t}=e;return(0,s.yg)(voo,(0,p.A)({},Aoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Loo.isMDXComponent=!0;const boo={toc:[]},Noo="wrapper";function koo(e){let{components:n,...t}=e;return(0,s.yg)(Noo,(0,p.A)({},boo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}koo.isMDXComponent=!0;const zoo={toc:[]},Poo="wrapper";function Ioo(e){let{components:n,...t}=e;return(0,s.yg)(Poo,(0,p.A)({},zoo,t,{components:n,mdxType:"MDXLayout"}))}Ioo.isMDXComponent=!0;const Roo={toc:[]},Woo="wrapper";function Soo(e){let{components:n,...t}=e;return(0,s.yg)(Woo,(0,p.A)({},Roo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Soo.isMDXComponent=!0;const Boo={toc:[]},Goo="wrapper";function Eoo(e){let{components:n,...t}=e;return(0,s.yg)(Goo,(0,p.A)({},Boo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Eoo.isMDXComponent=!0;const Ooo={toc:[]},Uoo="wrapper";function Foo(e){let{components:n,...t}=e;return(0,s.yg)(Uoo,(0,p.A)({},Ooo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Foo.isMDXComponent=!0;const Voo={toc:[]},qoo="wrapper";function joo(e){let{components:n,...t}=e;return(0,s.yg)(qoo,(0,p.A)({},Voo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}joo.isMDXComponent=!0;const Hoo={toc:[]},Yoo="wrapper";function Qoo(e){let{components:n,...t}=e;return(0,s.yg)(Yoo,(0,p.A)({},Hoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Qoo.isMDXComponent=!0;const $oo={toc:[]},Koo="wrapper";function Joo(e){let{components:n,...t}=e;return(0,s.yg)(Koo,(0,p.A)({},$oo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Joo.isMDXComponent=!0;const Zoo={toc:[]},epo="wrapper";function npo(e){let{components:n,...t}=e;return(0,s.yg)(epo,(0,p.A)({},Zoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending point of the ray."))}npo.isMDXComponent=!0;const tpo={toc:[]},opo="wrapper";function ppo(e){let{components:n,...t}=e;return(0,s.yg)(opo,(0,p.A)({},tpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ppo.isMDXComponent=!0;const rpo={toc:[]},spo="wrapper";function cpo(e){let{components:n,...t}=e;return(0,s.yg)(spo,(0,p.A)({},rpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}cpo.isMDXComponent=!0;const apo={toc:[]},ipo="wrapper";function lpo(e){let{components:n,...t}=e;return(0,s.yg)(ipo,(0,p.A)({},apo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lpo.isMDXComponent=!0;const upo={toc:[]},mpo="wrapper";function ypo(e){let{components:n,...t}=e;return(0,s.yg)(mpo,(0,p.A)({},upo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}ypo.isMDXComponent=!0;const dpo={toc:[]},hpo="wrapper";function gpo(e){let{components:n,...t}=e;return(0,s.yg)(hpo,(0,p.A)({},dpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}gpo.isMDXComponent=!0;const fpo={toc:[]},Dpo="wrapper";function Mpo(e){let{components:n,...t}=e;return(0,s.yg)(Dpo,(0,p.A)({},fpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Mpo.isMDXComponent=!0;const Xpo={toc:[]},_po="wrapper";function wpo(e){let{components:n,...t}=e;return(0,s.yg)(_po,(0,p.A)({},Xpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}wpo.isMDXComponent=!0;const Tpo={toc:[]},Cpo="wrapper";function xpo(e){let{components:n,...t}=e;return(0,s.yg)(Cpo,(0,p.A)({},Tpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}xpo.isMDXComponent=!0;const Apo={toc:[]},vpo="wrapper";function Lpo(e){let{components:n,...t}=e;return(0,s.yg)(vpo,(0,p.A)({},Apo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Lpo.isMDXComponent=!0;const bpo={toc:[]},Npo="wrapper";function kpo(e){let{components:n,...t}=e;return(0,s.yg)(Npo,(0,p.A)({},bpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}kpo.isMDXComponent=!0;const zpo={toc:[]},Ppo="wrapper";function Ipo(e){let{components:n,...t}=e;return(0,s.yg)(Ppo,(0,p.A)({},zpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ipo.isMDXComponent=!0;const Rpo={toc:[]},Wpo="wrapper";function Spo(e){let{components:n,...t}=e;return(0,s.yg)(Wpo,(0,p.A)({},Rpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Spo.isMDXComponent=!0;const Bpo={toc:[]},Gpo="wrapper";function Epo(e){let{components:n,...t}=e;return(0,s.yg)(Gpo,(0,p.A)({},Bpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Epo.isMDXComponent=!0;const Opo={toc:[]},Upo="wrapper";function Fpo(e){let{components:n,...t}=e;return(0,s.yg)(Upo,(0,p.A)({},Opo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Fpo.isMDXComponent=!0;const Vpo={toc:[]},qpo="wrapper";function jpo(e){let{components:n,...t}=e;return(0,s.yg)(qpo,(0,p.A)({},Vpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}jpo.isMDXComponent=!0;const Hpo={toc:[]},Ypo="wrapper";function Qpo(e){let{components:n,...t}=e;return(0,s.yg)(Ypo,(0,p.A)({},Hpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Qpo.isMDXComponent=!0;const $po={toc:[]},Kpo="wrapper";function Jpo(e){let{components:n,...t}=e;return(0,s.yg)(Kpo,(0,p.A)({},$po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Jpo.isMDXComponent=!0;const Zpo={toc:[]},ero="wrapper";function nro(e){let{components:n,...t}=e;return(0,s.yg)(ero,(0,p.A)({},Zpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}nro.isMDXComponent=!0;const tro={toc:[]},oro="wrapper";function pro(e){let{components:n,...t}=e;return(0,s.yg)(oro,(0,p.A)({},tro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}pro.isMDXComponent=!0;const rro={toc:[]},sro="wrapper";function cro(e){let{components:n,...t}=e;return(0,s.yg)(sro,(0,p.A)({},rro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}cro.isMDXComponent=!0;const aro={toc:[]},iro="wrapper";function lro(e){let{components:n,...t}=e;return(0,s.yg)(iro,(0,p.A)({},aro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lro.isMDXComponent=!0;const uro={toc:[]},mro="wrapper";function yro(e){let{components:n,...t}=e;return(0,s.yg)(mro,(0,p.A)({},uro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}yro.isMDXComponent=!0;const dro={toc:[]},hro="wrapper";function gro(e){let{components:n,...t}=e;return(0,s.yg)(hro,(0,p.A)({},dro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}gro.isMDXComponent=!0;const fro={toc:[]},Dro="wrapper";function Mro(e){let{components:n,...t}=e;return(0,s.yg)(Dro,(0,p.A)({},fro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Mro.isMDXComponent=!0;const Xro={toc:[]},_ro="wrapper";function wro(e){let{components:n,...t}=e;return(0,s.yg)(_ro,(0,p.A)({},Xro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}wro.isMDXComponent=!0;const Tro={toc:[]},Cro="wrapper";function xro(e){let{components:n,...t}=e;return(0,s.yg)(Cro,(0,p.A)({},Tro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}xro.isMDXComponent=!0;const Aro={toc:[]},vro="wrapper";function Lro(e){let{components:n,...t}=e;return(0,s.yg)(vro,(0,p.A)({},Aro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Lro.isMDXComponent=!0;const bro={toc:[]},Nro="wrapper";function kro(e){let{components:n,...t}=e;return(0,s.yg)(Nro,(0,p.A)({},bro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}kro.isMDXComponent=!0;const zro={toc:[]},Pro="wrapper";function Iro(e){let{components:n,...t}=e;return(0,s.yg)(Pro,(0,p.A)({},zro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Iro.isMDXComponent=!0;const Rro={toc:[]},Wro="wrapper";function Sro(e){let{components:n,...t}=e;return(0,s.yg)(Wro,(0,p.A)({},Rro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Sro.isMDXComponent=!0;const Bro={toc:[]},Gro="wrapper";function Ero(e){let{components:n,...t}=e;return(0,s.yg)(Gro,(0,p.A)({},Bro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Ero.isMDXComponent=!0;const Oro={toc:[]},Uro="wrapper";function Fro(e){let{components:n,...t}=e;return(0,s.yg)(Uro,(0,p.A)({},Oro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Fro.isMDXComponent=!0;const Vro={toc:[]},qro="wrapper";function jro(e){let{components:n,...t}=e;return(0,s.yg)(qro,(0,p.A)({},Vro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}jro.isMDXComponent=!0;const Hro={toc:[]},Yro="wrapper";function Qro(e){let{components:n,...t}=e;return(0,s.yg)(Yro,(0,p.A)({},Hro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Qro.isMDXComponent=!0;const $ro={toc:[]},Kro="wrapper";function Jro(e){let{components:n,...t}=e;return(0,s.yg)(Kro,(0,p.A)({},$ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Jro.isMDXComponent=!0;const Zro={toc:[]},eso="wrapper";function nso(e){let{components:n,...t}=e;return(0,s.yg)(eso,(0,p.A)({},Zro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}nso.isMDXComponent=!0;const tso={toc:[]},oso="wrapper";function pso(e){let{components:n,...t}=e;return(0,s.yg)(oso,(0,p.A)({},tso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}pso.isMDXComponent=!0;const rso={toc:[]},sso="wrapper";function cso(e){let{components:n,...t}=e;return(0,s.yg)(sso,(0,p.A)({},rso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}cso.isMDXComponent=!0;const aso={toc:[]},iso="wrapper";function lso(e){let{components:n,...t}=e;return(0,s.yg)(iso,(0,p.A)({},aso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}lso.isMDXComponent=!0;const uso={toc:[]},mso="wrapper";function yso(e){let{components:n,...t}=e;return(0,s.yg)(mso,(0,p.A)({},uso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yso.isMDXComponent=!0;const dso={toc:[]},hso="wrapper";function gso(e){let{components:n,...t}=e;return(0,s.yg)(hso,(0,p.A)({},dso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}gso.isMDXComponent=!0;const fso={toc:[]},Dso="wrapper";function Mso(e){let{components:n,...t}=e;return(0,s.yg)(Dso,(0,p.A)({},fso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Mso.isMDXComponent=!0;const Xso={toc:[]},_so="wrapper";function wso(e){let{components:n,...t}=e;return(0,s.yg)(_so,(0,p.A)({},Xso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wso.isMDXComponent=!0;const Tso={toc:[]},Cso="wrapper";function xso(e){let{components:n,...t}=e;return(0,s.yg)(Cso,(0,p.A)({},Tso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}xso.isMDXComponent=!0;const Aso={toc:[]},vso="wrapper";function Lso(e){let{components:n,...t}=e;return(0,s.yg)(vso,(0,p.A)({},Aso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Lso.isMDXComponent=!0;const bso={toc:[]},Nso="wrapper";function kso(e){let{components:n,...t}=e;return(0,s.yg)(Nso,(0,p.A)({},bso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}kso.isMDXComponent=!0;const zso={toc:[]},Pso="wrapper";function Iso(e){let{components:n,...t}=e;return(0,s.yg)(Pso,(0,p.A)({},zso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Iso.isMDXComponent=!0;const Rso={toc:[]},Wso="wrapper";function Sso(e){let{components:n,...t}=e;return(0,s.yg)(Wso,(0,p.A)({},Rso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Sso.isMDXComponent=!0;const Bso={toc:[]},Gso="wrapper";function Eso(e){let{components:n,...t}=e;return(0,s.yg)(Gso,(0,p.A)({},Bso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Eso.isMDXComponent=!0;const Oso={toc:[]},Uso="wrapper";function Fso(e){let{components:n,...t}=e;return(0,s.yg)(Uso,(0,p.A)({},Oso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fso.isMDXComponent=!0;const Vso={toc:[]},qso="wrapper";function jso(e){let{components:n,...t}=e;return(0,s.yg)(qso,(0,p.A)({},Vso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}jso.isMDXComponent=!0;const Hso={toc:[]},Yso="wrapper";function Qso(e){let{components:n,...t}=e;return(0,s.yg)(Yso,(0,p.A)({},Hso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qso.isMDXComponent=!0;const $so={toc:[]},Kso="wrapper";function Jso(e){let{components:n,...t}=e;return(0,s.yg)(Kso,(0,p.A)({},$so,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Jso.isMDXComponent=!0;const Zso={toc:[]},eco="wrapper";function nco(e){let{components:n,...t}=e;return(0,s.yg)(eco,(0,p.A)({},Zso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nco.isMDXComponent=!0;const tco={toc:[]},oco="wrapper";function pco(e){let{components:n,...t}=e;return(0,s.yg)(oco,(0,p.A)({},tco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}pco.isMDXComponent=!0;const rco={toc:[]},sco="wrapper";function cco(e){let{components:n,...t}=e;return(0,s.yg)(sco,(0,p.A)({},rco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cco.isMDXComponent=!0;const aco={toc:[]},ico="wrapper";function lco(e){let{components:n,...t}=e;return(0,s.yg)(ico,(0,p.A)({},aco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}lco.isMDXComponent=!0;const uco={toc:[]},mco="wrapper";function yco(e){let{components:n,...t}=e;return(0,s.yg)(mco,(0,p.A)({},uco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yco.isMDXComponent=!0;const dco={toc:[]},hco="wrapper";function gco(e){let{components:n,...t}=e;return(0,s.yg)(hco,(0,p.A)({},dco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}gco.isMDXComponent=!0;const fco={toc:[]},Dco="wrapper";function Mco(e){let{components:n,...t}=e;return(0,s.yg)(Dco,(0,p.A)({},fco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mco.isMDXComponent=!0;const Xco={toc:[]},_co="wrapper";function wco(e){let{components:n,...t}=e;return(0,s.yg)(_co,(0,p.A)({},Xco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}wco.isMDXComponent=!0;const Tco={toc:[]},Cco="wrapper";function xco(e){let{components:n,...t}=e;return(0,s.yg)(Cco,(0,p.A)({},Tco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xco.isMDXComponent=!0;const Aco={toc:[]},vco="wrapper";function Lco(e){let{components:n,...t}=e;return(0,s.yg)(vco,(0,p.A)({},Aco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Lco.isMDXComponent=!0;const bco={toc:[]},Nco="wrapper";function kco(e){let{components:n,...t}=e;return(0,s.yg)(Nco,(0,p.A)({},bco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kco.isMDXComponent=!0;const zco={toc:[]},Pco="wrapper";function Ico(e){let{components:n,...t}=e;return(0,s.yg)(Pco,(0,p.A)({},zco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Ico.isMDXComponent=!0;const Rco={toc:[]},Wco="wrapper";function Sco(e){let{components:n,...t}=e;return(0,s.yg)(Wco,(0,p.A)({},Rco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Sco.isMDXComponent=!0;const Bco={toc:[]},Gco="wrapper";function Eco(e){let{components:n,...t}=e;return(0,s.yg)(Gco,(0,p.A)({},Bco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Eco.isMDXComponent=!0;const Oco={toc:[]},Uco="wrapper";function Fco(e){let{components:n,...t}=e;return(0,s.yg)(Uco,(0,p.A)({},Oco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Fco.isMDXComponent=!0;const Vco={toc:[]},qco="wrapper";function jco(e){let{components:n,...t}=e;return(0,s.yg)(qco,(0,p.A)({},Vco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}jco.isMDXComponent=!0;const Hco={toc:[]},Yco="wrapper";function Qco(e){let{components:n,...t}=e;return(0,s.yg)(Yco,(0,p.A)({},Hco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Qco.isMDXComponent=!0;const $co={toc:[]},Kco="wrapper";function Jco(e){let{components:n,...t}=e;return(0,s.yg)(Kco,(0,p.A)({},$co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Jco.isMDXComponent=!0;const Zco={toc:[]},eao="wrapper";function nao(e){let{components:n,...t}=e;return(0,s.yg)(eao,(0,p.A)({},Zco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}nao.isMDXComponent=!0;const tao={toc:[]},oao="wrapper";function pao(e){let{components:n,...t}=e;return(0,s.yg)(oao,(0,p.A)({},tao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}pao.isMDXComponent=!0;const rao={toc:[]},sao="wrapper";function cao(e){let{components:n,...t}=e;return(0,s.yg)(sao,(0,p.A)({},rao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}cao.isMDXComponent=!0;const aao={toc:[]},iao="wrapper";function lao(e){let{components:n,...t}=e;return(0,s.yg)(iao,(0,p.A)({},aao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}lao.isMDXComponent=!0;const uao={toc:[]},mao="wrapper";function yao(e){let{components:n,...t}=e;return(0,s.yg)(mao,(0,p.A)({},uao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}yao.isMDXComponent=!0;const dao={toc:[]},hao="wrapper";function gao(e){let{components:n,...t}=e;return(0,s.yg)(hao,(0,p.A)({},dao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gao.isMDXComponent=!0;const fao={toc:[]},Dao="wrapper";function Mao(e){let{components:n,...t}=e;return(0,s.yg)(Dao,(0,p.A)({},fao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Mao.isMDXComponent=!0;const Xao={toc:[]},_ao="wrapper";function wao(e){let{components:n,...t}=e;return(0,s.yg)(_ao,(0,p.A)({},Xao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wao.isMDXComponent=!0;const Tao={toc:[]},Cao="wrapper";function xao(e){let{components:n,...t}=e;return(0,s.yg)(Cao,(0,p.A)({},Tao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}xao.isMDXComponent=!0;const Aao={toc:[]},vao="wrapper";function Lao(e){let{components:n,...t}=e;return(0,s.yg)(vao,(0,p.A)({},Aao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Lao.isMDXComponent=!0;const bao={toc:[]},Nao="wrapper";function kao(e){let{components:n,...t}=e;return(0,s.yg)(Nao,(0,p.A)({},bao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kao.isMDXComponent=!0;const zao={toc:[]},Pao="wrapper";function Iao(e){let{components:n,...t}=e;return(0,s.yg)(Pao,(0,p.A)({},zao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Iao.isMDXComponent=!0;const Rao={toc:[]},Wao="wrapper";function Sao(e){let{components:n,...t}=e;return(0,s.yg)(Wao,(0,p.A)({},Rao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Sao.isMDXComponent=!0;const Bao={toc:[]},Gao="wrapper";function Eao(e){let{components:n,...t}=e;return(0,s.yg)(Gao,(0,p.A)({},Bao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Eao.isMDXComponent=!0;const Oao={toc:[]},Uao="wrapper";function Fao(e){let{components:n,...t}=e;return(0,s.yg)(Uao,(0,p.A)({},Oao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Fao.isMDXComponent=!0;const Vao={toc:[]},qao="wrapper";function jao(e){let{components:n,...t}=e;return(0,s.yg)(qao,(0,p.A)({},Vao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}jao.isMDXComponent=!0;const Hao={toc:[]},Yao="wrapper";function Qao(e){let{components:n,...t}=e;return(0,s.yg)(Yao,(0,p.A)({},Hao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Qao.isMDXComponent=!0;const $ao={toc:[]},Kao="wrapper";function Jao(e){let{components:n,...t}=e;return(0,s.yg)(Kao,(0,p.A)({},$ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Jao.isMDXComponent=!0;const Zao={toc:[]},eio="wrapper";function nio(e){let{components:n,...t}=e;return(0,s.yg)(eio,(0,p.A)({},Zao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nio.isMDXComponent=!0;const tio={toc:[]},oio="wrapper";function pio(e){let{components:n,...t}=e;return(0,s.yg)(oio,(0,p.A)({},tio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pio.isMDXComponent=!0;const rio={toc:[]},sio="wrapper";function cio(e){let{components:n,...t}=e;return(0,s.yg)(sio,(0,p.A)({},rio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}cio.isMDXComponent=!0;const aio={toc:[]},iio="wrapper";function lio(e){let{components:n,...t}=e;return(0,s.yg)(iio,(0,p.A)({},aio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}lio.isMDXComponent=!0;const uio={toc:[]},mio="wrapper";function yio(e){let{components:n,...t}=e;return(0,s.yg)(mio,(0,p.A)({},uio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}yio.isMDXComponent=!0;const dio={toc:[]},hio="wrapper";function gio(e){let{components:n,...t}=e;return(0,s.yg)(hio,(0,p.A)({},dio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gio.isMDXComponent=!0;const fio={toc:[]},Dio="wrapper";function Mio(e){let{components:n,...t}=e;return(0,s.yg)(Dio,(0,p.A)({},fio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Mio.isMDXComponent=!0;const Xio={toc:[]},_io="wrapper";function wio(e){let{components:n,...t}=e;return(0,s.yg)(_io,(0,p.A)({},Xio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wio.isMDXComponent=!0;const Tio={toc:[]},Cio="wrapper";function xio(e){let{components:n,...t}=e;return(0,s.yg)(Cio,(0,p.A)({},Tio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}xio.isMDXComponent=!0;const Aio={toc:[]},vio="wrapper";function Lio(e){let{components:n,...t}=e;return(0,s.yg)(vio,(0,p.A)({},Aio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Lio.isMDXComponent=!0;const bio={toc:[]},Nio="wrapper";function kio(e){let{components:n,...t}=e;return(0,s.yg)(Nio,(0,p.A)({},bio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}kio.isMDXComponent=!0;const zio={toc:[]},Pio="wrapper";function Iio(e){let{components:n,...t}=e;return(0,s.yg)(Pio,(0,p.A)({},zio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Iio.isMDXComponent=!0;const Rio={toc:[]},Wio="wrapper";function Sio(e){let{components:n,...t}=e;return(0,s.yg)(Wio,(0,p.A)({},Rio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Sio.isMDXComponent=!0;const Bio={toc:[]},Gio="wrapper";function Eio(e){let{components:n,...t}=e;return(0,s.yg)(Gio,(0,p.A)({},Bio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Eio.isMDXComponent=!0;const Oio={toc:[]},Uio="wrapper";function Fio(e){let{components:n,...t}=e;return(0,s.yg)(Uio,(0,p.A)({},Oio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fio.isMDXComponent=!0;const Vio={toc:[]},qio="wrapper";function jio(e){let{components:n,...t}=e;return(0,s.yg)(qio,(0,p.A)({},Vio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}jio.isMDXComponent=!0;const Hio={toc:[]},Yio="wrapper";function Qio(e){let{components:n,...t}=e;return(0,s.yg)(Yio,(0,p.A)({},Hio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Qio.isMDXComponent=!0;const $io={toc:[]},Kio="wrapper";function Jio(e){let{components:n,...t}=e;return(0,s.yg)(Kio,(0,p.A)({},$io,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Jio.isMDXComponent=!0;const Zio={toc:[]},elo="wrapper";function nlo(e){let{components:n,...t}=e;return(0,s.yg)(elo,(0,p.A)({},Zio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}nlo.isMDXComponent=!0;const tlo={toc:[]},olo="wrapper";function plo(e){let{components:n,...t}=e;return(0,s.yg)(olo,(0,p.A)({},tlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}plo.isMDXComponent=!0;const rlo={toc:[]},slo="wrapper";function clo(e){let{components:n,...t}=e;return(0,s.yg)(slo,(0,p.A)({},rlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}clo.isMDXComponent=!0;const alo={toc:[]},ilo="wrapper";function llo(e){let{components:n,...t}=e;return(0,s.yg)(ilo,(0,p.A)({},alo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}llo.isMDXComponent=!0;const ulo={toc:[]},mlo="wrapper";function ylo(e){let{components:n,...t}=e;return(0,s.yg)(mlo,(0,p.A)({},ulo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}ylo.isMDXComponent=!0;const dlo={toc:[]},hlo="wrapper";function glo(e){let{components:n,...t}=e;return(0,s.yg)(hlo,(0,p.A)({},dlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}glo.isMDXComponent=!0;const flo={toc:[]},Dlo="wrapper";function Mlo(e){let{components:n,...t}=e;return(0,s.yg)(Dlo,(0,p.A)({},flo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Mlo.isMDXComponent=!0;const Xlo={toc:[]},_lo="wrapper";function wlo(e){let{components:n,...t}=e;return(0,s.yg)(_lo,(0,p.A)({},Xlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}wlo.isMDXComponent=!0;const Tlo={toc:[]},Clo="wrapper";function xlo(e){let{components:n,...t}=e;return(0,s.yg)(Clo,(0,p.A)({},Tlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}xlo.isMDXComponent=!0;const Alo={toc:[]},vlo="wrapper";function Llo(e){let{components:n,...t}=e;return(0,s.yg)(vlo,(0,p.A)({},Alo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Llo.isMDXComponent=!0;const blo={toc:[]},Nlo="wrapper";function klo(e){let{components:n,...t}=e;return(0,s.yg)(Nlo,(0,p.A)({},blo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}klo.isMDXComponent=!0;const zlo={toc:[]},Plo="wrapper";function Ilo(e){let{components:n,...t}=e;return(0,s.yg)(Plo,(0,p.A)({},zlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Ilo.isMDXComponent=!0;const Rlo={toc:[]},Wlo="wrapper";function Slo(e){let{components:n,...t}=e;return(0,s.yg)(Wlo,(0,p.A)({},Rlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Slo.isMDXComponent=!0;const Blo={toc:[]},Glo="wrapper";function Elo(e){let{components:n,...t}=e;return(0,s.yg)(Glo,(0,p.A)({},Blo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Elo.isMDXComponent=!0;const Olo={toc:[]},Ulo="wrapper";function Flo(e){let{components:n,...t}=e;return(0,s.yg)(Ulo,(0,p.A)({},Olo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Flo.isMDXComponent=!0;const Vlo={toc:[]},qlo="wrapper";function jlo(e){let{components:n,...t}=e;return(0,s.yg)(qlo,(0,p.A)({},Vlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}jlo.isMDXComponent=!0;const Hlo={toc:[]},Ylo="wrapper";function Qlo(e){let{components:n,...t}=e;return(0,s.yg)(Ylo,(0,p.A)({},Hlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Qlo.isMDXComponent=!0;const $lo={toc:[]},Klo="wrapper";function Jlo(e){let{components:n,...t}=e;return(0,s.yg)(Klo,(0,p.A)({},$lo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Jlo.isMDXComponent=!0;const Zlo={toc:[]},euo="wrapper";function nuo(e){let{components:n,...t}=e;return(0,s.yg)(euo,(0,p.A)({},Zlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}nuo.isMDXComponent=!0;const tuo={toc:[]},ouo="wrapper";function puo(e){let{components:n,...t}=e;return(0,s.yg)(ouo,(0,p.A)({},tuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}puo.isMDXComponent=!0;const ruo={toc:[]},suo="wrapper";function cuo(e){let{components:n,...t}=e;return(0,s.yg)(suo,(0,p.A)({},ruo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}cuo.isMDXComponent=!0;const auo={toc:[]},iuo="wrapper";function luo(e){let{components:n,...t}=e;return(0,s.yg)(iuo,(0,p.A)({},auo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}luo.isMDXComponent=!0;const uuo={toc:[]},muo="wrapper";function yuo(e){let{components:n,...t}=e;return(0,s.yg)(muo,(0,p.A)({},uuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}yuo.isMDXComponent=!0;const duo={toc:[]},huo="wrapper";function guo(e){let{components:n,...t}=e;return(0,s.yg)(huo,(0,p.A)({},duo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}guo.isMDXComponent=!0;const fuo={toc:[]},Duo="wrapper";function Muo(e){let{components:n,...t}=e;return(0,s.yg)(Duo,(0,p.A)({},fuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Muo.isMDXComponent=!0;const Xuo={toc:[]},_uo="wrapper";function wuo(e){let{components:n,...t}=e;return(0,s.yg)(_uo,(0,p.A)({},Xuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}wuo.isMDXComponent=!0;const Tuo={toc:[]},Cuo="wrapper";function xuo(e){let{components:n,...t}=e;return(0,s.yg)(Cuo,(0,p.A)({},Tuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}xuo.isMDXComponent=!0;const Auo={toc:[]},vuo="wrapper";function Luo(e){let{components:n,...t}=e;return(0,s.yg)(vuo,(0,p.A)({},Auo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Luo.isMDXComponent=!0;const buo={toc:[]},Nuo="wrapper";function kuo(e){let{components:n,...t}=e;return(0,s.yg)(Nuo,(0,p.A)({},buo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}kuo.isMDXComponent=!0;const zuo={toc:[]},Puo="wrapper";function Iuo(e){let{components:n,...t}=e;return(0,s.yg)(Puo,(0,p.A)({},zuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Iuo.isMDXComponent=!0;const Ruo={toc:[]},Wuo="wrapper";function Suo(e){let{components:n,...t}=e;return(0,s.yg)(Wuo,(0,p.A)({},Ruo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Suo.isMDXComponent=!0;const Buo={toc:[]},Guo="wrapper";function Euo(e){let{components:n,...t}=e;return(0,s.yg)(Guo,(0,p.A)({},Buo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Euo.isMDXComponent=!0;const Ouo={toc:[]},Uuo="wrapper";function Fuo(e){let{components:n,...t}=e;return(0,s.yg)(Uuo,(0,p.A)({},Ouo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Fuo.isMDXComponent=!0;const Vuo={toc:[]},quo="wrapper";function juo(e){let{components:n,...t}=e;return(0,s.yg)(quo,(0,p.A)({},Vuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}juo.isMDXComponent=!0;const Huo={toc:[]},Yuo="wrapper";function Quo(e){let{components:n,...t}=e;return(0,s.yg)(Yuo,(0,p.A)({},Huo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Quo.isMDXComponent=!0;const $uo={toc:[]},Kuo="wrapper";function Juo(e){let{components:n,...t}=e;return(0,s.yg)(Kuo,(0,p.A)({},$uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Juo.isMDXComponent=!0;const Zuo={toc:[]},emo="wrapper";function nmo(e){let{components:n,...t}=e;return(0,s.yg)(emo,(0,p.A)({},Zuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}nmo.isMDXComponent=!0;const tmo={toc:[]},omo="wrapper";function pmo(e){let{components:n,...t}=e;return(0,s.yg)(omo,(0,p.A)({},tmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}pmo.isMDXComponent=!0;const rmo={toc:[]},smo="wrapper";function cmo(e){let{components:n,...t}=e;return(0,s.yg)(smo,(0,p.A)({},rmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}cmo.isMDXComponent=!0;const amo={toc:[]},imo="wrapper";function lmo(e){let{components:n,...t}=e;return(0,s.yg)(imo,(0,p.A)({},amo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}lmo.isMDXComponent=!0;const umo={toc:[]},mmo="wrapper";function ymo(e){let{components:n,...t}=e;return(0,s.yg)(mmo,(0,p.A)({},umo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}ymo.isMDXComponent=!0;const dmo={toc:[]},hmo="wrapper";function gmo(e){let{components:n,...t}=e;return(0,s.yg)(hmo,(0,p.A)({},dmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}gmo.isMDXComponent=!0;const fmo={toc:[]},Dmo="wrapper";function Mmo(e){let{components:n,...t}=e;return(0,s.yg)(Dmo,(0,p.A)({},fmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Mmo.isMDXComponent=!0;const Xmo={toc:[]},_mo="wrapper";function wmo(e){let{components:n,...t}=e;return(0,s.yg)(_mo,(0,p.A)({},Xmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}wmo.isMDXComponent=!0;const Tmo={toc:[]},Cmo="wrapper";function xmo(e){let{components:n,...t}=e;return(0,s.yg)(Cmo,(0,p.A)({},Tmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}xmo.isMDXComponent=!0;const Amo={toc:[]},vmo="wrapper";function Lmo(e){let{components:n,...t}=e;return(0,s.yg)(vmo,(0,p.A)({},Amo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lmo.isMDXComponent=!0;const bmo={toc:[]},Nmo="wrapper";function kmo(e){let{components:n,...t}=e;return(0,s.yg)(Nmo,(0,p.A)({},bmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kmo.isMDXComponent=!0;const zmo={toc:[]},Pmo="wrapper";function Imo(e){let{components:n,...t}=e;return(0,s.yg)(Pmo,(0,p.A)({},zmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Imo.isMDXComponent=!0;const Rmo={toc:[]},Wmo="wrapper";function Smo(e){let{components:n,...t}=e;return(0,s.yg)(Wmo,(0,p.A)({},Rmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Smo.isMDXComponent=!0;const Bmo={toc:[]},Gmo="wrapper";function Emo(e){let{components:n,...t}=e;return(0,s.yg)(Gmo,(0,p.A)({},Bmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Emo.isMDXComponent=!0;const Omo={toc:[]},Umo="wrapper";function Fmo(e){let{components:n,...t}=e;return(0,s.yg)(Umo,(0,p.A)({},Omo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Fmo.isMDXComponent=!0;const Vmo={toc:[]},qmo="wrapper";function jmo(e){let{components:n,...t}=e;return(0,s.yg)(qmo,(0,p.A)({},Vmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}jmo.isMDXComponent=!0;const Hmo={toc:[]},Ymo="wrapper";function Qmo(e){let{components:n,...t}=e;return(0,s.yg)(Ymo,(0,p.A)({},Hmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Qmo.isMDXComponent=!0;const $mo={toc:[]},Kmo="wrapper";function Jmo(e){let{components:n,...t}=e;return(0,s.yg)(Kmo,(0,p.A)({},$mo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Jmo.isMDXComponent=!0;const Zmo={toc:[]},eyo="wrapper";function nyo(e){let{components:n,...t}=e;return(0,s.yg)(eyo,(0,p.A)({},Zmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}nyo.isMDXComponent=!0;const tyo={toc:[]},oyo="wrapper";function pyo(e){let{components:n,...t}=e;return(0,s.yg)(oyo,(0,p.A)({},tyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}pyo.isMDXComponent=!0;const ryo={toc:[]},syo="wrapper";function cyo(e){let{components:n,...t}=e;return(0,s.yg)(syo,(0,p.A)({},ryo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}cyo.isMDXComponent=!0;const ayo={toc:[]},iyo="wrapper";function lyo(e){let{components:n,...t}=e;return(0,s.yg)(iyo,(0,p.A)({},ayo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lyo.isMDXComponent=!0;const uyo={toc:[]},myo="wrapper";function yyo(e){let{components:n,...t}=e;return(0,s.yg)(myo,(0,p.A)({},uyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}yyo.isMDXComponent=!0;const dyo={toc:[]},hyo="wrapper";function gyo(e){let{components:n,...t}=e;return(0,s.yg)(hyo,(0,p.A)({},dyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}gyo.isMDXComponent=!0;const fyo={toc:[]},Dyo="wrapper";function Myo(e){let{components:n,...t}=e;return(0,s.yg)(Dyo,(0,p.A)({},fyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Myo.isMDXComponent=!0;const Xyo={toc:[]},_yo="wrapper";function wyo(e){let{components:n,...t}=e;return(0,s.yg)(_yo,(0,p.A)({},Xyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}wyo.isMDXComponent=!0;const Tyo={toc:[]},Cyo="wrapper";function xyo(e){let{components:n,...t}=e;return(0,s.yg)(Cyo,(0,p.A)({},Tyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}xyo.isMDXComponent=!0;const Ayo={toc:[]},vyo="wrapper";function Lyo(e){let{components:n,...t}=e;return(0,s.yg)(vyo,(0,p.A)({},Ayo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Lyo.isMDXComponent=!0;const byo={toc:[]},Nyo="wrapper";function kyo(e){let{components:n,...t}=e;return(0,s.yg)(Nyo,(0,p.A)({},byo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}kyo.isMDXComponent=!0;const zyo={toc:[]},Pyo="wrapper";function Iyo(e){let{components:n,...t}=e;return(0,s.yg)(Pyo,(0,p.A)({},zyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Iyo.isMDXComponent=!0;const Ryo={toc:[]},Wyo="wrapper";function Syo(e){let{components:n,...t}=e;return(0,s.yg)(Wyo,(0,p.A)({},Ryo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Syo.isMDXComponent=!0;const Byo={toc:[]},Gyo="wrapper";function Eyo(e){let{components:n,...t}=e;return(0,s.yg)(Gyo,(0,p.A)({},Byo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Eyo.isMDXComponent=!0;const Oyo={toc:[]},Uyo="wrapper";function Fyo(e){let{components:n,...t}=e;return(0,s.yg)(Uyo,(0,p.A)({},Oyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Fyo.isMDXComponent=!0;const Vyo={toc:[]},qyo="wrapper";function jyo(e){let{components:n,...t}=e;return(0,s.yg)(qyo,(0,p.A)({},Vyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jyo.isMDXComponent=!0;const Hyo={toc:[]},Yyo="wrapper";function Qyo(e){let{components:n,...t}=e;return(0,s.yg)(Yyo,(0,p.A)({},Hyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Qyo.isMDXComponent=!0;const $yo={toc:[]},Kyo="wrapper";function Jyo(e){let{components:n,...t}=e;return(0,s.yg)(Kyo,(0,p.A)({},$yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Jyo.isMDXComponent=!0;const Zyo={toc:[]},edo="wrapper";function ndo(e){let{components:n,...t}=e;return(0,s.yg)(edo,(0,p.A)({},Zyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}ndo.isMDXComponent=!0;const tdo={toc:[]},odo="wrapper";function pdo(e){let{components:n,...t}=e;return(0,s.yg)(odo,(0,p.A)({},tdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}pdo.isMDXComponent=!0;const rdo={toc:[]},sdo="wrapper";function cdo(e){let{components:n,...t}=e;return(0,s.yg)(sdo,(0,p.A)({},rdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}cdo.isMDXComponent=!0;const ado={toc:[]},ido="wrapper";function ldo(e){let{components:n,...t}=e;return(0,s.yg)(ido,(0,p.A)({},ado,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}ldo.isMDXComponent=!0;const udo={toc:[]},mdo="wrapper";function ydo(e){let{components:n,...t}=e;return(0,s.yg)(mdo,(0,p.A)({},udo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ydo.isMDXComponent=!0;const ddo={toc:[]},hdo="wrapper";function gdo(e){let{components:n,...t}=e;return(0,s.yg)(hdo,(0,p.A)({},ddo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}gdo.isMDXComponent=!0;const fdo={toc:[]},Ddo="wrapper";function Mdo(e){let{components:n,...t}=e;return(0,s.yg)(Ddo,(0,p.A)({},fdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mdo.isMDXComponent=!0;const Xdo={toc:[]},_do="wrapper";function wdo(e){let{components:n,...t}=e;return(0,s.yg)(_do,(0,p.A)({},Xdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}wdo.isMDXComponent=!0;const Tdo={toc:[]},Cdo="wrapper";function xdo(e){let{components:n,...t}=e;return(0,s.yg)(Cdo,(0,p.A)({},Tdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}xdo.isMDXComponent=!0;const Ado={toc:[]},vdo="wrapper";function Ldo(e){let{components:n,...t}=e;return(0,s.yg)(vdo,(0,p.A)({},Ado,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Ldo.isMDXComponent=!0;const bdo={toc:[]},Ndo="wrapper";function kdo(e){let{components:n,...t}=e;return(0,s.yg)(Ndo,(0,p.A)({},bdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}kdo.isMDXComponent=!0;const zdo={toc:[]},Pdo="wrapper";function Ido(e){let{components:n,...t}=e;return(0,s.yg)(Pdo,(0,p.A)({},zdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ido.isMDXComponent=!0;const Rdo={toc:[]},Wdo="wrapper";function Sdo(e){let{components:n,...t}=e;return(0,s.yg)(Wdo,(0,p.A)({},Rdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Sdo.isMDXComponent=!0;const Bdo={toc:[]},Gdo="wrapper";function Edo(e){let{components:n,...t}=e;return(0,s.yg)(Gdo,(0,p.A)({},Bdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Edo.isMDXComponent=!0;const Odo={toc:[]},Udo="wrapper";function Fdo(e){let{components:n,...t}=e;return(0,s.yg)(Udo,(0,p.A)({},Odo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Fdo.isMDXComponent=!0;const Vdo={toc:[]},qdo="wrapper";function jdo(e){let{components:n,...t}=e;return(0,s.yg)(qdo,(0,p.A)({},Vdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}jdo.isMDXComponent=!0;const Hdo={toc:[]},Ydo="wrapper";function Qdo(e){let{components:n,...t}=e;return(0,s.yg)(Ydo,(0,p.A)({},Hdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Qdo.isMDXComponent=!0;const $do={toc:[]},Kdo="wrapper";function Jdo(e){let{components:n,...t}=e;return(0,s.yg)(Kdo,(0,p.A)({},$do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Jdo.isMDXComponent=!0;const Zdo={toc:[]},eho="wrapper";function nho(e){let{components:n,...t}=e;return(0,s.yg)(eho,(0,p.A)({},Zdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}nho.isMDXComponent=!0;const tho={toc:[]},oho="wrapper";function pho(e){let{components:n,...t}=e;return(0,s.yg)(oho,(0,p.A)({},tho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}pho.isMDXComponent=!0;const rho={toc:[]},sho="wrapper";function cho(e){let{components:n,...t}=e;return(0,s.yg)(sho,(0,p.A)({},rho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}cho.isMDXComponent=!0;const aho={toc:[]},iho="wrapper";function lho(e){let{components:n,...t}=e;return(0,s.yg)(iho,(0,p.A)({},aho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}lho.isMDXComponent=!0;const uho={toc:[]},mho="wrapper";function yho(e){let{components:n,...t}=e;return(0,s.yg)(mho,(0,p.A)({},uho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}yho.isMDXComponent=!0;const dho={toc:[]},hho="wrapper";function gho(e){let{components:n,...t}=e;return(0,s.yg)(hho,(0,p.A)({},dho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}gho.isMDXComponent=!0;const fho={toc:[]},Dho="wrapper";function Mho(e){let{components:n,...t}=e;return(0,s.yg)(Dho,(0,p.A)({},fho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Mho.isMDXComponent=!0;const Xho={toc:[]},_ho="wrapper";function who(e){let{components:n,...t}=e;return(0,s.yg)(_ho,(0,p.A)({},Xho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}who.isMDXComponent=!0;const Tho={toc:[]},Cho="wrapper";function xho(e){let{components:n,...t}=e;return(0,s.yg)(Cho,(0,p.A)({},Tho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xho.isMDXComponent=!0;const Aho={toc:[]},vho="wrapper";function Lho(e){let{components:n,...t}=e;return(0,s.yg)(vho,(0,p.A)({},Aho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Lho.isMDXComponent=!0;const bho={toc:[]},Nho="wrapper";function kho(e){let{components:n,...t}=e;return(0,s.yg)(Nho,(0,p.A)({},bho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}kho.isMDXComponent=!0;const zho={toc:[]},Pho="wrapper";function Iho(e){let{components:n,...t}=e;return(0,s.yg)(Pho,(0,p.A)({},zho,t,{components:n,mdxType:"MDXLayout"}))}Iho.isMDXComponent=!0;const Rho={toc:[]},Who="wrapper";function Sho(e){let{components:n,...t}=e;return(0,s.yg)(Who,(0,p.A)({},Rho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Sho.isMDXComponent=!0;const Bho={toc:[]},Gho="wrapper";function Eho(e){let{components:n,...t}=e;return(0,s.yg)(Gho,(0,p.A)({},Bho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Eho.isMDXComponent=!0;const Oho={toc:[]},Uho="wrapper";function Fho(e){let{components:n,...t}=e;return(0,s.yg)(Uho,(0,p.A)({},Oho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Fho.isMDXComponent=!0;const Vho={toc:[]},qho="wrapper";function jho(e){let{components:n,...t}=e;return(0,s.yg)(qho,(0,p.A)({},Vho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}jho.isMDXComponent=!0;const Hho={toc:[]},Yho="wrapper";function Qho(e){let{components:n,...t}=e;return(0,s.yg)(Yho,(0,p.A)({},Hho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Qho.isMDXComponent=!0;const $ho={toc:[]},Kho="wrapper";function Jho(e){let{components:n,...t}=e;return(0,s.yg)(Kho,(0,p.A)({},$ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Jho.isMDXComponent=!0;const Zho={toc:[]},ego="wrapper";function ngo(e){let{components:n,...t}=e;return(0,s.yg)(ego,(0,p.A)({},Zho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}ngo.isMDXComponent=!0;const tgo={toc:[]},ogo="wrapper";function pgo(e){let{components:n,...t}=e;return(0,s.yg)(ogo,(0,p.A)({},tgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}pgo.isMDXComponent=!0;const rgo={toc:[]},sgo="wrapper";function cgo(e){let{components:n,...t}=e;return(0,s.yg)(sgo,(0,p.A)({},rgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}cgo.isMDXComponent=!0;const ago={toc:[]},igo="wrapper";function lgo(e){let{components:n,...t}=e;return(0,s.yg)(igo,(0,p.A)({},ago,t,{components:n,mdxType:"MDXLayout"}))}lgo.isMDXComponent=!0;const ugo={toc:[]},mgo="wrapper";function ygo(e){let{components:n,...t}=e;return(0,s.yg)(mgo,(0,p.A)({},ugo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ygo.isMDXComponent=!0;const dgo={toc:[]},hgo="wrapper";function ggo(e){let{components:n,...t}=e;return(0,s.yg)(hgo,(0,p.A)({},dgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}ggo.isMDXComponent=!0;const fgo={toc:[]},Dgo="wrapper";function Mgo(e){let{components:n,...t}=e;return(0,s.yg)(Dgo,(0,p.A)({},fgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mgo.isMDXComponent=!0;const Xgo={toc:[]},_go="wrapper";function wgo(e){let{components:n,...t}=e;return(0,s.yg)(_go,(0,p.A)({},Xgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}wgo.isMDXComponent=!0;const Tgo={toc:[]},Cgo="wrapper";function xgo(e){let{components:n,...t}=e;return(0,s.yg)(Cgo,(0,p.A)({},Tgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xgo.isMDXComponent=!0;const Ago={toc:[]},vgo="wrapper";function Lgo(e){let{components:n,...t}=e;return(0,s.yg)(vgo,(0,p.A)({},Ago,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Lgo.isMDXComponent=!0;const bgo={toc:[]},Ngo="wrapper";function kgo(e){let{components:n,...t}=e;return(0,s.yg)(Ngo,(0,p.A)({},bgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kgo.isMDXComponent=!0;const zgo={toc:[]},Pgo="wrapper";function Igo(e){let{components:n,...t}=e;return(0,s.yg)(Pgo,(0,p.A)({},zgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Igo.isMDXComponent=!0;const Rgo={toc:[]},Wgo="wrapper";function Sgo(e){let{components:n,...t}=e;return(0,s.yg)(Wgo,(0,p.A)({},Rgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Sgo.isMDXComponent=!0;const Bgo={toc:[]},Ggo="wrapper";function Ego(e){let{components:n,...t}=e;return(0,s.yg)(Ggo,(0,p.A)({},Bgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Ego.isMDXComponent=!0;const Ogo={toc:[]},Ugo="wrapper";function Fgo(e){let{components:n,...t}=e;return(0,s.yg)(Ugo,(0,p.A)({},Ogo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Fgo.isMDXComponent=!0;const Vgo={toc:[]},qgo="wrapper";function jgo(e){let{components:n,...t}=e;return(0,s.yg)(qgo,(0,p.A)({},Vgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}jgo.isMDXComponent=!0;const Hgo={toc:[]},Ygo="wrapper";function Qgo(e){let{components:n,...t}=e;return(0,s.yg)(Ygo,(0,p.A)({},Hgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Qgo.isMDXComponent=!0;const $go={toc:[]},Kgo="wrapper";function Jgo(e){let{components:n,...t}=e;return(0,s.yg)(Kgo,(0,p.A)({},$go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Jgo.isMDXComponent=!0;const Zgo={toc:[]},efo="wrapper";function nfo(e){let{components:n,...t}=e;return(0,s.yg)(efo,(0,p.A)({},Zgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}nfo.isMDXComponent=!0;const tfo={toc:[]},ofo="wrapper";function pfo(e){let{components:n,...t}=e;return(0,s.yg)(ofo,(0,p.A)({},tfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}pfo.isMDXComponent=!0;const rfo={toc:[]},sfo="wrapper";function cfo(e){let{components:n,...t}=e;return(0,s.yg)(sfo,(0,p.A)({},rfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cfo.isMDXComponent=!0;const afo={toc:[]},ifo="wrapper";function lfo(e){let{components:n,...t}=e;return(0,s.yg)(ifo,(0,p.A)({},afo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}lfo.isMDXComponent=!0;const ufo={toc:[]},mfo="wrapper";function yfo(e){let{components:n,...t}=e;return(0,s.yg)(mfo,(0,p.A)({},ufo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}yfo.isMDXComponent=!0;const dfo={toc:[]},hfo="wrapper";function gfo(e){let{components:n,...t}=e;return(0,s.yg)(hfo,(0,p.A)({},dfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}gfo.isMDXComponent=!0;const ffo={toc:[]},Dfo="wrapper";function Mfo(e){let{components:n,...t}=e;return(0,s.yg)(Dfo,(0,p.A)({},ffo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Mfo.isMDXComponent=!0;const Xfo={toc:[]},_fo="wrapper";function wfo(e){let{components:n,...t}=e;return(0,s.yg)(_fo,(0,p.A)({},Xfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}wfo.isMDXComponent=!0;const Tfo={toc:[]},Cfo="wrapper";function xfo(e){let{components:n,...t}=e;return(0,s.yg)(Cfo,(0,p.A)({},Tfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}xfo.isMDXComponent=!0;const Afo={toc:[]},vfo="wrapper";function Lfo(e){let{components:n,...t}=e;return(0,s.yg)(vfo,(0,p.A)({},Afo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Lfo.isMDXComponent=!0;const bfo={toc:[]},Nfo="wrapper";function kfo(e){let{components:n,...t}=e;return(0,s.yg)(Nfo,(0,p.A)({},bfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}kfo.isMDXComponent=!0;const zfo={toc:[]},Pfo="wrapper";function Ifo(e){let{components:n,...t}=e;return(0,s.yg)(Pfo,(0,p.A)({},zfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Ifo.isMDXComponent=!0;const Rfo={toc:[]},Wfo="wrapper";function Sfo(e){let{components:n,...t}=e;return(0,s.yg)(Wfo,(0,p.A)({},Rfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Sfo.isMDXComponent=!0;const Bfo={toc:[]},Gfo="wrapper";function Efo(e){let{components:n,...t}=e;return(0,s.yg)(Gfo,(0,p.A)({},Bfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Efo.isMDXComponent=!0;const Ofo={toc:[]},Ufo="wrapper";function Ffo(e){let{components:n,...t}=e;return(0,s.yg)(Ufo,(0,p.A)({},Ofo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Ffo.isMDXComponent=!0;const Vfo={toc:[]},qfo="wrapper";function jfo(e){let{components:n,...t}=e;return(0,s.yg)(qfo,(0,p.A)({},Vfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}jfo.isMDXComponent=!0;const Hfo={toc:[]},Yfo="wrapper";function Qfo(e){let{components:n,...t}=e;return(0,s.yg)(Yfo,(0,p.A)({},Hfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Qfo.isMDXComponent=!0;const $fo={toc:[]},Kfo="wrapper";function Jfo(e){let{components:n,...t}=e;return(0,s.yg)(Kfo,(0,p.A)({},$fo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Jfo.isMDXComponent=!0;const Zfo={toc:[]},eDo="wrapper";function nDo(e){let{components:n,...t}=e;return(0,s.yg)(eDo,(0,p.A)({},Zfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}nDo.isMDXComponent=!0;const tDo={toc:[]},oDo="wrapper";function pDo(e){let{components:n,...t}=e;return(0,s.yg)(oDo,(0,p.A)({},tDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}pDo.isMDXComponent=!0;const rDo={toc:[]},sDo="wrapper";function cDo(e){let{components:n,...t}=e;return(0,s.yg)(sDo,(0,p.A)({},rDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}cDo.isMDXComponent=!0;const aDo={toc:[]},iDo="wrapper";function lDo(e){let{components:n,...t}=e;return(0,s.yg)(iDo,(0,p.A)({},aDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}lDo.isMDXComponent=!0;const uDo={toc:[]},mDo="wrapper";function yDo(e){let{components:n,...t}=e;return(0,s.yg)(mDo,(0,p.A)({},uDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}yDo.isMDXComponent=!0;const dDo={toc:[]},hDo="wrapper";function gDo(e){let{components:n,...t}=e;return(0,s.yg)(hDo,(0,p.A)({},dDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}gDo.isMDXComponent=!0;const fDo={toc:[]},DDo="wrapper";function MDo(e){let{components:n,...t}=e;return(0,s.yg)(DDo,(0,p.A)({},fDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}MDo.isMDXComponent=!0;const XDo={toc:[]},_Do="wrapper";function wDo(e){let{components:n,...t}=e;return(0,s.yg)(_Do,(0,p.A)({},XDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}wDo.isMDXComponent=!0;const TDo={toc:[]},CDo="wrapper";function xDo(e){let{components:n,...t}=e;return(0,s.yg)(CDo,(0,p.A)({},TDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xDo.isMDXComponent=!0;const ADo={toc:[]},vDo="wrapper";function LDo(e){let{components:n,...t}=e;return(0,s.yg)(vDo,(0,p.A)({},ADo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}LDo.isMDXComponent=!0;const bDo={toc:[]},NDo="wrapper";function kDo(e){let{components:n,...t}=e;return(0,s.yg)(NDo,(0,p.A)({},bDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}kDo.isMDXComponent=!0;const zDo={toc:[]},PDo="wrapper";function IDo(e){let{components:n,...t}=e;return(0,s.yg)(PDo,(0,p.A)({},zDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}IDo.isMDXComponent=!0;const RDo={toc:[]},WDo="wrapper";function SDo(e){let{components:n,...t}=e;return(0,s.yg)(WDo,(0,p.A)({},RDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}SDo.isMDXComponent=!0;const BDo={toc:[]},GDo="wrapper";function EDo(e){let{components:n,...t}=e;return(0,s.yg)(GDo,(0,p.A)({},BDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}EDo.isMDXComponent=!0;const ODo={toc:[]},UDo="wrapper";function FDo(e){let{components:n,...t}=e;return(0,s.yg)(UDo,(0,p.A)({},ODo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}FDo.isMDXComponent=!0;const VDo={toc:[]},qDo="wrapper";function jDo(e){let{components:n,...t}=e;return(0,s.yg)(qDo,(0,p.A)({},VDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jDo.isMDXComponent=!0;const HDo={toc:[]},YDo="wrapper";function QDo(e){let{components:n,...t}=e;return(0,s.yg)(YDo,(0,p.A)({},HDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QDo.isMDXComponent=!0;const $Do={toc:[]},KDo="wrapper";function JDo(e){let{components:n,...t}=e;return(0,s.yg)(KDo,(0,p.A)({},$Do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}JDo.isMDXComponent=!0;const ZDo={toc:[]},eMo="wrapper";function nMo(e){let{components:n,...t}=e;return(0,s.yg)(eMo,(0,p.A)({},ZDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}nMo.isMDXComponent=!0;const tMo={toc:[]},oMo="wrapper";function pMo(e){let{components:n,...t}=e;return(0,s.yg)(oMo,(0,p.A)({},tMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}pMo.isMDXComponent=!0;const rMo={toc:[]},sMo="wrapper";function cMo(e){let{components:n,...t}=e;return(0,s.yg)(sMo,(0,p.A)({},rMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}cMo.isMDXComponent=!0;const aMo={toc:[]},iMo="wrapper";function lMo(e){let{components:n,...t}=e;return(0,s.yg)(iMo,(0,p.A)({},aMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lMo.isMDXComponent=!0;const uMo={toc:[]},mMo="wrapper";function yMo(e){let{components:n,...t}=e;return(0,s.yg)(mMo,(0,p.A)({},uMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yMo.isMDXComponent=!0;const dMo={toc:[]},hMo="wrapper";function gMo(e){let{components:n,...t}=e;return(0,s.yg)(hMo,(0,p.A)({},dMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gMo.isMDXComponent=!0;const fMo={toc:[]},DMo="wrapper";function MMo(e){let{components:n,...t}=e;return(0,s.yg)(DMo,(0,p.A)({},fMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}MMo.isMDXComponent=!0;const XMo={toc:[]},_Mo="wrapper";function wMo(e){let{components:n,...t}=e;return(0,s.yg)(_Mo,(0,p.A)({},XMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wMo.isMDXComponent=!0;const TMo={toc:[]},CMo="wrapper";function xMo(e){let{components:n,...t}=e;return(0,s.yg)(CMo,(0,p.A)({},TMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xMo.isMDXComponent=!0;const AMo={toc:[]},vMo="wrapper";function LMo(e){let{components:n,...t}=e;return(0,s.yg)(vMo,(0,p.A)({},AMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LMo.isMDXComponent=!0;const bMo={toc:[]},NMo="wrapper";function kMo(e){let{components:n,...t}=e;return(0,s.yg)(NMo,(0,p.A)({},bMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}kMo.isMDXComponent=!0;const zMo={toc:[]},PMo="wrapper";function IMo(e){let{components:n,...t}=e;return(0,s.yg)(PMo,(0,p.A)({},zMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}IMo.isMDXComponent=!0;const RMo={toc:[]},WMo="wrapper";function SMo(e){let{components:n,...t}=e;return(0,s.yg)(WMo,(0,p.A)({},RMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}SMo.isMDXComponent=!0;const BMo={toc:[]},GMo="wrapper";function EMo(e){let{components:n,...t}=e;return(0,s.yg)(GMo,(0,p.A)({},BMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}EMo.isMDXComponent=!0;const OMo={toc:[]},UMo="wrapper";function FMo(e){let{components:n,...t}=e;return(0,s.yg)(UMo,(0,p.A)({},OMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}FMo.isMDXComponent=!0;const VMo={toc:[]},qMo="wrapper";function jMo(e){let{components:n,...t}=e;return(0,s.yg)(qMo,(0,p.A)({},VMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jMo.isMDXComponent=!0;const HMo={toc:[]},YMo="wrapper";function QMo(e){let{components:n,...t}=e;return(0,s.yg)(YMo,(0,p.A)({},HMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}QMo.isMDXComponent=!0;const $Mo={toc:[]},KMo="wrapper";function JMo(e){let{components:n,...t}=e;return(0,s.yg)(KMo,(0,p.A)({},$Mo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JMo.isMDXComponent=!0;const ZMo={toc:[]},eXo="wrapper";function nXo(e){let{components:n,...t}=e;return(0,s.yg)(eXo,(0,p.A)({},ZMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}nXo.isMDXComponent=!0;const tXo={toc:[]},oXo="wrapper";function pXo(e){let{components:n,...t}=e;return(0,s.yg)(oXo,(0,p.A)({},tXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pXo.isMDXComponent=!0;const rXo={toc:[]},sXo="wrapper";function cXo(e){let{components:n,...t}=e;return(0,s.yg)(sXo,(0,p.A)({},rXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}cXo.isMDXComponent=!0;const aXo={toc:[]},iXo="wrapper";function lXo(e){let{components:n,...t}=e;return(0,s.yg)(iXo,(0,p.A)({},aXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}lXo.isMDXComponent=!0;const uXo={toc:[]},mXo="wrapper";function yXo(e){let{components:n,...t}=e;return(0,s.yg)(mXo,(0,p.A)({},uXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yXo.isMDXComponent=!0;const dXo={toc:[]},hXo="wrapper";function gXo(e){let{components:n,...t}=e;return(0,s.yg)(hXo,(0,p.A)({},dXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}gXo.isMDXComponent=!0;const fXo={toc:[]},DXo="wrapper";function MXo(e){let{components:n,...t}=e;return(0,s.yg)(DXo,(0,p.A)({},fXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}MXo.isMDXComponent=!0;const XXo={toc:[]},_Xo="wrapper";function wXo(e){let{components:n,...t}=e;return(0,s.yg)(_Xo,(0,p.A)({},XXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}wXo.isMDXComponent=!0;const TXo={toc:[]},CXo="wrapper";function xXo(e){let{components:n,...t}=e;return(0,s.yg)(CXo,(0,p.A)({},TXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}xXo.isMDXComponent=!0;const AXo={toc:[]},vXo="wrapper";function LXo(e){let{components:n,...t}=e;return(0,s.yg)(vXo,(0,p.A)({},AXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}LXo.isMDXComponent=!0;const bXo={toc:[]},NXo="wrapper";function kXo(e){let{components:n,...t}=e;return(0,s.yg)(NXo,(0,p.A)({},bXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}kXo.isMDXComponent=!0;const zXo={toc:[]},PXo="wrapper";function IXo(e){let{components:n,...t}=e;return(0,s.yg)(PXo,(0,p.A)({},zXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}IXo.isMDXComponent=!0;const RXo={toc:[]},WXo="wrapper";function SXo(e){let{components:n,...t}=e;return(0,s.yg)(WXo,(0,p.A)({},RXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}SXo.isMDXComponent=!0;const BXo={toc:[]},GXo="wrapper";function EXo(e){let{components:n,...t}=e;return(0,s.yg)(GXo,(0,p.A)({},BXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}EXo.isMDXComponent=!0;const OXo={toc:[]},UXo="wrapper";function FXo(e){let{components:n,...t}=e;return(0,s.yg)(UXo,(0,p.A)({},OXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}FXo.isMDXComponent=!0;const VXo={toc:[]},qXo="wrapper";function jXo(e){let{components:n,...t}=e;return(0,s.yg)(qXo,(0,p.A)({},VXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}jXo.isMDXComponent=!0;const HXo={toc:[]},YXo="wrapper";function QXo(e){let{components:n,...t}=e;return(0,s.yg)(YXo,(0,p.A)({},HXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QXo.isMDXComponent=!0;const $Xo={toc:[]},KXo="wrapper";function JXo(e){let{components:n,...t}=e;return(0,s.yg)(KXo,(0,p.A)({},$Xo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}JXo.isMDXComponent=!0;const ZXo={toc:[]},e_o="wrapper";function n_o(e){let{components:n,...t}=e;return(0,s.yg)(e_o,(0,p.A)({},ZXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}n_o.isMDXComponent=!0;const t_o={toc:[]},o_o="wrapper";function p_o(e){let{components:n,...t}=e;return(0,s.yg)(o_o,(0,p.A)({},t_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}p_o.isMDXComponent=!0;const r_o={toc:[]},s_o="wrapper";function c_o(e){let{components:n,...t}=e;return(0,s.yg)(s_o,(0,p.A)({},r_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}c_o.isMDXComponent=!0;const a_o={toc:[]},i_o="wrapper";function l_o(e){let{components:n,...t}=e;return(0,s.yg)(i_o,(0,p.A)({},a_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}l_o.isMDXComponent=!0;const u_o={toc:[]},m_o="wrapper";function y_o(e){let{components:n,...t}=e;return(0,s.yg)(m_o,(0,p.A)({},u_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}y_o.isMDXComponent=!0;const d_o={toc:[]},h_o="wrapper";function g_o(e){let{components:n,...t}=e;return(0,s.yg)(h_o,(0,p.A)({},d_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}g_o.isMDXComponent=!0;const f_o={toc:[]},D_o="wrapper";function M_o(e){let{components:n,...t}=e;return(0,s.yg)(D_o,(0,p.A)({},f_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}M_o.isMDXComponent=!0;const X_o={toc:[]},__o="wrapper";function w_o(e){let{components:n,...t}=e;return(0,s.yg)(__o,(0,p.A)({},X_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}w_o.isMDXComponent=!0;const T_o={toc:[]},C_o="wrapper";function x_o(e){let{components:n,...t}=e;return(0,s.yg)(C_o,(0,p.A)({},T_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}x_o.isMDXComponent=!0;const A_o={toc:[]},v_o="wrapper";function L_o(e){let{components:n,...t}=e;return(0,s.yg)(v_o,(0,p.A)({},A_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}L_o.isMDXComponent=!0;const b_o={toc:[]},N_o="wrapper";function k_o(e){let{components:n,...t}=e;return(0,s.yg)(N_o,(0,p.A)({},b_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}k_o.isMDXComponent=!0;const z_o={toc:[]},P_o="wrapper";function I_o(e){let{components:n,...t}=e;return(0,s.yg)(P_o,(0,p.A)({},z_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}I_o.isMDXComponent=!0;const R_o={toc:[]},W_o="wrapper";function S_o(e){let{components:n,...t}=e;return(0,s.yg)(W_o,(0,p.A)({},R_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}S_o.isMDXComponent=!0;const B_o={toc:[]},G_o="wrapper";function E_o(e){let{components:n,...t}=e;return(0,s.yg)(G_o,(0,p.A)({},B_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}E_o.isMDXComponent=!0;const O_o={toc:[]},U_o="wrapper";function F_o(e){let{components:n,...t}=e;return(0,s.yg)(U_o,(0,p.A)({},O_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}F_o.isMDXComponent=!0;const V_o={toc:[]},q_o="wrapper";function j_o(e){let{components:n,...t}=e;return(0,s.yg)(q_o,(0,p.A)({},V_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}j_o.isMDXComponent=!0;const H_o={toc:[]},Y_o="wrapper";function Q_o(e){let{components:n,...t}=e;return(0,s.yg)(Y_o,(0,p.A)({},H_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Q_o.isMDXComponent=!0;const $_o={toc:[]},K_o="wrapper";function J_o(e){let{components:n,...t}=e;return(0,s.yg)(K_o,(0,p.A)({},$_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}J_o.isMDXComponent=!0;const Z_o={toc:[]},ewo="wrapper";function nwo(e){let{components:n,...t}=e;return(0,s.yg)(ewo,(0,p.A)({},Z_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nwo.isMDXComponent=!0;const two={toc:[]},owo="wrapper";function pwo(e){let{components:n,...t}=e;return(0,s.yg)(owo,(0,p.A)({},two,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}pwo.isMDXComponent=!0;const rwo={toc:[]},swo="wrapper";function cwo(e){let{components:n,...t}=e;return(0,s.yg)(swo,(0,p.A)({},rwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}cwo.isMDXComponent=!0;const awo={toc:[]},iwo="wrapper";function lwo(e){let{components:n,...t}=e;return(0,s.yg)(iwo,(0,p.A)({},awo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}lwo.isMDXComponent=!0;const uwo={toc:[]},mwo="wrapper";function ywo(e){let{components:n,...t}=e;return(0,s.yg)(mwo,(0,p.A)({},uwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}ywo.isMDXComponent=!0;const dwo={toc:[]},hwo="wrapper";function gwo(e){let{components:n,...t}=e;return(0,s.yg)(hwo,(0,p.A)({},dwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gwo.isMDXComponent=!0;const fwo={toc:[]},Dwo="wrapper";function Mwo(e){let{components:n,...t}=e;return(0,s.yg)(Dwo,(0,p.A)({},fwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Mwo.isMDXComponent=!0;const Xwo={toc:[]},_wo="wrapper";function wwo(e){let{components:n,...t}=e;return(0,s.yg)(_wo,(0,p.A)({},Xwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wwo.isMDXComponent=!0;const Two={toc:[]},Cwo="wrapper";function xwo(e){let{components:n,...t}=e;return(0,s.yg)(Cwo,(0,p.A)({},Two,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}xwo.isMDXComponent=!0;const Awo={toc:[]},vwo="wrapper";function Lwo(e){let{components:n,...t}=e;return(0,s.yg)(vwo,(0,p.A)({},Awo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Lwo.isMDXComponent=!0;const bwo={toc:[]},Nwo="wrapper";function kwo(e){let{components:n,...t}=e;return(0,s.yg)(Nwo,(0,p.A)({},bwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}kwo.isMDXComponent=!0;const zwo={toc:[]},Pwo="wrapper";function Iwo(e){let{components:n,...t}=e;return(0,s.yg)(Pwo,(0,p.A)({},zwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Iwo.isMDXComponent=!0;const Rwo={toc:[]},Wwo="wrapper";function Swo(e){let{components:n,...t}=e;return(0,s.yg)(Wwo,(0,p.A)({},Rwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Swo.isMDXComponent=!0;const Bwo={toc:[]},Gwo="wrapper";function Ewo(e){let{components:n,...t}=e;return(0,s.yg)(Gwo,(0,p.A)({},Bwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Ewo.isMDXComponent=!0;const Owo={toc:[]},Uwo="wrapper";function Fwo(e){let{components:n,...t}=e;return(0,s.yg)(Uwo,(0,p.A)({},Owo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Fwo.isMDXComponent=!0;const Vwo={toc:[]},qwo="wrapper";function jwo(e){let{components:n,...t}=e;return(0,s.yg)(qwo,(0,p.A)({},Vwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}jwo.isMDXComponent=!0;const Hwo={toc:[]},Ywo="wrapper";function Qwo(e){let{components:n,...t}=e;return(0,s.yg)(Ywo,(0,p.A)({},Hwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Qwo.isMDXComponent=!0;const $wo={toc:[]},Kwo="wrapper";function Jwo(e){let{components:n,...t}=e;return(0,s.yg)(Kwo,(0,p.A)({},$wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Jwo.isMDXComponent=!0;const Zwo={toc:[]},eTo="wrapper";function nTo(e){let{components:n,...t}=e;return(0,s.yg)(eTo,(0,p.A)({},Zwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}nTo.isMDXComponent=!0;const tTo={toc:[]},oTo="wrapper";function pTo(e){let{components:n,...t}=e;return(0,s.yg)(oTo,(0,p.A)({},tTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pTo.isMDXComponent=!0;const rTo={toc:[]},sTo="wrapper";function cTo(e){let{components:n,...t}=e;return(0,s.yg)(sTo,(0,p.A)({},rTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}cTo.isMDXComponent=!0;const aTo={toc:[]},iTo="wrapper";function lTo(e){let{components:n,...t}=e;return(0,s.yg)(iTo,(0,p.A)({},aTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}lTo.isMDXComponent=!0;const uTo={toc:[]},mTo="wrapper";function yTo(e){let{components:n,...t}=e;return(0,s.yg)(mTo,(0,p.A)({},uTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}yTo.isMDXComponent=!0;const dTo={toc:[]},hTo="wrapper";function gTo(e){let{components:n,...t}=e;return(0,s.yg)(hTo,(0,p.A)({},dTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}gTo.isMDXComponent=!0;const fTo={toc:[]},DTo="wrapper";function MTo(e){let{components:n,...t}=e;return(0,s.yg)(DTo,(0,p.A)({},fTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}MTo.isMDXComponent=!0;const XTo={toc:[]},_To="wrapper";function wTo(e){let{components:n,...t}=e;return(0,s.yg)(_To,(0,p.A)({},XTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}wTo.isMDXComponent=!0;const TTo={toc:[]},CTo="wrapper";function xTo(e){let{components:n,...t}=e;return(0,s.yg)(CTo,(0,p.A)({},TTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}xTo.isMDXComponent=!0;const ATo={toc:[]},vTo="wrapper";function LTo(e){let{components:n,...t}=e;return(0,s.yg)(vTo,(0,p.A)({},ATo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}LTo.isMDXComponent=!0;const bTo={toc:[]},NTo="wrapper";function kTo(e){let{components:n,...t}=e;return(0,s.yg)(NTo,(0,p.A)({},bTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}kTo.isMDXComponent=!0;const zTo={toc:[]},PTo="wrapper";function ITo(e){let{components:n,...t}=e;return(0,s.yg)(PTo,(0,p.A)({},zTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}ITo.isMDXComponent=!0;const RTo={toc:[]},WTo="wrapper";function STo(e){let{components:n,...t}=e;return(0,s.yg)(WTo,(0,p.A)({},RTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}STo.isMDXComponent=!0;const BTo={toc:[]},GTo="wrapper";function ETo(e){let{components:n,...t}=e;return(0,s.yg)(GTo,(0,p.A)({},BTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}ETo.isMDXComponent=!0;const OTo={toc:[]},UTo="wrapper";function FTo(e){let{components:n,...t}=e;return(0,s.yg)(UTo,(0,p.A)({},OTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}FTo.isMDXComponent=!0;const VTo={toc:[]},qTo="wrapper";function jTo(e){let{components:n,...t}=e;return(0,s.yg)(qTo,(0,p.A)({},VTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}jTo.isMDXComponent=!0;const HTo={toc:[]},YTo="wrapper";function QTo(e){let{components:n,...t}=e;return(0,s.yg)(YTo,(0,p.A)({},HTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}QTo.isMDXComponent=!0;const $To={toc:[]},KTo="wrapper";function JTo(e){let{components:n,...t}=e;return(0,s.yg)(KTo,(0,p.A)({},$To,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}JTo.isMDXComponent=!0;const ZTo={toc:[]},eCo="wrapper";function nCo(e){let{components:n,...t}=e;return(0,s.yg)(eCo,(0,p.A)({},ZTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}nCo.isMDXComponent=!0;const tCo={toc:[]},oCo="wrapper";function pCo(e){let{components:n,...t}=e;return(0,s.yg)(oCo,(0,p.A)({},tCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}pCo.isMDXComponent=!0;const rCo={toc:[]},sCo="wrapper";function cCo(e){let{components:n,...t}=e;return(0,s.yg)(sCo,(0,p.A)({},rCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}cCo.isMDXComponent=!0;const aCo={toc:[]},iCo="wrapper";function lCo(e){let{components:n,...t}=e;return(0,s.yg)(iCo,(0,p.A)({},aCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}lCo.isMDXComponent=!0;const uCo={toc:[]},mCo="wrapper";function yCo(e){let{components:n,...t}=e;return(0,s.yg)(mCo,(0,p.A)({},uCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}yCo.isMDXComponent=!0;const dCo={toc:[]},hCo="wrapper";function gCo(e){let{components:n,...t}=e;return(0,s.yg)(hCo,(0,p.A)({},dCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}gCo.isMDXComponent=!0;const fCo={toc:[]},DCo="wrapper";function MCo(e){let{components:n,...t}=e;return(0,s.yg)(DCo,(0,p.A)({},fCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}MCo.isMDXComponent=!0;const XCo={toc:[]},_Co="wrapper";function wCo(e){let{components:n,...t}=e;return(0,s.yg)(_Co,(0,p.A)({},XCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}wCo.isMDXComponent=!0;const TCo={toc:[]},CCo="wrapper";function xCo(e){let{components:n,...t}=e;return(0,s.yg)(CCo,(0,p.A)({},TCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}xCo.isMDXComponent=!0;const ACo={toc:[]},vCo="wrapper";function LCo(e){let{components:n,...t}=e;return(0,s.yg)(vCo,(0,p.A)({},ACo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}LCo.isMDXComponent=!0;const bCo={toc:[]},NCo="wrapper";function kCo(e){let{components:n,...t}=e;return(0,s.yg)(NCo,(0,p.A)({},bCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}kCo.isMDXComponent=!0;const zCo={toc:[]},PCo="wrapper";function ICo(e){let{components:n,...t}=e;return(0,s.yg)(PCo,(0,p.A)({},zCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}ICo.isMDXComponent=!0;const RCo={toc:[]},WCo="wrapper";function SCo(e){let{components:n,...t}=e;return(0,s.yg)(WCo,(0,p.A)({},RCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}SCo.isMDXComponent=!0;const BCo={toc:[]},GCo="wrapper";function ECo(e){let{components:n,...t}=e;return(0,s.yg)(GCo,(0,p.A)({},BCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}ECo.isMDXComponent=!0;const OCo={toc:[]},UCo="wrapper";function FCo(e){let{components:n,...t}=e;return(0,s.yg)(UCo,(0,p.A)({},OCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}FCo.isMDXComponent=!0;const VCo={toc:[]},qCo="wrapper";function jCo(e){let{components:n,...t}=e;return(0,s.yg)(qCo,(0,p.A)({},VCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jCo.isMDXComponent=!0;const HCo={toc:[]},YCo="wrapper";function QCo(e){let{components:n,...t}=e;return(0,s.yg)(YCo,(0,p.A)({},HCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}QCo.isMDXComponent=!0;const $Co={toc:[]},KCo="wrapper";function JCo(e){let{components:n,...t}=e;return(0,s.yg)(KCo,(0,p.A)({},$Co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}JCo.isMDXComponent=!0;const ZCo={toc:[]},exo="wrapper";function nxo(e){let{components:n,...t}=e;return(0,s.yg)(exo,(0,p.A)({},ZCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nxo.isMDXComponent=!0;const txo={toc:[]},oxo="wrapper";function pxo(e){let{components:n,...t}=e;return(0,s.yg)(oxo,(0,p.A)({},txo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pxo.isMDXComponent=!0;const rxo={toc:[]},sxo="wrapper";function cxo(e){let{components:n,...t}=e;return(0,s.yg)(sxo,(0,p.A)({},rxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}cxo.isMDXComponent=!0;const axo={toc:[]},ixo="wrapper";function lxo(e){let{components:n,...t}=e;return(0,s.yg)(ixo,(0,p.A)({},axo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}lxo.isMDXComponent=!0;const uxo={toc:[]},mxo="wrapper";function yxo(e){let{components:n,...t}=e;return(0,s.yg)(mxo,(0,p.A)({},uxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}yxo.isMDXComponent=!0;const dxo={toc:[]},hxo="wrapper";function gxo(e){let{components:n,...t}=e;return(0,s.yg)(hxo,(0,p.A)({},dxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}gxo.isMDXComponent=!0;const fxo={toc:[]},Dxo="wrapper";function Mxo(e){let{components:n,...t}=e;return(0,s.yg)(Dxo,(0,p.A)({},fxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Mxo.isMDXComponent=!0;const Xxo={toc:[]},_xo="wrapper";function wxo(e){let{components:n,...t}=e;return(0,s.yg)(_xo,(0,p.A)({},Xxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}wxo.isMDXComponent=!0;const Txo={toc:[]},Cxo="wrapper";function xxo(e){let{components:n,...t}=e;return(0,s.yg)(Cxo,(0,p.A)({},Txo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xxo.isMDXComponent=!0;const Axo={toc:[]},vxo="wrapper";function Lxo(e){let{components:n,...t}=e;return(0,s.yg)(vxo,(0,p.A)({},Axo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Lxo.isMDXComponent=!0;const bxo={toc:[]},Nxo="wrapper";function kxo(e){let{components:n,...t}=e;return(0,s.yg)(Nxo,(0,p.A)({},bxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you're not interested in animating SVG, you can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,s.yg)("inlineCode",{parentName:"a"},"Img"))," instead."))}kxo.isMDXComponent=!0;const zxo={toc:[]},Pxo="wrapper";function Ixo(e){let{components:n,...t}=e;return(0,s.yg)(Pxo,(0,p.A)({},zxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A Node for drawing and animating SVG images."))}Ixo.isMDXComponent=!0;const Rxo={toc:[]},Wxo="wrapper";function Sxo(e){let{components:n,...t}=e;return(0,s.yg)(Wxo,(0,p.A)({},Rxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Sxo.isMDXComponent=!0;const Bxo={toc:[]},Gxo="wrapper";function Exo(e){let{components:n,...t}=e;return(0,s.yg)(Gxo,(0,p.A)({},Bxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Exo.isMDXComponent=!0;const Oxo={toc:[]},Uxo="wrapper";function Fxo(e){let{components:n,...t}=e;return(0,s.yg)(Uxo,(0,p.A)({},Oxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Fxo.isMDXComponent=!0;const Vxo={toc:[]},qxo="wrapper";function jxo(e){let{components:n,...t}=e;return(0,s.yg)(qxo,(0,p.A)({},Vxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}jxo.isMDXComponent=!0;const Hxo={toc:[]},Yxo="wrapper";function Qxo(e){let{components:n,...t}=e;return(0,s.yg)(Yxo,(0,p.A)({},Hxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Qxo.isMDXComponent=!0;const $xo={toc:[]},Kxo="wrapper";function Jxo(e){let{components:n,...t}=e;return(0,s.yg)(Kxo,(0,p.A)({},$xo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Jxo.isMDXComponent=!0;const Zxo={toc:[]},eAo="wrapper";function nAo(e){let{components:n,...t}=e;return(0,s.yg)(eAo,(0,p.A)({},Zxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}nAo.isMDXComponent=!0;const tAo={toc:[]},oAo="wrapper";function pAo(e){let{components:n,...t}=e;return(0,s.yg)(oAo,(0,p.A)({},tAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}pAo.isMDXComponent=!0;const rAo={toc:[]},sAo="wrapper";function cAo(e){let{components:n,...t}=e;return(0,s.yg)(sAo,(0,p.A)({},rAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cAo.isMDXComponent=!0;const aAo={toc:[]},iAo="wrapper";function lAo(e){let{components:n,...t}=e;return(0,s.yg)(iAo,(0,p.A)({},aAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}lAo.isMDXComponent=!0;const uAo={toc:[]},mAo="wrapper";function yAo(e){let{components:n,...t}=e;return(0,s.yg)(mAo,(0,p.A)({},uAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}yAo.isMDXComponent=!0;const dAo={toc:[]},hAo="wrapper";function gAo(e){let{components:n,...t}=e;return(0,s.yg)(hAo,(0,p.A)({},dAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}gAo.isMDXComponent=!0;const fAo={toc:[]},DAo="wrapper";function MAo(e){let{components:n,...t}=e;return(0,s.yg)(DAo,(0,p.A)({},fAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}MAo.isMDXComponent=!0;const XAo={toc:[]},_Ao="wrapper";function wAo(e){let{components:n,...t}=e;return(0,s.yg)(_Ao,(0,p.A)({},XAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wAo.isMDXComponent=!0;const TAo={toc:[]},CAo="wrapper";function xAo(e){let{components:n,...t}=e;return(0,s.yg)(CAo,(0,p.A)({},TAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}xAo.isMDXComponent=!0;const AAo={toc:[]},vAo="wrapper";function LAo(e){let{components:n,...t}=e;return(0,s.yg)(vAo,(0,p.A)({},AAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}LAo.isMDXComponent=!0;const bAo={toc:[]},NAo="wrapper";function kAo(e){let{components:n,...t}=e;return(0,s.yg)(NAo,(0,p.A)({},bAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}kAo.isMDXComponent=!0;const zAo={toc:[]},PAo="wrapper";function IAo(e){let{components:n,...t}=e;return(0,s.yg)(PAo,(0,p.A)({},zAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}IAo.isMDXComponent=!0;const RAo={toc:[]},WAo="wrapper";function SAo(e){let{components:n,...t}=e;return(0,s.yg)(WAo,(0,p.A)({},RAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}SAo.isMDXComponent=!0;const BAo={toc:[]},GAo="wrapper";function EAo(e){let{components:n,...t}=e;return(0,s.yg)(GAo,(0,p.A)({},BAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}EAo.isMDXComponent=!0;const OAo={toc:[]},UAo="wrapper";function FAo(e){let{components:n,...t}=e;return(0,s.yg)(UAo,(0,p.A)({},OAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}FAo.isMDXComponent=!0;const VAo={toc:[]},qAo="wrapper";function jAo(e){let{components:n,...t}=e;return(0,s.yg)(qAo,(0,p.A)({},VAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}jAo.isMDXComponent=!0;const HAo={toc:[]},YAo="wrapper";function QAo(e){let{components:n,...t}=e;return(0,s.yg)(YAo,(0,p.A)({},HAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}QAo.isMDXComponent=!0;const $Ao={toc:[]},KAo="wrapper";function JAo(e){let{components:n,...t}=e;return(0,s.yg)(KAo,(0,p.A)({},$Ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}JAo.isMDXComponent=!0;const ZAo={toc:[]},evo="wrapper";function nvo(e){let{components:n,...t}=e;return(0,s.yg)(evo,(0,p.A)({},ZAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}nvo.isMDXComponent=!0;const tvo={toc:[]},ovo="wrapper";function pvo(e){let{components:n,...t}=e;return(0,s.yg)(ovo,(0,p.A)({},tvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}pvo.isMDXComponent=!0;const rvo={toc:[]},svo="wrapper";function cvo(e){let{components:n,...t}=e;return(0,s.yg)(svo,(0,p.A)({},rvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cvo.isMDXComponent=!0;const avo={toc:[]},ivo="wrapper";function lvo(e){let{components:n,...t}=e;return(0,s.yg)(ivo,(0,p.A)({},avo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lvo.isMDXComponent=!0;const uvo={toc:[]},mvo="wrapper";function yvo(e){let{components:n,...t}=e;return(0,s.yg)(mvo,(0,p.A)({},uvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}yvo.isMDXComponent=!0;const dvo={toc:[]},hvo="wrapper";function gvo(e){let{components:n,...t}=e;return(0,s.yg)(hvo,(0,p.A)({},dvo,t,{components:n,mdxType:"MDXLayout"}))}gvo.isMDXComponent=!0;const fvo={toc:[]},Dvo="wrapper";function Mvo(e){let{components:n,...t}=e;return(0,s.yg)(Dvo,(0,p.A)({},fvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Mvo.isMDXComponent=!0;const Xvo={toc:[]},_vo="wrapper";function wvo(e){let{components:n,...t}=e;return(0,s.yg)(_vo,(0,p.A)({},Xvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wvo.isMDXComponent=!0;const Tvo={toc:[]},Cvo="wrapper";function xvo(e){let{components:n,...t}=e;return(0,s.yg)(Cvo,(0,p.A)({},Tvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}xvo.isMDXComponent=!0;const Avo={toc:[]},vvo="wrapper";function Lvo(e){let{components:n,...t}=e;return(0,s.yg)(vvo,(0,p.A)({},Avo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Lvo.isMDXComponent=!0;const bvo={toc:[]},Nvo="wrapper";function kvo(e){let{components:n,...t}=e;return(0,s.yg)(Nvo,(0,p.A)({},bvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}kvo.isMDXComponent=!0;const zvo={toc:[]},Pvo="wrapper";function Ivo(e){let{components:n,...t}=e;return(0,s.yg)(Pvo,(0,p.A)({},zvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Ivo.isMDXComponent=!0;const Rvo={toc:[]},Wvo="wrapper";function Svo(e){let{components:n,...t}=e;return(0,s.yg)(Wvo,(0,p.A)({},Rvo,t,{components:n,mdxType:"MDXLayout"}))}Svo.isMDXComponent=!0;const Bvo={toc:[]},Gvo="wrapper";function Evo(e){let{components:n,...t}=e;return(0,s.yg)(Gvo,(0,p.A)({},Bvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"SVG string to be rendered"))}Evo.isMDXComponent=!0;const Ovo={toc:[]},Uvo="wrapper";function Fvo(e){let{components:n,...t}=e;return(0,s.yg)(Uvo,(0,p.A)({},Ovo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Fvo.isMDXComponent=!0;const Vvo={toc:[]},qvo="wrapper";function jvo(e){let{components:n,...t}=e;return(0,s.yg)(qvo,(0,p.A)({},Vvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}jvo.isMDXComponent=!0;const Hvo={toc:[]},Yvo="wrapper";function Qvo(e){let{components:n,...t}=e;return(0,s.yg)(Yvo,(0,p.A)({},Hvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Qvo.isMDXComponent=!0;const $vo={toc:[]},Kvo="wrapper";function Jvo(e){let{components:n,...t}=e;return(0,s.yg)(Kvo,(0,p.A)({},$vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Jvo.isMDXComponent=!0;const Zvo={toc:[]},eLo="wrapper";function nLo(e){let{components:n,...t}=e;return(0,s.yg)(eLo,(0,p.A)({},Zvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}nLo.isMDXComponent=!0;const tLo={toc:[]},oLo="wrapper";function pLo(e){let{components:n,...t}=e;return(0,s.yg)(oLo,(0,p.A)({},tLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}pLo.isMDXComponent=!0;const rLo={toc:[]},sLo="wrapper";function cLo(e){let{components:n,...t}=e;return(0,s.yg)(sLo,(0,p.A)({},rLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Child to wrap all SVG node"))}cLo.isMDXComponent=!0;const aLo={toc:[]},iLo="wrapper";function lLo(e){let{components:n,...t}=e;return(0,s.yg)(iLo,(0,p.A)({},aLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}lLo.isMDXComponent=!0;const uLo={toc:[]},mLo="wrapper";function yLo(e){let{components:n,...t}=e;return(0,s.yg)(mLo,(0,p.A)({},uLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yLo.isMDXComponent=!0;const dLo={toc:[]},hLo="wrapper";function gLo(e){let{components:n,...t}=e;return(0,s.yg)(hLo,(0,p.A)({},dLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}gLo.isMDXComponent=!0;const fLo={toc:[]},DLo="wrapper";function MLo(e){let{components:n,...t}=e;return(0,s.yg)(DLo,(0,p.A)({},fLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}MLo.isMDXComponent=!0;const XLo={toc:[]},_Lo="wrapper";function wLo(e){let{components:n,...t}=e;return(0,s.yg)(_Lo,(0,p.A)({},XLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wLo.isMDXComponent=!0;const TLo={toc:[]},CLo="wrapper";function xLo(e){let{components:n,...t}=e;return(0,s.yg)(CLo,(0,p.A)({},TLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}xLo.isMDXComponent=!0;const ALo={toc:[]},vLo="wrapper";function LLo(e){let{components:n,...t}=e;return(0,s.yg)(vLo,(0,p.A)({},ALo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}LLo.isMDXComponent=!0;const bLo={toc:[]},NLo="wrapper";function kLo(e){let{components:n,...t}=e;return(0,s.yg)(NLo,(0,p.A)({},bLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}kLo.isMDXComponent=!0;const zLo={toc:[]},PLo="wrapper";function ILo(e){let{components:n,...t}=e;return(0,s.yg)(PLo,(0,p.A)({},zLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}ILo.isMDXComponent=!0;const RLo={toc:[]},WLo="wrapper";function SLo(e){let{components:n,...t}=e;return(0,s.yg)(WLo,(0,p.A)({},RLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}SLo.isMDXComponent=!0;const BLo={toc:[]},GLo="wrapper";function ELo(e){let{components:n,...t}=e;return(0,s.yg)(GLo,(0,p.A)({},BLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}ELo.isMDXComponent=!0;const OLo={toc:[]},ULo="wrapper";function FLo(e){let{components:n,...t}=e;return(0,s.yg)(ULo,(0,p.A)({},OLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," to convert."))}FLo.isMDXComponent=!0;const VLo={toc:[]},qLo="wrapper";function jLo(e){let{components:n,...t}=e;return(0,s.yg)(qLo,(0,p.A)({},VLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGShapeData")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGShape"),"."))}jLo.isMDXComponent=!0;const HLo={toc:[]},YLo="wrapper";function QLo(e){let{components:n,...t}=e;return(0,s.yg)(YLo,(0,p.A)({},HLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGShapeData")," to convert."))}QLo.isMDXComponent=!0;const $Lo={toc:[]},KLo="wrapper";function JLo(e){let{components:n,...t}=e;return(0,s.yg)(KLo,(0,p.A)({},$Lo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}JLo.isMDXComponent=!0;const ZLo={toc:[]},ebo="wrapper";function nbo(e){let{components:n,...t}=e;return(0,s.yg)(ebo,(0,p.A)({},ZLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nbo.isMDXComponent=!0;const tbo={toc:[]},obo="wrapper";function pbo(e){let{components:n,...t}=e;return(0,s.yg)(obo,(0,p.A)({},tbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}pbo.isMDXComponent=!0;const rbo={toc:[]},sbo="wrapper";function cbo(e){let{components:n,...t}=e;return(0,s.yg)(sbo,(0,p.A)({},rbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}cbo.isMDXComponent=!0;const abo={toc:[]},ibo="wrapper";function lbo(e){let{components:n,...t}=e;return(0,s.yg)(ibo,(0,p.A)({},abo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}lbo.isMDXComponent=!0;const ubo={toc:[]},mbo="wrapper";function ybo(e){let{components:n,...t}=e;return(0,s.yg)(mbo,(0,p.A)({},ubo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}ybo.isMDXComponent=!0;const dbo={toc:[]},hbo="wrapper";function gbo(e){let{components:n,...t}=e;return(0,s.yg)(hbo,(0,p.A)({},dbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}gbo.isMDXComponent=!0;const fbo={toc:[]},Dbo="wrapper";function Mbo(e){let{components:n,...t}=e;return(0,s.yg)(Dbo,(0,p.A)({},fbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Mbo.isMDXComponent=!0;const Xbo={toc:[]},_bo="wrapper";function wbo(e){let{components:n,...t}=e;return(0,s.yg)(_bo,(0,p.A)({},Xbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}wbo.isMDXComponent=!0;const Tbo={toc:[]},Cbo="wrapper";function xbo(e){let{components:n,...t}=e;return(0,s.yg)(Cbo,(0,p.A)({},Tbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}xbo.isMDXComponent=!0;const Abo={toc:[]},vbo="wrapper";function Lbo(e){let{components:n,...t}=e;return(0,s.yg)(vbo,(0,p.A)({},Abo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Lbo.isMDXComponent=!0;const bbo={toc:[]},Nbo="wrapper";function kbo(e){let{components:n,...t}=e;return(0,s.yg)(Nbo,(0,p.A)({},bbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}kbo.isMDXComponent=!0;const zbo={toc:[]},Pbo="wrapper";function Ibo(e){let{components:n,...t}=e;return(0,s.yg)(Pbo,(0,p.A)({},zbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Ibo.isMDXComponent=!0;const Rbo={toc:[]},Wbo="wrapper";function Sbo(e){let{components:n,...t}=e;return(0,s.yg)(Wbo,(0,p.A)({},Rbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Sbo.isMDXComponent=!0;const Bbo={toc:[]},Gbo="wrapper";function Ebo(e){let{components:n,...t}=e;return(0,s.yg)(Gbo,(0,p.A)({},Bbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ebo.isMDXComponent=!0;const Obo={toc:[]},Ubo="wrapper";function Fbo(e){let{components:n,...t}=e;return(0,s.yg)(Ubo,(0,p.A)({},Obo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Fbo.isMDXComponent=!0;const Vbo={toc:[]},qbo="wrapper";function jbo(e){let{components:n,...t}=e;return(0,s.yg)(qbo,(0,p.A)({},Vbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jbo.isMDXComponent=!0;const Hbo={toc:[]},Ybo="wrapper";function Qbo(e){let{components:n,...t}=e;return(0,s.yg)(Ybo,(0,p.A)({},Hbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Qbo.isMDXComponent=!0;const $bo={toc:[]},Kbo="wrapper";function Jbo(e){let{components:n,...t}=e;return(0,s.yg)(Kbo,(0,p.A)({},$bo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Jbo.isMDXComponent=!0;const Zbo={toc:[]},eNo="wrapper";function nNo(e){let{components:n,...t}=e;return(0,s.yg)(eNo,(0,p.A)({},Zbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}nNo.isMDXComponent=!0;const tNo={toc:[]},oNo="wrapper";function pNo(e){let{components:n,...t}=e;return(0,s.yg)(oNo,(0,p.A)({},tNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}pNo.isMDXComponent=!0;const rNo={toc:[]},sNo="wrapper";function cNo(e){let{components:n,...t}=e;return(0,s.yg)(sNo,(0,p.A)({},rNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}cNo.isMDXComponent=!0;const aNo={toc:[]},iNo="wrapper";function lNo(e){let{components:n,...t}=e;return(0,s.yg)(iNo,(0,p.A)({},aNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lNo.isMDXComponent=!0;const uNo={toc:[]},mNo="wrapper";function yNo(e){let{components:n,...t}=e;return(0,s.yg)(mNo,(0,p.A)({},uNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yNo.isMDXComponent=!0;const dNo={toc:[]},hNo="wrapper";function gNo(e){let{components:n,...t}=e;return(0,s.yg)(hNo,(0,p.A)({},dNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gNo.isMDXComponent=!0;const fNo={toc:[]},DNo="wrapper";function MNo(e){let{components:n,...t}=e;return(0,s.yg)(DNo,(0,p.A)({},fNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}MNo.isMDXComponent=!0;const XNo={toc:[]},_No="wrapper";function wNo(e){let{components:n,...t}=e;return(0,s.yg)(_No,(0,p.A)({},XNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wNo.isMDXComponent=!0;const TNo={toc:[]},CNo="wrapper";function xNo(e){let{components:n,...t}=e;return(0,s.yg)(CNo,(0,p.A)({},TNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xNo.isMDXComponent=!0;const ANo={toc:[]},vNo="wrapper";function LNo(e){let{components:n,...t}=e;return(0,s.yg)(vNo,(0,p.A)({},ANo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LNo.isMDXComponent=!0;const bNo={toc:[]},NNo="wrapper";function kNo(e){let{components:n,...t}=e;return(0,s.yg)(NNo,(0,p.A)({},bNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}kNo.isMDXComponent=!0;const zNo={toc:[]},PNo="wrapper";function INo(e){let{components:n,...t}=e;return(0,s.yg)(PNo,(0,p.A)({},zNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}INo.isMDXComponent=!0;const RNo={toc:[]},WNo="wrapper";function SNo(e){let{components:n,...t}=e;return(0,s.yg)(WNo,(0,p.A)({},RNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}SNo.isMDXComponent=!0;const BNo={toc:[]},GNo="wrapper";function ENo(e){let{components:n,...t}=e;return(0,s.yg)(GNo,(0,p.A)({},BNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ENo.isMDXComponent=!0;const ONo={toc:[]},UNo="wrapper";function FNo(e){let{components:n,...t}=e;return(0,s.yg)(UNo,(0,p.A)({},ONo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}FNo.isMDXComponent=!0;const VNo={toc:[]},qNo="wrapper";function jNo(e){let{components:n,...t}=e;return(0,s.yg)(qNo,(0,p.A)({},VNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jNo.isMDXComponent=!0;const HNo={toc:[]},YNo="wrapper";function QNo(e){let{components:n,...t}=e;return(0,s.yg)(YNo,(0,p.A)({},HNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}QNo.isMDXComponent=!0;const $No={toc:[]},KNo="wrapper";function JNo(e){let{components:n,...t}=e;return(0,s.yg)(KNo,(0,p.A)({},$No,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JNo.isMDXComponent=!0;const ZNo={toc:[]},eko="wrapper";function nko(e){let{components:n,...t}=e;return(0,s.yg)(eko,(0,p.A)({},ZNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}nko.isMDXComponent=!0;const tko={toc:[]},oko="wrapper";function pko(e){let{components:n,...t}=e;return(0,s.yg)(oko,(0,p.A)({},tko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pko.isMDXComponent=!0;const rko={toc:[]},sko="wrapper";function cko(e){let{components:n,...t}=e;return(0,s.yg)(sko,(0,p.A)({},rko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a tweening list to tween between two SVG nodes."))}cko.isMDXComponent=!0;const ako={toc:[]},iko="wrapper";function lko(e){let{components:n,...t}=e;return(0,s.yg)(iko,(0,p.A)({},ako,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial node,"))}lko.isMDXComponent=!0;const uko={toc:[]},mko="wrapper";function yko(e){let{components:n,...t}=e;return(0,s.yg)(mko,(0,p.A)({},uko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The final node."))}yko.isMDXComponent=!0;const dko={toc:[]},hko="wrapper";function gko(e){let{components:n,...t}=e;return(0,s.yg)(hko,(0,p.A)({},dko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the tween."))}gko.isMDXComponent=!0;const fko={toc:[]},Dko="wrapper";function Mko(e){let{components:n,...t}=e;return(0,s.yg)(Dko,(0,p.A)({},fko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function."))}Mko.isMDXComponent=!0;const Xko={toc:[]},_ko="wrapper";function wko(e){let{components:n,...t}=e;return(0,s.yg)(_ko,(0,p.A)({},Xko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}wko.isMDXComponent=!0;const Tko={toc:[]},Cko="wrapper";function xko(e){let{components:n,...t}=e;return(0,s.yg)(Cko,(0,p.A)({},Tko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}xko.isMDXComponent=!0;const Ako={toc:[]},vko="wrapper";function Lko(e){let{components:n,...t}=e;return(0,s.yg)(vko,(0,p.A)({},Ako,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all SVG nodes with the given id."))}Lko.isMDXComponent=!0;const bko={toc:[]},Nko="wrapper";function kko(e){let{components:n,...t}=e;return(0,s.yg)(Nko,(0,p.A)({},bko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An id to query."))}kko.isMDXComponent=!0;const zko={toc:[]},Pko="wrapper";function Iko(e){let{components:n,...t}=e;return(0,s.yg)(Pko,(0,p.A)({},zko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Iko.isMDXComponent=!0;const Rko={toc:[]},Wko="wrapper";function Sko(e){let{components:n,...t}=e;return(0,s.yg)(Wko,(0,p.A)({},Rko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Sko.isMDXComponent=!0;const Bko={toc:[]},Gko="wrapper";function Eko(e){let{components:n,...t}=e;return(0,s.yg)(Gko,(0,p.A)({},Bko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Eko.isMDXComponent=!0;const Oko={toc:[]},Uko="wrapper";function Fko(e){let{components:n,...t}=e;return(0,s.yg)(Uko,(0,p.A)({},Oko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Fko.isMDXComponent=!0;const Vko={toc:[]},qko="wrapper";function jko(e){let{components:n,...t}=e;return(0,s.yg)(qko,(0,p.A)({},Vko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jko.isMDXComponent=!0;const Hko={toc:[]},Yko="wrapper";function Qko(e){let{components:n,...t}=e;return(0,s.yg)(Yko,(0,p.A)({},Hko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Qko.isMDXComponent=!0;const $ko={toc:[]},Kko="wrapper";function Jko(e){let{components:n,...t}=e;return(0,s.yg)(Kko,(0,p.A)({},$ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Jko.isMDXComponent=!0;const Zko={toc:[]},ezo="wrapper";function nzo(e){let{components:n,...t}=e;return(0,s.yg)(ezo,(0,p.A)({},Zko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}nzo.isMDXComponent=!0;const tzo={toc:[]},ozo="wrapper";function pzo(e){let{components:n,...t}=e;return(0,s.yg)(ozo,(0,p.A)({},tzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}pzo.isMDXComponent=!0;const rzo={toc:[]},szo="wrapper";function czo(e){let{components:n,...t}=e;return(0,s.yg)(szo,(0,p.A)({},rzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}czo.isMDXComponent=!0;const azo={toc:[]},izo="wrapper";function lzo(e){let{components:n,...t}=e;return(0,s.yg)(izo,(0,p.A)({},azo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lzo.isMDXComponent=!0;const uzo={toc:[]},mzo="wrapper";function yzo(e){let{components:n,...t}=e;return(0,s.yg)(mzo,(0,p.A)({},uzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}yzo.isMDXComponent=!0;const dzo={toc:[]},hzo="wrapper";function gzo(e){let{components:n,...t}=e;return(0,s.yg)(hzo,(0,p.A)({},dzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gzo.isMDXComponent=!0;const fzo={toc:[]},Dzo="wrapper";function Mzo(e){let{components:n,...t}=e;return(0,s.yg)(Dzo,(0,p.A)({},fzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Mzo.isMDXComponent=!0;const Xzo={toc:[]},_zo="wrapper";function wzo(e){let{components:n,...t}=e;return(0,s.yg)(_zo,(0,p.A)({},Xzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wzo.isMDXComponent=!0;const Tzo={toc:[]},Czo="wrapper";function xzo(e){let{components:n,...t}=e;return(0,s.yg)(Czo,(0,p.A)({},Tzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}xzo.isMDXComponent=!0;const Azo={toc:[]},vzo="wrapper";function Lzo(e){let{components:n,...t}=e;return(0,s.yg)(vzo,(0,p.A)({},Azo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Lzo.isMDXComponent=!0;const bzo={toc:[]},Nzo="wrapper";function kzo(e){let{components:n,...t}=e;return(0,s.yg)(Nzo,(0,p.A)({},bzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kzo.isMDXComponent=!0;const zzo={toc:[]},Pzo="wrapper";function Izo(e){let{components:n,...t}=e;return(0,s.yg)(Pzo,(0,p.A)({},zzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Izo.isMDXComponent=!0;const Rzo={toc:[]},Wzo="wrapper";function Szo(e){let{components:n,...t}=e;return(0,s.yg)(Wzo,(0,p.A)({},Rzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Szo.isMDXComponent=!0;const Bzo={toc:[]},Gzo="wrapper";function Ezo(e){let{components:n,...t}=e;return(0,s.yg)(Gzo,(0,p.A)({},Bzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Ezo.isMDXComponent=!0;const Ozo={toc:[]},Uzo="wrapper";function Fzo(e){let{components:n,...t}=e;return(0,s.yg)(Uzo,(0,p.A)({},Ozo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Fzo.isMDXComponent=!0;const Vzo={toc:[]},qzo="wrapper";function jzo(e){let{components:n,...t}=e;return(0,s.yg)(qzo,(0,p.A)({},Vzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}jzo.isMDXComponent=!0;const Hzo={toc:[]},Yzo="wrapper";function Qzo(e){let{components:n,...t}=e;return(0,s.yg)(Yzo,(0,p.A)({},Hzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Qzo.isMDXComponent=!0;const $zo={toc:[]},Kzo="wrapper";function Jzo(e){let{components:n,...t}=e;return(0,s.yg)(Kzo,(0,p.A)({},$zo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Jzo.isMDXComponent=!0;const Zzo={toc:[]},ePo="wrapper";function nPo(e){let{components:n,...t}=e;return(0,s.yg)(ePo,(0,p.A)({},Zzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}nPo.isMDXComponent=!0;const tPo={toc:[]},oPo="wrapper";function pPo(e){let{components:n,...t}=e;return(0,s.yg)(oPo,(0,p.A)({},tPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}pPo.isMDXComponent=!0;const rPo={toc:[]},sPo="wrapper";function cPo(e){let{components:n,...t}=e;return(0,s.yg)(sPo,(0,p.A)({},rPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cPo.isMDXComponent=!0;const aPo={toc:[]},iPo="wrapper";function lPo(e){let{components:n,...t}=e;return(0,s.yg)(iPo,(0,p.A)({},aPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lPo.isMDXComponent=!0;const uPo={toc:[]},mPo="wrapper";function yPo(e){let{components:n,...t}=e;return(0,s.yg)(mPo,(0,p.A)({},uPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}yPo.isMDXComponent=!0;const dPo={toc:[]},hPo="wrapper";function gPo(e){let{components:n,...t}=e;return(0,s.yg)(hPo,(0,p.A)({},dPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gPo.isMDXComponent=!0;const fPo={toc:[]},DPo="wrapper";function MPo(e){let{components:n,...t}=e;return(0,s.yg)(DPo,(0,p.A)({},fPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}MPo.isMDXComponent=!0;const XPo={toc:[]},_Po="wrapper";function wPo(e){let{components:n,...t}=e;return(0,s.yg)(_Po,(0,p.A)({},XPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wPo.isMDXComponent=!0;const TPo={toc:[]},CPo="wrapper";function xPo(e){let{components:n,...t}=e;return(0,s.yg)(CPo,(0,p.A)({},TPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}xPo.isMDXComponent=!0;const APo={toc:[]},vPo="wrapper";function LPo(e){let{components:n,...t}=e;return(0,s.yg)(vPo,(0,p.A)({},APo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}LPo.isMDXComponent=!0;const bPo={toc:[]},NPo="wrapper";function kPo(e){let{components:n,...t}=e;return(0,s.yg)(NPo,(0,p.A)({},bPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}kPo.isMDXComponent=!0;const zPo={toc:[]},PPo="wrapper";function IPo(e){let{components:n,...t}=e;return(0,s.yg)(PPo,(0,p.A)({},zPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}IPo.isMDXComponent=!0;const RPo={toc:[]},WPo="wrapper";function SPo(e){let{components:n,...t}=e;return(0,s.yg)(WPo,(0,p.A)({},RPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}SPo.isMDXComponent=!0;const BPo={toc:[]},GPo="wrapper";function EPo(e){let{components:n,...t}=e;return(0,s.yg)(GPo,(0,p.A)({},BPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}EPo.isMDXComponent=!0;const OPo={toc:[]},UPo="wrapper";function FPo(e){let{components:n,...t}=e;return(0,s.yg)(UPo,(0,p.A)({},OPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}FPo.isMDXComponent=!0;const VPo={toc:[]},qPo="wrapper";function jPo(e){let{components:n,...t}=e;return(0,s.yg)(qPo,(0,p.A)({},VPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}jPo.isMDXComponent=!0;const HPo={toc:[]},YPo="wrapper";function QPo(e){let{components:n,...t}=e;return(0,s.yg)(YPo,(0,p.A)({},HPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}QPo.isMDXComponent=!0;const $Po={toc:[]},KPo="wrapper";function JPo(e){let{components:n,...t}=e;return(0,s.yg)(KPo,(0,p.A)({},$Po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}JPo.isMDXComponent=!0;const ZPo={toc:[]},eIo="wrapper";function nIo(e){let{components:n,...t}=e;return(0,s.yg)(eIo,(0,p.A)({},ZPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}nIo.isMDXComponent=!0;const tIo={toc:[]},oIo="wrapper";function pIo(e){let{components:n,...t}=e;return(0,s.yg)(oIo,(0,p.A)({},tIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert an SVG string to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}pIo.isMDXComponent=!0;const rIo={toc:[]},sIo="wrapper";function cIo(e){let{components:n,...t}=e;return(0,s.yg)(sIo,(0,p.A)({},rIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An SVG string to be parsed."))}cIo.isMDXComponent=!0;const aIo={toc:[]},iIo="wrapper";function lIo(e){let{components:n,...t}=e;return(0,s.yg)(iIo,(0,p.A)({},aIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}lIo.isMDXComponent=!0;const uIo={toc:[]},mIo="wrapper";function yIo(e){let{components:n,...t}=e;return(0,s.yg)(mIo,(0,p.A)({},uIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}yIo.isMDXComponent=!0;const dIo={toc:[]},hIo="wrapper";function gIo(e){let{components:n,...t}=e;return(0,s.yg)(hIo,(0,p.A)({},dIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}gIo.isMDXComponent=!0;const fIo={toc:[]},DIo="wrapper";function MIo(e){let{components:n,...t}=e;return(0,s.yg)(DIo,(0,p.A)({},fIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}MIo.isMDXComponent=!0;const XIo={toc:[]},_Io="wrapper";function wIo(e){let{components:n,...t}=e;return(0,s.yg)(_Io,(0,p.A)({},XIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}wIo.isMDXComponent=!0;const TIo={toc:[]},CIo="wrapper";function xIo(e){let{components:n,...t}=e;return(0,s.yg)(CIo,(0,p.A)({},TIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}xIo.isMDXComponent=!0;const AIo={toc:[]},vIo="wrapper";function LIo(e){let{components:n,...t}=e;return(0,s.yg)(vIo,(0,p.A)({},AIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}LIo.isMDXComponent=!0;const bIo={toc:[]},NIo="wrapper";function kIo(e){let{components:n,...t}=e;return(0,s.yg)(NIo,(0,p.A)({},bIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}kIo.isMDXComponent=!0;const zIo={toc:[]},PIo="wrapper";function IIo(e){let{components:n,...t}=e;return(0,s.yg)(PIo,(0,p.A)({},zIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}IIo.isMDXComponent=!0;const RIo={toc:[]},WIo="wrapper";function SIo(e){let{components:n,...t}=e;return(0,s.yg)(WIo,(0,p.A)({},RIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}SIo.isMDXComponent=!0;const BIo={toc:[]},GIo="wrapper";function EIo(e){let{components:n,...t}=e;return(0,s.yg)(GIo,(0,p.A)({},BIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}EIo.isMDXComponent=!0;const OIo={toc:[]},UIo="wrapper";function FIo(e){let{components:n,...t}=e;return(0,s.yg)(UIo,(0,p.A)({},OIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}FIo.isMDXComponent=!0;const VIo={toc:[]},qIo="wrapper";function jIo(e){let{components:n,...t}=e;return(0,s.yg)(qIo,(0,p.A)({},VIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}jIo.isMDXComponent=!0;const HIo={toc:[]},YIo="wrapper";function QIo(e){let{components:n,...t}=e;return(0,s.yg)(YIo,(0,p.A)({},HIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}QIo.isMDXComponent=!0;const $Io={toc:[]},KIo="wrapper";function JIo(e){let{components:n,...t}=e;return(0,s.yg)(KIo,(0,p.A)({},$Io,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}JIo.isMDXComponent=!0;const ZIo={toc:[]},eRo="wrapper";function nRo(e){let{components:n,...t}=e;return(0,s.yg)(eRo,(0,p.A)({},ZIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}nRo.isMDXComponent=!0;const tRo={toc:[]},oRo="wrapper";function pRo(e){let{components:n,...t}=e;return(0,s.yg)(oRo,(0,p.A)({},tRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pRo.isMDXComponent=!0;const rRo={toc:[]},sRo="wrapper";function cRo(e){let{components:n,...t}=e;return(0,s.yg)(sRo,(0,p.A)({},rRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}cRo.isMDXComponent=!0;const aRo={toc:[]},iRo="wrapper";function lRo(e){let{components:n,...t}=e;return(0,s.yg)(iRo,(0,p.A)({},aRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}lRo.isMDXComponent=!0;const uRo={toc:[]},mRo="wrapper";function yRo(e){let{components:n,...t}=e;return(0,s.yg)(mRo,(0,p.A)({},uRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}yRo.isMDXComponent=!0;const dRo={toc:[]},hRo="wrapper";function gRo(e){let{components:n,...t}=e;return(0,s.yg)(hRo,(0,p.A)({},dRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gRo.isMDXComponent=!0;const fRo={toc:[]},DRo="wrapper";function MRo(e){let{components:n,...t}=e;return(0,s.yg)(DRo,(0,p.A)({},fRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}MRo.isMDXComponent=!0;const XRo={toc:[]},_Ro="wrapper";function wRo(e){let{components:n,...t}=e;return(0,s.yg)(_Ro,(0,p.A)({},XRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}wRo.isMDXComponent=!0;const TRo={toc:[]},CRo="wrapper";function xRo(e){let{components:n,...t}=e;return(0,s.yg)(CRo,(0,p.A)({},TRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xRo.isMDXComponent=!0;const ARo={toc:[]},vRo="wrapper";function LRo(e){let{components:n,...t}=e;return(0,s.yg)(vRo,(0,p.A)({},ARo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}LRo.isMDXComponent=!0;const bRo={toc:[]},NRo="wrapper";function kRo(e){let{components:n,...t}=e;return(0,s.yg)(NRo,(0,p.A)({},bRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kRo.isMDXComponent=!0;const zRo={toc:[]},PRo="wrapper";function IRo(e){let{components:n,...t}=e;return(0,s.yg)(PRo,(0,p.A)({},zRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}IRo.isMDXComponent=!0;const RRo={toc:[]},WRo="wrapper";function SRo(e){let{components:n,...t}=e;return(0,s.yg)(WRo,(0,p.A)({},RRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}SRo.isMDXComponent=!0;const BRo={toc:[]},GRo="wrapper";function ERo(e){let{components:n,...t}=e;return(0,s.yg)(GRo,(0,p.A)({},BRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}ERo.isMDXComponent=!0;const ORo={toc:[]},URo="wrapper";function FRo(e){let{components:n,...t}=e;return(0,s.yg)(URo,(0,p.A)({},ORo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}FRo.isMDXComponent=!0;const VRo={toc:[]},qRo="wrapper";function jRo(e){let{components:n,...t}=e;return(0,s.yg)(qRo,(0,p.A)({},VRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}jRo.isMDXComponent=!0;const HRo={toc:[]},YRo="wrapper";function QRo(e){let{components:n,...t}=e;return(0,s.yg)(YRo,(0,p.A)({},HRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}QRo.isMDXComponent=!0;const $Ro={toc:[]},KRo="wrapper";function JRo(e){let{components:n,...t}=e;return(0,s.yg)(KRo,(0,p.A)({},$Ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JRo.isMDXComponent=!0;const ZRo={toc:[]},eWo="wrapper";function nWo(e){let{components:n,...t}=e;return(0,s.yg)(eWo,(0,p.A)({},ZRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}nWo.isMDXComponent=!0;const tWo={toc:[]},oWo="wrapper";function pWo(e){let{components:n,...t}=e;return(0,s.yg)(oWo,(0,p.A)({},tWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}pWo.isMDXComponent=!0;const rWo={toc:[]},sWo="wrapper";function cWo(e){let{components:n,...t}=e;return(0,s.yg)(sWo,(0,p.A)({},rWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cWo.isMDXComponent=!0;const aWo={toc:[]},iWo="wrapper";function lWo(e){let{components:n,...t}=e;return(0,s.yg)(iWo,(0,p.A)({},aWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lWo.isMDXComponent=!0;const uWo={toc:[]},mWo="wrapper";function yWo(e){let{components:n,...t}=e;return(0,s.yg)(mWo,(0,p.A)({},uWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}yWo.isMDXComponent=!0;const dWo={toc:[]},hWo="wrapper";function gWo(e){let{components:n,...t}=e;return(0,s.yg)(hWo,(0,p.A)({},dWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gWo.isMDXComponent=!0;const fWo={toc:[]},DWo="wrapper";function MWo(e){let{components:n,...t}=e;return(0,s.yg)(DWo,(0,p.A)({},fWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}MWo.isMDXComponent=!0;const XWo={toc:[]},_Wo="wrapper";function wWo(e){let{components:n,...t}=e;return(0,s.yg)(_Wo,(0,p.A)({},XWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wWo.isMDXComponent=!0;const TWo={toc:[]},CWo="wrapper";function xWo(e){let{components:n,...t}=e;return(0,s.yg)(CWo,(0,p.A)({},TWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xWo.isMDXComponent=!0;const AWo={toc:[]},vWo="wrapper";function LWo(e){let{components:n,...t}=e;return(0,s.yg)(vWo,(0,p.A)({},AWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}LWo.isMDXComponent=!0;const bWo={toc:[]},NWo="wrapper";function kWo(e){let{components:n,...t}=e;return(0,s.yg)(NWo,(0,p.A)({},bWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kWo.isMDXComponent=!0;const zWo={toc:[]},PWo="wrapper";function IWo(e){let{components:n,...t}=e;return(0,s.yg)(PWo,(0,p.A)({},zWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}IWo.isMDXComponent=!0;const RWo={toc:[]},WWo="wrapper";function SWo(e){let{components:n,...t}=e;return(0,s.yg)(WWo,(0,p.A)({},RWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"MotionCanvas Shape properties"))}SWo.isMDXComponent=!0;const BWo={toc:[]},GWo="wrapper";function EWo(e){let{components:n,...t}=e;return(0,s.yg)(GWo,(0,p.A)({},BWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get position, rotation and scale from Matrix transformation as Shape properties"))}EWo.isMDXComponent=!0;const OWo={toc:[]},UWo="wrapper";function FWo(e){let{components:n,...t}=e;return(0,s.yg)(UWo,(0,p.A)({},OWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Matrix transformation"))}FWo.isMDXComponent=!0;const VWo={toc:[]},qWo="wrapper";function jWo(e){let{components:n,...t}=e;return(0,s.yg)(qWo,(0,p.A)({},VWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," that can be used to build SVGDocument."))}jWo.isMDXComponent=!0;const HWo={toc:[]},YWo="wrapper";function QWo(e){let{components:n,...t}=e;return(0,s.yg)(YWo,(0,p.A)({},HWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse an SVG string as ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData"),"."))}QWo.isMDXComponent=!0;const $Wo={toc:[]},KWo="wrapper";function JWo(e){let{components:n,...t}=e;return(0,s.yg)(KWo,(0,p.A)({},$Wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"And SVG string to be parsed."))}JWo.isMDXComponent=!0;const ZWo={toc:[]},eSo="wrapper";function nSo(e){let{components:n,...t}=e;return(0,s.yg)(eSo,(0,p.A)({},ZWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}nSo.isMDXComponent=!0;const tSo={toc:[]},oSo="wrapper";function pSo(e){let{components:n,...t}=e;return(0,s.yg)(oSo,(0,p.A)({},tSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}pSo.isMDXComponent=!0;const rSo={toc:[]},sSo="wrapper";function cSo(e){let{components:n,...t}=e;return(0,s.yg)(sSo,(0,p.A)({},rSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cSo.isMDXComponent=!0;const aSo={toc:[]},iSo="wrapper";function lSo(e){let{components:n,...t}=e;return(0,s.yg)(iSo,(0,p.A)({},aSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}lSo.isMDXComponent=!0;const uSo={toc:[]},mSo="wrapper";function ySo(e){let{components:n,...t}=e;return(0,s.yg)(mSo,(0,p.A)({},uSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}ySo.isMDXComponent=!0;const dSo={toc:[]},hSo="wrapper";function gSo(e){let{components:n,...t}=e;return(0,s.yg)(hSo,(0,p.A)({},dSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}gSo.isMDXComponent=!0;const fSo={toc:[]},DSo="wrapper";function MSo(e){let{components:n,...t}=e;return(0,s.yg)(DSo,(0,p.A)({},fSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}MSo.isMDXComponent=!0;const XSo={toc:[]},_So="wrapper";function wSo(e){let{components:n,...t}=e;return(0,s.yg)(_So,(0,p.A)({},XSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}wSo.isMDXComponent=!0;const TSo={toc:[]},CSo="wrapper";function xSo(e){let{components:n,...t}=e;return(0,s.yg)(CSo,(0,p.A)({},TSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}xSo.isMDXComponent=!0;const ASo={toc:[]},vSo="wrapper";function LSo(e){let{components:n,...t}=e;return(0,s.yg)(vSo,(0,p.A)({},ASo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}LSo.isMDXComponent=!0;const bSo={toc:[]},NSo="wrapper";function kSo(e){let{components:n,...t}=e;return(0,s.yg)(NSo,(0,p.A)({},bSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}kSo.isMDXComponent=!0;const zSo={toc:[]},PSo="wrapper";function ISo(e){let{components:n,...t}=e;return(0,s.yg)(PSo,(0,p.A)({},zSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}ISo.isMDXComponent=!0;const RSo={toc:[]},WSo="wrapper";function SSo(e){let{components:n,...t}=e;return(0,s.yg)(WSo,(0,p.A)({},RSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SSo.isMDXComponent=!0;const BSo={toc:[]},GSo="wrapper";function ESo(e){let{components:n,...t}=e;return(0,s.yg)(GSo,(0,p.A)({},BSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ESo.isMDXComponent=!0;const OSo={toc:[]},USo="wrapper";function FSo(e){let{components:n,...t}=e;return(0,s.yg)(USo,(0,p.A)({},OSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}FSo.isMDXComponent=!0;const VSo={toc:[]},qSo="wrapper";function jSo(e){let{components:n,...t}=e;return(0,s.yg)(qSo,(0,p.A)({},VSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}jSo.isMDXComponent=!0;const HSo={toc:[]},YSo="wrapper";function QSo(e){let{components:n,...t}=e;return(0,s.yg)(YSo,(0,p.A)({},HSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}QSo.isMDXComponent=!0;const $So={toc:[]},KSo="wrapper";function JSo(e){let{components:n,...t}=e;return(0,s.yg)(KSo,(0,p.A)({},$So,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}JSo.isMDXComponent=!0;const ZSo={toc:[]},eBo="wrapper";function nBo(e){let{components:n,...t}=e;return(0,s.yg)(eBo,(0,p.A)({},ZSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nBo.isMDXComponent=!0;const tBo={toc:[]},oBo="wrapper";function pBo(e){let{components:n,...t}=e;return(0,s.yg)(oBo,(0,p.A)({},tBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}pBo.isMDXComponent=!0;const rBo={toc:[]},sBo="wrapper";function cBo(e){let{components:n,...t}=e;return(0,s.yg)(sBo,(0,p.A)({},rBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}cBo.isMDXComponent=!0;const aBo={toc:[]},iBo="wrapper";function lBo(e){let{components:n,...t}=e;return(0,s.yg)(iBo,(0,p.A)({},aBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}lBo.isMDXComponent=!0;const uBo={toc:[]},mBo="wrapper";function yBo(e){let{components:n,...t}=e;return(0,s.yg)(mBo,(0,p.A)({},uBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}yBo.isMDXComponent=!0;const dBo={toc:[]},hBo="wrapper";function gBo(e){let{components:n,...t}=e;return(0,s.yg)(hBo,(0,p.A)({},dBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}gBo.isMDXComponent=!0;const fBo={toc:[]},DBo="wrapper";function MBo(e){let{components:n,...t}=e;return(0,s.yg)(DBo,(0,p.A)({},fBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}MBo.isMDXComponent=!0;const XBo={toc:[]},_Bo="wrapper";function wBo(e){let{components:n,...t}=e;return(0,s.yg)(_Bo,(0,p.A)({},XBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}wBo.isMDXComponent=!0;const TBo={toc:[]},CBo="wrapper";function xBo(e){let{components:n,...t}=e;return(0,s.yg)(CBo,(0,p.A)({},TBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xBo.isMDXComponent=!0;const ABo={toc:[]},vBo="wrapper";function LBo(e){let{components:n,...t}=e;return(0,s.yg)(vBo,(0,p.A)({},ABo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LBo.isMDXComponent=!0;const bBo={toc:[]},NBo="wrapper";function kBo(e){let{components:n,...t}=e;return(0,s.yg)(NBo,(0,p.A)({},bBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}kBo.isMDXComponent=!0;const zBo={toc:[]},PBo="wrapper";function IBo(e){let{components:n,...t}=e;return(0,s.yg)(PBo,(0,p.A)({},zBo,t,{components:n,mdxType:"MDXLayout"}))}IBo.isMDXComponent=!0;const RBo={toc:[]},WBo="wrapper";function SBo(e){let{components:n,...t}=e;return(0,s.yg)(WBo,(0,p.A)({},RBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}SBo.isMDXComponent=!0;const BBo={toc:[]},GBo="wrapper";function EBo(e){let{components:n,...t}=e;return(0,s.yg)(GBo,(0,p.A)({},BBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}EBo.isMDXComponent=!0;const OBo={toc:[]},UBo="wrapper";function FBo(e){let{components:n,...t}=e;return(0,s.yg)(UBo,(0,p.A)({},OBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}FBo.isMDXComponent=!0;const VBo={toc:[]},qBo="wrapper";function jBo(e){let{components:n,...t}=e;return(0,s.yg)(qBo,(0,p.A)({},VBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}jBo.isMDXComponent=!0;const HBo={toc:[]},YBo="wrapper";function QBo(e){let{components:n,...t}=e;return(0,s.yg)(YBo,(0,p.A)({},HBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}QBo.isMDXComponent=!0;const $Bo={toc:[]},KBo="wrapper";function JBo(e){let{components:n,...t}=e;return(0,s.yg)(KBo,(0,p.A)({},$Bo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}JBo.isMDXComponent=!0;const ZBo={toc:[]},eGo="wrapper";function nGo(e){let{components:n,...t}=e;return(0,s.yg)(eGo,(0,p.A)({},ZBo,t,{components:n,mdxType:"MDXLayout"}))}nGo.isMDXComponent=!0;const tGo={toc:[]},oGo="wrapper";function pGo(e){let{components:n,...t}=e;return(0,s.yg)(oGo,(0,p.A)({},tGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}pGo.isMDXComponent=!0;const rGo={toc:[]},sGo="wrapper";function cGo(e){let{components:n,...t}=e;return(0,s.yg)(sGo,(0,p.A)({},rGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}cGo.isMDXComponent=!0;const aGo={toc:[]},iGo="wrapper";function lGo(e){let{components:n,...t}=e;return(0,s.yg)(iGo,(0,p.A)({},aGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lGo.isMDXComponent=!0;const uGo={toc:[]},mGo="wrapper";function yGo(e){let{components:n,...t}=e;return(0,s.yg)(mGo,(0,p.A)({},uGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}yGo.isMDXComponent=!0;const dGo={toc:[]},hGo="wrapper";function gGo(e){let{components:n,...t}=e;return(0,s.yg)(hGo,(0,p.A)({},dGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}gGo.isMDXComponent=!0;const fGo={toc:[]},DGo="wrapper";function MGo(e){let{components:n,...t}=e;return(0,s.yg)(DGo,(0,p.A)({},fGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}MGo.isMDXComponent=!0;const XGo={toc:[]},_Go="wrapper";function wGo(e){let{components:n,...t}=e;return(0,s.yg)(_Go,(0,p.A)({},XGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}wGo.isMDXComponent=!0;const TGo={toc:[]},CGo="wrapper";function xGo(e){let{components:n,...t}=e;return(0,s.yg)(CGo,(0,p.A)({},TGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}xGo.isMDXComponent=!0;const AGo={toc:[]},vGo="wrapper";function LGo(e){let{components:n,...t}=e;return(0,s.yg)(vGo,(0,p.A)({},AGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}LGo.isMDXComponent=!0;const bGo={toc:[]},NGo="wrapper";function kGo(e){let{components:n,...t}=e;return(0,s.yg)(NGo,(0,p.A)({},bGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}kGo.isMDXComponent=!0;const zGo={toc:[]},PGo="wrapper";function IGo(e){let{components:n,...t}=e;return(0,s.yg)(PGo,(0,p.A)({},zGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}IGo.isMDXComponent=!0;const RGo={toc:[]},WGo="wrapper";function SGo(e){let{components:n,...t}=e;return(0,s.yg)(WGo,(0,p.A)({},RGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}SGo.isMDXComponent=!0;const BGo={toc:[]},GGo="wrapper";function EGo(e){let{components:n,...t}=e;return(0,s.yg)(GGo,(0,p.A)({},BGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}EGo.isMDXComponent=!0;const OGo={toc:[]},UGo="wrapper";function FGo(e){let{components:n,...t}=e;return(0,s.yg)(UGo,(0,p.A)({},OGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}FGo.isMDXComponent=!0;const VGo={toc:[]},qGo="wrapper";function jGo(e){let{components:n,...t}=e;return(0,s.yg)(qGo,(0,p.A)({},VGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}jGo.isMDXComponent=!0;const HGo={toc:[]},YGo="wrapper";function QGo(e){let{components:n,...t}=e;return(0,s.yg)(YGo,(0,p.A)({},HGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}QGo.isMDXComponent=!0;const $Go={toc:[]},KGo="wrapper";function JGo(e){let{components:n,...t}=e;return(0,s.yg)(KGo,(0,p.A)({},$Go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}JGo.isMDXComponent=!0;const ZGo={toc:[]},eEo="wrapper";function nEo(e){let{components:n,...t}=e;return(0,s.yg)(eEo,(0,p.A)({},ZGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nEo.isMDXComponent=!0;const tEo={toc:[]},oEo="wrapper";function pEo(e){let{components:n,...t}=e;return(0,s.yg)(oEo,(0,p.A)({},tEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}pEo.isMDXComponent=!0;const rEo={toc:[]},sEo="wrapper";function cEo(e){let{components:n,...t}=e;return(0,s.yg)(sEo,(0,p.A)({},rEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}cEo.isMDXComponent=!0;const aEo={toc:[]},iEo="wrapper";function lEo(e){let{components:n,...t}=e;return(0,s.yg)(iEo,(0,p.A)({},aEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}lEo.isMDXComponent=!0;const uEo={toc:[]},mEo="wrapper";function yEo(e){let{components:n,...t}=e;return(0,s.yg)(mEo,(0,p.A)({},uEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}yEo.isMDXComponent=!0;const dEo={toc:[]},hEo="wrapper";function gEo(e){let{components:n,...t}=e;return(0,s.yg)(hEo,(0,p.A)({},dEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}gEo.isMDXComponent=!0;const fEo={toc:[]},DEo="wrapper";function MEo(e){let{components:n,...t}=e;return(0,s.yg)(DEo,(0,p.A)({},fEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}MEo.isMDXComponent=!0;const XEo={toc:[]},_Eo="wrapper";function wEo(e){let{components:n,...t}=e;return(0,s.yg)(_Eo,(0,p.A)({},XEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}wEo.isMDXComponent=!0;const TEo={toc:[]},CEo="wrapper";function xEo(e){let{components:n,...t}=e;return(0,s.yg)(CEo,(0,p.A)({},TEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}xEo.isMDXComponent=!0;const AEo={toc:[]},vEo="wrapper";function LEo(e){let{components:n,...t}=e;return(0,s.yg)(vEo,(0,p.A)({},AEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}LEo.isMDXComponent=!0;const bEo={toc:[]},NEo="wrapper";function kEo(e){let{components:n,...t}=e;return(0,s.yg)(NEo,(0,p.A)({},bEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}kEo.isMDXComponent=!0;const zEo={toc:[]},PEo="wrapper";function IEo(e){let{components:n,...t}=e;return(0,s.yg)(PEo,(0,p.A)({},zEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}IEo.isMDXComponent=!0;const REo={toc:[]},WEo="wrapper";function SEo(e){let{components:n,...t}=e;return(0,s.yg)(WEo,(0,p.A)({},REo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}SEo.isMDXComponent=!0;const BEo={toc:[]},GEo="wrapper";function EEo(e){let{components:n,...t}=e;return(0,s.yg)(GEo,(0,p.A)({},BEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}EEo.isMDXComponent=!0;const OEo={toc:[]},UEo="wrapper";function FEo(e){let{components:n,...t}=e;return(0,s.yg)(UEo,(0,p.A)({},OEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}FEo.isMDXComponent=!0;const VEo={toc:[]},qEo="wrapper";function jEo(e){let{components:n,...t}=e;return(0,s.yg)(qEo,(0,p.A)({},VEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jEo.isMDXComponent=!0;const HEo={toc:[]},YEo="wrapper";function QEo(e){let{components:n,...t}=e;return(0,s.yg)(YEo,(0,p.A)({},HEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QEo.isMDXComponent=!0;const $Eo={toc:[]},KEo="wrapper";function JEo(e){let{components:n,...t}=e;return(0,s.yg)(KEo,(0,p.A)({},$Eo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}JEo.isMDXComponent=!0;const ZEo={toc:[]},eOo="wrapper";function nOo(e){let{components:n,...t}=e;return(0,s.yg)(eOo,(0,p.A)({},ZEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}nOo.isMDXComponent=!0;const tOo={toc:[]},oOo="wrapper";function pOo(e){let{components:n,...t}=e;return(0,s.yg)(oOo,(0,p.A)({},tOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}pOo.isMDXComponent=!0;const rOo={toc:[]},sOo="wrapper";function cOo(e){let{components:n,...t}=e;return(0,s.yg)(sOo,(0,p.A)({},rOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}cOo.isMDXComponent=!0;const aOo={toc:[]},iOo="wrapper";function lOo(e){let{components:n,...t}=e;return(0,s.yg)(iOo,(0,p.A)({},aOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lOo.isMDXComponent=!0;const uOo={toc:[]},mOo="wrapper";function yOo(e){let{components:n,...t}=e;return(0,s.yg)(mOo,(0,p.A)({},uOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yOo.isMDXComponent=!0;const dOo={toc:[]},hOo="wrapper";function gOo(e){let{components:n,...t}=e;return(0,s.yg)(hOo,(0,p.A)({},dOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gOo.isMDXComponent=!0;const fOo={toc:[]},DOo="wrapper";function MOo(e){let{components:n,...t}=e;return(0,s.yg)(DOo,(0,p.A)({},fOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}MOo.isMDXComponent=!0;const XOo={toc:[]},_Oo="wrapper";function wOo(e){let{components:n,...t}=e;return(0,s.yg)(_Oo,(0,p.A)({},XOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wOo.isMDXComponent=!0;const TOo={toc:[]},COo="wrapper";function xOo(e){let{components:n,...t}=e;return(0,s.yg)(COo,(0,p.A)({},TOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xOo.isMDXComponent=!0;const AOo={toc:[]},vOo="wrapper";function LOo(e){let{components:n,...t}=e;return(0,s.yg)(vOo,(0,p.A)({},AOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LOo.isMDXComponent=!0;const bOo={toc:[]},NOo="wrapper";function kOo(e){let{components:n,...t}=e;return(0,s.yg)(NOo,(0,p.A)({},bOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}kOo.isMDXComponent=!0;const zOo={toc:[]},POo="wrapper";function IOo(e){let{components:n,...t}=e;return(0,s.yg)(POo,(0,p.A)({},zOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}IOo.isMDXComponent=!0;const ROo={toc:[]},WOo="wrapper";function SOo(e){let{components:n,...t}=e;return(0,s.yg)(WOo,(0,p.A)({},ROo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}SOo.isMDXComponent=!0;const BOo={toc:[]},GOo="wrapper";function EOo(e){let{components:n,...t}=e;return(0,s.yg)(GOo,(0,p.A)({},BOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}EOo.isMDXComponent=!0;const OOo={toc:[]},UOo="wrapper";function FOo(e){let{components:n,...t}=e;return(0,s.yg)(UOo,(0,p.A)({},OOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}FOo.isMDXComponent=!0;const VOo={toc:[]},qOo="wrapper";function jOo(e){let{components:n,...t}=e;return(0,s.yg)(qOo,(0,p.A)({},VOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jOo.isMDXComponent=!0;const HOo={toc:[]},YOo="wrapper";function QOo(e){let{components:n,...t}=e;return(0,s.yg)(YOo,(0,p.A)({},HOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}QOo.isMDXComponent=!0;const $Oo={toc:[]},KOo="wrapper";function JOo(e){let{components:n,...t}=e;return(0,s.yg)(KOo,(0,p.A)({},$Oo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JOo.isMDXComponent=!0;const ZOo={toc:[]},eUo="wrapper";function nUo(e){let{components:n,...t}=e;return(0,s.yg)(eUo,(0,p.A)({},ZOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}nUo.isMDXComponent=!0;const tUo={toc:[]},oUo="wrapper";function pUo(e){let{components:n,...t}=e;return(0,s.yg)(oUo,(0,p.A)({},tUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pUo.isMDXComponent=!0;const rUo={toc:[]},sUo="wrapper";function cUo(e){let{components:n,...t}=e;return(0,s.yg)(sUo,(0,p.A)({},rUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}cUo.isMDXComponent=!0;const aUo={toc:[]},iUo="wrapper";function lUo(e){let{components:n,...t}=e;return(0,s.yg)(iUo,(0,p.A)({},aUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}lUo.isMDXComponent=!0;const uUo={toc:[]},mUo="wrapper";function yUo(e){let{components:n,...t}=e;return(0,s.yg)(mUo,(0,p.A)({},uUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yUo.isMDXComponent=!0;const dUo={toc:[]},hUo="wrapper";function gUo(e){let{components:n,...t}=e;return(0,s.yg)(hUo,(0,p.A)({},dUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}gUo.isMDXComponent=!0;const fUo={toc:[]},DUo="wrapper";function MUo(e){let{components:n,...t}=e;return(0,s.yg)(DUo,(0,p.A)({},fUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}MUo.isMDXComponent=!0;const XUo={toc:[]},_Uo="wrapper";function wUo(e){let{components:n,...t}=e;return(0,s.yg)(_Uo,(0,p.A)({},XUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}wUo.isMDXComponent=!0;const TUo={toc:[]},CUo="wrapper";function xUo(e){let{components:n,...t}=e;return(0,s.yg)(CUo,(0,p.A)({},TUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}xUo.isMDXComponent=!0;const AUo={toc:[]},vUo="wrapper";function LUo(e){let{components:n,...t}=e;return(0,s.yg)(vUo,(0,p.A)({},AUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}LUo.isMDXComponent=!0;const bUo={toc:[]},NUo="wrapper";function kUo(e){let{components:n,...t}=e;return(0,s.yg)(NUo,(0,p.A)({},bUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}kUo.isMDXComponent=!0;const zUo={toc:[]},PUo="wrapper";function IUo(e){let{components:n,...t}=e;return(0,s.yg)(PUo,(0,p.A)({},zUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}IUo.isMDXComponent=!0;const RUo={toc:[]},WUo="wrapper";function SUo(e){let{components:n,...t}=e;return(0,s.yg)(WUo,(0,p.A)({},RUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}SUo.isMDXComponent=!0;const BUo={toc:[]},GUo="wrapper";function EUo(e){let{components:n,...t}=e;return(0,s.yg)(GUo,(0,p.A)({},BUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}EUo.isMDXComponent=!0;const OUo={toc:[]},UUo="wrapper";function FUo(e){let{components:n,...t}=e;return(0,s.yg)(UUo,(0,p.A)({},OUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}FUo.isMDXComponent=!0;const VUo={toc:[]},qUo="wrapper";function jUo(e){let{components:n,...t}=e;return(0,s.yg)(qUo,(0,p.A)({},VUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}jUo.isMDXComponent=!0;const HUo={toc:[]},YUo="wrapper";function QUo(e){let{components:n,...t}=e;return(0,s.yg)(YUo,(0,p.A)({},HUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QUo.isMDXComponent=!0;const $Uo={toc:[]},KUo="wrapper";function JUo(e){let{components:n,...t}=e;return(0,s.yg)(KUo,(0,p.A)({},$Uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}JUo.isMDXComponent=!0;const ZUo={toc:[]},eFo="wrapper";function nFo(e){let{components:n,...t}=e;return(0,s.yg)(eFo,(0,p.A)({},ZUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nFo.isMDXComponent=!0;const tFo={toc:[]},oFo="wrapper";function pFo(e){let{components:n,...t}=e;return(0,s.yg)(oFo,(0,p.A)({},tFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pFo.isMDXComponent=!0;const rFo={toc:[]},sFo="wrapper";function cFo(e){let{components:n,...t}=e;return(0,s.yg)(sFo,(0,p.A)({},rFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}cFo.isMDXComponent=!0;const aFo={toc:[]},iFo="wrapper";function lFo(e){let{components:n,...t}=e;return(0,s.yg)(iFo,(0,p.A)({},aFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lFo.isMDXComponent=!0;const uFo={toc:[]},mFo="wrapper";function yFo(e){let{components:n,...t}=e;return(0,s.yg)(mFo,(0,p.A)({},uFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}yFo.isMDXComponent=!0;const dFo={toc:[]},hFo="wrapper";function gFo(e){let{components:n,...t}=e;return(0,s.yg)(hFo,(0,p.A)({},dFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}gFo.isMDXComponent=!0;const fFo={toc:[]},DFo="wrapper";function MFo(e){let{components:n,...t}=e;return(0,s.yg)(DFo,(0,p.A)({},fFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MFo.isMDXComponent=!0;const XFo={toc:[]},_Fo="wrapper";function wFo(e){let{components:n,...t}=e;return(0,s.yg)(_Fo,(0,p.A)({},XFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}wFo.isMDXComponent=!0;const TFo={toc:[]},CFo="wrapper";function xFo(e){let{components:n,...t}=e;return(0,s.yg)(CFo,(0,p.A)({},TFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}xFo.isMDXComponent=!0;const AFo={toc:[]},vFo="wrapper";function LFo(e){let{components:n,...t}=e;return(0,s.yg)(vFo,(0,p.A)({},AFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}LFo.isMDXComponent=!0;const bFo={toc:[]},NFo="wrapper";function kFo(e){let{components:n,...t}=e;return(0,s.yg)(NFo,(0,p.A)({},bFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kFo.isMDXComponent=!0;const zFo={toc:[]},PFo="wrapper";function IFo(e){let{components:n,...t}=e;return(0,s.yg)(PFo,(0,p.A)({},zFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}IFo.isMDXComponent=!0;const RFo={toc:[]},WFo="wrapper";function SFo(e){let{components:n,...t}=e;return(0,s.yg)(WFo,(0,p.A)({},RFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}SFo.isMDXComponent=!0;const BFo={toc:[]},GFo="wrapper";function EFo(e){let{components:n,...t}=e;return(0,s.yg)(GFo,(0,p.A)({},BFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}EFo.isMDXComponent=!0;const OFo={toc:[]},UFo="wrapper";function FFo(e){let{components:n,...t}=e;return(0,s.yg)(UFo,(0,p.A)({},OFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}FFo.isMDXComponent=!0;const VFo={toc:[]},qFo="wrapper";function jFo(e){let{components:n,...t}=e;return(0,s.yg)(qFo,(0,p.A)({},VFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}jFo.isMDXComponent=!0;const HFo={toc:[]},YFo="wrapper";function QFo(e){let{components:n,...t}=e;return(0,s.yg)(YFo,(0,p.A)({},HFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}QFo.isMDXComponent=!0;const $Fo={toc:[]},KFo="wrapper";function JFo(e){let{components:n,...t}=e;return(0,s.yg)(KFo,(0,p.A)({},$Fo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}JFo.isMDXComponent=!0;const ZFo={toc:[]},eVo="wrapper";function nVo(e){let{components:n,...t}=e;return(0,s.yg)(eVo,(0,p.A)({},ZFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nVo.isMDXComponent=!0;const tVo={toc:[]},oVo="wrapper";function pVo(e){let{components:n,...t}=e;return(0,s.yg)(oVo,(0,p.A)({},tVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}pVo.isMDXComponent=!0;const rVo={toc:[]},sVo="wrapper";function cVo(e){let{components:n,...t}=e;return(0,s.yg)(sVo,(0,p.A)({},rVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}cVo.isMDXComponent=!0;const aVo={toc:[]},iVo="wrapper";function lVo(e){let{components:n,...t}=e;return(0,s.yg)(iVo,(0,p.A)({},aVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}lVo.isMDXComponent=!0;const uVo={toc:[]},mVo="wrapper";function yVo(e){let{components:n,...t}=e;return(0,s.yg)(mVo,(0,p.A)({},uVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}yVo.isMDXComponent=!0;const dVo={toc:[]},hVo="wrapper";function gVo(e){let{components:n,...t}=e;return(0,s.yg)(hVo,(0,p.A)({},dVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gVo.isMDXComponent=!0;const fVo={toc:[]},DVo="wrapper";function MVo(e){let{components:n,...t}=e;return(0,s.yg)(DVo,(0,p.A)({},fVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}MVo.isMDXComponent=!0;const XVo={toc:[]},_Vo="wrapper";function wVo(e){let{components:n,...t}=e;return(0,s.yg)(_Vo,(0,p.A)({},XVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wVo.isMDXComponent=!0;const TVo={toc:[]},CVo="wrapper";function xVo(e){let{components:n,...t}=e;return(0,s.yg)(CVo,(0,p.A)({},TVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}xVo.isMDXComponent=!0;const AVo={toc:[]},vVo="wrapper";function LVo(e){let{components:n,...t}=e;return(0,s.yg)(vVo,(0,p.A)({},AVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}LVo.isMDXComponent=!0;const bVo={toc:[]},NVo="wrapper";function kVo(e){let{components:n,...t}=e;return(0,s.yg)(NVo,(0,p.A)({},bVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}kVo.isMDXComponent=!0;const zVo={toc:[]},PVo="wrapper";function IVo(e){let{components:n,...t}=e;return(0,s.yg)(PVo,(0,p.A)({},zVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}IVo.isMDXComponent=!0;const RVo={toc:[]},WVo="wrapper";function SVo(e){let{components:n,...t}=e;return(0,s.yg)(WVo,(0,p.A)({},RVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}SVo.isMDXComponent=!0;const BVo={toc:[]},GVo="wrapper";function EVo(e){let{components:n,...t}=e;return(0,s.yg)(GVo,(0,p.A)({},BVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}EVo.isMDXComponent=!0;const OVo={toc:[]},UVo="wrapper";function FVo(e){let{components:n,...t}=e;return(0,s.yg)(UVo,(0,p.A)({},OVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}FVo.isMDXComponent=!0;const VVo={toc:[]},qVo="wrapper";function jVo(e){let{components:n,...t}=e;return(0,s.yg)(qVo,(0,p.A)({},VVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}jVo.isMDXComponent=!0;const HVo={toc:[]},YVo="wrapper";function QVo(e){let{components:n,...t}=e;return(0,s.yg)(YVo,(0,p.A)({},HVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}QVo.isMDXComponent=!0;const $Vo={toc:[]},KVo="wrapper";function JVo(e){let{components:n,...t}=e;return(0,s.yg)(KVo,(0,p.A)({},$Vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}JVo.isMDXComponent=!0;const ZVo={toc:[]},eqo="wrapper";function nqo(e){let{components:n,...t}=e;return(0,s.yg)(eqo,(0,p.A)({},ZVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}nqo.isMDXComponent=!0;const tqo={toc:[]},oqo="wrapper";function pqo(e){let{components:n,...t}=e;return(0,s.yg)(oqo,(0,p.A)({},tqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}pqo.isMDXComponent=!0;const rqo={toc:[]},sqo="wrapper";function cqo(e){let{components:n,...t}=e;return(0,s.yg)(sqo,(0,p.A)({},rqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}cqo.isMDXComponent=!0;const aqo={toc:[]},iqo="wrapper";function lqo(e){let{components:n,...t}=e;return(0,s.yg)(iqo,(0,p.A)({},aqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}lqo.isMDXComponent=!0;const uqo={toc:[]},mqo="wrapper";function yqo(e){let{components:n,...t}=e;return(0,s.yg)(mqo,(0,p.A)({},uqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}yqo.isMDXComponent=!0;const dqo={toc:[]},hqo="wrapper";function gqo(e){let{components:n,...t}=e;return(0,s.yg)(hqo,(0,p.A)({},dqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}gqo.isMDXComponent=!0;const fqo={toc:[]},Dqo="wrapper";function Mqo(e){let{components:n,...t}=e;return(0,s.yg)(Dqo,(0,p.A)({},fqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Mqo.isMDXComponent=!0;const Xqo={toc:[]},_qo="wrapper";function wqo(e){let{components:n,...t}=e;return(0,s.yg)(_qo,(0,p.A)({},Xqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wqo.isMDXComponent=!0;const Tqo={toc:[]},Cqo="wrapper";function xqo(e){let{components:n,...t}=e;return(0,s.yg)(Cqo,(0,p.A)({},Tqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}xqo.isMDXComponent=!0;const Aqo={toc:[]},vqo="wrapper";function Lqo(e){let{components:n,...t}=e;return(0,s.yg)(vqo,(0,p.A)({},Aqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Lqo.isMDXComponent=!0;const bqo={toc:[]},Nqo="wrapper";function kqo(e){let{components:n,...t}=e;return(0,s.yg)(Nqo,(0,p.A)({},bqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kqo.isMDXComponent=!0;const zqo={toc:[]},Pqo="wrapper";function Iqo(e){let{components:n,...t}=e;return(0,s.yg)(Pqo,(0,p.A)({},zqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Iqo.isMDXComponent=!0;const Rqo={toc:[]},Wqo="wrapper";function Sqo(e){let{components:n,...t}=e;return(0,s.yg)(Wqo,(0,p.A)({},Rqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Sqo.isMDXComponent=!0;const Bqo={toc:[]},Gqo="wrapper";function Eqo(e){let{components:n,...t}=e;return(0,s.yg)(Gqo,(0,p.A)({},Bqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Eqo.isMDXComponent=!0;const Oqo={toc:[]},Uqo="wrapper";function Fqo(e){let{components:n,...t}=e;return(0,s.yg)(Uqo,(0,p.A)({},Oqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Fqo.isMDXComponent=!0;const Vqo={toc:[]},qqo="wrapper";function jqo(e){let{components:n,...t}=e;return(0,s.yg)(qqo,(0,p.A)({},Vqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}jqo.isMDXComponent=!0;const Hqo={toc:[]},Yqo="wrapper";function Qqo(e){let{components:n,...t}=e;return(0,s.yg)(Yqo,(0,p.A)({},Hqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Qqo.isMDXComponent=!0;const $qo={toc:[]},Kqo="wrapper";function Jqo(e){let{components:n,...t}=e;return(0,s.yg)(Kqo,(0,p.A)({},$qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Jqo.isMDXComponent=!0;const Zqo={toc:[]},ejo="wrapper";function njo(e){let{components:n,...t}=e;return(0,s.yg)(ejo,(0,p.A)({},Zqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}njo.isMDXComponent=!0;const tjo={toc:[]},ojo="wrapper";function pjo(e){let{components:n,...t}=e;return(0,s.yg)(ojo,(0,p.A)({},tjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}pjo.isMDXComponent=!0;const rjo={toc:[]},sjo="wrapper";function cjo(e){let{components:n,...t}=e;return(0,s.yg)(sjo,(0,p.A)({},rjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}cjo.isMDXComponent=!0;const ajo={toc:[]},ijo="wrapper";function ljo(e){let{components:n,...t}=e;return(0,s.yg)(ijo,(0,p.A)({},ajo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}ljo.isMDXComponent=!0;const ujo={toc:[]},mjo="wrapper";function yjo(e){let{components:n,...t}=e;return(0,s.yg)(mjo,(0,p.A)({},ujo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}yjo.isMDXComponent=!0;const djo={toc:[]},hjo="wrapper";function gjo(e){let{components:n,...t}=e;return(0,s.yg)(hjo,(0,p.A)({},djo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gjo.isMDXComponent=!0;const fjo={toc:[]},Djo="wrapper";function Mjo(e){let{components:n,...t}=e;return(0,s.yg)(Djo,(0,p.A)({},fjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Mjo.isMDXComponent=!0;const Xjo={toc:[]},_jo="wrapper";function wjo(e){let{components:n,...t}=e;return(0,s.yg)(_jo,(0,p.A)({},Xjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}wjo.isMDXComponent=!0;const Tjo={toc:[]},Cjo="wrapper";function xjo(e){let{components:n,...t}=e;return(0,s.yg)(Cjo,(0,p.A)({},Tjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xjo.isMDXComponent=!0;const Ajo={toc:[]},vjo="wrapper";function Ljo(e){let{components:n,...t}=e;return(0,s.yg)(vjo,(0,p.A)({},Ajo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Ljo.isMDXComponent=!0;const bjo={toc:[]},Njo="wrapper";function kjo(e){let{components:n,...t}=e;return(0,s.yg)(Njo,(0,p.A)({},bjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}kjo.isMDXComponent=!0;const zjo={toc:[]},Pjo="wrapper";function Ijo(e){let{components:n,...t}=e;return(0,s.yg)(Pjo,(0,p.A)({},zjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ijo.isMDXComponent=!0;const Rjo={toc:[]},Wjo="wrapper";function Sjo(e){let{components:n,...t}=e;return(0,s.yg)(Wjo,(0,p.A)({},Rjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Sjo.isMDXComponent=!0;const Bjo={toc:[]},Gjo="wrapper";function Ejo(e){let{components:n,...t}=e;return(0,s.yg)(Gjo,(0,p.A)({},Bjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Ejo.isMDXComponent=!0;const Ojo={toc:[]},Ujo="wrapper";function Fjo(e){let{components:n,...t}=e;return(0,s.yg)(Ujo,(0,p.A)({},Ojo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Fjo.isMDXComponent=!0;const Vjo={toc:[]},qjo="wrapper";function jjo(e){let{components:n,...t}=e;return(0,s.yg)(qjo,(0,p.A)({},Vjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}jjo.isMDXComponent=!0;const Hjo={toc:[]},Yjo="wrapper";function Qjo(e){let{components:n,...t}=e;return(0,s.yg)(Yjo,(0,p.A)({},Hjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Qjo.isMDXComponent=!0;const $jo={toc:[]},Kjo="wrapper";function Jjo(e){let{components:n,...t}=e;return(0,s.yg)(Kjo,(0,p.A)({},$jo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Jjo.isMDXComponent=!0;const Zjo={toc:[]},eHo="wrapper";function nHo(e){let{components:n,...t}=e;return(0,s.yg)(eHo,(0,p.A)({},Zjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}nHo.isMDXComponent=!0;const tHo={toc:[]},oHo="wrapper";function pHo(e){let{components:n,...t}=e;return(0,s.yg)(oHo,(0,p.A)({},tHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}pHo.isMDXComponent=!0;const rHo={toc:[]},sHo="wrapper";function cHo(e){let{components:n,...t}=e;return(0,s.yg)(sHo,(0,p.A)({},rHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}cHo.isMDXComponent=!0;const aHo={toc:[]},iHo="wrapper";function lHo(e){let{components:n,...t}=e;return(0,s.yg)(iHo,(0,p.A)({},aHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}lHo.isMDXComponent=!0;const uHo={toc:[]},mHo="wrapper";function yHo(e){let{components:n,...t}=e;return(0,s.yg)(mHo,(0,p.A)({},uHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defining knots using the ",(0,s.yg)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.yg)("p",null,"Defining knots with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.yg)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}yHo.isMDXComponent=!0;const dHo={toc:[]},hHo="wrapper";function gHo(e){let{components:n,...t}=e;return(0,s.yg)(hHo,(0,p.A)({},dHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a smooth line through a number of points."))}gHo.isMDXComponent=!0;const fHo={toc:[]},DHo="wrapper";function MHo(e){let{components:n,...t}=e;return(0,s.yg)(DHo,(0,p.A)({},fHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}MHo.isMDXComponent=!0;const XHo={toc:[]},_Ho="wrapper";function wHo(e){let{components:n,...t}=e;return(0,s.yg)(_Ho,(0,p.A)({},XHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}wHo.isMDXComponent=!0;const THo={toc:[]},CHo="wrapper";function xHo(e){let{components:n,...t}=e;return(0,s.yg)(CHo,(0,p.A)({},THo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xHo.isMDXComponent=!0;const AHo={toc:[]},vHo="wrapper";function LHo(e){let{components:n,...t}=e;return(0,s.yg)(vHo,(0,p.A)({},AHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}LHo.isMDXComponent=!0;const bHo={toc:[]},NHo="wrapper";function kHo(e){let{components:n,...t}=e;return(0,s.yg)(NHo,(0,p.A)({},bHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}kHo.isMDXComponent=!0;const zHo={toc:[]},PHo="wrapper";function IHo(e){let{components:n,...t}=e;return(0,s.yg)(PHo,(0,p.A)({},zHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}IHo.isMDXComponent=!0;const RHo={toc:[]},WHo="wrapper";function SHo(e){let{components:n,...t}=e;return(0,s.yg)(WHo,(0,p.A)({},RHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}SHo.isMDXComponent=!0;const BHo={toc:[]},GHo="wrapper";function EHo(e){let{components:n,...t}=e;return(0,s.yg)(GHo,(0,p.A)({},BHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}EHo.isMDXComponent=!0;const OHo={toc:[]},UHo="wrapper";function FHo(e){let{components:n,...t}=e;return(0,s.yg)(UHo,(0,p.A)({},OHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}FHo.isMDXComponent=!0;const VHo={toc:[]},qHo="wrapper";function jHo(e){let{components:n,...t}=e;return(0,s.yg)(qHo,(0,p.A)({},VHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}jHo.isMDXComponent=!0;const HHo={toc:[]},YHo="wrapper";function QHo(e){let{components:n,...t}=e;return(0,s.yg)(YHo,(0,p.A)({},HHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}QHo.isMDXComponent=!0;const $Ho={toc:[]},KHo="wrapper";function JHo(e){let{components:n,...t}=e;return(0,s.yg)(KHo,(0,p.A)({},$Ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}JHo.isMDXComponent=!0;const ZHo={toc:[]},eYo="wrapper";function nYo(e){let{components:n,...t}=e;return(0,s.yg)(eYo,(0,p.A)({},ZHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}nYo.isMDXComponent=!0;const tYo={toc:[]},oYo="wrapper";function pYo(e){let{components:n,...t}=e;return(0,s.yg)(oYo,(0,p.A)({},tYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}pYo.isMDXComponent=!0;const rYo={toc:[]},sYo="wrapper";function cYo(e){let{components:n,...t}=e;return(0,s.yg)(sYo,(0,p.A)({},rYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cYo.isMDXComponent=!0;const aYo={toc:[]},iYo="wrapper";function lYo(e){let{components:n,...t}=e;return(0,s.yg)(iYo,(0,p.A)({},aYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lYo.isMDXComponent=!0;const uYo={toc:[]},mYo="wrapper";function yYo(e){let{components:n,...t}=e;return(0,s.yg)(mYo,(0,p.A)({},uYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}yYo.isMDXComponent=!0;const dYo={toc:[]},hYo="wrapper";function gYo(e){let{components:n,...t}=e;return(0,s.yg)(hYo,(0,p.A)({},dYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}gYo.isMDXComponent=!0;const fYo={toc:[]},DYo="wrapper";function MYo(e){let{components:n,...t}=e;return(0,s.yg)(DYo,(0,p.A)({},fYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}MYo.isMDXComponent=!0;const XYo={toc:[]},_Yo="wrapper";function wYo(e){let{components:n,...t}=e;return(0,s.yg)(_Yo,(0,p.A)({},XYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}wYo.isMDXComponent=!0;const TYo={toc:[]},CYo="wrapper";function xYo(e){let{components:n,...t}=e;return(0,s.yg)(CYo,(0,p.A)({},TYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xYo.isMDXComponent=!0;const AYo={toc:[]},vYo="wrapper";function LYo(e){let{components:n,...t}=e;return(0,s.yg)(vYo,(0,p.A)({},AYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}LYo.isMDXComponent=!0;const bYo={toc:[]},NYo="wrapper";function kYo(e){let{components:n,...t}=e;return(0,s.yg)(NYo,(0,p.A)({},bYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kYo.isMDXComponent=!0;const zYo={toc:[]},PYo="wrapper";function IYo(e){let{components:n,...t}=e;return(0,s.yg)(PYo,(0,p.A)({},zYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}IYo.isMDXComponent=!0;const RYo={toc:[]},WYo="wrapper";function SYo(e){let{components:n,...t}=e;return(0,s.yg)(WYo,(0,p.A)({},RYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}SYo.isMDXComponent=!0;const BYo={toc:[]},GYo="wrapper";function EYo(e){let{components:n,...t}=e;return(0,s.yg)(GYo,(0,p.A)({},BYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}EYo.isMDXComponent=!0;const OYo={toc:[]},UYo="wrapper";function FYo(e){let{components:n,...t}=e;return(0,s.yg)(UYo,(0,p.A)({},OYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}FYo.isMDXComponent=!0;const VYo={toc:[]},qYo="wrapper";function jYo(e){let{components:n,...t}=e;return(0,s.yg)(qYo,(0,p.A)({},VYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}jYo.isMDXComponent=!0;const HYo={toc:[]},YYo="wrapper";function QYo(e){let{components:n,...t}=e;return(0,s.yg)(YYo,(0,p.A)({},HYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}QYo.isMDXComponent=!0;const $Yo={toc:[]},KYo="wrapper";function JYo(e){let{components:n,...t}=e;return(0,s.yg)(KYo,(0,p.A)({},$Yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}JYo.isMDXComponent=!0;const ZYo={toc:[]},eQo="wrapper";function nQo(e){let{components:n,...t}=e;return(0,s.yg)(eQo,(0,p.A)({},ZYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}nQo.isMDXComponent=!0;const tQo={toc:[]},oQo="wrapper";function pQo(e){let{components:n,...t}=e;return(0,s.yg)(oQo,(0,p.A)({},tQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}pQo.isMDXComponent=!0;const rQo={toc:[]},sQo="wrapper";function cQo(e){let{components:n,...t}=e;return(0,s.yg)(sQo,(0,p.A)({},rQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."))}cQo.isMDXComponent=!0;const aQo={toc:[]},iQo="wrapper";function lQo(e){let{components:n,...t}=e;return(0,s.yg)(iQo,(0,p.A)({},aQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}lQo.isMDXComponent=!0;const uQo={toc:[]},mQo="wrapper";function yQo(e){let{components:n,...t}=e;return(0,s.yg)(mQo,(0,p.A)({},uQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}yQo.isMDXComponent=!0;const dQo={toc:[]},hQo="wrapper";function gQo(e){let{components:n,...t}=e;return(0,s.yg)(hQo,(0,p.A)({},dQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}gQo.isMDXComponent=!0;const fQo={toc:[]},DQo="wrapper";function MQo(e){let{components:n,...t}=e;return(0,s.yg)(DQo,(0,p.A)({},fQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}MQo.isMDXComponent=!0;const XQo={toc:[]},_Qo="wrapper";function wQo(e){let{components:n,...t}=e;return(0,s.yg)(_Qo,(0,p.A)({},XQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}wQo.isMDXComponent=!0;const TQo={toc:[]},CQo="wrapper";function xQo(e){let{components:n,...t}=e;return(0,s.yg)(CQo,(0,p.A)({},TQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xQo.isMDXComponent=!0;const AQo={toc:[]},vQo="wrapper";function LQo(e){let{components:n,...t}=e;return(0,s.yg)(vQo,(0,p.A)({},AQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LQo.isMDXComponent=!0;const bQo={toc:[]},NQo="wrapper";function kQo(e){let{components:n,...t}=e;return(0,s.yg)(NQo,(0,p.A)({},bQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}kQo.isMDXComponent=!0;const zQo={toc:[]},PQo="wrapper";function IQo(e){let{components:n,...t}=e;return(0,s.yg)(PQo,(0,p.A)({},zQo,t,{components:n,mdxType:"MDXLayout"}))}IQo.isMDXComponent=!0;const RQo={toc:[]},WQo="wrapper";function SQo(e){let{components:n,...t}=e;return(0,s.yg)(WQo,(0,p.A)({},RQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}SQo.isMDXComponent=!0;const BQo={toc:[]},GQo="wrapper";function EQo(e){let{components:n,...t}=e;return(0,s.yg)(GQo,(0,p.A)({},BQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}EQo.isMDXComponent=!0;const OQo={toc:[]},UQo="wrapper";function FQo(e){let{components:n,...t}=e;return(0,s.yg)(UQo,(0,p.A)({},OQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}FQo.isMDXComponent=!0;const VQo={toc:[]},qQo="wrapper";function jQo(e){let{components:n,...t}=e;return(0,s.yg)(qQo,(0,p.A)({},VQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}jQo.isMDXComponent=!0;const HQo={toc:[]},YQo="wrapper";function QQo(e){let{components:n,...t}=e;return(0,s.yg)(YQo,(0,p.A)({},HQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}QQo.isMDXComponent=!0;const $Qo={toc:[]},KQo="wrapper";function JQo(e){let{components:n,...t}=e;return(0,s.yg)(KQo,(0,p.A)({},$Qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property is only applied to knots that don't use explicit handles."))}JQo.isMDXComponent=!0;const ZQo={toc:[]},e$o="wrapper";function n$o(e){let{components:n,...t}=e;return(0,s.yg)(e$o,(0,p.A)({},ZQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0.4"))}n$o.isMDXComponent=!0;const t$o={toc:[]},o$o="wrapper";function p$o(e){let{components:n,...t}=e;return(0,s.yg)(o$o,(0,p.A)({},t$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The smoothness of the spline when using auto-calculated handles."))}p$o.isMDXComponent=!0;const r$o={toc:[]},s$o="wrapper";function c$o(e){let{components:n,...t}=e;return(0,s.yg)(s$o,(0,p.A)({},r$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}c$o.isMDXComponent=!0;const a$o={toc:[]},i$o="wrapper";function l$o(e){let{components:n,...t}=e;return(0,s.yg)(i$o,(0,p.A)({},a$o,t,{components:n,mdxType:"MDXLayout"}))}l$o.isMDXComponent=!0;const u$o={toc:[]},m$o="wrapper";function y$o(e){let{components:n,...t}=e;return(0,s.yg)(m$o,(0,p.A)({},u$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}y$o.isMDXComponent=!0;const d$o={toc:[]},h$o="wrapper";function g$o(e){let{components:n,...t}=e;return(0,s.yg)(h$o,(0,p.A)({},d$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}g$o.isMDXComponent=!0;const f$o={toc:[]},D$o="wrapper";function M$o(e){let{components:n,...t}=e;return(0,s.yg)(D$o,(0,p.A)({},f$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}M$o.isMDXComponent=!0;const X$o={toc:[]},_$o="wrapper";function w$o(e){let{components:n,...t}=e;return(0,s.yg)(_$o,(0,p.A)({},X$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}w$o.isMDXComponent=!0;const T$o={toc:[]},C$o="wrapper";function x$o(e){let{components:n,...t}=e;return(0,s.yg)(C$o,(0,p.A)({},T$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}x$o.isMDXComponent=!0;const A$o={toc:[]},v$o="wrapper";function L$o(e){let{components:n,...t}=e;return(0,s.yg)(v$o,(0,p.A)({},A$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}L$o.isMDXComponent=!0;const b$o={toc:[]},N$o="wrapper";function k$o(e){let{components:n,...t}=e;return(0,s.yg)(N$o,(0,p.A)({},b$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}k$o.isMDXComponent=!0;const z$o={toc:[]},P$o="wrapper";function I$o(e){let{components:n,...t}=e;return(0,s.yg)(P$o,(0,p.A)({},z$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}I$o.isMDXComponent=!0;const R$o={toc:[]},W$o="wrapper";function S$o(e){let{components:n,...t}=e;return(0,s.yg)(W$o,(0,p.A)({},R$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}S$o.isMDXComponent=!0;const B$o={toc:[]},G$o="wrapper";function E$o(e){let{components:n,...t}=e;return(0,s.yg)(G$o,(0,p.A)({},B$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}E$o.isMDXComponent=!0;const O$o={toc:[]},U$o="wrapper";function F$o(e){let{components:n,...t}=e;return(0,s.yg)(U$o,(0,p.A)({},O$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}F$o.isMDXComponent=!0;const V$o={toc:[]},q$o="wrapper";function j$o(e){let{components:n,...t}=e;return(0,s.yg)(q$o,(0,p.A)({},V$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}j$o.isMDXComponent=!0;const H$o={toc:[]},Y$o="wrapper";function Q$o(e){let{components:n,...t}=e;return(0,s.yg)(Y$o,(0,p.A)({},H$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Q$o.isMDXComponent=!0;const $$o={toc:[]},K$o="wrapper";function J$o(e){let{components:n,...t}=e;return(0,s.yg)(K$o,(0,p.A)({},$$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}J$o.isMDXComponent=!0;const Z$o={toc:[]},eKo="wrapper";function nKo(e){let{components:n,...t}=e;return(0,s.yg)(eKo,(0,p.A)({},Z$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}nKo.isMDXComponent=!0;const tKo={toc:[]},oKo="wrapper";function pKo(e){let{components:n,...t}=e;return(0,s.yg)(oKo,(0,p.A)({},tKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}pKo.isMDXComponent=!0;const rKo={toc:[]},sKo="wrapper";function cKo(e){let{components:n,...t}=e;return(0,s.yg)(sKo,(0,p.A)({},rKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cKo.isMDXComponent=!0;const aKo={toc:[]},iKo="wrapper";function lKo(e){let{components:n,...t}=e;return(0,s.yg)(iKo,(0,p.A)({},aKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}lKo.isMDXComponent=!0;const uKo={toc:[]},mKo="wrapper";function yKo(e){let{components:n,...t}=e;return(0,s.yg)(mKo,(0,p.A)({},uKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}yKo.isMDXComponent=!0;const dKo={toc:[]},hKo="wrapper";function gKo(e){let{components:n,...t}=e;return(0,s.yg)(hKo,(0,p.A)({},dKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}gKo.isMDXComponent=!0;const fKo={toc:[]},DKo="wrapper";function MKo(e){let{components:n,...t}=e;return(0,s.yg)(DKo,(0,p.A)({},fKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}MKo.isMDXComponent=!0;const XKo={toc:[]},_Ko="wrapper";function wKo(e){let{components:n,...t}=e;return(0,s.yg)(_Ko,(0,p.A)({},XKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}wKo.isMDXComponent=!0;const TKo={toc:[]},CKo="wrapper";function xKo(e){let{components:n,...t}=e;return(0,s.yg)(CKo,(0,p.A)({},TKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}xKo.isMDXComponent=!0;const AKo={toc:[]},vKo="wrapper";function LKo(e){let{components:n,...t}=e;return(0,s.yg)(vKo,(0,p.A)({},AKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}LKo.isMDXComponent=!0;const bKo={toc:[]},NKo="wrapper";function kKo(e){let{components:n,...t}=e;return(0,s.yg)(NKo,(0,p.A)({},bKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}kKo.isMDXComponent=!0;const zKo={toc:[]},PKo="wrapper";function IKo(e){let{components:n,...t}=e;return(0,s.yg)(PKo,(0,p.A)({},zKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}IKo.isMDXComponent=!0;const RKo={toc:[]},WKo="wrapper";function SKo(e){let{components:n,...t}=e;return(0,s.yg)(WKo,(0,p.A)({},RKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}SKo.isMDXComponent=!0;const BKo={toc:[]},GKo="wrapper";function EKo(e){let{components:n,...t}=e;return(0,s.yg)(GKo,(0,p.A)({},BKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}EKo.isMDXComponent=!0;const OKo={toc:[]},UKo="wrapper";function FKo(e){let{components:n,...t}=e;return(0,s.yg)(UKo,(0,p.A)({},OKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}FKo.isMDXComponent=!0;const VKo={toc:[]},qKo="wrapper";function jKo(e){let{components:n,...t}=e;return(0,s.yg)(qKo,(0,p.A)({},VKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}jKo.isMDXComponent=!0;const HKo={toc:[]},YKo="wrapper";function QKo(e){let{components:n,...t}=e;return(0,s.yg)(YKo,(0,p.A)({},HKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}QKo.isMDXComponent=!0;const $Ko={toc:[]},KKo="wrapper";function JKo(e){let{components:n,...t}=e;return(0,s.yg)(KKo,(0,p.A)({},$Ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}JKo.isMDXComponent=!0;const ZKo={toc:[]},eJo="wrapper";function nJo(e){let{components:n,...t}=e;return(0,s.yg)(eJo,(0,p.A)({},ZKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}nJo.isMDXComponent=!0;const tJo={toc:[]},oJo="wrapper";function pJo(e){let{components:n,...t}=e;return(0,s.yg)(oJo,(0,p.A)({},tJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}pJo.isMDXComponent=!0;const rJo={toc:[]},sJo="wrapper";function cJo(e){let{components:n,...t}=e;return(0,s.yg)(sJo,(0,p.A)({},rJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}cJo.isMDXComponent=!0;const aJo={toc:[]},iJo="wrapper";function lJo(e){let{components:n,...t}=e;return(0,s.yg)(iJo,(0,p.A)({},aJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}lJo.isMDXComponent=!0;const uJo={toc:[]},mJo="wrapper";function yJo(e){let{components:n,...t}=e;return(0,s.yg)(mJo,(0,p.A)({},uJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}yJo.isMDXComponent=!0;const dJo={toc:[]},hJo="wrapper";function gJo(e){let{components:n,...t}=e;return(0,s.yg)(hJo,(0,p.A)({},dJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}gJo.isMDXComponent=!0;const fJo={toc:[]},DJo="wrapper";function MJo(e){let{components:n,...t}=e;return(0,s.yg)(DJo,(0,p.A)({},fJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}MJo.isMDXComponent=!0;const XJo={toc:[]},_Jo="wrapper";function wJo(e){let{components:n,...t}=e;return(0,s.yg)(_Jo,(0,p.A)({},XJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}wJo.isMDXComponent=!0;const TJo={toc:[]},CJo="wrapper";function xJo(e){let{components:n,...t}=e;return(0,s.yg)(CJo,(0,p.A)({},TJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xJo.isMDXComponent=!0;const AJo={toc:[]},vJo="wrapper";function LJo(e){let{components:n,...t}=e;return(0,s.yg)(vJo,(0,p.A)({},AJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}LJo.isMDXComponent=!0;const bJo={toc:[]},NJo="wrapper";function kJo(e){let{components:n,...t}=e;return(0,s.yg)(NJo,(0,p.A)({},bJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}kJo.isMDXComponent=!0;const zJo={toc:[]},PJo="wrapper";function IJo(e){let{components:n,...t}=e;return(0,s.yg)(PJo,(0,p.A)({},zJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}IJo.isMDXComponent=!0;const RJo={toc:[]},WJo="wrapper";function SJo(e){let{components:n,...t}=e;return(0,s.yg)(WJo,(0,p.A)({},RJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}SJo.isMDXComponent=!0;const BJo={toc:[]},GJo="wrapper";function EJo(e){let{components:n,...t}=e;return(0,s.yg)(GJo,(0,p.A)({},BJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}EJo.isMDXComponent=!0;const OJo={toc:[]},UJo="wrapper";function FJo(e){let{components:n,...t}=e;return(0,s.yg)(UJo,(0,p.A)({},OJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}FJo.isMDXComponent=!0;const VJo={toc:[]},qJo="wrapper";function jJo(e){let{components:n,...t}=e;return(0,s.yg)(qJo,(0,p.A)({},VJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jJo.isMDXComponent=!0;const HJo={toc:[]},YJo="wrapper";function QJo(e){let{components:n,...t}=e;return(0,s.yg)(YJo,(0,p.A)({},HJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QJo.isMDXComponent=!0;const $Jo={toc:[]},KJo="wrapper";function JJo(e){let{components:n,...t}=e;return(0,s.yg)(KJo,(0,p.A)({},$Jo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}JJo.isMDXComponent=!0;const ZJo={toc:[]},eZo="wrapper";function nZo(e){let{components:n,...t}=e;return(0,s.yg)(eZo,(0,p.A)({},ZJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}nZo.isMDXComponent=!0;const tZo={toc:[]},oZo="wrapper";function pZo(e){let{components:n,...t}=e;return(0,s.yg)(oZo,(0,p.A)({},tZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}pZo.isMDXComponent=!0;const rZo={toc:[]},sZo="wrapper";function cZo(e){let{components:n,...t}=e;return(0,s.yg)(sZo,(0,p.A)({},rZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}cZo.isMDXComponent=!0;const aZo={toc:[]},iZo="wrapper";function lZo(e){let{components:n,...t}=e;return(0,s.yg)(iZo,(0,p.A)({},aZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lZo.isMDXComponent=!0;const uZo={toc:[]},mZo="wrapper";function yZo(e){let{components:n,...t}=e;return(0,s.yg)(mZo,(0,p.A)({},uZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yZo.isMDXComponent=!0;const dZo={toc:[]},hZo="wrapper";function gZo(e){let{components:n,...t}=e;return(0,s.yg)(hZo,(0,p.A)({},dZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gZo.isMDXComponent=!0;const fZo={toc:[]},DZo="wrapper";function MZo(e){let{components:n,...t}=e;return(0,s.yg)(DZo,(0,p.A)({},fZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}MZo.isMDXComponent=!0;const XZo={toc:[]},_Zo="wrapper";function wZo(e){let{components:n,...t}=e;return(0,s.yg)(_Zo,(0,p.A)({},XZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wZo.isMDXComponent=!0;const TZo={toc:[]},CZo="wrapper";function xZo(e){let{components:n,...t}=e;return(0,s.yg)(CZo,(0,p.A)({},TZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xZo.isMDXComponent=!0;const AZo={toc:[]},vZo="wrapper";function LZo(e){let{components:n,...t}=e;return(0,s.yg)(vZo,(0,p.A)({},AZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LZo.isMDXComponent=!0;const bZo={toc:[]},NZo="wrapper";function kZo(e){let{components:n,...t}=e;return(0,s.yg)(NZo,(0,p.A)({},bZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}kZo.isMDXComponent=!0;const zZo={toc:[]},PZo="wrapper";function IZo(e){let{components:n,...t}=e;return(0,s.yg)(PZo,(0,p.A)({},zZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}IZo.isMDXComponent=!0;const RZo={toc:[]},WZo="wrapper";function SZo(e){let{components:n,...t}=e;return(0,s.yg)(WZo,(0,p.A)({},RZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}SZo.isMDXComponent=!0;const BZo={toc:[]},GZo="wrapper";function EZo(e){let{components:n,...t}=e;return(0,s.yg)(GZo,(0,p.A)({},BZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}EZo.isMDXComponent=!0;const OZo={toc:[]},UZo="wrapper";function FZo(e){let{components:n,...t}=e;return(0,s.yg)(UZo,(0,p.A)({},OZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}FZo.isMDXComponent=!0;const VZo={toc:[]},qZo="wrapper";function jZo(e){let{components:n,...t}=e;return(0,s.yg)(qZo,(0,p.A)({},VZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jZo.isMDXComponent=!0;const HZo={toc:[]},YZo="wrapper";function QZo(e){let{components:n,...t}=e;return(0,s.yg)(YZo,(0,p.A)({},HZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}QZo.isMDXComponent=!0;const $Zo={toc:[]},KZo="wrapper";function JZo(e){let{components:n,...t}=e;return(0,s.yg)(KZo,(0,p.A)({},$Zo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JZo.isMDXComponent=!0;const ZZo={toc:[]},e0o="wrapper";function n0o(e){let{components:n,...t}=e;return(0,s.yg)(e0o,(0,p.A)({},ZZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}n0o.isMDXComponent=!0;const t0o={toc:[]},o0o="wrapper";function p0o(e){let{components:n,...t}=e;return(0,s.yg)(o0o,(0,p.A)({},t0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}p0o.isMDXComponent=!0;const r0o={toc:[]},s0o="wrapper";function c0o(e){let{components:n,...t}=e;return(0,s.yg)(s0o,(0,p.A)({},r0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}c0o.isMDXComponent=!0;const a0o={toc:[]},i0o="wrapper";function l0o(e){let{components:n,...t}=e;return(0,s.yg)(i0o,(0,p.A)({},a0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}l0o.isMDXComponent=!0;const u0o={toc:[]},m0o="wrapper";function y0o(e){let{components:n,...t}=e;return(0,s.yg)(m0o,(0,p.A)({},u0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}y0o.isMDXComponent=!0;const d0o={toc:[]},h0o="wrapper";function g0o(e){let{components:n,...t}=e;return(0,s.yg)(h0o,(0,p.A)({},d0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}g0o.isMDXComponent=!0;const f0o={toc:[]},D0o="wrapper";function M0o(e){let{components:n,...t}=e;return(0,s.yg)(D0o,(0,p.A)({},f0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}M0o.isMDXComponent=!0;const X0o={toc:[]},_0o="wrapper";function w0o(e){let{components:n,...t}=e;return(0,s.yg)(_0o,(0,p.A)({},X0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}w0o.isMDXComponent=!0;const T0o={toc:[]},C0o="wrapper";function x0o(e){let{components:n,...t}=e;return(0,s.yg)(C0o,(0,p.A)({},T0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}x0o.isMDXComponent=!0;const A0o={toc:[]},v0o="wrapper";function L0o(e){let{components:n,...t}=e;return(0,s.yg)(v0o,(0,p.A)({},A0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}L0o.isMDXComponent=!0;const b0o={toc:[]},N0o="wrapper";function k0o(e){let{components:n,...t}=e;return(0,s.yg)(N0o,(0,p.A)({},b0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}k0o.isMDXComponent=!0;const z0o={toc:[]},P0o="wrapper";function I0o(e){let{components:n,...t}=e;return(0,s.yg)(P0o,(0,p.A)({},z0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}I0o.isMDXComponent=!0;const R0o={toc:[]},W0o="wrapper";function S0o(e){let{components:n,...t}=e;return(0,s.yg)(W0o,(0,p.A)({},R0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}S0o.isMDXComponent=!0;const B0o={toc:[]},G0o="wrapper";function E0o(e){let{components:n,...t}=e;return(0,s.yg)(G0o,(0,p.A)({},B0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}E0o.isMDXComponent=!0;const O0o={toc:[]},U0o="wrapper";function F0o(e){let{components:n,...t}=e;return(0,s.yg)(U0o,(0,p.A)({},O0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}F0o.isMDXComponent=!0;const V0o={toc:[]},q0o="wrapper";function j0o(e){let{components:n,...t}=e;return(0,s.yg)(q0o,(0,p.A)({},V0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}j0o.isMDXComponent=!0;const H0o={toc:[]},Y0o="wrapper";function Q0o(e){let{components:n,...t}=e;return(0,s.yg)(Y0o,(0,p.A)({},H0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Q0o.isMDXComponent=!0;const $0o={toc:[]},K0o="wrapper";function J0o(e){let{components:n,...t}=e;return(0,s.yg)(K0o,(0,p.A)({},$0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}J0o.isMDXComponent=!0;const Z0o={toc:[]},e8o="wrapper";function n8o(e){let{components:n,...t}=e;return(0,s.yg)(e8o,(0,p.A)({},Z0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}n8o.isMDXComponent=!0;const t8o={toc:[]},o8o="wrapper";function p8o(e){let{components:n,...t}=e;return(0,s.yg)(o8o,(0,p.A)({},t8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}p8o.isMDXComponent=!0;const r8o={toc:[]},s8o="wrapper";function c8o(e){let{components:n,...t}=e;return(0,s.yg)(s8o,(0,p.A)({},r8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}c8o.isMDXComponent=!0;const a8o={toc:[]},i8o="wrapper";function l8o(e){let{components:n,...t}=e;return(0,s.yg)(i8o,(0,p.A)({},a8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}l8o.isMDXComponent=!0;const u8o={toc:[]},m8o="wrapper";function y8o(e){let{components:n,...t}=e;return(0,s.yg)(m8o,(0,p.A)({},u8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}y8o.isMDXComponent=!0;const d8o={toc:[]},h8o="wrapper";function g8o(e){let{components:n,...t}=e;return(0,s.yg)(h8o,(0,p.A)({},d8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}g8o.isMDXComponent=!0;const f8o={toc:[]},D8o="wrapper";function M8o(e){let{components:n,...t}=e;return(0,s.yg)(D8o,(0,p.A)({},f8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}M8o.isMDXComponent=!0;const X8o={toc:[]},_8o="wrapper";function w8o(e){let{components:n,...t}=e;return(0,s.yg)(_8o,(0,p.A)({},X8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}w8o.isMDXComponent=!0;const T8o={toc:[]},C8o="wrapper";function x8o(e){let{components:n,...t}=e;return(0,s.yg)(C8o,(0,p.A)({},T8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}x8o.isMDXComponent=!0;const A8o={toc:[]},v8o="wrapper";function L8o(e){let{components:n,...t}=e;return(0,s.yg)(v8o,(0,p.A)({},A8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}L8o.isMDXComponent=!0;const b8o={toc:[]},N8o="wrapper";function k8o(e){let{components:n,...t}=e;return(0,s.yg)(N8o,(0,p.A)({},b8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}k8o.isMDXComponent=!0;const z8o={toc:[]},P8o="wrapper";function I8o(e){let{components:n,...t}=e;return(0,s.yg)(P8o,(0,p.A)({},z8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}I8o.isMDXComponent=!0;const R8o={toc:[]},W8o="wrapper";function S8o(e){let{components:n,...t}=e;return(0,s.yg)(W8o,(0,p.A)({},R8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}S8o.isMDXComponent=!0;const B8o={toc:[]},G8o="wrapper";function E8o(e){let{components:n,...t}=e;return(0,s.yg)(G8o,(0,p.A)({},B8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}E8o.isMDXComponent=!0;const O8o={toc:[]},U8o="wrapper";function F8o(e){let{components:n,...t}=e;return(0,s.yg)(U8o,(0,p.A)({},O8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}F8o.isMDXComponent=!0;const V8o={toc:[]},q8o="wrapper";function j8o(e){let{components:n,...t}=e;return(0,s.yg)(q8o,(0,p.A)({},V8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}j8o.isMDXComponent=!0;const H8o={toc:[]},Y8o="wrapper";function Q8o(e){let{components:n,...t}=e;return(0,s.yg)(Y8o,(0,p.A)({},H8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Q8o.isMDXComponent=!0;const $8o={toc:[]},K8o="wrapper";function J8o(e){let{components:n,...t}=e;return(0,s.yg)(K8o,(0,p.A)({},$8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}J8o.isMDXComponent=!0;const Z8o={toc:[]},e2o="wrapper";function n2o(e){let{components:n,...t}=e;return(0,s.yg)(e2o,(0,p.A)({},Z8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}n2o.isMDXComponent=!0;const t2o={toc:[]},o2o="wrapper";function p2o(e){let{components:n,...t}=e;return(0,s.yg)(o2o,(0,p.A)({},t2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}p2o.isMDXComponent=!0;const r2o={toc:[]},s2o="wrapper";function c2o(e){let{components:n,...t}=e;return(0,s.yg)(s2o,(0,p.A)({},r2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}c2o.isMDXComponent=!0;const a2o={toc:[]},i2o="wrapper";function l2o(e){let{components:n,...t}=e;return(0,s.yg)(i2o,(0,p.A)({},a2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}l2o.isMDXComponent=!0;const u2o={toc:[]},m2o="wrapper";function y2o(e){let{components:n,...t}=e;return(0,s.yg)(m2o,(0,p.A)({},u2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}y2o.isMDXComponent=!0;const d2o={toc:[]},h2o="wrapper";function g2o(e){let{components:n,...t}=e;return(0,s.yg)(h2o,(0,p.A)({},d2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}g2o.isMDXComponent=!0;const f2o={toc:[]},D2o="wrapper";function M2o(e){let{components:n,...t}=e;return(0,s.yg)(D2o,(0,p.A)({},f2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}M2o.isMDXComponent=!0;const X2o={toc:[]},_2o="wrapper";function w2o(e){let{components:n,...t}=e;return(0,s.yg)(_2o,(0,p.A)({},X2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}w2o.isMDXComponent=!0;const T2o={toc:[]},C2o="wrapper";function x2o(e){let{components:n,...t}=e;return(0,s.yg)(C2o,(0,p.A)({},T2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}x2o.isMDXComponent=!0;const A2o={toc:[]},v2o="wrapper";function L2o(e){let{components:n,...t}=e;return(0,s.yg)(v2o,(0,p.A)({},A2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}L2o.isMDXComponent=!0;const b2o={toc:[]},N2o="wrapper";function k2o(e){let{components:n,...t}=e;return(0,s.yg)(N2o,(0,p.A)({},b2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}k2o.isMDXComponent=!0;const z2o={toc:[]},P2o="wrapper";function I2o(e){let{components:n,...t}=e;return(0,s.yg)(P2o,(0,p.A)({},z2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}I2o.isMDXComponent=!0;const R2o={toc:[]},W2o="wrapper";function S2o(e){let{components:n,...t}=e;return(0,s.yg)(W2o,(0,p.A)({},R2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}S2o.isMDXComponent=!0;const B2o={toc:[]},G2o="wrapper";function E2o(e){let{components:n,...t}=e;return(0,s.yg)(G2o,(0,p.A)({},B2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}E2o.isMDXComponent=!0;const O2o={toc:[]},U2o="wrapper";function F2o(e){let{components:n,...t}=e;return(0,s.yg)(U2o,(0,p.A)({},O2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}F2o.isMDXComponent=!0;const V2o={toc:[]},q2o="wrapper";function j2o(e){let{components:n,...t}=e;return(0,s.yg)(q2o,(0,p.A)({},V2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}j2o.isMDXComponent=!0;const H2o={toc:[]},Y2o="wrapper";function Q2o(e){let{components:n,...t}=e;return(0,s.yg)(Y2o,(0,p.A)({},H2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Q2o.isMDXComponent=!0;const $2o={toc:[]},K2o="wrapper";function J2o(e){let{components:n,...t}=e;return(0,s.yg)(K2o,(0,p.A)({},$2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}J2o.isMDXComponent=!0;const Z2o={toc:[]},e3o="wrapper";function n3o(e){let{components:n,...t}=e;return(0,s.yg)(e3o,(0,p.A)({},Z2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}n3o.isMDXComponent=!0;const t3o={toc:[]},o3o="wrapper";function p3o(e){let{components:n,...t}=e;return(0,s.yg)(o3o,(0,p.A)({},t3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}p3o.isMDXComponent=!0;const r3o={toc:[]},s3o="wrapper";function c3o(e){let{components:n,...t}=e;return(0,s.yg)(s3o,(0,p.A)({},r3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}c3o.isMDXComponent=!0;const a3o={toc:[]},i3o="wrapper";function l3o(e){let{components:n,...t}=e;return(0,s.yg)(i3o,(0,p.A)({},a3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}l3o.isMDXComponent=!0;const u3o={toc:[]},m3o="wrapper";function y3o(e){let{components:n,...t}=e;return(0,s.yg)(m3o,(0,p.A)({},u3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}y3o.isMDXComponent=!0;const d3o={toc:[]},h3o="wrapper";function g3o(e){let{components:n,...t}=e;return(0,s.yg)(h3o,(0,p.A)({},d3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}g3o.isMDXComponent=!0;const f3o={toc:[]},D3o="wrapper";function M3o(e){let{components:n,...t}=e;return(0,s.yg)(D3o,(0,p.A)({},f3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}M3o.isMDXComponent=!0;const X3o={toc:[]},_3o="wrapper";function w3o(e){let{components:n,...t}=e;return(0,s.yg)(_3o,(0,p.A)({},X3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}w3o.isMDXComponent=!0;const T3o={toc:[]},C3o="wrapper";function x3o(e){let{components:n,...t}=e;return(0,s.yg)(C3o,(0,p.A)({},T3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}x3o.isMDXComponent=!0;const A3o={toc:[]},v3o="wrapper";function L3o(e){let{components:n,...t}=e;return(0,s.yg)(v3o,(0,p.A)({},A3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}L3o.isMDXComponent=!0;const b3o={toc:[]},N3o="wrapper";function k3o(e){let{components:n,...t}=e;return(0,s.yg)(N3o,(0,p.A)({},b3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}k3o.isMDXComponent=!0;const z3o={toc:[]},P3o="wrapper";function I3o(e){let{components:n,...t}=e;return(0,s.yg)(P3o,(0,p.A)({},z3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}I3o.isMDXComponent=!0;const R3o={toc:[]},W3o="wrapper";function S3o(e){let{components:n,...t}=e;return(0,s.yg)(W3o,(0,p.A)({},R3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}S3o.isMDXComponent=!0;const B3o={toc:[]},G3o="wrapper";function E3o(e){let{components:n,...t}=e;return(0,s.yg)(G3o,(0,p.A)({},B3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}E3o.isMDXComponent=!0;const O3o={toc:[]},U3o="wrapper";function F3o(e){let{components:n,...t}=e;return(0,s.yg)(U3o,(0,p.A)({},O3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}F3o.isMDXComponent=!0;const V3o={toc:[]},q3o="wrapper";function j3o(e){let{components:n,...t}=e;return(0,s.yg)(q3o,(0,p.A)({},V3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}j3o.isMDXComponent=!0;const H3o={toc:[]},Y3o="wrapper";function Q3o(e){let{components:n,...t}=e;return(0,s.yg)(Y3o,(0,p.A)({},H3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Q3o.isMDXComponent=!0;const $3o={toc:[]},K3o="wrapper";function J3o(e){let{components:n,...t}=e;return(0,s.yg)(K3o,(0,p.A)({},$3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}J3o.isMDXComponent=!0;const Z3o={toc:[]},e1o="wrapper";function n1o(e){let{components:n,...t}=e;return(0,s.yg)(e1o,(0,p.A)({},Z3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}n1o.isMDXComponent=!0;const t1o={toc:[]},o1o="wrapper";function p1o(e){let{components:n,...t}=e;return(0,s.yg)(o1o,(0,p.A)({},t1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}p1o.isMDXComponent=!0;const r1o={toc:[]},s1o="wrapper";function c1o(e){let{components:n,...t}=e;return(0,s.yg)(s1o,(0,p.A)({},r1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}c1o.isMDXComponent=!0;const a1o={toc:[]},i1o="wrapper";function l1o(e){let{components:n,...t}=e;return(0,s.yg)(i1o,(0,p.A)({},a1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}l1o.isMDXComponent=!0;const u1o={toc:[]},m1o="wrapper";function y1o(e){let{components:n,...t}=e;return(0,s.yg)(m1o,(0,p.A)({},u1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}y1o.isMDXComponent=!0;const d1o={toc:[]},h1o="wrapper";function g1o(e){let{components:n,...t}=e;return(0,s.yg)(h1o,(0,p.A)({},d1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}g1o.isMDXComponent=!0;const f1o={toc:[]},D1o="wrapper";function M1o(e){let{components:n,...t}=e;return(0,s.yg)(D1o,(0,p.A)({},f1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}M1o.isMDXComponent=!0;const X1o={toc:[]},_1o="wrapper";function w1o(e){let{components:n,...t}=e;return(0,s.yg)(_1o,(0,p.A)({},X1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}w1o.isMDXComponent=!0;const T1o={toc:[]},C1o="wrapper";function x1o(e){let{components:n,...t}=e;return(0,s.yg)(C1o,(0,p.A)({},T1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}x1o.isMDXComponent=!0;const A1o={toc:[]},v1o="wrapper";function L1o(e){let{components:n,...t}=e;return(0,s.yg)(v1o,(0,p.A)({},A1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}L1o.isMDXComponent=!0;const b1o={toc:[]},N1o="wrapper";function k1o(e){let{components:n,...t}=e;return(0,s.yg)(N1o,(0,p.A)({},b1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}k1o.isMDXComponent=!0;const z1o={toc:[]},P1o="wrapper";function I1o(e){let{components:n,...t}=e;return(0,s.yg)(P1o,(0,p.A)({},z1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}I1o.isMDXComponent=!0;const R1o={toc:[]},W1o="wrapper";function S1o(e){let{components:n,...t}=e;return(0,s.yg)(W1o,(0,p.A)({},R1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}S1o.isMDXComponent=!0;const B1o={toc:[]},G1o="wrapper";function E1o(e){let{components:n,...t}=e;return(0,s.yg)(G1o,(0,p.A)({},B1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}E1o.isMDXComponent=!0;const O1o={toc:[]},U1o="wrapper";function F1o(e){let{components:n,...t}=e;return(0,s.yg)(U1o,(0,p.A)({},O1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}F1o.isMDXComponent=!0;const V1o={toc:[]},q1o="wrapper";function j1o(e){let{components:n,...t}=e;return(0,s.yg)(q1o,(0,p.A)({},V1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}j1o.isMDXComponent=!0;const H1o={toc:[]},Y1o="wrapper";function Q1o(e){let{components:n,...t}=e;return(0,s.yg)(Y1o,(0,p.A)({},H1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Q1o.isMDXComponent=!0;const $1o={toc:[]},K1o="wrapper";function J1o(e){let{components:n,...t}=e;return(0,s.yg)(K1o,(0,p.A)({},$1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}J1o.isMDXComponent=!0;const Z1o={toc:[]},e4o="wrapper";function n4o(e){let{components:n,...t}=e;return(0,s.yg)(e4o,(0,p.A)({},Z1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}n4o.isMDXComponent=!0;const t4o={toc:[]},o4o="wrapper";function p4o(e){let{components:n,...t}=e;return(0,s.yg)(o4o,(0,p.A)({},t4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}p4o.isMDXComponent=!0;const r4o={toc:[]},s4o="wrapper";function c4o(e){let{components:n,...t}=e;return(0,s.yg)(s4o,(0,p.A)({},r4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}c4o.isMDXComponent=!0;const a4o={toc:[]},i4o="wrapper";function l4o(e){let{components:n,...t}=e;return(0,s.yg)(i4o,(0,p.A)({},a4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}l4o.isMDXComponent=!0;const u4o={toc:[]},m4o="wrapper";function y4o(e){let{components:n,...t}=e;return(0,s.yg)(m4o,(0,p.A)({},u4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}y4o.isMDXComponent=!0;const d4o={toc:[]},h4o="wrapper";function g4o(e){let{components:n,...t}=e;return(0,s.yg)(h4o,(0,p.A)({},d4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}g4o.isMDXComponent=!0;const f4o={toc:[]},D4o="wrapper";function M4o(e){let{components:n,...t}=e;return(0,s.yg)(D4o,(0,p.A)({},f4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}M4o.isMDXComponent=!0;const X4o={toc:[]},_4o="wrapper";function w4o(e){let{components:n,...t}=e;return(0,s.yg)(_4o,(0,p.A)({},X4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}w4o.isMDXComponent=!0;const T4o={toc:[]},C4o="wrapper";function x4o(e){let{components:n,...t}=e;return(0,s.yg)(C4o,(0,p.A)({},T4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}x4o.isMDXComponent=!0;const A4o={toc:[]},v4o="wrapper";function L4o(e){let{components:n,...t}=e;return(0,s.yg)(v4o,(0,p.A)({},A4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}L4o.isMDXComponent=!0;const b4o={toc:[]},N4o="wrapper";function k4o(e){let{components:n,...t}=e;return(0,s.yg)(N4o,(0,p.A)({},b4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}k4o.isMDXComponent=!0;const z4o={toc:[]},P4o="wrapper";function I4o(e){let{components:n,...t}=e;return(0,s.yg)(P4o,(0,p.A)({},z4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}I4o.isMDXComponent=!0;const R4o={toc:[]},W4o="wrapper";function S4o(e){let{components:n,...t}=e;return(0,s.yg)(W4o,(0,p.A)({},R4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}S4o.isMDXComponent=!0;const B4o={toc:[]},G4o="wrapper";function E4o(e){let{components:n,...t}=e;return(0,s.yg)(G4o,(0,p.A)({},B4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}E4o.isMDXComponent=!0;const O4o={toc:[]},U4o="wrapper";function F4o(e){let{components:n,...t}=e;return(0,s.yg)(U4o,(0,p.A)({},O4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}F4o.isMDXComponent=!0;const V4o={toc:[]},q4o="wrapper";function j4o(e){let{components:n,...t}=e;return(0,s.yg)(q4o,(0,p.A)({},V4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}j4o.isMDXComponent=!0;const H4o={toc:[]},Y4o="wrapper";function Q4o(e){let{components:n,...t}=e;return(0,s.yg)(Y4o,(0,p.A)({},H4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Q4o.isMDXComponent=!0;const $4o={toc:[]},K4o="wrapper";function J4o(e){let{components:n,...t}=e;return(0,s.yg)(K4o,(0,p.A)({},$4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}J4o.isMDXComponent=!0;const Z4o={toc:[]},e6o="wrapper";function n6o(e){let{components:n,...t}=e;return(0,s.yg)(e6o,(0,p.A)({},Z4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}n6o.isMDXComponent=!0;const t6o={toc:[]},o6o="wrapper";function p6o(e){let{components:n,...t}=e;return(0,s.yg)(o6o,(0,p.A)({},t6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}p6o.isMDXComponent=!0;const r6o={toc:[]},s6o="wrapper";function c6o(e){let{components:n,...t}=e;return(0,s.yg)(s6o,(0,p.A)({},r6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}c6o.isMDXComponent=!0;const a6o={toc:[]},i6o="wrapper";function l6o(e){let{components:n,...t}=e;return(0,s.yg)(i6o,(0,p.A)({},a6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}l6o.isMDXComponent=!0;const u6o={toc:[]},m6o="wrapper";function y6o(e){let{components:n,...t}=e;return(0,s.yg)(m6o,(0,p.A)({},u6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}y6o.isMDXComponent=!0;const d6o={toc:[]},h6o="wrapper";function g6o(e){let{components:n,...t}=e;return(0,s.yg)(h6o,(0,p.A)({},d6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}g6o.isMDXComponent=!0;const f6o={toc:[]},D6o="wrapper";function M6o(e){let{components:n,...t}=e;return(0,s.yg)(D6o,(0,p.A)({},f6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}M6o.isMDXComponent=!0;const X6o={toc:[]},_6o="wrapper";function w6o(e){let{components:n,...t}=e;return(0,s.yg)(_6o,(0,p.A)({},X6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}w6o.isMDXComponent=!0;const T6o={toc:[]},C6o="wrapper";function x6o(e){let{components:n,...t}=e;return(0,s.yg)(C6o,(0,p.A)({},T6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}x6o.isMDXComponent=!0;const A6o={toc:[]},v6o="wrapper";function L6o(e){let{components:n,...t}=e;return(0,s.yg)(v6o,(0,p.A)({},A6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}L6o.isMDXComponent=!0;const b6o={toc:[]},N6o="wrapper";function k6o(e){let{components:n,...t}=e;return(0,s.yg)(N6o,(0,p.A)({},b6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}k6o.isMDXComponent=!0;const z6o={toc:[]},P6o="wrapper";function I6o(e){let{components:n,...t}=e;return(0,s.yg)(P6o,(0,p.A)({},z6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}I6o.isMDXComponent=!0;const R6o={toc:[]},W6o="wrapper";function S6o(e){let{components:n,...t}=e;return(0,s.yg)(W6o,(0,p.A)({},R6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}S6o.isMDXComponent=!0;const B6o={toc:[]},G6o="wrapper";function E6o(e){let{components:n,...t}=e;return(0,s.yg)(G6o,(0,p.A)({},B6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}E6o.isMDXComponent=!0;const O6o={toc:[]},U6o="wrapper";function F6o(e){let{components:n,...t}=e;return(0,s.yg)(U6o,(0,p.A)({},O6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}F6o.isMDXComponent=!0;const V6o={toc:[]},q6o="wrapper";function j6o(e){let{components:n,...t}=e;return(0,s.yg)(q6o,(0,p.A)({},V6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}j6o.isMDXComponent=!0;const H6o={toc:[]},Y6o="wrapper";function Q6o(e){let{components:n,...t}=e;return(0,s.yg)(Y6o,(0,p.A)({},H6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Q6o.isMDXComponent=!0;const $6o={toc:[]},K6o="wrapper";function J6o(e){let{components:n,...t}=e;return(0,s.yg)(K6o,(0,p.A)({},$6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}J6o.isMDXComponent=!0;const Z6o={toc:[]},e5o="wrapper";function n5o(e){let{components:n,...t}=e;return(0,s.yg)(e5o,(0,p.A)({},Z6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}n5o.isMDXComponent=!0;const t5o={toc:[]},o5o="wrapper";function p5o(e){let{components:n,...t}=e;return(0,s.yg)(o5o,(0,p.A)({},t5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}p5o.isMDXComponent=!0;const r5o={toc:[]},s5o="wrapper";function c5o(e){let{components:n,...t}=e;return(0,s.yg)(s5o,(0,p.A)({},r5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}c5o.isMDXComponent=!0;const a5o={toc:[]},i5o="wrapper";function l5o(e){let{components:n,...t}=e;return(0,s.yg)(i5o,(0,p.A)({},a5o,t,{components:n,mdxType:"MDXLayout"}))}l5o.isMDXComponent=!0;const u5o={toc:[]},m5o="wrapper";function y5o(e){let{components:n,...t}=e;return(0,s.yg)(m5o,(0,p.A)({},u5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}y5o.isMDXComponent=!0;const d5o={toc:[]},h5o="wrapper";function g5o(e){let{components:n,...t}=e;return(0,s.yg)(h5o,(0,p.A)({},d5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}g5o.isMDXComponent=!0;const f5o={toc:[]},D5o="wrapper";function M5o(e){let{components:n,...t}=e;return(0,s.yg)(D5o,(0,p.A)({},f5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}M5o.isMDXComponent=!0;const X5o={toc:[]},_5o="wrapper";function w5o(e){let{components:n,...t}=e;return(0,s.yg)(_5o,(0,p.A)({},X5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}w5o.isMDXComponent=!0;const T5o={toc:[]},C5o="wrapper";function x5o(e){let{components:n,...t}=e;return(0,s.yg)(C5o,(0,p.A)({},T5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}x5o.isMDXComponent=!0;const A5o={toc:[]},v5o="wrapper";function L5o(e){let{components:n,...t}=e;return(0,s.yg)(v5o,(0,p.A)({},A5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}L5o.isMDXComponent=!0;const b5o={toc:[]},N5o="wrapper";function k5o(e){let{components:n,...t}=e;return(0,s.yg)(N5o,(0,p.A)({},b5o,t,{components:n,mdxType:"MDXLayout"}))}k5o.isMDXComponent=!0;const z5o={toc:[]},P5o="wrapper";function I5o(e){let{components:n,...t}=e;return(0,s.yg)(P5o,(0,p.A)({},z5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}I5o.isMDXComponent=!0;const R5o={toc:[]},W5o="wrapper";function S5o(e){let{components:n,...t}=e;return(0,s.yg)(W5o,(0,p.A)({},R5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}S5o.isMDXComponent=!0;const B5o={toc:[]},G5o="wrapper";function E5o(e){let{components:n,...t}=e;return(0,s.yg)(G5o,(0,p.A)({},B5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}E5o.isMDXComponent=!0;const O5o={toc:[]},U5o="wrapper";function F5o(e){let{components:n,...t}=e;return(0,s.yg)(U5o,(0,p.A)({},O5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}F5o.isMDXComponent=!0;const V5o={toc:[]},q5o="wrapper";function j5o(e){let{components:n,...t}=e;return(0,s.yg)(q5o,(0,p.A)({},V5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}j5o.isMDXComponent=!0;const H5o={toc:[]},Y5o="wrapper";function Q5o(e){let{components:n,...t}=e;return(0,s.yg)(Y5o,(0,p.A)({},H5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Q5o.isMDXComponent=!0;const $5o={toc:[]},K5o="wrapper";function J5o(e){let{components:n,...t}=e;return(0,s.yg)(K5o,(0,p.A)({},$5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}J5o.isMDXComponent=!0;const Z5o={toc:[]},e7o="wrapper";function n7o(e){let{components:n,...t}=e;return(0,s.yg)(e7o,(0,p.A)({},Z5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}n7o.isMDXComponent=!0;const t7o={toc:[]},o7o="wrapper";function p7o(e){let{components:n,...t}=e;return(0,s.yg)(o7o,(0,p.A)({},t7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}p7o.isMDXComponent=!0;const r7o={toc:[]},s7o="wrapper";function c7o(e){let{components:n,...t}=e;return(0,s.yg)(s7o,(0,p.A)({},r7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}c7o.isMDXComponent=!0;const a7o={toc:[]},i7o="wrapper";function l7o(e){let{components:n,...t}=e;return(0,s.yg)(i7o,(0,p.A)({},a7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}l7o.isMDXComponent=!0;const u7o={toc:[]},m7o="wrapper";function y7o(e){let{components:n,...t}=e;return(0,s.yg)(m7o,(0,p.A)({},u7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}y7o.isMDXComponent=!0;const d7o={toc:[]},h7o="wrapper";function g7o(e){let{components:n,...t}=e;return(0,s.yg)(h7o,(0,p.A)({},d7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}g7o.isMDXComponent=!0;const f7o={toc:[]},D7o="wrapper";function M7o(e){let{components:n,...t}=e;return(0,s.yg)(D7o,(0,p.A)({},f7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}M7o.isMDXComponent=!0;const X7o={toc:[]},_7o="wrapper";function w7o(e){let{components:n,...t}=e;return(0,s.yg)(_7o,(0,p.A)({},X7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}w7o.isMDXComponent=!0;const T7o={toc:[]},C7o="wrapper";function x7o(e){let{components:n,...t}=e;return(0,s.yg)(C7o,(0,p.A)({},T7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}x7o.isMDXComponent=!0;const A7o={toc:[]},v7o="wrapper";function L7o(e){let{components:n,...t}=e;return(0,s.yg)(v7o,(0,p.A)({},A7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}L7o.isMDXComponent=!0;const b7o={toc:[]},N7o="wrapper";function k7o(e){let{components:n,...t}=e;return(0,s.yg)(N7o,(0,p.A)({},b7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}k7o.isMDXComponent=!0;const z7o={toc:[]},P7o="wrapper";function I7o(e){let{components:n,...t}=e;return(0,s.yg)(P7o,(0,p.A)({},z7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}I7o.isMDXComponent=!0;const R7o={toc:[]},W7o="wrapper";function S7o(e){let{components:n,...t}=e;return(0,s.yg)(W7o,(0,p.A)({},R7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}S7o.isMDXComponent=!0;const B7o={toc:[]},G7o="wrapper";function E7o(e){let{components:n,...t}=e;return(0,s.yg)(G7o,(0,p.A)({},B7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}E7o.isMDXComponent=!0;const O7o={toc:[]},U7o="wrapper";function F7o(e){let{components:n,...t}=e;return(0,s.yg)(U7o,(0,p.A)({},O7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}F7o.isMDXComponent=!0;const V7o={toc:[]},q7o="wrapper";function j7o(e){let{components:n,...t}=e;return(0,s.yg)(q7o,(0,p.A)({},V7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}j7o.isMDXComponent=!0;const H7o={toc:[]},Y7o="wrapper";function Q7o(e){let{components:n,...t}=e;return(0,s.yg)(Y7o,(0,p.A)({},H7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Q7o.isMDXComponent=!0;const $7o={toc:[]},K7o="wrapper";function J7o(e){let{components:n,...t}=e;return(0,s.yg)(K7o,(0,p.A)({},$7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}J7o.isMDXComponent=!0;const Z7o={toc:[]},e9o="wrapper";function n9o(e){let{components:n,...t}=e;return(0,s.yg)(e9o,(0,p.A)({},Z7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}n9o.isMDXComponent=!0;const t9o={toc:[]},o9o="wrapper";function p9o(e){let{components:n,...t}=e;return(0,s.yg)(o9o,(0,p.A)({},t9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}p9o.isMDXComponent=!0;const r9o={toc:[]},s9o="wrapper";function c9o(e){let{components:n,...t}=e;return(0,s.yg)(s9o,(0,p.A)({},r9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}c9o.isMDXComponent=!0;const a9o={toc:[]},i9o="wrapper";function l9o(e){let{components:n,...t}=e;return(0,s.yg)(i9o,(0,p.A)({},a9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}l9o.isMDXComponent=!0;const u9o={toc:[]},m9o="wrapper";function y9o(e){let{components:n,...t}=e;return(0,s.yg)(m9o,(0,p.A)({},u9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}y9o.isMDXComponent=!0;const d9o={toc:[]},h9o="wrapper";function g9o(e){let{components:n,...t}=e;return(0,s.yg)(h9o,(0,p.A)({},d9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}g9o.isMDXComponent=!0;const f9o={toc:[]},D9o="wrapper";function M9o(e){let{components:n,...t}=e;return(0,s.yg)(D9o,(0,p.A)({},f9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}M9o.isMDXComponent=!0;const X9o={toc:[]},_9o="wrapper";function w9o(e){let{components:n,...t}=e;return(0,s.yg)(_9o,(0,p.A)({},X9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}w9o.isMDXComponent=!0;const T9o={toc:[]},C9o="wrapper";function x9o(e){let{components:n,...t}=e;return(0,s.yg)(C9o,(0,p.A)({},T9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}x9o.isMDXComponent=!0;const A9o={toc:[]},v9o="wrapper";function L9o(e){let{components:n,...t}=e;return(0,s.yg)(v9o,(0,p.A)({},A9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}L9o.isMDXComponent=!0;const b9o={toc:[]},N9o="wrapper";function k9o(e){let{components:n,...t}=e;return(0,s.yg)(N9o,(0,p.A)({},b9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}k9o.isMDXComponent=!0;const z9o={toc:[]},P9o="wrapper";function I9o(e){let{components:n,...t}=e;return(0,s.yg)(P9o,(0,p.A)({},z9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}I9o.isMDXComponent=!0;const R9o={toc:[]},W9o="wrapper";function S9o(e){let{components:n,...t}=e;return(0,s.yg)(W9o,(0,p.A)({},R9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}S9o.isMDXComponent=!0;const B9o={toc:[]},G9o="wrapper";function E9o(e){let{components:n,...t}=e;return(0,s.yg)(G9o,(0,p.A)({},B9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}E9o.isMDXComponent=!0;const O9o={toc:[]},U9o="wrapper";function F9o(e){let{components:n,...t}=e;return(0,s.yg)(U9o,(0,p.A)({},O9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}F9o.isMDXComponent=!0;const V9o={toc:[]},q9o="wrapper";function j9o(e){let{components:n,...t}=e;return(0,s.yg)(q9o,(0,p.A)({},V9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}j9o.isMDXComponent=!0;const H9o={toc:[]},Y9o="wrapper";function Q9o(e){let{components:n,...t}=e;return(0,s.yg)(Y9o,(0,p.A)({},H9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Q9o.isMDXComponent=!0;const $9o={toc:[]},K9o="wrapper";function J9o(e){let{components:n,...t}=e;return(0,s.yg)(K9o,(0,p.A)({},$9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}J9o.isMDXComponent=!0;const Z9o={toc:[]},eep="wrapper";function nep(e){let{components:n,...t}=e;return(0,s.yg)(eep,(0,p.A)({},Z9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nep.isMDXComponent=!0;const tep={toc:[]},oep="wrapper";function pep(e){let{components:n,...t}=e;return(0,s.yg)(oep,(0,p.A)({},tep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pep.isMDXComponent=!0;const rep={toc:[]},sep="wrapper";function cep(e){let{components:n,...t}=e;return(0,s.yg)(sep,(0,p.A)({},rep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}cep.isMDXComponent=!0;const aep={toc:[]},iep="wrapper";function lep(e){let{components:n,...t}=e;return(0,s.yg)(iep,(0,p.A)({},aep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lep.isMDXComponent=!0;const uep={toc:[]},mep="wrapper";function yep(e){let{components:n,...t}=e;return(0,s.yg)(mep,(0,p.A)({},uep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}yep.isMDXComponent=!0;const dep={toc:[]},hep="wrapper";function gep(e){let{components:n,...t}=e;return(0,s.yg)(hep,(0,p.A)({},dep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gep.isMDXComponent=!0;const fep={toc:[]},Dep="wrapper";function Mep(e){let{components:n,...t}=e;return(0,s.yg)(Dep,(0,p.A)({},fep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mep.isMDXComponent=!0;const Xep={toc:[]},_ep="wrapper";function wep(e){let{components:n,...t}=e;return(0,s.yg)(_ep,(0,p.A)({},Xep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wep.isMDXComponent=!0;const Tep={toc:[]},Cep="wrapper";function xep(e){let{components:n,...t}=e;return(0,s.yg)(Cep,(0,p.A)({},Tep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}xep.isMDXComponent=!0;const Aep={toc:[]},vep="wrapper";function Lep(e){let{components:n,...t}=e;return(0,s.yg)(vep,(0,p.A)({},Aep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Lep.isMDXComponent=!0;const bep={toc:[]},Nep="wrapper";function kep(e){let{components:n,...t}=e;return(0,s.yg)(Nep,(0,p.A)({},bep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}kep.isMDXComponent=!0;const zep={toc:[]},Pep="wrapper";function Iep(e){let{components:n,...t}=e;return(0,s.yg)(Pep,(0,p.A)({},zep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Iep.isMDXComponent=!0;const Rep={toc:[]},Wep="wrapper";function Sep(e){let{components:n,...t}=e;return(0,s.yg)(Wep,(0,p.A)({},Rep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Sep.isMDXComponent=!0;const Bep={toc:[]},Gep="wrapper";function Eep(e){let{components:n,...t}=e;return(0,s.yg)(Gep,(0,p.A)({},Bep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Eep.isMDXComponent=!0;const Oep={toc:[]},Uep="wrapper";function Fep(e){let{components:n,...t}=e;return(0,s.yg)(Uep,(0,p.A)({},Oep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Fep.isMDXComponent=!0;const Vep={toc:[]},qep="wrapper";function jep(e){let{components:n,...t}=e;return(0,s.yg)(qep,(0,p.A)({},Vep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}jep.isMDXComponent=!0;const Hep={toc:[]},Yep="wrapper";function Qep(e){let{components:n,...t}=e;return(0,s.yg)(Yep,(0,p.A)({},Hep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Qep.isMDXComponent=!0;const $ep={toc:[]},Kep="wrapper";function Jep(e){let{components:n,...t}=e;return(0,s.yg)(Kep,(0,p.A)({},$ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Jep.isMDXComponent=!0;const Zep={toc:[]},enp="wrapper";function nnp(e){let{components:n,...t}=e;return(0,s.yg)(enp,(0,p.A)({},Zep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}nnp.isMDXComponent=!0;const tnp={toc:[]},onp="wrapper";function pnp(e){let{components:n,...t}=e;return(0,s.yg)(onp,(0,p.A)({},tnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}pnp.isMDXComponent=!0;const rnp={toc:[]},snp="wrapper";function cnp(e){let{components:n,...t}=e;return(0,s.yg)(snp,(0,p.A)({},rnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}cnp.isMDXComponent=!0;const anp={toc:[]},inp="wrapper";function lnp(e){let{components:n,...t}=e;return(0,s.yg)(inp,(0,p.A)({},anp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}lnp.isMDXComponent=!0;const unp={toc:[]},mnp="wrapper";function ynp(e){let{components:n,...t}=e;return(0,s.yg)(mnp,(0,p.A)({},unp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}ynp.isMDXComponent=!0;const dnp={toc:[]},hnp="wrapper";function gnp(e){let{components:n,...t}=e;return(0,s.yg)(hnp,(0,p.A)({},dnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}gnp.isMDXComponent=!0;const fnp={toc:[]},Dnp="wrapper";function Mnp(e){let{components:n,...t}=e;return(0,s.yg)(Dnp,(0,p.A)({},fnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Mnp.isMDXComponent=!0;const Xnp={toc:[]},_np="wrapper";function wnp(e){let{components:n,...t}=e;return(0,s.yg)(_np,(0,p.A)({},Xnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}wnp.isMDXComponent=!0;const Tnp={toc:[]},Cnp="wrapper";function xnp(e){let{components:n,...t}=e;return(0,s.yg)(Cnp,(0,p.A)({},Tnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}xnp.isMDXComponent=!0;const Anp={toc:[]},vnp="wrapper";function Lnp(e){let{components:n,...t}=e;return(0,s.yg)(vnp,(0,p.A)({},Anp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Lnp.isMDXComponent=!0;const bnp={toc:[]},Nnp="wrapper";function knp(e){let{components:n,...t}=e;return(0,s.yg)(Nnp,(0,p.A)({},bnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}knp.isMDXComponent=!0;const znp={toc:[]},Pnp="wrapper";function Inp(e){let{components:n,...t}=e;return(0,s.yg)(Pnp,(0,p.A)({},znp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Inp.isMDXComponent=!0;const Rnp={toc:[]},Wnp="wrapper";function Snp(e){let{components:n,...t}=e;return(0,s.yg)(Wnp,(0,p.A)({},Rnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Snp.isMDXComponent=!0;const Bnp={toc:[]},Gnp="wrapper";function Enp(e){let{components:n,...t}=e;return(0,s.yg)(Gnp,(0,p.A)({},Bnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Enp.isMDXComponent=!0;const Onp={toc:[]},Unp="wrapper";function Fnp(e){let{components:n,...t}=e;return(0,s.yg)(Unp,(0,p.A)({},Onp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Fnp.isMDXComponent=!0;const Vnp={toc:[]},qnp="wrapper";function jnp(e){let{components:n,...t}=e;return(0,s.yg)(qnp,(0,p.A)({},Vnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}jnp.isMDXComponent=!0;const Hnp={toc:[]},Ynp="wrapper";function Qnp(e){let{components:n,...t}=e;return(0,s.yg)(Ynp,(0,p.A)({},Hnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Qnp.isMDXComponent=!0;const $np={toc:[]},Knp="wrapper";function Jnp(e){let{components:n,...t}=e;return(0,s.yg)(Knp,(0,p.A)({},$np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Jnp.isMDXComponent=!0;const Znp={toc:[]},etp="wrapper";function ntp(e){let{components:n,...t}=e;return(0,s.yg)(etp,(0,p.A)({},Znp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}ntp.isMDXComponent=!0;const ttp={toc:[]},otp="wrapper";function ptp(e){let{components:n,...t}=e;return(0,s.yg)(otp,(0,p.A)({},ttp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}ptp.isMDXComponent=!0;const rtp={toc:[]},stp="wrapper";function ctp(e){let{components:n,...t}=e;return(0,s.yg)(stp,(0,p.A)({},rtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}ctp.isMDXComponent=!0;const atp={toc:[]},itp="wrapper";function ltp(e){let{components:n,...t}=e;return(0,s.yg)(itp,(0,p.A)({},atp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}ltp.isMDXComponent=!0;const utp={toc:[]},mtp="wrapper";function ytp(e){let{components:n,...t}=e;return(0,s.yg)(mtp,(0,p.A)({},utp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}ytp.isMDXComponent=!0;const dtp={toc:[]},htp="wrapper";function gtp(e){let{components:n,...t}=e;return(0,s.yg)(htp,(0,p.A)({},dtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gtp.isMDXComponent=!0;const ftp={toc:[]},Dtp="wrapper";function Mtp(e){let{components:n,...t}=e;return(0,s.yg)(Dtp,(0,p.A)({},ftp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Mtp.isMDXComponent=!0;const Xtp={toc:[]},_tp="wrapper";function wtp(e){let{components:n,...t}=e;return(0,s.yg)(_tp,(0,p.A)({},Xtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}wtp.isMDXComponent=!0;const Ttp={toc:[]},Ctp="wrapper";function xtp(e){let{components:n,...t}=e;return(0,s.yg)(Ctp,(0,p.A)({},Ttp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xtp.isMDXComponent=!0;const Atp={toc:[]},vtp="wrapper";function Ltp(e){let{components:n,...t}=e;return(0,s.yg)(vtp,(0,p.A)({},Atp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Ltp.isMDXComponent=!0;const btp={toc:[]},Ntp="wrapper";function ktp(e){let{components:n,...t}=e;return(0,s.yg)(Ntp,(0,p.A)({},btp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ktp.isMDXComponent=!0;const ztp={toc:[]},Ptp="wrapper";function Itp(e){let{components:n,...t}=e;return(0,s.yg)(Ptp,(0,p.A)({},ztp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Itp.isMDXComponent=!0;const Rtp={toc:[]},Wtp="wrapper";function Stp(e){let{components:n,...t}=e;return(0,s.yg)(Wtp,(0,p.A)({},Rtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Stp.isMDXComponent=!0;const Btp={toc:[]},Gtp="wrapper";function Etp(e){let{components:n,...t}=e;return(0,s.yg)(Gtp,(0,p.A)({},Btp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Etp.isMDXComponent=!0;const Otp={toc:[]},Utp="wrapper";function Ftp(e){let{components:n,...t}=e;return(0,s.yg)(Utp,(0,p.A)({},Otp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Ftp.isMDXComponent=!0;const Vtp={toc:[]},qtp="wrapper";function jtp(e){let{components:n,...t}=e;return(0,s.yg)(qtp,(0,p.A)({},Vtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}jtp.isMDXComponent=!0;const Htp={toc:[]},Ytp="wrapper";function Qtp(e){let{components:n,...t}=e;return(0,s.yg)(Ytp,(0,p.A)({},Htp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Qtp.isMDXComponent=!0;const $tp={toc:[]},Ktp="wrapper";function Jtp(e){let{components:n,...t}=e;return(0,s.yg)(Ktp,(0,p.A)({},$tp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Jtp.isMDXComponent=!0;const Ztp={toc:[]},eop="wrapper";function nop(e){let{components:n,...t}=e;return(0,s.yg)(eop,(0,p.A)({},Ztp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}nop.isMDXComponent=!0;const top={toc:[]},oop="wrapper";function pop(e){let{components:n,...t}=e;return(0,s.yg)(oop,(0,p.A)({},top,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}pop.isMDXComponent=!0;const rop={toc:[]},sop="wrapper";function cop(e){let{components:n,...t}=e;return(0,s.yg)(sop,(0,p.A)({},rop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}cop.isMDXComponent=!0;const aop={toc:[]},iop="wrapper";function lop(e){let{components:n,...t}=e;return(0,s.yg)(iop,(0,p.A)({},aop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}lop.isMDXComponent=!0;const uop={toc:[]},mop="wrapper";function yop(e){let{components:n,...t}=e;return(0,s.yg)(mop,(0,p.A)({},uop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}yop.isMDXComponent=!0;const dop={toc:[]},hop="wrapper";function gop(e){let{components:n,...t}=e;return(0,s.yg)(hop,(0,p.A)({},dop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}gop.isMDXComponent=!0;const fop={toc:[]},Dop="wrapper";function Mop(e){let{components:n,...t}=e;return(0,s.yg)(Dop,(0,p.A)({},fop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Mop.isMDXComponent=!0;const Xop={toc:[]},_op="wrapper";function wop(e){let{components:n,...t}=e;return(0,s.yg)(_op,(0,p.A)({},Xop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}wop.isMDXComponent=!0;const Top={toc:[]},Cop="wrapper";function xop(e){let{components:n,...t}=e;return(0,s.yg)(Cop,(0,p.A)({},Top,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}xop.isMDXComponent=!0;const Aop={toc:[]},vop="wrapper";function Lop(e){let{components:n,...t}=e;return(0,s.yg)(vop,(0,p.A)({},Aop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Lop.isMDXComponent=!0;const bop={toc:[]},Nop="wrapper";function kop(e){let{components:n,...t}=e;return(0,s.yg)(Nop,(0,p.A)({},bop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}kop.isMDXComponent=!0;const zop={toc:[]},Pop="wrapper";function Iop(e){let{components:n,...t}=e;return(0,s.yg)(Pop,(0,p.A)({},zop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Iop.isMDXComponent=!0;const Rop={toc:[]},Wop="wrapper";function Sop(e){let{components:n,...t}=e;return(0,s.yg)(Wop,(0,p.A)({},Rop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Sop.isMDXComponent=!0;const Bop={toc:[]},Gop="wrapper";function Eop(e){let{components:n,...t}=e;return(0,s.yg)(Gop,(0,p.A)({},Bop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Eop.isMDXComponent=!0;const Oop={toc:[]},Uop="wrapper";function Fop(e){let{components:n,...t}=e;return(0,s.yg)(Uop,(0,p.A)({},Oop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Fop.isMDXComponent=!0;const Vop={toc:[]},qop="wrapper";function jop(e){let{components:n,...t}=e;return(0,s.yg)(qop,(0,p.A)({},Vop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}jop.isMDXComponent=!0;const Hop={toc:[]},Yop="wrapper";function Qop(e){let{components:n,...t}=e;return(0,s.yg)(Yop,(0,p.A)({},Hop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Qop.isMDXComponent=!0;const $op={toc:[]},Kop="wrapper";function Jop(e){let{components:n,...t}=e;return(0,s.yg)(Kop,(0,p.A)({},$op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Jop.isMDXComponent=!0;const Zop={toc:[]},epp="wrapper";function npp(e){let{components:n,...t}=e;return(0,s.yg)(epp,(0,p.A)({},Zop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}npp.isMDXComponent=!0;const tpp={toc:[]},opp="wrapper";function ppp(e){let{components:n,...t}=e;return(0,s.yg)(opp,(0,p.A)({},tpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}ppp.isMDXComponent=!0;const rpp={toc:[]},spp="wrapper";function cpp(e){let{components:n,...t}=e;return(0,s.yg)(spp,(0,p.A)({},rpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}cpp.isMDXComponent=!0;const app={toc:[]},ipp="wrapper";function lpp(e){let{components:n,...t}=e;return(0,s.yg)(ipp,(0,p.A)({},app,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}lpp.isMDXComponent=!0;const upp={toc:[]},mpp="wrapper";function ypp(e){let{components:n,...t}=e;return(0,s.yg)(mpp,(0,p.A)({},upp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}ypp.isMDXComponent=!0;const dpp={toc:[]},hpp="wrapper";function gpp(e){let{components:n,...t}=e;return(0,s.yg)(hpp,(0,p.A)({},dpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gpp.isMDXComponent=!0;const fpp={toc:[]},Dpp="wrapper";function Mpp(e){let{components:n,...t}=e;return(0,s.yg)(Dpp,(0,p.A)({},fpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Mpp.isMDXComponent=!0;const Xpp={toc:[]},_pp="wrapper";function wpp(e){let{components:n,...t}=e;return(0,s.yg)(_pp,(0,p.A)({},Xpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}wpp.isMDXComponent=!0;const Tpp={toc:[]},Cpp="wrapper";function xpp(e){let{components:n,...t}=e;return(0,s.yg)(Cpp,(0,p.A)({},Tpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}xpp.isMDXComponent=!0;const App={toc:[]},vpp="wrapper";function Lpp(e){let{components:n,...t}=e;return(0,s.yg)(vpp,(0,p.A)({},App,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Lpp.isMDXComponent=!0;const bpp={toc:[]},Npp="wrapper";function kpp(e){let{components:n,...t}=e;return(0,s.yg)(Npp,(0,p.A)({},bpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kpp.isMDXComponent=!0;const zpp={toc:[]},Ppp="wrapper";function Ipp(e){let{components:n,...t}=e;return(0,s.yg)(Ppp,(0,p.A)({},zpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ipp.isMDXComponent=!0;const Rpp={toc:[]},Wpp="wrapper";function Spp(e){let{components:n,...t}=e;return(0,s.yg)(Wpp,(0,p.A)({},Rpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Spp.isMDXComponent=!0;const Bpp={toc:[]},Gpp="wrapper";function Epp(e){let{components:n,...t}=e;return(0,s.yg)(Gpp,(0,p.A)({},Bpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Epp.isMDXComponent=!0;const Opp={toc:[]},Upp="wrapper";function Fpp(e){let{components:n,...t}=e;return(0,s.yg)(Upp,(0,p.A)({},Opp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Fpp.isMDXComponent=!0;const Vpp={toc:[]},qpp="wrapper";function jpp(e){let{components:n,...t}=e;return(0,s.yg)(qpp,(0,p.A)({},Vpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jpp.isMDXComponent=!0;const Hpp={toc:[]},Ypp="wrapper";function Qpp(e){let{components:n,...t}=e;return(0,s.yg)(Ypp,(0,p.A)({},Hpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qpp.isMDXComponent=!0;const $pp={toc:[]},Kpp="wrapper";function Jpp(e){let{components:n,...t}=e;return(0,s.yg)(Kpp,(0,p.A)({},$pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Jpp.isMDXComponent=!0;const Zpp={toc:[]},erp="wrapper";function nrp(e){let{components:n,...t}=e;return(0,s.yg)(erp,(0,p.A)({},Zpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nrp.isMDXComponent=!0;const trp={toc:[]},orp="wrapper";function prp(e){let{components:n,...t}=e;return(0,s.yg)(orp,(0,p.A)({},trp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}prp.isMDXComponent=!0;const rrp={toc:[]},srp="wrapper";function crp(e){let{components:n,...t}=e;return(0,s.yg)(srp,(0,p.A)({},rrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}crp.isMDXComponent=!0;const arp={toc:[]},irp="wrapper";function lrp(e){let{components:n,...t}=e;return(0,s.yg)(irp,(0,p.A)({},arp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lrp.isMDXComponent=!0;const urp={toc:[]},mrp="wrapper";function yrp(e){let{components:n,...t}=e;return(0,s.yg)(mrp,(0,p.A)({},urp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}yrp.isMDXComponent=!0;const drp={toc:[]},hrp="wrapper";function grp(e){let{components:n,...t}=e;return(0,s.yg)(hrp,(0,p.A)({},drp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}grp.isMDXComponent=!0;const frp={toc:[]},Drp="wrapper";function Mrp(e){let{components:n,...t}=e;return(0,s.yg)(Drp,(0,p.A)({},frp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Mrp.isMDXComponent=!0;const Xrp={toc:[]},_rp="wrapper";function wrp(e){let{components:n,...t}=e;return(0,s.yg)(_rp,(0,p.A)({},Xrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wrp.isMDXComponent=!0;const Trp={toc:[]},Crp="wrapper";function xrp(e){let{components:n,...t}=e;return(0,s.yg)(Crp,(0,p.A)({},Trp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}xrp.isMDXComponent=!0;const Arp={toc:[]},vrp="wrapper";function Lrp(e){let{components:n,...t}=e;return(0,s.yg)(vrp,(0,p.A)({},Arp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Lrp.isMDXComponent=!0;const brp={toc:[]},Nrp="wrapper";function krp(e){let{components:n,...t}=e;return(0,s.yg)(Nrp,(0,p.A)({},brp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}krp.isMDXComponent=!0;const zrp={toc:[]},Prp="wrapper";function Irp(e){let{components:n,...t}=e;return(0,s.yg)(Prp,(0,p.A)({},zrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Irp.isMDXComponent=!0;const Rrp={toc:[]},Wrp="wrapper";function Srp(e){let{components:n,...t}=e;return(0,s.yg)(Wrp,(0,p.A)({},Rrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Srp.isMDXComponent=!0;const Brp={toc:[]},Grp="wrapper";function Erp(e){let{components:n,...t}=e;return(0,s.yg)(Grp,(0,p.A)({},Brp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut for"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontWeight={700} />\n")))}Erp.isMDXComponent=!0;const Orp={toc:[]},Urp="wrapper";function Frp(e){let{components:n,...t}=e;return(0,s.yg)(Urp,(0,p.A)({},Orp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a bold text node."))}Frp.isMDXComponent=!0;const Vrp={toc:[]},qrp="wrapper";function jrp(e){let{components:n,...t}=e;return(0,s.yg)(qrp,(0,p.A)({},Vrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional text properties."))}jrp.isMDXComponent=!0;const Hrp={toc:[]},Yrp="wrapper";function Qrp(e){let{components:n,...t}=e;return(0,s.yg)(Yrp,(0,p.A)({},Hrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut for"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontStyle={'italic'} />\n")))}Qrp.isMDXComponent=!0;const $rp={toc:[]},Krp="wrapper";function Jrp(e){let{components:n,...t}=e;return(0,s.yg)(Krp,(0,p.A)({},$rp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an italic text node."))}Jrp.isMDXComponent=!0;const Zrp={toc:[]},esp="wrapper";function nsp(e){let{components:n,...t}=e;return(0,s.yg)(esp,(0,p.A)({},Zrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional text properties."))}nsp.isMDXComponent=!0;const tsp={toc:[]},osp="wrapper";function psp(e){let{components:n,...t}=e;return(0,s.yg)(osp,(0,p.A)({},tsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}psp.isMDXComponent=!0;const rsp={toc:[]},ssp="wrapper";function csp(e){let{components:n,...t}=e;return(0,s.yg)(ssp,(0,p.A)({},rsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}csp.isMDXComponent=!0;const asp={toc:[]},isp="wrapper";function lsp(e){let{components:n,...t}=e;return(0,s.yg)(isp,(0,p.A)({},asp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lsp.isMDXComponent=!0;const usp={toc:[]},msp="wrapper";function ysp(e){let{components:n,...t}=e;return(0,s.yg)(msp,(0,p.A)({},usp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}ysp.isMDXComponent=!0;const dsp={toc:[]},hsp="wrapper";function gsp(e){let{components:n,...t}=e;return(0,s.yg)(hsp,(0,p.A)({},dsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}gsp.isMDXComponent=!0;const fsp={toc:[]},Dsp="wrapper";function Msp(e){let{components:n,...t}=e;return(0,s.yg)(Dsp,(0,p.A)({},fsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Msp.isMDXComponent=!0;const Xsp={toc:[]},_sp="wrapper";function wsp(e){let{components:n,...t}=e;return(0,s.yg)(_sp,(0,p.A)({},Xsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}wsp.isMDXComponent=!0;const Tsp={toc:[]},Csp="wrapper";function xsp(e){let{components:n,...t}=e;return(0,s.yg)(Csp,(0,p.A)({},Tsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this video."))}xsp.isMDXComponent=!0;const Asp={toc:[]},vsp="wrapper";function Lsp(e){let{components:n,...t}=e;return(0,s.yg)(vsp,(0,p.A)({},Asp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Lsp.isMDXComponent=!0;const bsp={toc:[]},Nsp="wrapper";function ksp(e){let{components:n,...t}=e;return(0,s.yg)(Nsp,(0,p.A)({},bsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ksp.isMDXComponent=!0;const zsp={toc:[]},Psp="wrapper";function Isp(e){let{components:n,...t}=e;return(0,s.yg)(Psp,(0,p.A)({},zsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Isp.isMDXComponent=!0;const Rsp={toc:[]},Wsp="wrapper";function Ssp(e){let{components:n,...t}=e;return(0,s.yg)(Wsp,(0,p.A)({},Rsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Ssp.isMDXComponent=!0;const Bsp={toc:[]},Gsp="wrapper";function Esp(e){let{components:n,...t}=e;return(0,s.yg)(Gsp,(0,p.A)({},Bsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Esp.isMDXComponent=!0;const Osp={toc:[]},Usp="wrapper";function Fsp(e){let{components:n,...t}=e;return(0,s.yg)(Usp,(0,p.A)({},Osp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Fsp.isMDXComponent=!0;const Vsp={toc:[]},qsp="wrapper";function jsp(e){let{components:n,...t}=e;return(0,s.yg)(qsp,(0,p.A)({},Vsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}jsp.isMDXComponent=!0;const Hsp={toc:[]},Ysp="wrapper";function Qsp(e){let{components:n,...t}=e;return(0,s.yg)(Ysp,(0,p.A)({},Hsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Qsp.isMDXComponent=!0;const $sp={toc:[]},Ksp="wrapper";function Jsp(e){let{components:n,...t}=e;return(0,s.yg)(Ksp,(0,p.A)({},$sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Jsp.isMDXComponent=!0;const Zsp={toc:[]},ecp="wrapper";function ncp(e){let{components:n,...t}=e;return(0,s.yg)(ecp,(0,p.A)({},Zsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ncp.isMDXComponent=!0;const tcp={toc:[]},ocp="wrapper";function pcp(e){let{components:n,...t}=e;return(0,s.yg)(ocp,(0,p.A)({},tcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}pcp.isMDXComponent=!0;const rcp={toc:[]},scp="wrapper";function ccp(e){let{components:n,...t}=e;return(0,s.yg)(scp,(0,p.A)({},rcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}ccp.isMDXComponent=!0;const acp={toc:[]},icp="wrapper";function lcp(e){let{components:n,...t}=e;return(0,s.yg)(icp,(0,p.A)({},acp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lcp.isMDXComponent=!0;const ucp={toc:[]},mcp="wrapper";function ycp(e){let{components:n,...t}=e;return(0,s.yg)(mcp,(0,p.A)({},ucp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}ycp.isMDXComponent=!0;const dcp={toc:[]},hcp="wrapper";function gcp(e){let{components:n,...t}=e;return(0,s.yg)(hcp,(0,p.A)({},dcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}gcp.isMDXComponent=!0;const fcp={toc:[]},Dcp="wrapper";function Mcp(e){let{components:n,...t}=e;return(0,s.yg)(Dcp,(0,p.A)({},fcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Mcp.isMDXComponent=!0;const Xcp={toc:[]},_cp="wrapper";function wcp(e){let{components:n,...t}=e;return(0,s.yg)(_cp,(0,p.A)({},Xcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}wcp.isMDXComponent=!0;const Tcp={toc:[]},Ccp="wrapper";function xcp(e){let{components:n,...t}=e;return(0,s.yg)(Ccp,(0,p.A)({},Tcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xcp.isMDXComponent=!0;const Acp={toc:[]},vcp="wrapper";function Lcp(e){let{components:n,...t}=e;return(0,s.yg)(vcp,(0,p.A)({},Acp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Lcp.isMDXComponent=!0;const bcp={toc:[]},Ncp="wrapper";function kcp(e){let{components:n,...t}=e;return(0,s.yg)(Ncp,(0,p.A)({},bcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kcp.isMDXComponent=!0;const zcp={toc:[]},Pcp="wrapper";function Icp(e){let{components:n,...t}=e;return(0,s.yg)(Pcp,(0,p.A)({},zcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Icp.isMDXComponent=!0;const Rcp={toc:[]},Wcp="wrapper";function Scp(e){let{components:n,...t}=e;return(0,s.yg)(Wcp,(0,p.A)({},Rcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Scp.isMDXComponent=!0;const Bcp={toc:[]},Gcp="wrapper";function Ecp(e){let{components:n,...t}=e;return(0,s.yg)(Gcp,(0,p.A)({},Bcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ecp.isMDXComponent=!0;const Ocp={toc:[]},Ucp="wrapper";function Fcp(e){let{components:n,...t}=e;return(0,s.yg)(Ucp,(0,p.A)({},Ocp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Fcp.isMDXComponent=!0;const Vcp={toc:[]},qcp="wrapper";function jcp(e){let{components:n,...t}=e;return(0,s.yg)(qcp,(0,p.A)({},Vcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}jcp.isMDXComponent=!0;const Hcp={toc:[]},Ycp="wrapper";function Qcp(e){let{components:n,...t}=e;return(0,s.yg)(Ycp,(0,p.A)({},Hcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Qcp.isMDXComponent=!0;const $cp={toc:[]},Kcp="wrapper";function Jcp(e){let{components:n,...t}=e;return(0,s.yg)(Kcp,(0,p.A)({},$cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Jcp.isMDXComponent=!0;const Zcp={toc:[]},eap="wrapper";function nap(e){let{components:n,...t}=e;return(0,s.yg)(eap,(0,p.A)({},Zcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}nap.isMDXComponent=!0;const tap={toc:[]},oap="wrapper";function pap(e){let{components:n,...t}=e;return(0,s.yg)(oap,(0,p.A)({},tap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}pap.isMDXComponent=!0;const rap={toc:[]},sap="wrapper";function cap(e){let{components:n,...t}=e;return(0,s.yg)(sap,(0,p.A)({},rap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"PNGs have better image quality and support transparency, but they make\nrendering slower."))}cap.isMDXComponent=!0;const aap={toc:[]},iap="wrapper";function lap(e){let{components:n,...t}=e;return(0,s.yg)(iap,(0,p.A)({},aap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"false"))}lap.isMDXComponent=!0;const uap={toc:[]},map="wrapper";function yap(e){let{components:n,...t}=e;return(0,s.yg)(map,(0,p.A)({},uap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video frames should be extracted as PNGs. Uses JPEGs when\nset to false."))}yap.isMDXComponent=!0;const dap={toc:[]},hap="wrapper";function gap(e){let{components:n,...t}=e;return(0,s.yg)(hap,(0,p.A)({},dap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gap.isMDXComponent=!0;const fap={toc:[]},Dap="wrapper";function Map(e){let{components:n,...t}=e;return(0,s.yg)(Dap,(0,p.A)({},fap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Map.isMDXComponent=!0;const Xap={toc:[]},_ap="wrapper";function wap(e){let{components:n,...t}=e;return(0,s.yg)(_ap,(0,p.A)({},Xap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}wap.isMDXComponent=!0;const Tap={toc:[]},Cap="wrapper";function xap(e){let{components:n,...t}=e;return(0,s.yg)(Cap,(0,p.A)({},Tap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}xap.isMDXComponent=!0;const Aap={toc:[]},vap="wrapper";function Lap(e){let{components:n,...t}=e;return(0,s.yg)(vap,(0,p.A)({},Aap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Lap.isMDXComponent=!0;const bap={toc:[]},Nap="wrapper";function kap(e){let{components:n,...t}=e;return(0,s.yg)(Nap,(0,p.A)({},bap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}kap.isMDXComponent=!0;const zap={toc:[]},Pap="wrapper";function Iap(e){let{components:n,...t}=e;return(0,s.yg)(Pap,(0,p.A)({},zap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Iap.isMDXComponent=!0;const Rap={toc:[]},Wap="wrapper";function Sap(e){let{components:n,...t}=e;return(0,s.yg)(Wap,(0,p.A)({},Rap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Sap.isMDXComponent=!0;const Bap={toc:[]},Gap="wrapper";function Eap(e){let{components:n,...t}=e;return(0,s.yg)(Gap,(0,p.A)({},Bap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Eap.isMDXComponent=!0;const Oap={toc:[]},Uap="wrapper";function Fap(e){let{components:n,...t}=e;return(0,s.yg)(Uap,(0,p.A)({},Oap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Fap.isMDXComponent=!0;const Vap={toc:[]},qap="wrapper";function jap(e){let{components:n,...t}=e;return(0,s.yg)(qap,(0,p.A)({},Vap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}jap.isMDXComponent=!0;const Hap={toc:[]},Yap="wrapper";function Qap(e){let{components:n,...t}=e;return(0,s.yg)(Yap,(0,p.A)({},Hap,t,{components:n,mdxType:"MDXLayout"}))}Qap.isMDXComponent=!0;const $ap={toc:[]},Kap="wrapper";function Jap(e){let{components:n,...t}=e;return(0,s.yg)(Kap,(0,p.A)({},$ap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Jap.isMDXComponent=!0;const Zap={toc:[]},eip="wrapper";function nip(e){let{components:n,...t}=e;return(0,s.yg)(eip,(0,p.A)({},Zap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nip.isMDXComponent=!0;const tip={toc:[]},oip="wrapper";function pip(e){let{components:n,...t}=e;return(0,s.yg)(oip,(0,p.A)({},tip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}pip.isMDXComponent=!0;const rip={toc:[]},sip="wrapper";function cip(e){let{components:n,...t}=e;return(0,s.yg)(sip,(0,p.A)({},rip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}cip.isMDXComponent=!0;const aip={toc:[]},iip="wrapper";function lip(e){let{components:n,...t}=e;return(0,s.yg)(iip,(0,p.A)({},aip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}lip.isMDXComponent=!0;const uip={toc:[]},mip="wrapper";function yip(e){let{components:n,...t}=e;return(0,s.yg)(mip,(0,p.A)({},uip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}yip.isMDXComponent=!0;const dip={toc:[]},hip="wrapper";function gip(e){let{components:n,...t}=e;return(0,s.yg)(hip,(0,p.A)({},dip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}gip.isMDXComponent=!0;const fip={toc:[]},Dip="wrapper";function Mip(e){let{components:n,...t}=e;return(0,s.yg)(Dip,(0,p.A)({},fip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}Mip.isMDXComponent=!0;const Xip={toc:[]},_ip="wrapper";function wip(e){let{components:n,...t}=e;return(0,s.yg)(_ip,(0,p.A)({},Xip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}wip.isMDXComponent=!0;const Tip={toc:[]},Cip="wrapper";function xip(e){let{components:n,...t}=e;return(0,s.yg)(Cip,(0,p.A)({},Tip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}xip.isMDXComponent=!0;const Aip={toc:[]},vip="wrapper";function Lip(e){let{components:n,...t}=e;return(0,s.yg)(vip,(0,p.A)({},Aip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video should be smoothed."))}Lip.isMDXComponent=!0;const bip={toc:[]},Nip="wrapper";function kip(e){let{components:n,...t}=e;return(0,s.yg)(Nip,(0,p.A)({},bip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}kip.isMDXComponent=!0;const zip={toc:[]},Pip="wrapper";function Iip(e){let{components:n,...t}=e;return(0,s.yg)(Pip,(0,p.A)({},zip,t,{components:n,mdxType:"MDXLayout"}))}Iip.isMDXComponent=!0;const Rip={toc:[]},Wip="wrapper";function Sip(e){let{components:n,...t}=e;return(0,s.yg)(Wip,(0,p.A)({},Rip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Sip.isMDXComponent=!0;const Bip={toc:[]},Gip="wrapper";function Eip(e){let{components:n,...t}=e;return(0,s.yg)(Gip,(0,p.A)({},Bip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Eip.isMDXComponent=!0;const Oip={toc:[]},Uip="wrapper";function Fip(e){let{components:n,...t}=e;return(0,s.yg)(Uip,(0,p.A)({},Oip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Fip.isMDXComponent=!0;const Vip={toc:[]},qip="wrapper";function jip(e){let{components:n,...t}=e;return(0,s.yg)(qip,(0,p.A)({},Vip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}jip.isMDXComponent=!0;const Hip={toc:[]},Yip="wrapper";function Qip(e){let{components:n,...t}=e;return(0,s.yg)(Yip,(0,p.A)({},Hip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Qip.isMDXComponent=!0;const $ip={toc:[]},Kip="wrapper";function Jip(e){let{components:n,...t}=e;return(0,s.yg)(Kip,(0,p.A)({},$ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Jip.isMDXComponent=!0;const Zip={toc:[]},elp="wrapper";function nlp(e){let{components:n,...t}=e;return(0,s.yg)(elp,(0,p.A)({},Zip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}nlp.isMDXComponent=!0;const tlp={toc:[]},olp="wrapper";function plp(e){let{components:n,...t}=e;return(0,s.yg)(olp,(0,p.A)({},tlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}plp.isMDXComponent=!0;const rlp={toc:[]},slp="wrapper";function clp(e){let{components:n,...t}=e;return(0,s.yg)(slp,(0,p.A)({},rlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}clp.isMDXComponent=!0;const alp={toc:[]},ilp="wrapper";function llp(e){let{components:n,...t}=e;return(0,s.yg)(ilp,(0,p.A)({},alp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}llp.isMDXComponent=!0;const ulp={toc:[]},mlp="wrapper";function ylp(e){let{components:n,...t}=e;return(0,s.yg)(mlp,(0,p.A)({},ulp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ylp.isMDXComponent=!0;const dlp={toc:[]},hlp="wrapper";function glp(e){let{components:n,...t}=e;return(0,s.yg)(hlp,(0,p.A)({},dlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}glp.isMDXComponent=!0;const flp={toc:[]},Dlp="wrapper";function Mlp(e){let{components:n,...t}=e;return(0,s.yg)(Dlp,(0,p.A)({},flp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Mlp.isMDXComponent=!0;const Xlp={toc:[]},_lp="wrapper";function wlp(e){let{components:n,...t}=e;return(0,s.yg)(_lp,(0,p.A)({},Xlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wlp.isMDXComponent=!0;const Tlp={toc:[]},Clp="wrapper";function xlp(e){let{components:n,...t}=e;return(0,s.yg)(Clp,(0,p.A)({},Tlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}xlp.isMDXComponent=!0;const Alp={toc:[]},vlp="wrapper";function Llp(e){let{components:n,...t}=e;return(0,s.yg)(vlp,(0,p.A)({},Alp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Llp.isMDXComponent=!0;const blp={toc:[]},Nlp="wrapper";function klp(e){let{components:n,...t}=e;return(0,s.yg)(Nlp,(0,p.A)({},blp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}klp.isMDXComponent=!0;const zlp={toc:[]},Plp="wrapper";function Ilp(e){let{components:n,...t}=e;return(0,s.yg)(Plp,(0,p.A)({},zlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Ilp.isMDXComponent=!0;const Rlp={toc:[]},Wlp="wrapper";function Slp(e){let{components:n,...t}=e;return(0,s.yg)(Wlp,(0,p.A)({},Rlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Slp.isMDXComponent=!0;const Blp={toc:[]},Glp="wrapper";function Elp(e){let{components:n,...t}=e;return(0,s.yg)(Glp,(0,p.A)({},Blp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Elp.isMDXComponent=!0;const Olp={toc:[]},Ulp="wrapper";function Flp(e){let{components:n,...t}=e;return(0,s.yg)(Ulp,(0,p.A)({},Olp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Flp.isMDXComponent=!0;const Vlp={toc:[]},qlp="wrapper";function jlp(e){let{components:n,...t}=e;return(0,s.yg)(qlp,(0,p.A)({},Vlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}jlp.isMDXComponent=!0;const Hlp={toc:[]},Ylp="wrapper";function Qlp(e){let{components:n,...t}=e;return(0,s.yg)(Ylp,(0,p.A)({},Hlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Qlp.isMDXComponent=!0;const $lp={toc:[]},Klp="wrapper";function Jlp(e){let{components:n,...t}=e;return(0,s.yg)(Klp,(0,p.A)({},$lp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Jlp.isMDXComponent=!0;const Zlp={toc:[]},eup="wrapper";function nup(e){let{components:n,...t}=e;return(0,s.yg)(eup,(0,p.A)({},Zlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}nup.isMDXComponent=!0;const tup={toc:[]},oup="wrapper";function pup(e){let{components:n,...t}=e;return(0,s.yg)(oup,(0,p.A)({},tup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}pup.isMDXComponent=!0;const rup={toc:[]},sup="wrapper";function cup(e){let{components:n,...t}=e;return(0,s.yg)(sup,(0,p.A)({},rup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}cup.isMDXComponent=!0;const aup={toc:[]},iup="wrapper";function lup(e){let{components:n,...t}=e;return(0,s.yg)(iup,(0,p.A)({},aup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lup.isMDXComponent=!0;const uup={toc:[]},mup="wrapper";function yup(e){let{components:n,...t}=e;return(0,s.yg)(mup,(0,p.A)({},uup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}yup.isMDXComponent=!0;const dup={toc:[]},hup="wrapper";function gup(e){let{components:n,...t}=e;return(0,s.yg)(hup,(0,p.A)({},dup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}gup.isMDXComponent=!0;const fup={toc:[]},Dup="wrapper";function Mup(e){let{components:n,...t}=e;return(0,s.yg)(Dup,(0,p.A)({},fup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Mup.isMDXComponent=!0;const Xup={toc:[]},_up="wrapper";function wup(e){let{components:n,...t}=e;return(0,s.yg)(_up,(0,p.A)({},Xup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}wup.isMDXComponent=!0;const Tup={toc:[]},Cup="wrapper";function xup(e){let{components:n,...t}=e;return(0,s.yg)(Cup,(0,p.A)({},Tup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}xup.isMDXComponent=!0;const Aup={toc:[]},vup="wrapper";function Lup(e){let{components:n,...t}=e;return(0,s.yg)(vup,(0,p.A)({},Aup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Lup.isMDXComponent=!0;const bup={toc:[]},Nup="wrapper";function kup(e){let{components:n,...t}=e;return(0,s.yg)(Nup,(0,p.A)({},bup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}kup.isMDXComponent=!0;const zup={toc:[]},Pup="wrapper";function Iup(e){let{components:n,...t}=e;return(0,s.yg)(Pup,(0,p.A)({},zup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Iup.isMDXComponent=!0;const Rup={toc:[]},Wup="wrapper";function Sup(e){let{components:n,...t}=e;return(0,s.yg)(Wup,(0,p.A)({},Rup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Sup.isMDXComponent=!0;const Bup={toc:[]},Gup="wrapper";function Eup(e){let{components:n,...t}=e;return(0,s.yg)(Gup,(0,p.A)({},Bup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Eup.isMDXComponent=!0;const Oup={toc:[]},Uup="wrapper";function Fup(e){let{components:n,...t}=e;return(0,s.yg)(Uup,(0,p.A)({},Oup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Fup.isMDXComponent=!0;const Vup={toc:[]},qup="wrapper";function jup(e){let{components:n,...t}=e;return(0,s.yg)(qup,(0,p.A)({},Vup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jup.isMDXComponent=!0;const Hup={toc:[]},Yup="wrapper";function Qup(e){let{components:n,...t}=e;return(0,s.yg)(Yup,(0,p.A)({},Hup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Qup.isMDXComponent=!0;const $up={toc:[]},Kup="wrapper";function Jup(e){let{components:n,...t}=e;return(0,s.yg)(Kup,(0,p.A)({},$up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jup.isMDXComponent=!0;const Zup={toc:[]},emp="wrapper";function nmp(e){let{components:n,...t}=e;return(0,s.yg)(emp,(0,p.A)({},Zup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nmp.isMDXComponent=!0;const tmp={toc:[]},omp="wrapper";function pmp(e){let{components:n,...t}=e;return(0,s.yg)(omp,(0,p.A)({},tmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pmp.isMDXComponent=!0;const rmp={toc:[]},smp="wrapper";function cmp(e){let{components:n,...t}=e;return(0,s.yg)(smp,(0,p.A)({},rmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cmp.isMDXComponent=!0;const amp={toc:[]},imp="wrapper";function lmp(e){let{components:n,...t}=e;return(0,s.yg)(imp,(0,p.A)({},amp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lmp.isMDXComponent=!0;const ump={toc:[]},mmp="wrapper";function ymp(e){let{components:n,...t}=e;return(0,s.yg)(mmp,(0,p.A)({},ump,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}ymp.isMDXComponent=!0;const dmp={toc:[]},hmp="wrapper";function gmp(e){let{components:n,...t}=e;return(0,s.yg)(hmp,(0,p.A)({},dmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gmp.isMDXComponent=!0;const fmp={toc:[]},Dmp="wrapper";function Mmp(e){let{components:n,...t}=e;return(0,s.yg)(Dmp,(0,p.A)({},fmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Mmp.isMDXComponent=!0;const Xmp={toc:[]},_mp="wrapper";function wmp(e){let{components:n,...t}=e;return(0,s.yg)(_mp,(0,p.A)({},Xmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wmp.isMDXComponent=!0;const Tmp={toc:[]},Cmp="wrapper";function xmp(e){let{components:n,...t}=e;return(0,s.yg)(Cmp,(0,p.A)({},Tmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}xmp.isMDXComponent=!0;const Amp={toc:[]},vmp="wrapper";function Lmp(e){let{components:n,...t}=e;return(0,s.yg)(vmp,(0,p.A)({},Amp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Lmp.isMDXComponent=!0;const bmp={toc:[]},Nmp="wrapper";function kmp(e){let{components:n,...t}=e;return(0,s.yg)(Nmp,(0,p.A)({},bmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}kmp.isMDXComponent=!0;const zmp={toc:[]},Pmp="wrapper";function Imp(e){let{components:n,...t}=e;return(0,s.yg)(Pmp,(0,p.A)({},zmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Imp.isMDXComponent=!0;const Rmp={toc:[]},Wmp="wrapper";function Smp(e){let{components:n,...t}=e;return(0,s.yg)(Wmp,(0,p.A)({},Rmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Smp.isMDXComponent=!0;const Bmp={toc:[]},Gmp="wrapper";function Emp(e){let{components:n,...t}=e;return(0,s.yg)(Gmp,(0,p.A)({},Bmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Emp.isMDXComponent=!0;const Omp={toc:[]},Ump="wrapper";function Fmp(e){let{components:n,...t}=e;return(0,s.yg)(Ump,(0,p.A)({},Omp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Fmp.isMDXComponent=!0;const Vmp={toc:[]},qmp="wrapper";function jmp(e){let{components:n,...t}=e;return(0,s.yg)(qmp,(0,p.A)({},Vmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}jmp.isMDXComponent=!0;const Hmp={toc:[]},Ymp="wrapper";function Qmp(e){let{components:n,...t}=e;return(0,s.yg)(Ymp,(0,p.A)({},Hmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Qmp.isMDXComponent=!0;const $mp={toc:[]},Kmp="wrapper";function Jmp(e){let{components:n,...t}=e;return(0,s.yg)(Kmp,(0,p.A)({},$mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Jmp.isMDXComponent=!0;const Zmp={toc:[]},eyp="wrapper";function nyp(e){let{components:n,...t}=e;return(0,s.yg)(eyp,(0,p.A)({},Zmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}nyp.isMDXComponent=!0;const typ={toc:[]},oyp="wrapper";function pyp(e){let{components:n,...t}=e;return(0,s.yg)(oyp,(0,p.A)({},typ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}pyp.isMDXComponent=!0;const ryp={toc:[]},syp="wrapper";function cyp(e){let{components:n,...t}=e;return(0,s.yg)(syp,(0,p.A)({},ryp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}cyp.isMDXComponent=!0;const ayp={toc:[]},iyp="wrapper";function lyp(e){let{components:n,...t}=e;return(0,s.yg)(iyp,(0,p.A)({},ayp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}lyp.isMDXComponent=!0;const uyp={toc:[]},myp="wrapper";function yyp(e){let{components:n,...t}=e;return(0,s.yg)(myp,(0,p.A)({},uyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yyp.isMDXComponent=!0;const dyp={toc:[]},hyp="wrapper";function gyp(e){let{components:n,...t}=e;return(0,s.yg)(hyp,(0,p.A)({},dyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}gyp.isMDXComponent=!0;const fyp={toc:[]},Dyp="wrapper";function Myp(e){let{components:n,...t}=e;return(0,s.yg)(Dyp,(0,p.A)({},fyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Myp.isMDXComponent=!0;const Xyp={toc:[]},_yp="wrapper";function wyp(e){let{components:n,...t}=e;return(0,s.yg)(_yp,(0,p.A)({},Xyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wyp.isMDXComponent=!0;const Typ={toc:[]},Cyp="wrapper";function xyp(e){let{components:n,...t}=e;return(0,s.yg)(Cyp,(0,p.A)({},Typ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}xyp.isMDXComponent=!0;const Ayp={toc:[]},vyp="wrapper";function Lyp(e){let{components:n,...t}=e;return(0,s.yg)(vyp,(0,p.A)({},Ayp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Lyp.isMDXComponent=!0;const byp={toc:[]},Nyp="wrapper";function kyp(e){let{components:n,...t}=e;return(0,s.yg)(Nyp,(0,p.A)({},byp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}kyp.isMDXComponent=!0;const zyp={toc:[]},Pyp="wrapper";function Iyp(e){let{components:n,...t}=e;return(0,s.yg)(Pyp,(0,p.A)({},zyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Iyp.isMDXComponent=!0;const Ryp={toc:[]},Wyp="wrapper";function Syp(e){let{components:n,...t}=e;return(0,s.yg)(Wyp,(0,p.A)({},Ryp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Syp.isMDXComponent=!0;const Byp={toc:[]},Gyp="wrapper";function Eyp(e){let{components:n,...t}=e;return(0,s.yg)(Gyp,(0,p.A)({},Byp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Eyp.isMDXComponent=!0;const Oyp={toc:[]},Uyp="wrapper";function Fyp(e){let{components:n,...t}=e;return(0,s.yg)(Uyp,(0,p.A)({},Oyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Fyp.isMDXComponent=!0;const Vyp={toc:[]},qyp="wrapper";function jyp(e){let{components:n,...t}=e;return(0,s.yg)(qyp,(0,p.A)({},Vyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}jyp.isMDXComponent=!0;const Hyp={toc:[]},Yyp="wrapper";function Qyp(e){let{components:n,...t}=e;return(0,s.yg)(Yyp,(0,p.A)({},Hyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Qyp.isMDXComponent=!0;const $yp={toc:[]},Kyp="wrapper";function Jyp(e){let{components:n,...t}=e;return(0,s.yg)(Kyp,(0,p.A)({},$yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Jyp.isMDXComponent=!0;const Zyp={toc:[]},edp="wrapper";function ndp(e){let{components:n,...t}=e;return(0,s.yg)(edp,(0,p.A)({},Zyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}ndp.isMDXComponent=!0;const tdp={toc:[]},odp="wrapper";function pdp(e){let{components:n,...t}=e;return(0,s.yg)(odp,(0,p.A)({},tdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pdp.isMDXComponent=!0;const rdp={toc:[]},sdp="wrapper";function cdp(e){let{components:n,...t}=e;return(0,s.yg)(sdp,(0,p.A)({},rdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cdp.isMDXComponent=!0;const adp={toc:[]},idp="wrapper";function ldp(e){let{components:n,...t}=e;return(0,s.yg)(idp,(0,p.A)({},adp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}ldp.isMDXComponent=!0;const udp={toc:[]},mdp="wrapper";function ydp(e){let{components:n,...t}=e;return(0,s.yg)(mdp,(0,p.A)({},udp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ydp.isMDXComponent=!0;const ddp={toc:[]},hdp="wrapper";function gdp(e){let{components:n,...t}=e;return(0,s.yg)(hdp,(0,p.A)({},ddp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}gdp.isMDXComponent=!0;const fdp={toc:[]},Ddp="wrapper";function Mdp(e){let{components:n,...t}=e;return(0,s.yg)(Ddp,(0,p.A)({},fdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Mdp.isMDXComponent=!0;const Xdp={toc:[]},_dp="wrapper";function wdp(e){let{components:n,...t}=e;return(0,s.yg)(_dp,(0,p.A)({},Xdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}wdp.isMDXComponent=!0;const Tdp={toc:[]},Cdp="wrapper";function xdp(e){let{components:n,...t}=e;return(0,s.yg)(Cdp,(0,p.A)({},Tdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}xdp.isMDXComponent=!0;const Adp={toc:[]},vdp="wrapper";function Ldp(e){let{components:n,...t}=e;return(0,s.yg)(vdp,(0,p.A)({},Adp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ldp.isMDXComponent=!0;const bdp={toc:[]},Ndp="wrapper";function kdp(e){let{components:n,...t}=e;return(0,s.yg)(Ndp,(0,p.A)({},bdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}kdp.isMDXComponent=!0;const zdp={toc:[]},Pdp="wrapper";function Idp(e){let{components:n,...t}=e;return(0,s.yg)(Pdp,(0,p.A)({},zdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Idp.isMDXComponent=!0;const Rdp={toc:[]},Wdp="wrapper";function Sdp(e){let{components:n,...t}=e;return(0,s.yg)(Wdp,(0,p.A)({},Rdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Sdp.isMDXComponent=!0;const Bdp={toc:[]},Gdp="wrapper";function Edp(e){let{components:n,...t}=e;return(0,s.yg)(Gdp,(0,p.A)({},Bdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Edp.isMDXComponent=!0;const Odp={toc:[]},Udp="wrapper";function Fdp(e){let{components:n,...t}=e;return(0,s.yg)(Udp,(0,p.A)({},Odp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Fdp.isMDXComponent=!0;const Vdp={toc:[]},qdp="wrapper";function jdp(e){let{components:n,...t}=e;return(0,s.yg)(qdp,(0,p.A)({},Vdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}jdp.isMDXComponent=!0;const Hdp={toc:[]},Ydp="wrapper";function Qdp(e){let{components:n,...t}=e;return(0,s.yg)(Ydp,(0,p.A)({},Hdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Qdp.isMDXComponent=!0;const $dp={toc:[]},Kdp="wrapper";function Jdp(e){let{components:n,...t}=e;return(0,s.yg)(Kdp,(0,p.A)({},$dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Jdp.isMDXComponent=!0;const Zdp={toc:[]},ehp="wrapper";function nhp(e){let{components:n,...t}=e;return(0,s.yg)(ehp,(0,p.A)({},Zdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}nhp.isMDXComponent=!0;const thp={toc:[]},ohp="wrapper";function php(e){let{components:n,...t}=e;return(0,s.yg)(ohp,(0,p.A)({},thp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}php.isMDXComponent=!0;const rhp={toc:[]},shp="wrapper";function chp(e){let{components:n,...t}=e;return(0,s.yg)(shp,(0,p.A)({},rhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}chp.isMDXComponent=!0;const ahp={toc:[]},ihp="wrapper";function lhp(e){let{components:n,...t}=e;return(0,s.yg)(ihp,(0,p.A)({},ahp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}lhp.isMDXComponent=!0;const uhp={toc:[]},mhp="wrapper";function yhp(e){let{components:n,...t}=e;return(0,s.yg)(mhp,(0,p.A)({},uhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}yhp.isMDXComponent=!0;const dhp={toc:[]},hhp="wrapper";function ghp(e){let{components:n,...t}=e;return(0,s.yg)(hhp,(0,p.A)({},dhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}ghp.isMDXComponent=!0;const fhp={toc:[]},Dhp="wrapper";function Mhp(e){let{components:n,...t}=e;return(0,s.yg)(Dhp,(0,p.A)({},fhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Mhp.isMDXComponent=!0;const Xhp={toc:[]},_hp="wrapper";function whp(e){let{components:n,...t}=e;return(0,s.yg)(_hp,(0,p.A)({},Xhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}whp.isMDXComponent=!0;const Thp={toc:[]},Chp="wrapper";function xhp(e){let{components:n,...t}=e;return(0,s.yg)(Chp,(0,p.A)({},Thp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}xhp.isMDXComponent=!0;const Ahp={toc:[]},vhp="wrapper";function Lhp(e){let{components:n,...t}=e;return(0,s.yg)(vhp,(0,p.A)({},Ahp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Lhp.isMDXComponent=!0;const bhp={toc:[]},Nhp="wrapper";function khp(e){let{components:n,...t}=e;return(0,s.yg)(Nhp,(0,p.A)({},bhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}khp.isMDXComponent=!0;const zhp={toc:[]},Php="wrapper";function Ihp(e){let{components:n,...t}=e;return(0,s.yg)(Php,(0,p.A)({},zhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Ihp.isMDXComponent=!0;const Rhp={toc:[]},Whp="wrapper";function Shp(e){let{components:n,...t}=e;return(0,s.yg)(Whp,(0,p.A)({},Rhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Shp.isMDXComponent=!0;const Bhp={toc:[]},Ghp="wrapper";function Ehp(e){let{components:n,...t}=e;return(0,s.yg)(Ghp,(0,p.A)({},Bhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Ehp.isMDXComponent=!0;const Ohp={toc:[]},Uhp="wrapper";function Fhp(e){let{components:n,...t}=e;return(0,s.yg)(Uhp,(0,p.A)({},Ohp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Fhp.isMDXComponent=!0;const Vhp={toc:[]},qhp="wrapper";function jhp(e){let{components:n,...t}=e;return(0,s.yg)(qhp,(0,p.A)({},Vhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}jhp.isMDXComponent=!0;const Hhp={toc:[]},Yhp="wrapper";function Qhp(e){let{components:n,...t}=e;return(0,s.yg)(Yhp,(0,p.A)({},Hhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Qhp.isMDXComponent=!0;const $hp={toc:[]},Khp="wrapper";function Jhp(e){let{components:n,...t}=e;return(0,s.yg)(Khp,(0,p.A)({},$hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Jhp.isMDXComponent=!0;const Zhp={toc:[]},egp="wrapper";function ngp(e){let{components:n,...t}=e;return(0,s.yg)(egp,(0,p.A)({},Zhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ngp.isMDXComponent=!0;const tgp={toc:[]},ogp="wrapper";function pgp(e){let{components:n,...t}=e;return(0,s.yg)(ogp,(0,p.A)({},tgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}pgp.isMDXComponent=!0;const rgp={toc:[]},sgp="wrapper";function cgp(e){let{components:n,...t}=e;return(0,s.yg)(sgp,(0,p.A)({},rgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}cgp.isMDXComponent=!0;const agp={toc:[]},igp="wrapper";function lgp(e){let{components:n,...t}=e;return(0,s.yg)(igp,(0,p.A)({},agp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}lgp.isMDXComponent=!0;const ugp={toc:[]},mgp="wrapper";function ygp(e){let{components:n,...t}=e;return(0,s.yg)(mgp,(0,p.A)({},ugp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}ygp.isMDXComponent=!0;const dgp={toc:[]},hgp="wrapper";function ggp(e){let{components:n,...t}=e;return(0,s.yg)(hgp,(0,p.A)({},dgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ggp.isMDXComponent=!0;const fgp={toc:[]},Dgp="wrapper";function Mgp(e){let{components:n,...t}=e;return(0,s.yg)(Dgp,(0,p.A)({},fgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Mgp.isMDXComponent=!0;const Xgp={toc:[]},_gp="wrapper";function wgp(e){let{components:n,...t}=e;return(0,s.yg)(_gp,(0,p.A)({},Xgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}wgp.isMDXComponent=!0;const Tgp={toc:[]},Cgp="wrapper";function xgp(e){let{components:n,...t}=e;return(0,s.yg)(Cgp,(0,p.A)({},Tgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}xgp.isMDXComponent=!0;const Agp={toc:[]},vgp="wrapper";function Lgp(e){let{components:n,...t}=e;return(0,s.yg)(vgp,(0,p.A)({},Agp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Lgp.isMDXComponent=!0;const bgp={toc:[]},Ngp="wrapper";function kgp(e){let{components:n,...t}=e;return(0,s.yg)(Ngp,(0,p.A)({},bgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}kgp.isMDXComponent=!0;const zgp={toc:[]},Pgp="wrapper";function Igp(e){let{components:n,...t}=e;return(0,s.yg)(Pgp,(0,p.A)({},zgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Igp.isMDXComponent=!0;const Rgp={toc:[]},Wgp="wrapper";function Sgp(e){let{components:n,...t}=e;return(0,s.yg)(Wgp,(0,p.A)({},Rgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Sgp.isMDXComponent=!0;const Bgp={toc:[]},Ggp="wrapper";function Egp(e){let{components:n,...t}=e;return(0,s.yg)(Ggp,(0,p.A)({},Bgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Egp.isMDXComponent=!0;const Ogp={toc:[]},Ugp="wrapper";function Fgp(e){let{components:n,...t}=e;return(0,s.yg)(Ugp,(0,p.A)({},Ogp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Fgp.isMDXComponent=!0;const Vgp={toc:[]},qgp="wrapper";function jgp(e){let{components:n,...t}=e;return(0,s.yg)(qgp,(0,p.A)({},Vgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}jgp.isMDXComponent=!0;const Hgp={toc:[]},Ygp="wrapper";function Qgp(e){let{components:n,...t}=e;return(0,s.yg)(Ygp,(0,p.A)({},Hgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Qgp.isMDXComponent=!0;const $gp={toc:[]},Kgp="wrapper";function Jgp(e){let{components:n,...t}=e;return(0,s.yg)(Kgp,(0,p.A)({},$gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Jgp.isMDXComponent=!0;const Zgp={toc:[]},efp="wrapper";function nfp(e){let{components:n,...t}=e;return(0,s.yg)(efp,(0,p.A)({},Zgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}nfp.isMDXComponent=!0;const tfp={toc:[]},ofp="wrapper";function pfp(e){let{components:n,...t}=e;return(0,s.yg)(ofp,(0,p.A)({},tfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}pfp.isMDXComponent=!0;const rfp={toc:[]},sfp="wrapper";function cfp(e){let{components:n,...t}=e;return(0,s.yg)(sfp,(0,p.A)({},rfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}cfp.isMDXComponent=!0;const afp={toc:[]},ifp="wrapper";function lfp(e){let{components:n,...t}=e;return(0,s.yg)(ifp,(0,p.A)({},afp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lfp.isMDXComponent=!0;const ufp={toc:[]},mfp="wrapper";function yfp(e){let{components:n,...t}=e;return(0,s.yg)(mfp,(0,p.A)({},ufp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}yfp.isMDXComponent=!0;const dfp={toc:[]},hfp="wrapper";function gfp(e){let{components:n,...t}=e;return(0,s.yg)(hfp,(0,p.A)({},dfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}gfp.isMDXComponent=!0;const ffp={toc:[]},Dfp="wrapper";function Mfp(e){let{components:n,...t}=e;return(0,s.yg)(Dfp,(0,p.A)({},ffp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Mfp.isMDXComponent=!0;const Xfp={toc:[]},_fp="wrapper";function wfp(e){let{components:n,...t}=e;return(0,s.yg)(_fp,(0,p.A)({},Xfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wfp.isMDXComponent=!0;const Tfp={toc:[]},Cfp="wrapper";function xfp(e){let{components:n,...t}=e;return(0,s.yg)(Cfp,(0,p.A)({},Tfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}xfp.isMDXComponent=!0;const Afp={toc:[]},vfp="wrapper";function Lfp(e){let{components:n,...t}=e;return(0,s.yg)(vfp,(0,p.A)({},Afp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Lfp.isMDXComponent=!0;const bfp={toc:[]},Nfp="wrapper";function kfp(e){let{components:n,...t}=e;return(0,s.yg)(Nfp,(0,p.A)({},bfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kfp.isMDXComponent=!0;const zfp={toc:[]},Pfp="wrapper";function Ifp(e){let{components:n,...t}=e;return(0,s.yg)(Pfp,(0,p.A)({},zfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Ifp.isMDXComponent=!0;const Rfp={toc:[]},Wfp="wrapper";function Sfp(e){let{components:n,...t}=e;return(0,s.yg)(Wfp,(0,p.A)({},Rfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Sfp.isMDXComponent=!0;const Bfp={toc:[]},Gfp="wrapper";function Efp(e){let{components:n,...t}=e;return(0,s.yg)(Gfp,(0,p.A)({},Bfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Efp.isMDXComponent=!0;const Ofp={toc:[]},Ufp="wrapper";function Ffp(e){let{components:n,...t}=e;return(0,s.yg)(Ufp,(0,p.A)({},Ofp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ffp.isMDXComponent=!0;const Vfp={toc:[]},qfp="wrapper";function jfp(e){let{components:n,...t}=e;return(0,s.yg)(qfp,(0,p.A)({},Vfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}jfp.isMDXComponent=!0;const Hfp={toc:[]},Yfp="wrapper";function Qfp(e){let{components:n,...t}=e;return(0,s.yg)(Yfp,(0,p.A)({},Hfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Qfp.isMDXComponent=!0;const $fp={toc:[]},Kfp="wrapper";function Jfp(e){let{components:n,...t}=e;return(0,s.yg)(Kfp,(0,p.A)({},$fp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Jfp.isMDXComponent=!0;const Zfp={toc:[]},eDp="wrapper";function nDp(e){let{components:n,...t}=e;return(0,s.yg)(eDp,(0,p.A)({},Zfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nDp.isMDXComponent=!0;const tDp={toc:[]},oDp="wrapper";function pDp(e){let{components:n,...t}=e;return(0,s.yg)(oDp,(0,p.A)({},tDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}pDp.isMDXComponent=!0;const rDp={toc:[]},sDp="wrapper";function cDp(e){let{components:n,...t}=e;return(0,s.yg)(sDp,(0,p.A)({},rDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}cDp.isMDXComponent=!0;const aDp={toc:[]},iDp="wrapper";function lDp(e){let{components:n,...t}=e;return(0,s.yg)(iDp,(0,p.A)({},aDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}lDp.isMDXComponent=!0;const uDp={toc:[]},mDp="wrapper";function yDp(e){let{components:n,...t}=e;return(0,s.yg)(mDp,(0,p.A)({},uDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}yDp.isMDXComponent=!0;const dDp={toc:[]},hDp="wrapper";function gDp(e){let{components:n,...t}=e;return(0,s.yg)(hDp,(0,p.A)({},dDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}gDp.isMDXComponent=!0;const fDp={toc:[]},DDp="wrapper";function MDp(e){let{components:n,...t}=e;return(0,s.yg)(DDp,(0,p.A)({},fDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}MDp.isMDXComponent=!0;const XDp={toc:[]},_Dp="wrapper";function wDp(e){let{components:n,...t}=e;return(0,s.yg)(_Dp,(0,p.A)({},XDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}wDp.isMDXComponent=!0;const TDp={toc:[]},CDp="wrapper";function xDp(e){let{components:n,...t}=e;return(0,s.yg)(CDp,(0,p.A)({},TDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}xDp.isMDXComponent=!0;const ADp={toc:[]},vDp="wrapper";function LDp(e){let{components:n,...t}=e;return(0,s.yg)(vDp,(0,p.A)({},ADp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}LDp.isMDXComponent=!0;const bDp={toc:[]},NDp="wrapper";function kDp(e){let{components:n,...t}=e;return(0,s.yg)(NDp,(0,p.A)({},bDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}kDp.isMDXComponent=!0;const zDp={toc:[]},PDp="wrapper";function IDp(e){let{components:n,...t}=e;return(0,s.yg)(PDp,(0,p.A)({},zDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}IDp.isMDXComponent=!0;const RDp={toc:[]},WDp="wrapper";function SDp(e){let{components:n,...t}=e;return(0,s.yg)(WDp,(0,p.A)({},RDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SDp.isMDXComponent=!0;const BDp={toc:[]},GDp="wrapper";function EDp(e){let{components:n,...t}=e;return(0,s.yg)(GDp,(0,p.A)({},BDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}EDp.isMDXComponent=!0;const ODp={toc:[]},UDp="wrapper";function FDp(e){let{components:n,...t}=e;return(0,s.yg)(UDp,(0,p.A)({},ODp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}FDp.isMDXComponent=!0;const VDp={toc:[]},qDp="wrapper";function jDp(e){let{components:n,...t}=e;return(0,s.yg)(qDp,(0,p.A)({},VDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}jDp.isMDXComponent=!0;const HDp={toc:[]},YDp="wrapper";function QDp(e){let{components:n,...t}=e;return(0,s.yg)(YDp,(0,p.A)({},HDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}QDp.isMDXComponent=!0;const $Dp={toc:[]},KDp="wrapper";function JDp(e){let{components:n,...t}=e;return(0,s.yg)(KDp,(0,p.A)({},$Dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}JDp.isMDXComponent=!0;const ZDp={toc:[]},eMp="wrapper";function nMp(e){let{components:n,...t}=e;return(0,s.yg)(eMp,(0,p.A)({},ZDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}nMp.isMDXComponent=!0;const tMp={toc:[]},oMp="wrapper";function pMp(e){let{components:n,...t}=e;return(0,s.yg)(oMp,(0,p.A)({},tMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}pMp.isMDXComponent=!0;const rMp={toc:[]},sMp="wrapper";function cMp(e){let{components:n,...t}=e;return(0,s.yg)(sMp,(0,p.A)({},rMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}cMp.isMDXComponent=!0;const aMp={toc:[]},iMp="wrapper";function lMp(e){let{components:n,...t}=e;return(0,s.yg)(iMp,(0,p.A)({},aMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lMp.isMDXComponent=!0;const uMp={toc:[]},mMp="wrapper";function yMp(e){let{components:n,...t}=e;return(0,s.yg)(mMp,(0,p.A)({},uMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}yMp.isMDXComponent=!0;const dMp={toc:[]},hMp="wrapper";function gMp(e){let{components:n,...t}=e;return(0,s.yg)(hMp,(0,p.A)({},dMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}gMp.isMDXComponent=!0;const fMp={toc:[]},DMp="wrapper";function MMp(e){let{components:n,...t}=e;return(0,s.yg)(DMp,(0,p.A)({},fMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}MMp.isMDXComponent=!0;const XMp={toc:[]},_Mp="wrapper";function wMp(e){let{components:n,...t}=e;return(0,s.yg)(_Mp,(0,p.A)({},XMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}wMp.isMDXComponent=!0;const TMp={toc:[]},CMp="wrapper";function xMp(e){let{components:n,...t}=e;return(0,s.yg)(CMp,(0,p.A)({},TMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}xMp.isMDXComponent=!0;const AMp={toc:[]},vMp="wrapper";function LMp(e){let{components:n,...t}=e;return(0,s.yg)(vMp,(0,p.A)({},AMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}LMp.isMDXComponent=!0;const bMp={toc:[]},NMp="wrapper";function kMp(e){let{components:n,...t}=e;return(0,s.yg)(NMp,(0,p.A)({},bMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}kMp.isMDXComponent=!0;const zMp={toc:[]},PMp="wrapper";function IMp(e){let{components:n,...t}=e;return(0,s.yg)(PMp,(0,p.A)({},zMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}IMp.isMDXComponent=!0;const RMp={toc:[]},WMp="wrapper";function SMp(e){let{components:n,...t}=e;return(0,s.yg)(WMp,(0,p.A)({},RMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}SMp.isMDXComponent=!0;const BMp={toc:[]},GMp="wrapper";function EMp(e){let{components:n,...t}=e;return(0,s.yg)(GMp,(0,p.A)({},BMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}EMp.isMDXComponent=!0;const OMp={toc:[]},UMp="wrapper";function FMp(e){let{components:n,...t}=e;return(0,s.yg)(UMp,(0,p.A)({},OMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}FMp.isMDXComponent=!0;const VMp={toc:[]},qMp="wrapper";function jMp(e){let{components:n,...t}=e;return(0,s.yg)(qMp,(0,p.A)({},VMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jMp.isMDXComponent=!0;const HMp={toc:[]},YMp="wrapper";function QMp(e){let{components:n,...t}=e;return(0,s.yg)(YMp,(0,p.A)({},HMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}QMp.isMDXComponent=!0;const $Mp={toc:[]},KMp="wrapper";function JMp(e){let{components:n,...t}=e;return(0,s.yg)(KMp,(0,p.A)({},$Mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}JMp.isMDXComponent=!0;const ZMp={toc:[]},eXp="wrapper";function nXp(e){let{components:n,...t}=e;return(0,s.yg)(eXp,(0,p.A)({},ZMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}nXp.isMDXComponent=!0;const tXp={toc:[]},oXp="wrapper";function pXp(e){let{components:n,...t}=e;return(0,s.yg)(oXp,(0,p.A)({},tXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}pXp.isMDXComponent=!0;const rXp={toc:[]},sXp="wrapper";function cXp(e){let{components:n,...t}=e;return(0,s.yg)(sXp,(0,p.A)({},rXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}cXp.isMDXComponent=!0;const aXp={toc:[]},iXp="wrapper";function lXp(e){let{components:n,...t}=e;return(0,s.yg)(iXp,(0,p.A)({},aXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lXp.isMDXComponent=!0;const uXp={toc:[]},mXp="wrapper";function yXp(e){let{components:n,...t}=e;return(0,s.yg)(mXp,(0,p.A)({},uXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}yXp.isMDXComponent=!0;const dXp={toc:[]},hXp="wrapper";function gXp(e){let{components:n,...t}=e;return(0,s.yg)(hXp,(0,p.A)({},dXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}gXp.isMDXComponent=!0;const fXp={toc:[]},DXp="wrapper";function MXp(e){let{components:n,...t}=e;return(0,s.yg)(DXp,(0,p.A)({},fXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}MXp.isMDXComponent=!0;const XXp={toc:[]},_Xp="wrapper";function wXp(e){let{components:n,...t}=e;return(0,s.yg)(_Xp,(0,p.A)({},XXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}wXp.isMDXComponent=!0;const TXp={toc:[]},CXp="wrapper";function xXp(e){let{components:n,...t}=e;return(0,s.yg)(CXp,(0,p.A)({},TXp,t,{components:n,mdxType:"MDXLayout"}))}xXp.isMDXComponent=!0;const AXp={toc:[]},vXp="wrapper";function LXp(e){let{components:n,...t}=e;return(0,s.yg)(vXp,(0,p.A)({},AXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}LXp.isMDXComponent=!0;const bXp={toc:[]},NXp="wrapper";function kXp(e){let{components:n,...t}=e;return(0,s.yg)(NXp,(0,p.A)({},bXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}kXp.isMDXComponent=!0;const zXp={toc:[]},PXp="wrapper";function IXp(e){let{components:n,...t}=e;return(0,s.yg)(PXp,(0,p.A)({},zXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}IXp.isMDXComponent=!0;const RXp={toc:[]},WXp="wrapper";function SXp(e){let{components:n,...t}=e;return(0,s.yg)(WXp,(0,p.A)({},RXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}SXp.isMDXComponent=!0;const BXp={toc:[]},GXp="wrapper";function EXp(e){let{components:n,...t}=e;return(0,s.yg)(GXp,(0,p.A)({},BXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}EXp.isMDXComponent=!0;const OXp={toc:[]},UXp="wrapper";function FXp(e){let{components:n,...t}=e;return(0,s.yg)(UXp,(0,p.A)({},OXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}FXp.isMDXComponent=!0;const VXp={toc:[]},qXp="wrapper";function jXp(e){let{components:n,...t}=e;return(0,s.yg)(qXp,(0,p.A)({},VXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}jXp.isMDXComponent=!0;const HXp={toc:[]},YXp="wrapper";function QXp(e){let{components:n,...t}=e;return(0,s.yg)(YXp,(0,p.A)({},HXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}QXp.isMDXComponent=!0;const $Xp={toc:[]},KXp="wrapper";function JXp(e){let{components:n,...t}=e;return(0,s.yg)(KXp,(0,p.A)({},$Xp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}JXp.isMDXComponent=!0;const ZXp={toc:[]},e_p="wrapper";function n_p(e){let{components:n,...t}=e;return(0,s.yg)(e_p,(0,p.A)({},ZXp,t,{components:n,mdxType:"MDXLayout"}))}n_p.isMDXComponent=!0;const t_p={toc:[]},o_p="wrapper";function p_p(e){let{components:n,...t}=e;return(0,s.yg)(o_p,(0,p.A)({},t_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}p_p.isMDXComponent=!0;const r_p={toc:[]},s_p="wrapper";function c_p(e){let{components:n,...t}=e;return(0,s.yg)(s_p,(0,p.A)({},r_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}c_p.isMDXComponent=!0;const a_p={toc:[]},i_p="wrapper";function l_p(e){let{components:n,...t}=e;return(0,s.yg)(i_p,(0,p.A)({},a_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}l_p.isMDXComponent=!0;const u_p={toc:[]},m_p="wrapper";function y_p(e){let{components:n,...t}=e;return(0,s.yg)(m_p,(0,p.A)({},u_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}y_p.isMDXComponent=!0;const d_p={toc:[]},h_p="wrapper";function g_p(e){let{components:n,...t}=e;return(0,s.yg)(h_p,(0,p.A)({},d_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}g_p.isMDXComponent=!0;const f_p={toc:[]},D_p="wrapper";function M_p(e){let{components:n,...t}=e;return(0,s.yg)(D_p,(0,p.A)({},f_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}M_p.isMDXComponent=!0;const X_p={toc:[]},__p="wrapper";function w_p(e){let{components:n,...t}=e;return(0,s.yg)(__p,(0,p.A)({},X_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}w_p.isMDXComponent=!0;const T_p={toc:[]},C_p="wrapper";function x_p(e){let{components:n,...t}=e;return(0,s.yg)(C_p,(0,p.A)({},T_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}x_p.isMDXComponent=!0;const A_p={toc:[]},v_p="wrapper";function L_p(e){let{components:n,...t}=e;return(0,s.yg)(v_p,(0,p.A)({},A_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}L_p.isMDXComponent=!0;const b_p={toc:[]},N_p="wrapper";function k_p(e){let{components:n,...t}=e;return(0,s.yg)(N_p,(0,p.A)({},b_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}k_p.isMDXComponent=!0;const z_p={toc:[]},P_p="wrapper";function I_p(e){let{components:n,...t}=e;return(0,s.yg)(P_p,(0,p.A)({},z_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}I_p.isMDXComponent=!0;const R_p={toc:[]},W_p="wrapper";function S_p(e){let{components:n,...t}=e;return(0,s.yg)(W_p,(0,p.A)({},R_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}S_p.isMDXComponent=!0;const B_p={toc:[]},G_p="wrapper";function E_p(e){let{components:n,...t}=e;return(0,s.yg)(G_p,(0,p.A)({},B_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}E_p.isMDXComponent=!0;const O_p={toc:[]},U_p="wrapper";function F_p(e){let{components:n,...t}=e;return(0,s.yg)(U_p,(0,p.A)({},O_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}F_p.isMDXComponent=!0;const V_p={toc:[]},q_p="wrapper";function j_p(e){let{components:n,...t}=e;return(0,s.yg)(q_p,(0,p.A)({},V_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}j_p.isMDXComponent=!0;const H_p={toc:[]},Y_p="wrapper";function Q_p(e){let{components:n,...t}=e;return(0,s.yg)(Y_p,(0,p.A)({},H_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Q_p.isMDXComponent=!0;const $_p={toc:[]},K_p="wrapper";function J_p(e){let{components:n,...t}=e;return(0,s.yg)(K_p,(0,p.A)({},$_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}J_p.isMDXComponent=!0;const Z_p={toc:[]},ewp="wrapper";function nwp(e){let{components:n,...t}=e;return(0,s.yg)(ewp,(0,p.A)({},Z_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}nwp.isMDXComponent=!0;const twp={toc:[]},owp="wrapper";function pwp(e){let{components:n,...t}=e;return(0,s.yg)(owp,(0,p.A)({},twp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pwp.isMDXComponent=!0;const rwp={toc:[]},swp="wrapper";function cwp(e){let{components:n,...t}=e;return(0,s.yg)(swp,(0,p.A)({},rwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}cwp.isMDXComponent=!0;const awp={toc:[]},iwp="wrapper";function lwp(e){let{components:n,...t}=e;return(0,s.yg)(iwp,(0,p.A)({},awp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}lwp.isMDXComponent=!0;const uwp={toc:[]},mwp="wrapper";function ywp(e){let{components:n,...t}=e;return(0,s.yg)(mwp,(0,p.A)({},uwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}ywp.isMDXComponent=!0;const dwp={toc:[]},hwp="wrapper";function gwp(e){let{components:n,...t}=e;return(0,s.yg)(hwp,(0,p.A)({},dwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}gwp.isMDXComponent=!0;const fwp={toc:[]},Dwp="wrapper";function Mwp(e){let{components:n,...t}=e;return(0,s.yg)(Dwp,(0,p.A)({},fwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Mwp.isMDXComponent=!0;const Xwp={toc:[]},_wp="wrapper";function wwp(e){let{components:n,...t}=e;return(0,s.yg)(_wp,(0,p.A)({},Xwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}wwp.isMDXComponent=!0;const Twp={toc:[]},Cwp="wrapper";function xwp(e){let{components:n,...t}=e;return(0,s.yg)(Cwp,(0,p.A)({},Twp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}xwp.isMDXComponent=!0;const Awp={toc:[]},vwp="wrapper";function Lwp(e){let{components:n,...t}=e;return(0,s.yg)(vwp,(0,p.A)({},Awp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Lwp.isMDXComponent=!0;const bwp={toc:[]},Nwp="wrapper";function kwp(e){let{components:n,...t}=e;return(0,s.yg)(Nwp,(0,p.A)({},bwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kwp.isMDXComponent=!0;const zwp={toc:[]},Pwp="wrapper";function Iwp(e){let{components:n,...t}=e;return(0,s.yg)(Pwp,(0,p.A)({},zwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Iwp.isMDXComponent=!0;const Rwp={toc:[]},Wwp="wrapper";function Swp(e){let{components:n,...t}=e;return(0,s.yg)(Wwp,(0,p.A)({},Rwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Swp.isMDXComponent=!0;const Bwp={toc:[]},Gwp="wrapper";function Ewp(e){let{components:n,...t}=e;return(0,s.yg)(Gwp,(0,p.A)({},Bwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Ewp.isMDXComponent=!0;const Owp={toc:[]},Uwp="wrapper";function Fwp(e){let{components:n,...t}=e;return(0,s.yg)(Uwp,(0,p.A)({},Owp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Fwp.isMDXComponent=!0;const Vwp={toc:[]},qwp="wrapper";function jwp(e){let{components:n,...t}=e;return(0,s.yg)(qwp,(0,p.A)({},Vwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}jwp.isMDXComponent=!0;const Hwp={toc:[]},Ywp="wrapper";function Qwp(e){let{components:n,...t}=e;return(0,s.yg)(Ywp,(0,p.A)({},Hwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Qwp.isMDXComponent=!0;const $wp={toc:[]},Kwp="wrapper";function Jwp(e){let{components:n,...t}=e;return(0,s.yg)(Kwp,(0,p.A)({},$wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Jwp.isMDXComponent=!0;const Zwp={toc:[]},eTp="wrapper";function nTp(e){let{components:n,...t}=e;return(0,s.yg)(eTp,(0,p.A)({},Zwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}nTp.isMDXComponent=!0;const tTp={toc:[]},oTp="wrapper";function pTp(e){let{components:n,...t}=e;return(0,s.yg)(oTp,(0,p.A)({},tTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}pTp.isMDXComponent=!0;const rTp={toc:[]},sTp="wrapper";function cTp(e){let{components:n,...t}=e;return(0,s.yg)(sTp,(0,p.A)({},rTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}cTp.isMDXComponent=!0;const aTp={toc:[]},iTp="wrapper";function lTp(e){let{components:n,...t}=e;return(0,s.yg)(iTp,(0,p.A)({},aTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lTp.isMDXComponent=!0;const uTp={toc:[]},mTp="wrapper";function yTp(e){let{components:n,...t}=e;return(0,s.yg)(mTp,(0,p.A)({},uTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}yTp.isMDXComponent=!0;const dTp={toc:[]},hTp="wrapper";function gTp(e){let{components:n,...t}=e;return(0,s.yg)(hTp,(0,p.A)({},dTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}gTp.isMDXComponent=!0;const fTp={toc:[]},DTp="wrapper";function MTp(e){let{components:n,...t}=e;return(0,s.yg)(DTp,(0,p.A)({},fTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}MTp.isMDXComponent=!0;const XTp={toc:[]},_Tp="wrapper";function wTp(e){let{components:n,...t}=e;return(0,s.yg)(_Tp,(0,p.A)({},XTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}wTp.isMDXComponent=!0;const TTp={toc:[]},CTp="wrapper";function xTp(e){let{components:n,...t}=e;return(0,s.yg)(CTp,(0,p.A)({},TTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}xTp.isMDXComponent=!0;const ATp={toc:[]},vTp="wrapper";function LTp(e){let{components:n,...t}=e;return(0,s.yg)(vTp,(0,p.A)({},ATp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}LTp.isMDXComponent=!0;const bTp={toc:[]},NTp="wrapper";function kTp(e){let{components:n,...t}=e;return(0,s.yg)(NTp,(0,p.A)({},bTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}kTp.isMDXComponent=!0;const zTp={toc:[]},PTp="wrapper";function ITp(e){let{components:n,...t}=e;return(0,s.yg)(PTp,(0,p.A)({},zTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}ITp.isMDXComponent=!0;const RTp={toc:[]},WTp="wrapper";function STp(e){let{components:n,...t}=e;return(0,s.yg)(WTp,(0,p.A)({},RTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}STp.isMDXComponent=!0;const BTp={toc:[]},GTp="wrapper";function ETp(e){let{components:n,...t}=e;return(0,s.yg)(GTp,(0,p.A)({},BTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ETp.isMDXComponent=!0;const OTp={toc:[]},UTp="wrapper";function FTp(e){let{components:n,...t}=e;return(0,s.yg)(UTp,(0,p.A)({},OTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}FTp.isMDXComponent=!0;const VTp={toc:[]},qTp="wrapper";function jTp(e){let{components:n,...t}=e;return(0,s.yg)(qTp,(0,p.A)({},VTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}jTp.isMDXComponent=!0;const HTp={toc:[]},YTp="wrapper";function QTp(e){let{components:n,...t}=e;return(0,s.yg)(YTp,(0,p.A)({},HTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}QTp.isMDXComponent=!0;const $Tp={toc:[]},KTp="wrapper";function JTp(e){let{components:n,...t}=e;return(0,s.yg)(KTp,(0,p.A)({},$Tp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}JTp.isMDXComponent=!0;const ZTp={toc:[]},eCp="wrapper";function nCp(e){let{components:n,...t}=e;return(0,s.yg)(eCp,(0,p.A)({},ZTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nCp.isMDXComponent=!0;const tCp={toc:[]},oCp="wrapper";function pCp(e){let{components:n,...t}=e;return(0,s.yg)(oCp,(0,p.A)({},tCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}pCp.isMDXComponent=!0;const rCp={toc:[]},sCp="wrapper";function cCp(e){let{components:n,...t}=e;return(0,s.yg)(sCp,(0,p.A)({},rCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cCp.isMDXComponent=!0;const aCp={toc:[]},iCp="wrapper";function lCp(e){let{components:n,...t}=e;return(0,s.yg)(iCp,(0,p.A)({},aCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lCp.isMDXComponent=!0;const uCp={toc:[]},mCp="wrapper";function yCp(e){let{components:n,...t}=e;return(0,s.yg)(mCp,(0,p.A)({},uCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yCp.isMDXComponent=!0;const dCp={toc:[]},hCp="wrapper";function gCp(e){let{components:n,...t}=e;return(0,s.yg)(hCp,(0,p.A)({},dCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}gCp.isMDXComponent=!0;const fCp={toc:[]},DCp="wrapper";function MCp(e){let{components:n,...t}=e;return(0,s.yg)(DCp,(0,p.A)({},fCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}MCp.isMDXComponent=!0;const XCp={toc:[]},_Cp="wrapper";function wCp(e){let{components:n,...t}=e;return(0,s.yg)(_Cp,(0,p.A)({},XCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}wCp.isMDXComponent=!0;const TCp={toc:[]},CCp="wrapper";function xCp(e){let{components:n,...t}=e;return(0,s.yg)(CCp,(0,p.A)({},TCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xCp.isMDXComponent=!0;const ACp={toc:[]},vCp="wrapper";function LCp(e){let{components:n,...t}=e;return(0,s.yg)(vCp,(0,p.A)({},ACp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}LCp.isMDXComponent=!0;const bCp={toc:[]},NCp="wrapper";function kCp(e){let{components:n,...t}=e;return(0,s.yg)(NCp,(0,p.A)({},bCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kCp.isMDXComponent=!0;const zCp={toc:[]},PCp="wrapper";function ICp(e){let{components:n,...t}=e;return(0,s.yg)(PCp,(0,p.A)({},zCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find a node by its key."))}ICp.isMDXComponent=!0;const RCp={toc:[]},WCp="wrapper";function SCp(e){let{components:n,...t}=e;return(0,s.yg)(WCp,(0,p.A)({},RCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The key of the node."))}SCp.isMDXComponent=!0;const BCp={toc:[]},GCp="wrapper";function ECp(e){let{components:n,...t}=e;return(0,s.yg)(GCp,(0,p.A)({},BCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}ECp.isMDXComponent=!0;const OCp={toc:[]},UCp="wrapper";function FCp(e){let{components:n,...t}=e;return(0,s.yg)(UCp,(0,p.A)({},OCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}FCp.isMDXComponent=!0;const VCp={toc:[]},qCp="wrapper";function jCp(e){let{components:n,...t}=e;return(0,s.yg)(qCp,(0,p.A)({},VCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}jCp.isMDXComponent=!0;const HCp={toc:[]},YCp="wrapper";function QCp(e){let{components:n,...t}=e;return(0,s.yg)(YCp,(0,p.A)({},HCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}QCp.isMDXComponent=!0;const $Cp={toc:[]},KCp="wrapper";function JCp(e){let{components:n,...t}=e;return(0,s.yg)(KCp,(0,p.A)({},$Cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}JCp.isMDXComponent=!0;const ZCp={toc:[]},exp="wrapper";function nxp(e){let{components:n,...t}=e;return(0,s.yg)(exp,(0,p.A)({},ZCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nxp.isMDXComponent=!0;const txp={toc:[]},oxp="wrapper";function pxp(e){let{components:n,...t}=e;return(0,s.yg)(oxp,(0,p.A)({},txp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}pxp.isMDXComponent=!0;const rxp={toc:[]},sxp="wrapper";function cxp(e){let{components:n,...t}=e;return(0,s.yg)(sxp,(0,p.A)({},rxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}cxp.isMDXComponent=!0;const axp={toc:[]},ixp="wrapper";function lxp(e){let{components:n,...t}=e;return(0,s.yg)(ixp,(0,p.A)({},axp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lxp.isMDXComponent=!0;const uxp={toc:[]},mxp="wrapper";function yxp(e){let{components:n,...t}=e;return(0,s.yg)(mxp,(0,p.A)({},uxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}yxp.isMDXComponent=!0;const dxp={toc:[]},hxp="wrapper";function gxp(e){let{components:n,...t}=e;return(0,s.yg)(hxp,(0,p.A)({},dxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}gxp.isMDXComponent=!0;const fxp={toc:[]},Dxp="wrapper";function Mxp(e){let{components:n,...t}=e;return(0,s.yg)(Dxp,(0,p.A)({},fxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Mxp.isMDXComponent=!0;const Xxp={toc:[]},_xp="wrapper";function wxp(e){let{components:n,...t}=e;return(0,s.yg)(_xp,(0,p.A)({},Xxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wxp.isMDXComponent=!0;const Txp={toc:[]},Cxp="wrapper";function xxp(e){let{components:n,...t}=e;return(0,s.yg)(Cxp,(0,p.A)({},Txp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}xxp.isMDXComponent=!0;const Axp={toc:[]},vxp="wrapper";function Lxp(e){let{components:n,...t}=e;return(0,s.yg)(vxp,(0,p.A)({},Axp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Lxp.isMDXComponent=!0;const bxp={toc:[]},Nxp="wrapper";function kxp(e){let{components:n,...t}=e;return(0,s.yg)(Nxp,(0,p.A)({},bxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}kxp.isMDXComponent=!0;const zxp={toc:[]},Pxp="wrapper";function Ixp(e){let{components:n,...t}=e;return(0,s.yg)(Pxp,(0,p.A)({},zxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Ixp.isMDXComponent=!0;const Rxp={toc:[]},Wxp="wrapper";function Sxp(e){let{components:n,...t}=e;return(0,s.yg)(Wxp,(0,p.A)({},Rxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Sxp.isMDXComponent=!0;const Bxp={toc:[]},Gxp="wrapper";function Exp(e){let{components:n,...t}=e;return(0,s.yg)(Gxp,(0,p.A)({},Bxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Exp.isMDXComponent=!0;const Oxp={toc:[]},Uxp="wrapper";function Fxp(e){let{components:n,...t}=e;return(0,s.yg)(Uxp,(0,p.A)({},Oxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Fxp.isMDXComponent=!0;const Vxp={toc:[]},qxp="wrapper";function jxp(e){let{components:n,...t}=e;return(0,s.yg)(qxp,(0,p.A)({},Vxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jxp.isMDXComponent=!0;const Hxp={toc:[]},Yxp="wrapper";function Qxp(e){let{components:n,...t}=e;return(0,s.yg)(Yxp,(0,p.A)({},Hxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Qxp.isMDXComponent=!0;const $xp={toc:[]},Kxp="wrapper";function Jxp(e){let{components:n,...t}=e;return(0,s.yg)(Kxp,(0,p.A)({},$xp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Jxp.isMDXComponent=!0;const Zxp={toc:[]},eAp="wrapper";function nAp(e){let{components:n,...t}=e;return(0,s.yg)(eAp,(0,p.A)({},Zxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nAp.isMDXComponent=!0;const tAp={toc:[]},oAp="wrapper";function pAp(e){let{components:n,...t}=e;return(0,s.yg)(oAp,(0,p.A)({},tAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}pAp.isMDXComponent=!0;const rAp={toc:[]},sAp="wrapper";function cAp(e){let{components:n,...t}=e;return(0,s.yg)(sAp,(0,p.A)({},rAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cAp.isMDXComponent=!0;const aAp={toc:[]},iAp="wrapper";function lAp(e){let{components:n,...t}=e;return(0,s.yg)(iAp,(0,p.A)({},aAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}lAp.isMDXComponent=!0;const uAp={toc:[]},mAp="wrapper";function yAp(e){let{components:n,...t}=e;return(0,s.yg)(mAp,(0,p.A)({},uAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}yAp.isMDXComponent=!0;const dAp={toc:[]},hAp="wrapper";function gAp(e){let{components:n,...t}=e;return(0,s.yg)(hAp,(0,p.A)({},dAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}gAp.isMDXComponent=!0;const fAp={toc:[]},DAp="wrapper";function MAp(e){let{components:n,...t}=e;return(0,s.yg)(DAp,(0,p.A)({},fAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}MAp.isMDXComponent=!0;const XAp={toc:[]},_Ap="wrapper";function wAp(e){let{components:n,...t}=e;return(0,s.yg)(_Ap,(0,p.A)({},XAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}wAp.isMDXComponent=!0;const TAp={toc:[]},CAp="wrapper";function xAp(e){let{components:n,...t}=e;return(0,s.yg)(CAp,(0,p.A)({},TAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xAp.isMDXComponent=!0;const AAp={toc:[]},vAp="wrapper";function LAp(e){let{components:n,...t}=e;return(0,s.yg)(vAp,(0,p.A)({},AAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LAp.isMDXComponent=!0;const bAp={toc:[]},NAp="wrapper";function kAp(e){let{components:n,...t}=e;return(0,s.yg)(NAp,(0,p.A)({},bAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}kAp.isMDXComponent=!0;const zAp={toc:[]},PAp="wrapper";function IAp(e){let{components:n,...t}=e;return(0,s.yg)(PAp,(0,p.A)({},zAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}IAp.isMDXComponent=!0;const RAp={toc:[]},WAp="wrapper";function SAp(e){let{components:n,...t}=e;return(0,s.yg)(WAp,(0,p.A)({},RAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}SAp.isMDXComponent=!0;const BAp={toc:[]},GAp="wrapper";function EAp(e){let{components:n,...t}=e;return(0,s.yg)(GAp,(0,p.A)({},BAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}EAp.isMDXComponent=!0;const OAp={toc:[]},UAp="wrapper";function FAp(e){let{components:n,...t}=e;return(0,s.yg)(UAp,(0,p.A)({},OAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}FAp.isMDXComponent=!0;const VAp={toc:[]},qAp="wrapper";function jAp(e){let{components:n,...t}=e;return(0,s.yg)(qAp,(0,p.A)({},VAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}jAp.isMDXComponent=!0;const HAp={toc:[]},YAp="wrapper";function QAp(e){let{components:n,...t}=e;return(0,s.yg)(YAp,(0,p.A)({},HAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}QAp.isMDXComponent=!0;const $Ap={toc:[]},KAp="wrapper";function JAp(e){let{components:n,...t}=e;return(0,s.yg)(KAp,(0,p.A)({},$Ap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}JAp.isMDXComponent=!0;const ZAp={toc:[]},evp="wrapper";function nvp(e){let{components:n,...t}=e;return(0,s.yg)(evp,(0,p.A)({},ZAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}nvp.isMDXComponent=!0;const tvp={toc:[]},ovp="wrapper";function pvp(e){let{components:n,...t}=e;return(0,s.yg)(ovp,(0,p.A)({},tvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}pvp.isMDXComponent=!0;const rvp={toc:[]},svp="wrapper";function cvp(e){let{components:n,...t}=e;return(0,s.yg)(svp,(0,p.A)({},rvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cvp.isMDXComponent=!0;const avp={toc:[]},ivp="wrapper";function lvp(e){let{components:n,...t}=e;return(0,s.yg)(ivp,(0,p.A)({},avp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}lvp.isMDXComponent=!0;const uvp={toc:[]},mvp="wrapper";function yvp(e){let{components:n,...t}=e;return(0,s.yg)(mvp,(0,p.A)({},uvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yvp.isMDXComponent=!0;const dvp={toc:[]},hvp="wrapper";function gvp(e){let{components:n,...t}=e;return(0,s.yg)(hvp,(0,p.A)({},dvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}gvp.isMDXComponent=!0;const fvp={toc:[]},Dvp="wrapper";function Mvp(e){let{components:n,...t}=e;return(0,s.yg)(Dvp,(0,p.A)({},fvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Mvp.isMDXComponent=!0;const Xvp={toc:[]},_vp="wrapper";function wvp(e){let{components:n,...t}=e;return(0,s.yg)(_vp,(0,p.A)({},Xvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}wvp.isMDXComponent=!0;const Tvp={toc:[]},Cvp="wrapper";function xvp(e){let{components:n,...t}=e;return(0,s.yg)(Cvp,(0,p.A)({},Tvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}xvp.isMDXComponent=!0;const Avp={toc:[]},vvp="wrapper";function Lvp(e){let{components:n,...t}=e;return(0,s.yg)(vvp,(0,p.A)({},Avp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Lvp.isMDXComponent=!0;const bvp={toc:[]},Nvp="wrapper";function kvp(e){let{components:n,...t}=e;return(0,s.yg)(Nvp,(0,p.A)({},bvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}kvp.isMDXComponent=!0;const zvp={toc:[]},Pvp="wrapper";function Ivp(e){let{components:n,...t}=e;return(0,s.yg)(Pvp,(0,p.A)({},zvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Ivp.isMDXComponent=!0;const Rvp={toc:[]},Wvp="wrapper";function Svp(e){let{components:n,...t}=e;return(0,s.yg)(Wvp,(0,p.A)({},Rvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Svp.isMDXComponent=!0;const Bvp={toc:[]},Gvp="wrapper";function Evp(e){let{components:n,...t}=e;return(0,s.yg)(Gvp,(0,p.A)({},Bvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Evp.isMDXComponent=!0;const Ovp={toc:[]},Uvp="wrapper";function Fvp(e){let{components:n,...t}=e;return(0,s.yg)(Uvp,(0,p.A)({},Ovp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Fvp.isMDXComponent=!0;const Vvp={toc:[]},qvp="wrapper";function jvp(e){let{components:n,...t}=e;return(0,s.yg)(qvp,(0,p.A)({},Vvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}jvp.isMDXComponent=!0;const Hvp={toc:[]},Yvp="wrapper";function Qvp(e){let{components:n,...t}=e;return(0,s.yg)(Yvp,(0,p.A)({},Hvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Qvp.isMDXComponent=!0;const $vp={toc:[]},Kvp="wrapper";function Jvp(e){let{components:n,...t}=e;return(0,s.yg)(Kvp,(0,p.A)({},$vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Jvp.isMDXComponent=!0;const Zvp={toc:[]},eLp="wrapper";function nLp(e){let{components:n,...t}=e;return(0,s.yg)(eLp,(0,p.A)({},Zvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nLp.isMDXComponent=!0;const tLp={toc:[]},oLp="wrapper";function pLp(e){let{components:n,...t}=e;return(0,s.yg)(oLp,(0,p.A)({},tLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}pLp.isMDXComponent=!0;const rLp={toc:[]},sLp="wrapper";function cLp(e){let{components:n,...t}=e;return(0,s.yg)(sLp,(0,p.A)({},rLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}cLp.isMDXComponent=!0;const aLp={toc:[]},iLp="wrapper";function lLp(e){let{components:n,...t}=e;return(0,s.yg)(iLp,(0,p.A)({},aLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}lLp.isMDXComponent=!0;const uLp={toc:[]},mLp="wrapper";function yLp(e){let{components:n,...t}=e;return(0,s.yg)(mLp,(0,p.A)({},uLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}yLp.isMDXComponent=!0;const dLp={toc:[]},hLp="wrapper";function gLp(e){let{components:n,...t}=e;return(0,s.yg)(hLp,(0,p.A)({},dLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}gLp.isMDXComponent=!0;const fLp={toc:[]},DLp="wrapper";function MLp(e){let{components:n,...t}=e;return(0,s.yg)(DLp,(0,p.A)({},fLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}MLp.isMDXComponent=!0;const XLp={toc:[]},_Lp="wrapper";function wLp(e){let{components:n,...t}=e;return(0,s.yg)(_Lp,(0,p.A)({},XLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wLp.isMDXComponent=!0;const TLp={toc:[]},CLp="wrapper";function xLp(e){let{components:n,...t}=e;return(0,s.yg)(CLp,(0,p.A)({},TLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}xLp.isMDXComponent=!0;const ALp={toc:[]},vLp="wrapper";function LLp(e){let{components:n,...t}=e;return(0,s.yg)(vLp,(0,p.A)({},ALp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}LLp.isMDXComponent=!0;const bLp={toc:[]},NLp="wrapper";function kLp(e){let{components:n,...t}=e;return(0,s.yg)(NLp,(0,p.A)({},bLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}kLp.isMDXComponent=!0;const zLp={toc:[]},PLp="wrapper";function ILp(e){let{components:n,...t}=e;return(0,s.yg)(PLp,(0,p.A)({},zLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ILp.isMDXComponent=!0;const RLp={toc:[]},WLp="wrapper";function SLp(e){let{components:n,...t}=e;return(0,s.yg)(WLp,(0,p.A)({},RLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}SLp.isMDXComponent=!0;const BLp={toc:[]},GLp="wrapper";function ELp(e){let{components:n,...t}=e;return(0,s.yg)(GLp,(0,p.A)({},BLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}ELp.isMDXComponent=!0;const OLp={toc:[]},ULp="wrapper";function FLp(e){let{components:n,...t}=e;return(0,s.yg)(ULp,(0,p.A)({},OLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}FLp.isMDXComponent=!0;const VLp={toc:[]},qLp="wrapper";function jLp(e){let{components:n,...t}=e;return(0,s.yg)(qLp,(0,p.A)({},VLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}jLp.isMDXComponent=!0;const HLp={toc:[]},YLp="wrapper";function QLp(e){let{components:n,...t}=e;return(0,s.yg)(YLp,(0,p.A)({},HLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}QLp.isMDXComponent=!0;const $Lp={toc:[]},KLp="wrapper";function JLp(e){let{components:n,...t}=e;return(0,s.yg)(KLp,(0,p.A)({},$Lp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}JLp.isMDXComponent=!0;const ZLp={toc:[]},ebp="wrapper";function nbp(e){let{components:n,...t}=e;return(0,s.yg)(ebp,(0,p.A)({},ZLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}nbp.isMDXComponent=!0;const tbp={toc:[]},obp="wrapper";function pbp(e){let{components:n,...t}=e;return(0,s.yg)(obp,(0,p.A)({},tbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pbp.isMDXComponent=!0;const rbp={toc:[]},sbp="wrapper";function cbp(e){let{components:n,...t}=e;return(0,s.yg)(sbp,(0,p.A)({},rbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cbp.isMDXComponent=!0;const abp={toc:[]},ibp="wrapper";function lbp(e){let{components:n,...t}=e;return(0,s.yg)(ibp,(0,p.A)({},abp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}lbp.isMDXComponent=!0;const ubp={toc:[]},mbp="wrapper";function ybp(e){let{components:n,...t}=e;return(0,s.yg)(mbp,(0,p.A)({},ubp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}ybp.isMDXComponent=!0;const dbp={toc:[]},hbp="wrapper";function gbp(e){let{components:n,...t}=e;return(0,s.yg)(hbp,(0,p.A)({},dbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}gbp.isMDXComponent=!0;const fbp={toc:[]},Dbp="wrapper";function Mbp(e){let{components:n,...t}=e;return(0,s.yg)(Dbp,(0,p.A)({},fbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Mbp.isMDXComponent=!0;const Xbp={toc:[]},_bp="wrapper";function wbp(e){let{components:n,...t}=e;return(0,s.yg)(_bp,(0,p.A)({},Xbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wbp.isMDXComponent=!0;const Tbp={toc:[]},Cbp="wrapper";function xbp(e){let{components:n,...t}=e;return(0,s.yg)(Cbp,(0,p.A)({},Tbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}xbp.isMDXComponent=!0;const Abp={toc:[]},vbp="wrapper";function Lbp(e){let{components:n,...t}=e;return(0,s.yg)(vbp,(0,p.A)({},Abp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Lbp.isMDXComponent=!0;const bbp={toc:[]},Nbp="wrapper";function kbp(e){let{components:n,...t}=e;return(0,s.yg)(Nbp,(0,p.A)({},bbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}kbp.isMDXComponent=!0;const zbp={toc:[]},Pbp="wrapper";function Ibp(e){let{components:n,...t}=e;return(0,s.yg)(Pbp,(0,p.A)({},zbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ibp.isMDXComponent=!0;const Rbp={toc:[]},Wbp="wrapper";function Sbp(e){let{components:n,...t}=e;return(0,s.yg)(Wbp,(0,p.A)({},Rbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Sbp.isMDXComponent=!0;const Bbp={toc:[]},Gbp="wrapper";function Ebp(e){let{components:n,...t}=e;return(0,s.yg)(Gbp,(0,p.A)({},Bbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Ebp.isMDXComponent=!0;const Obp={toc:[]},Ubp="wrapper";function Fbp(e){let{components:n,...t}=e;return(0,s.yg)(Ubp,(0,p.A)({},Obp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Fbp.isMDXComponent=!0;const Vbp={toc:[]},qbp="wrapper";function jbp(e){let{components:n,...t}=e;return(0,s.yg)(qbp,(0,p.A)({},Vbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}jbp.isMDXComponent=!0;const Hbp={toc:[]},Ybp="wrapper";function Qbp(e){let{components:n,...t}=e;return(0,s.yg)(Ybp,(0,p.A)({},Hbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Qbp.isMDXComponent=!0;const $bp={toc:[]},Kbp="wrapper";function Jbp(e){let{components:n,...t}=e;return(0,s.yg)(Kbp,(0,p.A)({},$bp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Jbp.isMDXComponent=!0;const Zbp={toc:[]},eNp="wrapper";function nNp(e){let{components:n,...t}=e;return(0,s.yg)(eNp,(0,p.A)({},Zbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nNp.isMDXComponent=!0;const tNp={toc:[]},oNp="wrapper";function pNp(e){let{components:n,...t}=e;return(0,s.yg)(oNp,(0,p.A)({},tNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}pNp.isMDXComponent=!0;const rNp={toc:[]},sNp="wrapper";function cNp(e){let{components:n,...t}=e;return(0,s.yg)(sNp,(0,p.A)({},rNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cNp.isMDXComponent=!0;const aNp={toc:[]},iNp="wrapper";function lNp(e){let{components:n,...t}=e;return(0,s.yg)(iNp,(0,p.A)({},aNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lNp.isMDXComponent=!0;const uNp={toc:[]},mNp="wrapper";function yNp(e){let{components:n,...t}=e;return(0,s.yg)(mNp,(0,p.A)({},uNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}yNp.isMDXComponent=!0;const dNp={toc:[]},hNp="wrapper";function gNp(e){let{components:n,...t}=e;return(0,s.yg)(hNp,(0,p.A)({},dNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gNp.isMDXComponent=!0;const fNp={toc:[]},DNp="wrapper";function MNp(e){let{components:n,...t}=e;return(0,s.yg)(DNp,(0,p.A)({},fNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}MNp.isMDXComponent=!0;const XNp={toc:[]},_Np="wrapper";function wNp(e){let{components:n,...t}=e;return(0,s.yg)(_Np,(0,p.A)({},XNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wNp.isMDXComponent=!0;const TNp={toc:[]},CNp="wrapper";function xNp(e){let{components:n,...t}=e;return(0,s.yg)(CNp,(0,p.A)({},TNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}xNp.isMDXComponent=!0;const ANp={toc:[]},vNp="wrapper";function LNp(e){let{components:n,...t}=e;return(0,s.yg)(vNp,(0,p.A)({},ANp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}LNp.isMDXComponent=!0;const bNp={toc:[]},NNp="wrapper";function kNp(e){let{components:n,...t}=e;return(0,s.yg)(NNp,(0,p.A)({},bNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}kNp.isMDXComponent=!0;const zNp={toc:[]},PNp="wrapper";function INp(e){let{components:n,...t}=e;return(0,s.yg)(PNp,(0,p.A)({},zNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}INp.isMDXComponent=!0;const RNp={toc:[]},WNp="wrapper";function SNp(e){let{components:n,...t}=e;return(0,s.yg)(WNp,(0,p.A)({},RNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}SNp.isMDXComponent=!0;const BNp={toc:[]},GNp="wrapper";function ENp(e){let{components:n,...t}=e;return(0,s.yg)(GNp,(0,p.A)({},BNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ENp.isMDXComponent=!0;const ONp={toc:[]},UNp="wrapper";function FNp(e){let{components:n,...t}=e;return(0,s.yg)(UNp,(0,p.A)({},ONp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}FNp.isMDXComponent=!0;const VNp={toc:[]},qNp="wrapper";function jNp(e){let{components:n,...t}=e;return(0,s.yg)(qNp,(0,p.A)({},VNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jNp.isMDXComponent=!0;const HNp={toc:[]},YNp="wrapper";function QNp(e){let{components:n,...t}=e;return(0,s.yg)(YNp,(0,p.A)({},HNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}QNp.isMDXComponent=!0;const $Np={toc:[]},KNp="wrapper";function JNp(e){let{components:n,...t}=e;return(0,s.yg)(KNp,(0,p.A)({},$Np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}JNp.isMDXComponent=!0;const ZNp={toc:[]},ekp="wrapper";function nkp(e){let{components:n,...t}=e;return(0,s.yg)(ekp,(0,p.A)({},ZNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nkp.isMDXComponent=!0;const tkp={toc:[]},okp="wrapper";function pkp(e){let{components:n,...t}=e;return(0,s.yg)(okp,(0,p.A)({},tkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pkp.isMDXComponent=!0;const rkp={toc:[]},skp="wrapper";function ckp(e){let{components:n,...t}=e;return(0,s.yg)(skp,(0,p.A)({},rkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ckp.isMDXComponent=!0;const akp={toc:[]},ikp="wrapper";function lkp(e){let{components:n,...t}=e;return(0,s.yg)(ikp,(0,p.A)({},akp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lkp.isMDXComponent=!0;const ukp={toc:[]},mkp="wrapper";function ykp(e){let{components:n,...t}=e;return(0,s.yg)(mkp,(0,p.A)({},ukp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ykp.isMDXComponent=!0;const dkp={toc:[]},hkp="wrapper";function gkp(e){let{components:n,...t}=e;return(0,s.yg)(hkp,(0,p.A)({},dkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gkp.isMDXComponent=!0;const fkp={toc:[]},Dkp="wrapper";function Mkp(e){let{components:n,...t}=e;return(0,s.yg)(Dkp,(0,p.A)({},fkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Mkp.isMDXComponent=!0;const Xkp={toc:[]},_kp="wrapper";function wkp(e){let{components:n,...t}=e;return(0,s.yg)(_kp,(0,p.A)({},Xkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wkp.isMDXComponent=!0;const Tkp={toc:[]},Ckp="wrapper";function xkp(e){let{components:n,...t}=e;return(0,s.yg)(Ckp,(0,p.A)({},Tkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xkp.isMDXComponent=!0;const Akp={toc:[]},vkp="wrapper";function Lkp(e){let{components:n,...t}=e;return(0,s.yg)(vkp,(0,p.A)({},Akp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}Lkp.isMDXComponent=!0;const bkp={toc:[]},Nkp="wrapper";function kkp(e){let{components:n,...t}=e;return(0,s.yg)(Nkp,(0,p.A)({},bkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the path of this circle should be closed."))}kkp.isMDXComponent=!0;const zkp={toc:[]},Pkp="wrapper";function Ikp(e){let{components:n,...t}=e;return(0,s.yg)(Pkp,(0,p.A)({},zkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the circle begins at ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}Ikp.isMDXComponent=!0;const Rkp={toc:[]},Wkp="wrapper";function Skp(e){let{components:n,...t}=e;return(0,s.yg)(Wkp,(0,p.A)({},Rkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the circle sector should be drawn counterclockwise."))}Skp.isMDXComponent=!0;const Bkp={toc:[]},Gkp="wrapper";function Ekp(e){let{components:n,...t}=e;return(0,s.yg)(Gkp,(0,p.A)({},Bkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ekp.isMDXComponent=!0;const Okp={toc:[]},Ukp="wrapper";function Fkp(e){let{components:n,...t}=e;return(0,s.yg)(Ukp,(0,p.A)({},Okp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Fkp.isMDXComponent=!0;const Vkp={toc:[]},qkp="wrapper";function jkp(e){let{components:n,...t}=e;return(0,s.yg)(qkp,(0,p.A)({},Vkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}jkp.isMDXComponent=!0;const Hkp={toc:[]},Ykp="wrapper";function Qkp(e){let{components:n,...t}=e;return(0,s.yg)(Ykp,(0,p.A)({},Hkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending angle in degrees for the circle sector."))}Qkp.isMDXComponent=!0;const $kp={toc:[]},Kkp="wrapper";function Jkp(e){let{components:n,...t}=e;return(0,s.yg)(Kkp,(0,p.A)({},$kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Jkp.isMDXComponent=!0;const Zkp={toc:[]},ezp="wrapper";function nzp(e){let{components:n,...t}=e;return(0,s.yg)(ezp,(0,p.A)({},Zkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}nzp.isMDXComponent=!0;const tzp={toc:[]},ozp="wrapper";function pzp(e){let{components:n,...t}=e;return(0,s.yg)(ozp,(0,p.A)({},tzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pzp.isMDXComponent=!0;const rzp={toc:[]},szp="wrapper";function czp(e){let{components:n,...t}=e;return(0,s.yg)(szp,(0,p.A)({},rzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}czp.isMDXComponent=!0;const azp={toc:[]},izp="wrapper";function lzp(e){let{components:n,...t}=e;return(0,s.yg)(izp,(0,p.A)({},azp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lzp.isMDXComponent=!0;const uzp={toc:[]},mzp="wrapper";function yzp(e){let{components:n,...t}=e;return(0,s.yg)(mzp,(0,p.A)({},uzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}yzp.isMDXComponent=!0;const dzp={toc:[]},hzp="wrapper";function gzp(e){let{components:n,...t}=e;return(0,s.yg)(hzp,(0,p.A)({},dzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}gzp.isMDXComponent=!0;const fzp={toc:[]},Dzp="wrapper";function Mzp(e){let{components:n,...t}=e;return(0,s.yg)(Dzp,(0,p.A)({},fzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Mzp.isMDXComponent=!0;const Xzp={toc:[]},_zp="wrapper";function wzp(e){let{components:n,...t}=e;return(0,s.yg)(_zp,(0,p.A)({},Xzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wzp.isMDXComponent=!0;const Tzp={toc:[]},Czp="wrapper";function xzp(e){let{components:n,...t}=e;return(0,s.yg)(Czp,(0,p.A)({},Tzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}xzp.isMDXComponent=!0;const Azp={toc:[]},vzp="wrapper";function Lzp(e){let{components:n,...t}=e;return(0,s.yg)(vzp,(0,p.A)({},Azp,t,{components:n,mdxType:"MDXLayout"}))}Lzp.isMDXComponent=!0;const bzp={toc:[]},Nzp="wrapper";function kzp(e){let{components:n,...t}=e;return(0,s.yg)(Nzp,(0,p.A)({},bzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}kzp.isMDXComponent=!0;const zzp={toc:[]},Pzp="wrapper";function Izp(e){let{components:n,...t}=e;return(0,s.yg)(Pzp,(0,p.A)({},zzp,t,{components:n,mdxType:"MDXLayout"}))}Izp.isMDXComponent=!0;const Rzp={toc:[]},Wzp="wrapper";function Szp(e){let{components:n,...t}=e;return(0,s.yg)(Wzp,(0,p.A)({},Rzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Szp.isMDXComponent=!0;const Bzp={toc:[]},Gzp="wrapper";function Ezp(e){let{components:n,...t}=e;return(0,s.yg)(Gzp,(0,p.A)({},Bzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Ezp.isMDXComponent=!0;const Ozp={toc:[]},Uzp="wrapper";function Fzp(e){let{components:n,...t}=e;return(0,s.yg)(Uzp,(0,p.A)({},Ozp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Fzp.isMDXComponent=!0;const Vzp={toc:[]},qzp="wrapper";function jzp(e){let{components:n,...t}=e;return(0,s.yg)(qzp,(0,p.A)({},Vzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting angle in degrees for the circle sector."))}jzp.isMDXComponent=!0;const Hzp={toc:[]},Yzp="wrapper";function Qzp(e){let{components:n,...t}=e;return(0,s.yg)(Yzp,(0,p.A)({},Hzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qzp.isMDXComponent=!0;const $zp={toc:[]},Kzp="wrapper";function Jzp(e){let{components:n,...t}=e;return(0,s.yg)(Kzp,(0,p.A)({},$zp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Jzp.isMDXComponent=!0;const Zzp={toc:[]},ePp="wrapper";function nPp(e){let{components:n,...t}=e;return(0,s.yg)(ePp,(0,p.A)({},Zzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}nPp.isMDXComponent=!0;const tPp={toc:[]},oPp="wrapper";function pPp(e){let{components:n,...t}=e;return(0,s.yg)(oPp,(0,p.A)({},tPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}pPp.isMDXComponent=!0;const rPp={toc:[]},sPp="wrapper";function cPp(e){let{components:n,...t}=e;return(0,s.yg)(sPp,(0,p.A)({},rPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cPp.isMDXComponent=!0;const aPp={toc:[]},iPp="wrapper";function lPp(e){let{components:n,...t}=e;return(0,s.yg)(iPp,(0,p.A)({},aPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}lPp.isMDXComponent=!0;const uPp={toc:[]},mPp="wrapper";function yPp(e){let{components:n,...t}=e;return(0,s.yg)(mPp,(0,p.A)({},uPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yPp.isMDXComponent=!0;const dPp={toc:[]},hPp="wrapper";function gPp(e){let{components:n,...t}=e;return(0,s.yg)(hPp,(0,p.A)({},dPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}gPp.isMDXComponent=!0;const fPp={toc:[]},DPp="wrapper";function MPp(e){let{components:n,...t}=e;return(0,s.yg)(DPp,(0,p.A)({},fPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MPp.isMDXComponent=!0;const XPp={toc:[]},_Pp="wrapper";function wPp(e){let{components:n,...t}=e;return(0,s.yg)(_Pp,(0,p.A)({},XPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}wPp.isMDXComponent=!0;const TPp={toc:[]},CPp="wrapper";function xPp(e){let{components:n,...t}=e;return(0,s.yg)(CPp,(0,p.A)({},TPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xPp.isMDXComponent=!0;const APp={toc:[]},vPp="wrapper";function LPp(e){let{components:n,...t}=e;return(0,s.yg)(vPp,(0,p.A)({},APp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}LPp.isMDXComponent=!0;const bPp={toc:[]},NPp="wrapper";function kPp(e){let{components:n,...t}=e;return(0,s.yg)(NPp,(0,p.A)({},bPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kPp.isMDXComponent=!0;const zPp={toc:[]},PPp="wrapper";function IPp(e){let{components:n,...t}=e;return(0,s.yg)(PPp,(0,p.A)({},zPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}IPp.isMDXComponent=!0;const RPp={toc:[]},WPp="wrapper";function SPp(e){let{components:n,...t}=e;return(0,s.yg)(WPp,(0,p.A)({},RPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SPp.isMDXComponent=!0;const BPp={toc:[]},GPp="wrapper";function EPp(e){let{components:n,...t}=e;return(0,s.yg)(GPp,(0,p.A)({},BPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}EPp.isMDXComponent=!0;const OPp={toc:[]},UPp="wrapper";function FPp(e){let{components:n,...t}=e;return(0,s.yg)(UPp,(0,p.A)({},OPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}FPp.isMDXComponent=!0;const VPp={toc:[]},qPp="wrapper";function jPp(e){let{components:n,...t}=e;return(0,s.yg)(qPp,(0,p.A)({},VPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jPp.isMDXComponent=!0;const HPp={toc:[]},YPp="wrapper";function QPp(e){let{components:n,...t}=e;return(0,s.yg)(YPp,(0,p.A)({},HPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}QPp.isMDXComponent=!0;const $Pp={toc:[]},KPp="wrapper";function JPp(e){let{components:n,...t}=e;return(0,s.yg)(KPp,(0,p.A)({},$Pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}JPp.isMDXComponent=!0;const ZPp={toc:[]},eIp="wrapper";function nIp(e){let{components:n,...t}=e;return(0,s.yg)(eIp,(0,p.A)({},ZPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}nIp.isMDXComponent=!0;const tIp={toc:[]},oIp="wrapper";function pIp(e){let{components:n,...t}=e;return(0,s.yg)(oIp,(0,p.A)({},tIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}pIp.isMDXComponent=!0;const rIp={toc:[]},sIp="wrapper";function cIp(e){let{components:n,...t}=e;return(0,s.yg)(sIp,(0,p.A)({},rIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cIp.isMDXComponent=!0;const aIp={toc:[]},iIp="wrapper";function lIp(e){let{components:n,...t}=e;return(0,s.yg)(iIp,(0,p.A)({},aIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lIp.isMDXComponent=!0;const uIp={toc:[]},mIp="wrapper";function yIp(e){let{components:n,...t}=e;return(0,s.yg)(mIp,(0,p.A)({},uIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yIp.isMDXComponent=!0;const dIp={toc:[]},hIp="wrapper";function gIp(e){let{components:n,...t}=e;return(0,s.yg)(hIp,(0,p.A)({},dIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gIp.isMDXComponent=!0;const fIp={toc:[]},DIp="wrapper";function MIp(e){let{components:n,...t}=e;return(0,s.yg)(DIp,(0,p.A)({},fIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to display."))}MIp.isMDXComponent=!0;const XIp={toc:[]},_Ip="wrapper";function wIp(e){let{components:n,...t}=e;return(0,s.yg)(_Ip,(0,p.A)({},XIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This value will be passed to the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeHighlighter")),"\ndefined by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#highlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"highlighter"))," property. Different highlighters may use\nit differently."),(0,s.yg)("p",null,"The default ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter"))," uses it to select\nthe language parser to use. The parser for the given dialect can be\nregistered as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// Import the lezer parser:\nimport {parser} from '@lezer/javascript';\n\n// Register it in the highlighter:\nLezerHighlighter.registerParser(parser, 'js');\n\n// Use the dialect in a code node:\n<Code dialect=\"js\" code=\"const a = 7;\" />\n")),(0,s.yg)("p",null,"When no dialect is provided, the highlighter will use the default\nparser:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'// Register the default parser by omitting the dialect:\nLezerHighlighter.registerParser(parser);\n\n// Code nodes with no dialect will now use the default parser:\n<Code code="const a = 7;" />\n')))}wIp.isMDXComponent=!0;const TIp={toc:[]},CIp="wrapper";function xIp(e){let{components:n,...t}=e;return(0,s.yg)(CIp,(0,p.A)({},TIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The dialect to use for highlighting the code."))}xIp.isMDXComponent=!0;const AIp={toc:[]},vIp="wrapper";function LIp(e){let{components:n,...t}=e;return(0,s.yg)(vIp,(0,p.A)({},AIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check out ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.yg)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}LIp.isMDXComponent=!0;const bIp={toc:[]},NIp="wrapper";function kIp(e){let{components:n,...t}=e;return(0,s.yg)(NIp,(0,p.A)({},bIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for the code."))}kIp.isMDXComponent=!0;const zIp={toc:[]},PIp="wrapper";function IIp(e){let{components:n,...t}=e;return(0,s.yg)(PIp,(0,p.A)({},zIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defaults to a shared ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}IIp.isMDXComponent=!0;const RIp={toc:[]},WIp="wrapper";function SIp(e){let{components:n,...t}=e;return(0,s.yg)(WIp,(0,p.A)({},RIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code highlighter to use for this code node."))}SIp.isMDXComponent=!0;const BIp={toc:[]},GIp="wrapper";function EIp(e){let{components:n,...t}=e;return(0,s.yg)(GIp,(0,p.A)({},BIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EIp.isMDXComponent=!0;const OIp={toc:[]},UIp="wrapper";function FIp(e){let{components:n,...t}=e;return(0,s.yg)(UIp,(0,p.A)({},OIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}FIp.isMDXComponent=!0;const VIp={toc:[]},qIp="wrapper";function jIp(e){let{components:n,...t}=e;return(0,s.yg)(qIp,(0,p.A)({},VIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}jIp.isMDXComponent=!0;const HIp={toc:[]},YIp="wrapper";function QIp(e){let{components:n,...t}=e;return(0,s.yg)(YIp,(0,p.A)({},HIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}QIp.isMDXComponent=!0;const $Ip={toc:[]},KIp="wrapper";function JIp(e){let{components:n,...t}=e;return(0,s.yg)(KIp,(0,p.A)({},$Ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JIp.isMDXComponent=!0;const ZIp={toc:[]},eRp="wrapper";function nRp(e){let{components:n,...t}=e;return(0,s.yg)(eRp,(0,p.A)({},ZIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}nRp.isMDXComponent=!0;const tRp={toc:[]},oRp="wrapper";function pRp(e){let{components:n,...t}=e;return(0,s.yg)(oRp,(0,p.A)({},tRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a single ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.yg)("p",null,"You can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.yg)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.yg)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}pRp.isMDXComponent=!0;const rRp={toc:[]},sRp="wrapper";function cRp(e){let{components:n,...t}=e;return(0,s.yg)(sRp,(0,p.A)({},rRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The currently selected code range."))}cRp.isMDXComponent=!0;const aRp={toc:[]},iRp="wrapper";function lRp(e){let{components:n,...t}=e;return(0,s.yg)(iRp,(0,p.A)({},aRp,t,{components:n,mdxType:"MDXLayout"}))}lRp.isMDXComponent=!0;const uRp={toc:[]},mRp="wrapper";function yRp(e){let{components:n,...t}=e;return(0,s.yg)(mRp,(0,p.A)({},uRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}yRp.isMDXComponent=!0;const dRp={toc:[]},hRp="wrapper";function gRp(e){let{components:n,...t}=e;return(0,s.yg)(hRp,(0,p.A)({},dRp,t,{components:n,mdxType:"MDXLayout"}))}gRp.isMDXComponent=!0;const fRp={toc:[]},DRp="wrapper";function MRp(e){let{components:n,...t}=e;return(0,s.yg)(DRp,(0,p.A)({},fRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MRp.isMDXComponent=!0;const XRp={toc:[]},_Rp="wrapper";function wRp(e){let{components:n,...t}=e;return(0,s.yg)(_Rp,(0,p.A)({},XRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}wRp.isMDXComponent=!0;const TRp={toc:[]},CRp="wrapper";function xRp(e){let{components:n,...t}=e;return(0,s.yg)(CRp,(0,p.A)({},TRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xRp.isMDXComponent=!0;const ARp={toc:[]},vRp="wrapper";function LRp(e){let{components:n,...t}=e;return(0,s.yg)(vRp,(0,p.A)({},ARp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}LRp.isMDXComponent=!0;const bRp={toc:[]},NRp="wrapper";function kRp(e){let{components:n,...t}=e;return(0,s.yg)(NRp,(0,p.A)({},bRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kRp.isMDXComponent=!0;const zRp={toc:[]},PRp="wrapper";function IRp(e){let{components:n,...t}=e;return(0,s.yg)(PRp,(0,p.A)({},zRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}IRp.isMDXComponent=!0;const RRp={toc:[]},WRp="wrapper";function SRp(e){let{components:n,...t}=e;return(0,s.yg)(WRp,(0,p.A)({},RRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}SRp.isMDXComponent=!0;const BRp={toc:[]},GRp="wrapper";function ERp(e){let{components:n,...t}=e;return(0,s.yg)(GRp,(0,p.A)({},BRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ERp.isMDXComponent=!0;const ORp={toc:[]},URp="wrapper";function FRp(e){let{components:n,...t}=e;return(0,s.yg)(URp,(0,p.A)({},ORp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FRp.isMDXComponent=!0;const VRp={toc:[]},qRp="wrapper";function jRp(e){let{components:n,...t}=e;return(0,s.yg)(qRp,(0,p.A)({},VRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}jRp.isMDXComponent=!0;const HRp={toc:[]},YRp="wrapper";function QRp(e){let{components:n,...t}=e;return(0,s.yg)(YRp,(0,p.A)({},HRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QRp.isMDXComponent=!0;const $Rp={toc:[]},KRp="wrapper";function JRp(e){let{components:n,...t}=e;return(0,s.yg)(KRp,(0,p.A)({},$Rp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}JRp.isMDXComponent=!0;const ZRp={toc:[]},eWp="wrapper";function nWp(e){let{components:n,...t}=e;return(0,s.yg)(eWp,(0,p.A)({},ZRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nWp.isMDXComponent=!0;const tWp={toc:[]},oWp="wrapper";function pWp(e){let{components:n,...t}=e;return(0,s.yg)(oWp,(0,p.A)({},tWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}pWp.isMDXComponent=!0;const rWp={toc:[]},sWp="wrapper";function cWp(e){let{components:n,...t}=e;return(0,s.yg)(sWp,(0,p.A)({},rWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cWp.isMDXComponent=!0;const aWp={toc:[]},iWp="wrapper";function lWp(e){let{components:n,...t}=e;return(0,s.yg)(iWp,(0,p.A)({},aWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lWp.isMDXComponent=!0;const uWp={toc:[]},mWp="wrapper";function yWp(e){let{components:n,...t}=e;return(0,s.yg)(mWp,(0,p.A)({},uWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yWp.isMDXComponent=!0;const dWp={toc:[]},hWp="wrapper";function gWp(e){let{components:n,...t}=e;return(0,s.yg)(hWp,(0,p.A)({},dWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gWp.isMDXComponent=!0;const fWp={toc:[]},DWp="wrapper";function MWp(e){let{components:n,...t}=e;return(0,s.yg)(DWp,(0,p.A)({},fWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}MWp.isMDXComponent=!0;const XWp={toc:[]},_Wp="wrapper";function wWp(e){let{components:n,...t}=e;return(0,s.yg)(_Wp,(0,p.A)({},XWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wWp.isMDXComponent=!0;const TWp={toc:[]},CWp="wrapper";function xWp(e){let{components:n,...t}=e;return(0,s.yg)(CWp,(0,p.A)({},TWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xWp.isMDXComponent=!0;const AWp={toc:[]},vWp="wrapper";function LWp(e){let{components:n,...t}=e;return(0,s.yg)(vWp,(0,p.A)({},AWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}LWp.isMDXComponent=!0;const bWp={toc:[]},NWp="wrapper";function kWp(e){let{components:n,...t}=e;return(0,s.yg)(NWp,(0,p.A)({},bWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kWp.isMDXComponent=!0;const zWp={toc:[]},PWp="wrapper";function IWp(e){let{components:n,...t}=e;return(0,s.yg)(PWp,(0,p.A)({},zWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IWp.isMDXComponent=!0;const RWp={toc:[]},WWp="wrapper";function SWp(e){let{components:n,...t}=e;return(0,s.yg)(WWp,(0,p.A)({},RWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}SWp.isMDXComponent=!0;const BWp={toc:[]},GWp="wrapper";function EWp(e){let{components:n,...t}=e;return(0,s.yg)(GWp,(0,p.A)({},BWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}EWp.isMDXComponent=!0;const OWp={toc:[]},UWp="wrapper";function FWp(e){let{components:n,...t}=e;return(0,s.yg)(UWp,(0,p.A)({},OWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}FWp.isMDXComponent=!0;const VWp={toc:[]},qWp="wrapper";function jWp(e){let{components:n,...t}=e;return(0,s.yg)(qWp,(0,p.A)({},VWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}jWp.isMDXComponent=!0;const HWp={toc:[]},YWp="wrapper";function QWp(e){let{components:n,...t}=e;return(0,s.yg)(YWp,(0,p.A)({},HWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QWp.isMDXComponent=!0;const $Wp={toc:[]},KWp="wrapper";function JWp(e){let{components:n,...t}=e;return(0,s.yg)(KWp,(0,p.A)({},$Wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}JWp.isMDXComponent=!0;const ZWp={toc:[]},eSp="wrapper";function nSp(e){let{components:n,...t}=e;return(0,s.yg)(eSp,(0,p.A)({},ZWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}nSp.isMDXComponent=!0;const tSp={toc:[]},oSp="wrapper";function pSp(e){let{components:n,...t}=e;return(0,s.yg)(oSp,(0,p.A)({},tSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}pSp.isMDXComponent=!0;const rSp={toc:[]},sSp="wrapper";function cSp(e){let{components:n,...t}=e;return(0,s.yg)(sSp,(0,p.A)({},rSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cSp.isMDXComponent=!0;const aSp={toc:[]},iSp="wrapper";function lSp(e){let{components:n,...t}=e;return(0,s.yg)(iSp,(0,p.A)({},aSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}lSp.isMDXComponent=!0;const uSp={toc:[]},mSp="wrapper";function ySp(e){let{components:n,...t}=e;return(0,s.yg)(mSp,(0,p.A)({},uSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}ySp.isMDXComponent=!0;const dSp={toc:[]},hSp="wrapper";function gSp(e){let{components:n,...t}=e;return(0,s.yg)(hSp,(0,p.A)({},dSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}gSp.isMDXComponent=!0;const fSp={toc:[]},DSp="wrapper";function MSp(e){let{components:n,...t}=e;return(0,s.yg)(DSp,(0,p.A)({},fSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MSp.isMDXComponent=!0;const XSp={toc:[]},_Sp="wrapper";function wSp(e){let{components:n,...t}=e;return(0,s.yg)(_Sp,(0,p.A)({},XSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}wSp.isMDXComponent=!0;const TSp={toc:[]},CSp="wrapper";function xSp(e){let{components:n,...t}=e;return(0,s.yg)(CSp,(0,p.A)({},TSp,t,{components:n,mdxType:"MDXLayout"}))}xSp.isMDXComponent=!0;const ASp={toc:[]},vSp="wrapper";function LSp(e){let{components:n,...t}=e;return(0,s.yg)(vSp,(0,p.A)({},ASp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}LSp.isMDXComponent=!0;const bSp={toc:[]},NSp="wrapper";function kSp(e){let{components:n,...t}=e;return(0,s.yg)(NSp,(0,p.A)({},bSp,t,{components:n,mdxType:"MDXLayout"}))}kSp.isMDXComponent=!0;const zSp={toc:[]},PSp="wrapper";function ISp(e){let{components:n,...t}=e;return(0,s.yg)(PSp,(0,p.A)({},zSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ISp.isMDXComponent=!0;const RSp={toc:[]},WSp="wrapper";function SSp(e){let{components:n,...t}=e;return(0,s.yg)(WSp,(0,p.A)({},RSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}SSp.isMDXComponent=!0;const BSp={toc:[]},GSp="wrapper";function ESp(e){let{components:n,...t}=e;return(0,s.yg)(GSp,(0,p.A)({},BSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ESp.isMDXComponent=!0;const OSp={toc:[]},USp="wrapper";function FSp(e){let{components:n,...t}=e;return(0,s.yg)(USp,(0,p.A)({},OSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}FSp.isMDXComponent=!0;const VSp={toc:[]},qSp="wrapper";function jSp(e){let{components:n,...t}=e;return(0,s.yg)(qSp,(0,p.A)({},VSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jSp.isMDXComponent=!0;const HSp={toc:[]},YSp="wrapper";function QSp(e){let{components:n,...t}=e;return(0,s.yg)(YSp,(0,p.A)({},HSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}QSp.isMDXComponent=!0;const $Sp={toc:[]},KSp="wrapper";function JSp(e){let{components:n,...t}=e;return(0,s.yg)(KSp,(0,p.A)({},$Sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JSp.isMDXComponent=!0;const ZSp={toc:[]},eBp="wrapper";function nBp(e){let{components:n,...t}=e;return(0,s.yg)(eBp,(0,p.A)({},ZSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}nBp.isMDXComponent=!0;const tBp={toc:[]},oBp="wrapper";function pBp(e){let{components:n,...t}=e;return(0,s.yg)(oBp,(0,p.A)({},tBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pBp.isMDXComponent=!0;const rBp={toc:[]},sBp="wrapper";function cBp(e){let{components:n,...t}=e;return(0,s.yg)(sBp,(0,p.A)({},rBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}cBp.isMDXComponent=!0;const aBp={toc:[]},iBp="wrapper";function lBp(e){let{components:n,...t}=e;return(0,s.yg)(iBp,(0,p.A)({},aBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lBp.isMDXComponent=!0;const uBp={toc:[]},mBp="wrapper";function yBp(e){let{components:n,...t}=e;return(0,s.yg)(mBp,(0,p.A)({},uBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}yBp.isMDXComponent=!0;const dBp={toc:[]},hBp="wrapper";function gBp(e){let{components:n,...t}=e;return(0,s.yg)(hBp,(0,p.A)({},dBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}gBp.isMDXComponent=!0;const fBp={toc:[]},DBp="wrapper";function MBp(e){let{components:n,...t}=e;return(0,s.yg)(DBp,(0,p.A)({},fBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}MBp.isMDXComponent=!0;const XBp={toc:[]},_Bp="wrapper";function wBp(e){let{components:n,...t}=e;return(0,s.yg)(_Bp,(0,p.A)({},XBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wBp.isMDXComponent=!0;const TBp={toc:[]},CBp="wrapper";function xBp(e){let{components:n,...t}=e;return(0,s.yg)(CBp,(0,p.A)({},TBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}xBp.isMDXComponent=!0;const ABp={toc:[]},vBp="wrapper";function LBp(e){let{components:n,...t}=e;return(0,s.yg)(vBp,(0,p.A)({},ABp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LBp.isMDXComponent=!0;const bBp={toc:[]},NBp="wrapper";function kBp(e){let{components:n,...t}=e;return(0,s.yg)(NBp,(0,p.A)({},bBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}kBp.isMDXComponent=!0;const zBp={toc:[]},PBp="wrapper";function IBp(e){let{components:n,...t}=e;return(0,s.yg)(PBp,(0,p.A)({},zBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}IBp.isMDXComponent=!0;const RBp={toc:[]},WBp="wrapper";function SBp(e){let{components:n,...t}=e;return(0,s.yg)(WBp,(0,p.A)({},RBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}SBp.isMDXComponent=!0;const BBp={toc:[]},GBp="wrapper";function EBp(e){let{components:n,...t}=e;return(0,s.yg)(GBp,(0,p.A)({},BBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}EBp.isMDXComponent=!0;const OBp={toc:[]},UBp="wrapper";function FBp(e){let{components:n,...t}=e;return(0,s.yg)(UBp,(0,p.A)({},OBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}FBp.isMDXComponent=!0;const VBp={toc:[]},qBp="wrapper";function jBp(e){let{components:n,...t}=e;return(0,s.yg)(qBp,(0,p.A)({},VBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jBp.isMDXComponent=!0;const HBp={toc:[]},YBp="wrapper";function QBp(e){let{components:n,...t}=e;return(0,s.yg)(YBp,(0,p.A)({},HBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QBp.isMDXComponent=!0;const $Bp={toc:[]},KBp="wrapper";function JBp(e){let{components:n,...t}=e;return(0,s.yg)(KBp,(0,p.A)({},$Bp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}JBp.isMDXComponent=!0;const ZBp={toc:[]},eGp="wrapper";function nGp(e){let{components:n,...t}=e;return(0,s.yg)(eGp,(0,p.A)({},ZBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nGp.isMDXComponent=!0;const tGp={toc:[]},oGp="wrapper";function pGp(e){let{components:n,...t}=e;return(0,s.yg)(oGp,(0,p.A)({},tGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pGp.isMDXComponent=!0;const rGp={toc:[]},sGp="wrapper";function cGp(e){let{components:n,...t}=e;return(0,s.yg)(sGp,(0,p.A)({},rGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cGp.isMDXComponent=!0;const aGp={toc:[]},iGp="wrapper";function lGp(e){let{components:n,...t}=e;return(0,s.yg)(iGp,(0,p.A)({},aGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lGp.isMDXComponent=!0;const uGp={toc:[]},mGp="wrapper";function yGp(e){let{components:n,...t}=e;return(0,s.yg)(mGp,(0,p.A)({},uGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yGp.isMDXComponent=!0;const dGp={toc:[]},hGp="wrapper";function gGp(e){let{components:n,...t}=e;return(0,s.yg)(hGp,(0,p.A)({},dGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}gGp.isMDXComponent=!0;const fGp={toc:[]},DGp="wrapper";function MGp(e){let{components:n,...t}=e;return(0,s.yg)(DGp,(0,p.A)({},fGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}MGp.isMDXComponent=!0;const XGp={toc:[]},_Gp="wrapper";function wGp(e){let{components:n,...t}=e;return(0,s.yg)(_Gp,(0,p.A)({},XGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}wGp.isMDXComponent=!0;const TGp={toc:[]},CGp="wrapper";function xGp(e){let{components:n,...t}=e;return(0,s.yg)(CGp,(0,p.A)({},TGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}xGp.isMDXComponent=!0;const AGp={toc:[]},vGp="wrapper";function LGp(e){let{components:n,...t}=e;return(0,s.yg)(vGp,(0,p.A)({},AGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LGp.isMDXComponent=!0;const bGp={toc:[]},NGp="wrapper";function kGp(e){let{components:n,...t}=e;return(0,s.yg)(NGp,(0,p.A)({},bGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}kGp.isMDXComponent=!0;const zGp={toc:[]},PGp="wrapper";function IGp(e){let{components:n,...t}=e;return(0,s.yg)(PGp,(0,p.A)({},zGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}IGp.isMDXComponent=!0;const RGp={toc:[]},WGp="wrapper";function SGp(e){let{components:n,...t}=e;return(0,s.yg)(WGp,(0,p.A)({},RGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}SGp.isMDXComponent=!0;const BGp={toc:[]},GGp="wrapper";function EGp(e){let{components:n,...t}=e;return(0,s.yg)(GGp,(0,p.A)({},BGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EGp.isMDXComponent=!0;const OGp={toc:[]},UGp="wrapper";function FGp(e){let{components:n,...t}=e;return(0,s.yg)(UGp,(0,p.A)({},OGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}FGp.isMDXComponent=!0;const VGp={toc:[]},qGp="wrapper";function jGp(e){let{components:n,...t}=e;return(0,s.yg)(qGp,(0,p.A)({},VGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}jGp.isMDXComponent=!0;const HGp={toc:[]},YGp="wrapper";function QGp(e){let{components:n,...t}=e;return(0,s.yg)(YGp,(0,p.A)({},HGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}QGp.isMDXComponent=!0;const $Gp={toc:[]},KGp="wrapper";function JGp(e){let{components:n,...t}=e;return(0,s.yg)(KGp,(0,p.A)({},$Gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JGp.isMDXComponent=!0;const ZGp={toc:[]},eEp="wrapper";function nEp(e){let{components:n,...t}=e;return(0,s.yg)(eEp,(0,p.A)({},ZGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}nEp.isMDXComponent=!0;const tEp={toc:[]},oEp="wrapper";function pEp(e){let{components:n,...t}=e;return(0,s.yg)(oEp,(0,p.A)({},tEp,t,{components:n,mdxType:"MDXLayout"}))}pEp.isMDXComponent=!0;const rEp={toc:[]},sEp="wrapper";function cEp(e){let{components:n,...t}=e;return(0,s.yg)(sEp,(0,p.A)({},rEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}cEp.isMDXComponent=!0;const aEp={toc:[]},iEp="wrapper";function lEp(e){let{components:n,...t}=e;return(0,s.yg)(iEp,(0,p.A)({},aEp,t,{components:n,mdxType:"MDXLayout"}))}lEp.isMDXComponent=!0;const uEp={toc:[]},mEp="wrapper";function yEp(e){let{components:n,...t}=e;return(0,s.yg)(mEp,(0,p.A)({},uEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}yEp.isMDXComponent=!0;const dEp={toc:[]},hEp="wrapper";function gEp(e){let{components:n,...t}=e;return(0,s.yg)(hEp,(0,p.A)({},dEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}gEp.isMDXComponent=!0;const fEp={toc:[]},DEp="wrapper";function MEp(e){let{components:n,...t}=e;return(0,s.yg)(DEp,(0,p.A)({},fEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MEp.isMDXComponent=!0;const XEp={toc:[]},_Ep="wrapper";function wEp(e){let{components:n,...t}=e;return(0,s.yg)(_Ep,(0,p.A)({},XEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}wEp.isMDXComponent=!0;const TEp={toc:[]},CEp="wrapper";function xEp(e){let{components:n,...t}=e;return(0,s.yg)(CEp,(0,p.A)({},TEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xEp.isMDXComponent=!0;const AEp={toc:[]},vEp="wrapper";function LEp(e){let{components:n,...t}=e;return(0,s.yg)(vEp,(0,p.A)({},AEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}LEp.isMDXComponent=!0;const bEp={toc:[]},NEp="wrapper";function kEp(e){let{components:n,...t}=e;return(0,s.yg)(NEp,(0,p.A)({},bEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kEp.isMDXComponent=!0;const zEp={toc:[]},PEp="wrapper";function IEp(e){let{components:n,...t}=e;return(0,s.yg)(PEp,(0,p.A)({},zEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}IEp.isMDXComponent=!0;const REp={toc:[]},WEp="wrapper";function SEp(e){let{components:n,...t}=e;return(0,s.yg)(WEp,(0,p.A)({},REp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SEp.isMDXComponent=!0;const BEp={toc:[]},GEp="wrapper";function EEp(e){let{components:n,...t}=e;return(0,s.yg)(GEp,(0,p.A)({},BEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}EEp.isMDXComponent=!0;const OEp={toc:[]},UEp="wrapper";function FEp(e){let{components:n,...t}=e;return(0,s.yg)(UEp,(0,p.A)({},OEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FEp.isMDXComponent=!0;const VEp={toc:[]},qEp="wrapper";function jEp(e){let{components:n,...t}=e;return(0,s.yg)(qEp,(0,p.A)({},VEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}jEp.isMDXComponent=!0;const HEp={toc:[]},YEp="wrapper";function QEp(e){let{components:n,...t}=e;return(0,s.yg)(YEp,(0,p.A)({},HEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom drawing logic used by the Code node."))}QEp.isMDXComponent=!0;const $Ep={toc:[]},KEp="wrapper";function JEp(e){let{components:n,...t}=e;return(0,s.yg)(KEp,(0,p.A)({},$Ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"token(ctx, text, position, color, selection) {\n  const blur = map(3, 0, selection);\n  const alpha = map(0.5, 1, selection);\n  ctx.globalAlpha *= alpha;\n  ctx.filter = `blur(${blur}px)`;\n  ctx.fillStyle = color;\n  ctx.fillText(text, position.x, position.y);\n}\n")))}JEp.isMDXComponent=!0;const ZEp={toc:[]},eOp="wrapper";function nOp(e){let{components:n,...t}=e;return(0,s.yg)(eOp,(0,p.A)({},ZEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for individual code tokens."))}nOp.isMDXComponent=!0;const tOp={toc:[]},oOp="wrapper";function pOp(e){let{components:n,...t}=e;return(0,s.yg)(oOp,(0,p.A)({},tOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pOp.isMDXComponent=!0;const rOp={toc:[]},sOp="wrapper";function cOp(e){let{components:n,...t}=e;return(0,s.yg)(sOp,(0,p.A)({},rOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}cOp.isMDXComponent=!0;const aOp={toc:[]},iOp="wrapper";function lOp(e){let{components:n,...t}=e;return(0,s.yg)(iOp,(0,p.A)({},aOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lOp.isMDXComponent=!0;const uOp={toc:[]},mOp="wrapper";function yOp(e){let{components:n,...t}=e;return(0,s.yg)(mOp,(0,p.A)({},uOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}yOp.isMDXComponent=!0;const dOp={toc:[]},hOp="wrapper";function gOp(e){let{components:n,...t}=e;return(0,s.yg)(hOp,(0,p.A)({},dOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gOp.isMDXComponent=!0;const fOp={toc:[]},DOp="wrapper";function MOp(e){let{components:n,...t}=e;return(0,s.yg)(DOp,(0,p.A)({},fOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}MOp.isMDXComponent=!0;const XOp={toc:[]},_Op="wrapper";function wOp(e){let{components:n,...t}=e;return(0,s.yg)(_Op,(0,p.A)({},XOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wOp.isMDXComponent=!0;const TOp={toc:[]},COp="wrapper";function xOp(e){let{components:n,...t}=e;return(0,s.yg)(COp,(0,p.A)({},TOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xOp.isMDXComponent=!0;const AOp={toc:[]},vOp="wrapper";function LOp(e){let{components:n,...t}=e;return(0,s.yg)(vOp,(0,p.A)({},AOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}LOp.isMDXComponent=!0;const bOp={toc:[]},NOp="wrapper";function kOp(e){let{components:n,...t}=e;return(0,s.yg)(NOp,(0,p.A)({},bOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kOp.isMDXComponent=!0;const zOp={toc:[]},POp="wrapper";function IOp(e){let{components:n,...t}=e;return(0,s.yg)(POp,(0,p.A)({},zOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}IOp.isMDXComponent=!0;const ROp={toc:[]},WOp="wrapper";function SOp(e){let{components:n,...t}=e;return(0,s.yg)(WOp,(0,p.A)({},ROp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SOp.isMDXComponent=!0;const BOp={toc:[]},GOp="wrapper";function EOp(e){let{components:n,...t}=e;return(0,s.yg)(GOp,(0,p.A)({},BOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}EOp.isMDXComponent=!0;const OOp={toc:[]},UOp="wrapper";function FOp(e){let{components:n,...t}=e;return(0,s.yg)(UOp,(0,p.A)({},OOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}FOp.isMDXComponent=!0;const VOp={toc:[]},qOp="wrapper";function jOp(e){let{components:n,...t}=e;return(0,s.yg)(qOp,(0,p.A)({},VOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jOp.isMDXComponent=!0;const HOp={toc:[]},YOp="wrapper";function QOp(e){let{components:n,...t}=e;return(0,s.yg)(YOp,(0,p.A)({},HOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QOp.isMDXComponent=!0;const $Op={toc:[]},KOp="wrapper";function JOp(e){let{components:n,...t}=e;return(0,s.yg)(KOp,(0,p.A)({},$Op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}JOp.isMDXComponent=!0;const ZOp={toc:[]},eUp="wrapper";function nUp(e){let{components:n,...t}=e;return(0,s.yg)(eUp,(0,p.A)({},ZOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the end of each grid line."))}nUp.isMDXComponent=!0;const tUp={toc:[]},oUp="wrapper";function pUp(e){let{components:n,...t}=e;return(0,s.yg)(oUp,(0,p.A)({},tUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pUp.isMDXComponent=!0;const rUp={toc:[]},sUp="wrapper";function cUp(e){let{components:n,...t}=e;return(0,s.yg)(sUp,(0,p.A)({},rUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}cUp.isMDXComponent=!0;const aUp={toc:[]},iUp="wrapper";function lUp(e){let{components:n,...t}=e;return(0,s.yg)(iUp,(0,p.A)({},aUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}lUp.isMDXComponent=!0;const uUp={toc:[]},mUp="wrapper";function yUp(e){let{components:n,...t}=e;return(0,s.yg)(mUp,(0,p.A)({},uUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}yUp.isMDXComponent=!0;const dUp={toc:[]},hUp="wrapper";function gUp(e){let{components:n,...t}=e;return(0,s.yg)(hUp,(0,p.A)({},dUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gUp.isMDXComponent=!0;const fUp={toc:[]},DUp="wrapper";function MUp(e){let{components:n,...t}=e;return(0,s.yg)(DUp,(0,p.A)({},fUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}MUp.isMDXComponent=!0;const XUp={toc:[]},_Up="wrapper";function wUp(e){let{components:n,...t}=e;return(0,s.yg)(_Up,(0,p.A)({},XUp,t,{components:n,mdxType:"MDXLayout"}))}wUp.isMDXComponent=!0;const TUp={toc:[]},CUp="wrapper";function xUp(e){let{components:n,...t}=e;return(0,s.yg)(CUp,(0,p.A)({},TUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The spacing between the grid lines."))}xUp.isMDXComponent=!0;const AUp={toc:[]},vUp="wrapper";function LUp(e){let{components:n,...t}=e;return(0,s.yg)(vUp,(0,p.A)({},AUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}LUp.isMDXComponent=!0;const bUp={toc:[]},NUp="wrapper";function kUp(e){let{components:n,...t}=e;return(0,s.yg)(NUp,(0,p.A)({},bUp,t,{components:n,mdxType:"MDXLayout"}))}kUp.isMDXComponent=!0;const zUp={toc:[]},PUp="wrapper";function IUp(e){let{components:n,...t}=e;return(0,s.yg)(PUp,(0,p.A)({},zUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}IUp.isMDXComponent=!0;const RUp={toc:[]},WUp="wrapper";function SUp(e){let{components:n,...t}=e;return(0,s.yg)(WUp,(0,p.A)({},RUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}SUp.isMDXComponent=!0;const BUp={toc:[]},GUp="wrapper";function EUp(e){let{components:n,...t}=e;return(0,s.yg)(GUp,(0,p.A)({},BUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EUp.isMDXComponent=!0;const OUp={toc:[]},UUp="wrapper";function FUp(e){let{components:n,...t}=e;return(0,s.yg)(UUp,(0,p.A)({},OUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}FUp.isMDXComponent=!0;const VUp={toc:[]},qUp="wrapper";function jUp(e){let{components:n,...t}=e;return(0,s.yg)(qUp,(0,p.A)({},VUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jUp.isMDXComponent=!0;const HUp={toc:[]},YUp="wrapper";function QUp(e){let{components:n,...t}=e;return(0,s.yg)(YUp,(0,p.A)({},HUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}QUp.isMDXComponent=!0;const $Up={toc:[]},KUp="wrapper";function JUp(e){let{components:n,...t}=e;return(0,s.yg)(KUp,(0,p.A)({},$Up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JUp.isMDXComponent=!0;const ZUp={toc:[]},eFp="wrapper";function nFp(e){let{components:n,...t}=e;return(0,s.yg)(eFp,(0,p.A)({},ZUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}nFp.isMDXComponent=!0;const tFp={toc:[]},oFp="wrapper";function pFp(e){let{components:n,...t}=e;return(0,s.yg)(oFp,(0,p.A)({},tFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}pFp.isMDXComponent=!0;const rFp={toc:[]},sFp="wrapper";function cFp(e){let{components:n,...t}=e;return(0,s.yg)(sFp,(0,p.A)({},rFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}cFp.isMDXComponent=!0;const aFp={toc:[]},iFp="wrapper";function lFp(e){let{components:n,...t}=e;return(0,s.yg)(iFp,(0,p.A)({},aFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}lFp.isMDXComponent=!0;const uFp={toc:[]},mFp="wrapper";function yFp(e){let{components:n,...t}=e;return(0,s.yg)(mFp,(0,p.A)({},uFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}yFp.isMDXComponent=!0;const dFp={toc:[]},hFp="wrapper";function gFp(e){let{components:n,...t}=e;return(0,s.yg)(hFp,(0,p.A)({},dFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gFp.isMDXComponent=!0;const fFp={toc:[]},DFp="wrapper";function MFp(e){let{components:n,...t}=e;return(0,s.yg)(DFp,(0,p.A)({},fFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}MFp.isMDXComponent=!0;const XFp={toc:[]},_Fp="wrapper";function wFp(e){let{components:n,...t}=e;return(0,s.yg)(_Fp,(0,p.A)({},XFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wFp.isMDXComponent=!0;const TFp={toc:[]},CFp="wrapper";function xFp(e){let{components:n,...t}=e;return(0,s.yg)(CFp,(0,p.A)({},TFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}xFp.isMDXComponent=!0;const AFp={toc:[]},vFp="wrapper";function LFp(e){let{components:n,...t}=e;return(0,s.yg)(vFp,(0,p.A)({},AFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LFp.isMDXComponent=!0;const bFp={toc:[]},NFp="wrapper";function kFp(e){let{components:n,...t}=e;return(0,s.yg)(NFp,(0,p.A)({},bFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}kFp.isMDXComponent=!0;const zFp={toc:[]},PFp="wrapper";function IFp(e){let{components:n,...t}=e;return(0,s.yg)(PFp,(0,p.A)({},zFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}IFp.isMDXComponent=!0;const RFp={toc:[]},WFp="wrapper";function SFp(e){let{components:n,...t}=e;return(0,s.yg)(WFp,(0,p.A)({},RFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SFp.isMDXComponent=!0;const BFp={toc:[]},GFp="wrapper";function EFp(e){let{components:n,...t}=e;return(0,s.yg)(GFp,(0,p.A)({},BFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}EFp.isMDXComponent=!0;const OFp={toc:[]},UFp="wrapper";function FFp(e){let{components:n,...t}=e;return(0,s.yg)(UFp,(0,p.A)({},OFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}FFp.isMDXComponent=!0;const VFp={toc:[]},qFp="wrapper";function jFp(e){let{components:n,...t}=e;return(0,s.yg)(qFp,(0,p.A)({},VFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jFp.isMDXComponent=!0;const HFp={toc:[]},YFp="wrapper";function QFp(e){let{components:n,...t}=e;return(0,s.yg)(YFp,(0,p.A)({},HFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QFp.isMDXComponent=!0;const $Fp={toc:[]},KFp="wrapper";function JFp(e){let{components:n,...t}=e;return(0,s.yg)(KFp,(0,p.A)({},$Fp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}JFp.isMDXComponent=!0;const ZFp={toc:[]},eVp="wrapper";function nVp(e){let{components:n,...t}=e;return(0,s.yg)(eVp,(0,p.A)({},ZFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nVp.isMDXComponent=!0;const tVp={toc:[]},oVp="wrapper";function pVp(e){let{components:n,...t}=e;return(0,s.yg)(oVp,(0,p.A)({},tVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pVp.isMDXComponent=!0;const rVp={toc:[]},sVp="wrapper";function cVp(e){let{components:n,...t}=e;return(0,s.yg)(sVp,(0,p.A)({},rVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cVp.isMDXComponent=!0;const aVp={toc:[]},iVp="wrapper";function lVp(e){let{components:n,...t}=e;return(0,s.yg)(iVp,(0,p.A)({},aVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}lVp.isMDXComponent=!0;const uVp={toc:[]},mVp="wrapper";function yVp(e){let{components:n,...t}=e;return(0,s.yg)(mVp,(0,p.A)({},uVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}yVp.isMDXComponent=!0;const dVp={toc:[]},hVp="wrapper";function gVp(e){let{components:n,...t}=e;return(0,s.yg)(hVp,(0,p.A)({},dVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide the color in one of the following formats:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"named color like ",(0,s.yg)("inlineCode",{parentName:"li"},"red"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.yg)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.yg)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}gVp.isMDXComponent=!0;const fVp={toc:[]},DVp="wrapper";function MVp(e){let{components:n,...t}=e;return(0,s.yg)(DVp,(0,p.A)({},fVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the icon"))}MVp.isMDXComponent=!0;const XVp={toc:[]},_Vp="wrapper";function wVp(e){let{components:n,...t}=e;return(0,s.yg)(_Vp,(0,p.A)({},XVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wVp.isMDXComponent=!0;const TVp={toc:[]},CVp="wrapper";function xVp(e){let{components:n,...t}=e;return(0,s.yg)(CVp,(0,p.A)({},TVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}xVp.isMDXComponent=!0;const AVp={toc:[]},vVp="wrapper";function LVp(e){let{components:n,...t}=e;return(0,s.yg)(vVp,(0,p.A)({},AVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}LVp.isMDXComponent=!0;const bVp={toc:[]},NVp="wrapper";function kVp(e){let{components:n,...t}=e;return(0,s.yg)(NVp,(0,p.A)({},bVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}kVp.isMDXComponent=!0;const zVp={toc:[]},PVp="wrapper";function IVp(e){let{components:n,...t}=e;return(0,s.yg)(PVp,(0,p.A)({},zVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}IVp.isMDXComponent=!0;const RVp={toc:[]},WVp="wrapper";function SVp(e){let{components:n,...t}=e;return(0,s.yg)(WVp,(0,p.A)({},RVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}SVp.isMDXComponent=!0;const BVp={toc:[]},GVp="wrapper";function EVp(e){let{components:n,...t}=e;return(0,s.yg)(GVp,(0,p.A)({},BVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}EVp.isMDXComponent=!0;const OVp={toc:[]},UVp="wrapper";function FVp(e){let{components:n,...t}=e;return(0,s.yg)(UVp,(0,p.A)({},OVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}FVp.isMDXComponent=!0;const VVp={toc:[]},qVp="wrapper";function jVp(e){let{components:n,...t}=e;return(0,s.yg)(qVp,(0,p.A)({},VVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can find identifiers on ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}jVp.isMDXComponent=!0;const HVp={toc:[]},YVp="wrapper";function QVp(e){let{components:n,...t}=e;return(0,s.yg)(YVp,(0,p.A)({},HVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The identifier of the icon."))}QVp.isMDXComponent=!0;const $Vp={toc:[]},KVp="wrapper";function JVp(e){let{components:n,...t}=e;return(0,s.yg)(KVp,(0,p.A)({},$Vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JVp.isMDXComponent=!0;const ZVp={toc:[]},eqp="wrapper";function nqp(e){let{components:n,...t}=e;return(0,s.yg)(eqp,(0,p.A)({},ZVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}nqp.isMDXComponent=!0;const tqp={toc:[]},oqp="wrapper";function pqp(e){let{components:n,...t}=e;return(0,s.yg)(oqp,(0,p.A)({},tqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}pqp.isMDXComponent=!0;const rqp={toc:[]},sqp="wrapper";function cqp(e){let{components:n,...t}=e;return(0,s.yg)(sqp,(0,p.A)({},rqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}cqp.isMDXComponent=!0;const aqp={toc:[]},iqp="wrapper";function lqp(e){let{components:n,...t}=e;return(0,s.yg)(iqp,(0,p.A)({},aqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lqp.isMDXComponent=!0;const uqp={toc:[]},mqp="wrapper";function yqp(e){let{components:n,...t}=e;return(0,s.yg)(mqp,(0,p.A)({},uqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}yqp.isMDXComponent=!0;const dqp={toc:[]},hqp="wrapper";function gqp(e){let{components:n,...t}=e;return(0,s.yg)(hqp,(0,p.A)({},dqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gqp.isMDXComponent=!0;const fqp={toc:[]},Dqp="wrapper";function Mqp(e){let{components:n,...t}=e;return(0,s.yg)(Dqp,(0,p.A)({},fqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Mqp.isMDXComponent=!0;const Xqp={toc:[]},_qp="wrapper";function wqp(e){let{components:n,...t}=e;return(0,s.yg)(_qp,(0,p.A)({},Xqp,t,{components:n,mdxType:"MDXLayout"}))}wqp.isMDXComponent=!0;const Tqp={toc:[]},Cqp="wrapper";function xqp(e){let{components:n,...t}=e;return(0,s.yg)(Cqp,(0,p.A)({},Tqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}xqp.isMDXComponent=!0;const Aqp={toc:[]},vqp="wrapper";function Lqp(e){let{components:n,...t}=e;return(0,s.yg)(vqp,(0,p.A)({},Aqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}Lqp.isMDXComponent=!0;const bqp={toc:[]},Nqp="wrapper";function kqp(e){let{components:n,...t}=e;return(0,s.yg)(Nqp,(0,p.A)({},bqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}kqp.isMDXComponent=!0;const zqp={toc:[]},Pqp="wrapper";function Iqp(e){let{components:n,...t}=e;return(0,s.yg)(Pqp,(0,p.A)({},zqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}Iqp.isMDXComponent=!0;const Rqp={toc:[]},Wqp="wrapper";function Sqp(e){let{components:n,...t}=e;return(0,s.yg)(Wqp,(0,p.A)({},Rqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Sqp.isMDXComponent=!0;const Bqp={toc:[]},Gqp="wrapper";function Eqp(e){let{components:n,...t}=e;return(0,s.yg)(Gqp,(0,p.A)({},Bqp,t,{components:n,mdxType:"MDXLayout"}))}Eqp.isMDXComponent=!0;const Oqp={toc:[]},Uqp="wrapper";function Fqp(e){let{components:n,...t}=e;return(0,s.yg)(Uqp,(0,p.A)({},Oqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}Fqp.isMDXComponent=!0;const Vqp={toc:[]},qqp="wrapper";function jqp(e){let{components:n,...t}=e;return(0,s.yg)(qqp,(0,p.A)({},Vqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}jqp.isMDXComponent=!0;const Hqp={toc:[]},Yqp="wrapper";function Qqp(e){let{components:n,...t}=e;return(0,s.yg)(Yqp,(0,p.A)({},Hqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Qqp.isMDXComponent=!0;const $qp={toc:[]},Kqp="wrapper";function Jqp(e){let{components:n,...t}=e;return(0,s.yg)(Kqp,(0,p.A)({},$qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Jqp.isMDXComponent=!0;const Zqp={toc:[]},ejp="wrapper";function njp(e){let{components:n,...t}=e;return(0,s.yg)(ejp,(0,p.A)({},Zqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}njp.isMDXComponent=!0;const tjp={toc:[]},ojp="wrapper";function pjp(e){let{components:n,...t}=e;return(0,s.yg)(ojp,(0,p.A)({},tjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}pjp.isMDXComponent=!0;const rjp={toc:[]},sjp="wrapper";function cjp(e){let{components:n,...t}=e;return(0,s.yg)(sjp,(0,p.A)({},rjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}cjp.isMDXComponent=!0;const ajp={toc:[]},ijp="wrapper";function ljp(e){let{components:n,...t}=e;return(0,s.yg)(ijp,(0,p.A)({},ajp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ljp.isMDXComponent=!0;const ujp={toc:[]},mjp="wrapper";function yjp(e){let{components:n,...t}=e;return(0,s.yg)(mjp,(0,p.A)({},ujp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}yjp.isMDXComponent=!0;const djp={toc:[]},hjp="wrapper";function gjp(e){let{components:n,...t}=e;return(0,s.yg)(hjp,(0,p.A)({},djp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gjp.isMDXComponent=!0;const fjp={toc:[]},Djp="wrapper";function Mjp(e){let{components:n,...t}=e;return(0,s.yg)(Djp,(0,p.A)({},fjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Mjp.isMDXComponent=!0;const Xjp={toc:[]},_jp="wrapper";function wjp(e){let{components:n,...t}=e;return(0,s.yg)(_jp,(0,p.A)({},Xjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wjp.isMDXComponent=!0;const Tjp={toc:[]},Cjp="wrapper";function xjp(e){let{components:n,...t}=e;return(0,s.yg)(Cjp,(0,p.A)({},Tjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}xjp.isMDXComponent=!0;const Ajp={toc:[]},vjp="wrapper";function Ljp(e){let{components:n,...t}=e;return(0,s.yg)(vjp,(0,p.A)({},Ajp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Ljp.isMDXComponent=!0;const bjp={toc:[]},Njp="wrapper";function kjp(e){let{components:n,...t}=e;return(0,s.yg)(Njp,(0,p.A)({},bjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}kjp.isMDXComponent=!0;const zjp={toc:[]},Pjp="wrapper";function Ijp(e){let{components:n,...t}=e;return(0,s.yg)(Pjp,(0,p.A)({},zjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ijp.isMDXComponent=!0;const Rjp={toc:[]},Wjp="wrapper";function Sjp(e){let{components:n,...t}=e;return(0,s.yg)(Wjp,(0,p.A)({},Rjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Sjp.isMDXComponent=!0;const Bjp={toc:[]},Gjp="wrapper";function Ejp(e){let{components:n,...t}=e;return(0,s.yg)(Gjp,(0,p.A)({},Bjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ejp.isMDXComponent=!0;const Ojp={toc:[]},Ujp="wrapper";function Fjp(e){let{components:n,...t}=e;return(0,s.yg)(Ujp,(0,p.A)({},Ojp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Fjp.isMDXComponent=!0;const Vjp={toc:[]},qjp="wrapper";function jjp(e){let{components:n,...t}=e;return(0,s.yg)(qjp,(0,p.A)({},Vjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jjp.isMDXComponent=!0;const Hjp={toc:[]},Yjp="wrapper";function Qjp(e){let{components:n,...t}=e;return(0,s.yg)(Yjp,(0,p.A)({},Hjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Qjp.isMDXComponent=!0;const $jp={toc:[]},Kjp="wrapper";function Jjp(e){let{components:n,...t}=e;return(0,s.yg)(Kjp,(0,p.A)({},$jp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Jjp.isMDXComponent=!0;const Zjp={toc:[]},eHp="wrapper";function nHp(e){let{components:n,...t}=e;return(0,s.yg)(eHp,(0,p.A)({},Zjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}nHp.isMDXComponent=!0;const tHp={toc:[]},oHp="wrapper";function pHp(e){let{components:n,...t}=e;return(0,s.yg)(oHp,(0,p.A)({},tHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pHp.isMDXComponent=!0;const rHp={toc:[]},sHp="wrapper";function cHp(e){let{components:n,...t}=e;return(0,s.yg)(sHp,(0,p.A)({},rHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cHp.isMDXComponent=!0;const aHp={toc:[]},iHp="wrapper";function lHp(e){let{components:n,...t}=e;return(0,s.yg)(iHp,(0,p.A)({},aHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lHp.isMDXComponent=!0;const uHp={toc:[]},mHp="wrapper";function yHp(e){let{components:n,...t}=e;return(0,s.yg)(mHp,(0,p.A)({},uHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yHp.isMDXComponent=!0;const dHp={toc:[]},hHp="wrapper";function gHp(e){let{components:n,...t}=e;return(0,s.yg)(hHp,(0,p.A)({},dHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gHp.isMDXComponent=!0;const fHp={toc:[]},DHp="wrapper";function MHp(e){let{components:n,...t}=e;return(0,s.yg)(DHp,(0,p.A)({},fHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}MHp.isMDXComponent=!0;const XHp={toc:[]},_Hp="wrapper";function wHp(e){let{components:n,...t}=e;return(0,s.yg)(_Hp,(0,p.A)({},XHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wHp.isMDXComponent=!0;const THp={toc:[]},CHp="wrapper";function xHp(e){let{components:n,...t}=e;return(0,s.yg)(CHp,(0,p.A)({},THp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xHp.isMDXComponent=!0;const AHp={toc:[]},vHp="wrapper";function LHp(e){let{components:n,...t}=e;return(0,s.yg)(vHp,(0,p.A)({},AHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}LHp.isMDXComponent=!0;const bHp={toc:[]},NHp="wrapper";function kHp(e){let{components:n,...t}=e;return(0,s.yg)(NHp,(0,p.A)({},bHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kHp.isMDXComponent=!0;const zHp={toc:[]},PHp="wrapper";function IHp(e){let{components:n,...t}=e;return(0,s.yg)(PHp,(0,p.A)({},zHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}IHp.isMDXComponent=!0;const RHp={toc:[]},WHp="wrapper";function SHp(e){let{components:n,...t}=e;return(0,s.yg)(WHp,(0,p.A)({},RHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}SHp.isMDXComponent=!0;const BHp={toc:[]},GHp="wrapper";function EHp(e){let{components:n,...t}=e;return(0,s.yg)(GHp,(0,p.A)({},BHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}EHp.isMDXComponent=!0;const OHp={toc:[]},UHp="wrapper";function FHp(e){let{components:n,...t}=e;return(0,s.yg)(UHp,(0,p.A)({},OHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}FHp.isMDXComponent=!0;const VHp={toc:[]},qHp="wrapper";function jHp(e){let{components:n,...t}=e;return(0,s.yg)(qHp,(0,p.A)({},VHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}jHp.isMDXComponent=!0;const HHp={toc:[]},YHp="wrapper";function QHp(e){let{components:n,...t}=e;return(0,s.yg)(YHp,(0,p.A)({},HHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}QHp.isMDXComponent=!0;const $Hp={toc:[]},KHp="wrapper";function JHp(e){let{components:n,...t}=e;return(0,s.yg)(KHp,(0,p.A)({},$Hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}JHp.isMDXComponent=!0;const ZHp={toc:[]},eYp="wrapper";function nYp(e){let{components:n,...t}=e;return(0,s.yg)(eYp,(0,p.A)({},ZHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}nYp.isMDXComponent=!0;const tYp={toc:[]},oYp="wrapper";function pYp(e){let{components:n,...t}=e;return(0,s.yg)(oYp,(0,p.A)({},tYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pYp.isMDXComponent=!0;const rYp={toc:[]},sYp="wrapper";function cYp(e){let{components:n,...t}=e;return(0,s.yg)(sYp,(0,p.A)({},rYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}cYp.isMDXComponent=!0;const aYp={toc:[]},iYp="wrapper";function lYp(e){let{components:n,...t}=e;return(0,s.yg)(iYp,(0,p.A)({},aYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lYp.isMDXComponent=!0;const uYp={toc:[]},mYp="wrapper";function yYp(e){let{components:n,...t}=e;return(0,s.yg)(mYp,(0,p.A)({},uYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}yYp.isMDXComponent=!0;const dYp={toc:[]},hYp="wrapper";function gYp(e){let{components:n,...t}=e;return(0,s.yg)(hYp,(0,p.A)({},dYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}gYp.isMDXComponent=!0;const fYp={toc:[]},DYp="wrapper";function MYp(e){let{components:n,...t}=e;return(0,s.yg)(DYp,(0,p.A)({},fYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}MYp.isMDXComponent=!0;const XYp={toc:[]},_Yp="wrapper";function wYp(e){let{components:n,...t}=e;return(0,s.yg)(_Yp,(0,p.A)({},XYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}wYp.isMDXComponent=!0;const TYp={toc:[]},CYp="wrapper";function xYp(e){let{components:n,...t}=e;return(0,s.yg)(CYp,(0,p.A)({},TYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}xYp.isMDXComponent=!0;const AYp={toc:[]},vYp="wrapper";function LYp(e){let{components:n,...t}=e;return(0,s.yg)(vYp,(0,p.A)({},AYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LYp.isMDXComponent=!0;const bYp={toc:[]},NYp="wrapper";function kYp(e){let{components:n,...t}=e;return(0,s.yg)(NYp,(0,p.A)({},bYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}kYp.isMDXComponent=!0;const zYp={toc:[]},PYp="wrapper";function IYp(e){let{components:n,...t}=e;return(0,s.yg)(PYp,(0,p.A)({},zYp,t,{components:n,mdxType:"MDXLayout"}))}IYp.isMDXComponent=!0;const RYp={toc:[]},WYp="wrapper";function SYp(e){let{components:n,...t}=e;return(0,s.yg)(WYp,(0,p.A)({},RYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}SYp.isMDXComponent=!0;const BYp={toc:[]},GYp="wrapper";function EYp(e){let{components:n,...t}=e;return(0,s.yg)(GYp,(0,p.A)({},BYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}EYp.isMDXComponent=!0;const OYp={toc:[]},UYp="wrapper";function FYp(e){let{components:n,...t}=e;return(0,s.yg)(UYp,(0,p.A)({},OYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}FYp.isMDXComponent=!0;const VYp={toc:[]},qYp="wrapper";function jYp(e){let{components:n,...t}=e;return(0,s.yg)(qYp,(0,p.A)({},VYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}jYp.isMDXComponent=!0;const HYp={toc:[]},YYp="wrapper";function QYp(e){let{components:n,...t}=e;return(0,s.yg)(YYp,(0,p.A)({},HYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}QYp.isMDXComponent=!0;const $Yp={toc:[]},KYp="wrapper";function JYp(e){let{components:n,...t}=e;return(0,s.yg)(KYp,(0,p.A)({},$Yp,t,{components:n,mdxType:"MDXLayout"}))}JYp.isMDXComponent=!0;const ZYp={toc:[]},eQp="wrapper";function nQp(e){let{components:n,...t}=e;return(0,s.yg)(eQp,(0,p.A)({},ZYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}nQp.isMDXComponent=!0;const tQp={toc:[]},oQp="wrapper";function pQp(e){let{components:n,...t}=e;return(0,s.yg)(oQp,(0,p.A)({},tQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}pQp.isMDXComponent=!0;const rQp={toc:[]},sQp="wrapper";function cQp(e){let{components:n,...t}=e;return(0,s.yg)(sQp,(0,p.A)({},rQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}cQp.isMDXComponent=!0;const aQp={toc:[]},iQp="wrapper";function lQp(e){let{components:n,...t}=e;return(0,s.yg)(iQp,(0,p.A)({},aQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lQp.isMDXComponent=!0;const uQp={toc:[]},mQp="wrapper";function yQp(e){let{components:n,...t}=e;return(0,s.yg)(mQp,(0,p.A)({},uQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}yQp.isMDXComponent=!0;const dQp={toc:[]},hQp="wrapper";function gQp(e){let{components:n,...t}=e;return(0,s.yg)(hQp,(0,p.A)({},dQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}gQp.isMDXComponent=!0;const fQp={toc:[]},DQp="wrapper";function MQp(e){let{components:n,...t}=e;return(0,s.yg)(DQp,(0,p.A)({},fQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}MQp.isMDXComponent=!0;const XQp={toc:[]},_Qp="wrapper";function wQp(e){let{components:n,...t}=e;return(0,s.yg)(_Qp,(0,p.A)({},XQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wQp.isMDXComponent=!0;const TQp={toc:[]},CQp="wrapper";function xQp(e){let{components:n,...t}=e;return(0,s.yg)(CQp,(0,p.A)({},TQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}xQp.isMDXComponent=!0;const AQp={toc:[]},vQp="wrapper";function LQp(e){let{components:n,...t}=e;return(0,s.yg)(vQp,(0,p.A)({},AQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LQp.isMDXComponent=!0;const bQp={toc:[]},NQp="wrapper";function kQp(e){let{components:n,...t}=e;return(0,s.yg)(NQp,(0,p.A)({},bQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}kQp.isMDXComponent=!0;const zQp={toc:[]},PQp="wrapper";function IQp(e){let{components:n,...t}=e;return(0,s.yg)(PQp,(0,p.A)({},zQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}IQp.isMDXComponent=!0;const RQp={toc:[]},WQp="wrapper";function SQp(e){let{components:n,...t}=e;return(0,s.yg)(WQp,(0,p.A)({},RQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}SQp.isMDXComponent=!0;const BQp={toc:[]},GQp="wrapper";function EQp(e){let{components:n,...t}=e;return(0,s.yg)(GQp,(0,p.A)({},BQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}EQp.isMDXComponent=!0;const OQp={toc:[]},UQp="wrapper";function FQp(e){let{components:n,...t}=e;return(0,s.yg)(UQp,(0,p.A)({},OQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}FQp.isMDXComponent=!0;const VQp={toc:[]},qQp="wrapper";function jQp(e){let{components:n,...t}=e;return(0,s.yg)(qQp,(0,p.A)({},VQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jQp.isMDXComponent=!0;const HQp={toc:[]},YQp="wrapper";function QQp(e){let{components:n,...t}=e;return(0,s.yg)(YQp,(0,p.A)({},HQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QQp.isMDXComponent=!0;const $Qp={toc:[]},KQp="wrapper";function JQp(e){let{components:n,...t}=e;return(0,s.yg)(KQp,(0,p.A)({},$Qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}JQp.isMDXComponent=!0;const ZQp={toc:[]},e$p="wrapper";function n$p(e){let{components:n,...t}=e;return(0,s.yg)(e$p,(0,p.A)({},ZQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}n$p.isMDXComponent=!0;const t$p={toc:[]},o$p="wrapper";function p$p(e){let{components:n,...t}=e;return(0,s.yg)(o$p,(0,p.A)({},t$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}p$p.isMDXComponent=!0;const r$p={toc:[]},s$p="wrapper";function c$p(e){let{components:n,...t}=e;return(0,s.yg)(s$p,(0,p.A)({},r$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}c$p.isMDXComponent=!0;const a$p={toc:[]},i$p="wrapper";function l$p(e){let{components:n,...t}=e;return(0,s.yg)(i$p,(0,p.A)({},a$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}l$p.isMDXComponent=!0;const u$p={toc:[]},m$p="wrapper";function y$p(e){let{components:n,...t}=e;return(0,s.yg)(m$p,(0,p.A)({},u$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}y$p.isMDXComponent=!0;const d$p={toc:[]},h$p="wrapper";function g$p(e){let{components:n,...t}=e;return(0,s.yg)(h$p,(0,p.A)({},d$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}g$p.isMDXComponent=!0;const f$p={toc:[]},D$p="wrapper";function M$p(e){let{components:n,...t}=e;return(0,s.yg)(D$p,(0,p.A)({},f$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}M$p.isMDXComponent=!0;const X$p={toc:[]},_$p="wrapper";function w$p(e){let{components:n,...t}=e;return(0,s.yg)(_$p,(0,p.A)({},X$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}w$p.isMDXComponent=!0;const T$p={toc:[]},C$p="wrapper";function x$p(e){let{components:n,...t}=e;return(0,s.yg)(C$p,(0,p.A)({},T$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}x$p.isMDXComponent=!0;const A$p={toc:[]},v$p="wrapper";function L$p(e){let{components:n,...t}=e;return(0,s.yg)(v$p,(0,p.A)({},A$p,t,{components:n,mdxType:"MDXLayout"}))}L$p.isMDXComponent=!0;const b$p={toc:[]},N$p="wrapper";function k$p(e){let{components:n,...t}=e;return(0,s.yg)(N$p,(0,p.A)({},b$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}k$p.isMDXComponent=!0;const z$p={toc:[]},P$p="wrapper";function I$p(e){let{components:n,...t}=e;return(0,s.yg)(P$p,(0,p.A)({},z$p,t,{components:n,mdxType:"MDXLayout"}))}I$p.isMDXComponent=!0;const R$p={toc:[]},W$p="wrapper";function S$p(e){let{components:n,...t}=e;return(0,s.yg)(W$p,(0,p.A)({},R$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}S$p.isMDXComponent=!0;const B$p={toc:[]},G$p="wrapper";function E$p(e){let{components:n,...t}=e;return(0,s.yg)(G$p,(0,p.A)({},B$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}E$p.isMDXComponent=!0;const O$p={toc:[]},U$p="wrapper";function F$p(e){let{components:n,...t}=e;return(0,s.yg)(U$p,(0,p.A)({},O$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}F$p.isMDXComponent=!0;const V$p={toc:[]},q$p="wrapper";function j$p(e){let{components:n,...t}=e;return(0,s.yg)(q$p,(0,p.A)({},V$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}j$p.isMDXComponent=!0;const H$p={toc:[]},Y$p="wrapper";function Q$p(e){let{components:n,...t}=e;return(0,s.yg)(Y$p,(0,p.A)({},H$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Q$p.isMDXComponent=!0;const $$p={toc:[]},K$p="wrapper";function J$p(e){let{components:n,...t}=e;return(0,s.yg)(K$p,(0,p.A)({},$$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}J$p.isMDXComponent=!0;const Z$p={toc:[]},eKp="wrapper";function nKp(e){let{components:n,...t}=e;return(0,s.yg)(eKp,(0,p.A)({},Z$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nKp.isMDXComponent=!0;const tKp={toc:[]},oKp="wrapper";function pKp(e){let{components:n,...t}=e;return(0,s.yg)(oKp,(0,p.A)({},tKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}pKp.isMDXComponent=!0;const rKp={toc:[]},sKp="wrapper";function cKp(e){let{components:n,...t}=e;return(0,s.yg)(sKp,(0,p.A)({},rKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cKp.isMDXComponent=!0;const aKp={toc:[]},iKp="wrapper";function lKp(e){let{components:n,...t}=e;return(0,s.yg)(iKp,(0,p.A)({},aKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}lKp.isMDXComponent=!0;const uKp={toc:[]},mKp="wrapper";function yKp(e){let{components:n,...t}=e;return(0,s.yg)(mKp,(0,p.A)({},uKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yKp.isMDXComponent=!0;const dKp={toc:[]},hKp="wrapper";function gKp(e){let{components:n,...t}=e;return(0,s.yg)(hKp,(0,p.A)({},dKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}gKp.isMDXComponent=!0;const fKp={toc:[]},DKp="wrapper";function MKp(e){let{components:n,...t}=e;return(0,s.yg)(DKp,(0,p.A)({},fKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}MKp.isMDXComponent=!0;const XKp={toc:[]},_Kp="wrapper";function wKp(e){let{components:n,...t}=e;return(0,s.yg)(_Kp,(0,p.A)({},XKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wKp.isMDXComponent=!0;const TKp={toc:[]},CKp="wrapper";function xKp(e){let{components:n,...t}=e;return(0,s.yg)(CKp,(0,p.A)({},TKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xKp.isMDXComponent=!0;const AKp={toc:[]},vKp="wrapper";function LKp(e){let{components:n,...t}=e;return(0,s.yg)(vKp,(0,p.A)({},AKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}LKp.isMDXComponent=!0;const bKp={toc:[]},NKp="wrapper";function kKp(e){let{components:n,...t}=e;return(0,s.yg)(NKp,(0,p.A)({},bKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kKp.isMDXComponent=!0;const zKp={toc:[]},PKp="wrapper";function IKp(e){let{components:n,...t}=e;return(0,s.yg)(PKp,(0,p.A)({},zKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IKp.isMDXComponent=!0;const RKp={toc:[]},WKp="wrapper";function SKp(e){let{components:n,...t}=e;return(0,s.yg)(WKp,(0,p.A)({},RKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SKp.isMDXComponent=!0;const BKp={toc:[]},GKp="wrapper";function EKp(e){let{components:n,...t}=e;return(0,s.yg)(GKp,(0,p.A)({},BKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}EKp.isMDXComponent=!0;const OKp={toc:[]},UKp="wrapper";function FKp(e){let{components:n,...t}=e;return(0,s.yg)(UKp,(0,p.A)({},OKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}FKp.isMDXComponent=!0;const VKp={toc:[]},qKp="wrapper";function jKp(e){let{components:n,...t}=e;return(0,s.yg)(qKp,(0,p.A)({},VKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jKp.isMDXComponent=!0;const HKp={toc:[]},YKp="wrapper";function QKp(e){let{components:n,...t}=e;return(0,s.yg)(YKp,(0,p.A)({},HKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}QKp.isMDXComponent=!0;const $Kp={toc:[]},KKp="wrapper";function JKp(e){let{components:n,...t}=e;return(0,s.yg)(KKp,(0,p.A)({},$Kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}JKp.isMDXComponent=!0;const ZKp={toc:[]},eJp="wrapper";function nJp(e){let{components:n,...t}=e;return(0,s.yg)(eJp,(0,p.A)({},ZKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}nJp.isMDXComponent=!0;const tJp={toc:[]},oJp="wrapper";function pJp(e){let{components:n,...t}=e;return(0,s.yg)(oJp,(0,p.A)({},tJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}pJp.isMDXComponent=!0;const rJp={toc:[]},sJp="wrapper";function cJp(e){let{components:n,...t}=e;return(0,s.yg)(sJp,(0,p.A)({},rJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}cJp.isMDXComponent=!0;const aJp={toc:[]},iJp="wrapper";function lJp(e){let{components:n,...t}=e;return(0,s.yg)(iJp,(0,p.A)({},aJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}lJp.isMDXComponent=!0;const uJp={toc:[]},mJp="wrapper";function yJp(e){let{components:n,...t}=e;return(0,s.yg)(mJp,(0,p.A)({},uJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yJp.isMDXComponent=!0;const dJp={toc:[]},hJp="wrapper";function gJp(e){let{components:n,...t}=e;return(0,s.yg)(hJp,(0,p.A)({},dJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}gJp.isMDXComponent=!0;const fJp={toc:[]},DJp="wrapper";function MJp(e){let{components:n,...t}=e;return(0,s.yg)(DJp,(0,p.A)({},fJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}MJp.isMDXComponent=!0;const XJp={toc:[]},_Jp="wrapper";function wJp(e){let{components:n,...t}=e;return(0,s.yg)(_Jp,(0,p.A)({},XJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}wJp.isMDXComponent=!0;const TJp={toc:[]},CJp="wrapper";function xJp(e){let{components:n,...t}=e;return(0,s.yg)(CJp,(0,p.A)({},TJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xJp.isMDXComponent=!0;const AJp={toc:[]},vJp="wrapper";function LJp(e){let{components:n,...t}=e;return(0,s.yg)(vJp,(0,p.A)({},AJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}LJp.isMDXComponent=!0;const bJp={toc:[]},NJp="wrapper";function kJp(e){let{components:n,...t}=e;return(0,s.yg)(NJp,(0,p.A)({},bJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}kJp.isMDXComponent=!0;const zJp={toc:[]},PJp="wrapper";function IJp(e){let{components:n,...t}=e;return(0,s.yg)(PJp,(0,p.A)({},zJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}IJp.isMDXComponent=!0;const RJp={toc:[]},WJp="wrapper";function SJp(e){let{components:n,...t}=e;return(0,s.yg)(WJp,(0,p.A)({},RJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}SJp.isMDXComponent=!0;const BJp={toc:[]},GJp="wrapper";function EJp(e){let{components:n,...t}=e;return(0,s.yg)(GJp,(0,p.A)({},BJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}EJp.isMDXComponent=!0;const OJp={toc:[]},UJp="wrapper";function FJp(e){let{components:n,...t}=e;return(0,s.yg)(UJp,(0,p.A)({},OJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FJp.isMDXComponent=!0;const VJp={toc:[]},qJp="wrapper";function jJp(e){let{components:n,...t}=e;return(0,s.yg)(qJp,(0,p.A)({},VJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}jJp.isMDXComponent=!0;const HJp={toc:[]},YJp="wrapper";function QJp(e){let{components:n,...t}=e;return(0,s.yg)(YJp,(0,p.A)({},HJp,t,{components:n,mdxType:"MDXLayout"}))}QJp.isMDXComponent=!0;const $Jp={toc:[]},KJp="wrapper";function JJp(e){let{components:n,...t}=e;return(0,s.yg)(KJp,(0,p.A)({},$Jp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}JJp.isMDXComponent=!0;const ZJp={toc:[]},eZp="wrapper";function nZp(e){let{components:n,...t}=e;return(0,s.yg)(eZp,(0,p.A)({},ZJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}nZp.isMDXComponent=!0;const tZp={toc:[]},oZp="wrapper";function pZp(e){let{components:n,...t}=e;return(0,s.yg)(oZp,(0,p.A)({},tZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}pZp.isMDXComponent=!0;const rZp={toc:[]},sZp="wrapper";function cZp(e){let{components:n,...t}=e;return(0,s.yg)(sZp,(0,p.A)({},rZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}cZp.isMDXComponent=!0;const aZp={toc:[]},iZp="wrapper";function lZp(e){let{components:n,...t}=e;return(0,s.yg)(iZp,(0,p.A)({},aZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}lZp.isMDXComponent=!0;const uZp={toc:[]},mZp="wrapper";function yZp(e){let{components:n,...t}=e;return(0,s.yg)(mZp,(0,p.A)({},uZp,t,{components:n,mdxType:"MDXLayout"}))}yZp.isMDXComponent=!0;const dZp={toc:[]},hZp="wrapper";function gZp(e){let{components:n,...t}=e;return(0,s.yg)(hZp,(0,p.A)({},dZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}gZp.isMDXComponent=!0;const fZp={toc:[]},DZp="wrapper";function MZp(e){let{components:n,...t}=e;return(0,s.yg)(DZp,(0,p.A)({},fZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}MZp.isMDXComponent=!0;const XZp={toc:[]},_Zp="wrapper";function wZp(e){let{components:n,...t}=e;return(0,s.yg)(_Zp,(0,p.A)({},XZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}wZp.isMDXComponent=!0;const TZp={toc:[]},CZp="wrapper";function xZp(e){let{components:n,...t}=e;return(0,s.yg)(CZp,(0,p.A)({},TZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xZp.isMDXComponent=!0;const AZp={toc:[]},vZp="wrapper";function LZp(e){let{components:n,...t}=e;return(0,s.yg)(vZp,(0,p.A)({},AZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}LZp.isMDXComponent=!0;const bZp={toc:[]},NZp="wrapper";function kZp(e){let{components:n,...t}=e;return(0,s.yg)(NZp,(0,p.A)({},bZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kZp.isMDXComponent=!0;const zZp={toc:[]},PZp="wrapper";function IZp(e){let{components:n,...t}=e;return(0,s.yg)(PZp,(0,p.A)({},zZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}IZp.isMDXComponent=!0;const RZp={toc:[]},WZp="wrapper";function SZp(e){let{components:n,...t}=e;return(0,s.yg)(WZp,(0,p.A)({},RZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SZp.isMDXComponent=!0;const BZp={toc:[]},GZp="wrapper";function EZp(e){let{components:n,...t}=e;return(0,s.yg)(GZp,(0,p.A)({},BZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}EZp.isMDXComponent=!0;const OZp={toc:[]},UZp="wrapper";function FZp(e){let{components:n,...t}=e;return(0,s.yg)(UZp,(0,p.A)({},OZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FZp.isMDXComponent=!0;const VZp={toc:[]},qZp="wrapper";function jZp(e){let{components:n,...t}=e;return(0,s.yg)(qZp,(0,p.A)({},VZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}jZp.isMDXComponent=!0;const HZp={toc:[]},YZp="wrapper";function QZp(e){let{components:n,...t}=e;return(0,s.yg)(YZp,(0,p.A)({},HZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QZp.isMDXComponent=!0;const $Zp={toc:[]},KZp="wrapper";function JZp(e){let{components:n,...t}=e;return(0,s.yg)(KZp,(0,p.A)({},$Zp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}JZp.isMDXComponent=!0;const ZZp={toc:[]},e0p="wrapper";function n0p(e){let{components:n,...t}=e;return(0,s.yg)(e0p,(0,p.A)({},ZZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}n0p.isMDXComponent=!0;const t0p={toc:[]},o0p="wrapper";function p0p(e){let{components:n,...t}=e;return(0,s.yg)(o0p,(0,p.A)({},t0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}p0p.isMDXComponent=!0;const r0p={toc:[]},s0p="wrapper";function c0p(e){let{components:n,...t}=e;return(0,s.yg)(s0p,(0,p.A)({},r0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}c0p.isMDXComponent=!0;const a0p={toc:[]},i0p="wrapper";function l0p(e){let{components:n,...t}=e;return(0,s.yg)(i0p,(0,p.A)({},a0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}l0p.isMDXComponent=!0;const u0p={toc:[]},m0p="wrapper";function y0p(e){let{components:n,...t}=e;return(0,s.yg)(m0p,(0,p.A)({},u0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}y0p.isMDXComponent=!0;const d0p={toc:[]},h0p="wrapper";function g0p(e){let{components:n,...t}=e;return(0,s.yg)(h0p,(0,p.A)({},d0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}g0p.isMDXComponent=!0;const f0p={toc:[]},D0p="wrapper";function M0p(e){let{components:n,...t}=e;return(0,s.yg)(D0p,(0,p.A)({},f0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}M0p.isMDXComponent=!0;const X0p={toc:[]},_0p="wrapper";function w0p(e){let{components:n,...t}=e;return(0,s.yg)(_0p,(0,p.A)({},X0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}w0p.isMDXComponent=!0;const T0p={toc:[]},C0p="wrapper";function x0p(e){let{components:n,...t}=e;return(0,s.yg)(C0p,(0,p.A)({},T0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}x0p.isMDXComponent=!0;const A0p={toc:[]},v0p="wrapper";function L0p(e){let{components:n,...t}=e;return(0,s.yg)(v0p,(0,p.A)({},A0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}L0p.isMDXComponent=!0;const b0p={toc:[]},N0p="wrapper";function k0p(e){let{components:n,...t}=e;return(0,s.yg)(N0p,(0,p.A)({},b0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}k0p.isMDXComponent=!0;const z0p={toc:[]},P0p="wrapper";function I0p(e){let{components:n,...t}=e;return(0,s.yg)(P0p,(0,p.A)({},z0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}I0p.isMDXComponent=!0;const R0p={toc:[]},W0p="wrapper";function S0p(e){let{components:n,...t}=e;return(0,s.yg)(W0p,(0,p.A)({},R0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}S0p.isMDXComponent=!0;const B0p={toc:[]},G0p="wrapper";function E0p(e){let{components:n,...t}=e;return(0,s.yg)(G0p,(0,p.A)({},B0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}E0p.isMDXComponent=!0;const O0p={toc:[]},U0p="wrapper";function F0p(e){let{components:n,...t}=e;return(0,s.yg)(U0p,(0,p.A)({},O0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}F0p.isMDXComponent=!0;const V0p={toc:[]},q0p="wrapper";function j0p(e){let{components:n,...t}=e;return(0,s.yg)(q0p,(0,p.A)({},V0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}j0p.isMDXComponent=!0;const H0p={toc:[]},Y0p="wrapper";function Q0p(e){let{components:n,...t}=e;return(0,s.yg)(Y0p,(0,p.A)({},H0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Q0p.isMDXComponent=!0;const $0p={toc:[]},K0p="wrapper";function J0p(e){let{components:n,...t}=e;return(0,s.yg)(K0p,(0,p.A)({},$0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}J0p.isMDXComponent=!0;const Z0p={toc:[]},e8p="wrapper";function n8p(e){let{components:n,...t}=e;return(0,s.yg)(e8p,(0,p.A)({},Z0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}n8p.isMDXComponent=!0;const t8p={toc:[]},o8p="wrapper";function p8p(e){let{components:n,...t}=e;return(0,s.yg)(o8p,(0,p.A)({},t8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}p8p.isMDXComponent=!0;const r8p={toc:[]},s8p="wrapper";function c8p(e){let{components:n,...t}=e;return(0,s.yg)(s8p,(0,p.A)({},r8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}c8p.isMDXComponent=!0;const a8p={toc:[]},i8p="wrapper";function l8p(e){let{components:n,...t}=e;return(0,s.yg)(i8p,(0,p.A)({},a8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}l8p.isMDXComponent=!0;const u8p={toc:[]},m8p="wrapper";function y8p(e){let{components:n,...t}=e;return(0,s.yg)(m8p,(0,p.A)({},u8p,t,{components:n,mdxType:"MDXLayout"}))}y8p.isMDXComponent=!0;const d8p={toc:[]},h8p="wrapper";function g8p(e){let{components:n,...t}=e;return(0,s.yg)(h8p,(0,p.A)({},d8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}g8p.isMDXComponent=!0;const f8p={toc:[]},D8p="wrapper";function M8p(e){let{components:n,...t}=e;return(0,s.yg)(D8p,(0,p.A)({},f8p,t,{components:n,mdxType:"MDXLayout"}))}M8p.isMDXComponent=!0;const X8p={toc:[]},_8p="wrapper";function w8p(e){let{components:n,...t}=e;return(0,s.yg)(_8p,(0,p.A)({},X8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w8p.isMDXComponent=!0;const T8p={toc:[]},C8p="wrapper";function x8p(e){let{components:n,...t}=e;return(0,s.yg)(C8p,(0,p.A)({},T8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}x8p.isMDXComponent=!0;const A8p={toc:[]},v8p="wrapper";function L8p(e){let{components:n,...t}=e;return(0,s.yg)(v8p,(0,p.A)({},A8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}L8p.isMDXComponent=!0;const b8p={toc:[]},N8p="wrapper";function k8p(e){let{components:n,...t}=e;return(0,s.yg)(N8p,(0,p.A)({},b8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}k8p.isMDXComponent=!0;const z8p={toc:[]},P8p="wrapper";function I8p(e){let{components:n,...t}=e;return(0,s.yg)(P8p,(0,p.A)({},z8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}I8p.isMDXComponent=!0;const R8p={toc:[]},W8p="wrapper";function S8p(e){let{components:n,...t}=e;return(0,s.yg)(W8p,(0,p.A)({},R8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}S8p.isMDXComponent=!0;const B8p={toc:[]},G8p="wrapper";function E8p(e){let{components:n,...t}=e;return(0,s.yg)(G8p,(0,p.A)({},B8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}E8p.isMDXComponent=!0;const O8p={toc:[]},U8p="wrapper";function F8p(e){let{components:n,...t}=e;return(0,s.yg)(U8p,(0,p.A)({},O8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}F8p.isMDXComponent=!0;const V8p={toc:[]},q8p="wrapper";function j8p(e){let{components:n,...t}=e;return(0,s.yg)(q8p,(0,p.A)({},V8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}j8p.isMDXComponent=!0;const H8p={toc:[]},Y8p="wrapper";function Q8p(e){let{components:n,...t}=e;return(0,s.yg)(Y8p,(0,p.A)({},H8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Q8p.isMDXComponent=!0;const $8p={toc:[]},K8p="wrapper";function J8p(e){let{components:n,...t}=e;return(0,s.yg)(K8p,(0,p.A)({},$8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}J8p.isMDXComponent=!0;const Z8p={toc:[]},e2p="wrapper";function n2p(e){let{components:n,...t}=e;return(0,s.yg)(e2p,(0,p.A)({},Z8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}n2p.isMDXComponent=!0;const t2p={toc:[]},o2p="wrapper";function p2p(e){let{components:n,...t}=e;return(0,s.yg)(o2p,(0,p.A)({},t2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}p2p.isMDXComponent=!0;const r2p={toc:[]},s2p="wrapper";function c2p(e){let{components:n,...t}=e;return(0,s.yg)(s2p,(0,p.A)({},r2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}c2p.isMDXComponent=!0;const a2p={toc:[]},i2p="wrapper";function l2p(e){let{components:n,...t}=e;return(0,s.yg)(i2p,(0,p.A)({},a2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}l2p.isMDXComponent=!0;const u2p={toc:[]},m2p="wrapper";function y2p(e){let{components:n,...t}=e;return(0,s.yg)(m2p,(0,p.A)({},u2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}y2p.isMDXComponent=!0;const d2p={toc:[]},h2p="wrapper";function g2p(e){let{components:n,...t}=e;return(0,s.yg)(h2p,(0,p.A)({},d2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}g2p.isMDXComponent=!0;const f2p={toc:[]},D2p="wrapper";function M2p(e){let{components:n,...t}=e;return(0,s.yg)(D2p,(0,p.A)({},f2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}M2p.isMDXComponent=!0;const X2p={toc:[]},_2p="wrapper";function w2p(e){let{components:n,...t}=e;return(0,s.yg)(_2p,(0,p.A)({},X2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}w2p.isMDXComponent=!0;const T2p={toc:[]},C2p="wrapper";function x2p(e){let{components:n,...t}=e;return(0,s.yg)(C2p,(0,p.A)({},T2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}x2p.isMDXComponent=!0;const A2p={toc:[]},v2p="wrapper";function L2p(e){let{components:n,...t}=e;return(0,s.yg)(v2p,(0,p.A)({},A2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}L2p.isMDXComponent=!0;const b2p={toc:[]},N2p="wrapper";function k2p(e){let{components:n,...t}=e;return(0,s.yg)(N2p,(0,p.A)({},b2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}k2p.isMDXComponent=!0;const z2p={toc:[]},P2p="wrapper";function I2p(e){let{components:n,...t}=e;return(0,s.yg)(P2p,(0,p.A)({},z2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}I2p.isMDXComponent=!0;const R2p={toc:[]},W2p="wrapper";function S2p(e){let{components:n,...t}=e;return(0,s.yg)(W2p,(0,p.A)({},R2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}S2p.isMDXComponent=!0;const B2p={toc:[]},G2p="wrapper";function E2p(e){let{components:n,...t}=e;return(0,s.yg)(G2p,(0,p.A)({},B2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}E2p.isMDXComponent=!0;const O2p={toc:[]},U2p="wrapper";function F2p(e){let{components:n,...t}=e;return(0,s.yg)(U2p,(0,p.A)({},O2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}F2p.isMDXComponent=!0;const V2p={toc:[]},q2p="wrapper";function j2p(e){let{components:n,...t}=e;return(0,s.yg)(q2p,(0,p.A)({},V2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}j2p.isMDXComponent=!0;const H2p={toc:[]},Y2p="wrapper";function Q2p(e){let{components:n,...t}=e;return(0,s.yg)(Y2p,(0,p.A)({},H2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Q2p.isMDXComponent=!0;const $2p={toc:[]},K2p="wrapper";function J2p(e){let{components:n,...t}=e;return(0,s.yg)(K2p,(0,p.A)({},$2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}J2p.isMDXComponent=!0;const Z2p={toc:[]},e3p="wrapper";function n3p(e){let{components:n,...t}=e;return(0,s.yg)(e3p,(0,p.A)({},Z2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}n3p.isMDXComponent=!0;const t3p={toc:[]},o3p="wrapper";function p3p(e){let{components:n,...t}=e;return(0,s.yg)(o3p,(0,p.A)({},t3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}p3p.isMDXComponent=!0;const r3p={toc:[]},s3p="wrapper";function c3p(e){let{components:n,...t}=e;return(0,s.yg)(s3p,(0,p.A)({},r3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}c3p.isMDXComponent=!0;const a3p={toc:[]},i3p="wrapper";function l3p(e){let{components:n,...t}=e;return(0,s.yg)(i3p,(0,p.A)({},a3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}l3p.isMDXComponent=!0;const u3p={toc:[]},m3p="wrapper";function y3p(e){let{components:n,...t}=e;return(0,s.yg)(m3p,(0,p.A)({},u3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}y3p.isMDXComponent=!0;const d3p={toc:[]},h3p="wrapper";function g3p(e){let{components:n,...t}=e;return(0,s.yg)(h3p,(0,p.A)({},d3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}g3p.isMDXComponent=!0;const f3p={toc:[]},D3p="wrapper";function M3p(e){let{components:n,...t}=e;return(0,s.yg)(D3p,(0,p.A)({},f3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}M3p.isMDXComponent=!0;const X3p={toc:[]},_3p="wrapper";function w3p(e){let{components:n,...t}=e;return(0,s.yg)(_3p,(0,p.A)({},X3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}w3p.isMDXComponent=!0;const T3p={toc:[]},C3p="wrapper";function x3p(e){let{components:n,...t}=e;return(0,s.yg)(C3p,(0,p.A)({},T3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The points of the line."))}x3p.isMDXComponent=!0;const A3p={toc:[]},v3p="wrapper";function L3p(e){let{components:n,...t}=e;return(0,s.yg)(v3p,(0,p.A)({},A3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the line's corners."))}L3p.isMDXComponent=!0;const b3p={toc:[]},N3p="wrapper";function k3p(e){let{components:n,...t}=e;return(0,s.yg)(N3p,(0,p.A)({},b3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}k3p.isMDXComponent=!0;const z3p={toc:[]},P3p="wrapper";function I3p(e){let{components:n,...t}=e;return(0,s.yg)(P3p,(0,p.A)({},z3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}I3p.isMDXComponent=!0;const R3p={toc:[]},W3p="wrapper";function S3p(e){let{components:n,...t}=e;return(0,s.yg)(W3p,(0,p.A)({},R3p,t,{components:n,mdxType:"MDXLayout"}))}S3p.isMDXComponent=!0;const B3p={toc:[]},G3p="wrapper";function E3p(e){let{components:n,...t}=e;return(0,s.yg)(G3p,(0,p.A)({},B3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}E3p.isMDXComponent=!0;const O3p={toc:[]},U3p="wrapper";function F3p(e){let{components:n,...t}=e;return(0,s.yg)(U3p,(0,p.A)({},O3p,t,{components:n,mdxType:"MDXLayout"}))}F3p.isMDXComponent=!0;const V3p={toc:[]},q3p="wrapper";function j3p(e){let{components:n,...t}=e;return(0,s.yg)(q3p,(0,p.A)({},V3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}j3p.isMDXComponent=!0;const H3p={toc:[]},Y3p="wrapper";function Q3p(e){let{components:n,...t}=e;return(0,s.yg)(Y3p,(0,p.A)({},H3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Q3p.isMDXComponent=!0;const $3p={toc:[]},K3p="wrapper";function J3p(e){let{components:n,...t}=e;return(0,s.yg)(K3p,(0,p.A)({},$3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}J3p.isMDXComponent=!0;const Z3p={toc:[]},e1p="wrapper";function n1p(e){let{components:n,...t}=e;return(0,s.yg)(e1p,(0,p.A)({},Z3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}n1p.isMDXComponent=!0;const t1p={toc:[]},o1p="wrapper";function p1p(e){let{components:n,...t}=e;return(0,s.yg)(o1p,(0,p.A)({},t1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}p1p.isMDXComponent=!0;const r1p={toc:[]},s1p="wrapper";function c1p(e){let{components:n,...t}=e;return(0,s.yg)(s1p,(0,p.A)({},r1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}c1p.isMDXComponent=!0;const a1p={toc:[]},i1p="wrapper";function l1p(e){let{components:n,...t}=e;return(0,s.yg)(i1p,(0,p.A)({},a1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}l1p.isMDXComponent=!0;const u1p={toc:[]},m1p="wrapper";function y1p(e){let{components:n,...t}=e;return(0,s.yg)(m1p,(0,p.A)({},u1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}y1p.isMDXComponent=!0;const d1p={toc:[]},h1p="wrapper";function g1p(e){let{components:n,...t}=e;return(0,s.yg)(h1p,(0,p.A)({},d1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}g1p.isMDXComponent=!0;const f1p={toc:[]},D1p="wrapper";function M1p(e){let{components:n,...t}=e;return(0,s.yg)(D1p,(0,p.A)({},f1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}M1p.isMDXComponent=!0;const X1p={toc:[]},_1p="wrapper";function w1p(e){let{components:n,...t}=e;return(0,s.yg)(_1p,(0,p.A)({},X1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w1p.isMDXComponent=!0;const T1p={toc:[]},C1p="wrapper";function x1p(e){let{components:n,...t}=e;return(0,s.yg)(C1p,(0,p.A)({},T1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}x1p.isMDXComponent=!0;const A1p={toc:[]},v1p="wrapper";function L1p(e){let{components:n,...t}=e;return(0,s.yg)(v1p,(0,p.A)({},A1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}L1p.isMDXComponent=!0;const b1p={toc:[]},N1p="wrapper";function k1p(e){let{components:n,...t}=e;return(0,s.yg)(N1p,(0,p.A)({},b1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}k1p.isMDXComponent=!0;const z1p={toc:[]},P1p="wrapper";function I1p(e){let{components:n,...t}=e;return(0,s.yg)(P1p,(0,p.A)({},z1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}I1p.isMDXComponent=!0;const R1p={toc:[]},W1p="wrapper";function S1p(e){let{components:n,...t}=e;return(0,s.yg)(W1p,(0,p.A)({},R1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}S1p.isMDXComponent=!0;const B1p={toc:[]},G1p="wrapper";function E1p(e){let{components:n,...t}=e;return(0,s.yg)(G1p,(0,p.A)({},B1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}E1p.isMDXComponent=!0;const O1p={toc:[]},U1p="wrapper";function F1p(e){let{components:n,...t}=e;return(0,s.yg)(U1p,(0,p.A)({},O1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}F1p.isMDXComponent=!0;const V1p={toc:[]},q1p="wrapper";function j1p(e){let{components:n,...t}=e;return(0,s.yg)(q1p,(0,p.A)({},V1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}j1p.isMDXComponent=!0;const H1p={toc:[]},Y1p="wrapper";function Q1p(e){let{components:n,...t}=e;return(0,s.yg)(Y1p,(0,p.A)({},H1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Q1p.isMDXComponent=!0;const $1p={toc:[]},K1p="wrapper";function J1p(e){let{components:n,...t}=e;return(0,s.yg)(K1p,(0,p.A)({},$1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}J1p.isMDXComponent=!0;const Z1p={toc:[]},e4p="wrapper";function n4p(e){let{components:n,...t}=e;return(0,s.yg)(e4p,(0,p.A)({},Z1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}n4p.isMDXComponent=!0;const t4p={toc:[]},o4p="wrapper";function p4p(e){let{components:n,...t}=e;return(0,s.yg)(o4p,(0,p.A)({},t4p,t,{components:n,mdxType:"MDXLayout"}))}p4p.isMDXComponent=!0;const r4p={toc:[]},s4p="wrapper";function c4p(e){let{components:n,...t}=e;return(0,s.yg)(s4p,(0,p.A)({},r4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}c4p.isMDXComponent=!0;const a4p={toc:[]},i4p="wrapper";function l4p(e){let{components:n,...t}=e;return(0,s.yg)(i4p,(0,p.A)({},a4p,t,{components:n,mdxType:"MDXLayout"}))}l4p.isMDXComponent=!0;const u4p={toc:[]},m4p="wrapper";function y4p(e){let{components:n,...t}=e;return(0,s.yg)(m4p,(0,p.A)({},u4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}y4p.isMDXComponent=!0;const d4p={toc:[]},h4p="wrapper";function g4p(e){let{components:n,...t}=e;return(0,s.yg)(h4p,(0,p.A)({},d4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}g4p.isMDXComponent=!0;const f4p={toc:[]},D4p="wrapper";function M4p(e){let{components:n,...t}=e;return(0,s.yg)(D4p,(0,p.A)({},f4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}M4p.isMDXComponent=!0;const X4p={toc:[]},_4p="wrapper";function w4p(e){let{components:n,...t}=e;return(0,s.yg)(_4p,(0,p.A)({},X4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}w4p.isMDXComponent=!0;const T4p={toc:[]},C4p="wrapper";function x4p(e){let{components:n,...t}=e;return(0,s.yg)(C4p,(0,p.A)({},T4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}x4p.isMDXComponent=!0;const A4p={toc:[]},v4p="wrapper";function L4p(e){let{components:n,...t}=e;return(0,s.yg)(v4p,(0,p.A)({},A4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}L4p.isMDXComponent=!0;const b4p={toc:[]},N4p="wrapper";function k4p(e){let{components:n,...t}=e;return(0,s.yg)(N4p,(0,p.A)({},b4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}k4p.isMDXComponent=!0;const z4p={toc:[]},P4p="wrapper";function I4p(e){let{components:n,...t}=e;return(0,s.yg)(P4p,(0,p.A)({},z4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}I4p.isMDXComponent=!0;const R4p={toc:[]},W4p="wrapper";function S4p(e){let{components:n,...t}=e;return(0,s.yg)(W4p,(0,p.A)({},R4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}S4p.isMDXComponent=!0;const B4p={toc:[]},G4p="wrapper";function E4p(e){let{components:n,...t}=e;return(0,s.yg)(G4p,(0,p.A)({},B4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}E4p.isMDXComponent=!0;const O4p={toc:[]},U4p="wrapper";function F4p(e){let{components:n,...t}=e;return(0,s.yg)(U4p,(0,p.A)({},O4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}F4p.isMDXComponent=!0;const V4p={toc:[]},q4p="wrapper";function j4p(e){let{components:n,...t}=e;return(0,s.yg)(q4p,(0,p.A)({},V4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}j4p.isMDXComponent=!0;const H4p={toc:[]},Y4p="wrapper";function Q4p(e){let{components:n,...t}=e;return(0,s.yg)(Y4p,(0,p.A)({},H4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Q4p.isMDXComponent=!0;const $4p={toc:[]},K4p="wrapper";function J4p(e){let{components:n,...t}=e;return(0,s.yg)(K4p,(0,p.A)({},$4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}J4p.isMDXComponent=!0;const Z4p={toc:[]},e6p="wrapper";function n6p(e){let{components:n,...t}=e;return(0,s.yg)(e6p,(0,p.A)({},Z4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}n6p.isMDXComponent=!0;const t6p={toc:[]},o6p="wrapper";function p6p(e){let{components:n,...t}=e;return(0,s.yg)(o6p,(0,p.A)({},t6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}p6p.isMDXComponent=!0;const r6p={toc:[]},s6p="wrapper";function c6p(e){let{components:n,...t}=e;return(0,s.yg)(s6p,(0,p.A)({},r6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}c6p.isMDXComponent=!0;const a6p={toc:[]},i6p="wrapper";function l6p(e){let{components:n,...t}=e;return(0,s.yg)(i6p,(0,p.A)({},a6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}l6p.isMDXComponent=!0;const u6p={toc:[]},m6p="wrapper";function y6p(e){let{components:n,...t}=e;return(0,s.yg)(m6p,(0,p.A)({},u6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}y6p.isMDXComponent=!0;const d6p={toc:[]},h6p="wrapper";function g6p(e){let{components:n,...t}=e;return(0,s.yg)(h6p,(0,p.A)({},d6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}g6p.isMDXComponent=!0;const f6p={toc:[]},D6p="wrapper";function M6p(e){let{components:n,...t}=e;return(0,s.yg)(D6p,(0,p.A)({},f6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}M6p.isMDXComponent=!0;const X6p={toc:[]},_6p="wrapper";function w6p(e){let{components:n,...t}=e;return(0,s.yg)(_6p,(0,p.A)({},X6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}w6p.isMDXComponent=!0;const T6p={toc:[]},C6p="wrapper";function x6p(e){let{components:n,...t}=e;return(0,s.yg)(C6p,(0,p.A)({},T6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}x6p.isMDXComponent=!0;const A6p={toc:[]},v6p="wrapper";function L6p(e){let{components:n,...t}=e;return(0,s.yg)(v6p,(0,p.A)({},A6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}L6p.isMDXComponent=!0;const b6p={toc:[]},N6p="wrapper";function k6p(e){let{components:n,...t}=e;return(0,s.yg)(N6p,(0,p.A)({},b6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}k6p.isMDXComponent=!0;const z6p={toc:[]},P6p="wrapper";function I6p(e){let{components:n,...t}=e;return(0,s.yg)(P6p,(0,p.A)({},z6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}I6p.isMDXComponent=!0;const R6p={toc:[]},W6p="wrapper";function S6p(e){let{components:n,...t}=e;return(0,s.yg)(W6p,(0,p.A)({},R6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}S6p.isMDXComponent=!0;const B6p={toc:[]},G6p="wrapper";function E6p(e){let{components:n,...t}=e;return(0,s.yg)(G6p,(0,p.A)({},B6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}E6p.isMDXComponent=!0;const O6p={toc:[]},U6p="wrapper";function F6p(e){let{components:n,...t}=e;return(0,s.yg)(U6p,(0,p.A)({},O6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}F6p.isMDXComponent=!0;const V6p={toc:[]},q6p="wrapper";function j6p(e){let{components:n,...t}=e;return(0,s.yg)(q6p,(0,p.A)({},V6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}j6p.isMDXComponent=!0;const H6p={toc:[]},Y6p="wrapper";function Q6p(e){let{components:n,...t}=e;return(0,s.yg)(Y6p,(0,p.A)({},H6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Q6p.isMDXComponent=!0;const $6p={toc:[]},K6p="wrapper";function J6p(e){let{components:n,...t}=e;return(0,s.yg)(K6p,(0,p.A)({},$6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}J6p.isMDXComponent=!0;const Z6p={toc:[]},e5p="wrapper";function n5p(e){let{components:n,...t}=e;return(0,s.yg)(e5p,(0,p.A)({},Z6p,t,{components:n,mdxType:"MDXLayout"}))}n5p.isMDXComponent=!0;const t5p={toc:[]},o5p="wrapper";function p5p(e){let{components:n,...t}=e;return(0,s.yg)(o5p,(0,p.A)({},t5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}p5p.isMDXComponent=!0;const r5p={toc:[]},s5p="wrapper";function c5p(e){let{components:n,...t}=e;return(0,s.yg)(s5p,(0,p.A)({},r5p,t,{components:n,mdxType:"MDXLayout"}))}c5p.isMDXComponent=!0;const a5p={toc:[]},i5p="wrapper";function l5p(e){let{components:n,...t}=e;return(0,s.yg)(i5p,(0,p.A)({},a5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}l5p.isMDXComponent=!0;const u5p={toc:[]},m5p="wrapper";function y5p(e){let{components:n,...t}=e;return(0,s.yg)(m5p,(0,p.A)({},u5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}y5p.isMDXComponent=!0;const d5p={toc:[]},h5p="wrapper";function g5p(e){let{components:n,...t}=e;return(0,s.yg)(h5p,(0,p.A)({},d5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}g5p.isMDXComponent=!0;const f5p={toc:[]},D5p="wrapper";function M5p(e){let{components:n,...t}=e;return(0,s.yg)(D5p,(0,p.A)({},f5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}M5p.isMDXComponent=!0;const X5p={toc:[]},_5p="wrapper";function w5p(e){let{components:n,...t}=e;return(0,s.yg)(_5p,(0,p.A)({},X5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}w5p.isMDXComponent=!0;const T5p={toc:[]},C5p="wrapper";function x5p(e){let{components:n,...t}=e;return(0,s.yg)(C5p,(0,p.A)({},T5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}x5p.isMDXComponent=!0;const A5p={toc:[]},v5p="wrapper";function L5p(e){let{components:n,...t}=e;return(0,s.yg)(v5p,(0,p.A)({},A5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}L5p.isMDXComponent=!0;const b5p={toc:[]},N5p="wrapper";function k5p(e){let{components:n,...t}=e;return(0,s.yg)(N5p,(0,p.A)({},b5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}k5p.isMDXComponent=!0;const z5p={toc:[]},P5p="wrapper";function I5p(e){let{components:n,...t}=e;return(0,s.yg)(P5p,(0,p.A)({},z5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}I5p.isMDXComponent=!0;const R5p={toc:[]},W5p="wrapper";function S5p(e){let{components:n,...t}=e;return(0,s.yg)(W5p,(0,p.A)({},R5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}S5p.isMDXComponent=!0;const B5p={toc:[]},G5p="wrapper";function E5p(e){let{components:n,...t}=e;return(0,s.yg)(G5p,(0,p.A)({},B5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}E5p.isMDXComponent=!0;const O5p={toc:[]},U5p="wrapper";function F5p(e){let{components:n,...t}=e;return(0,s.yg)(U5p,(0,p.A)({},O5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}F5p.isMDXComponent=!0;const V5p={toc:[]},q5p="wrapper";function j5p(e){let{components:n,...t}=e;return(0,s.yg)(q5p,(0,p.A)({},V5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}j5p.isMDXComponent=!0;const H5p={toc:[]},Y5p="wrapper";function Q5p(e){let{components:n,...t}=e;return(0,s.yg)(Y5p,(0,p.A)({},H5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Q5p.isMDXComponent=!0;const $5p={toc:[]},K5p="wrapper";function J5p(e){let{components:n,...t}=e;return(0,s.yg)(K5p,(0,p.A)({},$5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}J5p.isMDXComponent=!0;const Z5p={toc:[]},e7p="wrapper";function n7p(e){let{components:n,...t}=e;return(0,s.yg)(e7p,(0,p.A)({},Z5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}n7p.isMDXComponent=!0;const t7p={toc:[]},o7p="wrapper";function p7p(e){let{components:n,...t}=e;return(0,s.yg)(o7p,(0,p.A)({},t7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}p7p.isMDXComponent=!0;const r7p={toc:[]},s7p="wrapper";function c7p(e){let{components:n,...t}=e;return(0,s.yg)(s7p,(0,p.A)({},r7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}c7p.isMDXComponent=!0;const a7p={toc:[]},i7p="wrapper";function l7p(e){let{components:n,...t}=e;return(0,s.yg)(i7p,(0,p.A)({},a7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}l7p.isMDXComponent=!0;const u7p={toc:[]},m7p="wrapper";function y7p(e){let{components:n,...t}=e;return(0,s.yg)(m7p,(0,p.A)({},u7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}y7p.isMDXComponent=!0;const d7p={toc:[]},h7p="wrapper";function g7p(e){let{components:n,...t}=e;return(0,s.yg)(h7p,(0,p.A)({},d7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}g7p.isMDXComponent=!0;const f7p={toc:[]},D7p="wrapper";function M7p(e){let{components:n,...t}=e;return(0,s.yg)(D7p,(0,p.A)({},f7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}M7p.isMDXComponent=!0;const X7p={toc:[]},_7p="wrapper";function w7p(e){let{components:n,...t}=e;return(0,s.yg)(_7p,(0,p.A)({},X7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}w7p.isMDXComponent=!0;const T7p={toc:[]},C7p="wrapper";function x7p(e){let{components:n,...t}=e;return(0,s.yg)(C7p,(0,p.A)({},T7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}x7p.isMDXComponent=!0;const A7p={toc:[]},v7p="wrapper";function L7p(e){let{components:n,...t}=e;return(0,s.yg)(v7p,(0,p.A)({},A7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}L7p.isMDXComponent=!0;const b7p={toc:[]},N7p="wrapper";function k7p(e){let{components:n,...t}=e;return(0,s.yg)(N7p,(0,p.A)({},b7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}k7p.isMDXComponent=!0;const z7p={toc:[]},P7p="wrapper";function I7p(e){let{components:n,...t}=e;return(0,s.yg)(P7p,(0,p.A)({},z7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}I7p.isMDXComponent=!0;const R7p={toc:[]},W7p="wrapper";function S7p(e){let{components:n,...t}=e;return(0,s.yg)(W7p,(0,p.A)({},R7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}S7p.isMDXComponent=!0;const B7p={toc:[]},G7p="wrapper";function E7p(e){let{components:n,...t}=e;return(0,s.yg)(G7p,(0,p.A)({},B7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}E7p.isMDXComponent=!0;const O7p={toc:[]},U7p="wrapper";function F7p(e){let{components:n,...t}=e;return(0,s.yg)(U7p,(0,p.A)({},O7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}F7p.isMDXComponent=!0;const V7p={toc:[]},q7p="wrapper";function j7p(e){let{components:n,...t}=e;return(0,s.yg)(q7p,(0,p.A)({},V7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}j7p.isMDXComponent=!0;const H7p={toc:[]},Y7p="wrapper";function Q7p(e){let{components:n,...t}=e;return(0,s.yg)(Y7p,(0,p.A)({},H7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Q7p.isMDXComponent=!0;const $7p={toc:[]},K7p="wrapper";function J7p(e){let{components:n,...t}=e;return(0,s.yg)(K7p,(0,p.A)({},$7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}J7p.isMDXComponent=!0;const Z7p={toc:[]},e9p="wrapper";function n9p(e){let{components:n,...t}=e;return(0,s.yg)(e9p,(0,p.A)({},Z7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}n9p.isMDXComponent=!0;const t9p={toc:[]},o9p="wrapper";function p9p(e){let{components:n,...t}=e;return(0,s.yg)(o9p,(0,p.A)({},t9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}p9p.isMDXComponent=!0;const r9p={toc:[]},s9p="wrapper";function c9p(e){let{components:n,...t}=e;return(0,s.yg)(s9p,(0,p.A)({},r9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}c9p.isMDXComponent=!0;const a9p={toc:[]},i9p="wrapper";function l9p(e){let{components:n,...t}=e;return(0,s.yg)(i9p,(0,p.A)({},a9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}l9p.isMDXComponent=!0;const u9p={toc:[]},m9p="wrapper";function y9p(e){let{components:n,...t}=e;return(0,s.yg)(m9p,(0,p.A)({},u9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}y9p.isMDXComponent=!0;const d9p={toc:[]},h9p="wrapper";function g9p(e){let{components:n,...t}=e;return(0,s.yg)(h9p,(0,p.A)({},d9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}g9p.isMDXComponent=!0;const f9p={toc:[]},D9p="wrapper";function M9p(e){let{components:n,...t}=e;return(0,s.yg)(D9p,(0,p.A)({},f9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}M9p.isMDXComponent=!0;const X9p={toc:[]},_9p="wrapper";function w9p(e){let{components:n,...t}=e;return(0,s.yg)(_9p,(0,p.A)({},X9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}w9p.isMDXComponent=!0;const T9p={toc:[]},C9p="wrapper";function x9p(e){let{components:n,...t}=e;return(0,s.yg)(C9p,(0,p.A)({},T9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}x9p.isMDXComponent=!0;const A9p={toc:[]},v9p="wrapper";function L9p(e){let{components:n,...t}=e;return(0,s.yg)(v9p,(0,p.A)({},A9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the polygon's corners."))}L9p.isMDXComponent=!0;const b9p={toc:[]},N9p="wrapper";function k9p(e){let{components:n,...t}=e;return(0,s.yg)(N9p,(0,p.A)({},b9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}k9p.isMDXComponent=!0;const z9p={toc:[]},P9p="wrapper";function I9p(e){let{components:n,...t}=e;return(0,s.yg)(P9p,(0,p.A)({},z9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}I9p.isMDXComponent=!0;const R9p={toc:[]},W9p="wrapper";function S9p(e){let{components:n,...t}=e;return(0,s.yg)(W9p,(0,p.A)({},R9p,t,{components:n,mdxType:"MDXLayout"}))}S9p.isMDXComponent=!0;const B9p={toc:[]},G9p="wrapper";function E9p(e){let{components:n,...t}=e;return(0,s.yg)(G9p,(0,p.A)({},B9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"For example, a value of 6 creates a hexagon."))}E9p.isMDXComponent=!0;const O9p={toc:[]},U9p="wrapper";function F9p(e){let{components:n,...t}=e;return(0,s.yg)(U9p,(0,p.A)({},O9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of sides of the polygon."))}F9p.isMDXComponent=!0;const V9p={toc:[]},q9p="wrapper";function j9p(e){let{components:n,...t}=e;return(0,s.yg)(q9p,(0,p.A)({},V9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}j9p.isMDXComponent=!0;const H9p={toc:[]},Y9p="wrapper";function Q9p(e){let{components:n,...t}=e;return(0,s.yg)(Y9p,(0,p.A)({},H9p,t,{components:n,mdxType:"MDXLayout"}))}Q9p.isMDXComponent=!0;const $9p={toc:[]},K9p="wrapper";function J9p(e){let{components:n,...t}=e;return(0,s.yg)(K9p,(0,p.A)({},$9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}J9p.isMDXComponent=!0;const Z9p={toc:[]},eer="wrapper";function ner(e){let{components:n,...t}=e;return(0,s.yg)(eer,(0,p.A)({},Z9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}ner.isMDXComponent=!0;const ter={toc:[]},oer="wrapper";function per(e){let{components:n,...t}=e;return(0,s.yg)(oer,(0,p.A)({},ter,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}per.isMDXComponent=!0;const rer={toc:[]},ser="wrapper";function cer(e){let{components:n,...t}=e;return(0,s.yg)(ser,(0,p.A)({},rer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}cer.isMDXComponent=!0;const aer={toc:[]},ier="wrapper";function ler(e){let{components:n,...t}=e;return(0,s.yg)(ier,(0,p.A)({},aer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ler.isMDXComponent=!0;const uer={toc:[]},mer="wrapper";function yer(e){let{components:n,...t}=e;return(0,s.yg)(mer,(0,p.A)({},uer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}yer.isMDXComponent=!0;const der={toc:[]},her="wrapper";function ger(e){let{components:n,...t}=e;return(0,s.yg)(her,(0,p.A)({},der,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ger.isMDXComponent=!0;const fer={toc:[]},Der="wrapper";function Mer(e){let{components:n,...t}=e;return(0,s.yg)(Der,(0,p.A)({},fer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Mer.isMDXComponent=!0;const Xer={toc:[]},_er="wrapper";function wer(e){let{components:n,...t}=e;return(0,s.yg)(_er,(0,p.A)({},Xer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wer.isMDXComponent=!0;const Ter={toc:[]},Cer="wrapper";function xer(e){let{components:n,...t}=e;return(0,s.yg)(Cer,(0,p.A)({},Ter,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}xer.isMDXComponent=!0;const Aer={toc:[]},ver="wrapper";function Ler(e){let{components:n,...t}=e;return(0,s.yg)(ver,(0,p.A)({},Aer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ler.isMDXComponent=!0;const ber={toc:[]},Ner="wrapper";function ker(e){let{components:n,...t}=e;return(0,s.yg)(Ner,(0,p.A)({},ber,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ker.isMDXComponent=!0;const zer={toc:[]},Per="wrapper";function Ier(e){let{components:n,...t}=e;return(0,s.yg)(Per,(0,p.A)({},zer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ier.isMDXComponent=!0;const Rer={toc:[]},Wer="wrapper";function Ser(e){let{components:n,...t}=e;return(0,s.yg)(Wer,(0,p.A)({},Rer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Ser.isMDXComponent=!0;const Ber={toc:[]},Ger="wrapper";function Eer(e){let{components:n,...t}=e;return(0,s.yg)(Ger,(0,p.A)({},Ber,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Eer.isMDXComponent=!0;const Oer={toc:[]},Uer="wrapper";function Fer(e){let{components:n,...t}=e;return(0,s.yg)(Uer,(0,p.A)({},Oer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Fer.isMDXComponent=!0;const Ver={toc:[]},qer="wrapper";function jer(e){let{components:n,...t}=e;return(0,s.yg)(qer,(0,p.A)({},Ver,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jer.isMDXComponent=!0;const Her={toc:[]},Yer="wrapper";function Qer(e){let{components:n,...t}=e;return(0,s.yg)(Yer,(0,p.A)({},Her,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Qer.isMDXComponent=!0;const $er={toc:[]},Ker="wrapper";function Jer(e){let{components:n,...t}=e;return(0,s.yg)(Ker,(0,p.A)({},$er,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Jer.isMDXComponent=!0;const Zer={toc:[]},enr="wrapper";function nnr(e){let{components:n,...t}=e;return(0,s.yg)(enr,(0,p.A)({},Zer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}nnr.isMDXComponent=!0;const tnr={toc:[]},onr="wrapper";function pnr(e){let{components:n,...t}=e;return(0,s.yg)(onr,(0,p.A)({},tnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pnr.isMDXComponent=!0;const rnr={toc:[]},snr="wrapper";function cnr(e){let{components:n,...t}=e;return(0,s.yg)(snr,(0,p.A)({},rnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cnr.isMDXComponent=!0;const anr={toc:[]},inr="wrapper";function lnr(e){let{components:n,...t}=e;return(0,s.yg)(inr,(0,p.A)({},anr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lnr.isMDXComponent=!0;const unr={toc:[]},mnr="wrapper";function ynr(e){let{components:n,...t}=e;return(0,s.yg)(mnr,(0,p.A)({},unr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ynr.isMDXComponent=!0;const dnr={toc:[]},hnr="wrapper";function gnr(e){let{components:n,...t}=e;return(0,s.yg)(hnr,(0,p.A)({},dnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gnr.isMDXComponent=!0;const fnr={toc:[]},Dnr="wrapper";function Mnr(e){let{components:n,...t}=e;return(0,s.yg)(Dnr,(0,p.A)({},fnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Mnr.isMDXComponent=!0;const Xnr={toc:[]},_nr="wrapper";function wnr(e){let{components:n,...t}=e;return(0,s.yg)(_nr,(0,p.A)({},Xnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wnr.isMDXComponent=!0;const Tnr={toc:[]},Cnr="wrapper";function xnr(e){let{components:n,...t}=e;return(0,s.yg)(Cnr,(0,p.A)({},Tnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xnr.isMDXComponent=!0;const Anr={toc:[]},vnr="wrapper";function Lnr(e){let{components:n,...t}=e;return(0,s.yg)(vnr,(0,p.A)({},Anr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Lnr.isMDXComponent=!0;const bnr={toc:[]},Nnr="wrapper";function knr(e){let{components:n,...t}=e;return(0,s.yg)(Nnr,(0,p.A)({},bnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}knr.isMDXComponent=!0;const znr={toc:[]},Pnr="wrapper";function Inr(e){let{components:n,...t}=e;return(0,s.yg)(Pnr,(0,p.A)({},znr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Inr.isMDXComponent=!0;const Rnr={toc:[]},Wnr="wrapper";function Snr(e){let{components:n,...t}=e;return(0,s.yg)(Wnr,(0,p.A)({},Rnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Snr.isMDXComponent=!0;const Bnr={toc:[]},Gnr="wrapper";function Enr(e){let{components:n,...t}=e;return(0,s.yg)(Gnr,(0,p.A)({},Bnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Enr.isMDXComponent=!0;const Onr={toc:[]},Unr="wrapper";function Fnr(e){let{components:n,...t}=e;return(0,s.yg)(Unr,(0,p.A)({},Onr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Fnr.isMDXComponent=!0;const Vnr={toc:[]},qnr="wrapper";function jnr(e){let{components:n,...t}=e;return(0,s.yg)(qnr,(0,p.A)({},Vnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}jnr.isMDXComponent=!0;const Hnr={toc:[]},Ynr="wrapper";function Qnr(e){let{components:n,...t}=e;return(0,s.yg)(Ynr,(0,p.A)({},Hnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Qnr.isMDXComponent=!0;const $nr={toc:[]},Knr="wrapper";function Jnr(e){let{components:n,...t}=e;return(0,s.yg)(Knr,(0,p.A)({},$nr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Jnr.isMDXComponent=!0;const Znr={toc:[]},etr="wrapper";function ntr(e){let{components:n,...t}=e;return(0,s.yg)(etr,(0,p.A)({},Znr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}ntr.isMDXComponent=!0;const ttr={toc:[]},otr="wrapper";function ptr(e){let{components:n,...t}=e;return(0,s.yg)(otr,(0,p.A)({},ttr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ptr.isMDXComponent=!0;const rtr={toc:[]},str="wrapper";function ctr(e){let{components:n,...t}=e;return(0,s.yg)(str,(0,p.A)({},rtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}ctr.isMDXComponent=!0;const atr={toc:[]},itr="wrapper";function ltr(e){let{components:n,...t}=e;return(0,s.yg)(itr,(0,p.A)({},atr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}ltr.isMDXComponent=!0;const utr={toc:[]},mtr="wrapper";function ytr(e){let{components:n,...t}=e;return(0,s.yg)(mtr,(0,p.A)({},utr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}ytr.isMDXComponent=!0;const dtr={toc:[]},htr="wrapper";function gtr(e){let{components:n,...t}=e;return(0,s.yg)(htr,(0,p.A)({},dtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gtr.isMDXComponent=!0;const ftr={toc:[]},Dtr="wrapper";function Mtr(e){let{components:n,...t}=e;return(0,s.yg)(Dtr,(0,p.A)({},ftr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Mtr.isMDXComponent=!0;const Xtr={toc:[]},_tr="wrapper";function wtr(e){let{components:n,...t}=e;return(0,s.yg)(_tr,(0,p.A)({},Xtr,t,{components:n,mdxType:"MDXLayout"}))}wtr.isMDXComponent=!0;const Ttr={toc:[]},Ctr="wrapper";function xtr(e){let{components:n,...t}=e;return(0,s.yg)(Ctr,(0,p.A)({},Ttr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}xtr.isMDXComponent=!0;const Atr={toc:[]},vtr="wrapper";function Ltr(e){let{components:n,...t}=e;return(0,s.yg)(vtr,(0,p.A)({},Atr,t,{components:n,mdxType:"MDXLayout"}))}Ltr.isMDXComponent=!0;const btr={toc:[]},Ntr="wrapper";function ktr(e){let{components:n,...t}=e;return(0,s.yg)(Ntr,(0,p.A)({},btr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ktr.isMDXComponent=!0;const ztr={toc:[]},Ptr="wrapper";function Itr(e){let{components:n,...t}=e;return(0,s.yg)(Ptr,(0,p.A)({},ztr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Itr.isMDXComponent=!0;const Rtr={toc:[]},Wtr="wrapper";function Str(e){let{components:n,...t}=e;return(0,s.yg)(Wtr,(0,p.A)({},Rtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Str.isMDXComponent=!0;const Btr={toc:[]},Gtr="wrapper";function Etr(e){let{components:n,...t}=e;return(0,s.yg)(Gtr,(0,p.A)({},Btr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Etr.isMDXComponent=!0;const Otr={toc:[]},Utr="wrapper";function Ftr(e){let{components:n,...t}=e;return(0,s.yg)(Utr,(0,p.A)({},Otr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ftr.isMDXComponent=!0;const Vtr={toc:[]},qtr="wrapper";function jtr(e){let{components:n,...t}=e;return(0,s.yg)(qtr,(0,p.A)({},Vtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}jtr.isMDXComponent=!0;const Htr={toc:[]},Ytr="wrapper";function Qtr(e){let{components:n,...t}=e;return(0,s.yg)(Ytr,(0,p.A)({},Htr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Qtr.isMDXComponent=!0;const $tr={toc:[]},Ktr="wrapper";function Jtr(e){let{components:n,...t}=e;return(0,s.yg)(Ktr,(0,p.A)({},$tr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Jtr.isMDXComponent=!0;const Ztr={toc:[]},eor="wrapper";function nor(e){let{components:n,...t}=e;return(0,s.yg)(eor,(0,p.A)({},Ztr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nor.isMDXComponent=!0;const tor={toc:[]},oor="wrapper";function por(e){let{components:n,...t}=e;return(0,s.yg)(oor,(0,p.A)({},tor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}por.isMDXComponent=!0;const ror={toc:[]},sor="wrapper";function cor(e){let{components:n,...t}=e;return(0,s.yg)(sor,(0,p.A)({},ror,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cor.isMDXComponent=!0;const aor={toc:[]},ior="wrapper";function lor(e){let{components:n,...t}=e;return(0,s.yg)(ior,(0,p.A)({},aor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}lor.isMDXComponent=!0;const uor={toc:[]},mor="wrapper";function yor(e){let{components:n,...t}=e;return(0,s.yg)(mor,(0,p.A)({},uor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}yor.isMDXComponent=!0;const dor={toc:[]},hor="wrapper";function gor(e){let{components:n,...t}=e;return(0,s.yg)(hor,(0,p.A)({},dor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}gor.isMDXComponent=!0;const Dor={toc:[]},Mor="wrapper";function Xor(e){let{components:n,...t}=e;return(0,s.yg)(Mor,(0,p.A)({},Dor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Xor.isMDXComponent=!0;const _or={toc:[]},wor="wrapper";function Tor(e){let{components:n,...t}=e;return(0,s.yg)(wor,(0,p.A)({},_or,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Tor.isMDXComponent=!0;const Cor={toc:[]},xor="wrapper";function Aor(e){let{components:n,...t}=e;return(0,s.yg)(xor,(0,p.A)({},Cor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Aor.isMDXComponent=!0;const vor={toc:[]},Lor="wrapper";function bor(e){let{components:n,...t}=e;return(0,s.yg)(Lor,(0,p.A)({},vor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}bor.isMDXComponent=!0;const Nor={toc:[]},kor="wrapper";function zor(e){let{components:n,...t}=e;return(0,s.yg)(kor,(0,p.A)({},Nor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}zor.isMDXComponent=!0;const Por={toc:[]},Ior="wrapper";function Ror(e){let{components:n,...t}=e;return(0,s.yg)(Ior,(0,p.A)({},Por,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Ror.isMDXComponent=!0;const Wor={toc:[]},Sor="wrapper";function Bor(e){let{components:n,...t}=e;return(0,s.yg)(Sor,(0,p.A)({},Wor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Bor.isMDXComponent=!0;const Gor={toc:[]},Eor="wrapper";function Oor(e){let{components:n,...t}=e;return(0,s.yg)(Eor,(0,p.A)({},Gor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Oor.isMDXComponent=!0;const Uor={toc:[]},For="wrapper";function Vor(e){let{components:n,...t}=e;return(0,s.yg)(For,(0,p.A)({},Uor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Vor.isMDXComponent=!0;const qor={toc:[]},jor="wrapper";function Hor(e){let{components:n,...t}=e;return(0,s.yg)(jor,(0,p.A)({},qor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Hor.isMDXComponent=!0;const Yor={toc:[]},Qor="wrapper";function $or(e){let{components:n,...t}=e;return(0,s.yg)(Qor,(0,p.A)({},Yor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}$or.isMDXComponent=!0;const Kor={toc:[]},Jor="wrapper";function Zor(e){let{components:n,...t}=e;return(0,s.yg)(Jor,(0,p.A)({},Kor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Zor.isMDXComponent=!0;const epr={toc:[]},npr="wrapper";function tpr(e){let{components:n,...t}=e;return(0,s.yg)(npr,(0,p.A)({},epr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}tpr.isMDXComponent=!0;const opr={toc:[]},ppr="wrapper";function rpr(e){let{components:n,...t}=e;return(0,s.yg)(ppr,(0,p.A)({},opr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}rpr.isMDXComponent=!0;const spr={toc:[]},cpr="wrapper";function apr(e){let{components:n,...t}=e;return(0,s.yg)(cpr,(0,p.A)({},spr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}apr.isMDXComponent=!0;const ipr={toc:[]},lpr="wrapper";function upr(e){let{components:n,...t}=e;return(0,s.yg)(lpr,(0,p.A)({},ipr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}upr.isMDXComponent=!0;const mpr={toc:[]},ypr="wrapper";function dpr(e){let{components:n,...t}=e;return(0,s.yg)(ypr,(0,p.A)({},mpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}dpr.isMDXComponent=!0;const hpr={toc:[]},gpr="wrapper";function fpr(e){let{components:n,...t}=e;return(0,s.yg)(gpr,(0,p.A)({},hpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}fpr.isMDXComponent=!0;const Dpr={toc:[]},Mpr="wrapper";function Xpr(e){let{components:n,...t}=e;return(0,s.yg)(Mpr,(0,p.A)({},Dpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Xpr.isMDXComponent=!0;const _pr={toc:[]},wpr="wrapper";function Tpr(e){let{components:n,...t}=e;return(0,s.yg)(wpr,(0,p.A)({},_pr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Tpr.isMDXComponent=!0;const Cpr={toc:[]},xpr="wrapper";function Apr(e){let{components:n,...t}=e;return(0,s.yg)(xpr,(0,p.A)({},Cpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Apr.isMDXComponent=!0;const vpr={toc:[]},Lpr="wrapper";function bpr(e){let{components:n,...t}=e;return(0,s.yg)(Lpr,(0,p.A)({},vpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}bpr.isMDXComponent=!0;const Npr={toc:[]},kpr="wrapper";function zpr(e){let{components:n,...t}=e;return(0,s.yg)(kpr,(0,p.A)({},Npr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}zpr.isMDXComponent=!0;const Ppr={toc:[]},Ipr="wrapper";function Rpr(e){let{components:n,...t}=e;return(0,s.yg)(Ipr,(0,p.A)({},Ppr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Rpr.isMDXComponent=!0;const Wpr={toc:[]},Spr="wrapper";function Bpr(e){let{components:n,...t}=e;return(0,s.yg)(Spr,(0,p.A)({},Wpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting point of the ray."))}Bpr.isMDXComponent=!0;const Gpr={toc:[]},Epr="wrapper";function Opr(e){let{components:n,...t}=e;return(0,s.yg)(Epr,(0,p.A)({},Gpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Opr.isMDXComponent=!0;const Upr={toc:[]},Fpr="wrapper";function Vpr(e){let{components:n,...t}=e;return(0,s.yg)(Fpr,(0,p.A)({},Upr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Vpr.isMDXComponent=!0;const qpr={toc:[]},jpr="wrapper";function Hpr(e){let{components:n,...t}=e;return(0,s.yg)(jpr,(0,p.A)({},qpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Hpr.isMDXComponent=!0;const Ypr={toc:[]},Qpr="wrapper";function $pr(e){let{components:n,...t}=e;return(0,s.yg)(Qpr,(0,p.A)({},Ypr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}$pr.isMDXComponent=!0;const Kpr={toc:[]},Jpr="wrapper";function Zpr(e){let{components:n,...t}=e;return(0,s.yg)(Jpr,(0,p.A)({},Kpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Zpr.isMDXComponent=!0;const err={toc:[]},nrr="wrapper";function trr(e){let{components:n,...t}=e;return(0,s.yg)(nrr,(0,p.A)({},err,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}trr.isMDXComponent=!0;const orr={toc:[]},prr="wrapper";function rrr(e){let{components:n,...t}=e;return(0,s.yg)(prr,(0,p.A)({},orr,t,{components:n,mdxType:"MDXLayout"}))}rrr.isMDXComponent=!0;const srr={toc:[]},crr="wrapper";function arr(e){let{components:n,...t}=e;return(0,s.yg)(crr,(0,p.A)({},srr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}arr.isMDXComponent=!0;const irr={toc:[]},lrr="wrapper";function urr(e){let{components:n,...t}=e;return(0,s.yg)(lrr,(0,p.A)({},irr,t,{components:n,mdxType:"MDXLayout"}))}urr.isMDXComponent=!0;const mrr={toc:[]},yrr="wrapper";function drr(e){let{components:n,...t}=e;return(0,s.yg)(yrr,(0,p.A)({},mrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}drr.isMDXComponent=!0;const hrr={toc:[]},grr="wrapper";function frr(e){let{components:n,...t}=e;return(0,s.yg)(grr,(0,p.A)({},hrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}frr.isMDXComponent=!0;const Drr={toc:[]},Mrr="wrapper";function Xrr(e){let{components:n,...t}=e;return(0,s.yg)(Mrr,(0,p.A)({},Drr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Xrr.isMDXComponent=!0;const _rr={toc:[]},wrr="wrapper";function Trr(e){let{components:n,...t}=e;return(0,s.yg)(wrr,(0,p.A)({},_rr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Trr.isMDXComponent=!0;const Crr={toc:[]},xrr="wrapper";function Arr(e){let{components:n,...t}=e;return(0,s.yg)(xrr,(0,p.A)({},Crr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Arr.isMDXComponent=!0;const vrr={toc:[]},Lrr="wrapper";function brr(e){let{components:n,...t}=e;return(0,s.yg)(Lrr,(0,p.A)({},vrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}brr.isMDXComponent=!0;const Nrr={toc:[]},krr="wrapper";function zrr(e){let{components:n,...t}=e;return(0,s.yg)(krr,(0,p.A)({},Nrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending point of the ray."))}zrr.isMDXComponent=!0;const Prr={toc:[]},Irr="wrapper";function Rrr(e){let{components:n,...t}=e;return(0,s.yg)(Irr,(0,p.A)({},Prr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Rrr.isMDXComponent=!0;const Wrr={toc:[]},Srr="wrapper";function Brr(e){let{components:n,...t}=e;return(0,s.yg)(Srr,(0,p.A)({},Wrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Brr.isMDXComponent=!0;const Grr={toc:[]},Err="wrapper";function Orr(e){let{components:n,...t}=e;return(0,s.yg)(Err,(0,p.A)({},Grr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Orr.isMDXComponent=!0;const Urr={toc:[]},Frr="wrapper";function Vrr(e){let{components:n,...t}=e;return(0,s.yg)(Frr,(0,p.A)({},Urr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Vrr.isMDXComponent=!0;const qrr={toc:[]},jrr="wrapper";function Hrr(e){let{components:n,...t}=e;return(0,s.yg)(jrr,(0,p.A)({},qrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Hrr.isMDXComponent=!0;const Yrr={toc:[]},Qrr="wrapper";function $rr(e){let{components:n,...t}=e;return(0,s.yg)(Qrr,(0,p.A)({},Yrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}$rr.isMDXComponent=!0;const Krr={toc:[]},Jrr="wrapper";function Zrr(e){let{components:n,...t}=e;return(0,s.yg)(Jrr,(0,p.A)({},Krr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Zrr.isMDXComponent=!0;const esr={toc:[]},nsr="wrapper";function tsr(e){let{components:n,...t}=e;return(0,s.yg)(nsr,(0,p.A)({},esr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}tsr.isMDXComponent=!0;const osr={toc:[]},psr="wrapper";function rsr(e){let{components:n,...t}=e;return(0,s.yg)(psr,(0,p.A)({},osr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}rsr.isMDXComponent=!0;const ssr={toc:[]},csr="wrapper";function asr(e){let{components:n,...t}=e;return(0,s.yg)(csr,(0,p.A)({},ssr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}asr.isMDXComponent=!0;const isr={toc:[]},lsr="wrapper";function usr(e){let{components:n,...t}=e;return(0,s.yg)(lsr,(0,p.A)({},isr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}usr.isMDXComponent=!0;const msr={toc:[]},ysr="wrapper";function dsr(e){let{components:n,...t}=e;return(0,s.yg)(ysr,(0,p.A)({},msr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}dsr.isMDXComponent=!0;const hsr={toc:[]},gsr="wrapper";function fsr(e){let{components:n,...t}=e;return(0,s.yg)(gsr,(0,p.A)({},hsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}fsr.isMDXComponent=!0;const Dsr={toc:[]},Msr="wrapper";function Xsr(e){let{components:n,...t}=e;return(0,s.yg)(Msr,(0,p.A)({},Dsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Xsr.isMDXComponent=!0;const _sr={toc:[]},wsr="wrapper";function Tsr(e){let{components:n,...t}=e;return(0,s.yg)(wsr,(0,p.A)({},_sr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Tsr.isMDXComponent=!0;const Csr={toc:[]},xsr="wrapper";function Asr(e){let{components:n,...t}=e;return(0,s.yg)(xsr,(0,p.A)({},Csr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Asr.isMDXComponent=!0;const vsr={toc:[]},Lsr="wrapper";function bsr(e){let{components:n,...t}=e;return(0,s.yg)(Lsr,(0,p.A)({},vsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}bsr.isMDXComponent=!0;const Nsr={toc:[]},ksr="wrapper";function zsr(e){let{components:n,...t}=e;return(0,s.yg)(ksr,(0,p.A)({},Nsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}zsr.isMDXComponent=!0;const Psr={toc:[]},Isr="wrapper";function Rsr(e){let{components:n,...t}=e;return(0,s.yg)(Isr,(0,p.A)({},Psr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Rsr.isMDXComponent=!0;const Wsr={toc:[]},Ssr="wrapper";function Bsr(e){let{components:n,...t}=e;return(0,s.yg)(Ssr,(0,p.A)({},Wsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Bsr.isMDXComponent=!0;const Gsr={toc:[]},Esr="wrapper";function Osr(e){let{components:n,...t}=e;return(0,s.yg)(Esr,(0,p.A)({},Gsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Osr.isMDXComponent=!0;const Usr={toc:[]},Fsr="wrapper";function Vsr(e){let{components:n,...t}=e;return(0,s.yg)(Fsr,(0,p.A)({},Usr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Vsr.isMDXComponent=!0;const qsr={toc:[]},jsr="wrapper";function Hsr(e){let{components:n,...t}=e;return(0,s.yg)(jsr,(0,p.A)({},qsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Hsr.isMDXComponent=!0;const Ysr={toc:[]},Qsr="wrapper";function $sr(e){let{components:n,...t}=e;return(0,s.yg)(Qsr,(0,p.A)({},Ysr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}$sr.isMDXComponent=!0;const Ksr={toc:[]},Jsr="wrapper";function Zsr(e){let{components:n,...t}=e;return(0,s.yg)(Jsr,(0,p.A)({},Ksr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Zsr.isMDXComponent=!0;const ecr={toc:[]},ncr="wrapper";function tcr(e){let{components:n,...t}=e;return(0,s.yg)(ncr,(0,p.A)({},ecr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}tcr.isMDXComponent=!0;const ocr={toc:[]},pcr="wrapper";function rcr(e){let{components:n,...t}=e;return(0,s.yg)(pcr,(0,p.A)({},ocr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}rcr.isMDXComponent=!0;const scr={toc:[]},ccr="wrapper";function acr(e){let{components:n,...t}=e;return(0,s.yg)(ccr,(0,p.A)({},scr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}acr.isMDXComponent=!0;const icr={toc:[]},lcr="wrapper";function ucr(e){let{components:n,...t}=e;return(0,s.yg)(lcr,(0,p.A)({},icr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ucr.isMDXComponent=!0;const mcr={toc:[]},ycr="wrapper";function dcr(e){let{components:n,...t}=e;return(0,s.yg)(ycr,(0,p.A)({},mcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}dcr.isMDXComponent=!0;const hcr={toc:[]},gcr="wrapper";function fcr(e){let{components:n,...t}=e;return(0,s.yg)(gcr,(0,p.A)({},hcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}fcr.isMDXComponent=!0;const Dcr={toc:[]},Mcr="wrapper";function Xcr(e){let{components:n,...t}=e;return(0,s.yg)(Mcr,(0,p.A)({},Dcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Xcr.isMDXComponent=!0;const _cr={toc:[]},wcr="wrapper";function Tcr(e){let{components:n,...t}=e;return(0,s.yg)(wcr,(0,p.A)({},_cr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Tcr.isMDXComponent=!0;const Ccr={toc:[]},xcr="wrapper";function Acr(e){let{components:n,...t}=e;return(0,s.yg)(xcr,(0,p.A)({},Ccr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Acr.isMDXComponent=!0;const vcr={toc:[]},Lcr="wrapper";function bcr(e){let{components:n,...t}=e;return(0,s.yg)(Lcr,(0,p.A)({},vcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}bcr.isMDXComponent=!0;const Ncr={toc:[]},kcr="wrapper";function zcr(e){let{components:n,...t}=e;return(0,s.yg)(kcr,(0,p.A)({},Ncr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}zcr.isMDXComponent=!0;const Pcr={toc:[]},Icr="wrapper";function Rcr(e){let{components:n,...t}=e;return(0,s.yg)(Icr,(0,p.A)({},Pcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Rcr.isMDXComponent=!0;const Wcr={toc:[]},Scr="wrapper";function Bcr(e){let{components:n,...t}=e;return(0,s.yg)(Scr,(0,p.A)({},Wcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Bcr.isMDXComponent=!0;const Gcr={toc:[]},Ecr="wrapper";function Ocr(e){let{components:n,...t}=e;return(0,s.yg)(Ecr,(0,p.A)({},Gcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Ocr.isMDXComponent=!0;const Ucr={toc:[]},Fcr="wrapper";function Vcr(e){let{components:n,...t}=e;return(0,s.yg)(Fcr,(0,p.A)({},Ucr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Vcr.isMDXComponent=!0;const qcr={toc:[]},jcr="wrapper";function Hcr(e){let{components:n,...t}=e;return(0,s.yg)(jcr,(0,p.A)({},qcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Hcr.isMDXComponent=!0;const Ycr={toc:[]},Qcr="wrapper";function $cr(e){let{components:n,...t}=e;return(0,s.yg)(Qcr,(0,p.A)({},Ycr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}$cr.isMDXComponent=!0;const Kcr={toc:[]},Jcr="wrapper";function Zcr(e){let{components:n,...t}=e;return(0,s.yg)(Jcr,(0,p.A)({},Kcr,t,{components:n,mdxType:"MDXLayout"}))}Zcr.isMDXComponent=!0;const ear={toc:[]},nar="wrapper";function tar(e){let{components:n,...t}=e;return(0,s.yg)(nar,(0,p.A)({},ear,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}tar.isMDXComponent=!0;const oar={toc:[]},par="wrapper";function rar(e){let{components:n,...t}=e;return(0,s.yg)(par,(0,p.A)({},oar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}rar.isMDXComponent=!0;const sar={toc:[]},car="wrapper";function aar(e){let{components:n,...t}=e;return(0,s.yg)(car,(0,p.A)({},sar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}aar.isMDXComponent=!0;const iar={toc:[]},lar="wrapper";function uar(e){let{components:n,...t}=e;return(0,s.yg)(lar,(0,p.A)({},iar,t,{components:n,mdxType:"MDXLayout"}))}uar.isMDXComponent=!0;const mar={toc:[]},yar="wrapper";function dar(e){let{components:n,...t}=e;return(0,s.yg)(yar,(0,p.A)({},mar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}dar.isMDXComponent=!0;const har={toc:[]},gar="wrapper";function far(e){let{components:n,...t}=e;return(0,s.yg)(gar,(0,p.A)({},har,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}far.isMDXComponent=!0;const Dar={toc:[]},Mar="wrapper";function Xar(e){let{components:n,...t}=e;return(0,s.yg)(Mar,(0,p.A)({},Dar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Xar.isMDXComponent=!0;const _ar={toc:[]},war="wrapper";function Tar(e){let{components:n,...t}=e;return(0,s.yg)(war,(0,p.A)({},_ar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Tar.isMDXComponent=!0;const Car={toc:[]},xar="wrapper";function Aar(e){let{components:n,...t}=e;return(0,s.yg)(xar,(0,p.A)({},Car,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Aar.isMDXComponent=!0;const Lar={toc:[]},bar="wrapper";function Nar(e){let{components:n,...t}=e;return(0,s.yg)(bar,(0,p.A)({},Lar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Nar.isMDXComponent=!0;const kar={toc:[]},zar="wrapper";function Par(e){let{components:n,...t}=e;return(0,s.yg)(zar,(0,p.A)({},kar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Par.isMDXComponent=!0;const Iar={toc:[]},Rar="wrapper";function War(e){let{components:n,...t}=e;return(0,s.yg)(Rar,(0,p.A)({},Iar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}War.isMDXComponent=!0;const Sar={toc:[]},Bar="wrapper";function Gar(e){let{components:n,...t}=e;return(0,s.yg)(Bar,(0,p.A)({},Sar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Gar.isMDXComponent=!0;const Ear={toc:[]},Oar="wrapper";function Uar(e){let{components:n,...t}=e;return(0,s.yg)(Oar,(0,p.A)({},Ear,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Uar.isMDXComponent=!0;const Far={toc:[]},Var="wrapper";function qar(e){let{components:n,...t}=e;return(0,s.yg)(Var,(0,p.A)({},Far,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qar.isMDXComponent=!0;const jar={toc:[]},Har="wrapper";function Yar(e){let{components:n,...t}=e;return(0,s.yg)(Har,(0,p.A)({},jar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Yar.isMDXComponent=!0;const Qar={toc:[]},$ar="wrapper";function Kar(e){let{components:n,...t}=e;return(0,s.yg)($ar,(0,p.A)({},Qar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represent SVG document that contains SVG shapes.\nThis only used single time because ",(0,s.yg)("inlineCode",{parentName:"p"},"nodes")," have reference to parent SVG renderer."))}Kar.isMDXComponent=!0;const Jar={toc:[]},Zar="wrapper";function eir(e){let{components:n,...t}=e;return(0,s.yg)(Zar,(0,p.A)({},Jar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Data of SVGDocument.\nThis can used many times because it do not reference parent SVG.\nThis must build into SVGDocument"))}eir.isMDXComponent=!0;const nir={toc:[]},tir="wrapper";function oir(e){let{components:n,...t}=e;return(0,s.yg)(tir,(0,p.A)({},nir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}oir.isMDXComponent=!0;const pir={toc:[]},rir="wrapper";function sir(e){let{components:n,...t}=e;return(0,s.yg)(rir,(0,p.A)({},pir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}sir.isMDXComponent=!0;const cir={toc:[]},air="wrapper";function iir(e){let{components:n,...t}=e;return(0,s.yg)(air,(0,p.A)({},cir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}iir.isMDXComponent=!0;const lir={toc:[]},uir="wrapper";function mir(e){let{components:n,...t}=e;return(0,s.yg)(uir,(0,p.A)({},lir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}mir.isMDXComponent=!0;const yir={toc:[]},dir="wrapper";function hir(e){let{components:n,...t}=e;return(0,s.yg)(dir,(0,p.A)({},yir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hir.isMDXComponent=!0;const gir={toc:[]},fir="wrapper";function Dir(e){let{components:n,...t}=e;return(0,s.yg)(fir,(0,p.A)({},gir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Dir.isMDXComponent=!0;const Mir={toc:[]},Xir="wrapper";function _ir(e){let{components:n,...t}=e;return(0,s.yg)(Xir,(0,p.A)({},Mir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}_ir.isMDXComponent=!0;const wir={toc:[]},Tir="wrapper";function Cir(e){let{components:n,...t}=e;return(0,s.yg)(Tir,(0,p.A)({},wir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Cir.isMDXComponent=!0;const xir={toc:[]},Air="wrapper";function vir(e){let{components:n,...t}=e;return(0,s.yg)(Air,(0,p.A)({},xir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}vir.isMDXComponent=!0;const Lir={toc:[]},bir="wrapper";function Nir(e){let{components:n,...t}=e;return(0,s.yg)(bir,(0,p.A)({},Lir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Nir.isMDXComponent=!0;const kir={toc:[]},zir="wrapper";function Pir(e){let{components:n,...t}=e;return(0,s.yg)(zir,(0,p.A)({},kir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Pir.isMDXComponent=!0;const Iir={toc:[]},Rir="wrapper";function Wir(e){let{components:n,...t}=e;return(0,s.yg)(Rir,(0,p.A)({},Iir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Wir.isMDXComponent=!0;const Sir={toc:[]},Bir="wrapper";function Gir(e){let{components:n,...t}=e;return(0,s.yg)(Bir,(0,p.A)({},Sir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Gir.isMDXComponent=!0;const Eir={toc:[]},Oir="wrapper";function Uir(e){let{components:n,...t}=e;return(0,s.yg)(Oir,(0,p.A)({},Eir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Uir.isMDXComponent=!0;const Fir={toc:[]},Vir="wrapper";function qir(e){let{components:n,...t}=e;return(0,s.yg)(Vir,(0,p.A)({},Fir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}qir.isMDXComponent=!0;const jir={toc:[]},Hir="wrapper";function Yir(e){let{components:n,...t}=e;return(0,s.yg)(Hir,(0,p.A)({},jir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Yir.isMDXComponent=!0;const Qir={toc:[]},$ir="wrapper";function Kir(e){let{components:n,...t}=e;return(0,s.yg)($ir,(0,p.A)({},Qir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Kir.isMDXComponent=!0;const Jir={toc:[]},Zir="wrapper";function elr(e){let{components:n,...t}=e;return(0,s.yg)(Zir,(0,p.A)({},Jir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}elr.isMDXComponent=!0;const nlr={toc:[]},tlr="wrapper";function olr(e){let{components:n,...t}=e;return(0,s.yg)(tlr,(0,p.A)({},nlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}olr.isMDXComponent=!0;const plr={toc:[]},rlr="wrapper";function slr(e){let{components:n,...t}=e;return(0,s.yg)(rlr,(0,p.A)({},plr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}slr.isMDXComponent=!0;const clr={toc:[]},alr="wrapper";function ilr(e){let{components:n,...t}=e;return(0,s.yg)(alr,(0,p.A)({},clr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ilr.isMDXComponent=!0;const llr={toc:[]},ulr="wrapper";function mlr(e){let{components:n,...t}=e;return(0,s.yg)(ulr,(0,p.A)({},llr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}mlr.isMDXComponent=!0;const ylr={toc:[]},dlr="wrapper";function hlr(e){let{components:n,...t}=e;return(0,s.yg)(dlr,(0,p.A)({},ylr,t,{components:n,mdxType:"MDXLayout"}))}hlr.isMDXComponent=!0;const glr={toc:[]},flr="wrapper";function Dlr(e){let{components:n,...t}=e;return(0,s.yg)(flr,(0,p.A)({},glr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Dlr.isMDXComponent=!0;const Mlr={toc:[]},Xlr="wrapper";function _lr(e){let{components:n,...t}=e;return(0,s.yg)(Xlr,(0,p.A)({},Mlr,t,{components:n,mdxType:"MDXLayout"}))}_lr.isMDXComponent=!0;const wlr={toc:[]},Tlr="wrapper";function Clr(e){let{components:n,...t}=e;return(0,s.yg)(Tlr,(0,p.A)({},wlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Clr.isMDXComponent=!0;const xlr={toc:[]},Alr="wrapper";function vlr(e){let{components:n,...t}=e;return(0,s.yg)(Alr,(0,p.A)({},xlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}vlr.isMDXComponent=!0;const Llr={toc:[]},blr="wrapper";function Nlr(e){let{components:n,...t}=e;return(0,s.yg)(blr,(0,p.A)({},Llr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Nlr.isMDXComponent=!0;const klr={toc:[]},zlr="wrapper";function Plr(e){let{components:n,...t}=e;return(0,s.yg)(zlr,(0,p.A)({},klr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Plr.isMDXComponent=!0;const Ilr={toc:[]},Rlr="wrapper";function Wlr(e){let{components:n,...t}=e;return(0,s.yg)(Rlr,(0,p.A)({},Ilr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Wlr.isMDXComponent=!0;const Slr={toc:[]},Blr="wrapper";function Glr(e){let{components:n,...t}=e;return(0,s.yg)(Blr,(0,p.A)({},Slr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Glr.isMDXComponent=!0;const Elr={toc:[]},Olr="wrapper";function Ulr(e){let{components:n,...t}=e;return(0,s.yg)(Olr,(0,p.A)({},Elr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represent SVG shape.\nThis only used single time because ",(0,s.yg)("inlineCode",{parentName:"p"},"node")," may have reference to parent SVG renderer."))}Ulr.isMDXComponent=!0;const Flr={toc:[]},Vlr="wrapper";function qlr(e){let{components:n,...t}=e;return(0,s.yg)(Vlr,(0,p.A)({},Flr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Data of SVGShape.\nThis can used many times  because it do not reference parent SVG.\nThis must build into SVGShape"))}qlr.isMDXComponent=!0;const jlr={toc:[]},Hlr="wrapper";function Ylr(e){let{components:n,...t}=e;return(0,s.yg)(Hlr,(0,p.A)({},jlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ylr.isMDXComponent=!0;const Qlr={toc:[]},$lr="wrapper";function Klr(e){let{components:n,...t}=e;return(0,s.yg)($lr,(0,p.A)({},Qlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Klr.isMDXComponent=!0;const Jlr={toc:[]},Zlr="wrapper";function eur(e){let{components:n,...t}=e;return(0,s.yg)(Zlr,(0,p.A)({},Jlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}eur.isMDXComponent=!0;const nur={toc:[]},tur="wrapper";function our(e){let{components:n,...t}=e;return(0,s.yg)(tur,(0,p.A)({},nur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}our.isMDXComponent=!0;const pur={toc:[]},rur="wrapper";function sur(e){let{components:n,...t}=e;return(0,s.yg)(rur,(0,p.A)({},pur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}sur.isMDXComponent=!0;const cur={toc:[]},aur="wrapper";function iur(e){let{components:n,...t}=e;return(0,s.yg)(aur,(0,p.A)({},cur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}iur.isMDXComponent=!0;const lur={toc:[]},uur="wrapper";function mur(e){let{components:n,...t}=e;return(0,s.yg)(uur,(0,p.A)({},lur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}mur.isMDXComponent=!0;const yur={toc:[]},dur="wrapper";function hur(e){let{components:n,...t}=e;return(0,s.yg)(dur,(0,p.A)({},yur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}hur.isMDXComponent=!0;const gur={toc:[]},fur="wrapper";function Dur(e){let{components:n,...t}=e;return(0,s.yg)(fur,(0,p.A)({},gur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Dur.isMDXComponent=!0;const Mur={toc:[]},Xur="wrapper";function _ur(e){let{components:n,...t}=e;return(0,s.yg)(Xur,(0,p.A)({},Mur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}_ur.isMDXComponent=!0;const wur={toc:[]},Tur="wrapper";function Cur(e){let{components:n,...t}=e;return(0,s.yg)(Tur,(0,p.A)({},wur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Cur.isMDXComponent=!0;const xur={toc:[]},Aur="wrapper";function vur(e){let{components:n,...t}=e;return(0,s.yg)(Aur,(0,p.A)({},xur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}vur.isMDXComponent=!0;const Lur={toc:[]},bur="wrapper";function Nur(e){let{components:n,...t}=e;return(0,s.yg)(bur,(0,p.A)({},Lur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Nur.isMDXComponent=!0;const kur={toc:[]},zur="wrapper";function Pur(e){let{components:n,...t}=e;return(0,s.yg)(zur,(0,p.A)({},kur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Pur.isMDXComponent=!0;const Iur={toc:[]},Rur="wrapper";function Wur(e){let{components:n,...t}=e;return(0,s.yg)(Rur,(0,p.A)({},Iur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Wur.isMDXComponent=!0;const Sur={toc:[]},Bur="wrapper";function Gur(e){let{components:n,...t}=e;return(0,s.yg)(Bur,(0,p.A)({},Sur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Gur.isMDXComponent=!0;const Eur={toc:[]},Our="wrapper";function Uur(e){let{components:n,...t}=e;return(0,s.yg)(Our,(0,p.A)({},Eur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Uur.isMDXComponent=!0;const Fur={toc:[]},Vur="wrapper";function qur(e){let{components:n,...t}=e;return(0,s.yg)(Vur,(0,p.A)({},Fur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}qur.isMDXComponent=!0;const jur={toc:[]},Hur="wrapper";function Yur(e){let{components:n,...t}=e;return(0,s.yg)(Hur,(0,p.A)({},jur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Yur.isMDXComponent=!0;const Qur={toc:[]},$ur="wrapper";function Kur(e){let{components:n,...t}=e;return(0,s.yg)($ur,(0,p.A)({},Qur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Kur.isMDXComponent=!0;const Jur={toc:[]},Zur="wrapper";function emr(e){let{components:n,...t}=e;return(0,s.yg)(Zur,(0,p.A)({},Jur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}emr.isMDXComponent=!0;const nmr={toc:[]},tmr="wrapper";function omr(e){let{components:n,...t}=e;return(0,s.yg)(tmr,(0,p.A)({},nmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}omr.isMDXComponent=!0;const pmr={toc:[]},rmr="wrapper";function smr(e){let{components:n,...t}=e;return(0,s.yg)(rmr,(0,p.A)({},pmr,t,{components:n,mdxType:"MDXLayout"}))}smr.isMDXComponent=!0;const cmr={toc:[]},amr="wrapper";function imr(e){let{components:n,...t}=e;return(0,s.yg)(amr,(0,p.A)({},cmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}imr.isMDXComponent=!0;const lmr={toc:[]},umr="wrapper";function mmr(e){let{components:n,...t}=e;return(0,s.yg)(umr,(0,p.A)({},lmr,t,{components:n,mdxType:"MDXLayout"}))}mmr.isMDXComponent=!0;const ymr={toc:[]},dmr="wrapper";function hmr(e){let{components:n,...t}=e;return(0,s.yg)(dmr,(0,p.A)({},ymr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hmr.isMDXComponent=!0;const gmr={toc:[]},fmr="wrapper";function Dmr(e){let{components:n,...t}=e;return(0,s.yg)(fmr,(0,p.A)({},gmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Dmr.isMDXComponent=!0;const Mmr={toc:[]},Xmr="wrapper";function _mr(e){let{components:n,...t}=e;return(0,s.yg)(Xmr,(0,p.A)({},Mmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_mr.isMDXComponent=!0;const wmr={toc:[]},Tmr="wrapper";function Cmr(e){let{components:n,...t}=e;return(0,s.yg)(Tmr,(0,p.A)({},wmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Cmr.isMDXComponent=!0;const xmr={toc:[]},Amr="wrapper";function vmr(e){let{components:n,...t}=e;return(0,s.yg)(Amr,(0,p.A)({},xmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}vmr.isMDXComponent=!0;const Lmr={toc:[]},bmr="wrapper";function Nmr(e){let{components:n,...t}=e;return(0,s.yg)(bmr,(0,p.A)({},Lmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Nmr.isMDXComponent=!0;const kmr={toc:[]},zmr="wrapper";function Pmr(e){let{components:n,...t}=e;return(0,s.yg)(zmr,(0,p.A)({},kmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Pmr.isMDXComponent=!0;const Imr={toc:[]},Rmr="wrapper";function Wmr(e){let{components:n,...t}=e;return(0,s.yg)(Rmr,(0,p.A)({},Imr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Wmr.isMDXComponent=!0;const Smr={toc:[]},Bmr="wrapper";function Gmr(e){let{components:n,...t}=e;return(0,s.yg)(Bmr,(0,p.A)({},Smr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Gmr.isMDXComponent=!0;const Emr={toc:[]},Omr="wrapper";function Umr(e){let{components:n,...t}=e;return(0,s.yg)(Omr,(0,p.A)({},Emr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Umr.isMDXComponent=!0;const Fmr={toc:[]},Vmr="wrapper";function qmr(e){let{components:n,...t}=e;return(0,s.yg)(Vmr,(0,p.A)({},Fmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qmr.isMDXComponent=!0;const jmr={toc:[]},Hmr="wrapper";function Ymr(e){let{components:n,...t}=e;return(0,s.yg)(Hmr,(0,p.A)({},jmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Ymr.isMDXComponent=!0;const Qmr={toc:[]},$mr="wrapper";function Kmr(e){let{components:n,...t}=e;return(0,s.yg)($mr,(0,p.A)({},Qmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Kmr.isMDXComponent=!0;const Jmr={toc:[]},Zmr="wrapper";function eyr(e){let{components:n,...t}=e;return(0,s.yg)(Zmr,(0,p.A)({},Jmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}eyr.isMDXComponent=!0;const nyr={toc:[]},tyr="wrapper";function oyr(e){let{components:n,...t}=e;return(0,s.yg)(tyr,(0,p.A)({},nyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}oyr.isMDXComponent=!0;const pyr={toc:[]},ryr="wrapper";function syr(e){let{components:n,...t}=e;return(0,s.yg)(ryr,(0,p.A)({},pyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}syr.isMDXComponent=!0;const cyr={toc:[]},ayr="wrapper";function iyr(e){let{components:n,...t}=e;return(0,s.yg)(ayr,(0,p.A)({},cyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}iyr.isMDXComponent=!0;const lyr={toc:[]},uyr="wrapper";function myr(e){let{components:n,...t}=e;return(0,s.yg)(uyr,(0,p.A)({},lyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}myr.isMDXComponent=!0;const yyr={toc:[]},dyr="wrapper";function hyr(e){let{components:n,...t}=e;return(0,s.yg)(dyr,(0,p.A)({},yyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}hyr.isMDXComponent=!0;const gyr={toc:[]},fyr="wrapper";function Dyr(e){let{components:n,...t}=e;return(0,s.yg)(fyr,(0,p.A)({},gyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Dyr.isMDXComponent=!0;const Myr={toc:[]},Xyr="wrapper";function _yr(e){let{components:n,...t}=e;return(0,s.yg)(Xyr,(0,p.A)({},Myr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}_yr.isMDXComponent=!0;const wyr={toc:[]},Tyr="wrapper";function Cyr(e){let{components:n,...t}=e;return(0,s.yg)(Tyr,(0,p.A)({},wyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Cyr.isMDXComponent=!0;const xyr={toc:[]},Ayr="wrapper";function vyr(e){let{components:n,...t}=e;return(0,s.yg)(Ayr,(0,p.A)({},xyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}vyr.isMDXComponent=!0;const Lyr={toc:[]},byr="wrapper";function Nyr(e){let{components:n,...t}=e;return(0,s.yg)(byr,(0,p.A)({},Lyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Nyr.isMDXComponent=!0;const kyr={toc:[]},zyr="wrapper";function Pyr(e){let{components:n,...t}=e;return(0,s.yg)(zyr,(0,p.A)({},kyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Pyr.isMDXComponent=!0;const Iyr={toc:[]},Ryr="wrapper";function Wyr(e){let{components:n,...t}=e;return(0,s.yg)(Ryr,(0,p.A)({},Iyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Wyr.isMDXComponent=!0;const Syr={toc:[]},Byr="wrapper";function Gyr(e){let{components:n,...t}=e;return(0,s.yg)(Byr,(0,p.A)({},Syr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Gyr.isMDXComponent=!0;const Eyr={toc:[]},Oyr="wrapper";function Uyr(e){let{components:n,...t}=e;return(0,s.yg)(Oyr,(0,p.A)({},Eyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Uyr.isMDXComponent=!0;const Fyr={toc:[]},Vyr="wrapper";function qyr(e){let{components:n,...t}=e;return(0,s.yg)(Vyr,(0,p.A)({},Fyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qyr.isMDXComponent=!0;const jyr={toc:[]},Hyr="wrapper";function Yyr(e){let{components:n,...t}=e;return(0,s.yg)(Hyr,(0,p.A)({},jyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Yyr.isMDXComponent=!0;const Qyr={toc:[]},$yr="wrapper";function Kyr(e){let{components:n,...t}=e;return(0,s.yg)($yr,(0,p.A)({},Qyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Kyr.isMDXComponent=!0;const Jyr={toc:[]},Zyr="wrapper";function edr(e){let{components:n,...t}=e;return(0,s.yg)(Zyr,(0,p.A)({},Jyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}edr.isMDXComponent=!0;const ndr={toc:[]},tdr="wrapper";function odr(e){let{components:n,...t}=e;return(0,s.yg)(tdr,(0,p.A)({},ndr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}odr.isMDXComponent=!0;const pdr={toc:[]},rdr="wrapper";function sdr(e){let{components:n,...t}=e;return(0,s.yg)(rdr,(0,p.A)({},pdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}sdr.isMDXComponent=!0;const cdr={toc:[]},adr="wrapper";function idr(e){let{components:n,...t}=e;return(0,s.yg)(adr,(0,p.A)({},cdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}idr.isMDXComponent=!0;const ldr={toc:[]},udr="wrapper";function mdr(e){let{components:n,...t}=e;return(0,s.yg)(udr,(0,p.A)({},ldr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}mdr.isMDXComponent=!0;const ydr={toc:[]},ddr="wrapper";function hdr(e){let{components:n,...t}=e;return(0,s.yg)(ddr,(0,p.A)({},ydr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."))}hdr.isMDXComponent=!0;const gdr={toc:[]},fdr="wrapper";function Ddr(e){let{components:n,...t}=e;return(0,s.yg)(fdr,(0,p.A)({},gdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}Ddr.isMDXComponent=!0;const Mdr={toc:[]},Xdr="wrapper";function _dr(e){let{components:n,...t}=e;return(0,s.yg)(Xdr,(0,p.A)({},Mdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_dr.isMDXComponent=!0;const wdr={toc:[]},Tdr="wrapper";function Cdr(e){let{components:n,...t}=e;return(0,s.yg)(Tdr,(0,p.A)({},wdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Cdr.isMDXComponent=!0;const xdr={toc:[]},Adr="wrapper";function vdr(e){let{components:n,...t}=e;return(0,s.yg)(Adr,(0,p.A)({},xdr,t,{components:n,mdxType:"MDXLayout"}))}vdr.isMDXComponent=!0;const Ldr={toc:[]},bdr="wrapper";function Ndr(e){let{components:n,...t}=e;return(0,s.yg)(bdr,(0,p.A)({},Ldr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property is only applied to knots that don't use explicit handles."))}Ndr.isMDXComponent=!0;const kdr={toc:[]},zdr="wrapper";function Pdr(e){let{components:n,...t}=e;return(0,s.yg)(zdr,(0,p.A)({},kdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The smoothness of the spline when using auto-calculated handles."))}Pdr.isMDXComponent=!0;const Idr={toc:[]},Rdr="wrapper";function Wdr(e){let{components:n,...t}=e;return(0,s.yg)(Rdr,(0,p.A)({},Idr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Wdr.isMDXComponent=!0;const Sdr={toc:[]},Bdr="wrapper";function Gdr(e){let{components:n,...t}=e;return(0,s.yg)(Bdr,(0,p.A)({},Sdr,t,{components:n,mdxType:"MDXLayout"}))}Gdr.isMDXComponent=!0;const Edr={toc:[]},Odr="wrapper";function Udr(e){let{components:n,...t}=e;return(0,s.yg)(Odr,(0,p.A)({},Edr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Udr.isMDXComponent=!0;const Fdr={toc:[]},Vdr="wrapper";function qdr(e){let{components:n,...t}=e;return(0,s.yg)(Vdr,(0,p.A)({},Fdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}qdr.isMDXComponent=!0;const jdr={toc:[]},Hdr="wrapper";function Ydr(e){let{components:n,...t}=e;return(0,s.yg)(Hdr,(0,p.A)({},jdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ydr.isMDXComponent=!0;const Qdr={toc:[]},$dr="wrapper";function Kdr(e){let{components:n,...t}=e;return(0,s.yg)($dr,(0,p.A)({},Qdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Kdr.isMDXComponent=!0;const Jdr={toc:[]},Zdr="wrapper";function ehr(e){let{components:n,...t}=e;return(0,s.yg)(Zdr,(0,p.A)({},Jdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ehr.isMDXComponent=!0;const nhr={toc:[]},thr="wrapper";function ohr(e){let{components:n,...t}=e;return(0,s.yg)(thr,(0,p.A)({},nhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}ohr.isMDXComponent=!0;const phr={toc:[]},rhr="wrapper";function shr(e){let{components:n,...t}=e;return(0,s.yg)(rhr,(0,p.A)({},phr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}shr.isMDXComponent=!0;const chr={toc:[]},ahr="wrapper";function ihr(e){let{components:n,...t}=e;return(0,s.yg)(ahr,(0,p.A)({},chr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}ihr.isMDXComponent=!0;const lhr={toc:[]},uhr="wrapper";function mhr(e){let{components:n,...t}=e;return(0,s.yg)(uhr,(0,p.A)({},lhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}mhr.isMDXComponent=!0;const yhr={toc:[]},dhr="wrapper";function hhr(e){let{components:n,...t}=e;return(0,s.yg)(dhr,(0,p.A)({},yhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}hhr.isMDXComponent=!0;const ghr={toc:[]},fhr="wrapper";function Dhr(e){let{components:n,...t}=e;return(0,s.yg)(fhr,(0,p.A)({},ghr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dhr.isMDXComponent=!0;const Mhr={toc:[]},Xhr="wrapper";function _hr(e){let{components:n,...t}=e;return(0,s.yg)(Xhr,(0,p.A)({},Mhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}_hr.isMDXComponent=!0;const whr={toc:[]},Thr="wrapper";function Chr(e){let{components:n,...t}=e;return(0,s.yg)(Thr,(0,p.A)({},whr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Chr.isMDXComponent=!0;const xhr={toc:[]},Ahr="wrapper";function vhr(e){let{components:n,...t}=e;return(0,s.yg)(Ahr,(0,p.A)({},xhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}vhr.isMDXComponent=!0;const Lhr={toc:[]},bhr="wrapper";function Nhr(e){let{components:n,...t}=e;return(0,s.yg)(bhr,(0,p.A)({},Lhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Nhr.isMDXComponent=!0;const khr={toc:[]},zhr="wrapper";function Phr(e){let{components:n,...t}=e;return(0,s.yg)(zhr,(0,p.A)({},khr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Phr.isMDXComponent=!0;const Ihr={toc:[]},Rhr="wrapper";function Whr(e){let{components:n,...t}=e;return(0,s.yg)(Rhr,(0,p.A)({},Ihr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Whr.isMDXComponent=!0;const Shr={toc:[]},Bhr="wrapper";function Ghr(e){let{components:n,...t}=e;return(0,s.yg)(Bhr,(0,p.A)({},Shr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Ghr.isMDXComponent=!0;const Ehr={toc:[]},Ohr="wrapper";function Uhr(e){let{components:n,...t}=e;return(0,s.yg)(Ohr,(0,p.A)({},Ehr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Uhr.isMDXComponent=!0;const Fhr={toc:[]},Vhr="wrapper";function qhr(e){let{components:n,...t}=e;return(0,s.yg)(Vhr,(0,p.A)({},Fhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}qhr.isMDXComponent=!0;const jhr={toc:[]},Hhr="wrapper";function Yhr(e){let{components:n,...t}=e;return(0,s.yg)(Hhr,(0,p.A)({},jhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Yhr.isMDXComponent=!0;const Qhr={toc:[]},$hr="wrapper";function Khr(e){let{components:n,...t}=e;return(0,s.yg)($hr,(0,p.A)({},Qhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Khr.isMDXComponent=!0;const Jhr={toc:[]},Zhr="wrapper";function egr(e){let{components:n,...t}=e;return(0,s.yg)(Zhr,(0,p.A)({},Jhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}egr.isMDXComponent=!0;const ngr={toc:[]},tgr="wrapper";function ogr(e){let{components:n,...t}=e;return(0,s.yg)(tgr,(0,p.A)({},ngr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ogr.isMDXComponent=!0;const pgr={toc:[]},rgr="wrapper";function sgr(e){let{components:n,...t}=e;return(0,s.yg)(rgr,(0,p.A)({},pgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}sgr.isMDXComponent=!0;const cgr={toc:[]},agr="wrapper";function igr(e){let{components:n,...t}=e;return(0,s.yg)(agr,(0,p.A)({},cgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}igr.isMDXComponent=!0;const lgr={toc:[]},ugr="wrapper";function mgr(e){let{components:n,...t}=e;return(0,s.yg)(ugr,(0,p.A)({},lgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}mgr.isMDXComponent=!0;const ygr={toc:[]},dgr="wrapper";function hgr(e){let{components:n,...t}=e;return(0,s.yg)(dgr,(0,p.A)({},ygr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}hgr.isMDXComponent=!0;const ggr={toc:[]},fgr="wrapper";function Dgr(e){let{components:n,...t}=e;return(0,s.yg)(fgr,(0,p.A)({},ggr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dgr.isMDXComponent=!0;const Mgr={toc:[]},Xgr="wrapper";function _gr(e){let{components:n,...t}=e;return(0,s.yg)(Xgr,(0,p.A)({},Mgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}_gr.isMDXComponent=!0;const wgr={toc:[]},Tgr="wrapper";function Cgr(e){let{components:n,...t}=e;return(0,s.yg)(Tgr,(0,p.A)({},wgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Cgr.isMDXComponent=!0;const xgr={toc:[]},Agr="wrapper";function vgr(e){let{components:n,...t}=e;return(0,s.yg)(Agr,(0,p.A)({},xgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}vgr.isMDXComponent=!0;const Lgr={toc:[]},bgr="wrapper";function Ngr(e){let{components:n,...t}=e;return(0,s.yg)(bgr,(0,p.A)({},Lgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ngr.isMDXComponent=!0;const kgr={toc:[]},zgr="wrapper";function Pgr(e){let{components:n,...t}=e;return(0,s.yg)(zgr,(0,p.A)({},kgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Pgr.isMDXComponent=!0;const Igr={toc:[]},Rgr="wrapper";function Wgr(e){let{components:n,...t}=e;return(0,s.yg)(Rgr,(0,p.A)({},Igr,t,{components:n,mdxType:"MDXLayout"}))}Wgr.isMDXComponent=!0;const Sgr={toc:[]},Bgr="wrapper";function Ggr(e){let{components:n,...t}=e;return(0,s.yg)(Bgr,(0,p.A)({},Sgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Ggr.isMDXComponent=!0;const Egr={toc:[]},Ogr="wrapper";function Ugr(e){let{components:n,...t}=e;return(0,s.yg)(Ogr,(0,p.A)({},Egr,t,{components:n,mdxType:"MDXLayout"}))}Ugr.isMDXComponent=!0;const Fgr={toc:[]},Vgr="wrapper";function qgr(e){let{components:n,...t}=e;return(0,s.yg)(Vgr,(0,p.A)({},Fgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qgr.isMDXComponent=!0;const jgr={toc:[]},Hgr="wrapper";function Ygr(e){let{components:n,...t}=e;return(0,s.yg)(Hgr,(0,p.A)({},jgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Ygr.isMDXComponent=!0;const Qgr={toc:[]},$gr="wrapper";function Kgr(e){let{components:n,...t}=e;return(0,s.yg)($gr,(0,p.A)({},Qgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Kgr.isMDXComponent=!0;const Jgr={toc:[]},Zgr="wrapper";function efr(e){let{components:n,...t}=e;return(0,s.yg)(Zgr,(0,p.A)({},Jgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}efr.isMDXComponent=!0;const nfr={toc:[]},tfr="wrapper";function ofr(e){let{components:n,...t}=e;return(0,s.yg)(tfr,(0,p.A)({},nfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ofr.isMDXComponent=!0;const pfr={toc:[]},rfr="wrapper";function sfr(e){let{components:n,...t}=e;return(0,s.yg)(rfr,(0,p.A)({},pfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}sfr.isMDXComponent=!0;const cfr={toc:[]},afr="wrapper";function ifr(e){let{components:n,...t}=e;return(0,s.yg)(afr,(0,p.A)({},cfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}ifr.isMDXComponent=!0;const lfr={toc:[]},ufr="wrapper";function mfr(e){let{components:n,...t}=e;return(0,s.yg)(ufr,(0,p.A)({},lfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this video."))}mfr.isMDXComponent=!0;const yfr={toc:[]},dfr="wrapper";function hfr(e){let{components:n,...t}=e;return(0,s.yg)(dfr,(0,p.A)({},yfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}hfr.isMDXComponent=!0;const gfr={toc:[]},ffr="wrapper";function Dfr(e){let{components:n,...t}=e;return(0,s.yg)(ffr,(0,p.A)({},gfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Dfr.isMDXComponent=!0;const Mfr={toc:[]},Xfr="wrapper";function _fr(e){let{components:n,...t}=e;return(0,s.yg)(Xfr,(0,p.A)({},Mfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_fr.isMDXComponent=!0;const wfr={toc:[]},Tfr="wrapper";function Cfr(e){let{components:n,...t}=e;return(0,s.yg)(Tfr,(0,p.A)({},wfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Cfr.isMDXComponent=!0;const xfr={toc:[]},Afr="wrapper";function vfr(e){let{components:n,...t}=e;return(0,s.yg)(Afr,(0,p.A)({},xfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}vfr.isMDXComponent=!0;const Lfr={toc:[]},bfr="wrapper";function Nfr(e){let{components:n,...t}=e;return(0,s.yg)(bfr,(0,p.A)({},Lfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Nfr.isMDXComponent=!0;const kfr={toc:[]},zfr="wrapper";function Pfr(e){let{components:n,...t}=e;return(0,s.yg)(zfr,(0,p.A)({},kfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Pfr.isMDXComponent=!0;const Ifr={toc:[]},Rfr="wrapper";function Wfr(e){let{components:n,...t}=e;return(0,s.yg)(Rfr,(0,p.A)({},Ifr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Wfr.isMDXComponent=!0;const Sfr={toc:[]},Bfr="wrapper";function Gfr(e){let{components:n,...t}=e;return(0,s.yg)(Bfr,(0,p.A)({},Sfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Gfr.isMDXComponent=!0;const Efr={toc:[]},Ofr="wrapper";function Ufr(e){let{components:n,...t}=e;return(0,s.yg)(Ofr,(0,p.A)({},Efr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ufr.isMDXComponent=!0;const Ffr={toc:[]},Vfr="wrapper";function qfr(e){let{components:n,...t}=e;return(0,s.yg)(Vfr,(0,p.A)({},Ffr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}qfr.isMDXComponent=!0;const jfr={toc:[]},Hfr="wrapper";function Yfr(e){let{components:n,...t}=e;return(0,s.yg)(Hfr,(0,p.A)({},jfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Yfr.isMDXComponent=!0;const Qfr={toc:[]},$fr="wrapper";function Kfr(e){let{components:n,...t}=e;return(0,s.yg)($fr,(0,p.A)({},Qfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Kfr.isMDXComponent=!0;const Jfr={toc:[]},Zfr="wrapper";function eDr(e){let{components:n,...t}=e;return(0,s.yg)(Zfr,(0,p.A)({},Jfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}eDr.isMDXComponent=!0;const nDr={toc:[]},tDr="wrapper";function oDr(e){let{components:n,...t}=e;return(0,s.yg)(tDr,(0,p.A)({},nDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}oDr.isMDXComponent=!0;const pDr={toc:[]},rDr="wrapper";function sDr(e){let{components:n,...t}=e;return(0,s.yg)(rDr,(0,p.A)({},pDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}sDr.isMDXComponent=!0;const cDr={toc:[]},aDr="wrapper";function iDr(e){let{components:n,...t}=e;return(0,s.yg)(aDr,(0,p.A)({},cDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}iDr.isMDXComponent=!0;const lDr={toc:[]},uDr="wrapper";function mDr(e){let{components:n,...t}=e;return(0,s.yg)(uDr,(0,p.A)({},lDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}mDr.isMDXComponent=!0;const yDr={toc:[]},dDr="wrapper";function hDr(e){let{components:n,...t}=e;return(0,s.yg)(dDr,(0,p.A)({},yDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}hDr.isMDXComponent=!0;const gDr={toc:[]},fDr="wrapper";function DDr(e){let{components:n,...t}=e;return(0,s.yg)(fDr,(0,p.A)({},gDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}DDr.isMDXComponent=!0;const MDr={toc:[]},XDr="wrapper";function _Dr(e){let{components:n,...t}=e;return(0,s.yg)(XDr,(0,p.A)({},MDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}_Dr.isMDXComponent=!0;const wDr={toc:[]},TDr="wrapper";function CDr(e){let{components:n,...t}=e;return(0,s.yg)(TDr,(0,p.A)({},wDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}CDr.isMDXComponent=!0;const xDr={toc:[]},ADr="wrapper";function vDr(e){let{components:n,...t}=e;return(0,s.yg)(ADr,(0,p.A)({},xDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}vDr.isMDXComponent=!0;const LDr={toc:[]},bDr="wrapper";function NDr(e){let{components:n,...t}=e;return(0,s.yg)(bDr,(0,p.A)({},LDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}NDr.isMDXComponent=!0;const kDr={toc:[]},zDr="wrapper";function PDr(e){let{components:n,...t}=e;return(0,s.yg)(zDr,(0,p.A)({},kDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}PDr.isMDXComponent=!0;const IDr={toc:[]},RDr="wrapper";function WDr(e){let{components:n,...t}=e;return(0,s.yg)(RDr,(0,p.A)({},IDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}WDr.isMDXComponent=!0;const SDr={toc:[]},BDr="wrapper";function GDr(e){let{components:n,...t}=e;return(0,s.yg)(BDr,(0,p.A)({},SDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}GDr.isMDXComponent=!0;const EDr={toc:[]},ODr="wrapper";function UDr(e){let{components:n,...t}=e;return(0,s.yg)(ODr,(0,p.A)({},EDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}UDr.isMDXComponent=!0;const FDr={toc:[]},VDr="wrapper";function qDr(e){let{components:n,...t}=e;return(0,s.yg)(VDr,(0,p.A)({},FDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qDr.isMDXComponent=!0;const jDr={toc:[]},HDr="wrapper";function YDr(e){let{components:n,...t}=e;return(0,s.yg)(HDr,(0,p.A)({},jDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}YDr.isMDXComponent=!0;const QDr={toc:[]},$Dr="wrapper";function KDr(e){let{components:n,...t}=e;return(0,s.yg)($Dr,(0,p.A)({},QDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}KDr.isMDXComponent=!0;const JDr={toc:[]},ZDr="wrapper";function eMr(e){let{components:n,...t}=e;return(0,s.yg)(ZDr,(0,p.A)({},JDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}eMr.isMDXComponent=!0;const nMr={toc:[]},tMr="wrapper";function oMr(e){let{components:n,...t}=e;return(0,s.yg)(tMr,(0,p.A)({},nMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"PNGs have better image quality and support transparency, but they make\nrendering slower."))}oMr.isMDXComponent=!0;const pMr={toc:[]},rMr="wrapper";function sMr(e){let{components:n,...t}=e;return(0,s.yg)(rMr,(0,p.A)({},pMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video frames should be extracted as PNGs. Uses JPEGs when\nset to false."))}sMr.isMDXComponent=!0;const cMr={toc:[]},aMr="wrapper";function iMr(e){let{components:n,...t}=e;return(0,s.yg)(aMr,(0,p.A)({},cMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}iMr.isMDXComponent=!0;const lMr={toc:[]},uMr="wrapper";function mMr(e){let{components:n,...t}=e;return(0,s.yg)(uMr,(0,p.A)({},lMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}mMr.isMDXComponent=!0;const yMr={toc:[]},dMr="wrapper";function hMr(e){let{components:n,...t}=e;return(0,s.yg)(dMr,(0,p.A)({},yMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hMr.isMDXComponent=!0;const gMr={toc:[]},fMr="wrapper";function DMr(e){let{components:n,...t}=e;return(0,s.yg)(fMr,(0,p.A)({},gMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}DMr.isMDXComponent=!0;const MMr={toc:[]},XMr="wrapper";function _Mr(e){let{components:n,...t}=e;return(0,s.yg)(XMr,(0,p.A)({},MMr,t,{components:n,mdxType:"MDXLayout"}))}_Mr.isMDXComponent=!0;const wMr={toc:[]},TMr="wrapper";function CMr(e){let{components:n,...t}=e;return(0,s.yg)(TMr,(0,p.A)({},wMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}CMr.isMDXComponent=!0;const xMr={toc:[]},AMr="wrapper";function vMr(e){let{components:n,...t}=e;return(0,s.yg)(AMr,(0,p.A)({},xMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}vMr.isMDXComponent=!0;const LMr={toc:[]},bMr="wrapper";function NMr(e){let{components:n,...t}=e;return(0,s.yg)(bMr,(0,p.A)({},LMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}NMr.isMDXComponent=!0;const kMr={toc:[]},zMr="wrapper";function PMr(e){let{components:n,...t}=e;return(0,s.yg)(zMr,(0,p.A)({},kMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video should be smoothed."))}PMr.isMDXComponent=!0;const IMr={toc:[]},RMr="wrapper";function WMr(e){let{components:n,...t}=e;return(0,s.yg)(RMr,(0,p.A)({},IMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}WMr.isMDXComponent=!0;const SMr={toc:[]},BMr="wrapper";function GMr(e){let{components:n,...t}=e;return(0,s.yg)(BMr,(0,p.A)({},SMr,t,{components:n,mdxType:"MDXLayout"}))}GMr.isMDXComponent=!0;const EMr={toc:[]},OMr="wrapper";function UMr(e){let{components:n,...t}=e;return(0,s.yg)(OMr,(0,p.A)({},EMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}UMr.isMDXComponent=!0;const FMr={toc:[]},VMr="wrapper";function qMr(e){let{components:n,...t}=e;return(0,s.yg)(VMr,(0,p.A)({},FMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}qMr.isMDXComponent=!0;const jMr={toc:[]},HMr="wrapper";function YMr(e){let{components:n,...t}=e;return(0,s.yg)(HMr,(0,p.A)({},jMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}YMr.isMDXComponent=!0;const QMr={toc:[]},$Mr="wrapper";function KMr(e){let{components:n,...t}=e;return(0,s.yg)($Mr,(0,p.A)({},QMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}KMr.isMDXComponent=!0;const JMr={toc:[]},ZMr="wrapper";function eXr(e){let{components:n,...t}=e;return(0,s.yg)(ZMr,(0,p.A)({},JMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}eXr.isMDXComponent=!0;const nXr={toc:[]},tXr="wrapper";function oXr(e){let{components:n,...t}=e;return(0,s.yg)(tXr,(0,p.A)({},nXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}oXr.isMDXComponent=!0;const pXr={toc:[]},rXr="wrapper";function sXr(e){let{components:n,...t}=e;return(0,s.yg)(rXr,(0,p.A)({},pXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}sXr.isMDXComponent=!0;const cXr={toc:[]},aXr="wrapper";function iXr(e){let{components:n,...t}=e;return(0,s.yg)(aXr,(0,p.A)({},cXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}iXr.isMDXComponent=!0;const lXr={toc:[]},uXr="wrapper";function mXr(e){let{components:n,...t}=e;return(0,s.yg)(uXr,(0,p.A)({},lXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}mXr.isMDXComponent=!0;const yXr={toc:[]},dXr="wrapper";function hXr(e){let{components:n,...t}=e;return(0,s.yg)(dXr,(0,p.A)({},yXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}hXr.isMDXComponent=!0;const gXr={toc:[]},fXr="wrapper";function DXr(e){let{components:n,...t}=e;return(0,s.yg)(fXr,(0,p.A)({},gXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}DXr.isMDXComponent=!0;const MXr={toc:[]},XXr="wrapper";function _Xr(e){let{components:n,...t}=e;return(0,s.yg)(XXr,(0,p.A)({},MXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}_Xr.isMDXComponent=!0;const wXr={toc:[]},TXr="wrapper";function CXr(e){let{components:n,...t}=e;return(0,s.yg)(TXr,(0,p.A)({},wXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}CXr.isMDXComponent=!0;const xXr={toc:[]},AXr="wrapper";function vXr(e){let{components:n,...t}=e;return(0,s.yg)(AXr,(0,p.A)({},xXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}vXr.isMDXComponent=!0;const LXr={toc:[]},bXr="wrapper";function NXr(e){let{components:n,...t}=e;return(0,s.yg)(bXr,(0,p.A)({},LXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}NXr.isMDXComponent=!0;const kXr={toc:[]},zXr="wrapper";function PXr(e){let{components:n,...t}=e;return(0,s.yg)(zXr,(0,p.A)({},kXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}PXr.isMDXComponent=!0;const IXr={toc:[]},RXr="wrapper";function WXr(e){let{components:n,...t}=e;return(0,s.yg)(RXr,(0,p.A)({},IXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}WXr.isMDXComponent=!0;const SXr={toc:[]},BXr="wrapper";function GXr(e){let{components:n,...t}=e;return(0,s.yg)(BXr,(0,p.A)({},SXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}GXr.isMDXComponent=!0;const EXr={toc:[]},OXr="wrapper";function UXr(e){let{components:n,...t}=e;return(0,s.yg)(OXr,(0,p.A)({},EXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}UXr.isMDXComponent=!0;const FXr={toc:[]},VXr="wrapper";function qXr(e){let{components:n,...t}=e;return(0,s.yg)(VXr,(0,p.A)({},FXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}qXr.isMDXComponent=!0;const jXr={toc:[]},HXr="wrapper";function YXr(e){let{components:n,...t}=e;return(0,s.yg)(HXr,(0,p.A)({},jXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}YXr.isMDXComponent=!0;const QXr={toc:[]},$Xr="wrapper";function KXr(e){let{components:n,...t}=e;return(0,s.yg)($Xr,(0,p.A)({},QXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}KXr.isMDXComponent=!0;const JXr={toc:[]},ZXr="wrapper";function e_r(e){let{components:n,...t}=e;return(0,s.yg)(ZXr,(0,p.A)({},JXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}e_r.isMDXComponent=!0;const n_r={toc:[]},t_r="wrapper";function o_r(e){let{components:n,...t}=e;return(0,s.yg)(t_r,(0,p.A)({},n_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}o_r.isMDXComponent=!0;const p_r={toc:[]},r_r="wrapper";function s_r(e){let{components:n,...t}=e;return(0,s.yg)(r_r,(0,p.A)({},p_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}s_r.isMDXComponent=!0;const c_r={toc:[]},a_r="wrapper";function i_r(e){let{components:n,...t}=e;return(0,s.yg)(a_r,(0,p.A)({},c_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}i_r.isMDXComponent=!0;const l_r={toc:[]},u_r="wrapper";function m_r(e){let{components:n,...t}=e;return(0,s.yg)(u_r,(0,p.A)({},l_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}m_r.isMDXComponent=!0;const y_r={toc:[]},d_r="wrapper";function h_r(e){let{components:n,...t}=e;return(0,s.yg)(d_r,(0,p.A)({},y_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}h_r.isMDXComponent=!0;const g_r={toc:[]},f_r="wrapper";function D_r(e){let{components:n,...t}=e;return(0,s.yg)(f_r,(0,p.A)({},g_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}D_r.isMDXComponent=!0;const M_r={toc:[]},X_r="wrapper";function __r(e){let{components:n,...t}=e;return(0,s.yg)(X_r,(0,p.A)({},M_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}__r.isMDXComponent=!0;const w_r={toc:[]},T_r="wrapper";function C_r(e){let{components:n,...t}=e;return(0,s.yg)(T_r,(0,p.A)({},w_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}C_r.isMDXComponent=!0;const x_r={toc:[]},A_r="wrapper";function v_r(e){let{components:n,...t}=e;return(0,s.yg)(A_r,(0,p.A)({},x_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}v_r.isMDXComponent=!0;const L_r={toc:[]},b_r="wrapper";function N_r(e){let{components:n,...t}=e;return(0,s.yg)(b_r,(0,p.A)({},L_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}N_r.isMDXComponent=!0;const k_r={toc:[]},z_r="wrapper";function P_r(e){let{components:n,...t}=e;return(0,s.yg)(z_r,(0,p.A)({},k_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}P_r.isMDXComponent=!0;const I_r={toc:[]},R_r="wrapper";function W_r(e){let{components:n,...t}=e;return(0,s.yg)(R_r,(0,p.A)({},I_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}W_r.isMDXComponent=!0;const S_r={toc:[]},B_r="wrapper";function G_r(e){let{components:n,...t}=e;return(0,s.yg)(B_r,(0,p.A)({},S_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}G_r.isMDXComponent=!0;const E_r={toc:[]},O_r="wrapper";function U_r(e){let{components:n,...t}=e;return(0,s.yg)(O_r,(0,p.A)({},E_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}U_r.isMDXComponent=!0;const F_r={toc:[]},V_r="wrapper";function q_r(e){let{components:n,...t}=e;return(0,s.yg)(V_r,(0,p.A)({},F_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}q_r.isMDXComponent=!0;const j_r={toc:[]},H_r="wrapper";function Y_r(e){let{components:n,...t}=e;return(0,s.yg)(H_r,(0,p.A)({},j_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Y_r.isMDXComponent=!0;const Q_r={toc:[]},$_r="wrapper";function K_r(e){let{components:n,...t}=e;return(0,s.yg)($_r,(0,p.A)({},Q_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}K_r.isMDXComponent=!0;const J_r={toc:[]},Z_r="wrapper";function ewr(e){let{components:n,...t}=e;return(0,s.yg)(Z_r,(0,p.A)({},J_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ewr.isMDXComponent=!0;const nwr={toc:[]},twr="wrapper";function owr(e){let{components:n,...t}=e;return(0,s.yg)(twr,(0,p.A)({},nwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}owr.isMDXComponent=!0;const pwr={toc:[]},rwr="wrapper";function swr(e){let{components:n,...t}=e;return(0,s.yg)(rwr,(0,p.A)({},pwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}swr.isMDXComponent=!0;const cwr={toc:[]},awr="wrapper";function iwr(e){let{components:n,...t}=e;return(0,s.yg)(awr,(0,p.A)({},cwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}iwr.isMDXComponent=!0;const lwr={toc:[]},uwr="wrapper";function mwr(e){let{components:n,...t}=e;return(0,s.yg)(uwr,(0,p.A)({},lwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}mwr.isMDXComponent=!0;const ywr={toc:[]},dwr="wrapper";function hwr(e){let{components:n,...t}=e;return(0,s.yg)(dwr,(0,p.A)({},ywr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}hwr.isMDXComponent=!0;const gwr={toc:[]},fwr="wrapper";function Dwr(e){let{components:n,...t}=e;return(0,s.yg)(fwr,(0,p.A)({},gwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dwr.isMDXComponent=!0;const Mwr={toc:[]},Xwr="wrapper";function _wr(e){let{components:n,...t}=e;return(0,s.yg)(Xwr,(0,p.A)({},Mwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}_wr.isMDXComponent=!0;const wwr={toc:[]},Twr="wrapper";function Cwr(e){let{components:n,...t}=e;return(0,s.yg)(Twr,(0,p.A)({},wwr,t,{components:n,mdxType:"MDXLayout"}))}Cwr.isMDXComponent=!0;const xwr={toc:[]},Awr="wrapper";function vwr(e){let{components:n,...t}=e;return(0,s.yg)(Awr,(0,p.A)({},xwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}vwr.isMDXComponent=!0;const Lwr={toc:[]},bwr="wrapper";function Nwr(e){let{components:n,...t}=e;return(0,s.yg)(bwr,(0,p.A)({},Lwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}Nwr.isMDXComponent=!0;const kwr={toc:[]},zwr="wrapper";function Pwr(e){let{components:n,...t}=e;return(0,s.yg)(zwr,(0,p.A)({},kwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Pwr.isMDXComponent=!0;const Iwr={toc:[]},Rwr="wrapper";function Wwr(e){let{components:n,...t}=e;return(0,s.yg)(Rwr,(0,p.A)({},Iwr,t,{components:n,mdxType:"MDXLayout"}))}Wwr.isMDXComponent=!0;const Swr={toc:[]},Bwr="wrapper";function Gwr(e){let{components:n,...t}=e;return(0,s.yg)(Bwr,(0,p.A)({},Swr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Gwr.isMDXComponent=!0;const Ewr={toc:[]},Owr="wrapper";function Uwr(e){let{components:n,...t}=e;return(0,s.yg)(Owr,(0,p.A)({},Ewr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Uwr.isMDXComponent=!0;const Fwr={toc:[]},Vwr="wrapper";function qwr(e){let{components:n,...t}=e;return(0,s.yg)(Vwr,(0,p.A)({},Fwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qwr.isMDXComponent=!0;const jwr={toc:[]},Hwr="wrapper";function Ywr(e){let{components:n,...t}=e;return(0,s.yg)(Hwr,(0,p.A)({},jwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Ywr.isMDXComponent=!0;const Qwr={toc:[]},$wr="wrapper";function Kwr(e){let{components:n,...t}=e;return(0,s.yg)($wr,(0,p.A)({},Qwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Kwr.isMDXComponent=!0;const Jwr={toc:[]},Zwr="wrapper";function eTr(e){let{components:n,...t}=e;return(0,s.yg)(Zwr,(0,p.A)({},Jwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}eTr.isMDXComponent=!0;const nTr={toc:[]},tTr="wrapper";function oTr(e){let{components:n,...t}=e;return(0,s.yg)(tTr,(0,p.A)({},nTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}oTr.isMDXComponent=!0;const pTr={toc:[]},rTr="wrapper";function sTr(e){let{components:n,...t}=e;return(0,s.yg)(rTr,(0,p.A)({},pTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}sTr.isMDXComponent=!0;const cTr={toc:[]},aTr="wrapper";function iTr(e){let{components:n,...t}=e;return(0,s.yg)(aTr,(0,p.A)({},cTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}iTr.isMDXComponent=!0;const lTr={toc:[]},uTr="wrapper";function mTr(e){let{components:n,...t}=e;return(0,s.yg)(uTr,(0,p.A)({},lTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}mTr.isMDXComponent=!0;const yTr={toc:[]},dTr="wrapper";function hTr(e){let{components:n,...t}=e;return(0,s.yg)(dTr,(0,p.A)({},yTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hTr.isMDXComponent=!0;const gTr={toc:[]},fTr="wrapper";function DTr(e){let{components:n,...t}=e;return(0,s.yg)(fTr,(0,p.A)({},gTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}DTr.isMDXComponent=!0;const MTr={toc:[]},XTr="wrapper";function _Tr(e){let{components:n,...t}=e;return(0,s.yg)(XTr,(0,p.A)({},MTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}_Tr.isMDXComponent=!0;const wTr={toc:[]},TTr="wrapper";function CTr(e){let{components:n,...t}=e;return(0,s.yg)(TTr,(0,p.A)({},wTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given t value."))}CTr.isMDXComponent=!0;const xTr={toc:[]},ATr="wrapper";function vTr(e){let{components:n,...t}=e;return(0,s.yg)(ATr,(0,p.A)({},xTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}vTr.isMDXComponent=!0;const LTr={toc:[]},bTr="wrapper";function NTr(e){let{components:n,...t}=e;return(0,s.yg)(bTr,(0,p.A)({},LTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}NTr.isMDXComponent=!0;const kTr={toc:[]},zTr="wrapper";function PTr(e){let{components:n,...t}=e;return(0,s.yg)(zTr,(0,p.A)({},kTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}PTr.isMDXComponent=!0;const ITr={toc:[]},RTr="wrapper";function WTr(e){let{components:n,...t}=e;return(0,s.yg)(RTr,(0,p.A)({},ITr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.yg)("p",null,"Source code liberally taken from:\n",(0,s.yg)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}WTr.isMDXComponent=!0;const STr={toc:[]},BTr="wrapper";function GTr(e){let{components:n,...t}=e;return(0,s.yg)(BTr,(0,p.A)({},STr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}GTr.isMDXComponent=!0;const ETr={toc:[]},OTr="wrapper";function UTr(e){let{components:n,...t}=e;return(0,s.yg)(OTr,(0,p.A)({},ETr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}UTr.isMDXComponent=!0;const FTr={toc:[]},VTr="wrapper";function qTr(e){let{components:n,...t}=e;return(0,s.yg)(VTr,(0,p.A)({},FTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}qTr.isMDXComponent=!0;const jTr={toc:[]},HTr="wrapper";function YTr(e){let{components:n,...t}=e;return(0,s.yg)(HTr,(0,p.A)({},jTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}YTr.isMDXComponent=!0;const QTr={toc:[]},$Tr="wrapper";function KTr(e){let{components:n,...t}=e;return(0,s.yg)($Tr,(0,p.A)({},QTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}KTr.isMDXComponent=!0;const JTr={toc:[]},ZTr="wrapper";function eCr(e){let{components:n,...t}=e;return(0,s.yg)(ZTr,(0,p.A)({},JTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}eCr.isMDXComponent=!0;const nCr={toc:[]},tCr="wrapper";function oCr(e){let{components:n,...t}=e;return(0,s.yg)(tCr,(0,p.A)({},nCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}oCr.isMDXComponent=!0;const pCr={toc:[]},rCr="wrapper";function sCr(e){let{components:n,...t}=e;return(0,s.yg)(rCr,(0,p.A)({},pCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}sCr.isMDXComponent=!0;const cCr={toc:[]},aCr="wrapper";function iCr(e){let{components:n,...t}=e;return(0,s.yg)(aCr,(0,p.A)({},cCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}iCr.isMDXComponent=!0;const lCr={toc:[]},uCr="wrapper";function mCr(e){let{components:n,...t}=e;return(0,s.yg)(uCr,(0,p.A)({},lCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The cubic coefficient"))}mCr.isMDXComponent=!0;const yCr={toc:[]},dCr="wrapper";function hCr(e){let{components:n,...t}=e;return(0,s.yg)(dCr,(0,p.A)({},yCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The degree of the polynomial"))}hCr.isMDXComponent=!0;const gCr={toc:[]},fCr="wrapper";function DCr(e){let{components:n,...t}=e;return(0,s.yg)(fCr,(0,p.A)({},gCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the nth derivative of the polynomial."))}DCr.isMDXComponent=!0;const MCr={toc:[]},XCr="wrapper";function _Cr(e){let{components:n,...t}=e;return(0,s.yg)(XCr,(0,p.A)({},MCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of times to differentiate the polynomial."))}_Cr.isMDXComponent=!0;const wCr={toc:[]},TCr="wrapper";function CCr(e){let{components:n,...t}=e;return(0,s.yg)(TCr,(0,p.A)({},wCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given value t."))}CCr.isMDXComponent=!0;const xCr={toc:[]},ACr="wrapper";function vCr(e){let{components:n,...t}=e;return(0,s.yg)(ACr,(0,p.A)({},xCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to sample at"))}vCr.isMDXComponent=!0;const LCr={toc:[]},bCr="wrapper";function NCr(e){let{components:n,...t}=e;return(0,s.yg)(bCr,(0,p.A)({},LCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}NCr.isMDXComponent=!0;const kCr={toc:[]},zCr="wrapper";function PCr(e){let{components:n,...t}=e;return(0,s.yg)(zCr,(0,p.A)({},kCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to sample at"))}PCr.isMDXComponent=!0;const ICr={toc:[]},RCr="wrapper";function WCr(e){let{components:n,...t}=e;return(0,s.yg)(RCr,(0,p.A)({},ICr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The derivative of the polynomial to sample from"))}WCr.isMDXComponent=!0;const SCr={toc:[]},BCr="wrapper";function GCr(e){let{components:n,...t}=e;return(0,s.yg)(BCr,(0,p.A)({},SCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the local extrema of the polynomial."))}GCr.isMDXComponent=!0;const ECr={toc:[]},OCr="wrapper";function UCr(e){let{components:n,...t}=e;return(0,s.yg)(OCr,(0,p.A)({},ECr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}UCr.isMDXComponent=!0;const FCr={toc:[]},VCr="wrapper";function qCr(e){let{components:n,...t}=e;return(0,s.yg)(VCr,(0,p.A)({},FCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the output value range within the unit interval."))}qCr.isMDXComponent=!0;const jCr={toc:[]},HCr="wrapper";function YCr(e){let{components:n,...t}=e;return(0,s.yg)(HCr,(0,p.A)({},jCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}YCr.isMDXComponent=!0;const QCr={toc:[]},$Cr="wrapper";function KCr(e){let{components:n,...t}=e;return(0,s.yg)($Cr,(0,p.A)({},QCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the roots (values where this polynomial = 0)."))}KCr.isMDXComponent=!0;const JCr={toc:[]},ZCr="wrapper";function exr(e){let{components:n,...t}=e;return(0,s.yg)(ZCr,(0,p.A)({},JCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}exr.isMDXComponent=!0;const nxr={toc:[]},txr="wrapper";function oxr(e){let{components:n,...t}=e;return(0,s.yg)(txr,(0,p.A)({},nxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The point at which to split the polynomial."))}oxr.isMDXComponent=!0;const pxr={toc:[]},rxr="wrapper";function sxr(e){let{components:n,...t}=e;return(0,s.yg)(rxr,(0,p.A)({},pxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a constant polynomial"))}sxr.isMDXComponent=!0;const cxr={toc:[]},axr="wrapper";function ixr(e){let{components:n,...t}=e;return(0,s.yg)(axr,(0,p.A)({},cxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}ixr.isMDXComponent=!0;const lxr={toc:[]},uxr="wrapper";function mxr(e){let{components:n,...t}=e;return(0,s.yg)(uxr,(0,p.A)({},lxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a cubic polynomial"))}mxr.isMDXComponent=!0;const yxr={toc:[]},dxr="wrapper";function hxr(e){let{components:n,...t}=e;return(0,s.yg)(dxr,(0,p.A)({},yxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}hxr.isMDXComponent=!0;const gxr={toc:[]},fxr="wrapper";function Dxr(e){let{components:n,...t}=e;return(0,s.yg)(fxr,(0,p.A)({},gxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}Dxr.isMDXComponent=!0;const Mxr={toc:[]},Xxr="wrapper";function _xr(e){let{components:n,...t}=e;return(0,s.yg)(Xxr,(0,p.A)({},Mxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}_xr.isMDXComponent=!0;const wxr={toc:[]},Txr="wrapper";function Cxr(e){let{components:n,...t}=e;return(0,s.yg)(Txr,(0,p.A)({},wxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The cubic coefficient"))}Cxr.isMDXComponent=!0;const xxr={toc:[]},Axr="wrapper";function vxr(e){let{components:n,...t}=e;return(0,s.yg)(Axr,(0,p.A)({},xxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a linear polynomial"))}vxr.isMDXComponent=!0;const Lxr={toc:[]},bxr="wrapper";function Nxr(e){let{components:n,...t}=e;return(0,s.yg)(bxr,(0,p.A)({},Lxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Nxr.isMDXComponent=!0;const kxr={toc:[]},zxr="wrapper";function Pxr(e){let{components:n,...t}=e;return(0,s.yg)(zxr,(0,p.A)({},kxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}Pxr.isMDXComponent=!0;const Ixr={toc:[]},Rxr="wrapper";function Wxr(e){let{components:n,...t}=e;return(0,s.yg)(Rxr,(0,p.A)({},Ixr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a quadratic polynomial"))}Wxr.isMDXComponent=!0;const Sxr={toc:[]},Bxr="wrapper";function Gxr(e){let{components:n,...t}=e;return(0,s.yg)(Bxr,(0,p.A)({},Sxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Gxr.isMDXComponent=!0;const Exr={toc:[]},Oxr="wrapper";function Uxr(e){let{components:n,...t}=e;return(0,s.yg)(Oxr,(0,p.A)({},Exr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}Uxr.isMDXComponent=!0;const Fxr={toc:[]},Vxr="wrapper";function qxr(e){let{components:n,...t}=e;return(0,s.yg)(Vxr,(0,p.A)({},Fxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}qxr.isMDXComponent=!0;const jxr={toc:[]},Hxr="wrapper";function Yxr(e){let{components:n,...t}=e;return(0,s.yg)(Hxr,(0,p.A)({},jxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}Yxr.isMDXComponent=!0;const Qxr={toc:[]},$xr="wrapper";function Kxr(e){let{components:n,...t}=e;return(0,s.yg)($xr,(0,p.A)({},Qxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}Kxr.isMDXComponent=!0;const Jxr={toc:[]},Zxr="wrapper";function eAr(e){let{components:n,...t}=e;return(0,s.yg)(Zxr,(0,p.A)({},Jxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given t value."))}eAr.isMDXComponent=!0;const nAr={toc:[]},tAr="wrapper";function oAr(e){let{components:n,...t}=e;return(0,s.yg)(tAr,(0,p.A)({},nAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}oAr.isMDXComponent=!0;const pAr={toc:[]},rAr="wrapper";function sAr(e){let{components:n,...t}=e;return(0,s.yg)(rAr,(0,p.A)({},pAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}sAr.isMDXComponent=!0;const cAr={toc:[]},aAr="wrapper";function iAr(e){let{components:n,...t}=e;return(0,s.yg)(aAr,(0,p.A)({},cAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}iAr.isMDXComponent=!0;const lAr={toc:[]},uAr="wrapper";function mAr(e){let{components:n,...t}=e;return(0,s.yg)(uAr,(0,p.A)({},lAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.yg)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}mAr.isMDXComponent=!0;const yAr={toc:[]},dAr="wrapper";function hAr(e){let{components:n,...t}=e;return(0,s.yg)(dAr,(0,p.A)({},yAr,t,{components:n,mdxType:"MDXLayout"}))}hAr.isMDXComponent=!0;const gAr={toc:[]},fAr="wrapper";function DAr(e){let{components:n,...t}=e;return(0,s.yg)(fAr,(0,p.A)({},gAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}DAr.isMDXComponent=!0;const MAr={toc:[]},XAr="wrapper";function _Ar(e){let{components:n,...t}=e;return(0,s.yg)(XAr,(0,p.A)({},MAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots defining the spline"))}_Ar.isMDXComponent=!0;const wAr={toc:[]},TAr="wrapper";function CAr(e){let{components:n,...t}=e;return(0,s.yg)(TAr,(0,p.A)({},wAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the spline should be closed or not"))}CAr.isMDXComponent=!0;const xAr={toc:[]},AAr="wrapper";function vAr(e){let{components:n,...t}=e;return(0,s.yg)(AAr,(0,p.A)({},xAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}vAr.isMDXComponent=!0;const LAr={toc:[]},bAr="wrapper";function NAr(e){let{components:n,...t}=e;return(0,s.yg)(bAr,(0,p.A)({},LAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}NAr.isMDXComponent=!0;const kAr={toc:[]},zAr="wrapper";function PAr(e){let{components:n,...t}=e;return(0,s.yg)(zAr,(0,p.A)({},kAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}PAr.isMDXComponent=!0;const IAr={toc:[]},RAr="wrapper";function WAr(e){let{components:n,...t}=e;return(0,s.yg)(RAr,(0,p.A)({},IAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}WAr.isMDXComponent=!0;const SAr={toc:[]},BAr="wrapper";function GAr(e){let{components:n,...t}=e;return(0,s.yg)(BAr,(0,p.A)({},SAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}GAr.isMDXComponent=!0;const EAr={toc:[]},OAr="wrapper";function UAr(e){let{components:n,...t}=e;return(0,s.yg)(OAr,(0,p.A)({},EAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}UAr.isMDXComponent=!0;const FAr={toc:[]},VAr="wrapper";function qAr(e){let{components:n,...t}=e;return(0,s.yg)(VAr,(0,p.A)({},FAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}qAr.isMDXComponent=!0;const jAr={toc:[]},HAr="wrapper";function YAr(e){let{components:n,...t}=e;return(0,s.yg)(HAr,(0,p.A)({},jAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}YAr.isMDXComponent=!0;const QAr={toc:[]},$Ar="wrapper";function KAr(e){let{components:n,...t}=e;return(0,s.yg)($Ar,(0,p.A)({},QAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}KAr.isMDXComponent=!0;const JAr={toc:[]},ZAr="wrapper";function evr(e){let{components:n,...t}=e;return(0,s.yg)(ZAr,(0,p.A)({},JAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}evr.isMDXComponent=!0;const nvr={toc:[]},tvr="wrapper";function ovr(e){let{components:n,...t}=e;return(0,s.yg)(tvr,(0,p.A)({},nvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}ovr.isMDXComponent=!0;const pvr={toc:[]},rvr="wrapper";function svr(e){let{components:n,...t}=e;return(0,s.yg)(rvr,(0,p.A)({},pvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}svr.isMDXComponent=!0;const cvr={toc:[]},avr="wrapper";function ivr(e){let{components:n,...t}=e;return(0,s.yg)(avr,(0,p.A)({},cvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}ivr.isMDXComponent=!0;const lvr={toc:[]},uvr="wrapper";function mvr(e){let{components:n,...t}=e;return(0,s.yg)(uvr,(0,p.A)({},lvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.yg)("p",null,"By default, any property is cloneable."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}mvr.isMDXComponent=!0;const yvr={toc:[]},dvr="wrapper";function hvr(e){let{components:n,...t}=e;return(0,s.yg)(dvr,(0,p.A)({},yvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}hvr.isMDXComponent=!0;const gvr={toc:[]},fvr="wrapper";function Dvr(e){let{components:n,...t}=e;return(0,s.yg)(fvr,(0,p.A)({},gvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a cloneable property decorator."))}Dvr.isMDXComponent=!0;const Mvr={toc:[]},Xvr="wrapper";function _vr(e){let{components:n,...t}=e;return(0,s.yg)(Xvr,(0,p.A)({},Mvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the property should be cloneable."))}_vr.isMDXComponent=!0;const wvr={toc:[]},Tvr="wrapper";function Cvr(e){let{components:n,...t}=e;return(0,s.yg)(Tvr,(0,p.A)({},wvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}Cvr.isMDXComponent=!0;const xvr={toc:[]},Avr="wrapper";function vvr(e){let{components:n,...t}=e;return(0,s.yg)(Avr,(0,p.A)({},xvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}vvr.isMDXComponent=!0;const Lvr={toc:[]},bvr="wrapper";function Nvr(e){let{components:n,...t}=e;return(0,s.yg)(bvr,(0,p.A)({},Lvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a compound property decorator."))}Nvr.isMDXComponent=!0;const kvr={toc:[]},zvr="wrapper";function Pvr(e){let{components:n,...t}=e;return(0,s.yg)(zvr,(0,p.A)({},kvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}Pvr.isMDXComponent=!0;const Ivr={toc:[]},Rvr="wrapper";function Wvr(e){let{components:n,...t}=e;return(0,s.yg)(Rvr,(0,p.A)({},Ivr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.yg)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}Wvr.isMDXComponent=!0;const Svr={toc:[]},Bvr="wrapper";function Gvr(e){let{components:n,...t}=e;return(0,s.yg)(Bvr,(0,p.A)({},Svr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a computed method decorator."))}Gvr.isMDXComponent=!0;const Evr={toc:[]},Ovr="wrapper";function Uvr(e){let{components:n,...t}=e;return(0,s.yg)(Ovr,(0,p.A)({},Evr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the initial value of a property."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Uvr.isMDXComponent=!0;const Fvr={toc:[]},Vvr="wrapper";function qvr(e){let{components:n,...t}=e;return(0,s.yg)(Vvr,(0,p.A)({},Fvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}qvr.isMDXComponent=!0;const jvr={toc:[]},Hvr="wrapper";function Yvr(e){let{components:n,...t}=e;return(0,s.yg)(Hvr,(0,p.A)({},jvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an initial signal value decorator."))}Yvr.isMDXComponent=!0;const Qvr={toc:[]},$vr="wrapper";function Kvr(e){let{components:n,...t}=e;return(0,s.yg)($vr,(0,p.A)({},Qvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of the property."))}Kvr.isMDXComponent=!0;const Jvr={toc:[]},Zvr="wrapper";function eLr(e){let{components:n,...t}=e;return(0,s.yg)(Zvr,(0,p.A)({},Jvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.yg)("p",null,"By default, any property is inspectable."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}eLr.isMDXComponent=!0;const nLr={toc:[]},tLr="wrapper";function oLr(e){let{components:n,...t}=e;return(0,s.yg)(tLr,(0,p.A)({},nLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}oLr.isMDXComponent=!0;const pLr={toc:[]},rLr="wrapper";function sLr(e){let{components:n,...t}=e;return(0,s.yg)(rLr,(0,p.A)({},pLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an inspectable property decorator."))}sLr.isMDXComponent=!0;const cLr={toc:[]},aLr="wrapper";function iLr(e){let{components:n,...t}=e;return(0,s.yg)(aLr,(0,p.A)({},cLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the property should be inspectable."))}iLr.isMDXComponent=!0;const lLr={toc:[]},uLr="wrapper";function mLr(e){let{components:n,...t}=e;return(0,s.yg)(uLr,(0,p.A)({},lLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}mLr.isMDXComponent=!0;const yLr={toc:[]},dLr="wrapper";function hLr(e){let{components:n,...t}=e;return(0,s.yg)(dLr,(0,p.A)({},yLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}hLr.isMDXComponent=!0;const gLr={toc:[]},fLr="wrapper";function DLr(e){let{components:n,...t}=e;return(0,s.yg)(fLr,(0,p.A)({},gLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal interpolation function decorator."))}DLr.isMDXComponent=!0;const MLr={toc:[]},XLr="wrapper";function _Lr(e){let{components:n,...t}=e;return(0,s.yg)(XLr,(0,p.A)({},MLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interpolation function for the property."))}_Lr.isMDXComponent=!0;const wLr={toc:[]},TLr="wrapper";function CLr(e){let{components:n,...t}=e;return(0,s.yg)(TLr,(0,p.A)({},wLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.yg)("p",null,"If the wrapper class has a method called ",(0,s.yg)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}CLr.isMDXComponent=!0;const xLr={toc:[]},ALr="wrapper";function vLr(e){let{components:n,...t}=e;return(0,s.yg)(ALr,(0,p.A)({},xLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}vLr.isMDXComponent=!0;const LLr={toc:[]},bLr="wrapper";function NLr(e){let{components:n,...t}=e;return(0,s.yg)(bLr,(0,p.A)({},LLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal parser decorator."))}NLr.isMDXComponent=!0;const kLr={toc:[]},zLr="wrapper";function PLr(e){let{components:n,...t}=e;return(0,s.yg)(zLr,(0,p.A)({},kLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The wrapper class for the property."))}PLr.isMDXComponent=!0;const ILr={toc:[]},RLr="wrapper";function WLr(e){let{components:n,...t}=e;return(0,s.yg)(RLr,(0,p.A)({},ILr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns the given property into a signal."),(0,s.yg)("p",null,"The class using this decorator can implement the following methods:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}WLr.isMDXComponent=!0;const SLr={toc:[]},BLr="wrapper";function GLr(e){let{components:n,...t}=e;return(0,s.yg)(BLr,(0,p.A)({},SLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}GLr.isMDXComponent=!0;const ELr={toc:[]},OLr="wrapper";function ULr(e){let{components:n,...t}=e;return(0,s.yg)(OLr,(0,p.A)({},ELr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal decorator."))}ULr.isMDXComponent=!0;const FLr={toc:[]},VLr="wrapper";function qLr(e){let{components:n,...t}=e;return(0,s.yg)(VLr,(0,p.A)({},FLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut decorator for setting both the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.yg)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.yg)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.yg)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.yg)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}qLr.isMDXComponent=!0;const jLr={toc:[]},HLr="wrapper";function YLr(e){let{components:n,...t}=e;return(0,s.yg)(HLr,(0,p.A)({},jLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}YLr.isMDXComponent=!0;const QLr={toc:[]},$Lr="wrapper";function KLr(e){let{components:n,...t}=e;return(0,s.yg)($Lr,(0,p.A)({},QLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal wrapper decorator."))}KLr.isMDXComponent=!0;const JLr={toc:[]},ZLr="wrapper";function ebr(e){let{components:n,...t}=e;return(0,s.yg)(ZLr,(0,p.A)({},JLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The wrapper class for the property."))}ebr.isMDXComponent=!0;const nbr={toc:[]},tbr="wrapper";function obr(e){let{components:n,...t}=e;return(0,s.yg)(tbr,(0,p.A)({},nbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A unified abstraction for all CSS filters."))}obr.isMDXComponent=!0;const pbr={toc:[]},rbr="wrapper";function sbr(e){let{components:n,...t}=e;return(0,s.yg)(rbr,(0,p.A)({},pbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the desired length is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}sbr.isMDXComponent=!0;const cbr={toc:[]},abr="wrapper";function ibr(e){let{components:n,...t}=e;return(0,s.yg)(abr,(0,p.A)({},cbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a desired length used internally by layout Nodes."))}ibr.isMDXComponent=!0;const lbr={toc:[]},ubr="wrapper";function mbr(e){let{components:n,...t}=e;return(0,s.yg)(ubr,(0,p.A)({},lbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value can be either:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'"))))}mbr.isMDXComponent=!0;const ybr={toc:[]},dbr="wrapper";function hbr(e){let{components:n,...t}=e;return(0,s.yg)(dbr,(0,p.A)({},ybr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a length used by most layout properties."))}hbr.isMDXComponent=!0;const gbr={toc:[]},fbr="wrapper";function Dbr(e){let{components:n,...t}=e;return(0,s.yg)(fbr,(0,p.A)({},gbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a length limit used by layout properties such as ",(0,s.yg)("inlineCode",{parentName:"p"},"max-width"),"."))}Dbr.isMDXComponent=!0;const Mbr={toc:[]},Xbr="wrapper";function _br(e){let{components:n,...t}=e;return(0,s.yg)(Xbr,(0,p.A)({},Mbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.yg)("inlineCode",{parentName:"a"},"blur"))," filter."))}_br.isMDXComponent=!0;const wbr={toc:[]},Tbr="wrapper";function Cbr(e){let{components:n,...t}=e;return(0,s.yg)(Tbr,(0,p.A)({},wbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter in pixels."))}Cbr.isMDXComponent=!0;const xbr={toc:[]},Abr="wrapper";function vbr(e){let{components:n,...t}=e;return(0,s.yg)(Abr,(0,p.A)({},xbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.yg)("inlineCode",{parentName:"a"},"brightness"))," filter."))}vbr.isMDXComponent=!0;const Lbr={toc:[]},bbr="wrapper";function Nbr(e){let{components:n,...t}=e;return(0,s.yg)(bbr,(0,p.A)({},Lbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}Nbr.isMDXComponent=!0;const kbr={toc:[]},zbr="wrapper";function Pbr(e){let{components:n,...t}=e;return(0,s.yg)(zbr,(0,p.A)({},kbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.yg)("inlineCode",{parentName:"a"},"contrast"))," filter."))}Pbr.isMDXComponent=!0;const Ibr={toc:[]},Rbr="wrapper";function Wbr(e){let{components:n,...t}=e;return(0,s.yg)(Rbr,(0,p.A)({},Ibr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}Wbr.isMDXComponent=!0;const Sbr={toc:[]},Bbr="wrapper";function Gbr(e){let{components:n,...t}=e;return(0,s.yg)(Bbr,(0,p.A)({},Sbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.yg)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}Gbr.isMDXComponent=!0;const Ebr={toc:[]},Obr="wrapper";function Ubr(e){let{components:n,...t}=e;return(0,s.yg)(Obr,(0,p.A)({},Ebr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}Ubr.isMDXComponent=!0;const Fbr={toc:[]},Vbr="wrapper";function qbr(e){let{components:n,...t}=e;return(0,s.yg)(Vbr,(0,p.A)({},Fbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.yg)("inlineCode",{parentName:"a"},"hue"))," filter."))}qbr.isMDXComponent=!0;const jbr={toc:[]},Hbr="wrapper";function Ybr(e){let{components:n,...t}=e;return(0,s.yg)(Hbr,(0,p.A)({},jbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter in degrees."))}Ybr.isMDXComponent=!0;const Qbr={toc:[]},$br="wrapper";function Kbr(e){let{components:n,...t}=e;return(0,s.yg)($br,(0,p.A)({},Qbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.yg)("inlineCode",{parentName:"a"},"invert"))," filter."))}Kbr.isMDXComponent=!0;const Jbr={toc:[]},Zbr="wrapper";function eNr(e){let{components:n,...t}=e;return(0,s.yg)(Zbr,(0,p.A)({},Jbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}eNr.isMDXComponent=!0;const nNr={toc:[]},tNr="wrapper";function oNr(e){let{components:n,...t}=e;return(0,s.yg)(tNr,(0,p.A)({},nNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.yg)("inlineCode",{parentName:"a"},"saturate"))," filter."))}oNr.isMDXComponent=!0;const pNr={toc:[]},rNr="wrapper";function sNr(e){let{components:n,...t}=e;return(0,s.yg)(rNr,(0,p.A)({},pNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}sNr.isMDXComponent=!0;const cNr={toc:[]},aNr="wrapper";function iNr(e){let{components:n,...t}=e;return(0,s.yg)(aNr,(0,p.A)({},cNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.yg)("inlineCode",{parentName:"a"},"sepia"))," filter."))}iNr.isMDXComponent=!0;const lNr={toc:[]},uNr="wrapper";function mNr(e){let{components:n,...t}=e;return(0,s.yg)(uNr,(0,p.A)({},lNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}mNr.isMDXComponent=!0;const yNr={toc:[]},dNr="wrapper";function hNr(e){let{components:n,...t}=e;return(0,s.yg)(dNr,(0,p.A)({},yNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}hNr.isMDXComponent=!0;const gNr={toc:[]},fNr="wrapper";function DNr(e){let{components:n,...t}=e;return(0,s.yg)(fNr,(0,p.A)({},gNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback in the context of this scene."))}DNr.isMDXComponent=!0;const MNr={toc:[]},XNr="wrapper";function _Nr(e){let{components:n,...t}=e;return(0,s.yg)(XNr,(0,p.A)({},MNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}_Nr.isMDXComponent=!0;const wNr={toc:[]},TNr="wrapper";function CNr(e){let{components:n,...t}=e;return(0,s.yg)(TNr,(0,p.A)({},wNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the view."),(0,s.yg)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.yg)("p",null,"Can modify the state of the view."))}CNr.isMDXComponent=!0;const xNr={toc:[]},ANr="wrapper";function vNr(e){let{components:n,...t}=e;return(0,s.yg)(ANr,(0,p.A)({},xNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a predicate that checks if the given object is an instance of the\ngiven class."))}vNr.isMDXComponent=!0;const LNr={toc:[]},bNr="wrapper";function NNr(e){let{components:n,...t}=e;return(0,s.yg)(bNr,(0,p.A)({},LNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class to check against."))}function kNr(e){let{id:n}=e;const t=o[n]??r.Fragment;return r.createElement(t,null)}NNr.isMDXComponent=!0},5063:(e,n,t)=>{t.d(n,{A:()=>i});var o=t(6476),p=t(5396),r=t(7576),s=t(53),c=t(4041);const a={toggle:"toggle_S_IX",collapsed:"collapsed_wdUB",collapse:"collapse_TjTN",inverse:"inverse_g6vW",clearFix:"clearFix_HQ1T"};function i(e){let{comment:n,full:t=!0}=e;const o=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@remarks"===n}))),[n]);return c.createElement(c.Fragment,null,t&&c.createElement(l,{comment:n}),c.createElement(p.A,{id:n?.summaryId}),c.createElement(p.A,{id:o?.contentId}),t&&c.createElement(u,{comment:n}))}function l(e){let{comment:n}=e;return(0,c.useMemo)((()=>n?.modifierTags?.includes("@experimental")),[n])?c.createElement(r.A,null):null}function u(e){let{comment:n}=e;const[t,r]=(0,c.useState)(!0),i=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@preview"===n}))),[n]),l=(0,c.useMemo)((()=>n?.blockTags?.filter((e=>{let{tag:n}=e;return"@example"===n}))??[]),[n]),u=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@defaultValue"===n}))),[n]),m=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@deprecated"===n}))),[n]),y=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@see"===n}))),[n]);return c.createElement(c.Fragment,null,c.createElement(p.A,{id:i?.contentId}),l.length>0&&c.createElement(c.Fragment,null,c.createElement("h4",null,c.createElement("a",{className:(0,s.A)(a.toggle,t&&a.collapsed),onClick:e=>{e.preventDefault(),r(!t)},href:"#"},"Examples")),c.createElement(o.N,{lazy:!0,as:"div",collapsed:t},c.createElement("div",{className:a.collapse},l.map((e=>c.createElement(p.A,{key:e.contentId,id:e.contentId})))),c.createElement("div",{className:a.clearFix})),c.createElement("div",{className:(0,s.A)(a.clearFix,a.inverse)})),u&&c.createElement(c.Fragment,null,"Default Value:"," ",c.createElement("code",null,u.content.map((e=>e.text)).join(""))),m&&c.createElement(c.Fragment,null,c.createElement("h4",null,"Deprecated"),c.createElement(p.A,{id:m.contentId})),y&&c.createElement(c.Fragment,null,c.createElement("h4",null,"See also"),c.createElement(p.A,{id:y.contentId})))}},1125:(e,n,t)=>{t.d(n,{A:()=>Be});var o=t(1282),p=t(4905),r=t(9575),s=t(4041);function c(e){let{width:n=24,height:t=24,...o}=e;return s.createElement("svg",(0,r.A)({width:n,height:t,"aria-hidden":"true",viewBox:"0 0 24 24"},o),s.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=t(4593),l=t(53);function u(e){let{children:n,highlight:t,onClick:r,link:u}=e;const m=(0,p.f)(),y=(0,i.o0)();return s.createElement("div",{className:(0,l.A)(o.A.codeBlockContent,a.codeBlock,t&&a.highlight,r&&a.pointer)},s.createElement("pre",{onClick:r,onKeyDown:e=>{"Enter"===e.key&&r?.()},tabIndex:0,ref:m.codeBlockRef,className:(0,l.A)(o.A.codeBlock,"thin-scrollbar")},s.createElement("code",{className:o.A.codeBlockLines,style:y},n)),u&&s.createElement("div",{className:o.A.buttonGroup},s.createElement("button",{title:"Go to source",className:"clean-btn",onClick:e=>{e.preventDefault(),window.open(u,"_blank")}},s.createElement(c,{width:18,height:18}))))}var m=t(6333);function y(e){let{children:n}=e;return s.createElement(m.A,{as:"div",className:(0,l.A)(a.codeBlockContainer,"language-typescript")},n)}function d(e){let{children:n}=e;const t=(0,s.useRef)();return(0,s.useLayoutEffect)((()=>{if(!t.current)return;const e=t.current.closest("pre");if(e.scrollWidth>e.clientWidth){const n=Array.from(t.current.querySelectorAll(`.${a.elements}`)).sort(((e,n)=>function(e,n){return e>n?1:e<n?-1:0}(n.innerText.length,e.innerText.length)));for(;e.scrollWidth>e.clientWidth&&n.length>0;)n.shift().classList.add(a.wrap)}})),s.createElement(s.Fragment,null,n&&s.createElement("span",{ref:t,className:(0,l.A)(a.line,"token-line")},n),s.createElement("br",null))}var h=t(5063),g=t(9659);function f(e){let{width:n=24,height:t=24,...o}=e;return s.createElement("svg",(0,r.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0},o),s.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}var D=t(6382);const M={header:"header_nSmr",filters:"filters_z1iC",icon:"icon_ROIU"};function X(){const e=(0,s.useRef)(null),[n,t]=(0,s.useState)(!1),[o,p]=(0,D.R7)();return(0,s.useEffect)((()=>{const n=n=>{e.current&&!e.current.contains(n.target)&&t(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[e]),s.createElement(s.Fragment,null,s.createElement("div",{ref:e,className:(0,l.A)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},s.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:e=>{e.preventDefault(),t(!n)},onKeyDown:e=>{"Enter"===e.key&&(e.preventDefault(),t(!n))}},"Filters",s.createElement(f,{className:M.icon})),s.createElement("ul",{className:"dropdown__menu"},s.createElement("li",null,s.createElement("label",{htmlFor:"private",className:(0,l.A)("dropdown__link",o.private&&"dropdown__link--active")},s.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:o.private,onChange:e=>{p({...o,private:e.target.checked})}}),"Protected members")),s.createElement("li",{onKeyDown:e=>{"Tab"===e.key&&t(!1)}},s.createElement("label",{htmlFor:"inherited",className:(0,l.A)("dropdown__link",o.inherited&&"dropdown__link--active")},s.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:o.inherited,onChange:e=>{p({...o,inherited:e.target.checked})}}),"Inherited members")))))}function _(e){let{children:n,kind:t}=e;return t===g.k.Class||t===g.k.Interface?s.createElement("div",{className:(0,l.A)("row",M.header)},s.createElement("div",{className:(0,l.A)("col",M.filters)},s.createElement(X,null)),s.createElement("div",{className:"col"},n)):s.createElement(s.Fragment,null,n)}var w=t(6090),T=t(9631);function C(e){let{children:n,type:t,to:o,id:p,tooltip:c}=e;const a=(0,i.J2)(t);return o?s.createElement(T.A,(0,r.A)({id:p,to:o,"data-tooltip":c},a),n):s.createElement("span",(0,r.A)({id:p},a),n)}let x=function(e){return e[e.None=0]="None",e[e.Angle=1]="Angle",e[e.Curly=2]="Curly",e[e.Square=3]="Square",e[e.Parentheses=4]="Parentheses",e}({}),A=function(e){return e.Comma=", ",e.Pipe=" | ",e.Ampersand=" & ",e}({});const v={[x.None]:a.none,[x.Angle]:a.angle,[x.Curly]:a.curly,[x.Square]:a.square,[x.Parentheses]:a.parentheses};function L(e){let{children:n,type:t,separator:o=A.Comma}=e;return s.createElement("span",{className:(0,l.A)(a.list,v[t??x.None])},s.createElement("span",{className:(0,l.A)(a.elements,o!==A.Comma&&a.left)},(Array.isArray(n)?n:[n]).flatMap(((e,n)=>s.createElement("span",{"data-separator":o,key:n,className:a.element},e)))))}function b(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.elementType}),"[]")}function N(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.checkType}),s.createElement(C,{type:"keyword"}," extends "),s.createElement(oe,{type:n.extendsType})," ? ",s.createElement(oe,{type:n.trueType})," : ",s.createElement(oe,{type:n.falseType}))}function k(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.objectType}),"[",s.createElement(oe,{type:n.indexType}),"]")}function z(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"infer "),s.createElement(C,{type:"constant"},n.name))}function P(e){let{type:n}=e;return s.createElement(L,{type:x.Parentheses,separator:A.Ampersand},n.types.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))}function I(e){let{type:n}=e;return s.createElement(C,{type:"keyword"},n.name)}function R(e){let{type:n}=e;const[t,o]=(0,s.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return s.createElement(C,{type:o},t)}function W(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(L,{type:x.Curly},s.createElement(s.Fragment,null,"[",s.createElement(C,{type:"class"},n.parameter),s.createElement(C,{type:"keyword"}," in "),s.createElement(oe,{type:n.parameterType}),"]: ",s.createElement(oe,{type:n.templateType}))))}function S(e){let{type:n}=e;return s.createElement(s.Fragment,null,n.name,": ",s.createElement(oe,{type:n.element}))}function B(e){let{type:n}=e;return n.asserts?s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"asserts "),s.createElement(C,null,n.name," ")):s.createElement(s.Fragment,null,s.createElement(C,null,n.name," "),s.createElement(C,{type:"keyword"},"is "),s.createElement(oe,{type:n.targetType}))}function G(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"typeof "),s.createElement(oe,{type:n.queryType}))}function E(e){let{flags:n,explicitAccessModifier:t}=e;const o=[];return n?.isAbstract&&o.push("abstract"),n?.isStatic&&o.push("static"),n?.isConst&&o.push("const"),n?.isReadonly&&o.push("readonly"),n?.isPrivate&&o.push("private"),n?.isProtected&&o.push("protected"),(n?.isPublic||t&&!n?.isProtected&&!n?.isPrivate)&&o.push("public"),s.createElement(s.Fragment,null,o.map((e=>s.createElement(C,{key:e,type:"keyword"},e," "))))}function O(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),n.varianceModifier&&s.createElement(C,{type:"keyword"},n.varianceModifier," "),s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&s.createElement(s.Fragment,null," extends ",s.createElement(oe,{type:n.type})),n.default&&s.createElement(s.Fragment,null," = ",s.createElement(oe,{type:n.default})))}var U=t(8675);const F={[g.k.Namespace]:"namespace",[g.k.Enum]:"enum",[g.k.Class]:"class",[g.k.Interface]:"interface"};function V(e){let{reflection:n}=e;const t=(0,U.as)();return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),s.createElement(C,{type:"keyword"},F[n.kind]," "),s.createElement(C,{type:"class-name"},n.name),!!n.typeParameters?.length&&s.createElement(L,{type:x.Angle},n.typeParameters.map((e=>s.createElement(O,{key:e.id,reflection:t(e)}))))," ",!!n.extendedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"extends "),s.createElement(L,null,n.extendedTypes.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))),!!n.implementedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"implements "),s.createElement(L,null,n.implementedTypes.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))))}function q(e){let{reflection:n}=e;const t="__namedParameters"===n.name?"{...}":n.name;return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),n.flags.isRest&&"...",s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},t),n.flags.isOptional&&"?",": ",n.type&&s.createElement(oe,{type:n.type}),n.defaultValue&&s.createElement(s.Fragment,null," = ",s.createElement(C,{type:"plain"},n.defaultValue)))}function j(e){let{reflection:n,flags:t}=e;const o=(0,U.as)(),p="__type"===n.name;return s.createElement(s.Fragment,null,s.createElement(E,{flags:t??n.flags,explicitAccessModifier:!p}),n.kind===g.k.GetSignature&&s.createElement(C,{type:"keyword"},"get "),n.kind===g.k.SetSignature&&s.createElement(C,{type:"keyword"},"set "),n.overwrites&&s.createElement(s.Fragment,null,s.createElement(C,{to:n.overwrites.externalUrl??(0,U.ID)(o(n.overwrites.id)),type:"keyword"},"override")," "),n.kind===g.k.ConstructorSignature?s.createElement(s.Fragment,null,s.createElement(C,{to:"#",type:"keyword"},"new")," ",s.createElement(C,{type:"plain"},n.type.name)):p?"":s.createElement(C,{type:"function"},n.name),!!n.typeParameter?.length&&s.createElement(L,{type:x.Angle},n.typeParameter.map((e=>s.createElement(O,{key:e.id,reflection:o(e)})))),n.parameters?.length?s.createElement(L,{type:x.Parentheses},n.parameters.map((e=>s.createElement(q,{key:e,reflection:o(e)})))):"()",n.type&&s.createElement(s.Fragment,null,p?" => ":": ",s.createElement(oe,{type:n.type})))}function H(e){let{reflection:n}=e;const t=n.signatures?.[0]??n.getSignature??n.setSignature??n.indexSignature;return s.createElement(j,{reflection:t})}function Y(e){let{reflection:n}=e;return s.createElement(q,{reflection:n})}function Q(e){let{reflection:n}=e;const t=(0,U.as)();return s.createElement(s.Fragment,null,s.createElement(E,{flags:n.flags}),s.createElement(C,{type:"keyword"},"type "),s.createElement(C,{type:"class-name"},n.name),n.typeParameters&&s.createElement(L,{type:x.Angle},n.typeParameters.map((e=>s.createElement(O,{key:e.id,reflection:t(e)}))))," = ",s.createElement(oe,{type:n.type}))}function $(e){let{reflection:n}=e;const t=(0,U.as)();if(n.signatures){let e=n.signatures[0];if(e?.kind||(e=t(e)),e)return s.createElement(j,{reflection:e})}return n.children?s.createElement(L,{type:x.Curly},n.children.map((e=>s.createElement(K,{key:e.id,reflection:t(e)})))):s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"unknown"))}function K(e){let{reflection:n}=e;const t=(0,s.useMemo)((()=>{switch(n.kind){case g.k.Project:case g.k.Module:case g.k.EnumMember:case g.k.Variable:case g.k.Function:break;case g.k.Namespace:case g.k.Enum:case g.k.Class:case g.k.Interface:return V;case g.k.Constructor:return j;case g.k.Property:return Y;case g.k.Method:return H;case g.k.CallSignature:case g.k.IndexSignature:case g.k.ConstructorSignature:case g.k.Parameter:break;case g.k.TypeLiteral:return $;case g.k.TypeParameter:return O;case g.k.Accessor:case g.k.GetSignature:case g.k.SetSignature:case g.k.ObjectLiteral:break;case g.k.TypeAlias:return Q;case g.k.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return s.createElement(t,{reflection:n})}function J(e){let{type:n}=e;const t=(0,U.as)();return s.createElement(K,{reflection:t(n.declaration)})}function Z(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"string"},"`",n.head),n.tail.map(((e,n)=>{let[t,o]=e;return s.createElement(s.Fragment,null,"${",s.createElement(oe,{key:n,type:t}),"}",s.createElement(C,{type:"string"},o))})),s.createElement(C,{type:"string"},"`"))}function ee(e){let{type:n}=e;return n.elements?s.createElement(L,{type:x.Square},n.elements.map(((e,n)=>s.createElement(oe,{key:n,type:e})))):s.createElement(s.Fragment,null,"[]")}function ne(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},n.operator," "),s.createElement(oe,{type:n.target}))}function te(e){let{type:n}=e;return s.createElement(L,{type:x.Parentheses,separator:A.Pipe},n.types.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))}function oe(e){const n=(0,s.useMemo)((()=>{switch(e.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return ne;case"conditional":return N;case"reflection":return J;case"query":return G;case"named-tuple-member":return S;case"union":return te;case"intrinsic":return I;case"literal":return R;case"reference":return pe;case"predicate":return B;case"tuple":return ee;case"array":return b;case"intersection":return P;case"inferred":return z;case"mapped":return W;case"template-literal":return Z;case"indexedAccess":return k}throw new Error(`Missing component for type: ${e.type.type}`)}),[e.type]);return s.createElement(n,e)}function pe(e){let{type:n}=e;const t=(0,U.gG)(n.project),o=t?.[n.id],p=n.externalUrl??(0,U.ID)(o);return s.createElement(s.Fragment,null,s.createElement(C,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!!n.typeArguments?.length&&s.createElement(L,{type:x.Angle},n.typeArguments.map(((e,n)=>s.createElement(oe,{key:n,type:e})))))}function re(e){let{group:n}=e;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?s.createElement(Be,{reflection:n.nested[0]}):s.createElement(s.Fragment,null,n.external.length>0&&s.createElement("ul",null,n.external.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e})))))),n.nested.length>0&&n.nested.map(((e,n)=>s.createElement(s.Fragment,{key:e.id},n>0&&s.createElement("hr",null),s.createElement(Be,{reflection:e})))))}var se=t(4441),ce=t(2663);const ae={tabItem:"tabItem_OMyP"};function ie(e){let{children:n,hidden:t,className:o}=e;return s.createElement("div",{role:"tabpanel",className:(0,ce.A)(ae.tabItem,o),hidden:t},n)}var le=t(1034),ue=t(6703),me=t(6004),ye=t(2096);function de(e){return function(e){return s.Children.map(e,(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:o,default:p}}=e;return{value:n,label:t,attributes:o,default:p}}))}function he(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??de(t);return function(e){const n=(0,me.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function ge(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function fe(e){let{queryString:n=!1,groupId:t}=e;const o=(0,w.W6)(),p=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,ue.aZ)(p),(0,s.useCallback)((e=>{if(!p)return;const n=new URLSearchParams(o.location.search);n.set(p,e),o.replace({...o.location,search:n.toString()})}),[p,o])]}function De(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,p=he(e),[r,c]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!ge({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=t.find((e=>e.default))??t[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:p}))),[a,i]=fe({queryString:t,groupId:o}),[l,u]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[o,p]=(0,ye.Dv)(t);return[o,(0,s.useCallback)((e=>{t&&p.set(e)}),[t,p])]}({groupId:o}),m=(()=>{const e=a??l;return ge({value:e,tabValues:p})?e:null})();(0,s.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!ge({value:e,tabValues:p}))throw new Error(`Can't select invalid tab value=${e}`);c(e),i(e),u(e)}),[i,u,p]),tabValues:p}}var Me=t(213);const Xe={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};function _e(e){let{className:n,block:t,selectedValue:o,selectValue:p,tabValues:c}=e;const a=[],{blockElementScrollPositionUntilNextRender:i}=(0,le.a_)(),l=e=>{const n=e.currentTarget,t=a.indexOf(n),r=c[t].value;r!==o&&(i(n),p(r))},u=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;n=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;n=a[t]??a[a.length-1];break}}n?.focus()};return s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,ce.A)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:p}=e;return s.createElement("li",(0,r.A)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:e=>a.push(e),onKeyDown:u,onClick:l},p,{className:(0,ce.A)("tabs__item",Xe.tabItem,p?.className,{"tabs__item--active":o===n})}),t??n)})))}function we(e){let{lazy:n,children:t,selectedValue:o}=e;const p=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=p.find((e=>e.props.value===o));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return s.createElement("div",{className:"margin-top--md"},p.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==o}))))}function Te(e){const n=De(e);return s.createElement("div",{className:(0,ce.A)("tabs-container",Xe.tabList)},s.createElement(_e,(0,r.A)({},e,n)),s.createElement(we,(0,r.A)({},e,n)))}function Ce(e){const n=(0,Me.A)();return s.createElement(Te,(0,r.A)({key:String(n)},e))}function xe(e){let{group:n,project:t}=e;const o=(0,w.zy)(),p=(0,U.gG)(t),r=o.hash.split("-")[0].slice(1),[c]=(0,D.R7)(),a=(0,s.useMemo)((()=>(n.categories??[n]).map((e=>function(e,n,t){const o=[],p=[],r=[];for(const s of e.children){const e=n[s];e&&(0,D.XN)(t,e)&&(r.push(e.anchor),e.hasOwnPage?o.push(e):p.push(e))}if(o.length>0||p.length>0)return{title:e.title,external:o,nested:p,anchors:r}}(e,p,c))).filter((e=>!!e))),[n,p,c]);return(0,s.useEffect)((()=>{if(1===a.length)return;const e=o.hash.split("-")[0].slice(1);for(const n of a)if(n.anchors.includes(e))return}),[o.hash,a]),0===a.length?s.createElement(s.Fragment,null):s.createElement(s.Fragment,null,s.createElement(se.A,{as:"h2",id:n.title},n.title),a.length>1?s.createElement(Ce,{groupId:n.title},a.map((e=>s.createElement(ie,{default:e.anchors.includes(r),value:e.title,label:e.title,className:"margin-top--lg"},s.createElement(re,{group:e}))))):s.createElement(re,{group:a[0]}))}var Ae=t(5396);function ve(e){let{parameters:n}=e;const t=(0,U.as)(),o=(0,s.useMemo)((()=>n?.map(t)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Parameters"),s.createElement("ul",null,o.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(q,{reflection:e})),s.createElement(Ae.A,{id:e.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function Le(e){let{parameters:n}=e;const t=(0,U.as)(),o=(0,s.useMemo)((()=>n?.map(t)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Type Parameters"),s.createElement("ul",null,o.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(O,{reflection:e})),s.createElement(Ae.A,{id:e.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function be(e){let{signatures:n,flags:t,source:o}=e;const p=(0,U.as)(),r=(0,s.useMemo)((()=>n.map(p)),[n]),[c,a]=(0,s.useState)(r[0]);return s.createElement(s.Fragment,null,s.createElement(y,null,r.map((e=>s.createElement(u,{link:o?.url,key:e.id,highlight:n.length>1&&e.id===c.id,onClick:n.length>1?()=>a(e):void 0},s.createElement(d,null,s.createElement(j,{reflection:e,flags:t})))))),s.createElement(h.A,{comment:c.comment}),s.createElement(Le,{parameters:c.typeParameter}),s.createElement(ve,{parameters:c.parameters}))}function Ne(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(K,{reflection:n})))),s.createElement(_,{kind:n.kind},s.createElement(h.A,{comment:n.comment})),s.createElement(Le,{parameters:n.typeParameters}),n.implementedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Implemented by"),s.createElement("ul",null,n.implementedBy.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e}))))))),n.extendedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Extended by"),s.createElement("ul",null,n.extendedBy.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e}))))))),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(be,{signatures:n.signatures})),n.groups?.map((e=>s.createElement(xe,{group:e,key:e.title,project:n.project}))))}function ke(e){let{reflection:n,headless:t}=e;const o=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((e=>!!e));return s.createElement(s.Fragment,null,!t&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(be,{signatures:o,flags:n.flags,source:n.sources?.[0]}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pe,{type:n.inheritedFrom}))),n.overwrites&&s.createElement("small",null,"Overwrites"," ",s.createElement("code",null,s.createElement(pe,{type:n.overwrites}))))}var ze=t(154);function Pe(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(ze.A,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),s.createElement(_,{kind:n.kind},s.createElement(h.A,{comment:n.comment})),n.groups?.map((e=>s.createElement(xe,{group:e,key:e.title,project:n.project}))))}const Ie={cardContainer:"cardContainer_ybwo",cardTitle:"cardTitle_Ehd1",cardDescription:"cardDescription_b6wr"};function Re(e){let{reflection:n}=e;const t=(0,U.gG)(n.project),o=n.groups[0].children.map((e=>t[e])).filter((e=>!!e));return s.createElement("article",{className:"margin-top--lg"},s.createElement("section",{className:(0,l.A)("row")},o.map((e=>s.createElement("article",{key:e.id,className:"col col--6 margin-bottom--lg"},s.createElement(T.A,{href:e.href,className:(0,l.A)("card padding--lg",Ie.cardContainer)},s.createElement("h2",{className:(0,l.A)("text--truncate",Ie.cardTitle)},s.createElement("code",null,e.name)),s.createElement("div",{className:(0,l.A)("text--truncate",Ie.cardDescription)},e.comment?.summaryText??"\xa0")))))))}function We(e){let{reflection:n,headless:t}=e;return s.createElement(s.Fragment,null,!t&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(Y,{reflection:n})))),s.createElement(h.A,{comment:n.comment}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pe,{type:n.inheritedFrom}))))}function Se(e){let{reflection:n}=e;const t=(0,U.gG)(n.project);return s.createElement(s.Fragment,null,s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name)),s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(K,{reflection:n})))),s.createElement(h.A,{comment:n.comment}),s.createElement(Le,{parameters:n.typeParameters}),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(be,{signatures:n.signatures})),n.groups?.map((e=>s.createElement(s.Fragment,{key:e.title},s.createElement("h2",null,e.title),e.children.map((e=>t[e])).filter((e=>e&&(e.flags.isPublic||!e.flags.isProtected&&!e.flags.isPrivate))).map((e=>s.createElement(Be,{key:e.id,reflection:e})))))))}function Be(e){let{reflection:n,headless:t=!1}=e;const o=(0,s.useMemo)((()=>{switch(n.kind){case g.k.Project:return Re;case g.k.Module:return Pe;case g.k.Namespace:case g.k.Enum:case g.k.Class:case g.k.Interface:return Ne;case g.k.Function:case g.k.Accessor:case g.k.Constructor:case g.k.Method:return ke;case g.k.Variable:case g.k.Property:case g.k.EnumMember:return We;case g.k.CallSignature:case g.k.IndexSignature:case g.k.ConstructorSignature:case g.k.Parameter:case g.k.TypeLiteral:case g.k.TypeParameter:case g.k.GetSignature:case g.k.SetSignature:case g.k.ObjectLiteral:break;case g.k.TypeAlias:return Se;case g.k.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return s.createElement(o,{reflection:n,headless:t})}},9659:(e,n,t)=>{t.d(n,{k:()=>o});let o=function(e){return e[e.Project=1]="Project",e[e.Module=2]="Module",e[e.Namespace=4]="Namespace",e[e.Enum=8]="Enum",e[e.EnumMember=16]="EnumMember",e[e.Variable=32]="Variable",e[e.Function=64]="Function",e[e.Class=128]="Class",e[e.Interface=256]="Interface",e[e.Constructor=512]="Constructor",e[e.Property=1024]="Property",e[e.Method=2048]="Method",e[e.CallSignature=4096]="CallSignature",e[e.IndexSignature=8192]="IndexSignature",e[e.ConstructorSignature=16384]="ConstructorSignature",e[e.Parameter=32768]="Parameter",e[e.TypeLiteral=65536]="TypeLiteral",e[e.TypeParameter=131072]="TypeParameter",e[e.Accessor=262144]="Accessor",e[e.GetSignature=524288]="GetSignature",e[e.SetSignature=1048576]="SetSignature",e[e.ObjectLiteral=2097152]="ObjectLiteral",e[e.TypeAlias=4194304]="TypeAlias",e[e.Reference=8388608]="Reference",e}({})},7576:(e,n,t)=>{t.d(n,{A:()=>s});var o=t(9631),p=t(9996),r=t(4041);function s(){return r.createElement(p.A,{type:"experimental"},"This is an ",r.createElement(o.A,{to:"/experimental"},"experimental feature"),". The behavior and API may change drastically between minor releases.")}},8675:(e,n,t)=>{t.d(n,{Fx:()=>a,ID:()=>i,Kv:()=>r,as:()=>c,gG:()=>s});var o=t(4041);const p=o.createContext({lookup:{},urlLookup:{}});function r(e){let{children:n,lookup:t,urlLookup:r}=e;return o.createElement(p.Provider,{value:{lookup:t,urlLookup:r}},n)}function s(e){const{lookup:n}=(0,o.useContext)(p);return n[e]}function c(){const{lookup:e}=(0,o.useContext)(p);return n=>{if("number"==typeof n?.project)return e[n.project][n.id]}}function a(){const{urlLookup:e,lookup:n}=(0,o.useContext)(p);return t=>{const o=e[t];return o?n[o.projectId]?.[o.id]??null:null}}function i(e){if(e)return e.href}},4593:(e,n,t)=>{t.d(n,{J2:()=>c,d5:()=>s,o0:()=>a});var o=t(8408),p=t(4041);const r=p.createContext(null);function s(e){let{children:n}=e;const t=(0,o.A)(),s=(0,p.useMemo)((()=>function(e,n){const{plain:t}=e,o=Object.create(null),p=e.styles.reduce(((e,t)=>{const{languages:o,style:p}=t;return o&&!o.includes(n)||t.types.forEach((n=>{e[n]={...e[n],...p}})),e}),o);return p.root=t,p.plain={...t,backgroundColor:null},p}(t,"typescript")),[t]);return p.createElement(r.Provider,{value:s},n)}function c(e){void 0===e&&(e="plain");const n=(0,p.useContext)(r);return{className:`token ${e}`,style:n[e]??n.plain}}function a(e){void 0===e&&(e="plain");const n=(0,p.useContext)(r);return n[e]??n.plain}},6382:(e,n,t)=>{t.d(n,{B4:()=>l,R7:()=>u,XN:()=>m});var o=t(9531),p=t(213),r=t(4041);const s="api-filters",c=o.A.canUseDOM?localStorage.getItem(s):null,a=c?JSON.parse(c):{inherited:!0,private:!1},i=r.createContext([a,()=>{}]);function l(e){let{children:n}=e;const[t,o]=(0,r.useState)(a),c=(0,p.A)();return r.createElement(i.Provider,{value:[t,e=>{c&&localStorage.setItem(s,JSON.stringify(e)),o(e)}]},n)}function u(){return(0,r.useContext)(i)}function m(e,n){const t=n.flags?.isPrivate||n.flags?.isProtected;if(!e.private&&t)return!1;const o=!!n.inheritedFrom;return!(!e.inherited&&o)}},9996:(e,n,t)=>{t.d(n,{A:()=>m});var o=t(9575),p=t(4041);function r(e){let{width:n=24,height:t=24,...r}=e;return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0,fill:"currentColor"},r),p.createElement("path",{d:"M19.8,18.4L14,10.67V6.5l1.35-1.69C15.61,4.48,15.38,4,14.96,4H9.04C8.62,4,8.39,4.48,8.65,4.81L10,6.5v4.17L4.2,18.4 C3.71,19.06,4.18,20,5,20h14C19.82,20,20.29,19.06,19.8,18.4z"}))}function s(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function c(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function i(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}var l=t(8621);const u={icon:"icon_Fw4I"};function m(e){let{title:n,type:t,...m}=e;const y=(0,p.useMemo)((()=>{switch(t){case"tip":return a;case"caution":return i;case"danger":return s;case"experimental":return r;default:return c}}),[t]);return"experimental"===t&&(n??="Experimental",t="caution"),p.createElement(p.Fragment,null,p.createElement(l.A,(0,o.A)({icon:p.createElement(y,{className:u.icon}),title:n,type:t},m)))}},1635:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>y,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var o=t(9575),p=(t(4041),t(2247)),r=t(9987);const s={sidebar_position:2,slug:"/flow"},c="Animation flow",a={unversionedId:"motion-canvas/flow",id:"motion-canvas/flow",title:"Animation flow",description:"_Note: These docs were adopted from the original",source:"@site/docs/motion-canvas/flow.mdx",sourceDirName:"motion-canvas",slug:"/flow",permalink:"/flow",draft:!1,editUrl:"https://github.com/havenhq/revideo/blob/main/packages/docs/docs/motion-canvas/flow.mdx",tags:[],version:"current",lastUpdatedBy:"Justus Mattern",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"/flow"},sidebar:"docs",previous:{title:"Motion Canvas Guide",permalink:"/category/motion-canvas-guide"},next:{title:"Scene hierarchy",permalink:"/hierarchy"}},i={},l=[{value:"Flow Generators",id:"flow-generators",level:2},{value:"<code>all</code>",id:"all",level:3},{value:"<code>any</code>",id:"any",level:3},{value:"<code>chain</code>",id:"chain",level:3},{value:"<code>delay</code>",id:"delay",level:3},{value:"<code>sequence</code>",id:"sequence",level:3},{value:"<code>loop</code>",id:"loop",level:3},{value:"Looping",id:"looping",level:2},{value:"Using <code>Array.map</code> and <code>all</code>",id:"using-arraymap-and-all",level:3},{value:"Using a <code>for</code> loop and <code>all</code>",id:"using-a-for-loop-and-all",level:3},{value:"Using a <code>for</code> loop",id:"using-a-for-loop",level:3}],u={toc:l},m="wrapper";function y(e){let{components:n,...t}=e;return(0,p.yg)(m,(0,o.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,p.yg)("h1",{id:"animation-flow"},"Animation flow"),(0,p.yg)("p",null,(0,p.yg)("em",{parentName:"p"},"Note: These docs were adopted from the original\n",(0,p.yg)("a",{parentName:"em",href:"https://motioncanvas.io/docs/"},"Motion Canvas")," docs")),(0,p.yg)("p",null,"Motion Canvas uses generator functions to describe animations."),(0,p.yg)("p",null,"A generator function is a function that can return multiple values:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-ts"},"function* example() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst generator = example();\n\nconsole.log(generator.next().value); // 1;\nconsole.log(generator.next().value); // 2;\nconsole.log(generator.next().value); // 3;\n")),(0,p.yg)("p",null,"When the ",(0,p.yg)("inlineCode",{parentName:"p"},"yield")," keyword is encountered, the execution of the function pauses,\nand resumes only when the caller requests another value. This is particularly\nuseful when declaring animations - usually we want to change the things on the\nscreen in incremental steps to create an illusion of movement. We also want to\nwait a constant amount of time between these updates so that our eyes can\nregister what's happening. With generators, we can update things in-between the\n",(0,p.yg)("inlineCode",{parentName:"p"},"yield")," keywords, and then wait for a bit whenever the function yields."),(0,p.yg)("p",null,"This is the fundamental idea of Motion Canvas. ",(0,p.yg)("inlineCode",{parentName:"p"},"yield"),' means: "The current frame\nis ready, display it on the screen and come back to me later."'),(0,p.yg)("p",null,"With that in mind, we can make a circle flicker on the screen using the\nfollowing code:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  circle().fill('red');\n  yield;\n  circle().fill('blue');\n  yield;\n  circle().fill('red');\n  yield;\n});\n")),(0,p.yg)("p",null,"Needless to say, it would be extremely cumbersome if we had to write all\nanimations like that. Fortunately, JavaScript has another keyword for use within\ngenerators - ",(0,p.yg)("inlineCode",{parentName:"p"},"yield*"),". It allows us to delegate the yielding to another\ngenerator."),(0,p.yg)("p",null,"For instance, we could extract the flickering code from the above example to a\nseparate generator and delegate our scene function to it:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"import {ThreadGenerator} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  yield* flicker(circle());\n});\n\nfunction* flicker(circle: Circle): ThreadGenerator {\n  circle.fill('red');\n  yield;\n  circle.fill('blue');\n  yield;\n  circle.fill('red');\n  yield;\n}\n")),(0,p.yg)("p",null,"The resulting animation is exactly the same, but now we have a reusable function\nthat we can use whenever we need some flickering."),(0,p.yg)("p",null,"Motion Canvas provides a lot of useful generators like this. You may remember\nthis snippet:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-ts"},"yield * myCircle().fill('#e6a700', 1);\n")),(0,p.yg)("p",null,"It animates the fill color of the circle from its current value to ",(0,p.yg)("inlineCode",{parentName:"p"},"#e6a700"),"\nover a span of one second. As you may guess, the result of calling\n",(0,p.yg)("inlineCode",{parentName:"p"},"fill('#e6a700', 1)")," is another generator to which we can redirect our scene\nfunction. Generators like this are called tweens, because they animate\nbe",(0,p.yg)("strong",{parentName:"p"},"tween")," two values. You can read more about them in the\n",(0,p.yg)("a",{parentName:"p",href:"/tweening"},"tweening")," section."),(0,p.yg)("h2",{id:"flow-generators"},"Flow Generators"),(0,p.yg)("p",null,"Another kind of generators are ",(0,p.yg)("em",{parentName:"p"},"flow generators"),". They take one or more\ngenerators as their input and combine them together. We've mentioned the ",(0,p.yg)("inlineCode",{parentName:"p"},"all()"),"\ngenerator in the quickstart section, there's a few more:"),(0,p.yg)("h3",{id:"all"},(0,p.yg)("inlineCode",{parentName:"h3"},"all")),(0,p.yg)(r.A,{url:"/api/core/flow#all",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"any"},(0,p.yg)("inlineCode",{parentName:"h3"},"any")),(0,p.yg)(r.A,{url:"/api/core/flow#any",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"chain"},(0,p.yg)("inlineCode",{parentName:"h3"},"chain")),(0,p.yg)(r.A,{url:"/api/core/flow#chain",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"delay"},(0,p.yg)("inlineCode",{parentName:"h3"},"delay")),(0,p.yg)(r.A,{url:"/api/core/flow#delay",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"sequence"},(0,p.yg)("inlineCode",{parentName:"h3"},"sequence")),(0,p.yg)(r.A,{url:"/api/core/flow#sequence",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"loop"},(0,p.yg)("inlineCode",{parentName:"h3"},"loop")),(0,p.yg)(r.A,{url:"/api/core/flow#loop",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h2",{id:"looping"},"Looping"),(0,p.yg)("p",null,"There are many ways to animate multiple objects. Here are some examples. Try\nusing them in the below editor."),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor ratio=2",editor:!0,ratio:"2"},"import {makeScene2D, Rect} from '@revideo/2d';\nimport {all, waitFor, makeRef, range} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const rects: Rect[] = [];\n\n  // Create some rects\n  view.add(\n    range(5).map(i => (\n      <Rect\n        ref={makeRef(rects, i)}\n        width={100}\n        height={100}\n        x={-250 + 125 * i}\n        fill=\"#88C0D0\"\n        radius={10}\n      />\n    )),\n  );\n\n  yield* waitFor(1);\n\n  // Animate them\n  yield* all(\n    ...rects.map(rect => rect.position.y(100, 1).to(-100, 2).to(0, 1)),\n  );\n});\n")),(0,p.yg)("h3",{id:"using-arraymap-and-all"},"Using ",(0,p.yg)("inlineCode",{parentName:"h3"},"Array.map")," and ",(0,p.yg)("inlineCode",{parentName:"h3"},"all")),(0,p.yg)("p",null,"This is one of the most elegant ways to do simple tweens, but requires nesting\n",(0,p.yg)("inlineCode",{parentName:"p"},"all")," to do multiple tweens on an object since the ",(0,p.yg)("inlineCode",{parentName:"p"},"map")," callback must return a\n",(0,p.yg)("inlineCode",{parentName:"p"},"ThreadGenerator"),"."),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"yield *\n  all(\n    ...rects.map(rect =>\n      // No yield or anything; we return this generator and deal with it outside\n      rect.position.y(100, 1).to(-100, 2).to(0, 1),\n    ),\n  );\n")),(0,p.yg)("h3",{id:"using-a-for-loop-and-all"},"Using a ",(0,p.yg)("inlineCode",{parentName:"h3"},"for")," loop and ",(0,p.yg)("inlineCode",{parentName:"h3"},"all")),(0,p.yg)("p",null,"This is similar to above, but uses a ",(0,p.yg)("inlineCode",{parentName:"p"},"for")," loop and an array of generators."),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"const generators = [];\nfor (const rect of rects) {\n  // No yield here, just store the generators.\n  generators.push(rect.position.y(100, 1).to(-100, 2).to(0, 1));\n}\n\n// Run all of the generators.\nyield * all(...generators);\n")),(0,p.yg)("h3",{id:"using-a-for-loop"},"Using a ",(0,p.yg)("inlineCode",{parentName:"h3"},"for")," loop"),(0,p.yg)("p",null,"This is a bit of a cumbersome option because you have to figure out how long it\nwould take for the generator in the loop to complete, but is useful in some\nsituations."),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"for (const rect of rects) {\n  // Note the absence of a * after this yield\n  yield rect.position.y(100, 1).to(-100, 2).to(0, 1);\n}\n\n// Wait for the duration of the above generators\nyield * waitFor(4);\n")))}y.isMDXComponent=!0}}]);